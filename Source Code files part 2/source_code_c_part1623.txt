        (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) lphCall,
            (ULONG_PTR) 0,
            (ULONG_PTR) dwCountryCode,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) GetACP()            // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            lpszW,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer = 0;


    LOG((TL_TRACE, "Entering lineMakeCallA"));
    LOG((TL_INFO, "  hLine= 0x%08lx", hLine));

    if (!lpszDestAddress)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[3] = Dword;
        funcArgs.Args[3]     = (ULONG_PTR) TAPI_NO_DATA;
    }
    else if (IsBadStringPtrA (lpszDestAddress, (DWORD) -1))
    {
       LOG((TL_ERROR, "lineMakeCall: Bad lpszDestAddress pointer"));
       return LINEERR_INVALPOINTER;
    }
    else  if (!(funcArgs.Args[3] = (ULONG_PTR)  NotSoWideStringToWideString(
                    lpszDestAddress,
                    (DWORD) -1
                    )))
    {
       return LINEERR_OPERATIONFAILED; // really either NOMEM. INVALPOINTER
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphCall, NULL);
        if (0 == hPointer)
        {
            lResult = LINEERR_NOMEM;
            goto _return;
        }
        funcArgs.Args[2] = (ULONG_PTR)hPointer;
    }

    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[5] = Dword;
        funcArgs.Args[5]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    lResult = DOFUNC (&funcArgs, "lineMakeCall");
    if (hPointer && 0 > lResult)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

_return:
    if (funcArgs.Args[3] != (ULONG_PTR) TAPI_NO_DATA)
    {
       ClientFree ((LPVOID) funcArgs.Args[3]);
    }

    return lResult;
}


LONG
WINAPI
lineMakeCall(
    HLINE   hLine,
    LPHCALL lphCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode,
    LPLINECALLPARAMS const lpCallParams
    )
{
    return lineMakeCallA(
                hLine,
                lphCall,
                lpszDestAddress,
                dwCountryCode,
                lpCallParams
                );
}


LONG
WINAPI
lineMonitorDigits(
    HCALL   hCall,
    DWORD   dwDigitModes
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lMonitorDigits),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwDigitModes
        },

        {
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineMonitorDigits"));
}


LONG
WINAPI
lineMonitorMedia(
    HCALL   hCall,
    DWORD   dwMediaModes
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lMonitorMedia),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwMediaModes
        },

        {
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineMonitorMedia"));
}


LONG
WINAPI
lineMonitorTones(
    HCALL   hCall,
    LPLINEMONITORTONE   const lpToneList,
    DWORD   dwNumEntries
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lMonitorTones),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpToneList,
            (ULONG_PTR) dwNumEntries * sizeof(LINEMONITORTONE),
            (ULONG_PTR) 0                   // dwToneListID, remotesp only
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size,
            Dword
        }
    };


    if (!lpToneList)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = (ULONG_PTR) TAPI_NO_DATA;
        funcArgs.ArgTypes[2] = Dword;
    }

    return (DOFUNC (&funcArgs, "lineMonitorTones"));
}


LONG
WINAPI
lineNegotiateAPIVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPLINEEXTENSIONID   lpExtensionID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 7, lNegotiateAPIVersion),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAPILowVersion,
            (ULONG_PTR) dwAPIHighVersion,
            (ULONG_PTR) lpdwAPIVersion,
            (ULONG_PTR) lpExtensionID,
            (ULONG_PTR) sizeof(LINEEXTENSIONID)
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            lpDword,
            lpGet_SizeToFollow,
            Size
        }
    };

    if (dwAPIHighVersion > TAPI_CURRENT_VERSION)
    {
        funcArgs.Args[3] = TAPI_CURRENT_VERSION;
    }

    if ((LPVOID) lpdwAPIVersion == (LPVOID) lpExtensionID)
    {
        return LINEERR_INVALPOINTER;
    }

    return (DOFUNC (&funcArgs, "lineNegotiateAPIVersion"));
}


LONG
WINAPI
lineNegotiateExtVersion(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    DWORD       dwExtLowVersion,
    DWORD       dwExtHighVersion,
    LPDWORD     lpdwExtVersion
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, lNegotiateExtVersion),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) dwExtLowVersion,
            (ULONG_PTR) dwExtHighVersion,
            (ULONG_PTR) lpdwExtVersion
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            Dword,
            lpDword
        }
    };


    if (dwAPIVersion > TAPI_CURRENT_VERSION)
    {
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    return (DOFUNC (&funcArgs, "lineNegotiateExtVersion"));
}


LONG
WINAPI
lineOpenW(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    LPHLINE                 lphLine,
    DWORD                   dwAPIVersion,
    DWORD                   dwExtVersion,
    DWORD_PTR               dwCallbackInstance,
    DWORD                   dwPrivileges,
    DWORD                   dwMediaModes,
    LPLINECALLPARAMS const  lpCallParams
    )
{
    LONG lResult;
    DWORD hCallbackInstance = 0;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 12, lOpen),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) lphLine,
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) dwExtVersion,
            (ULONG_PTR) dwCallbackInstance,
            (ULONG_PTR) dwPrivileges,
            (ULONG_PTR) dwMediaModes,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) TAPI_NO_DATA,       // dwAsciiCallParamsCodePage
            (ULONG_PTR) 0,
            (ULONG_PTR) 0                   // LINEOPEN_PARAMS.hRemoteLine
        },

        {
            hXxxApp,
            Dword,
            lpDword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword,
            Dword,
            Dword
        }
    };


    if (dwAPIVersion > TAPI_CURRENT_VERSION)
    {
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    if (dwDeviceID != LINEMAPPER &&
        !(dwPrivileges &
            (LINEOPENOPTION_PROXY|LINEOPENOPTION_SINGLEADDRESS)))
    {
        //
        // Reset Arg & ArgType so no inval ptr err,
        // & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[8] = Dword;
        funcArgs.Args[8]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (0 != dwCallbackInstance)
    {
        hCallbackInstance = NewObject (ghHandleTable, (PVOID)dwCallbackInstance, (PVOID)UIntToPtr(hLineApp));
        if (0 == hCallbackInstance)
        {
            return LINEERR_NOMEM;
        }

        funcArgs.Args[5] = hCallbackInstance;
    }

    lResult = (DOFUNC (&funcArgs, "lineOpen"));


    //
    // If we we managed a successful LINEMAPPER & there's an LCR hook
    // for this function then call it to allow it to override our
    // results if it wants to. (One good thing about calling it after
    // the fact is that we leverage our param checking.)
    //

    if (dwDeviceID == LINEMAPPER  &&
        lResult == 0  &&
        IsLeastCostRoutingEnabled()  &&
        pfnLineOpenWLCR)
    {
        lResult = (*pfnLineOpenWLCR)(
            hLineApp,
            dwDeviceID,
            lphLine,
            dwAPIVersion,
            dwExtVersion,
            dwCallbackInstance,
            dwPrivileges,
            dwMediaModes,
            lpCallParams
            );
    }

#if DBG

    if ( !IsBadWritePtr( (LPBYTE)lphLine, 4 ) )
    {
        LOG((TL_TRACE,
            "Returning from lineOpenW, *lphLine = 0x%08lx",
            *lphLine
            ));
    }

    LOG((TL_TRACE, "Returning from lineOpenW, retcode = 0x%08lx", lResult));

#endif

    if (lResult && 0 != hCallbackInstance)
    {
        DereferenceObject (ghHandleTable, hCallbackInstance, 1);
    }

    return( lResult );
}


LONG
WINAPI
lineOpenA(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    LPHLINE                 lphLine,
    DWORD                   dwAPIVersion,
    DWORD                   dwExtVersion,
    DWORD_PTR               dwCallbackInstance,
    DWORD                   dwPrivileges,
    DWORD                   dwMediaModes,
    LPLINECALLPARAMS const  lpCallParams
    )
{
    LONG lResult;
    DWORD hCallbackInstance = 0;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 12, lOpen),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) lphLine,
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) dwExtVersion,
            (ULONG_PTR) dwCallbackInstance,
            (ULONG_PTR) dwPrivileges,
            (ULONG_PTR) dwMediaModes,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) GetACP(),           // dwAsciiCallParamsCodePage
            (ULONG_PTR) 0,
            (ULONG_PTR) 0                   // LINEOPEN_PARAMS.hRemoteLine
        },

        {
            hXxxApp,
            Dword,
            lpDword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword,
            Dword,
            Dword
        }
    };


    if (dwAPIVersion > TAPI_CURRENT_VERSION)
    {
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    if (dwDeviceID != LINEMAPPER &&
        !(dwPrivileges & (LINEOPENOPTION_PROXY|LINEOPENOPTION_SINGLEADDRESS)))
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[8] = Dword;
        funcArgs.Args[8]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (0 != dwCallbackInstance)
    {
        hCallbackInstance = NewObject (ghHandleTable, (PVOID)dwCallbackInstance, (PVOID)UIntToPtr(hLineApp));
        if (0 == hCallbackInstance)
        {
            return LINEERR_NOMEM;
        }

        funcArgs.Args[5] = hCallbackInstance;
    }

    lResult = (DOFUNC (&funcArgs, "lineOpen"));

    //
    // If we we managed a successful LINEMAPPER & there's an LCR hook
    // for this function then call it to allow it to override our
    // results if it wants to. (One good thing about calling it after
    // the fact is that we leverage our param checking.)
    //

    if (dwDeviceID == LINEMAPPER  &&
        lResult == 0  &&
        IsLeastCostRoutingEnabled()  &&
        pfnLineOpenALCR)
    {
        lResult = (*pfnLineOpenALCR)(
            hLineApp,
            dwDeviceID,
            lphLine,
            dwAPIVersion,
            dwExtVersion,
            dwCallbackInstance,
            dwPrivileges,
            dwMediaModes,
            lpCallParams
            );
    }

#if DBG

    if ( !IsBadWritePtr( (LPBYTE)lphLine, 4 ) )
    {
        LOG((TL_TRACE,
            "Returning from lineOpenA, *lphLine = 0x%08lx",
            *lphLine
            ));
    }

    LOG((TL_TRACE, "Returning from lineOpenA, retcode = 0x%08lx", lResult));

#endif

    if (lResult && 0 != hCallbackInstance)
    {
        DereferenceObject (ghHandleTable, hCallbackInstance, 1);
    }

    return( lResult );
}


LONG
WINAPI
lineOpen(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    LPHLINE                 lphLine,
    DWORD                   dwAPIVersion,
    DWORD                   dwExtVersion,
    DWORD_PTR               dwCallbackInstance,
    DWORD                   dwPrivileges,
    DWORD                   dwMediaModes,
    LPLINECALLPARAMS const  lpCallParams
    )
{
    return lineOpenA(
                hLineApp,
                dwDeviceID,
                lphLine,
                dwAPIVersion,
                dwExtVersion,
                dwCallbackInstance,
                dwPrivileges,
                dwMediaModes,
                lpCallParams
                );
}


void
PASCAL
lineParkAPostProcess(
    PASYNCEVENTMSG  pMsg
    )
{
    LOG((TL_TRACE, "lineParkAPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD       dwSize = (DWORD) pMsg->Param4;
        LPVARSTRING pNonDirAddress = (LPVARSTRING) ReferenceObject (ghHandleTable, pMsg->Param3, 0);

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param3, 2);

        try
        {
            if (gbNTVDMClient)
            {
#ifndef _WIN64

                LPVARSTRING pNonDirAddressVDM = (LPVARSTRING)
                    gpfnWOWGetVDMPointer(
                        (DWORD) pNonDirAddress,
                        dwSize,
                        TRUE // fProtectedMode
                        );


                if (pNonDirAddressVDM)
                {
                    CopyMemory(
                        pNonDirAddressVDM,
                        (LPBYTE) (pMsg + 1),
                        dwSize
                        );

                    if (pNonDirAddressVDM->dwUsedSize >= sizeof (VARSTRING)  &&
                        pNonDirAddressVDM->dwStringSize != 0)
                    {
                        TCHAR     *p;
                        DWORD     dwStringSize =
                                      pNonDirAddressVDM->dwStringSize /
                                          sizeof (WCHAR);


                        if ((p = ClientAlloc(pNonDirAddressVDM->dwStringSize)))
                        {
                            pNonDirAddressVDM->dwStringFormat =
                                STRINGFORMAT_ASCII;
                            pNonDirAddressVDM->dwStringSize =
                                dwStringSize;

                            WideCharToMultiByte(
                                GetACP(),
                                0,
                                (LPCWSTR) (((LPBYTE) pNonDirAddressVDM) +
                                    pNonDirAddressVDM->dwStringOffset),
                                dwStringSize,
                                (LPSTR) p,
                                dwStringSize,
                                NULL,
                                NULL
                                );

                            CopyMemory(
                                (((LPBYTE) pNonDirAddressVDM) +
                                    pNonDirAddressVDM->dwStringOffset),
                                p,
                                dwStringSize
                                );

                            ClientFree (p);
                        }
                    }
                }
                else
                {
                    pMsg->Param2 = LINEERR_INVALPOINTER;
                }
#endif
            }
            else
            {
                CopyMemory (pNonDirAddress, (LPBYTE) (pMsg + 1), dwSize);

                if (pNonDirAddress->dwUsedSize >= sizeof (VARSTRING)  &&
                    pNonDirAddress->dwStringSize != 0)
                {
                      TCHAR     *p;
                      DWORD     dwStringSize = pNonDirAddress->dwStringSize /
                                    sizeof (WCHAR);


                      if ((p = ClientAlloc (pNonDirAddress->dwStringSize)))
                      {
                          pNonDirAddress->dwStringFormat = STRINGFORMAT_ASCII;
                          pNonDirAddress->dwStringSize = dwStringSize;

                          WideCharToMultiByte(
                              GetACP(),
                              0,
                              (LPCWSTR) (((LPBYTE) pNonDirAddress) +
                                  pNonDirAddress->dwStringOffset),
                              dwStringSize,
                              (LPSTR) p,
                              dwStringSize,
                              NULL,
                              NULL
                              );

                          CopyMemory(
                              (((LPBYTE) pNonDirAddress) +
                                  pNonDirAddress->dwStringOffset),
                              p,
                              dwStringSize
                              );

                          ClientFree (p);
                      }
                }
            }
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}


LONG
WINAPI
lineParkW(
    HCALL       hCall,
    DWORD       dwParkMode,
    LPCWSTR     lpszDirAddress,
    LPVARSTRING lpNonDirAddress
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lPark),

        {
            (ULONG_PTR) 0,                  // post process proc
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwParkMode,
            (ULONG_PTR) TAPI_NO_DATA,       // lpszDirAddress,
            (ULONG_PTR) lpNonDirAddress,    // pass ptr as Dword for post proc
            (ULONG_PTR) TAPI_NO_DATA,       // lpNonDirAddress, pass ptr as
                                            //   lpGet_Xx for IsValPtr chk
        },

        {
            Dword,
            Dword,
            Dword,
            Dword, // lpszW,
            Dword,
            Dword, // lpGet_Struct
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (dwParkMode == LINEPARKMODE_DIRECTED)
    {
        funcArgs.ArgTypes[3] = lpszW;
        funcArgs.Args[3]     = (ULONG_PTR) lpszDirAddress;
    }
    else if (dwParkMode == LINEPARKMODE_NONDIRECTED)
    {
        if ( !lpNonDirAddress )
        {
            return LINEERR_INVALPOINTER;
        }

        //
        // Set post process proc
        //
        hPointer = NewObject (ghHandleTable, (PVOID)lpNonDirAddress, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[4] = (ULONG_PTR)hPointer;

        funcArgs.Args[0] = (ULONG_PTR)
            GetFunctionIndex(lineDevSpecificPostProcess);

        funcArgs.ArgTypes[5] = lpGet_Struct;
        funcArgs.Args[5]     = (ULONG_PTR) lpNonDirAddress;
    }

    lResult = (DOFUNC (&funcArgs, "linePark"));
    if (0 > lResult && hPointer)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineParkA(
    HCALL       hCall,
    DWORD       dwParkMode,
    LPCSTR      lpszDirAddress,
    LPVARSTRING lpNonDirAddress
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lPark),

        {
            (ULONG_PTR) 0,                  // post process proc
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwParkMode,
            (ULONG_PTR) TAPI_NO_DATA,       // lpszDirAddress,
            (ULONG_PTR) lpNonDirAddress,    // pass ptr as Dword for post proc
            (ULONG_PTR) TAPI_NO_DATA,       // lpNonDirAddress, pass ptr as
                                            //   lpGet_Xx for IsValPtr chk
        },

        {
            Dword,
            Dword,
            Dword,
            Dword, // lpszW,
            Dword,
            Dword, // lpGet_Struct
        }
    };
    LONG    lResult;
    PWSTR   szTempPtr = NULL;
    DWORD   hPointer = 0;

    switch (dwParkMode)
    {
        case LINEPARKMODE_DIRECTED:
        {
            if (IsBadStringPtrA (lpszDirAddress, (DWORD) -1))
            {
                return LINEERR_INVALPOINTER;
            }

            szTempPtr = NotSoWideStringToWideString (lpszDirAddress, (DWORD) -1);
            funcArgs.ArgTypes[3] = lpszW;
            funcArgs.Args[3]     = (ULONG_PTR) szTempPtr;

            break;
        }

        case LINEPARKMODE_NONDIRECTED:
        {
            if ( !lpNonDirAddress )
            {
                return LINEERR_INVALPOINTER;
            }

            //
            // Set post process proc
            //
            hPointer = NewObject (ghHandleTable, (PVOID)lpNonDirAddress, NULL);
            if (0 == hPointer)
            {
                return LINEERR_NOMEM;
            }
            funcArgs.Args[4] = (ULONG_PTR)hPointer;


            funcArgs.Args[0] = (ULONG_PTR)
                GetFunctionIndex(lineParkAPostProcess);
            funcArgs.ArgTypes[5] = lpGet_Struct;

            if (gbNTVDMClient == FALSE)
            {
                funcArgs.Args[5] = (ULONG_PTR) lpNonDirAddress;
            }
            else
            {
#ifndef _WIN64
                if (!gpfnWOWGetVDMPointer  ||

                    !(funcArgs.Args[5] = (ULONG_PTR) gpfnWOWGetVDMPointer(
                        (DWORD) lpNonDirAddress,
                        sizeof (VARSTRING),     // what if it's > sizeof(VARS)?
                        TRUE // fProtectedMode
                        )))
#endif
                {
                    return LINEERR_OPERATIONFAILED;
                }
            }

            break;
        }

        default:

            return LINEERR_INVALPARKMODE;
    }


    lResult = (DOFUNC (&funcArgs, "linePark"));
    if (0 > lResult && hPointer)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}


LONG
WINAPI
linePark(
    HCALL       hCall,
    DWORD       dwParkMode,
    LPCSTR      lpszDirAddress,
    LPVARSTRING lpNonDirAddress
    )
{
    return lineParkA (hCall, dwParkMode, lpszDirAddress, lpNonDirAddress);
}


LONG
WINAPI
linePickupW(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPHCALL lphCall,
    LPCWSTR lpszDestAddress,
    LPCWSTR lpszGroupID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lPickup),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lphCall,
            (ULONG_PTR) lpszDestAddress,
            (ULONG_PTR) lpszGroupID
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpszW,
            lpszW
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (!lpszDestAddress)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[4] = Dword;
        funcArgs.Args[4]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!lpszGroupID)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[5] = Dword;
        funcArgs.Args[5]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[3] = (ULONG_PTR)hPointer;
    }


    lResult = (DOFUNC (&funcArgs, "linePickup"));
    if (0 > lResult && hPointer)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
linePickupA(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPHCALL lphCall,
    LPCSTR  lpszDestAddress,
    LPCSTR  lpszGroupID
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;
    PWSTR   szTempPtr2;


    if ((lpszDestAddress && IsBadStringPtrA (lpszDestAddress, (DWORD) -1)) ||
        (lpszGroupID && IsBadStringPtrA (lpszGroupID, (DWORD) -1)))
    {
        return LINEERR_INVALPOINTER;
    }

    szTempPtr = NotSoWideStringToWideString (lpszDestAddress, (DWORD) -1);
    szTempPtr2 = NotSoWideStringToWideString (lpszGroupID, (DWORD) -1);

    lResult = linePickupW (hLine, dwAddressID, lphCall, szTempPtr, szTempPtr2);

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    if (szTempPtr2)
    {
        ClientFree (szTempPtr2);
    }

    return lResult;
}


LONG
WINAPI
linePickup(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPHCALL lphCall,
    LPCSTR  lpszDestAddress,
    LPCSTR  lpszGroupID
    )
{
    return linePickupA(
                hLine,
                dwAddressID,
                lphCall,
                lpszDestAddress,
                lpszGroupID
                );
}


LONG
WINAPI
linePrepareAddToConferenceW(
    HCALL   hConfCall,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lPrepareAddToConference),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hConfCall,
            (ULONG_PTR) lphConsultCall,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) TAPI_NO_DATA        // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[3] = Dword;
        funcArgs.Args[3]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphConsultCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphConsultCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[2] = (ULONG_PTR)hPointer;
    }

    lResult = (DOFUNC (&funcArgs, "linePrepareAddToConferenceW"));
    if (0 > lResult && hPointer)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
linePrepareAddToConferenceA(
    HCALL   hConfCall,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lPrepareAddToConference),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hConfCall,
            (ULONG_PTR) lphConsultCall,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) GetACP()            // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[3] = Dword;
        funcArgs.Args[3]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphConsultCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphConsultCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[2] = (ULONG_PTR)hPointer;
    }

    lResult = (DOFUNC (&funcArgs, "linePrepareAddToConference"));
    if (0 > lResult && hPointer)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
linePrepareAddToConference(
    HCALL   hConfCall,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    return linePrepareAddToConferenceA(
              hConfCall,
              lphConsultCall,
              lpCallParams
    );
}


LONG
WINAPI
lineProxyMessage(
    HLINE   hLine,
    HCALL   hCall,
    DWORD   dwMsg,
    DWORD   dwParam1,
    DWORD   dwParam2,
    DWORD   dwParam3
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, lProxyMessage),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwMsg,
            (ULONG_PTR) dwParam1,
            (ULONG_PTR) dwParam2,
            (ULONG_PTR) dwParam3
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
        }
    };


    return (DOFUNC (&funcArgs, "lineProxyMessage"));
}


LONG
WINAPI
lineProxyResponse(
    HLINE               hLine,
    LPLINEPROXYREQUEST  lpProxyRequest,
    DWORD               dwResult
    )
{
    LONG    lResult = 0;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lProxyResponse),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) 0,
            (ULONG_PTR) lpProxyRequest,
            (ULONG_PTR) dwResult
        },

        {
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    PPROXYREQUESTHEADER pProxyRequestHeader;


    //
    // The following is not the most thorough checking, but it's close
    // enough that a client app won't get a totally unexpected value
    // back
    //

    if (dwResult != 0  &&
        (dwResult < LINEERR_ALLOCATED  ||
            dwResult > LINEERR_DIALVOICEDETECT))
    {
        return LINEERR_INVALPARAM;
    }


    //
    // Backtrack a little bit to get the pointer to what ought to be
    // the proxy header, and then make sure we're dealing with a valid
    // proxy request
    //

    pProxyRequestHeader = (PPROXYREQUESTHEADER)
        (((LPBYTE) lpProxyRequest) - sizeof (PROXYREQUESTHEADER));

    try
    {
        //
        // Make sure we've a valid pProxyRequestHeader, then invalidate
        // the key so subsequent attempts to call lineProxyResponse with
        // the same lpProxyRequest fail
        //

        if (pProxyRequestHeader->dwKey != TPROXYREQUESTHEADER_KEY)
        {
            lResult = LINEERR_INVALPOINTER;
        }

        pProxyRequestHeader->dwKey = 0xefefefef;

        funcArgs.Args[1] = (ULONG_PTR) pProxyRequestHeader->dwInstance;


        //
        // See if this is one of the requests that don't require
        // any data to get passed back & reset the appropriate
        // params if so
        //

        switch (lpProxyRequest->dwRequestType)
        {
        case LINEPROXYREQUEST_SETAGENTGROUP:
        case LINEPROXYREQUEST_SETAGENTSTATE:
        case LINEPROXYREQUEST_SETAGENTACTIVITY:
        case LINEPROXYREQUEST_SETAGENTMEASUREMENTPERIOD:
        case LINEPROXYREQUEST_SETAGENTSESSIONSTATE:
        case LINEPROXYREQUEST_SETQUEUEMEASUREMENTPERIOD:
        case LINEPROXYREQUEST_SETAGENTSTATEEX:

            funcArgs.Args[2]     = (ULONG_PTR) TAPI_NO_DATA;
            funcArgs.ArgTypes[2] = Dword;

            break;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        lResult = LINEERR_INVALPOINTER;
    }


    if (lResult == 0)
    {
        lResult = DOFUNC (&funcArgs, "lineProxyResponse");


        //
        // If we've gotten this far we want to free the buffer
        // unconditionally
        //

        ClientFree (pProxyRequestHeader);
    }

    return lResult;
}


LONG
WINAPI
lineRedirectW(
    HCALL   hCall,
    LPCWSTR lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lRedirect),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpszDestAddress,
            (ULONG_PTR) dwCountryCode
        },

        {
            Dword,
            lpszW,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineRedirect"));
}


LONG
WINAPI
lineRedirectA(
    HCALL   hCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if (IsBadStringPtrA (lpszDestAddress, (DWORD) -1))
    {
        return LINEERR_INVALPOINTER;
    }

    szTempPtr = NotSoWideStringToWideString (lpszDestAddress, (DWORD) -1);

    lResult = lineRedirectW (hCall, szTempPtr, dwCountryCode);

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}


LONG
WINAPI
lineRedirect(
    HCALL   hCall,
    LPCSTR  lpszDestAddress,
    DWORD   dwCountryCode
    )
{
    return lineRedirectA (hCall, lpszDestAddress, dwCountryCode);
}


LONG
WINAPI
lineRegisterRequestRecipient(
    HLINEAPP    hLineApp,
    DWORD       dwRegistrationInstance,
    DWORD       dwRequestMode,
    DWORD       bEnable
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lRegisterRequestRecipient),

        {
            (ULONG_PTR) hLineApp,
            (ULONG_PTR) dwRegistrationInstance,
            (ULONG_PTR) dwRequestMode,
            (ULONG_PTR) bEnable
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineRegisterRequestRecipient"));
}


LONG
WINAPI
lineReleaseUserUserInfo(
    HCALL   hCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 1, lReleaseUserUserInfo),

        {
            (ULONG_PTR) hCall
        },

        {
            Dword,
        }
    };


    return (DOFUNC (&funcArgs, "lineReleaseUserUserInfo"));
}


LONG
WINAPI
lineRemoveFromConference(
    HCALL   hCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 1, lRemoveFromConference),

        {
            (ULONG_PTR) hCall
        },

        {
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineRemoveFromConference"));
}


LONG
WINAPI
lineRemoveProvider(
    DWORD   dwPermanentProviderID,
    HWND    hwndOwner
    )
{
    return (lineXxxProvider(
        gszTUISPI_providerRemove,   // func name
        NULL,                       // lpszProviderFilename
        hwndOwner,                  // hwndOwner
        dwPermanentProviderID,      // dwPermProviderID
        NULL                        // lpdwPermProviderID
        ));
}


LONG
WINAPI
lineSecureCall(
    HCALL hCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 1, lSecureCall),

        {
            (ULONG_PTR) hCall
        },

        {
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSecureCall"));
}


LONG
WINAPI
lineSendUserUserInfo(
    HCALL   hCall,
    LPCSTR  lpsUserUserInfo,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSendUserUserInfo),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpsUserUserInfo,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    if (!lpsUserUserInfo)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = (ULONG_PTR) TAPI_NO_DATA;
        funcArgs.ArgTypes[2] = Dword;
    }

    return (DOFUNC (&funcArgs, "lineSendUserUserInfo"));
}


LONG
WINAPI
lineSetAgentActivity(
    HLINE   hLine,
    DWORD   dwAddressID,
    DWORD   dwActivityID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetAgentActivity),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwActivityID
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetAgentActivity"));
}


LONG
WINAPI
lineSetAgentGroup(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    )
{
    static LINEAGENTGROUPLIST EmptyGroupList =
    {
        sizeof (LINEAGENTGROUPLIST),    // dwTotalSize
        sizeof (LINEAGENTGROUPLIST),    // dwNeededSize
        sizeof (LINEAGENTGROUPLIST),    // dwUsedSize
        0,                              // dwNumEntries
        0,                              // dwListSize
        0                               // dwListOffset
    };
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetAgentGroup),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lpAgentGroupList
        },

        {
            Dword,
            Dword,
            lpSet_Struct
        }
    };


    if (!lpAgentGroupList)
    {
        funcArgs.Args[2] = (ULONG_PTR) &EmptyGroupList;
    }

    return (DOFUNC (&funcArgs, "lineSetAgentGroup"));
}


LONG
WINAPI
lineSetAgentMeasurementPeriod(
    HLINE   hLine,
    HAGENT  hAgent,
    DWORD   dwMeasurementPeriod
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetAgentMeasurementPeriod),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgent,
            (ULONG_PTR) dwMeasurementPeriod
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetAgentMeasurementPeriod"));
}


LONG
WINAPI
lineSetAgentSessionState(
    HLINE           hLine,
    HAGENTSESSION   hAgentSession,
    DWORD           dwSessionState,
    DWORD           dwNextSessionState
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lSetAgentSessionState),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgentSession,
            (ULONG_PTR) dwSessionState,
            (ULONG_PTR) dwNextSessionState
        },

        {
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetAgentSessionState"));
}


LONG
WINAPI
lineSetAgentState(
    HLINE   hLine,
    DWORD   dwAddressID,
    DWORD   dwAgentState,
    DWORD   dwNextAgentState
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lSetAgentState),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwAgentState,
            (ULONG_PTR) dwNextAgentState
        },

        {
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetAgentState"));
}


LONG
WINAPI
lineSetAgentStateEx(
    HLINE               hLine,
    HAGENT              hAgent,
    DWORD               dwAgentState,
    DWORD               dwNextAgentState
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 4, lSetAgentStateEx),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) hAgent,
            (ULONG_PTR) dwAgentState,
            (ULONG_PTR) dwNextAgentState
        },

        {
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetAgentStateEx"));
}


LONG
WINAPI
lineSetAppPriorityW(
    LPCWSTR             lpszAppName,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCWSTR             lpszExtensionName,
    DWORD               dwPriority
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 7, lSetAppPriority),

        {
            (ULONG_PTR) lpszAppName,
            (ULONG_PTR) dwMediaMode,
            (ULONG_PTR) TAPI_NO_DATA,       // (DWORD) lpExtensionID,
            (ULONG_PTR) 0,                  // (DWORD) sizeof(LINEEXTENSIONID),
            (ULONG_PTR) dwRequestMode,
            (ULONG_PTR) TAPI_NO_DATA,       // (DWORD) lpszExtensionName,
            (ULONG_PTR) dwPriority
        },

        {
            lpszW,
            Dword,
            Dword,  // lpSet_SizeToFollow,
            Dword,  // Size,
            Dword,
            Dword,  // lpsz,
            Dword
        }
    };

#if 0
    if (dwMediaMode & 0xff000000)
    {
        //
        // Reset lpExtensionID (& following Size) Arg & ArgType
        // since it's a valid param in this case
        //

        funcArgs.ArgTypes[2] = lpSet_SizeToFollow;
        funcArgs.Args[2]     = (ULONG_PTR)  lpExtensionID;
        funcArgs.ArgTypes[3] = Size;
        funcArgs.Args[3]     = (ULONG_PTR) sizeof(LINEEXTENSIONID);

        if (lpszExtensionName)
        {
            //
            // Reset lpszExtensionName Arg & ArgType since it's
            // a valid param in this case
            //

            funcArgs.ArgTypes[5] = lpszW;
            funcArgs.Args[5]     = (ULONG_PTR)  lpszExtensionName;
        }
    }
#endif

    return (DOFUNC (&funcArgs, "lineSetAppPriority"));
}


LONG
WINAPI
lineSetAppPriorityA(
    LPCSTR              lpszAppName,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCSTR              lpszExtensionName,
    DWORD               dwPriority
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;
#if 0
    PWSTR   szTempPtr2;

    if (IsBadStringPtrA (lpszAppName, (DWORD) -1) ||
        ((dwMediaMode & 0xff000000) && lpszExtensionName &&
            IsBadStringPtrA (lpszExtensionName, (DWORD) -1)))
    {
        return LINEERR_INVALPOINTER;
    }

    szTempPtr2 = NotSoWideStringToWideString (lpszExtensionName, (DWORD) -1);
#endif
    szTempPtr = NotSoWideStringToWideString (lpszAppName, (DWORD) -1);
    lResult = lineSetAppPriorityW(
        szTempPtr,
        dwMediaMode,
        lpExtensionID,
        dwRequestMode,
        NULL, //szTempPtr2,
        dwPriority
        );

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

#if 0
    if (szTempPtr2)
    {
        ClientFree (szTempPtr2);
    }
#endif

    return lResult;
}


LONG
WINAPI
lineSetAppPriority(
    LPCSTR  lpszAppName,
    DWORD   dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD   dwRequestMode,
    LPCSTR  lpszExtensionName,
    DWORD   dwPriority
    )
{
    return lineSetAppPriorityA(
                lpszAppName,
                dwMediaMode,
                lpExtensionID,
                dwRequestMode,
                lpszExtensionName,
                dwPriority
                );
}


LONG
WINAPI
lineSetAppSpecific(
    HCALL   hCall,
    DWORD   dwAppSpecific
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lSetAppSpecific),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwAppSpecific
        },

        {
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetAppSpecific"));
}


LONG
WINAPI
lineSetCallData(
    HCALL   hCall,
    LPVOID  lpCallData,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetCallData),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpCallData,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    if (dwSize == 0)
    {
        funcArgs.Args[1]     = (ULONG_PTR) TAPI_NO_DATA;
        funcArgs.ArgTypes[1] =
        funcArgs.ArgTypes[2] = Dword;
    }

    return (DOFUNC (&funcArgs, "lineSetCallData"));
}


LONG
WINAPI
lineSetCallParams(
    HCALL   hCall,
    DWORD   dwBearerMode,
    DWORD   dwMinRate,
    DWORD   dwMaxRate,
    LPLINEDIALPARAMS const lpDialParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 6, lSetCallParams),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwBearerMode,
            (ULONG_PTR) dwMinRate,
            (ULONG_PTR) dwMaxRate,
            (ULONG_PTR) lpDialParams,
            (ULONG_PTR) sizeof(LINEDIALPARAMS)
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    if (!lpDialParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[4] = Dword;
        funcArgs.Args[4]     = (ULONG_PTR) TAPI_NO_DATA;
        funcArgs.ArgTypes[5] = Dword;
    }

    return (DOFUNC (&funcArgs, "lineSetCallParams"));
}


LONG
WINAPI
lineSetCallPrivilege(
    HCALL   hCall,
    DWORD   dwCallPrivilege
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lSetCallPrivilege),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwCallPrivilege
        },

        {
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetCallPrivilege"));
}


LONG
WINAPI
lineSetCallQualityOfService(
    HCALL   hCall,
    LPVOID  lpSendingFlowspec,
    DWORD   dwSendingFlowspecSize,
    LPVOID  lpReceivingFlowspec,
    DWORD   dwReceivingFlowspecSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lSetCallQualityOfService),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) lpSendingFlowspec,
            (ULONG_PTR) dwSendingFlowspecSize,
            (ULONG_PTR) lpReceivingFlowspec,
            (ULONG_PTR) dwReceivingFlowspecSize
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size,
            lpSet_SizeToFollow,
            Size,
        }
    };


    return (DOFUNC (&funcArgs, "lineSetCallQualityOfService"));
}


LONG
WINAPI
lineSetCallTreatment(
    HCALL   hCall,
    DWORD   dwTreatment
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 2, lSetCallTreatment),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwTreatment
        },

        {
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetCallTreatment"));
}


LONG
WINAPI
lineSetDevConfigW(
    DWORD   dwDeviceID,
    LPVOID  const lpDeviceConfig,
    DWORD   dwSize,
    LPCWSTR lpszDeviceClass
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lSetDevConfig),

        {
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) lpDeviceConfig,
            (ULONG_PTR) dwSize,
            (ULONG_PTR) lpszDeviceClass
        },

        {
            Dword,
            lpSet_SizeToFollow,
            Size,
            lpszW
        }
    };


    return (DOFUNC (&funcArgs, "lineSetDevConfig"));
}


LONG
WINAPI
lineSetDevConfigA(
    DWORD   dwDeviceID,
    LPVOID  const lpDeviceConfig,
    DWORD   dwSize,
    LPCSTR  lpszDeviceClass
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if (IsBadStringPtrA (lpszDeviceClass, (DWORD) -1))
    {
        return LINEERR_INVALPOINTER;
    }
    else if (!(szTempPtr = NotSoWideStringToWideString(
                lpszDeviceClass,
                (DWORD) -1
                )))
    {
        return LINEERR_NOMEM;
    }

    lResult = lineSetDevConfigW(
        dwDeviceID,
        lpDeviceConfig,
        dwSize,
        szTempPtr
        );

    ClientFree (szTempPtr);

    return lResult;
}


LONG
WINAPI
lineSetDevConfig(
    DWORD   dwDeviceID,
    LPVOID  const lpDeviceConfig,
    DWORD   dwSize,
    LPCSTR  lpszDeviceClass
    )
{
    return lineSetDevConfigA(
                dwDeviceID,
                lpDeviceConfig,
                dwSize,
                lpszDeviceClass
                );
}


LONG
WINAPI
lineSetLineDevStatus(
    HLINE   hLine,
    DWORD   dwStatusToChange,
    DWORD   fStatus
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetLineDevStatus),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwStatusToChange,
            (ULONG_PTR) fStatus
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetLineDevStatus"));
}


LONG
WINAPI
lineSetMediaControl(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    DWORD   dwSelect,
    LPLINEMEDIACONTROLDIGIT const lpDigitList,
    DWORD   dwDigitNumEntries,
    LPLINEMEDIACONTROLMEDIA const lpMediaList,
    DWORD   dwMediaNumEntries,
    LPLINEMEDIACONTROLTONE  const lpToneList,
    DWORD   dwToneNumEntries,
    LPLINEMEDIACONTROLCALLSTATE const lpCallStateList,
    DWORD   dwCallStateNumEntries
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 12, lSetMediaControl),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwSelect,
            (ULONG_PTR) TAPI_NO_DATA,
            (ULONG_PTR) dwDigitNumEntries * sizeof(LINEMEDIACONTROLDIGIT),
            (ULONG_PTR) TAPI_NO_DATA,
            (ULONG_PTR) dwMediaNumEntries * sizeof(LINEMEDIACONTROLMEDIA),
            (ULONG_PTR) TAPI_NO_DATA,
            (ULONG_PTR) dwToneNumEntries * sizeof(LINEMEDIACONTROLTONE),
            (ULONG_PTR) TAPI_NO_DATA,
            (ULONG_PTR) dwCallStateNumEntries * sizeof(LINEMEDIACONTROLCALLSTATE)
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    //
    // If lpXxxList is non-NULL reset Arg & ArgType, and check
    // to see that dwXxxNumEntries is not unacceptably large
    //

    if (lpDigitList)
    {
            if (dwDigitNumEntries >
                    (0x1000000 / sizeof (LINEMEDIACONTROLDIGIT)))
            {
            return LINEERR_INVALPOINTER;
            }

            funcArgs.ArgTypes[4] = lpSet_SizeToFollow;
            funcArgs.Args[4]     = (ULONG_PTR) lpDigitList;
            funcArgs.ArgTypes[5] = Size;
    }

    if (lpMediaList)
    {
            if (dwMediaNumEntries >
                    (0x1000000 / sizeof (LINEMEDIACONTROLMEDIA)))
            {
            return LINEERR_INVALPOINTER;
            }

            funcArgs.ArgTypes[6] = lpSet_SizeToFollow;
            funcArgs.Args[6]     = (ULONG_PTR) lpMediaList;
            funcArgs.ArgTypes[7] = Size;
    }

    if (lpToneList)
    {
            if (dwToneNumEntries >
                    (0x1000000 / sizeof (LINEMEDIACONTROLTONE)))
            {
            return LINEERR_INVALPOINTER;
            }

            funcArgs.ArgTypes[8] = lpSet_SizeToFollow;
            funcArgs.Args[8]     = (ULONG_PTR) lpToneList;
            funcArgs.ArgTypes[9] = Size;
    }

    if (lpCallStateList)
    {
            if (dwCallStateNumEntries >
                    (0x1000000 / sizeof (LINEMEDIACONTROLCALLSTATE)))
            {
            return LINEERR_INVALPOINTER;
            }

            funcArgs.ArgTypes[10] = lpSet_SizeToFollow;
            funcArgs.Args[10]     = (ULONG_PTR) lpCallStateList;
            funcArgs.ArgTypes[11] = Size;
    }

    return (DOFUNC (&funcArgs, "lineSetMediaControl"));
}


LONG
WINAPI
lineSetMediaMode(
    HCALL   hCall,
    DWORD   dwMediaModes
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, lSetMediaMode),

        {
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwMediaModes
        },

        {
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetMediaMode"));
}


LONG
WINAPI
lineSetNumRings(
    HLINE   hLine,
    DWORD   dwAddressID,
    DWORD   dwNumRings
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lSetNumRings),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) dwNumRings
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetNumRings"));
}


LONG
WINAPI
lineSetQueueMeasurementPeriod(
    HLINE   hLine,
    DWORD   dwQueueID,
    DWORD   dwMeasurementPeriod
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 3, lSetQueueMeasurementPeriod),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwQueueID,
            (ULONG_PTR) dwMeasurementPeriod
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetQueueMeasurementPeriod"));
}


LONG
WINAPI
lineSetStatusMessages(
    HLINE hLine,
    DWORD dwLineStates,
    DWORD dwAddressStates
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 3, lSetStatusMessages),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwLineStates,
            (ULONG_PTR) dwAddressStates
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetStatusMessages"));
}


LONG
WINAPI
lineSetTerminal(
    HLINE   hLine,
    DWORD   dwAddressID,
    HCALL   hCall,
    DWORD   dwSelect,
    DWORD   dwTerminalModes,
    DWORD   dwTerminalID,
    DWORD   bEnable
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 7, lSetTerminal),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) hCall,
            (ULONG_PTR) dwSelect,
            (ULONG_PTR) dwTerminalModes,
            (ULONG_PTR) dwTerminalID,
            (ULONG_PTR) bEnable
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineSetTerminal"));
}


void
PASCAL
lineSetupConferencePostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "lineSetupConfPostProcess: enter"));
    LOG((TL_INFO,
        "\t\tdwP1=x%lx, dwP2=x%lx, dwP3=x%lx, dwP4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        HCALL   hConfCall      = (HCALL) pMsg->Param3,
                hConsultCall   = (HCALL) *(&pMsg->Param4 + 1);
        LPHCALL lphConfCall    = (LPHCALL) ReferenceObject (ghHandleTable, pMsg->Param4, 0),
                lphConsultCall = (LPHCALL) ReferenceObject (ghHandleTable, *(&pMsg->Param4 + 2), 0);

        // We don't need the handle to the pointer any more...
        DereferenceObject (ghHandleTable, pMsg->Param4, 2);
        DereferenceObject (ghHandleTable, *(&pMsg->Param4 + 2), 2);

        try
        {
            if (gbNTVDMClient)
            {
#ifndef _WIN64
                LPHCALL lphConfCallVDM = (LPHCALL) gpfnWOWGetVDMPointer(
                            (DWORD) lphConfCall,
                            sizeof (HCALL),
                            TRUE // fProtectedMode
                            ),
                        lphConsultCallVDM = (LPHCALL) gpfnWOWGetVDMPointer(
                            (DWORD) lphConsultCall,
                            sizeof (HCALL),
                            TRUE // fProtectedMode
                            );

                if (lphConfCallVDM && lphConsultCallVDM)
                {
                    *lphConfCallVDM = hConfCall;
                    *lphConsultCallVDM = hConsultCall;
                }
                else
                {
                    pMsg->Param2 = LINEERR_INVALPOINTER;
                }
#endif
            }
            else
            {
                *lphConfCall = hConfCall;
                *lphConsultCall = hConsultCall;
            }
        }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            pMsg->Param2 = LINEERR_INVALPOINTER;
        }
    }
}


LONG
WINAPI
lineSetupConferenceW(
    HCALL   hCall,
    HLINE   hLine,
    LPHCALL lphConfCall,
    LPHCALL lphConsultCall,
    DWORD   dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 8, lSetupConference),

        {
            (ULONG_PTR) GetFunctionIndex(lineSetupConferencePostProcess),
            (ULONG_PTR) hCall,
            (ULONG_PTR) hLine,
            (ULONG_PTR) lphConfCall,
            (ULONG_PTR) lphConsultCall,
            (ULONG_PTR) dwNumParties,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) TAPI_NO_DATA        // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer1 = 0, hPointer2 = 0;
    LONG  lResult;


    if (lphConfCall == lphConsultCall)
    {
        return LINEERR_INVALPOINTER;
    }

    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[6] = Dword;
        funcArgs.Args[6]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphConfCall) ||
            IsBadDwordPtr (lphConsultCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer1 = NewObject (ghHandleTable, (PVOID)lphConfCall, NULL);
        if (0 == hPointer1)
        {
            return LINEERR_NOMEM;
        }
        hPointer2 = NewObject (ghHandleTable, (PVOID)lphConsultCall, NULL);
        if (0 == hPointer2)
        {
            DereferenceObject (ghHandleTable, hPointer1, 1);
            return LINEERR_NOMEM;
        }
        funcArgs.Args[3] = (ULONG_PTR)hPointer1;
        funcArgs.Args[4] = (ULONG_PTR)hPointer2;
    }


    lResult = (DOFUNC (&funcArgs, "lineSetupConferenceW"));
    if (0 > lResult && hPointer1)
    {
        DereferenceObject (ghHandleTable, hPointer1, 1);
        DereferenceObject (ghHandleTable, hPointer2, 1);
    }

    return lResult;
}


LONG
WINAPI
lineSetupConferenceA(
    HCALL   hCall,
    HLINE   hLine,
    LPHCALL lphConfCall,
    LPHCALL lphConsultCall,
    DWORD   dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 8, lSetupConference),

        {
            (ULONG_PTR) GetFunctionIndex(lineSetupConferencePostProcess),
            (ULONG_PTR) hCall,
            (ULONG_PTR) hLine,
            (ULONG_PTR) lphConfCall,
            (ULONG_PTR) lphConsultCall,
            (ULONG_PTR) dwNumParties,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) GetACP()            // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer1 = 0, hPointer2 = 0;
    LONG  lResult;


    if (lphConfCall == lphConsultCall)
    {
        return LINEERR_INVALPOINTER;
    }

    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[6] = Dword;
        funcArgs.Args[6]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphConfCall) ||
            IsBadDwordPtr (lphConsultCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer1 = NewObject (ghHandleTable, (PVOID)lphConfCall, NULL);
        if (0 == hPointer1)
        {
            return LINEERR_NOMEM;
        }
        hPointer2 = NewObject (ghHandleTable, (PVOID)lphConsultCall, NULL);
        if (0 == hPointer2)
        {
            DereferenceObject (ghHandleTable, hPointer1, 1);
            return LINEERR_NOMEM;
        }
        funcArgs.Args[3] = (ULONG_PTR)hPointer1;
        funcArgs.Args[4] = (ULONG_PTR)hPointer2;
    }


    lResult = (DOFUNC (&funcArgs, "lineSetupConference"));
    if (0 > lResult && hPointer1)
    {
        DereferenceObject (ghHandleTable, hPointer1, 1);
        DereferenceObject (ghHandleTable, hPointer2, 1);
    }

    return lResult;
}


LONG
WINAPI
lineSetupConference(
    HCALL   hCall,
    HLINE   hLine,
    LPHCALL lphConfCall,
    LPHCALL lphConsultCall,
    DWORD   dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    return lineSetupConferenceA(
                hCall,
                hLine,
                lphConfCall,
                lphConsultCall,
                dwNumParties,
                lpCallParams
                );
}


LONG
WINAPI
lineSetupTransferW(
    HCALL   hCall,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lSetupTransfer),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hCall,
            (ULONG_PTR) lphConsultCall,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) TAPI_NO_DATA        // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[3] = Dword;
        funcArgs.Args[3]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphConsultCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphConsultCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[2] = (ULONG_PTR)hPointer;
    }

    lResult = (DOFUNC (&funcArgs, "lineSetupTransferW"));
    if (0 > lResult && hPointer)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineSetupTransferA(
    HCALL   hCall,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lSetupTransfer),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hCall,
            (ULONG_PTR) lphConsultCall,
            (ULONG_PTR) lpCallParams,
            (ULONG_PTR) GetACP()            // dwAsciiCallParamsCodePage
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_Struct,
            Dword
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (!lpCallParams)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[3] = Dword;
        funcArgs.Args[3]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphConsultCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphConsultCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[2] = (ULONG_PTR)hPointer;
    }

    lResult = (DOFUNC (&funcArgs, "lineSetupTransferW"));
    if (0 > lResult && hPointer)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineSetupTransfer(
    HCALL   hCall,
    LPHCALL lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    return lineSetupTransferA (hCall, lphConsultCall, lpCallParams);
}


LONG
WINAPI
lineShutdown(
    HLINEAPP    hLineApp
    )
{
    return (xxxShutdown (hLineApp, TRUE));
}


LONG
WINAPI
lineSwapHold(
    HCALL   hActiveCall,
    HCALL   hHeldCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 2, lSwapHold),

        {
            (ULONG_PTR) hActiveCall,
            (ULONG_PTR) hHeldCall
        },

        {
            Dword,
            Dword
        }
    };

    return (DOFUNC (&funcArgs, "lineSwapHold"));
}


LONG
WINAPI
lineUncompleteCall(
    HLINE   hLine,
    DWORD   dwCompletionID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 2, lUncompleteCall),

        {
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwCompletionID
        },

        {
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineUncompleteCall"));
}


LONG
WINAPI
lineUnhold(
    HCALL   hCall
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 1, lUnhold),

        {
            (ULONG_PTR) hCall
        },

        {
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "lineUnhold"));
}


LONG
WINAPI
lineUnparkW(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPHCALL lphCall,
    LPCWSTR lpszDestAddress
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | ASYNC | 5, lUnpark),

        {
            (ULONG_PTR) GetFunctionIndex(lineMakeCallPostProcess),
            (ULONG_PTR) hLine,
            (ULONG_PTR) dwAddressID,
            (ULONG_PTR) lphCall,
            (ULONG_PTR) lpszDestAddress
        },

        {
            Dword,
            Dword,
            Dword,
            Dword,
            lpszW
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;

    if (!gbNTVDMClient)
    {
        if (IsBadDwordPtr (lphCall))
        {
            return LINEERR_INVALPOINTER;
        }

        hPointer = NewObject (ghHandleTable, (PVOID)lphCall, NULL);
        if (0 == hPointer)
        {
            return LINEERR_NOMEM;
        }
        funcArgs.Args[3] = (ULONG_PTR)hPointer;
    }


    lResult = (DOFUNC (&funcArgs, "lineUnpark"));
    if (0 > lResult && hPointer)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
lineUnparkA(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPHCALL lphCall,
    LPCSTR  lpszDestAddress
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if (IsBadStringPtrA (lpszDestAddress, (DWORD) -1))
    {
        return LINEERR_INVALPOINTER;
    }
    else if (!(szTempPtr = NotSoWideStringToWideString(
                    lpszDestAddress,
                    (DWORD) -1
                    )))
    {
        return LINEERR_NOMEM;
    }

    lResult = lineUnparkW (hLine, dwAddressID, lphCall, szTempPtr);

    ClientFree (szTempPtr);

    return lResult;
}


LONG
WINAPI
lineUnpark(
    HLINE   hLine,
    DWORD   dwAddressID,
    LPHCALL lphCall,
    LPCSTR  lpszDestAddress
    )
{
    return  lineUnparkA (hLine, dwAddressID, lphCall, lpszDestAddress);

}

//
// ------------------------------- phoneXxx -----------------------------------
//

LONG
WINAPI
phoneClose(
    HPHONE  hPhone
    )
{
    LONG lResult;
    DWORD Handle = 0;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 2, pClose),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) &Handle
        },

        {
            Dword,
            lpDword
        }
    };


    lResult = DOFUNC (&funcArgs, "phoneClose");

    if (0 == lResult &&
        0 != Handle)
    {
        DereferenceObject (ghHandleTable, Handle, 1);
    }

    return lResult;
}


LONG
WINAPI
phoneConfigDialogW(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCWSTR lpszDeviceClass
    )
{
    LONG        lResult;
    HANDLE      hDll;
    TUISPIPROC  pfnTUISPI_phoneConfigDialog;


    if (lpszDeviceClass && TAPIIsBadStringPtrW (lpszDeviceClass, (UINT) -1))
    {
        LOG((TL_ERROR, "Bad lpszDeviceClass in phoneConfigDialogW [%p]",
                   lpszDeviceClass ));
        return PHONEERR_INVALPOINTER;
    }

    if ((lResult = LoadUIDll(
            hwndOwner,
            dwDeviceID,
            TUISPIDLL_OBJECT_PHONEID,
            &hDll,
            gszTUISPI_phoneConfigDialog,
            &pfnTUISPI_phoneConfigDialog

            )) == 0)
    {
        LOG((TL_TRACE, "Calling TUISPI_phoneConfigDialog..."));

        lResult = (*pfnTUISPI_phoneConfigDialog)(
            TUISPIDLLCallback,
            dwDeviceID,
            hwndOwner,
            lpszDeviceClass
            );

#if DBG
        {
            char szResult[32];

            LOG((TL_TRACE,
                "TUISPI_phoneConfigDialog: result = %hs",
                MapResultCodeToText (lResult, szResult)
                ));
        }
#else
            LOG((TL_TRACE,
                "TUISPI_phoneConfigDialog: result = x%x",
                lResult
                ));
#endif
        FreeLibrary (hDll);
    }

    return lResult;
}


LONG
WINAPI
phoneConfigDialogA(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCSTR  lpszDeviceClass
    )
{
    LONG  lResult;
    PWSTR szTempString;


    if (lpszDeviceClass && IsBadStringPtrA (lpszDeviceClass, (DWORD) -1))
    {
        return PHONEERR_INVALPOINTER;
    }

    szTempString = NotSoWideStringToWideString (lpszDeviceClass, (DWORD) -1);


    lResult = phoneConfigDialogW (dwDeviceID, hwndOwner, szTempString);

    if (szTempString)
    {
        ClientFree (szTempString);
    }

    return lResult;
}


LONG
WINAPI
phoneConfigDialog(
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCSTR  lpszDeviceClass
    )
{
    return phoneConfigDialogA (dwDeviceID, hwndOwner, lpszDeviceClass);
}


void
PASCAL
phoneDevSpecificPostProcess(
    PASYNCEVENTMSG pMsg
    )
{
    LOG((TL_TRACE, "phoneDevSpecificPostProcess: enter"));
    LOG((TL_INFO,
		"\t\tp1=x%lx, p2=x%lx, p3=x%lx, p4=x%lx",
        pMsg->Param1,
        pMsg->Param2,
        pMsg->Param3,
        pMsg->Param4
        ));

    if (pMsg->Param2 == 0)
    {
        DWORD   dwSize  = (DWORD) pMsg->Param4;

        if (dwSize > 0)
        {
            LPBYTE  pParams = (LPBYTE) ReferenceObject (ghHandleTable, pMsg->Param3, 0);

            // We don't need the handle to the pointer any more...
            DereferenceObject (ghHandleTable, pMsg->Param3, 2);

            try
            {
                if (gbNTVDMClient)
                {
#ifndef _WIN64

                    LPVARSTRING pParamsVDM = (LPVARSTRING) gpfnWOWGetVDMPointer(
                        (DWORD) pParams,
                        dwSize,
                        TRUE // fProtectedMode
                        );


                    if (pParamsVDM)
                    {
                        CopyMemory (pParamsVDM, (LPBYTE) (pMsg + 1), dwSize);
                    }
                    else
                    {
                        pMsg->Param2 = PHONEERR_INVALPOINTER;
                    }
#endif
                }
                else
                {
                    CopyMemory (pParams, (LPBYTE) (pMsg + 1), dwSize);
                }
            }
            except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
            {
                pMsg->Param2 = PHONEERR_INVALPOINTER;
            }
        }
    }
}


LONG
WINAPI
phoneDevSpecific(
    HPHONE  hPhone,
    LPVOID  lpParams,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 5, pDevSpecific),

        {
            (ULONG_PTR) GetFunctionIndex(phoneDevSpecificPostProcess),
            (ULONG_PTR) hPhone,
            (ULONG_PTR) lpParams,   // passed as Dword for post processing
            (ULONG_PTR) lpParams,   // passed as LpSet_Xxx for IsValidPtr chk
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };
    DWORD hPointer = 0;
    LONG  lResult;


    if (gbNTVDMClient)
    {
#ifndef _WIN64
        if (!gpfnWOWGetVDMPointer  ||

            !(funcArgs.Args[3] = (ULONG_PTR) gpfnWOWGetVDMPointer(
                (DWORD) lpParams,
                dwSize,
                TRUE // fProtectedMode
                )))
#endif
        {
            return PHONEERR_OPERATIONFAILED;
        }
    }

    if (!gbNTVDMClient)
    {
        if ( !lpParams && dwSize > 0)
        {
            return PHONEERR_INVALPOINTER;
        }

        if (dwSize > 0)
        {
            hPointer = NewObject (ghHandleTable, (PVOID)lpParams, NULL);
            if (0 == hPointer)
            {
                return PHONEERR_NOMEM;
            }
            funcArgs.Args[2] = (ULONG_PTR)hPointer;
        }
    }

    lResult = (DOFUNC (&funcArgs, "phoneDevSpecific"));
    if (0 > lResult && hPointer)
    {
        DereferenceObject (ghHandleTable, hPointer, 1);
    }

    return lResult;
}


LONG
WINAPI
phoneGetButtonInfoW(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetButtonInfo),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwButtonLampID,
            (ULONG_PTR) lpButtonInfo
        },

        {
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "phoneGetButtonInfo"));
}


LONG
WINAPI
phoneGetButtonInfoA(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    )
{
    LONG lResult;


    lResult = phoneGetButtonInfoW (hPhone, dwButtonLampID, lpButtonInfo);

    if ( 0 == lResult )
    {
        WideStringToNotSoWideString(
            (LPBYTE)lpButtonInfo,
            &lpButtonInfo->dwButtonTextSize
            );
    }

    return lResult;
}


LONG
WINAPI
phoneGetButtonInfo(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    )
{
    return phoneGetButtonInfoA (hPhone, dwButtonLampID, lpButtonInfo);
}


LONG
WINAPI
phoneGetData(
    HPHONE  hPhone,
    DWORD   dwDataID,
    LPVOID  lpData,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 4, pGetData),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwDataID,
            (ULONG_PTR) lpData,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            lpGet_SizeToFollow,
            Size
        }
    };


    return (DOFUNC (&funcArgs, "phoneGetData"));
}


LONG
WINAPI
phoneGetDevCapsW(
    HPHONEAPP   hPhoneApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    DWORD       dwExtVersion,
    LPPHONECAPS lpPhoneCaps
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 5, pGetDevCaps),

        {
            (ULONG_PTR) hPhoneApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) dwExtVersion,
            (ULONG_PTR) lpPhoneCaps
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };

    if (dwAPIVersion > TAPI_CURRENT_VERSION)
    {
        return PHONEERR_INCOMPATIBLEAPIVERSION;
    }

    return (DOFUNC (&funcArgs, "phoneGetDevCaps"));
}


LONG
WINAPI
phoneGetDevCapsA(
    HPHONEAPP   hPhoneApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    DWORD       dwExtVersion,
    LPPHONECAPS lpPhoneCaps
    )
{
    LONG lResult;


    lResult = phoneGetDevCapsW(
        hPhoneApp,
        dwDeviceID,
        dwAPIVersion,
        dwExtVersion,
        lpPhoneCaps
        );

    if (lResult == 0)
    {
        lpPhoneCaps->dwStringFormat = STRINGFORMAT_ASCII;

        WideStringToNotSoWideString(
            (LPBYTE) lpPhoneCaps,
            &lpPhoneCaps->dwProviderInfoSize
            );

        WideStringToNotSoWideString(
            (LPBYTE) lpPhoneCaps,
            &lpPhoneCaps->dwPhoneInfoSize
            );

        WideStringToNotSoWideString(
            (LPBYTE) lpPhoneCaps,
            &lpPhoneCaps->dwPhoneNameSize
            );

        if (dwAPIVersion >= 0x00020000)
        {
            WideStringToNotSoWideString(
                (LPBYTE) lpPhoneCaps,
                &lpPhoneCaps->dwDeviceClassesSize
                );
        }
    }


    return lResult;
}


LONG
WINAPI
phoneGetDevCaps(
    HPHONEAPP   hPhoneApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    DWORD       dwExtVersion,
    LPPHONECAPS lpPhoneCaps
    )
{
    return phoneGetDevCapsA(
                hPhoneApp,
                dwDeviceID,
                dwAPIVersion,
                dwExtVersion,
                lpPhoneCaps
                );
}


LONG
WINAPI
phoneGetDisplay(
    HPHONE  hPhone,
    LPVARSTRING lpDisplay
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 2, pGetDisplay),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) lpDisplay
        },

        {
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "phoneGetDisplay"));
}


LONG
WINAPI
phoneGetGain(
    HPHONE hPhone,
    DWORD dwHookSwitchDev,
    LPDWORD lpdwGain
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetGain),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwHookSwitchDev,
            (ULONG_PTR) lpdwGain
        },

        {
            Dword,
            Dword,
            lpDword
        }
    };


    return (DOFUNC (&funcArgs, "phoneGetGain"));
}


LONG
WINAPI
phoneGetHookSwitch(
    HPHONE hPhone,
    LPDWORD lpdwHookSwitchDevs
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 2, pGetHookSwitch),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) lpdwHookSwitchDevs
        },

        {
            Dword,
            lpDword
        }
    };


    return (DOFUNC (&funcArgs, "phoneGetHookSwitch"));
}


LONG
WINAPI
phoneGetIconW(
    DWORD   dwDeviceID,
    LPCWSTR lpszDeviceClass,
    LPHICON lphIcon
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetIcon),

        {
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) lpszDeviceClass,
            (ULONG_PTR) lphIcon
        },

        {
            Dword,
            lpszW,
            lpDword
        }
    };


    if (IsBadDwordPtr ((LPDWORD) lphIcon))
    {
        LOG((TL_ERROR,
            "Bad icon pointer passed into PhoneGetIconA [0x%p]",
            lphIcon
            ));

        return PHONEERR_INVALPOINTER;
    }

    if (lpszDeviceClass == (LPCWSTR) NULL)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    return DOFUNC (&funcArgs, "phoneGetIcon");
}


LONG
WINAPI
phoneGetIconA(
    DWORD   dwDeviceID,
    LPCSTR  lpszDeviceClass,
    LPHICON lphIcon
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if (lpszDeviceClass)
    {
        if (IsBadStringPtrA (lpszDeviceClass, (DWORD) (DWORD) -1))
        {
            return PHONEERR_INVALPOINTER;
        }

        szTempPtr = NotSoWideStringToWideString (lpszDeviceClass, (DWORD) -1);
    }
    else
    {
        szTempPtr = NULL;
    }

    lResult = phoneGetIconW (dwDeviceID, szTempPtr, lphIcon);

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}


LONG
WINAPI
phoneGetIcon(
    DWORD   dwDeviceID,
    LPCSTR  lpszDeviceClass,
    LPHICON lphIcon
    )
{
    return (phoneGetIconA (dwDeviceID, lpszDeviceClass, lphIcon));
}


LONG
WINAPI
phoneGetIDW(
    HPHONE      hPhone,
    LPVARSTRING lpDeviceID,
    LPCWSTR     lpszDeviceClass
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetID),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) lpDeviceID,
            (ULONG_PTR) lpszDeviceClass
        },

        {
            Dword,
            lpGet_Struct,
            lpszW
        }
    };

    LPVARSTRING lpDeviceIDTemp = NULL;
    DWORD       dwNumDevices;
    DWORD       dwBufSize;
    DWORD       dwResult;
    DWORD       dwDeviceId1, dwDeviceId2;
    BOOL        bDoItAgain = FALSE;


    if ( TAPIIsBadStringPtrW(lpszDeviceClass, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszDeviceClass in phoneGetIDW"));
        return( PHONEERR_INVALPOINTER );
    }

    if ( IsBadWritePtr(lpDeviceID, sizeof(VARSTRING)) )
    {
        LOG((TL_ERROR, "Bad lpDeviceID in lineGetIDW"));
        return( PHONEERR_INVALPOINTER);
    }

    //
    // if the request is for a wave device, call LGetIDEx
    //
    if (!_wcsicmp(lpszDeviceClass, L"wave/in")  ||
        !_wcsicmp(lpszDeviceClass, L"wave/out") ||
        !_wcsicmp(lpszDeviceClass, L"midi/in")  ||
        !_wcsicmp(lpszDeviceClass, L"midi/out") ||
        !_wcsicmp(lpszDeviceClass, L"wave/in/out")
       )
    {
        dwNumDevices = _wcsicmp(lpszDeviceClass, L"wave/in/out") ? 1 : 2;
        dwBufSize = lpDeviceID->dwTotalSize + dwNumDevices * WAVE_STRING_ID_BUFFER_SIZE;
        do
        {
            //
            // Allocate additional memory for the device string ID
            //
            lpDeviceIDTemp = (LPVARSTRING)ClientAlloc (dwBufSize);
            if (!lpDeviceIDTemp)
            {
                LOG((TL_ERROR, "Failed to allocate memory"));
                return( PHONEERR_NOMEM );
            }
            lpDeviceIDTemp->dwTotalSize = dwBufSize;
            funcArgs.Flags = MAKELONG (PHONE_FUNC | SYNC | 3, pGetIDEx);
            funcArgs.Args[1] = (ULONG_PTR)lpDeviceIDTemp;

            //
            // Call LGetIDEx
            //
            dwResult = DOFUNC (&funcArgs, "phoneGetIDEx");
            if (dwResult)
            {
                LOG((TL_ERROR, "phoneGetIDEx failed with x%x", dwResult));
                ClientFree (lpDeviceIDTemp);
                return dwResult;
            }

            if (lpDeviceIDTemp->dwNeededSize > lpDeviceIDTemp->dwTotalSize && !bDoItAgain)
            {
                LOG((TL_INFO, 
                     "phoneGetIDEx returned needed size (%d) bigger than total size (%d) -> need to realloc", 
                     lpDeviceIDTemp->dwNeededSize, 
                     lpDeviceIDTemp->dwTotalSize ));
                dwBufSize = lpDeviceIDTemp->dwNeededSize;
                ClientFree ( lpDeviceIDTemp );
                bDoItAgain = TRUE;
            }
            else
            {
                bDoItAgain = FALSE;
            }
            
        } while (bDoItAgain);

        if (lpDeviceIDTemp->dwNeededSize > lpDeviceIDTemp->dwTotalSize)
        {
            LOG((TL_ERROR, "needed size (%d) still bigger than total size (%d)",
                     lpDeviceIDTemp->dwNeededSize, 
                     lpDeviceIDTemp->dwTotalSize ));
            ClientFree (lpDeviceIDTemp);
            return PHONEERR_OPERATIONFAILED;
        }

        //
        // Get the device ID from string ID
        //
        if (dwNumDevices == 1)
        {
            if (!WaveStringIdToDeviceId (
                (LPWSTR)((LPBYTE)lpDeviceIDTemp + lpDeviceIDTemp->dwStringOffset),
                lpszDeviceClass,
                &dwDeviceId1)
               )
            {
                LOG((TL_ERROR, "WaveStringIdToDeviceId failed"));
                ClientFree (lpDeviceIDTemp);
                return PHONEERR_OPERATIONFAILED;
            }
            
            // check if the client buffer is big enough
            if (lpDeviceID->dwTotalSize < sizeof(VARSTRING) + sizeof(DWORD))
            {
                lpDeviceID->dwNeededSize = sizeof(VARSTRING) + sizeof(DWORD);
                lpDeviceID->dwUsedSize = sizeof(VARSTRING);
            }
            else
            {
                lpDeviceID->dwNeededSize = lpDeviceID->dwUsedSize = sizeof(VARSTRING) + sizeof(DWORD);
                lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;
                lpDeviceID->dwStringSize = sizeof(DWORD);
                lpDeviceID->dwStringOffset = sizeof(VARSTRING);
                *(DWORD *)(lpDeviceID + 1) = dwDeviceId1;
            }
        }
        else
        {
            LPWSTR szString1 = (LPWSTR)((LPBYTE)lpDeviceIDTemp + lpDeviceIDTemp->dwStringOffset);

            if (!WaveStringIdToDeviceId (
                    szString1,
                    L"wave/in",
                    &dwDeviceId1) ||
                !WaveStringIdToDeviceId (
                    (LPWSTR)((LPBYTE)lpDeviceIDTemp + lpDeviceIDTemp->dwStringOffset + wcslen(szString1)),
                    L"wave/out",
                    &dwDeviceId2)
               )
            {
                LOG((TL_ERROR, "WaveStringIdToDeviceId failed"));
                ClientFree (lpDeviceIDTemp);
                return PHONEERR_OPERATIONFAILED;
            }
            
            // check if the client buffer is big enough
            if (lpDeviceID->dwTotalSize < sizeof(VARSTRING) + 2 * sizeof(DWORD))
            {
                lpDeviceID->dwNeededSize = sizeof(VARSTRING) + 2 * sizeof(DWORD);
                lpDeviceID->dwUsedSize = sizeof(VARSTRING);
            }
            else
            {
                lpDeviceID->dwNeededSize = lpDeviceID->dwUsedSize = sizeof(VARSTRING) + 2 * sizeof(DWORD);
                lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;
                lpDeviceID->dwStringSize = 2 * sizeof(DWORD);
                lpDeviceID->dwStringOffset = sizeof(VARSTRING);
                *(DWORD *)(lpDeviceID + 1) = dwDeviceId1;
                *((DWORD *)(lpDeviceID + 1) + 1) = dwDeviceId2;
            }
        }
        ClientFree (lpDeviceIDTemp);
        return NO_ERROR;
    }
    else
    {
        return (DOFUNC (&funcArgs, "phoneGetID"));
    }
}


LONG
WINAPI
phoneGetIDA(
    HPHONE      hPhone,
    LPVARSTRING lpDeviceID,
    LPCSTR      lpszDeviceClass
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if ( IsBadStringPtrA(lpszDeviceClass, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszDeviceClass in phoneGetIDA"));
        return( PHONEERR_INVALPOINTER );
    }

    szTempPtr = NotSoWideStringToWideString (lpszDeviceClass, (DWORD) -1);

    lResult = phoneGetIDW (hPhone, lpDeviceID, szTempPtr);

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}


LONG
WINAPI
phoneGetID(
    HPHONE      hPhone,
    LPVARSTRING lpDeviceID,
    LPCSTR      lpszDeviceClass
    )
{
    return phoneGetIDA (hPhone, lpDeviceID, lpszDeviceClass);
}


LONG
WINAPI
phoneGetLamp(
    HPHONE hPhone,
    DWORD dwButtonLampID,
    LPDWORD lpdwLampMode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetLamp),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwButtonLampID,
            (ULONG_PTR) lpdwLampMode
        },

        {
            Dword,
            Dword,
            lpDword
        }
    };


    return (DOFUNC (&funcArgs, "phoneGetLamp"));
}



LONG
WINAPI
phoneGetMessage(
    HPHONEAPP       hPhoneApp,
    LPPHONEMESSAGE  lpMessage,
    DWORD           dwTimeout
    )
{
    return (xxxGetMessage(
                FALSE,
                (HLINEAPP) hPhoneApp,
                (LPLINEMESSAGE) lpMessage,
                dwTimeout
                ));
}


LONG
WINAPI
phoneGetRing(
    HPHONE hPhone,
    LPDWORD lpdwRingMode,
    LPDWORD lpdwVolume
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetRing),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) lpdwRingMode,
            (ULONG_PTR) lpdwVolume
        },

        {
            Dword,
            lpDword,
            lpDword
        }
    };


    if (lpdwRingMode == lpdwVolume)
    {
        return PHONEERR_INVALPOINTER;
    }

    return (DOFUNC (&funcArgs, "phoneGetRing"));
}


LONG
WINAPI
phoneGetStatusW(
    HPHONE hPhone,
    LPPHONESTATUS lpPhoneStatus
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 2, pGetStatus),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) lpPhoneStatus
        },

        {
            Dword,
            lpGet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "phoneGetStatus"));
}


LONG
WINAPI
phoneGetStatusA(
    HPHONE hPhone,
    LPPHONESTATUS lpPhoneStatus
    )
{
    LONG lResult;


    lResult = phoneGetStatusW (hPhone, lpPhoneStatus);

    if (lResult == 0)
    {
        WideStringToNotSoWideString(
            (LPBYTE)lpPhoneStatus,
            &lpPhoneStatus->dwOwnerNameSize
            );
    }

    return lResult;
}


LONG
WINAPI
phoneGetStatus(
    HPHONE hPhone,
    LPPHONESTATUS lpPhoneStatus
    )
{
    return phoneGetStatusA (hPhone, lpPhoneStatus);
}


LONG
WINAPI
phoneGetStatusMessages(
    HPHONE  hPhone,
    LPDWORD lpdwPhoneStates,
    LPDWORD lpdwButtonModes,
    LPDWORD lpdwButtonStates
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 4, pGetStatusMessages),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) lpdwPhoneStates,
            (ULONG_PTR) lpdwButtonModes,
            (ULONG_PTR) lpdwButtonStates
        },

        {
            Dword,
            lpDword,
            lpDword,
            lpDword
        }
    };


    if (lpdwPhoneStates == lpdwButtonModes  ||
        lpdwPhoneStates == lpdwButtonStates  ||
        lpdwButtonModes == lpdwButtonStates)
    {
        return PHONEERR_INVALPOINTER;
    }

    return (DOFUNC (&funcArgs, "phoneGetStatusMessages"));
}


LONG
WINAPI
phoneGetVolume(
    HPHONE hPhone,
    DWORD dwHookSwitchDev,
    LPDWORD lpdwVolume
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 3, pGetVolume),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwHookSwitchDev,
            (ULONG_PTR) lpdwVolume
        },

        {
            Dword,
            Dword,
            lpDword
        }
    };


    return (DOFUNC (&funcArgs, "phoneGetVolume"));
}


LONG
WINAPI
phoneInitialize(
    LPHPHONEAPP     lphPhoneApp,
    HINSTANCE       hInstance,
    PHONECALLBACK   lpfnCallback,
    LPCSTR          lpszFriendlyAppName,
    LPDWORD         lpdwNumDevs
    )
{
    LONG    lResult;
    PWSTR   szTempPtr;


    if (lpszFriendlyAppName)
    {
        if (IsBadStringPtrA (lpszFriendlyAppName, (DWORD) -1))
        {
            LOG((TL_ERROR,
                "phoneInitialize: bad lpszFriendlyAppName (x%p)",
                lpszFriendlyAppName
                ));

            return PHONEERR_INVALPOINTER;
        }

        szTempPtr = NotSoWideStringToWideString(
            lpszFriendlyAppName,
            (DWORD) -1
            );
    }
    else
    {
        szTempPtr = NULL;
    }

    //
    // NOTE: the hack below for the lpInitExParam is for 16-bit apps,
    //       since the lpszAppName really points at a
    //       <friendly name>\0<module name>\0 string and we need the
    //       module name in xxxInitialize()
    //

    lResult = (xxxInitialize(
        FALSE,
        (LPVOID) lphPhoneApp,
        hInstance,
        lpfnCallback,
        szTempPtr,
        lpdwNumDevs,
        NULL,
#ifdef _WIN64
        NULL
#else
        (LPLINEINITIALIZEEXPARAMS)
            (((DWORD) lpfnCallback & 0xffff0000) == 0xffff0000 ?
                lpszFriendlyAppName : NULL)
#endif
#if DBG
        ,"phoneInitialize"
#endif
        ));

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}


LONG
WINAPI
phoneInitializeExW(
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCWSTR                     lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    )
{
    if (IsBadDwordPtr (lpdwAPIVersion))
    {
        LOG((TL_ERROR,
            "phoneInitializeExW: bad lpdwAPIVersion (x%p)",
            lpdwAPIVersion
            ));

        return PHONEERR_INVALPOINTER;
    }

    return (xxxInitialize(
        FALSE,
        (LPVOID) lphPhoneApp,
        hInstance,
        lpfnCallback,
        lpszFriendlyAppName,
        lpdwNumDevs,
        lpdwAPIVersion,
        (LPVOID) lpPhoneInitializeExParams
#if DBG
        ,"phoneInitializeExW"
#endif
        ));
}


LONG
WINAPI
phoneInitializeExA(
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCSTR                      lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    )
{
    LONG    lResult;
    PWSTR   szTempPtr = NULL;


    if (lpszFriendlyAppName)
    {
        if (IsBadStringPtrA (lpszFriendlyAppName, (DWORD) -1))
        {
            LOG((TL_ERROR,
                "phoneInitializeExA: bad lpszFriendlyAppName (x%p)",
                lpszFriendlyAppName
                ));

            return PHONEERR_INVALPOINTER;
        }

        szTempPtr = NotSoWideStringToWideString(
            lpszFriendlyAppName,
            (DWORD) -1
            );
    }
    else
    {
        szTempPtr = NULL;
    }

    lResult = phoneInitializeExW(
        lphPhoneApp,
        hInstance,
        lpfnCallback,
        szTempPtr,
        lpdwNumDevs,
        lpdwAPIVersion,
        lpPhoneInitializeExParams
        );

    if (szTempPtr)
    {
        ClientFree (szTempPtr);
    }

    return lResult;
}


LONG
WINAPI
phoneNegotiateAPIVersion(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 7, pNegotiateAPIVersion),

        {
            (ULONG_PTR) hPhoneApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAPILowVersion,
            (ULONG_PTR) dwAPIHighVersion,
            (ULONG_PTR) lpdwAPIVersion,
            (ULONG_PTR) lpExtensionID,
            (ULONG_PTR) sizeof(PHONEEXTENSIONID)
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            lpDword,
            lpGet_SizeToFollow,
            Size
        }
    };

    if (dwAPIHighVersion > TAPI_CURRENT_VERSION)
    {
        funcArgs.Args[3] = TAPI_CURRENT_VERSION;
    }

    if ((LPVOID) lpdwAPIVersion == (LPVOID) lpExtensionID)
    {
        return PHONEERR_INVALPOINTER;
    }

    return (DOFUNC (&funcArgs, "phoneNegotiateAPIVersion"));
}


LONG
WINAPI
phoneNegotiateExtVersion(
    HPHONEAPP   hPhoneApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    DWORD       dwExtLowVersion,
    DWORD       dwExtHighVersion,
    LPDWORD     lpdwExtVersion
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 6, pNegotiateExtVersion),

        {
            (ULONG_PTR) hPhoneApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) dwExtLowVersion,
            (ULONG_PTR) dwExtHighVersion,
            (ULONG_PTR) lpdwExtVersion
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            Dword,
            lpDword
        }
    };


    if (dwAPIVersion > TAPI_CURRENT_VERSION)
    {
        return PHONEERR_INCOMPATIBLEAPIVERSION;
    }

    return (DOFUNC (&funcArgs, "phoneNegotiateExtVersion"));
}


LONG
WINAPI
phoneOpen(
    HPHONEAPP   hPhoneApp,
    DWORD       dwDeviceID,
    LPHPHONE    lphPhone,
    DWORD       dwAPIVersion,
    DWORD       dwExtVersion,
    DWORD_PTR   dwCallbackInstance,
    DWORD       dwPrivilege
    )
{
    DWORD hCallbackInstance = 0;
    LONG    lResult;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 8, pOpen),

        {
            (ULONG_PTR) hPhoneApp,
            (ULONG_PTR) dwDeviceID,
            (ULONG_PTR) lphPhone,
            (ULONG_PTR) dwAPIVersion,
            (ULONG_PTR) dwExtVersion,
            (ULONG_PTR) dwCallbackInstance,
            (ULONG_PTR) dwPrivilege,
            (ULONG_PTR) 0,                  // PHONEOPEN_PARAMS.hRemotePhone
        },

        {
            hXxxApp,
            Dword,
            lpDword,
            Dword,
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    if (dwAPIVersion > TAPI_CURRENT_VERSION)
    {
        return PHONEERR_INCOMPATIBLEAPIVERSION;
    }

    if (0 != dwCallbackInstance)
    {
        hCallbackInstance = NewObject (ghHandleTable, (PVOID)dwCallbackInstance, (PVOID)UIntToPtr(hPhoneApp));
        if (0 == hCallbackInstance)
        {
            return PHONEERR_NOMEM;
        }

        funcArgs.Args[5] = hCallbackInstance;
    }

    lResult = DOFUNC (&funcArgs, "phoneOpen");

    if (lResult && 0 != hCallbackInstance)
    {
        DereferenceObject (ghHandleTable, hCallbackInstance, 1);
    }

    return lResult;
}


LONG
WINAPI
phoneSetButtonInfoW(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 3, pSetButtonInfo),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwButtonLampID,
            (ULONG_PTR) lpButtonInfo
        },

        {
            Dword,
            Dword,
            lpSet_Struct
        }
    };


    return (DOFUNC (&funcArgs, "phoneSetButtonInfo"));
}


LONG
WINAPI
phoneSetButtonInfoA(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    )
{
    LONG                lResult;
    LPPHONEBUTTONINFO   lppbi;


    if (IsBadReadPtr( lpButtonInfo, sizeof(PHONEBUTTONINFO)) ||
        IsBadReadPtr( lpButtonInfo, lpButtonInfo->dwTotalSize))
    {
        LOG((TL_ERROR, "Bad lpButtonInfo - not at least sizeof(PHONEBUTTONINFO)"));
        return PHONEERR_INVALPOINTER;
    }


    //
    // See if there's a need to do this, first
    //

    if ( lpButtonInfo->dwButtonTextSize )
    {
       DWORD dwNewStringSize,
             dwOffset = lpButtonInfo->dwButtonTextOffset,
             dwSize = lpButtonInfo->dwButtonTextSize,
             dwTotalSize = lpButtonInfo->dwTotalSize;


       //
       // Check to see if dwButtonTextSize/Offset is valid before
       // conversion (check against size of 1.0 PHONEBUTTONINFO here
       // (9*DWORD), tapisrv will check again for the appropriate version)
       //

       if ((dwOffset < (9 * sizeof (DWORD))) ||
           (dwOffset >= dwTotalSize) ||
           ((dwOffset + dwSize) > dwTotalSize) ||
           ((dwOffset + dwSize) < dwOffset))
       {
           LOG((TL_ERROR, "phoneSetButtonInfo: dwButtonTextSize/Offset invalid"));
           return PHONEERR_OPERATIONFAILED;
       }


       //
       // Assume the worst for size...
       //

       if (!(lppbi = ClientAlloc (lpButtonInfo->dwTotalSize * sizeof(WCHAR))))
       {
           return PHONEERR_NOMEM;
       }

       CopyMemory( lppbi, lpButtonInfo, lpButtonInfo->dwTotalSize );


       //
       // We _KNOW_ that the old structure was as big as the dwTotalSize
       // so we can put our rebuilt string starting there. Make sure
       // to align new wide string on WORD boundary.
       //

       dwNewStringSize = sizeof(WCHAR) * MultiByteToWideChar(
            GetACP(),
            MB_PRECOMPOSED,
            (LPBYTE)lpButtonInfo + lpButtonInfo->dwButtonTextOffset,
            lpButtonInfo->dwButtonTextSize,
            (PWSTR)((LPBYTE)lppbi + ((dwTotalSize + 1) & 0xfffffffe)),
            lpButtonInfo->dwButtonTextSize
            );

       lppbi->dwTotalSize += dwNewStringSize;

       lppbi->dwButtonTextSize   = dwNewStringSize;
       lppbi->dwButtonTextOffset = (dwTotalSize + 1) & 0xfffffffe;
    }
    else
    {
        lppbi = NULL;
    }


    lResult = phoneSetButtonInfoW(
        hPhone,
        dwButtonLampID,
        lppbi ? lppbi : lpButtonInfo
        );

    if (lppbi)
    {
        ClientFree (lppbi);
    }

    return lResult;
}


LONG
WINAPI
phoneSetButtonInfo(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    )
{
    return phoneSetButtonInfoA (hPhone, dwButtonLampID, lpButtonInfo);
}


LONG
WINAPI
phoneSetData(
    HPHONE  hPhone,
    DWORD   dwDataID,
    LPVOID  const lpData,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 4, pSetData),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwDataID,
            (ULONG_PTR) lpData,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    return (DOFUNC (&funcArgs, "phoneSetData"));
}


LONG
WINAPI
phoneSetDisplay(
    HPHONE  hPhone,
    DWORD   dwRow,
    DWORD   dwColumn,
    LPCSTR  lpsDisplay,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 5, pSetDisplay),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwRow,
            (ULONG_PTR) dwColumn,
            (ULONG_PTR) lpsDisplay,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size
        }
    };


    return (DOFUNC (&funcArgs, "phoneSetDisplay"));
}


LONG
WINAPI
phoneSetGain(
    HPHONE  hPhone,
    DWORD   dwHookSwitchDev,
    DWORD   dwGain
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 3, pSetGain),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwHookSwitchDev,
            (ULONG_PTR) dwGain
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "phoneSetGain"));
}


LONG
WINAPI
phoneSetHookSwitch(
    HPHONE  hPhone,
    DWORD   dwHookSwitchDevs,
    DWORD   dwHookSwitchMode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 3, pSetHookSwitch),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwHookSwitchDevs,
            (ULONG_PTR) dwHookSwitchMode
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    if (!(dwHookSwitchDevs & AllHookSwitchDevs) ||
        (dwHookSwitchDevs & (~AllHookSwitchDevs)))
    {
        return PHONEERR_INVALHOOKSWITCHDEV;
    }

    if (!IsOnlyOneBitSetInDWORD (dwHookSwitchMode) ||
        (dwHookSwitchMode & ~AllHookSwitchModes))
    {
        return PHONEERR_INVALHOOKSWITCHMODE;
    }

    return (DOFUNC (&funcArgs, "phoneSetHookSwitch"));
}


LONG
WINAPI
phoneSetLamp(
    HPHONE  hPhone,
    DWORD   dwButtonLampID,
    DWORD   dwLampMode
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 3, pSetLamp),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwButtonLampID,
            (ULONG_PTR) dwLampMode
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "phoneSetLamp"));
}


LONG
WINAPI
phoneSetRing(
    HPHONE  hPhone,
    DWORD   dwRingMode,
    DWORD   dwVolume
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 3, pSetRing),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwRingMode,
            (ULONG_PTR) dwVolume
        },

        {
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "phoneSetRing"));
}


LONG
WINAPI
phoneSetStatusMessages(
    HPHONE  hPhone,
    DWORD   dwPhoneStates,
    DWORD   dwButtonModes,
    DWORD   dwButtonStates
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | SYNC | 4, pSetStatusMessages),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwPhoneStates,
            (ULONG_PTR) dwButtonModes,
            (ULONG_PTR) dwButtonStates
        },

        {
            Dword,
            Dword,
            Dword,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "phoneSetStatusMessages"));
}


LONG
WINAPI
phoneSetVolume(
    HPHONE  hPhone,
    DWORD   dwHookSwitchDev,
    DWORD   dwVolume
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (PHONE_FUNC | ASYNC | 3, pSetVolume),

        {
            (ULONG_PTR) hPhone,
            (ULONG_PTR) dwHookSwitchDev,
            (ULONG_PTR) dwVolume
        },

        {
            Dword,
            Dword,
            Dword
        }
    };

return (DOFUNC (&funcArgs, "phoneSetVolume"));
}


LONG
WINAPI
phoneShutdown(
    HPHONEAPP   hPhoneApp
    )
{
    return (xxxShutdown ((HLINEAPP) hPhoneApp, FALSE));
}


//
// ------------------------------- tapiXxx ------------------------------------
//

LONG
WINAPI
tapiRequestDrop(
    HWND    hWnd,
    WPARAM  wRequestID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (TAPI_FUNC | SYNC | 2, tRequestDrop),

        {
            (ULONG_PTR) hWnd,
            (ULONG_PTR) wRequestID
        },

        {
            Hwnd,
            Dword
        }
    };


    return (DOFUNC (&funcArgs, "tapiRequestDrop"));
}


LONG
WINAPI
tapiRequestMakeCallW(
    LPCWSTR  lpszDestAddress,
    LPCWSTR  lpszAppName,
    LPCWSTR  lpszCalledParty,
    LPCWSTR  lpszComment
    )
{
    LONG        lResult;
    DWORD       hRequestMakeCallAttempted, dwProxyListSize = 512;
    LPVARSTRING pProxyList;
    FUNC_ARGS funcArgs =
    {
        MAKELONG (TAPI_FUNC | SYNC | 7, tRequestMakeCall),

        {
            (ULONG_PTR) lpszDestAddress,
            (ULONG_PTR) lpszAppName,
            (ULONG_PTR) lpszCalledParty,
            (ULONG_PTR) lpszComment,
            (ULONG_PTR) 0,
            (ULONG_PTR) 0,
            (ULONG_PTR) &hRequestMakeCallAttempted
        },

        {
            lpszW,
            lpszW,
            lpszW,
            lpszW,
            lpGet_Struct,
            Dword,
            lpDword
        }
    };


    if (TAPIIsBadStringPtrW (lpszDestAddress, (DWORD) -1) ||
        (lstrlenW (lpszDestAddress) + 1) > TAPIMAXDESTADDRESSSIZE)
    {
        return TAPIERR_INVALDESTADDRESS;
    }

    if (!lpszAppName)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[1] = Dword;
        funcArgs.Args[1]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!lpszCalledParty)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[2] = Dword;
        funcArgs.Args[2]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!lpszComment)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[3] = Dword;
        funcArgs.Args[3]     = (ULONG_PTR) TAPI_NO_DATA;
    }


    //
    //
    //

    if (!(pProxyList = ClientAlloc (dwProxyListSize)))
    {
        return TAPIERR_NOREQUESTRECIPIENT;
    }

    pProxyList->dwTotalSize = dwProxyListSize;

    funcArgs.Args[4] = (ULONG_PTR) pProxyList;

    if ((lResult = DOFUNC (&funcArgs, "tapiRequestMakeCall")) == 0)
    {
        //
        //
        //

        if (hRequestMakeCallAttempted != 0)
        {
            WCHAR  *pszProxyName, *pszNextProxyName;
            BOOL    bLastAppInList = FALSE, bStartedProxy = FALSE;


            pszProxyName =
            pszNextProxyName =
                (WCHAR *)(((LPBYTE) pProxyList) + pProxyList->dwStringOffset);


            while (!bLastAppInList)
            {
                while (1)
                {
                    if (*pszNextProxyName == 0)
                    {
                        bLastAppInList = TRUE;
                        break;
                    }
                    else if (*pszNextProxyName == L'"')
                    {
                        *pszNextProxyName = 0;
                        pszNextProxyName++;
                        break;
                    }

                    pszNextProxyName++;
                }

                //
                // Fake layer to get a local struct
                //
                {
                    FARPROC pShellExecuteEx = NULL;
                    HINSTANCE hInst;

                    LPTSTR pszBuffer;
                    DWORD dwSize = lstrlenW(pszProxyName)+1;

                    SHELLEXECUTEINFO sei =
                    {
                        sizeof(SHELLEXECUTEINFO),
                        0,
                        0,              // hWnd
                        NULL,           //"Open"
                        NULL,           // lpFile
                        NULL,
                        NULL,           //Directory
                        SW_MINIMIZE,
                        NULL            //hProcess - huh?
                    };

                    pszBuffer = (LPTSTR)ClientAlloc(dwSize*sizeof(TCHAR));
                    SHUnicodeToTChar(pszProxyName, pszBuffer, dwSize );
                    sei.lpFile = pszBuffer;

                    hInst = LoadLibrary( TEXT("shell32.dll") );
                    if (NULL != hInst)
                    {
                        pShellExecuteEx = GetProcAddress(
                            hInst,
    #ifdef UNICODE
                            "ShellExecuteExW"
    #else
                            "ShellExecuteEx"
    #endif
                            );

                        if (pShellExecuteEx && pShellExecuteEx(&sei) == TRUE)
                        {
                            bStartedProxy = TRUE;
                            ClientFree(pszBuffer);
                            break;
                        }
                        else
#if DBG
                        {
                            LOG((TL_ERROR,
                                "tapiRequestMakeCall: ShellExecuteExW(%ls) error - x%x",
                                pszProxyName,
                                GetLastError()
                                ));
                        }
#else
                            LOG((TL_ERROR,
                                "tapiRequestMakeCall: ShellExecuteExW error - x%x",
                                GetLastError()
                                ));

#endif
                        ClientFree(pszBuffer);
                        FreeLibrary( hInst );
                    }
                    else
                    {
                        LOG((TL_ERROR,
                            "tapiRequestMakeCall: LoadLibrary(shell32.dll) failed - x%x",
                            GetLastError()
                            ));
                    }

                }

                pszProxyName = pszNextProxyName;
            }

            if (bStartedProxy == FALSE)
            {
                //
                // Alert tapisrv that it needs to free the ReqMakeCall inst
                //

                FUNC_ARGS funcArgs =
                {
                    MAKELONG (TAPI_FUNC | SYNC | 7, tRequestMakeCall),

                    {
                        (ULONG_PTR) 0,
                        (ULONG_PTR) 0,
                        (ULONG_PTR) 0,
                        (ULONG_PTR) 0,
                        (ULONG_PTR) 0,
                        (ULONG_PTR) hRequestMakeCallAttempted,
                        (ULONG_PTR) 0
                    },

                    {
                        Dword,
                        Dword,
                        Dword,
                        Dword,
                        Dword,
                        Dword,
                        Dword,
                    }
                };


                LOG((TL_ERROR,
                    "tapiRequestMakeCall: failed to start proxy, deleting request"
                    ));

                lResult = DOFUNC (&funcArgs, "tapiRequestMakeCall_cleanup");
            }
        }
    }

    ClientFree (pProxyList);

    return lResult;
}


LONG
WINAPI
tapiRequestMakeCallA(
    LPCSTR  lpszDestAddress,
    LPCSTR  lpszAppName,
    LPCSTR  lpszCalledParty,
    LPCSTR  lpszComment
    )
{
    LONG    lResult;
    PWSTR   szTempPtr1;
    PWSTR   szTempPtr2;
    PWSTR   szTempPtr3;
    PWSTR   szTempPtr4;


    if (IsBadStringPtrA (lpszDestAddress, (DWORD) -1) ||
        (lstrlenA (lpszDestAddress) + 1) > TAPIMAXDESTADDRESSSIZE)
    {
        return TAPIERR_INVALDESTADDRESS;
    }

    if ((lpszAppName && IsBadStringPtrA (lpszAppName, (DWORD) -1)) ||
        (lpszCalledParty && IsBadStringPtrA (lpszCalledParty, (DWORD) -1)) ||
        (lpszComment && IsBadStringPtrA (lpszComment, (DWORD) -1)))
    {
        return TAPIERR_INVALPOINTER;
    }

    szTempPtr1= NotSoWideStringToWideString (lpszDestAddress, (DWORD) -1);

    if ( !szTempPtr1 )
    {
        return TAPIERR_INVALPOINTER;
    }

    szTempPtr2= NotSoWideStringToWideString (lpszAppName, (DWORD) -1);
    szTempPtr3= NotSoWideStringToWideString (lpszCalledParty, (DWORD) -1);
    szTempPtr4= NotSoWideStringToWideString (lpszComment, (DWORD) -1);

    lResult = tapiRequestMakeCallW(
        szTempPtr1,
        szTempPtr2,
        szTempPtr3,
        szTempPtr4
        );

    ClientFree (szTempPtr1);

    if (szTempPtr2)
    {
        ClientFree (szTempPtr2);
    }

    if (szTempPtr3)
    {
        ClientFree (szTempPtr3);
    }

    if (szTempPtr4)
    {
        ClientFree (szTempPtr4);
    }

    return lResult;
}


LONG
WINAPI
tapiRequestMakeCall(
    LPCSTR  lpszDestAddress,
    LPCSTR  lpszAppName,
    LPCSTR  lpszCalledParty,
    LPCSTR  lpszComment
    )
{
    return tapiRequestMakeCallA(
                lpszDestAddress,
                lpszAppName,
                lpszCalledParty,
                lpszComment
                );
}


LONG
WINAPI
tapiRequestMediaCallW(
    HWND    hWnd,
    WPARAM  wRequestID,
    LPCWSTR lpszDeviceClass,
    LPCWSTR lpDeviceID,
    DWORD   dwSize,
    DWORD   dwSecure,
    LPCWSTR lpszDestAddress,
    LPCWSTR lpszAppName,
    LPCWSTR lpszCalledParty,
    LPCWSTR lpszComment
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (TAPI_FUNC | SYNC | 10, tRequestMediaCall),

        {
            (ULONG_PTR) hWnd,
            (ULONG_PTR) wRequestID,
            (ULONG_PTR) lpszDeviceClass,
            (ULONG_PTR) lpDeviceID,
            (ULONG_PTR) dwSize,
            (ULONG_PTR) dwSecure,
            (ULONG_PTR) lpszDestAddress,
            (ULONG_PTR) lpszAppName,
            (ULONG_PTR) lpszCalledParty,
            (ULONG_PTR) lpszComment,
        },

        {
            Hwnd,
            Dword,
            lpszW,
            lpGet_SizeToFollow,
            Size,
            Dword,
            lpszW,
            lpszW,
            lpszW,
            lpszW
        }
    };


    if (TAPIIsBadStringPtrW (lpszDeviceClass, (UINT) -1) ||
        (lstrlenW (lpszDeviceClass) + 1) > TAPIMAXDEVICECLASSSIZE)
    {
        return TAPIERR_INVALDEVICECLASS;
    }

    if (IsBadWritePtr ((LPVOID) lpDeviceID, dwSize) ||
        dwSize > (TAPIMAXDEVICEIDSIZE * sizeof (WCHAR)))
    {
        return TAPIERR_INVALDEVICEID;
    }

    if (TAPIIsBadStringPtrW (lpszDestAddress, (UINT) -1) ||
        (lstrlenW (lpszDestAddress) + 1) > TAPIMAXDESTADDRESSSIZE)
    {
        return TAPIERR_INVALDESTADDRESS;
    }

    if (!lpszAppName)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[7] = Dword;
        funcArgs.Args[7]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!lpszCalledParty)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[8] = Dword;
        funcArgs.Args[8]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    if (!lpszComment)
    {
        //
        // Reset Arg & ArgType so no inval ptr err, & TAPI_NO_DATA is indicated
        //

        funcArgs.ArgTypes[9] = Dword;
        funcArgs.Args[9]     = (ULONG_PTR) TAPI_NO_DATA;
    }

    return (DOFUNC (&funcArgs, "tapiRequestMediaCall"));
}


LONG
WINAPI
tapiRequestMediaCallA(
    HWND    hWnd,
    WPARAM  wRequestID,
    LPCSTR  lpszDeviceClass,
    LPCSTR  lpDeviceID,
    DWORD   dwSize,
    DWORD   dwSecure,
    LPCSTR  lpszDestAddress,
    LPCSTR  lpszAppName,
    LPCSTR  lpszCalledParty,
    LPCSTR  lpszComment
    )
{
    LONG    lResult;
    PWSTR   szTempPtr1 = NULL, szTempPtr2 = NULL, szTempPtr3 = NULL,
            szTempPtr4 = NULL, szTempPtr5 = NULL, szTempPtr6 = NULL;


    if (IsBadStringPtrA (lpszDeviceClass, (UINT) -1) ||
        (lstrlenA (lpszDeviceClass) + 1) > TAPIMAXDEVICECLASSSIZE)
    {
        lResult = TAPIERR_INVALDEVICECLASS;
        goto ExitHere;
    }
    else
    {
        szTempPtr1 = NotSoWideStringToWideString(
            lpszDeviceClass,
            (DWORD) -1
            );
    }

    if (IsBadWritePtr ((LPVOID) lpDeviceID, dwSize) ||
        dwSize > TAPIMAXDEVICEIDSIZE)
    {
        lResult = TAPIERR_INVALDEVICEID;
        goto ExitHere;
    }
    else
    {
        dwSize *= 2;
        szTempPtr2 = ClientAlloc (dwSize);
    }

    if (IsBadStringPtrA (lpszDestAddress, (UINT) -1) ||
        (lstrlenA (lpszDestAddress) + 1) > TAPIMAXDESTADDRESSSIZE)
    {
        lResult = TAPIERR_INVALDESTADDRESS;
        goto ExitHere;
    }
    else
    {
        szTempPtr3 = NotSoWideStringToWideString(
            lpszDestAddress,
            (DWORD) -1
            );
    }

    if ((lpszAppName && IsBadStringPtrA (lpszAppName, (UINT) -1)) ||
        (lpszCalledParty && IsBadStringPtrA (lpszCalledParty, (UINT) -1)) ||
        (lpszComment && IsBadStringPtrA (lpszComment, (UINT) -1)))
    {
        lResult = TAPIERR_INVALPOINTER;
        goto ExitHere;
    }

    szTempPtr4 = NotSoWideStringToWideString (lpszAppName, (DWORD) -1);
    szTempPtr5 = NotSoWideStringToWideString (lpszCalledParty, (DWORD) -1);
    szTempPtr6 = NotSoWideStringToWideString (lpszComment, (DWORD) -1);

    lResult = tapiRequestMediaCallW(
        hWnd,
        wRequestID,
        szTempPtr1,
        szTempPtr2,
        dwSize,
        dwSecure,
        szTempPtr3,
        szTempPtr4,
        szTempPtr5,
        szTempPtr6
        );

ExitHere:
    if (szTempPtr1)
    {
        ClientFree (szTempPtr1);
    }

    if (szTempPtr2)
    {
        ClientFree (szTempPtr2);
    }

    if (szTempPtr3)
    {
        ClientFree (szTempPtr3);
    }

    if (szTempPtr4)
    {
        ClientFree (szTempPtr4);
    }

    if (szTempPtr5)
    {
        ClientFree (szTempPtr5);
    }

    if (szTempPtr6)
    {
        ClientFree (szTempPtr6);
    }

    return lResult;
}


LONG
WINAPI
tapiRequestMediaCall(
    HWND    hWnd,
    WPARAM  wRequestID,
    LPCSTR  lpszDeviceClass,
    LPCSTR  lpDeviceID,
    DWORD   dwSize,
    DWORD   dwSecure,
    LPCSTR  lpszDestAddress,
    LPCSTR  lpszAppName,
    LPCSTR  lpszCalledParty,
    LPCSTR  lpszComment
    )
{
    return  tapiRequestMediaCallA(
                hWnd,
                wRequestID,
                lpszDeviceClass,
                lpDeviceID,
                dwSize,
                dwSecure,
                lpszDestAddress,
                lpszAppName,
                lpszCalledParty,
                lpszComment
                );
}


//
// ----------------------------------------------------------------------------
//

LONG
WINAPI
GetTapi16CallbackMsg(
    PINIT_DATA  pInitData,
    LPDWORD     pMsg
    )
{
    LONG lResult = 0;


    LOG((TL_TRACE, "GetTapi16CallbackMsg: enter"));

    EnterCriticalSection (&gCriticalSection);

    try
    {
        if (pInitData->dwKey != INITDATA_KEY)
        {
            goto GetTapi16CallbackMsg_leaveCritSec;
        }
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        goto GetTapi16CallbackMsg_leaveCritSec;
    }

    if (pInitData->dwNumUsedEntries > 0)
    {
        CopyMemory(
            pMsg,
            pInitData->pValidEntry,
            sizeof(ASYNC_EVENT_PARAMS)
            );

        pInitData->pValidEntry++;

        if (pInitData->pValidEntry >= (pInitData->pEventBuffer +
                pInitData->dwNumTotalEntries))
        {
            pInitData->pValidEntry = pInitData->pEventBuffer;
        }

        pInitData->dwNumUsedEntries--;

        if (pInitData->dwNumUsedEntries == 0)
        {
            pInitData->bPendingAsyncEventMsg = FALSE;
        }

        lResult = 1;
    }

GetTapi16CallbackMsg_leaveCritSec:

    LeaveCriticalSection (&gCriticalSection);

    LOG((TL_TRACE, "GetTapi16CallbackMsg: exit (result=x%x)", lResult));

    return lResult;
}




//
// ----------------------- Private support routines ---------------------------
//

void
FreeInitData(
    PINIT_DATA  pInitData
    )
{
    EnterCriticalSection (&gCriticalSection);

    if (pInitData && ( pInitData->dwKey != 0xefefefef ) )
    {
        pInitData->dwKey = 0xefefefef;

        LeaveCriticalSection (&gCriticalSection);

        if ((pInitData->dwInitOptions & 0x3) ==
                LINEINITIALIZEEXOPTION_USEEVENT)
        {
            if (pInitData->hEvent)
            {
                //
                // Signal the event to release any threads which might
                // be waiting on it, then close the handle
                //

                SetEvent (pInitData->hEvent);
                CloseHandle (pInitData->hEvent);
            }
        }
        else if ((pInitData->dwInitOptions & 0x3) ==
                    LINEINITIALIZEEXOPTION_USEHIDDENWINDOW)
        {
            // NOTE: let thunk destroy it's own window

            if (pInitData->hwnd && !gbNTVDMClient)
            {
                //
                // If this is the thread which created the window
                // then we can destroy the window in line.  Otherwise,
                // post a message telling the window to destroy itself.
                //

                if (pInitData->dwThreadID == GetCurrentThreadId())
                {
                    DestroyWindow (pInitData->hwnd);
                }
                else
                {
                    PostMessage(
                        pInitData->hwnd,
                        WM_ASYNCEVENT,
                        (WPARAM) gdwInitialTickCount,
                        (LPARAM) 0xffffffff
                        );
                }
            }
        }

        if (pInitData->pEventBuffer)
        {
            ClientFree (pInitData->pEventBuffer);
        }

        DereferenceObject (ghHandleTable, pInitData->hInitData, 1);
		ClientFree (pInitData);
    }
    else
    {
        LeaveCriticalSection (&gCriticalSection);
    }

}

INT_PTR
CALLBACK
TAPIWndProc(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    switch (msg)
    {
    case WM_ASYNCEVENT:
    {
        BOOL                bFirstPass = TRUE, bPostMsg;
        PINIT_DATA          pInitData = (PINIT_DATA) lParam;


        LOG((TL_TRACE, "TAPIWndProc: received WM_ASYNCEVENT, hwnd=x%p", hwnd));

        if (lParam == (LPARAM) 0xffffffff)
        {
            if (wParam == (WPARAM) gdwInitialTickCount)
            {
                DestroyWindow (hwnd);
            }

            return FALSE;
        }

        while (1)
        {
            //
            // Enter the critical section, verify the pInitData, and
            // see if there are any events in in the queue to process.
            // If so, remove an event from the queue, adjust the
            // ptrs & count, leave the critical section, and call
            // the callback.
            //
            // Note that there is some tricky stuff below to insure
            // that there is always another outstanding WM_ASYNCEVENT
            // msg prior to calling the app's callback (if there are)
            // any more events inthe queue.  This is necessary because
            // some ill-behaved apps have msg loops (to synchronously
            // wait for async request results, etc) within their
            // callbacks, and we don't want to block sending any msgs
            // to them.
            //

            EnterCriticalSection (&gCriticalSection);

            try
            {
                if (pInitData->dwKey != INITDATA_KEY)
                {
                    LOG((TL_ERROR, "TAPIWndProc: bad pInitInst (x%p)", pInitData));
                    LeaveCriticalSection (&gCriticalSection);
                    break;
                }
            }
            except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
            {
                LOG((TL_ERROR, "TAPIWndProc: bad pInitInst (x%p)", pInitData));
                LeaveCriticalSection (&gCriticalSection);
                break;
            }

            if (bFirstPass)
            {
                pInitData->bPendingAsyncEventMsg = FALSE;
                bFirstPass = FALSE;
            }

            if (pInitData->dwNumUsedEntries != 0)
            {
                ASYNC_EVENT_PARAMS      event;
                LINECALLBACK            lpfnCallback;

                CopyMemory(
                    &event,
                    pInitData->pValidEntry,
                    sizeof (ASYNC_EVENT_PARAMS)
                    );

                pInitData->pValidEntry++;

                if (pInitData->pValidEntry >= (pInitData->pEventBuffer +
                        pInitData->dwNumTotalEntries))
                {
                    pInitData->pValidEntry = pInitData->pEventBuffer;
                }

                pInitData->dwNumUsedEntries--;

                if (pInitData->dwNumUsedEntries != 0 &&
                    pInitData->bPendingAsyncEventMsg == FALSE)
                {
                    bPostMsg = TRUE;
                    pInitData->bPendingAsyncEventMsg = TRUE;
                }

                lpfnCallback = pInitData->lpfnCallback;

                LeaveCriticalSection (&gCriticalSection);

                LOG((TL_INFO,
                    "Calling app's callback, hDev=x%x, "\
                        "Msg=%d, dwInst=x%lx P1=x%lx, P2=x%x P3=x%lx",
                    event.hDevice,
                    event.dwMsg,
                    event.dwCallbackInstance,
                    event.dwParam1,
                    event.dwParam2,
                    event.dwParam3
                    ));

                if (bPostMsg)
                {
                    PostMessage (hwnd, WM_ASYNCEVENT, wParam, lParam);
                }

                (*lpfnCallback)(
                    event.hDevice,
                    event.dwMsg,
                    event.dwCallbackInstance,
                    event.dwParam1,
                    event.dwParam2,
                    event.dwParam3
                    );

            }
            else
            {
                LOG((TL_TRACE, "No entries - spurious entry."));

                LeaveCriticalSection (&gCriticalSection);

                break;
            }
        }

        return FALSE;
    }
    default:

        break;
    }

    return (DefWindowProc (hwnd, msg, wParam, lParam));
}

LONG
CreateHiddenWindow(
    HWND   *lphwnd,
    DWORD   dwErrorClass
    )
{
    LONG lResult = 0;

    //
    // Register the hidden window class
    //
    if (!gbHiddenWndClassRegistered)
    {
        DWORD       dwError;
        WNDCLASS    wndclass;


        ZeroMemory(&wndclass, sizeof(WNDCLASS));

        wndclass.lpfnWndProc   = (WNDPROC) TAPIWndProc;
        wndclass.hInstance     = g_hInst;
        wndclass.lpszClassName = szTapi32WndClass;

        if (!RegisterClass (&wndclass) &&
            ((dwError = GetLastError()) != ERROR_CLASS_ALREADY_EXISTS))
        {
           LOG((TL_ERROR,
               "CreateHiddenWindow: RegisterClass failed, err=%d",
               dwError
               ));
        }
        else
        {
            gbHiddenWndClassRegistered = TRUE;
        }
    }

    if (!(*lphwnd = CreateWindow(
            szTapi32WndClass,   // class name
            NULL,               // title
            WS_OVERLAPPED | WS_MINIMIZE,  // 0,           // dwStyle
            0,                  // x
            0,                  // y
            0,                  // width
            0,                  // height
            (HWND) NULL,        // parent wnd
            (HMENU) NULL,       // menu
            g_hInst,             // instance
            NULL                // params
            )))
    {
        LOG((TL_ERROR, "CreateWindow failed, err=%ld", GetLastError()));

        lResult = gaOpFailedErrors[dwErrorClass];
    }

    return lResult;
}



void __RPC_FAR * __RPC_API midl_user_allocate(size_t len)
{
    LOG((TL_TRACE, "midl_user_allocate: enter, size=x%x", len));

    return (ClientAlloc (len));
}


void __RPC_API midl_user_free(void __RPC_FAR * ptr)
{
    LOG((TL_TRACE, "midl_user_free: enter, p=x%p", ptr));

    ClientFree (ptr);
}

LONG
WINAPI
ReAllocClientResources(
    DWORD dwErrorClass
    )
{
    LONG            lResult;
    DWORD           dwRefCountTemp;


    LOG((TL_TRACE, "AllocClientResources: enter"));

    WaitForSingleObject (ghInitMutex, INFINITE);

    if (0 == gdwRpcRefCount)
    {
        ReleaseMutex (ghInitMutex);
        return TAPIERR_REQUESTFAILED;
    }
    
    dwRefCountTemp = gdwRpcRefCount;
    gdwRpcRefCount = 1;
    FreeClientResources ();
    lResult = AllocClientResources(dwErrorClass);
    if (TAPI_SUCCESS == lResult)
    {
        gdwRpcRefCount = dwRefCountTemp;
    }
    else
    {
        gdwRpcRefCount = 0;
    }

    ReleaseMutex (ghInitMutex);
    return lResult;
}

LONG
WINAPI
AllocClientResources(
    DWORD dwErrorClass
    )
{
    DWORD           dwExceptionCount = 0;
    DWORD           dwError = 0;
    LONG            lResult = gaOpFailedErrors[dwErrorClass];
    SC_HANDLE       hSCMgr = NULL, hTapiSrv = NULL;


    LOG((TL_TRACE, "AllocClientResources: enter"));


    //
    // If we're in safeboot mode, tapisrv won't start;
    // fail initialization.
    //
    if (0 != GetSystemMetrics (SM_CLEANBOOT))
    {
        lResult = gaOpFailedErrors[dwErrorClass];

        goto AllocClientResources_return;
    }

    //
    // Serialize the following init code
    //

    WaitForSingleObject (ghInitMutex, INFINITE);

    if (0 != gdwRpcRefCount)
    {
        gdwRpcRefCount++;
        lResult = TAPI_SUCCESS;

        goto AllocClientResources_return;
    }

    //
    // Start the TAPISRV.EXE service
    //

    if ((hSCMgr = OpenSCManager(
            NULL,               // local machine
            NULL,               // ServicesActive database
            SC_MANAGER_CONNECT  // desired access
            )) == NULL)
    {
        dwError = GetLastError();
        LOG((TL_ERROR, "OpenSCManager failed, err=%d", dwError ));

        if ( ERROR_ACCESS_DENIED == dwError ||
             ERROR_NOACCESS == dwError
           )
        {
            // if OpenSCManager fails with ACCESS_DENIED, 
            // we still need to try to attach to TAPISRV
            goto AllocClientResources_attachToServer;
        }
        else
        {
            goto AllocClientResources_return;
        }
    }

    if ((hTapiSrv = OpenService(
            hSCMgr,                 // SC mgr handle
            TEXT("TAPISRV"),        // name of service to open
            SERVICE_START |         // desired access
                SERVICE_QUERY_STATUS
            )) == NULL)
    {
        dwError = GetLastError();
        LOG((TL_ERROR, "OpenService failed, err=%d", dwError));

        if ( ERROR_ACCESS_DENIED == dwError ||
             ERROR_NOACCESS == dwError
           )
        {
            // if OpenService fails with ACCESS_DENIED, 
            // we still need to try to attach to TAPISRV
            goto AllocClientResources_attachToServer;
        }
        else
        {
            goto AllocClientResources_cleanup1;
        }
    }

AllocClientResources_queryServiceStatus:

    {
        #define MAX_NUM_SECONDS_TO_WAIT_FOR_TAPISRV 180

        DWORD   dwNumSecondsSleptStartPending = 0,
                dwNumSecondsSleptStopPending = 0;

        while (1)
        {
            SERVICE_STATUS  status;


            QueryServiceStatus (hTapiSrv, &status);

            switch (status.dwCurrentState)
            {
            case SERVICE_RUNNING:

                LOG((TL_INFO, "Tapisrv running"));
                goto AllocClientResources_attachToServer;

            case SERVICE_START_PENDING:

                Sleep (1000);

                if (++dwNumSecondsSleptStartPending >
                        MAX_NUM_SECONDS_TO_WAIT_FOR_TAPISRV)
                {
                    LOG((TL_ERROR,
                        "ERROR: Tapisrv stuck SERVICE_START_PENDING"
                        ));

                    goto AllocClientResources_cleanup2;
                }

                break;

            case SERVICE_STOP_PENDING:

                Sleep (1000);

                if (++dwNumSecondsSleptStopPending >
                        MAX_NUM_SECONDS_TO_WAIT_FOR_TAPISRV)
                {
                    LOG((TL_ERROR,
                        "ERROR: Tapisrv stuck SERVICE_STOP_PENDING"
                        ));

                    goto AllocClientResources_cleanup2;
                }

                break;

            case SERVICE_STOPPED:

                LOG((TL_TRACE, "Starting tapisrv (NT)..."));

                if (!StartService(
                        hTapiSrv,   // service handle
                        0,          // num args
                        NULL        // args
                        ))
                {
                    DWORD dwLastError = GetLastError();


                    if (dwLastError != ERROR_SERVICE_ALREADY_RUNNING)
                    {
                        LOG((TL_ERROR,
                            "StartService(TapiSrv) failed, err=%d",
                            dwLastError
                            ));

                        goto AllocClientResources_cleanup2;
                    }
                }

                break;

            default:

                LOG((TL_ERROR,
                    "error, service status=%d",
                    status.dwCurrentState
                    ));

                goto AllocClientResources_cleanup2;
            }
        }
    }

    //
    // Init the RPC connection
    //

AllocClientResources_attachToServer:

    {
        #define CNLEN              25   // computer name length
        #define UNCLEN        CNLEN+2   // \\computername
        #define PATHLEN           260   // Path
        #define MAXPROTSEQ         20   // protocol sequence "ncacn_np"

        BOOL            bException = FALSE;
        RPC_STATUS      status;
        TCHAR           pszNetworkAddress[UNCLEN+1];
        LPTSTR          pszUuid          = NULL;
        LPTSTR          pszOptions       = NULL;
        LPTSTR          pszStringBinding = NULL;
        LPTSTR          pszBuffer;
        DWORD          dwProcessID = GetCurrentProcessId(), dwSize = 256;
        WCHAR         *pszUserName = ClientAlloc (dwSize * sizeof(WCHAR) );
        WCHAR         *pszComputerName = ClientAlloc(
                            (MAX_COMPUTERNAME_LENGTH+1) * sizeof(WCHAR)
                            );


        pszNetworkAddress[0] = TEXT('\0');

        status = RpcStringBindingCompose(
            pszUuid,
            TEXT("ncalrpc"),
            pszNetworkAddress,
            TEXT("tapsrvlpc"),
            pszOptions,
            &pszStringBinding
            );

        if (status)
        {
            LOG((TL_ERROR,
                "RpcStringBindingCompose failed: err=%d, szNetAddr='%s'",
                status,
                pszNetworkAddress
                ));
            lResult = gaOpFailedErrors[dwErrorClass];
            ClientFree (pszUserName);
            ClientFree (pszComputerName);
            goto AllocClientResources_cleanup2;
        }

        status = RpcBindingFromStringBinding(
            pszStringBinding,
            &hTapSrv
            );

        if (status)
        {
            LOG((TL_ERROR,
                "RpcBindingFromStringBinding failed, err=%d, szBinding='%s'",
                status,
                pszStringBinding
                ));
            lResult = gaOpFailedErrors[dwErrorClass];
            RpcStringFree(&pszStringBinding);
            ClientFree (pszUserName);
            ClientFree (pszComputerName);
            goto AllocClientResources_cleanup2;
        }

        pszBuffer = (LPTSTR)ClientAlloc( (dwSize>(MAX_COMPUTERNAME_LENGTH+1)?dwSize:(MAX_COMPUTERNAME_LENGTH+1) ) * sizeof(TCHAR));
        if ( NULL == pszBuffer )
        {
            LOG((TL_ERROR, "Mem alloc of 0x%lx bytes failed(ca1)", dwSize ));
            lResult = gaOpFailedErrors[dwErrorClass];
            RpcStringFree(&pszStringBinding);
            ClientFree (pszUserName);
            ClientFree (pszComputerName);
            goto AllocClientResources_cleanup2;
        }

        GetUserName(pszBuffer, &dwSize);
        SHTCharToUnicode(pszBuffer, pszUserName, 256);

        dwSize = (MAX_COMPUTERNAME_LENGTH+1);
        GetComputerName( pszBuffer, &dwSize );
        SHTCharToUnicode(pszBuffer, pszComputerName, MAX_COMPUTERNAME_LENGTH+1);

        ClientFree(pszBuffer);

        RpcTryExcept
        {
            LOG((TL_TRACE, "AllocCliRes: calling ClientAttach..."));

            lResult = ClientAttach(
                (PCONTEXT_HANDLE_TYPE *) &gphCx,
                dwProcessID,
                (long *) &ghAsyncEventsEvent,
                pszUserName,
                pszComputerName
                );

            LOG((TL_TRACE, "AllocCliRes: ClientAttach returned x%x", lResult));
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
        {
            LOG((TL_ERROR,
                "AllocCliRes: ClientAttach caused except=%d",
                RpcExceptionCode()
                ));
            bException = TRUE;
        }
        RpcEndExcept

        ClientFree (pszUserName);
        ClientFree (pszComputerName);

        RpcBindingFree (&hTapSrv);


        RpcStringFree(&pszStringBinding);

        if (bException)
        {

            // 
            // Make sure we don't leak the handle duplicated in ClientAttach
            //
            if (ghAsyncEventsEvent)
            {
                CloseHandle (ghAsyncEventsEvent);
                ghAsyncEventsEvent = NULL;
            }

            //
            // If here chances are that we started the service and it's
            // not ready to receive rpc requests. So we'll give it a
            // little time to get rolling and then try again.
            //

            if (dwExceptionCount < gdwMaxNumRequestRetries)
            {
                Sleep ((++dwExceptionCount > 1 ? gdwRequestRetryTimeout : 0));

                if (hTapiSrv)     // Win NT && successful OpenService()
                {
                    goto AllocClientResources_queryServiceStatus;
                }
                else
                {
                    goto AllocClientResources_attachToServer;
                }
            }
            else
            {
                LOG((TL_ERROR,
                    "AllocCliRes: ClientAttach failed, result=x%x",
                    gaServiceNotRunningErrors[dwErrorClass]
                    ));

                lResult = gaServiceNotRunningErrors[dwErrorClass];
            }
        }
    }

    if (lResult == 0)
    {
        gdwRpcRefCount++;
    }


AllocClientResources_cleanup2:

    if (hTapiSrv) 
    {
        CloseServiceHandle (hTapiSrv);
    }

AllocClientResources_cleanup1:

    if (hSCMgr)
    {
        CloseServiceHandle (hSCMgr);
    }

AllocClientResources_return:

    ReleaseMutex (ghInitMutex);

    LOG((TL_TRACE, "AllocClientResources: exit, returning x%x", lResult));

    return lResult;
}


LONG
PASCAL
xxxShutdown(
    HLINEAPP    hXXXApp,
    BOOL        bLineShutdown
    )
{

//NOTE NOTE NOTE NOTE NOTE NOTE
//NOTE NOTE NOTE NOTE NOTE NOTE
// There is "identical" code in lineShutdownInt - if this changes that should
// probably change as well!!!!!

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 1, (bLineShutdown ? lShutdown:pShutdown)),

        {
            (ULONG_PTR) hXXXApp
        },

        {
            hXxxApp
        }
    };
    LONG lResult;


    WaitForSingleObject (ghInitMutex, INFINITE);

    lResult = DOFUNC(
        &funcArgs,
        (bLineShutdown ? "lineShutdown" : "phoneShutdown")
        );

    if (lResult == 0)
    {
        PINIT_DATA  pInitData;

        ReleaseAllHandles (ghHandleTable, (PVOID)UIntToPtr(hXXXApp));

        if ((pInitData = ReferenceObject (ghHandleTable, hXXXApp, 0)))
        {
            DereferenceObject (ghHandleTable, hXXXApp, 1);
            FreeInitData (pInitData);
        }

        EnterCriticalSection (&gCriticalSection);

        gdwNumInits--;

        if (gdwNumInits == 0)
        {

            //
            // Tell the async events thread to quit
            //

            gpAsyncEventsThreadParams->bExitThread = TRUE;
            SetEvent (ghAsyncEventsEvent);

            gpAsyncEventsThreadParams = NULL;


            //
            // Safely close any existing generic dialog instances
            //

            if (gpUIThreadInstances)
            {
                PUITHREADDATA   pUIThreadData, pNextUIThreadData;


                pUIThreadData = gpUIThreadInstances;

                while (pUIThreadData)
                {
                    //
                    // Grab a ptr to the next UIThreadData while it's still
                    // safe, wait until the ui dll has indicated that it
                    // is will to receive generic dlg data, then pass it
                    // NULL/0 to tell it to shutdown the dlg inst
                    //

                    pNextUIThreadData = pUIThreadData->pNext;

                    WaitForSingleObject (pUIThreadData->hEvent, INFINITE);

                    LOG((TL_TRACE,
                        "xxxShutdown: calling " \
                            "TUISPI_providerGenericDialogData..."
                        ));

                    (*pUIThreadData->pfnTUISPI_providerGenericDialogData)(
                        pUIThreadData->htDlgInst,
                        NULL,
                        0
                        );

                    LOG((TL_TRACE,
                        "xxxShutdown: " \
                            "TUISPI_providerGenericDialogData returned"
                        ));

                    pUIThreadData = pNextUIThreadData;
                }
            }

            //
            // Free up any other resources we were using
            //

            if (ghWow32Dll)
            {
                FreeLibrary (ghWow32Dll);
                ghWow32Dll = NULL;
            }

            //  Disable tracing after last line shutdown
            TRACELOGDEREGISTER();
        }

        LeaveCriticalSection (&gCriticalSection);
        //
        // Remove the RPC ref count added in lineInitialize
        // 
        FreeClientResources();
    }

    ReleaseMutex (ghInitMutex);

    return lResult;
}


LONG
PASCAL
xxxGetMessage(
    BOOL            bLine,
    HLINEAPP        hXxxApp,
    LPLINEMESSAGE   pMsg,
    DWORD           dwTimeout
    )
{
    LONG        lResult;
    BOOL        bInCriticalSection = FALSE;
    PINIT_DATA  pInitData;


    if (IsBadWritePtr (pMsg, sizeof (LINEMESSAGE)))
    {
        lResult = (bLine ? LINEERR_INVALPOINTER : PHONEERR_INVALPOINTER);
        goto xxxGetMessage_return2;
    }

    if (!(pInitData = (PINIT_DATA) ReferenceObject(
            ghHandleTable,
            hXxxApp,
            INITDATA_KEY
            )))
    {
        LOG((TL_ERROR, "xxxGetMessage:  hXxxApp=x%x invalid", hXxxApp));

        lResult = (bLine ? LINEERR_INVALAPPHANDLE :
            PHONEERR_INVALAPPHANDLE);
        goto xxxGetMessage_return2;
    }

    try
    {
        if ((pInitData->dwInitOptions & 0x3) !=
                LINEINITIALIZEEXOPTION_USEEVENT)
        {
            LOG((TL_ERROR,
                "GetMessage:  This app did not call initex with _USEEVENT"
                ));

            lResult = (bLine ? LINEERR_INVALAPPHANDLE :
                PHONEERR_INVALAPPHANDLE);
            goto xxxGetMessage_return;
        }

        if (pInitData->dwNumUsedEntries)
        {
            EnterCriticalSection (&gCriticalSection);
            bInCriticalSection = TRUE;

            if (pInitData->dwKey == INITDATA_KEY)
            {
                if (pInitData->dwNumUsedEntries)
                {
                    CopyMemory(
                        pMsg,
                        pInitData->pValidEntry,
                        sizeof (ASYNC_EVENT_PARAMS)
                        );

                    pInitData->pValidEntry++;

                    if (pInitData->pValidEntry >= (pInitData->pEventBuffer +
                            pInitData->dwNumTotalEntries))
                    {
                        pInitData->pValidEntry = pInitData->pEventBuffer;
                    }

                    pInitData->dwNumUsedEntries--;


                    //
                    // If the buffer is empty then reset the event
                    // to nonsignaled
                    //

                    if (pInitData->dwNumUsedEntries == 0)
                    {
                        ResetEvent (pInitData->hEvent);
                    }

                    lResult = 0;
                }
                else
                {
                    lResult = (bLine ? LINEERR_OPERATIONFAILED :
                        PHONEERR_OPERATIONFAILED);
                }
            }
            else
            {
                LOG((TL_ERROR, "GetMessage:  bad key2"));

                lResult = (bLine ? LINEERR_INVALAPPHANDLE :
                    PHONEERR_INVALAPPHANDLE);
            }

            LeaveCriticalSection (&gCriticalSection);
            bInCriticalSection = FALSE;
        }
        else
        {
            lResult = (bLine ? LINEERR_OPERATIONFAILED :
                PHONEERR_OPERATIONFAILED);
        }

        if (dwTimeout != 0 && lResult != 0)
        {
xxxGetMessage_wait:

            switch (WaitForSingleObject (pInitData->hEvent, dwTimeout))
            {
            case WAIT_OBJECT_0:

                EnterCriticalSection (&gCriticalSection);
                bInCriticalSection = TRUE;

                if (pInitData->dwKey == INITDATA_KEY)
                {
                    if (pInitData->dwNumUsedEntries)
                    {
                        CopyMemory(
                            pMsg,
                            pInitData->pValidEntry,
                            sizeof (ASYNC_EVENT_PARAMS)
                            );

                        pInitData->pValidEntry++;

                        if (pInitData->pValidEntry >= (pInitData->pEventBuffer+
                                pInitData->dwNumTotalEntries))
                        {
                            pInitData->pValidEntry = pInitData->pEventBuffer;
                        }

                        pInitData->dwNumUsedEntries--;


                        //
                        // If the buffer is empty then reset the event
                        // to nonsignaled
                        //

                        if (pInitData->dwNumUsedEntries == 0)
                        {
                            ResetEvent (pInitData->hEvent);
                        }

                        //
                        // Everything looks good, now.
                        //
                        lResult = 0;
                    }
                    else if (dwTimeout == INFINITE)
                    {
                        LeaveCriticalSection (&gCriticalSection);
                        bInCriticalSection = FALSE;
                        goto xxxGetMessage_wait;
                    }
                }
                else
                {
                    LOG((TL_ERROR, "GetMessage:  bad key1"));
                    lResult = (bLine ? LINEERR_INVALAPPHANDLE :
                        PHONEERR_INVALAPPHANDLE);
                }

                LeaveCriticalSection (&gCriticalSection);
                bInCriticalSection = FALSE;

                break;

            case WAIT_TIMEOUT:
            default:

                lResult = (bLine ? LINEERR_OPERATIONFAILED :
                    PHONEERR_OPERATIONFAILED);
            }
        }
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        LOG((TL_ERROR, "GetMessage:  exception"));

        if (bInCriticalSection)
        {
            LeaveCriticalSection (&gCriticalSection);
        }

        lResult = (bLine ? LINEERR_INVALAPPHANDLE : PHONEERR_INVALAPPHANDLE);
    }

xxxGetMessage_return:

    DereferenceObject (ghHandleTable, hXxxApp, 1);

xxxGetMessage_return2:

    {
        char    szResult[32],
               *pszFuncName = (bLine ? "lineGetMessage" : "phoneGetMessage");
#if DBG
        if (lResult == 0)
        {
            
            LOG((TL_TRACE,
                "%hs: exit, returning msg=%hs\n" \
                    "\thDev=x%01lx, ctx=x%01lx, p1=x%01lx, " \
                    "p2=x%01lx, p3=x%01lx",
                pszFuncName,
                aszMsgs[pMsg->dwMessageID],
                (DWORD)pMsg->hDevice,
                pMsg->dwCallbackInstance,
                pMsg->dwParam1,
                pMsg->dwParam2,
                pMsg->dwParam3
                ));
        }
        else
        {
            LOG((TL_TRACE,
                "%hs: exit, result=%hs",
                pszFuncName,
                MapResultCodeToText (lResult, szResult)
                ));
        }
#else
        if (lResult == 0)
        {
            
            LOG((TL_TRACE,
                "%hs: exit, returning msgID=x%x\n" \
                    "\thDev=x%01lx, ctx=x%01lx, p1=x%01lx, " \
                    "p2=x%01lx, p3=x%01lx",
                pszFuncName,
                pMsg->dwMessageID,
                (DWORD)pMsg->hDevice,
                pMsg->dwCallbackInstance,
                pMsg->dwParam1,
                pMsg->dwParam2,
                pMsg->dwParam3
                ));
        }
        else
        {
            LOG((TL_TRACE,
                "%hs: exit, result=x%x",
                pszFuncName,
                lResult
                ));
        }

#endif
    }

    return lResult;
}


/*
#if DBG
LPVOID
WINAPI
ClientAllocReal(
    DWORD   dwSize,
    DWORD   dwLine,
    PSTR    pszFile
    )
#else
LPVOID
WINAPI
ClientAllocReal(
    DWORD   dwSize
    )
#endif
{
    LPVOID  p;


#if DBG
    dwSize += sizeof (MYMEMINFO);
#endif

    p = LocalAlloc (LPTR, dwSize);

#if DBG
    if (p)
    {
        ((PMYMEMINFO) p)->dwLine  = dwLine;
        ((PMYMEMINFO) p)->pszFile = pszFile;

        p = (LPVOID) (((PMYMEMINFO) p) + 1);
    }
#endif

    return p;
}


VOID
WINAPI
ClientFree(
    LPVOID  p
    )
{
    if (!p)
    {
        return;
    }

#if DBG

    //
    // Fill the buffer (but not the MYMEMINFO header) with 0xa1's
    // to facilitate debugging
    //

    {
        LPVOID  p2 = p;


        p = (LPVOID) (((PMYMEMINFO) p) - 1);

        FillMemory(
            p2,
            LocalSize (p) - sizeof (MYMEMINFO),
            0xa1
            );
    }

#endif

    LocalFree (p);
}
*/

#if DBG
LPVOID
WINAPI
ClientAllocReal(
    DWORD   dwSize,
    DWORD   dwLine,
    PSTR    pszFile
    )
#else
LPVOID
WINAPI
ClientAllocReal(
    DWORD   dwSize
    )
#endif
{
    //
    // Alloc 16 extra bytes so we can make sure the pointer we pass back
    // is 64-bit aligned & have space to store the original pointer
    //
#if DBG

    PMYMEMINFO      pHold;
    PDWORD_PTR      pAligned;
    PBYTE           p;

    if (0 == dwSize)
    {
        return NULL;
    }

    p = (PBYTE)LocalAlloc(LPTR, dwSize + sizeof(MYMEMINFO) + 16);

    if (p == NULL)
    {
        return NULL;
    }

    // note note note - this only works because mymeminfo is
    // a 16 bit multiple in size.  if it wasn't, this
    // align stuff would cause problems.
    pAligned = (PDWORD_PTR) (p + 8 - (((DWORD_PTR) p) & (DWORD_PTR)0x7));
    *pAligned = (DWORD_PTR) p;
    pHold = (PMYMEMINFO)((DWORD_PTR)pAligned + 8);

    pHold->dwSize = dwSize;
    pHold->dwLine = dwLine;
    pHold->pszFile = pszFile;

    EnterCriticalSection(&csMemoryList);

    if (gpMemLast != NULL)
    {
        gpMemLast->pNext = pHold;
        pHold->pPrev = gpMemLast;
        gpMemLast = pHold;
    }
    else
    {
        gpMemFirst = gpMemLast = pHold;
    }

    LeaveCriticalSection(&csMemoryList);

    return (LPVOID)(pHold + 1);

#else

    LPBYTE  p;
    PDWORD_PTR pAligned;


    if (0 == dwSize)
    {
        return NULL;
    }

    if ((p = (LPBYTE) LocalAlloc (LPTR, dwSize + 16)))
    {
        pAligned = (PDWORD_PTR) (p + 8 - (((DWORD_PTR) p) & (DWORD_PTR)0x7));
        *pAligned = (DWORD_PTR) p;
        pAligned = (PDWORD_PTR)((DWORD_PTR)pAligned + 8);
    }
    else
    {
        pAligned = NULL;
    }

    return ((LPVOID) pAligned);
#endif
}


void
WINAPI
ClientFree(
    LPVOID  p
    )
{
#if DBG
    PMYMEMINFO       pHold;

    if (p == NULL)
    {
        return;
    }

    pHold = (PMYMEMINFO)(((LPBYTE)p) - sizeof(MYMEMINFO));

    EnterCriticalSection(&csMemoryList);

    if (pHold->pPrev)
    {
        pHold->pPrev->pNext = pHold->pNext;
    }
    else
    {
        gpMemFirst = pHold->pNext;
    }

    if (pHold->pNext)
    {
        pHold->pNext->pPrev = pHold->pPrev;
    }
    else
    {
        gpMemLast = pHold->pPrev;
    }

    LeaveCriticalSection(&csMemoryList);

    {
        LPVOID  pOrig = (LPVOID) *((PDWORD_PTR)((DWORD_PTR)pHold - 8));


        LocalFree (pOrig);
    }
//    LocalFree(pHold);

    return;
#else
    if (p != NULL)
    {
        LPVOID  pOrig = (LPVOID) *((PDWORD_PTR)((DWORD_PTR)p - 8));


        LocalFree (pOrig);
    }
#endif

}


#if DBG
void
DumpMemoryList()
{


    PMYMEMINFO       pHold;

    if (gpMemFirst == NULL)
    {
        LOG((TL_INFO, "DumpMemoryList: ALL MEMORY DEALLOCATED"));

        return;
    }

    pHold = gpMemFirst;

    while (pHold)
    {
       LOG((TL_ERROR, "DumpMemoryList: %p not freed - LINE %d FILE %hs!", pHold+1, pHold->dwLine, pHold->pszFile));

       pHold = pHold->pNext;
    }


    if (gbBreakOnLeak)
    {
        DebugBreak();
    }

}
#endif




SIZE_T
WINAPI
ClientSize(
    LPVOID  p
    )
{
    if (p != NULL)
    {
#if DBG
        p = (LPVOID)(((LPBYTE)p) - sizeof(MYMEMINFO));
#endif
        p = (LPVOID)*((PDWORD_PTR)((DWORD_PTR)p - 8));
        return (LocalSize (p) - 16);
    }

    return 0;
}


LONG
WINAPI
FreeClientResources(
    void
    )
{
    //
    // Serialize the following code
    //

    WaitForSingleObject (ghInitMutex, INFINITE);

    if (0 == gdwRpcRefCount)
    {   
        ReleaseMutex (ghInitMutex);
        return TAPIERR_REQUESTFAILED;
    }

    gdwRpcRefCount--;
    if (0 == gdwRpcRefCount)
    {

        //
        // If we've made an rpc connection with tapisrv then cleanly detach
        //

        if (gphCx)
        {
            RpcTryExcept
            {
                ClientDetach (&gphCx);
            }
            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
                // do something?
            }
            RpcEndExcept

            gphCx = NULL;

            // 
            // we also need to close the handle to ghAsyncEventsEvent
            //
            if (ghAsyncEventsEvent)
            {
                CloseHandle(ghAsyncEventsEvent);
                ghAsyncEventsEvent = NULL;
            }
        }
    }

    ReleaseMutex (ghInitMutex);

    return 0;
}


#if DBG
VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN LPTSTR lpszFormat,
    IN ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
    if (dwDbgLevel <= gdwDebugLevel)
    {
        TCHAR    buf[1280] = TEXT("TAPI32 (xxxxxxxx): ");
        va_list ap;


        wsprintf( &buf[8], TEXT("%08lx"), GetCurrentThreadId() );
        buf[16] = TEXT(')');

        va_start(ap, lpszFormat);

        wvsprintf(&buf[19],
                   lpszFormat,
                   ap
                  );

        lstrcat (buf, TEXT("\n"));

        OutputDebugString (buf);

        va_end(ap);
    }
}
#endif


LONG
CALLBACK
TUISPIDLLCallback(
    DWORD   dwObjectID,
    DWORD   dwObjectType,
    LPVOID  lpParams,
    DWORD   dwSize
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, xUIDLLCallback),

        {
            (ULONG_PTR) dwObjectID,
            (ULONG_PTR) dwObjectType,
            (ULONG_PTR) lpParams,
            (ULONG_PTR) dwSize,
            (ULONG_PTR) lpParams,
            (ULONG_PTR) dwSize
        },

        {
            Dword,
            Dword,
            lpSet_SizeToFollow,
            Size,
            lpGet_SizeToFollow,
            Size
        }
    };


    return (DOFUNC (&funcArgs, "UIDLLCallback"));
}


void
UIThread(
    LPVOID  pParams
    )
{
    DWORD           dwThreadID =  GetCurrentThreadId();
    HANDLE          hTapi32;
    PUITHREADDATA   pUIThreadData = (PUITHREADDATA) pParams;


    LOG((TL_TRACE, "UIThread: enter (tid=%d)", dwThreadID));


    //
    // Call LoadLibrary to increment the reference count in case this
    // thread is still running when this dll gets unloaded
    //

    hTapi32 = LoadLibrary (TEXT("tapi32.dll"));

    LOG((TL_TRACE, "UIThread: calling TUISPI_providerGenericDialog..."));

    (*pUIThreadData->pfnTUISPI_providerGenericDialog)(
        TUISPIDLLCallback,
        pUIThreadData->htDlgInst,
        pUIThreadData->pParams,
        pUIThreadData->dwSize,
        pUIThreadData->hEvent
        );

    LOG((TL_TRACE,
        "UIThread: TUISPI_providerGenericDialog returned (tid=%d)",
        dwThreadID
        ));


    //
    // Remove the ui thread data struct from the global list
    //

    EnterCriticalSection (&gCriticalSection);

    if (pUIThreadData->pNext)
    {
        pUIThreadData->pNext->pPrev = pUIThreadData->pPrev;
    }

    if (pUIThreadData->pPrev)
    {
        pUIThreadData->pPrev->pNext = pUIThreadData->pNext;
    }
    else
    {
        gpUIThreadInstances = pUIThreadData->pNext;
    }

    LeaveCriticalSection (&gCriticalSection);


    //
    // Free the library & buffers, then alert tapisrv
    //

    FreeLibrary (pUIThreadData->hUIDll);

    CloseHandle (pUIThreadData->hThread);

    CloseHandle (pUIThreadData->hEvent);

    if (pUIThreadData->pParams)
    {
        ClientFree (pUIThreadData->pParams);
    }

    {
        FUNC_ARGS funcArgs =
        {
            MAKELONG (LINE_FUNC | SYNC | 1, xFreeDialogInstance),

            {
                (ULONG_PTR) pUIThreadData->htDlgInst
            },

            {
                Dword
            }
        };


        DOFUNC (&funcArgs, "FreeDialogInstance");
    }

    ClientFree (pUIThreadData);

    LOG((TL_TRACE, "UIThread: exit (tid=%d)", dwThreadID));

    FreeLibraryAndExitThread (hTapi32, 0);
}


LONG
//WINAPI
CALLBACK
LAddrParamsInited(
    LPDWORD lpdwInited
    )
{
    HKEY  hKey;
    HKEY  hKey2;


    //
    // Default to 0, i.e. not initialized
    //

    *lpdwInited = 0;


    //
    // This is called by the modem setup wizard to determine
    // whether they should put up TAPI's Wizard page.
    //

    if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            gszTelephonyKey,
            0,
            KEY_READ,
            &hKey2

            ) == ERROR_SUCCESS)
    {
        if (RegOpenKeyEx(
                hKey2,
                gszLocations,
                0,
                KEY_READ,
                &hKey

                ) == ERROR_SUCCESS)
        {

            // query the Locations key for number of locations (subkeys)
            if (RegQueryInfoKey(hKey,
                                NULL,
                                NULL,
                                NULL,
                                lpdwInited,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                                ) == ERROR_SUCCESS)
            {

                //
                // Make sure we return a "proper" code
                //

                if ( *lpdwInited > 1 )
                {
                   *lpdwInited = 1;
                }
            }
            RegCloseKey (hKey);
        }

        RegCloseKey (hKey2);
    }

    return 0;
}


LONG
WINAPI
lineTranslateDialogA(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    HWND        hwndOwner,
    LPCSTR      lpszAddressIn
    );


LONG
CALLBACK
//WINAPI
LOpenDialAsst(
    HWND    hwnd,
    LPCSTR  lpszAddressIn,
    BOOL    fSimple,
    BOOL    fSilentInstall
    )
{
    TCHAR   szBuf[256];
    TCHAR   szWinlogon[64];
    DWORD   dwLengthNeeded;
    HDESK   hDesk;
//   lineTranslateDialog(hLineApp, 0, 0x00020000, hwnd, lpszAddressIn );

    gbTranslateSimple = fSimple;
    gbTranslateSilent = fSilentInstall;

    //
    //  Check to see if we are called from LOGON desktop, if so, simply
    //  make sure we have at least one location
    //
    hDesk = GetThreadDesktop (GetCurrentThreadId ());
    if (hDesk == NULL ||
        !GetUserObjectInformation (
            hDesk,
            UOI_NAME,
            (PVOID)szBuf,
            sizeof(szBuf),
            &dwLengthNeeded
            ) ||
        LoadString (
            g_hInst, 
            IDS_LOGONDESKNAME, 
            szWinlogon, 
            sizeof(szWinlogon)/sizeof(TCHAR)
            ) == 0 ||
        _tcsicmp (szBuf, szWinlogon) == 0)
    {
        return EnsureOneLocation (hwnd);
    }

   return lineTranslateDialogA( 0, 0, 0x00020000, hwnd, lpszAddressIn );
}


/////////////////////////////////////////////////////////////////////
// internalPerformance
//   tapiperf.dll calls this function to get performance data
//   this just calls into tapisrv
/////////////////////////////////////////////////////////////////////
LONG
WINAPI
internalPerformance(
    PPERFBLOCK  pPerfBlock
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, tPerformance),

        {
            (ULONG_PTR) pPerfBlock,
            (ULONG_PTR) sizeof(PERFBLOCK)
        },

        {
            lpGet_SizeToFollow,
            Size
        }
    };


    return (DOFUNC (&funcArgs, "PerfDataCall"));
}

BOOL 
WaveStringIdToDeviceId(
    LPWSTR  pwszStringID,
    LPCWSTR  pwszDeviceType,
    LPDWORD pdwDeviceId
    )
{
    if (!pwszDeviceType || !pwszStringID)
        return FALSE;

    // get the device id, based on string id and device class
    if ( !_wcsicmp(pwszDeviceType, L"wave/in") ||
         !_wcsicmp(pwszDeviceType, L"wave/in/out")
       )
    {
        return (MMSYSERR_NOERROR == waveInMessage(
                                    NULL,
                                    DRV_QUERYIDFROMSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    (DWORD_PTR)pdwDeviceId));

    } else if (!_wcsicmp(pwszDeviceType, L"wave/out"))
    {
        return (MMSYSERR_NOERROR == waveOutMessage(
                                    NULL,
                                    DRV_QUERYIDFROMSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    (DWORD_PTR)pdwDeviceId));
    } else if (!_wcsicmp(pwszDeviceType, L"midi/in"))
    {
        return (MMSYSERR_NOERROR == midiInMessage(
                                    NULL,
                                    DRV_QUERYIDFROMSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    (DWORD_PTR)pdwDeviceId));
    }  else if (!_wcsicmp(pwszDeviceType, L"midi/out"))
    {
        return (MMSYSERR_NOERROR == midiOutMessage(
                                    NULL,
                                    DRV_QUERYIDFROMSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    (DWORD_PTR)pdwDeviceId));
    }

    return FALSE;
}


//***************************************************************************
//***************************************************************************
//***************************************************************************
#if DBG

// Debug only stuff was left as ANSI
char *aszLineErrors[] =
{
    NULL,
    "ALLOCATED",
    "BADDEVICEID",
    "BEARERMODEUNAVAIL",
    "inval err value (0x80000004)",      // 0x80000004 isn't valid err code
    "CALLUNAVAIL",
    "COMPLETIONOVERRUN",
    "CONFERENCEFULL",
    "DIALBILLING",
    "DIALDIALTONE",
    "DIALPROMPT",
    "DIALQUIET",
    "INCOMPATIBLEAPIVERSION",
    "INCOMPATIBLEEXTVERSION",
    "INIFILECORRUPT",
    "INUSE",
    "INVALADDRESS",                     // 0x80000010
    "INVALADDRESSID",
    "INVALADDRESSMODE",
    "INVALADDRESSSTATE",
    "INVALAPPHANDLE",
    "INVALAPPNAME",
    "INVALBEARERMODE",
    "INVALCALLCOMPLMODE",
    "INVALCALLHANDLE",
    "INVALCALLPARAMS",
    "INVALCALLPRIVILEGE",
    "INVALCALLSELECT",
    "INVALCALLSTATE",
    "INVALCALLSTATELIST",
    "INVALCARD",
    "INVALCOMPLETIONID",
    "INVALCONFCALLHANDLE",              // 0x80000020
    "INVALCONSULTCALLHANDLE",
    "INVALCOUNTRYCODE",
    "INVALDEVICECLASS",
    "INVALDEVICEHANDLE",
    "INVALDIALPARAMS",
    "INVALDIGITLIST",
    "INVALDIGITMODE",
    "INVALDIGITS",
    "INVALEXTVERSION",
    "INVALGROUPID",
    "INVALLINEHANDLE",
    "INVALLINESTATE",
    "INVALLOCATION",
    "INVALMEDIALIST",
    "INVALMEDIAMODE",
    "INVALMESSAGEID",                   // 0x80000030
    "inval err value (0x80000031)",      // 0x80000031 isn't valid err code
    "INVALPARAM",
    "INVALPARKID",
    "INVALPARKMODE",
    "INVALPOINTER",
    "INVALPRIVSELECT",
    "INVALRATE",
    "INVALREQUESTMODE",
    "INVALTERMINALID",
    "INVALTERMINALMODE",
    "INVALTIMEOUT",
    "INVALTONE",
    "INVALTONELIST",
    "INVALTONEMODE",
    "INVALTRANSFERMODE",
    "LINEMAPPERFAILED",                 // 0x80000040
    "NOCONFERENCE",
    "NODEVICE",
    "NODRIVER",
    "NOMEM",
    "NOREQUEST",
    "NOTOWNER",
    "NOTREGISTERED",
    "OPERATIONFAILED",
    "OPERATIONUNAVAIL",
    "RATEUNAVAIL",
    "RESOURCEUNAVAIL",
    "REQUESTOVERRUN",
    "STRUCTURETOOSMALL",
    "TARGETNOTFOUND",
    "TARGETSELF",
    "UNINITIALIZED",                    // 0x80000050
    "USERUSERINFOTOOBIG",
    "REINIT",
    "ADDRESSBLOCKED",
    "BILLINGREJECTED",
    "INVALFEATURE",
    "NOMULTIPLEINSTANCE",
    "INVALAGENTID",
    "INVALAGENTGROUP",
    "INVALPASSWORD",
    "INVALAGENTSTATE",
    "INVALAGENTACTIVITY",
    "DIALVOICEDETECT"
};

char *aszPhoneErrors[] =
{
    "SUCCESS",
    "ALLOCATED",
    "BADDEVICEID",
    "INCOMPATIBLEAPIVERSION",
    "INCOMPATIBLEEXTVERSION",
    "INIFILECORRUPT",
    "INUSE",
    "INVALAPPHANDLE",
    "INVALAPPNAME",
    "INVALBUTTONLAMPID",
    "INVALBUTTONMODE",
    "INVALBUTTONSTATE",
    "INVALDATAID",
    "INVALDEVICECLASS",
    "INVALEXTVERSION",
    "INVALHOOKSWITCHDEV",
    "INVALHOOKSWITCHMODE",              // 0x90000010
    "INVALLAMPMODE",
    "INVALPARAM",
    "INVALPHONEHANDLE",
    "INVALPHONESTATE",
    "INVALPOINTER",
    "INVALPRIVILEGE",
    "INVALRINGMODE",
    "NODEVICE",
    "NODRIVER",
    "NOMEM",
    "NOTOWNER",
    "OPERATIONFAILED",
    "OPERATIONUNAVAIL",
    "inval err value (0x9000001e)",      // 0x9000001e isn't valid err code
    "RESOURCEUNAVAIL",
    "REQUESTOVERRUN",                   // 0x90000020
    "STRUCTURETOOSMALL",
    "UNINITIALIZED",
    "REINIT"
};

char *aszTapiErrors[] =
{
    "SUCCESS",
    "DROPPED",
    "NOREQUESTRECIPIENT",
    "REQUESTQUEUEFULL",
    "INVALDESTADDRESS",
    "INVALWINDOWHANDLE",
    "INVALDEVICECLASS",
    "INVALDEVICEID",
    "DEVICECLASSUNAVAIL",
    "DEVICEIDUNAVAIL",
    "DEVICEINUSE",
    "DESTBUSY",
    "DESTNOANSWER",
    "DESTUNAVAIL",
    "UNKNOWNWINHANDLE",
    "UNKNOWNREQUESTID",
    "REQUESTFAILED",
    "REQUESTCANCELLED",
    "INVALPOINTER"
};


char *
PASCAL
MapResultCodeToText(
    LONG    lResult,
    char   *pszResult
    )
{
    if (lResult == 0)
    {
        wsprintfA (pszResult, "SUCCESS");
    }
    else if (lResult > 0)
    {
        wsprintfA (pszResult, "x%x (completing async)", lResult);
    }
    else if (((DWORD) lResult) <= LINEERR_DIALVOICEDETECT)
    {
        lResult &= 0x0fffffff;

        wsprintfA (pszResult, "LINEERR_%s", aszLineErrors[lResult]);
    }
    else if (((DWORD) lResult) <= PHONEERR_REINIT)
    {
        if (((DWORD) lResult) >= PHONEERR_ALLOCATED)
        {
            lResult &= 0x0fffffff;

            wsprintfA (pszResult, "PHONEERR_%s", aszPhoneErrors[lResult]);
        }
        else
        {
            goto MapResultCodeToText_badErrorCode;
        }
    }
    else if (((DWORD) lResult) <= ((DWORD) TAPIERR_DROPPED) &&
             ((DWORD) lResult) >= ((DWORD) TAPIERR_INVALPOINTER))
    {
        lResult = ~lResult + 1;

        wsprintfA (pszResult, "TAPIERR_%s", aszTapiErrors[lResult]);
    }
    else
    {

MapResultCodeToText_badErrorCode:

        wsprintfA (pszResult, "inval error value (x%x)");
    }

    return pszResult;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\cplareacodetab.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplareacodetab.cpp
                                                              
       Author:  toddb - 10/06/98
              
****************************************************************************/

//
// Functions used only by the Area Code Rules tab of the New Location Property Sheet.
// Shared functions are in the Location.cpp file.
//
#include "cplPreComp.h"
#include "cplLocationPS.h"


INT_PTR CALLBACK CLocationPropSheet::AreaCode_DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CLocationPropSheet* pthis = (CLocationPropSheet*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        pthis = (CLocationPropSheet*)(((PROPSHEETPAGE*)lParam)->lParam);
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis); 
        return pthis->AreaCode_OnInitDialog(hwndDlg);

    case WM_COMMAND:
        return pthis->AreaCode_OnCommand(hwndDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam );

    case WM_NOTIFY:
        return pthis->AreaCode_OnNotify(hwndDlg, (LPNMHDR)lParam);
    
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        WinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a103HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        WinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a103HelpIDs);
        break;
    }

    return 0;
}

void BuildRuleDescription(CAreaCodeRule * pRule, LPTSTR szText, UINT cchSize)
{
    TCHAR szAreaCode[MAX_INPUT];
    TCHAR szNumToDial[MAX_INPUT];

    BOOL hHasDialAreaCode = pRule->HasDialAreaCode();
    BOOL bHasDialNumber = pRule->HasDialNumber();

    // we almost always need these strings so go ahead and convert them
    SHUnicodeToTChar( pRule->GetAreaCode(), szAreaCode, ARRAYSIZE(szAreaCode));
    SHUnicodeToTChar( pRule->GetNumberToDial(), szNumToDial, ARRAYSIZE(szNumToDial));

    // Just a little sanity check so we don't get crappy looking strings.
    if ( bHasDialNumber && !*szNumToDial )
    {
        bHasDialNumber = FALSE;
    }

    int iFormatString;

// TODO: Special default rules processing
//    if ( pRule == special rule that always shows up last )
//    {
//        iFormatString = IDS_DAIL_ONEpAC_ALLOTHER;
//    }
//    else
    if ( pRule->HasAppliesToAllPrefixes() )
    {
        if ( bHasDialNumber )
        {
            if ( hHasDialAreaCode )
            {
                // Dial '%2' plus the area code before the number for all numbers within the %1 area code.
                iFormatString = IDS_DIAL_XpAC_FORALL;
            }
            else
            {
                // Dial '%2' before the number for all numbers within the %1 area code.
                iFormatString = IDS_DIAL_X_FORALL;
            }
        }
        else if ( hHasDialAreaCode )
        {
            // Dial the area code before the number for all numbers within the %1 area code.
            iFormatString = IDS_DIAL_AC_FORALL;
        }
        else
        {
            // Dial only the number for all numbers within the %1 area code.
            iFormatString = IDS_DIAL_NUMONLY_FORALL;
        }
    }
    else
    {
        if ( bHasDialNumber )
        {
            if ( hHasDialAreaCode )
            {
                // Dial '%2' plus the area code before the number for numbers with the selected prefixes within the %1 area code.
                iFormatString = IDS_DIAL_XpAC_FORSELECTED;
            }
            else
            {
                // Dial '%2' before the number for numbers with the selected prefixes within the %1 area code.
                iFormatString = IDS_DIAL_X_FORSELECTED;
            }
        }
        else if ( hHasDialAreaCode )
        {
            // Dial the area code before the number for numbers with the selected prefixes within the %1 area code.
            iFormatString = IDS_DIAL_AC_FORSELECTED;
        }
        else
        {
            // Dial only the number for numbers with the selected prefixes within the %1 area code.
            iFormatString = IDS_DIAL_NUMONLY_FORSELECTED;
        }
    }

    TCHAR szFormatString[512];
    LPTSTR aArgs[] = {szAreaCode,szNumToDial};

    LoadString( GetUIInstance(), iFormatString, szFormatString, ARRAYSIZE(szFormatString) );

    FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
            szFormatString, 0,0, szText, cchSize, (va_list *)aArgs );
}

void BuildRuleText(CAreaCodeRule * pRule, LPTSTR szText, UINT cchSize)
{
    TCHAR szNumToDial[MAX_INPUT];
    SHUnicodeToTChar( pRule->GetNumberToDial(), szNumToDial, ARRAYSIZE(szNumToDial));

    // Just a little sanity check so we don't get crappy looking strings.
    BOOL bHasDialNumber = pRule->HasDialNumber();
    if ( bHasDialNumber && !*szNumToDial )
    {
        bHasDialNumber = FALSE;
    }

    if ( bHasDialNumber )
    {
        int iFormatString;
        TCHAR szFormatString[512];
        LPTSTR aArgs[] = {szNumToDial};

        if ( pRule->HasDialAreaCode() )
        {
            // both string
            iFormatString = IDS_DIALXPLUSAREACODE;
        }
        else
        {
            // dial number string
            iFormatString = IDS_DIALX;
        }
        LoadString( GetUIInstance(), iFormatString, szFormatString, ARRAYSIZE(szFormatString) );

        FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                szFormatString, 0,0, szText, cchSize, (va_list *)aArgs );
    }
    else if ( pRule->HasDialAreaCode() )
    {
        // area code only string
        LoadString( GetUIInstance(), IDS_DIALAREACODE, szText, cchSize );
    }
    else
    {
        // none of the above string
        LoadString( GetUIInstance(), IDS_DIALNUMBERONLY, szText, cchSize );
    }
}

BOOL CLocationPropSheet::AreaCode_OnInitDialog(HWND hDlg)
{
    // add the three columns to the listview
    RECT rc;
    TCHAR szText[MAX_INPUT];
    HWND hwndList = GetDlgItem(hDlg, IDC_LIST);

    GetClientRect(hwndList, &rc);

    int cxList = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    LVCOLUMN lvc;
    lvc.mask = LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    lvc.pszText = szText;

    struct {
        int iStrID;
        int cxPercent;
    } aData[] = {
        { IDS_AREACODE, 20 },
        { IDS_PREFIXES, 20 },
        { IDS_RULE,     60 },
    };

    for (int i=0; i<ARRAYSIZE(aData); i++)
    {
        LoadString(GetUIInstance(), aData[i].iStrID, szText, ARRAYSIZE(szText));
        lvc.iSubItem = i;
        lvc.cx = MulDiv(cxList, aData[i].cxPercent, 100);
        ListView_InsertColumn( hwndList, i, &lvc );
    }

    ListView_SetExtendedListViewStyleEx(hwndList, 
        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT, 
        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT);

    PopulateAreaCodeRuleList( hwndList );

    SetDataForSelectedRule(hDlg);

    return 1;
}

void CLocationPropSheet::SetDataForSelectedRule(HWND hDlg)
{
    TCHAR szText[512];

    // Set the button states
    EnableWindow(GetDlgItem(hDlg, IDC_EDIT),   0!=m_pRule);
    EnableWindow(GetDlgItem(hDlg, IDC_DELETE), 0!=m_pRule);
    if ( m_pRule )
    {
        // Set the description text
        BuildRuleDescription(m_pRule, szText, ARRAYSIZE(szText));
    }
    else
    {
        // text for when no rule is selected:
        LoadString(GetUIInstance(), IDS_SELECTARULE, szText, ARRAYSIZE(szText));
    }
    SetWindowText(GetDlgItem(hDlg, IDC_DESCRIPTIONTEXT), szText);
}

void CLocationPropSheet::AddRuleToList( HWND hwndList, CAreaCodeRule * pRule, BOOL bSelect )
{
    TCHAR szText[512];
    LVITEM lvi;
    SHUnicodeToTChar( pRule->GetAreaCode(), szText, ARRAYSIZE(szText));
    lvi.pszText = szText;
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = 0;
    lvi.iSubItem = 0;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    lvi.lParam = (LPARAM)pRule;
    if ( bSelect )
    {
        lvi.mask |= LVIF_STATE;
        lvi.state = LVIS_SELECTED | LVIS_FOCUSED;
        // We added the new rule in the selected state so update m_pRule
        m_pRule = pRule;

        // Since we now have a selected rule, update the button states
        HWND hwndParent = GetParent(hwndList);

        EnableWindow( GetDlgItem(hwndParent, IDC_EDIT),   TRUE );
        EnableWindow( GetDlgItem(hwndParent, IDC_DELETE), TRUE );
    }
    int iItem = ListView_InsertItem(hwndList, &lvi);

    LoadString(GetUIInstance(), pRule->HasAppliesToAllPrefixes()?IDS_ALLPREFIXES:IDS_SELECTEDPREFIXES,
            szText, ARRAYSIZE(szText));
    ListView_SetItemText(hwndList, iItem, 1, szText);

    BuildRuleText( pRule, szText, ARRAYSIZE(szText));
    ListView_SetItemText(hwndList, iItem, 2, szText);
}

void CLocationPropSheet::RemoveRuleFromList(HWND hwndList, BOOL bSelect)
{
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM)m_pRule;
    int iItem = ListView_FindItem(hwndList,-1,&lvfi);
    if ( -1 != iItem )
    {
        if ( bSelect )
        {
            iItem = DeleteItemAndSelectPrevious( GetParent(hwndList), IDC_LIST, iItem, IDC_DELETE, IDC_NEW );

            if ( -1 != iItem )
            {
                LVITEM lvi;
                lvi.iItem = iItem;
                lvi.iSubItem = 0;
                lvi.mask = LVIF_PARAM;
                ListView_GetItem( hwndList, &lvi );

                // Store the currently selected item
                m_pRule = (CAreaCodeRule *)lvi.lParam;
            }
            else
            {
                m_pRule = NULL;
            }
        }
        else
        {
            ListView_DeleteItem(hwndList,iItem);
            m_pRule = NULL;
        }
    }
}

void CLocationPropSheet::PopulateAreaCodeRuleList( HWND hwndList )
{
    m_pLoc->ResetRules();

    int i;
    int iItems;
    CAreaCodeRule * pRule;

    iItems = m_pLoc->GetNumRules();
    for (i=0; i<iItems; i++)
    {
        if ( S_OK == m_pLoc->NextRule(1,&pRule,NULL) )
        {
            AddRuleToList( hwndList, pRule, FALSE );
        }
    }
}

BOOL CLocationPropSheet::AreaCode_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl)
{
    switch ( wID )
    {
    case IDC_NEW:
    case IDC_EDIT:
        LaunchNewRuleDialog(IDC_NEW == wID,hwndParent);
        break;

    case IDC_DELETE:
        DeleteSelectedRule(GetDlgItem(hwndParent,IDC_LIST));
        break;

    default:
        return 0;
    }
    return 1;
}

void CLocationPropSheet::LaunchNewRuleDialog(BOOL bNew, HWND hwndParent)
{
    CAreaCodeRule * pRule;
    if ( bNew )
    {
        // Initialize with default values
        pRule = new CAreaCodeRule;
        if ( !pRule )
        {
            return;
        }

        pRule->Initialize(L"",L"1",RULE_APPLIESTOALLPREFIXES,NULL,0);
    }
    else if ( m_pRule )
    {
        // Initialize with m_pRule's values
        pRule = m_pRule;
    }
    else
    {
        // This should be impossible
        return;
    }

    CAreaCodeRuleDialog acrd( bNew, pRule );
    if ( IDOK == acrd.DoModal(hwndParent) )
    {
        // The user changed something
        HWND hwndList = GetDlgItem(hwndParent,IDC_LIST);
        SendMessage(GetParent(hwndParent), PSM_CHANGED, (WPARAM)hwndParent, 0);

        if ( bNew )
        {
            m_pLoc->AddRule(pRule);
        }
        else
        {
            // Assert( m_pRule == pRule );
            RemoveRuleFromList(hwndList, FALSE);
        }
        AddRuleToList(hwndList, pRule, TRUE);
        SetDataForSelectedRule(hwndParent);
    }
    else if ( bNew )
    {
        delete pRule;
    }
}

void CLocationPropSheet::DeleteSelectedRule(HWND hwndList)
{
    // First we confirm the delete with the user
    TCHAR szText[1024];
    TCHAR szTitle[128];
    int result;
    HWND hwndParent = GetParent(hwndList);
    
    LoadString(GetUIInstance(), IDS_DELETERULETEXT, szText, ARRAYSIZE(szText));
    LoadString(GetUIInstance(), IDS_CONFIRMDELETE, szTitle, ARRAYSIZE(szTitle));

    result = SHMessageBoxCheck( hwndParent, szText, szTitle, MB_YESNO, IDYES, TEXT("TAPIDeleteAreaCodeRule") );
    if ( IDYES == result )
    {
        // remove the item corresponding to m_pRule from the list
        m_pLoc->RemoveRule(m_pRule);
        RemoveRuleFromList(hwndList, TRUE);

        // Now we want to select the next rule in the list

        HWND hwndParent = GetParent(hwndList);
        SetDataForSelectedRule(hwndParent);
        SendMessage(GetParent(hwndParent), PSM_CHANGED, (WPARAM)hwndParent, 0);
    }
}

BOOL CLocationPropSheet::AreaCode_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr)
{
    // Let the generic handler have a crack at it first
    OnNotify(hwndDlg, pnmhdr);

    if (pnmhdr->idFrom == IDC_LIST)
    {
        #define pnmlv ((LPNMLISTVIEW)pnmhdr)

        switch (pnmhdr->code)
        {
        case LVN_ITEMCHANGED:
            if ( pnmlv->uChanged & LVIF_STATE )
            {
                if (pnmlv->uNewState & LVIS_SELECTED)
                {
                    LVITEM lvi;
                    lvi.iItem = pnmlv->iItem;
                    lvi.iSubItem = pnmlv->iSubItem;
                    lvi.mask = LVIF_PARAM;
                    ListView_GetItem( pnmhdr->hwndFrom, &lvi );

                    // Store the currently selected item
                    m_pRule = (CAreaCodeRule *)lvi.lParam;
                }
                else
                {
                    m_pRule = NULL;
                }

                SetDataForSelectedRule(hwndDlg);
            }

            break;

        case NM_DBLCLK:
            if ( (-1 == pnmlv->iItem) || !m_pRule )
            {
                // Do new case
                LaunchNewRuleDialog(TRUE,hwndDlg);
            }
            else
            {
                // Do Edit case
                LaunchNewRuleDialog(FALSE,hwndDlg);
            }
            break;

        default:
            break;
        }
        #undef pnmlv
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\cplcallingcardps.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplcallingcardps.cpp
                                                              
       Author:  toddb - 10/06/98
              
****************************************************************************/

// Property Sheet stuff for the main page
#include "cplPreComp.h"
#include "cplCallingCardPS.h"
#include "cplSimpleDialogs.h"
#include <strsafe.h>

#define MaxCallingCardRuleItems 16


CCallingCardPropSheet::CCallingCardPropSheet(BOOL bNew, BOOL bShowPIN, CCallingCard * pCard, CCallingCards * pCards)
{
    m_bNew = bNew;
    m_bShowPIN = bShowPIN;
    m_pCard = pCard;
    m_pCards = pCards;
    m_bWasApplied = FALSE;

    PWSTR pwsz;
    pwsz = pCard->GetLongDistanceRule();
    m_bHasLongDistance = (pwsz && *pwsz);

    pwsz = pCard->GetInternationalRule();
    m_bHasInternational = (pwsz && *pwsz);

    pwsz = pCard->GetLocalRule();
    m_bHasLocal = (pwsz && *pwsz);
}


CCallingCardPropSheet::~CCallingCardPropSheet()
{
}


LONG CCallingCardPropSheet::DoPropSheet(HWND hwndParent)
{
    CCPAGEDATA aPageData[] =
    {
        { this, 0 },
        { this, 1 },
        { this, 2 },
    };

    struct
    {
        int     iDlgID;
        DLGPROC pfnDlgProc;
        LPARAM  lParam;
    }
    aData[] =
    {
        { IDD_CARD_GENERAL,         CCallingCardPropSheet::General_DialogProc,  (LPARAM)this },
        { IDD_CARD_LONGDISTANCE,    CCallingCardPropSheet::DialogProc,          (LPARAM)&aPageData[0] },
        { IDD_CARD_INTERNATIONAL,   CCallingCardPropSheet::DialogProc,          (LPARAM)&aPageData[1] },
        { IDD_CARD_LOCALCALLS,      CCallingCardPropSheet::DialogProc,          (LPARAM)&aPageData[2] },
    };

    PROPSHEETHEADER psh;
    PROPSHEETPAGE   psp;
    HPROPSHEETPAGE  hpsp[ARRAYSIZE(aData)];

    // Initialize the header:
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_DEFAULT;
    psh.hwndParent = hwndParent;
    psh.hInstance = GetUIInstance();
    psh.hIcon = NULL;
    psh.pszCaption = MAKEINTRESOURCE(m_bNew?IDS_NEWCALLINGCARD:IDS_EDITCALLINGCARD);
    psh.nPages = ARRAYSIZE(aData);
    psh.nStartPage = 0;
    psh.pfnCallback = NULL;
    psh.phpage = hpsp;

    // Now setup the Property Sheet Page
    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = GetUIInstance();

    for (int i=0; i<ARRAYSIZE(aData); i++)
    {
        psp.pszTemplate = MAKEINTRESOURCE(aData[i].iDlgID);
        psp.pfnDlgProc = aData[i].pfnDlgProc;
        psp.lParam = aData[i].lParam;
        hpsp[i] = CreatePropertySheetPage( &psp );
    }

    PropertySheet( &psh );

    return m_bWasApplied?PSN_APPLY:PSN_RESET;
}

// ********************************************************************
// 
// GENERAL page
//
// ********************************************************************

INT_PTR CALLBACK CCallingCardPropSheet::General_DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CCallingCardPropSheet* pthis = (CCallingCardPropSheet*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        pthis = (CCallingCardPropSheet*)(((PROPSHEETPAGE*)lParam)->lParam);
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis); 
        return pthis->General_OnInitDialog(hwndDlg);

    case WM_COMMAND:
        pthis->General_OnCommand(hwndDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam );
        return 1;

    case WM_NOTIFY:
        return pthis->General_OnNotify(hwndDlg, (LPNMHDR)lParam);
   
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        WinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a105HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        WinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a105HelpIDs);
        break;
    }

    return 0;
}

BOOL CCallingCardPropSheet::General_OnInitDialog(HWND hwndDlg)
{
    // Set all the edit controls to the inital values
    HWND hwnd;
    TCHAR szText[MAX_INPUT];

    hwnd = GetDlgItem(hwndDlg,IDC_CARDNAME);
    SHUnicodeToTChar(m_pCard->GetCardName(), szText, ARRAYSIZE(szText));
    SetWindowText(hwnd, szText);
    SendMessage(hwnd, EM_SETLIMITTEXT, CPL_SETTEXTLIMIT, 0);

    hwnd = GetDlgItem(hwndDlg,IDC_CARDNUMBER);
    SHUnicodeToTChar(m_pCard->GetAccountNumber(), szText, ARRAYSIZE(szText));
    SetWindowText(hwnd, szText);
    SendMessage(hwnd, EM_SETLIMITTEXT, CPL_SETTEXTLIMIT, 0);
    LimitInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWSPACE);

    hwnd = GetDlgItem(hwndDlg,IDC_PIN);
	if(m_bShowPIN)
	{
    	SHUnicodeToTChar(m_pCard->GetPIN(), szText, ARRAYSIZE(szText));
    	SetWindowText(hwnd, szText);
    }
    SendMessage(hwnd, EM_SETLIMITTEXT, CPL_SETTEXTLIMIT, 0);
    LimitInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWSPACE);

    SetTextForRules(hwndDlg);

    return 1;
}

void CCallingCardPropSheet::SetTextForRules(HWND hwndDlg)
{
    TCHAR szText[512];
    int iDlgID = IDC_CARDUSAGE1;
    if ( m_bHasLongDistance )
    {
        // load the "dialing long distance calls." string
        LoadString(GetUIInstance(), IDS_DIALING_LD_CALLS, szText, ARRAYSIZE(szText));
        SetWindowText(GetDlgItem(hwndDlg,iDlgID), szText);
        iDlgID++;
    }
    if ( m_bHasInternational )
    {
        // load the "dialing international calls." string
        LoadString(GetUIInstance(), IDS_DIALING_INT_CALLS, szText, ARRAYSIZE(szText));
        SetWindowText(GetDlgItem(hwndDlg,iDlgID), szText);
        iDlgID++;
    }
    if ( m_bHasLocal )
    {
        // load the "dialing local calls." string
        LoadString(GetUIInstance(), IDS_DIALING_LOC_CALLS, szText, ARRAYSIZE(szText));
        SetWindowText(GetDlgItem(hwndDlg,iDlgID), szText);
        iDlgID++;
    }
    if ( IDC_CARDUSAGE1 == iDlgID )
    {
        // load the "there are no rules defined for this card" string
        LoadString(GetUIInstance(),IDS_NOCCRULES,szText,ARRAYSIZE(szText));
        SetWindowText(GetDlgItem(hwndDlg,iDlgID), szText);
        iDlgID++;
    }
    while (iDlgID <= IDC_CARDUSAGE3)
    {
        SetWindowText(GetDlgItem(hwndDlg,iDlgID), TEXT(""));
        iDlgID++;
    }
}

BOOL CCallingCardPropSheet::General_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl)
{
    switch ( wID )
    {
    case IDC_CARDNAME:
    case IDC_CARDNUMBER:
    case IDC_PIN:
        switch (wNotifyCode)
        {
        case EN_CHANGE:
            SendMessage(GetParent(hwndParent),PSM_CHANGED,(WPARAM)hwndParent,0);
            break;

        default:
            break;
        }
        break;

    default:
        break;
    }

    return 0;
}

BOOL CCallingCardPropSheet::General_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr)
{
    // The only notifies we should receive are from the property sheet
    switch (pnmhdr->code)
    {
    case PSN_APPLY:     // user pressed OK or Apply
        // update all the strings
        HideToolTip();
        return Gerneral_OnApply(hwndDlg);

    case PSN_RESET:     // user pressed Cancel
        HideToolTip();
        break;

    case PSN_SETACTIVE: // user is switching pages
        // the user might have added some rules since switching pages so we
        // need to update the text fields that show which rules are set.
        SetTextForRules(hwndDlg);
        HideToolTip();
        break;
    }
    return 0;
}

BOOL CCallingCardPropSheet::Gerneral_OnApply(HWND hwndDlg)
{
    HWND hwnd;
    DWORD dwStatus;
    PWSTR pwszOldCardNumber;
    PWSTR pwszOldPinNumber;
    WCHAR wsz[MAX_INPUT];
    TCHAR szText[MAX_INPUT];


    LOG((TL_TRACE,  "Gerneral_OnApply:  -- enter"));

    // In order for this to work, I have to first store the new rules into the
    // m_pCard object.  Each page that has been created must be asked to generate
    // it's rule.  We do this in response to the PSM_QUERYSIBLINGS command.
    // Unfortunately, we have to first store a copy of all the data we're about to
    // change.  That way, if the validation fails we can return the CallingCard
    // object to it's original value (so if the user then presses cancel it will
    // be in the correct state).

    // cache the current values for the rules and access numbers
    pwszOldCardNumber = ClientAllocString(m_pCard->GetAccountNumber());
    pwszOldPinNumber = ClientAllocString(m_pCard->GetPIN());

    // now update the object with the value we are about to test.
    hwnd = GetDlgItem(hwndDlg,IDC_CARDNUMBER);
    GetWindowText(hwnd, szText, ARRAYSIZE(szText));
    SHTCharToUnicode(szText, wsz, ARRAYSIZE(wsz));
    m_pCard->SetAccountNumber(wsz);

    hwnd = GetDlgItem(hwndDlg,IDC_PIN);
    GetWindowText(hwnd, szText, ARRAYSIZE(szText));
    SHTCharToUnicode(szText, wsz, ARRAYSIZE(wsz));
    m_pCard->SetPIN(wsz);

    // let the other pages update thier values
    PropSheet_QuerySiblings(GetParent(hwndDlg),0,0);

    // Now we can validate the card.
    dwStatus = m_pCard->Validate();
    if ( dwStatus )
    {
        int iStrID;
        int iDlgItem;
        int iDlgID = 0;

        // Set the current values for the rules and access numbers to our cached values.
        // This is required in case the user later decides to cancel instead of appling.
        m_pCard->SetAccountNumber(pwszOldCardNumber);
        m_pCard->SetPIN(pwszOldPinNumber);
        ClientFree( pwszOldCardNumber );
        ClientFree( pwszOldPinNumber );
        
        // Something isn't right, figure out what.  The order we check these
        // in depends on which tab the error would need to be fixed from.
        // First we check the items that get fixed on the general tab.
        if ( dwStatus & (CCVF_NOCARDNAME|CCVF_NOCARDNUMBER|CCVF_NOPINNUMBER) )
        {
            if ( dwStatus & CCVF_NOCARDNAME )
            {
                iStrID = IDS_MUSTENTERCARDNAME;
                iDlgItem = IDC_CARDNAME;
            }
            else if ( dwStatus & CCVF_NOCARDNUMBER )
            {
                iStrID = IDS_MUSTENTERCARDNUMBER;
                iDlgItem = IDC_CARDNUMBER;
            }
            else
            {
                iStrID = IDS_MUSTENTERPINNUMBER;
                iDlgItem = IDC_PIN;
            }

            iDlgID = IDD_CARD_GENERAL;
        }
        else if ( dwStatus & CCVF_NOCARDRULES )
        {
            // For this problem we stay on whatever page we are already on
            // since this problem can be fixed on one of three different pages.
            iStrID = IDS_NORULESFORTHISCARD;
        }
        else if ( dwStatus & CCVF_NOLONGDISTANCEACCESSNUMBER )
        {
            iStrID = IDS_NOLONGDISTANCEACCESSNUMBER;
            iDlgID = IDD_CARD_LONGDISTANCE;
            iDlgItem = IDC_LONGDISTANCENUMBER;
        }
        else if ( dwStatus & CCVF_NOINTERNATIONALACCESSNUMBER )
        {
            iStrID = IDS_NOINTERNATIONALACCESSNUMBER;
            iDlgID = IDD_CARD_INTERNATIONAL;
            iDlgItem = IDC_INTERNATIONALNUMBER;
        }
        else if ( dwStatus & CCVF_NOLOCALACCESSNUMBER )
        {
            iStrID = IDS_NOLOCALACCESSNUMBER;
            iDlgID = IDD_CARD_LOCALCALLS;
            iDlgItem = IDC_LOCALNUMBER;
        }

        hwnd = GetParent(hwndDlg);
        if ( iDlgID )
        {
            PropSheet_SetCurSelByID(hwnd,iDlgID);
            hwnd = PropSheet_GetCurrentPageHwnd(hwnd);
            hwnd = GetDlgItem(hwnd,iDlgItem);
        }
        else
        {
            hwnd = hwndDlg;
        }
        ShowErrorMessage(hwnd, iStrID);
        SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,PSNRET_INVALID_NOCHANGEPAGE);
        return TRUE;
    }

    // Check for the calling card name being unique
    TCHAR szNone[MAX_INPUT];
    LoadString(GetUIInstance(),IDS_NONE, szNone, ARRAYSIZE(szNone));

    hwnd = GetDlgItem(hwndDlg,IDC_CARDNAME);
    GetWindowText(hwnd, szText, ARRAYSIZE(szText));
    if ( 0 == StrCmpIW(szText, szNone) )
    {
        goto buggeroff;
    }
    SHTCharToUnicode(szText, wsz, ARRAYSIZE(wsz));

    CCallingCard * pCard;
    m_pCards->Reset(TRUE);      // TRUE means show "hidden" cards, FALSE means hide them

    while ( S_OK == m_pCards->Next(1,&pCard,NULL) )
    {
        // hidden cards shall remain hidden for ever so we don't check names against those
        if ( !pCard->IsMarkedHidden() )
        {
            // Card0 is the "None (Direct Dial)" card which we don't want to consider
            if ( 0 != pCard->GetCardID() )
            {
                // we don't want to consider ourself either
                if ( pCard->GetCardID() != m_pCard->GetCardID() )
                {
                    // see if the names are identical
                    if ( 0 == StrCmpIW(pCard->GetCardName(), wsz) )
                    {
                        // yes, the name is in conflict
buggeroff:
                        // return altered values to original state
                        m_pCard->SetAccountNumber(pwszOldCardNumber);
                        m_pCard->SetPIN(pwszOldPinNumber);
                        ClientFree( pwszOldCardNumber );
                        ClientFree( pwszOldPinNumber );

                        // display an error message
                        hwnd = GetParent(hwndDlg);
                        PropSheet_SetCurSelByID(hwnd,IDD_CARD_GENERAL);
                        hwnd = PropSheet_GetCurrentPageHwnd(hwnd);
                        hwnd = GetDlgItem(hwnd,IDC_CARDNAME);
                        ShowErrorMessage(hwnd, IDS_NEEDUNIQUECARDNAME);
                        SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;
                    }
                }
            }
        }
    }

    // card name doesn't conflict, update it.
    m_pCard->SetCardName(wsz);

    m_bWasApplied = TRUE;

    ClientFree( pwszOldCardNumber );
    ClientFree( pwszOldPinNumber );
    return 0;
}


// ********************************************************************
// 
// LONG DISTANCE, INTERNATIONAL, and LOCAL pages
//
// ********************************************************************

INT_PTR CALLBACK CCallingCardPropSheet::DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CCPAGEDATA * pPageData = (CCPAGEDATA *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        pPageData = (CCPAGEDATA*)(((PROPSHEETPAGE*)lParam)->lParam);
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)pPageData); 
        return pPageData->pthis->OnInitDialog(hwndDlg,pPageData->iWhichPage);

    case WM_COMMAND:
        pPageData->pthis->OnCommand(hwndDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam, pPageData->iWhichPage);
        return 1;

    case WM_NOTIFY:
        return pPageData->pthis->OnNotify(hwndDlg, (LPNMHDR)lParam,pPageData->iWhichPage);

    case PSM_QUERYSIBLINGS:
        return pPageData->pthis->UpdateRule(hwndDlg,pPageData->iWhichPage);

    case WM_DESTROY:
        return pPageData->pthis->OnDestroy(hwndDlg);

#define aIDs ((pPageData->iWhichPage==0)?a106HelpIDs:((pPageData->iWhichPage==1)?a107HelpIDs:a108HelpIDs))
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        WinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) aIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        WinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) aIDs);
        break;
#undef aIDs
    }

    return 0;
}

void GetDescriptionForRule(PWSTR pwszRule, PTSTR szText, UINT cchText)
{
    switch (*pwszRule)
    {
    case L',':
        {
            // Check if all characters are commas. If they are not, fall through to the 
            // "dial the specified digits" case
            if(HasOnlyCommasW(pwszRule))
            {
                // add a "wait for x seconds" rule.  Each consecutive ',' adds two seconds to x.
                int iSecondsToWait = lstrlenW(pwszRule)*2;
                TCHAR szFormat[256];
                LPTSTR aArgs[] = {(LPTSTR)UIntToPtr(iSecondsToWait)};

                LoadString(GetUIInstance(),IDS_WAITFORXSECONDS, szFormat, ARRAYSIZE(szFormat));

                FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        szFormat, 0,0, szText, cchText, (va_list *)aArgs );

                break;        
            }
        }

        // ATTENTION !!
        // Fall through

    case L'0':
    case L'1':
    case L'2':
    case L'3':
    case L'4':
    case L'5':
    case L'6':
    case L'7':
    case L'8':
    case L'9':
    case L'A':
    case L'a':
    case L'B':
    case L'b':
    case L'C':
    case L'c':
    case L'D':
    case L'd':
    case L'#':
    case L'*':
    case L'+':
    case L'!':
        {
            // Add a "dial the specified digits" rule.  The whole sequence of these digits should
            // be considered to be one rule.
            TCHAR szRule[MAX_INPUT];
            TCHAR szFormat[MAX_INPUT];
            TCHAR szTemp[MAX_INPUT*2]; // big enough for the rule and the format
            LPTSTR aArgs[] = {szRule};

            SHUnicodeToTChar(pwszRule, szRule, ARRAYSIZE(szRule));
            LoadString(GetUIInstance(),IDS_DIALX, szFormat, ARRAYSIZE(szFormat));

            // The formated message might be larger than cchText, in which case we just
            // want to truncate the result.  FormatMessage would simply fail in that case
            // so we format to a larger buffer and then truncate down.
            if (FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    szFormat, 0,0, szTemp, ARRAYSIZE(szTemp), (va_list *)aArgs ))
            {
                StrCpyN(szText, szTemp, cchText);
            }
            else
            {
                szText[0] = 0;
            }
        }
        break;

    default:
        {
            int iStrID;

            switch (*pwszRule)
            {
            case L'J':
                // add a "dial the access number" rule.
                iStrID = IDS_DIALACCESSNUMBER;
                break;

            case L'K':
                // add a "dial the account number" rule.
                iStrID = IDS_DIALACOUNTNUMBER;
                break;

            case L'H':
                // add a "dial the pin number" rule.
                iStrID = IDS_DIALPINNUMBER;
                break;

            case L'W':
                // add a "Wait for dial tone" rule.
                iStrID = IDS_WAITFORDIALTONE;
                break;

            case L'@':
                // add a "Wait for quiet" rule.
                iStrID = IDS_WAITFORQUIET;
                break;

            case L'E':
            case L'F':
            case L'G':
                // add a "dial the destination number" rule.  We look for these three letters together.
                // Only certain combinations of these letters are valid, as indicated below:
                if ( 0 == StrCmpW(pwszRule, L"EFG") )
                {
                    iStrID = IDS_DIAL_CCpACpNUM;
                }
                else if ( 0 == StrCmpW(pwszRule, L"EG") )
                {
                    iStrID = IDS_DIAL_CCpNUM;
                }
                else if ( 0 == StrCmpW(pwszRule, L"FG") )
                {
                    iStrID = IDS_DIAL_ACpNUM;
                }
                else if ( 0 == StrCmpW(pwszRule, L"E") )
                {
                    iStrID = IDS_DIAL_CC;
                }
                else if ( 0 == StrCmpW(pwszRule, L"F") )
                {
                    iStrID = IDS_DIAL_AC;
                }
                else if ( 0 == StrCmpW(pwszRule, L"G") )
                {
                    iStrID = IDS_DIAL_NUM;
                }
                break;

            default:
                // We shouldn't be able to get here"
                LOG((TL_ERROR, "Invalid calling card rule"));
                szText[0] = NULL;
                return;
            }

            LoadString(GetUIInstance(), iStrID, szText, cchText);
        }
        break;
    }
}

void PopulateStepList(HWND hwndList, PWSTR pwszRuleList)
{
    TCHAR szText[MAX_INPUT];
    WCHAR wch;
    PWSTR pwsz;

    int i = 0;

    // Parse the string into a series of rules.  There are only types of rules that we should see
    // in a calling card sting:
    //  J               dial the access number
    //  K               dial the account number
    //  H               dial the pin number
    //  0-9,#,*,+,!,ABCD Dial the digits directly
    //  W               Wait for dial tone
    //  @               Wait for quiet
    //  ,               Wait for two seconds
    //  E               Dial the counrty code
    //  F               Dial the area code
    //  G               Dial the local number (prefix and root)

    // We copy the characters for the given rule into a buffer.  Then we allocate a heap
    // buffer into which these characters get copied.  Each list view item tracks one of
    // these character buffers in it's lParam data.

    LOG((TL_INFO, "Rule to process (%ls)",pwszRuleList));
    while ( *pwszRuleList )
    {
        switch (*pwszRuleList)
        {
        case L'J':
            // add a "dial the access number" rule.
        case L'K':
            // add a "dial the account number" rule.
        case L'H':
            // add a "dial the pin number" rule.
        case L'W':
            // add a "Wait for dial tone" rule.
        case L'@':
            // add a "Wait for quiet" rule.

            // These are all the one character rules.
            pwsz = pwszRuleList+1;
            LOG((TL_INFO, "JKHW@ case (%ls) <%p>",pwsz,pwsz));
            break;

        case L'E':
        case L'F':
        case L'G':
            // add a "dial the destination number" rule.  We look for these three letters together.
            // If we find a consecutive group of these digits then we treat them as one rule.  Only
            // a few combinations of these letters are actually valid rules.  If we find some other
            // combination then we must treat it as a seperate rule instead of a single rule.  We
            // start by looking for the longest valid rules and then check for the shorter ones.
            if ( 0 == StrCmpNW(pwszRuleList, L"EFG", 3) )
            {
                pwsz = pwszRuleList+3;
            }
            else if ( 0 == StrCmpNW(pwszRuleList, L"EG", 2) )
            {
                pwsz = pwszRuleList+2;
            }
            else if ( 0 == StrCmpNW(pwszRuleList, L"FG", 2) )
            {
                pwsz = pwszRuleList+2;
            }
            else
            {
                pwsz = pwszRuleList+1;
            }
            LOG((TL_INFO, "EFG case (%ls)",pwsz));
            break;

        case L',':
            // add a "wait for x seconds" rule.  Each consecutive , adds two seconds to x.
            pwsz = pwszRuleList+1;
            while ( *(pwsz) == L',' )
            {
                pwsz++;
            }
            break;

        case L'0':
        case L'1':
        case L'2':
        case L'3':
        case L'4':
        case L'5':
        case L'6':
        case L'7':
        case L'8':
        case L'9':
        case L'A':
        case L'a':
        case L'B':
        case L'b':
        case L'C':
        case L'c':
        case L'D':
        case L'd':
        case L'#':
        case L'*':
        case L'+':
        case L'!':
            // Add a "dial the specified digits" rule.  The whole sequence of these digits should
            // be considered to be one rule.
            pwsz = pwszRuleList+1;
            while ( ((*pwsz >= L'0') && (*pwsz <= L'9')) ||
                    ((*pwsz >= L'A') && (*pwsz <= L'D')) ||
                    ((*pwsz >= L'a') && (*pwsz <= L'd')) ||
                    (*pwsz == L'#') ||
                    (*pwsz == L'*') ||
                    (*pwsz == L'+') ||
                    (*pwsz == L'!')
                    )
            {
                pwsz++;
            }
            LOG((TL_INFO, "0-9,A-D,#,*,+,! case (%ls)", pwsz));
            break;

        default:
            // We shouldn't be able to get here
            LOG((TL_ERROR, "Invalid calling card rule"));

            // we just ignore this character and go back to the while loop.  Yes, this is a continue
            // inside a switch inside a while loop.  A bit confusing, perhaps, but it's what we want.
            pwszRuleList++;
            continue;
        }

        // we temporarily stick a NULL into wpszRuleList to seperate out one rule
        wch = *pwsz;
        *pwsz = NULL;

        // for each rule, add a list box entry
        LVITEM lvi;
        lvi.mask = LVIF_TEXT|LVIF_PARAM;
        lvi.iItem = i++;
        lvi.iSubItem = 0;
        lvi.pszText = szText;
        lvi.lParam = (LPARAM)ClientAllocString(pwszRuleList);
        GetDescriptionForRule(pwszRuleList, szText, ARRAYSIZE(szText));
        LOG((TL_INFO, "Description for (%ls) is (%s)", pwszRuleList,szText));

        ListView_InsertItem(hwndList, &lvi);

        // restore pwszRuleList to it's former state before continuing or this is going to be a real short ride.
        pwsz[0] = wch;

        // after the above restoration, pwsz points to the head of the next rule (or to a NULL)
        pwszRuleList = pwsz;
    }
}

BOOL CCallingCardPropSheet::OnInitDialog(HWND hwndDlg, int iPage)
{
    LOG((TL_TRACE,  "OnInitDialog <%d>",iPage));

    PWSTR pwsz;
    RECT rc;
    HWND hwnd = GetDlgItem(hwndDlg, IDC_LIST);

    GetClientRect(hwnd, &rc);

    LVCOLUMN lvc;
    lvc.mask = LVCF_SUBITEM | LVCF_WIDTH;
    lvc.iSubItem = 0;
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn( hwnd, 0, &lvc );
    
    ListView_SetExtendedListViewStyleEx(hwnd,
        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT,
        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT);

    switch ( iPage )
    {
    case 0:
        pwsz = m_pCard->GetLongDistanceRule();
        break;

    case 1:
        pwsz = m_pCard->GetInternationalRule();
        break;

    case 2:
        pwsz = m_pCard->GetLocalRule();
        break;

    default:
        LOG((TL_ERROR, "OnInitDialog: Invalid page ID %d, failing.", iPage));
        return -1;
    }
    PopulateStepList(hwnd, pwsz);

    int iDlgItem;
    switch (iPage)
    {
    case 0:
        iDlgItem = IDC_LONGDISTANCENUMBER;
        pwsz = m_pCard->GetLongDistanceAccessNumber();
        break;

    case 1:
        iDlgItem = IDC_INTERNATIONALNUMBER;
        pwsz = m_pCard->GetInternationalAccessNumber();
        break;

    case 2:
        iDlgItem = IDC_LOCALNUMBER;
        pwsz = m_pCard->GetLocalAccessNumber();
        break;
    }

    TCHAR szText[MAX_INPUT];
    hwnd = GetDlgItem(hwndDlg,iDlgItem);
    SHUnicodeToTChar(pwsz, szText, ARRAYSIZE(szText));
    SetWindowText(hwnd, szText);
    SendMessage(hwnd, EM_SETLIMITTEXT, CPL_SETTEXTLIMIT, 0);
    LimitInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWSPACE);

    // disable the buttons since no item is selected by default
    SetButtonStates(hwndDlg,-1);

    return 0;
}

BOOL CCallingCardPropSheet::OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl, int iPage)
{
    HWND hwndList = GetDlgItem(hwndParent, IDC_LIST);

    switch ( wID )
    {
    case IDC_LONGDISTANCENUMBER:
    case IDC_INTERNATIONALNUMBER:
    case IDC_LOCALNUMBER:
        if (EN_CHANGE == wNotifyCode)
        {
            SendMessage(GetParent(hwndParent),PSM_CHANGED,(WPARAM)hwndParent,0);
        }
        break;

    case IDC_MOVEUP:
    case IDC_MOVEDOWN:
    case IDC_REMOVE:
        {
            TCHAR szText[MAX_INPUT];
            int iSelected = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);

            if (-1 != iSelected)
            {
                LVITEM lvi;
                lvi.mask = LVIF_TEXT | LVIF_PARAM;
                lvi.iItem = iSelected;
                lvi.iSubItem = 0;
                lvi.pszText = szText;
                lvi.cchTextMax = ARRAYSIZE(szText);
                ListView_GetItem(hwndList, &lvi);

                ListView_DeleteItem(hwndList, iSelected);

                if ( IDC_MOVEDOWN == wID )
                {
                    iSelected++;
                }
                else
                {
                    iSelected--;
                }

                if ( IDC_REMOVE == wID )
                {
                    ClientFree( (PWSTR)lvi.lParam );
                    if ( ListView_GetItemCount(hwndList) > 0 )
                    {
                        if (-1 == iSelected)
                            iSelected = 0;

                        ListView_SetItemState(hwndList, iSelected, LVIS_SELECTED, LVIS_SELECTED); 
                    }
                    else
                    {
                        // the last rule was deleted, update the "has rule" state
                        switch (iPage)
                        {
                        case 0:
                            m_bHasLongDistance = FALSE;
                            break;

                        case 1:
                            m_bHasInternational = FALSE;
                            break;

                        case 2:
                            m_bHasLocal = FALSE;
                            break;
                        }
                        if ( GetFocus() == hwndCrl )
                        {
                            HWND hwndDef = GetDlgItem(hwndParent,IDC_ACCESSNUMBER);
                            SendMessage(hwndCrl, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE,0));
                            SendMessage(hwndDef, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE,0));
                            SetFocus(hwndDef);
                        }
                        EnableWindow(hwndCrl,FALSE);
                    }
                }
                else
                {
                    lvi.mask |= LVIF_STATE;
                    lvi.iItem = iSelected;
                    lvi.state = lvi.stateMask = LVIS_SELECTED;
                    iSelected = ListView_InsertItem(hwndList, &lvi);
                }

                ListView_EnsureVisible(hwndList, iSelected, FALSE);
            }

            SendMessage(GetParent(hwndParent), PSM_CHANGED, (WPARAM)hwndParent, 0);
        }
        break;

    case IDC_ACCESSNUMBER:
    case IDC_PIN:
    case IDC_CARDNUMBER:
    case IDC_DESTNUMBER:
    case IDC_WAITFOR:
    case IDC_SPECIFYDIGITS:
        {
            TCHAR szText[MAX_INPUT];
            WCHAR wszRule[MAX_INPUT];
            int iItem = ListView_GetItemCount(hwndList);
            LVITEM lvi;
            lvi.mask = LVIF_TEXT | LVIF_PARAM;
            lvi.iItem = iItem;
            lvi.iSubItem = 0;
            lvi.pszText = szText;

            switch ( wID )
            {
                case IDC_ACCESSNUMBER:
                    lvi.lParam = (LPARAM)ClientAllocString(L"J");
                    break;

                case IDC_PIN:
                    lvi.lParam = (LPARAM)ClientAllocString(L"H");
                    break;

                case IDC_CARDNUMBER:
                    lvi.lParam = (LPARAM)ClientAllocString(L"K");
                    break;

                case IDC_DESTNUMBER:
                    {
                        CDestNumDialog dnd(iPage==1, iPage!=2);
                        INT_PTR iRes = dnd.DoModal(hwndParent);
                        if (iRes == (INT_PTR)IDOK)
                        {
                            lvi.lParam = (LPARAM)ClientAllocString(dnd.GetResult());
                        }
                        else
                        {
                            return 0;
                        }
                    }
                    break;

                case IDC_WAITFOR:
                    {
                        CWaitForDialog wd;
                        INT_PTR ipRes = wd.DoModal(hwndParent);
                        if (ipRes == (INT_PTR)IDOK)
                        {
                            int iRes;
                            iRes = wd.GetWaitType();
                            LOG((TL_INFO, "WaitType is %d", iRes));
                            switch (iRes)
                            {
                            case 0:
                                lvi.lParam = (LPARAM)ClientAllocString(L"W");
                                break;

                            case 1:
                                lvi.lParam = (LPARAM)ClientAllocString(L"@");
                                break;

                            default:
                                iRes = iRes/2;
                                if ( ARRAYSIZE(wszRule) <= iRes )
                                {
                                    iRes = ARRAYSIZE(wszRule)-1;
                                }

                                for (int i=0; i<iRes; i++)
                                {
                                    wszRule[i] = L',';
                                }
                                wszRule[i] = NULL;
                                lvi.lParam = (LPARAM)ClientAllocString(wszRule);
                                break;
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    }
                    break;

                case IDC_SPECIFYDIGITS:
                    {
                        CEditDialog ed;
                        WCHAR   *pwcSrc, *pwcDest;
                        INT_PTR iRes = ed.DoModal(hwndParent, IDS_SPECIFYDIGITS, IDS_TYPEDIGITS, IDS_DIGITS, 
                            LIF_ALLOWNUMBER|LIF_ALLOWPOUND|LIF_ALLOWSTAR|LIF_ALLOWSPACE|LIF_ALLOWCOMMA|LIF_ALLOWPLUS|LIF_ALLOWBANG|LIF_ALLOWATOD);
                        if (iRes == (INT_PTR)IDOK)
                        {
                            SHTCharToUnicode(ed.GetString(), wszRule, ARRAYSIZE(wszRule));
                            // Strip the spaces
                            pwcSrc  = wszRule;
                            pwcDest = wszRule;
                            do
                            {
                                if(*pwcSrc != TEXT(' '))    // including the NULL
                                    *pwcDest++ = *pwcSrc;
                            } while(*pwcSrc++);
                            
                            if (!wszRule[0])
                                return 0;

                            lvi.lParam = (LPARAM)ClientAllocString(wszRule);
                        }
                        else
                        {
                            return 0;
                        }
                    }
                    break;
            }

            if (NULL != lvi.lParam)
            {
                GetDescriptionForRule((PWSTR)lvi.lParam, szText, ARRAYSIZE(szText));

                iItem = ListView_InsertItem(hwndList, &lvi);
                ListView_EnsureVisible(hwndList, iItem, FALSE);
            }

            // a new rule was added, update the "has rule" state
            switch (iPage)
            {
            case 0:
                m_bHasLongDistance = TRUE;
                break;

            case 1:
                m_bHasInternational = TRUE;
                break;

            case 2:
                m_bHasLocal = TRUE;
                break;
            }

            // update the property sheet state
            SendMessage(GetParent(hwndParent), PSM_CHANGED, (WPARAM)hwndParent, 0);
        }
        break;

    default:
        break;
    }
    return 0;
}

void CCallingCardPropSheet::SetButtonStates(HWND hwndDlg, int iItem)
{
    EnableWindow(GetDlgItem(hwndDlg,IDC_MOVEUP), iItem>0);
    EnableWindow(GetDlgItem(hwndDlg,IDC_MOVEDOWN),
                 (-1!=iItem) && (ListView_GetItemCount(GetDlgItem(hwndDlg,IDC_LIST))-1)!=iItem);
    EnableWindow(GetDlgItem(hwndDlg,IDC_REMOVE), -1!=iItem);
}

BOOL CCallingCardPropSheet::OnNotify(HWND hwndDlg, LPNMHDR pnmhdr, int iPage)
{
    switch ( pnmhdr->idFrom )
    {
    case IDC_LIST:
        #define pnmlv ((LPNMLISTVIEW)pnmhdr)

        switch (pnmhdr->code)
        {
        case LVN_ITEMCHANGED:
            if (pnmlv->uChanged & LVIF_STATE)
            {
                if (pnmlv->uNewState & LVIS_SELECTED)
                {
                    SetButtonStates(hwndDlg,pnmlv->iItem);
                }
                else
                {
                    SetButtonStates(hwndDlg,-1);
                }
            }
            break;

        default:
            break;
        }
        break;
        #undef pnmlv

    default:
        switch (pnmhdr->code)
        {
        case PSN_APPLY:     // user pressed OK or Apply
            LOG((TL_INFO, "OnApply <%d>", iPage));
        case PSN_RESET:     // user pressed Cancel
        case PSN_KILLACTIVE: // user is switching pages
            HideToolTip();
            break;
        }
        break;
    }

    return 0;
}

BOOL CCallingCardPropSheet::UpdateRule(HWND hwndDlg, int iPage)
{
    LOG((TL_TRACE,  "UpdateRule <%d>",iPage));

    WCHAR wszRule[1024];
    PWSTR pwsz = wszRule;
    HWND hwnd = GetDlgItem(hwndDlg,IDC_LIST);

    // in case there are no rules, we need to NULL the string
    wszRule[0] = L'\0';

    // add up all the items in the list and set the correct string
    int iItems = ListView_GetItemCount(hwnd);
    if (iItems > MaxCallingCardRuleItems)
        iItems = MaxCallingCardRuleItems;

    LVITEM lvi;
    HRESULT hr = S_OK;
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    for (int i=0; i<iItems && SUCCEEDED(hr); i++)
    {
        lvi.iItem = i;
        ListView_GetItem(hwnd, &lvi);

        hr = StringCchCatExW(pwsz, 1024, (PWSTR)lvi.lParam, NULL, NULL, STRSAFE_NO_TRUNCATION);

        LOG((TL_INFO, "UpdateRule\tRule %d: %ls %s", i, lvi.lParam, FAILED(hr)?"FAILED":"SUCCEEDED"));
    }

    int iDlgItem;

    switch(iPage)
    {
    case 0:
        m_pCard->SetLongDistanceRule(wszRule);
        iDlgItem = IDC_LONGDISTANCENUMBER;
        break;

    case 1:
        m_pCard->SetInternationalRule(wszRule);
        iDlgItem = IDC_INTERNATIONALNUMBER;
        break;

    case 2:
        m_pCard->SetLocalRule(wszRule);
        iDlgItem = IDC_LOCALNUMBER;
        break;
    }

    TCHAR szText[MAX_INPUT];
    hwnd = GetDlgItem(hwndDlg,iDlgItem);
    GetWindowText(hwnd, szText, ARRAYSIZE(szText));
    SHTCharToUnicode(szText, wszRule, ARRAYSIZE(wszRule));

    switch(iPage)
    {
    case 0:
        m_pCard->SetLongDistanceAccessNumber(wszRule);
        break;

    case 1:
        m_pCard->SetInternationalAccessNumber(wszRule);
        break;

    case 2:
        m_pCard->SetLocalAccessNumber(wszRule);
        break;
    }

    return 0;
}

BOOL CCallingCardPropSheet::OnDestroy(HWND hwndDlg)
{
    HWND hwnd = GetDlgItem(hwndDlg,IDC_LIST);
    
    // Free the memory we allocated and track in the list view
    int iItems = ListView_GetItemCount(hwnd);
    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    for (int i=0; i<iItems; i++)
    {
        lvi.iItem = i;
        ListView_GetItem(hwnd, &lvi);

        ClientFree((PWSTR)lvi.lParam);
    }

    return TRUE;
}


BOOL  HasOnlyCommasW(PWSTR pwszStr)
{
    while(*pwszStr)
        if(*pwszStr++ != L',')
            return FALSE;

    return TRUE;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\cplcallingcardps.h ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplcallingcardps.h
                                                              
       Author:  toddb - 10/06/98
              
****************************************************************************/

#pragma once


class CCallingCardPropSheet
{
public:
    CCallingCardPropSheet(BOOL bNew, BOOL bShowPIN, CCallingCard * pCard, CCallingCards * pCards);
    ~CCallingCardPropSheet();
#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CCallingCardPropSheet)
#endif
    LONG DoPropSheet(HWND hwndParent);

protected:
    // functions for the general page
    static INT_PTR CALLBACK General_DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    BOOL General_OnInitDialog(HWND hwndDlg);
    BOOL General_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl);
    BOOL General_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr);
    BOOL Gerneral_OnApply(HWND hwndDlg);
    void SetTextForRules(HWND hwndDlg);

    // functions shared by all the other pages
    static INT_PTR CALLBACK DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    BOOL OnInitDialog(HWND hwndDlg, int iPage);
    BOOL OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl, int iPage);
    BOOL OnNotify(HWND hwndDlg, LPNMHDR pnmhdr, int iPage);
    BOOL OnDestroy(HWND hwndDlg);
    void SetButtonStates(HWND hwndDlg, int iItem);
    BOOL UpdateRule(HWND hwndDlg, int iPage);

    BOOL            m_bNew;     // True if this is a new location, false if we're editing an existing one
    BOOL			m_bShowPIN;	// True if it's safe to display the PIN
    CCallingCard *  m_pCard;    // pointer to the location object to use.
    CCallingCards * m_pCards;   // pointer to the list of all cards in the parent
    BOOL            m_bHasLongDistance;
    BOOL            m_bHasInternational;
    BOOL            m_bHasLocal;
    BOOL            m_bWasApplied;
};

typedef struct tagCCPAGEDATA
{
    CCallingCardPropSheet * pthis;
    int iWhichPage;
} CCPAGEDATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\cplcallingcardtab.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplcallingcardtab.cpp
                                                              
       Author:  toddb - 10/06/98

****************************************************************************/

//
// Functions used only by the Calling Card tab of the New Location Property Sheet.
// Shared functions are in the Location.cpp file.
//
#include "cplPreComp.h"
#include "cplLocationPS.h"


INT_PTR CALLBACK CLocationPropSheet::CallingCard_DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CLocationPropSheet* pthis = (CLocationPropSheet*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        pthis = (CLocationPropSheet*)(((PROPSHEETPAGE*)lParam)->lParam);
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis); 
        return pthis->CallingCard_OnInitDialog(hwndDlg);

    case WM_COMMAND:
        pthis->CallingCard_OnCommand(hwndDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam );
        return 1;

    case WM_NOTIFY:
        return pthis->CallingCard_OnNotify(hwndDlg, (LPNMHDR)lParam);
   
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        WinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a104HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        WinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a104HelpIDs);
        break;
    }

    return 0;
}

BOOL CLocationPropSheet::CallingCard_OnInitDialog(HWND hDlg)
{
    RECT rc;
    HWND hwnd = GetDlgItem(hDlg, IDC_LIST);

    GetClientRect(hwnd, &rc);

    LVCOLUMN lvc;
    lvc.mask = LVCF_SUBITEM | LVCF_WIDTH;
    lvc.iSubItem = 0;
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn( hwnd, 0, &lvc );
    
    ListView_SetExtendedListViewStyleEx(hwnd, 
        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT, 
        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT);

    m_dwDefaultCard = m_pLoc->GetPreferredCardID();
    if ( 0 == m_dwDefaultCard )
    {
        // Card0 is the "None (Direct Dial)" card which we want to go away
        m_pLoc->UseCallingCard(FALSE);
    }

    PopulateCardList( hwnd );

	// The PIN is not displayed when it's not safe (at logon time, for ex.)

	m_bShowPIN = TapiIsSafeToDisplaySensitiveData();
	
    SetDataForSelectedCard(hDlg);

    hwnd = GetDlgItem(hDlg,IDC_CARDNUMBER);
    SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);
    LimitInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWSPACE);

    hwnd = GetDlgItem(hDlg,IDC_PIN);
    SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);
    LimitInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWSPACE);

    return 0;
}

int CALLBACK CallingCard_ListSort(LPARAM lItem1, LPARAM lItem2, LPARAM )
{
    if ( !lItem1 )
    {
        return -1;
    }
    if ( !lItem2 )
    {
        return 1;
    }

    CCallingCard * pCard1 = (CCallingCard *)lItem1;
    CCallingCard * pCard2 = (CCallingCard *)lItem2;

    return StrCmpIW(pCard1->GetCardName(),pCard2->GetCardName());
}

void CLocationPropSheet::PopulateCardList( HWND hwndList )
{
    CCallingCard * pCard;

    HIMAGELIST himl = ImageList_Create(16, 16, ILC_COLOR|ILC_MASK, 2, 2);
    HBITMAP hBmp = CreateMappedBitmap(GetUIInstance(), IDB_BUTTONS, 0, NULL, 0);

    if (NULL != hBmp)
    {
        ImageList_AddMasked( himl, hBmp, CLR_DEFAULT);
        DeleteObject( hBmp );
    }

    ListView_SetImageList(hwndList, himl, LVSIL_SMALL);

    // Add our special "none" item
    AddCardToList(hwndList,NULL,FALSE);

    m_Cards.Initialize();
    m_Cards.Reset(TRUE);    // TRUE means show "hidden" cards, FALSE means hide them

    while ( S_OK == m_Cards.Next(1,&pCard,NULL) )
    {
        if ( !pCard->IsMarkedHidden() )
        {
            // Card0 is the "None (Direct Dial)" card which we don't want to show
            if ( 0 != pCard->GetCardID() )
            {
                AddCardToList(hwndList,pCard,FALSE);
            }
        }
    }

    ListView_SortItems(hwndList, CallingCard_ListSort, 0);

    EnsureVisible(hwndList, m_pCard);
}

void CLocationPropSheet::AddCardToList(HWND hwndList, CCallingCard * pCard, BOOL bSelect)
{
    TCHAR szText[MAX_INPUT];
    // basically, bSelect is FALSE when we are first populating the list and TRUE when we
    // add items later.  When the value is FALSE what we really mean is "Select the item
    // only if it is the currently selected item based on the location settings".
    if (pCard)
    {
        SHUnicodeToTChar(pCard->GetCardName(), szText, ARRAYSIZE(szText));
        bSelect = bSelect || ((m_dwDefaultCard != 0) && (m_dwDefaultCard==pCard->GetCardID()));
    }
    else
    {
        LoadString(GetUIInstance(), IDS_NONE, szText, ARRAYSIZE(szText));
        bSelect = bSelect || !(m_dwDefaultCard != 0);
    }

    LVITEM lvi;
    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    lvi.iItem = 0;
    lvi.iSubItem = 0;
    lvi.pszText = szText;
    lvi.iImage = 0;
    lvi.lParam = (LPARAM)pCard;

    if ( bSelect )
    {
        lvi.mask |= LVIF_STATE;
        lvi.state = lvi.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
        lvi.iImage = 1;
        SetCheck(hwndList, m_pCard, FALSE);
        m_pCard = pCard;
    }

    ListView_InsertItem(hwndList, &lvi);
}

void CLocationPropSheet::SetCheck(HWND hwndList, CCallingCard * pCard, int iImage)
{
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM)pCard;
    int iItem = ListView_FindItem(hwndList,-1,&lvfi);

    if (-1 != iItem)
    {
        LVITEM lvi;
        lvi.mask = LVIF_IMAGE;
        lvi.iItem = iItem;
        lvi.iSubItem = 0;
        lvi.iImage = iImage;

        ListView_SetItem( hwndList, &lvi );
        ListView_Update( hwndList, iItem ); // need the font to be drawn non-bold
    }
}

void CLocationPropSheet::EnsureVisible(HWND hwndList, CCallingCard * pCard)
{
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM)pCard;
    int iItem = ListView_FindItem(hwndList,-1,&lvfi);

    if (-1 != iItem)
    {
        ListView_EnsureVisible( hwndList, iItem, FALSE );
    }

}

void CLocationPropSheet::UpdateCardInList(HWND hwndList, CCallingCard * pCard)
{
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM)pCard;
    int iItem = ListView_FindItem(hwndList,-1,&lvfi);

    if (-1 != iItem)
    {
        TCHAR szText[MAX_INPUT];
        SHUnicodeToTChar( pCard->GetCardName(), szText, ARRAYSIZE(szText) );

        LVITEM lvi;
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iItem = iItem;
        lvi.iSubItem = 0;
        lvi.pszText = szText;
        lvi.lParam = (LONG_PTR)pCard;

        ListView_SetItem( hwndList, &lvi );
    }
}

void CLocationPropSheet::SetDataForSelectedCard(HWND hDlg)
{
    // if a card is selected, then set the text for:
    //  PIN Number
    //  Card Number
    //  Long Distance Access Number
    //  International Access Number
    if ( m_pCard )
    {
        TCHAR szText[MAX_INPUT];

        if(m_bShowPIN)
        {
        	SHUnicodeToTChar(m_pCard->GetPIN(), szText, ARRAYSIZE(szText));
        	SetWindowText( GetDlgItem(hDlg, IDC_PIN), szText );
        }
        else
        {
	        SetWindowText( GetDlgItem(hDlg, IDC_PIN), TEXT("") );
        }

        SHUnicodeToTChar(m_pCard->GetAccountNumber(), szText, ARRAYSIZE(szText));
        SetWindowText( GetDlgItem(hDlg, IDC_CARDNUMBER), szText );

        SHUnicodeToTChar(m_pCard->GetLongDistanceAccessNumber(), szText, ARRAYSIZE(szText));
        SetWindowText( GetDlgItem(hDlg, IDC_LONGDISTANCE), szText );

        SHUnicodeToTChar(m_pCard->GetInternationalAccessNumber(), szText, ARRAYSIZE(szText));
        SetWindowText( GetDlgItem(hDlg, IDC_INTERNATIONAL), szText );

        SHUnicodeToTChar(m_pCard->GetLocalAccessNumber(), szText, ARRAYSIZE(szText));
        SetWindowText( GetDlgItem(hDlg, IDC_LOCAL), szText );
    }
    else
    {
        SetWindowText( GetDlgItem(hDlg, IDC_PIN), TEXT("") );
        SetWindowText( GetDlgItem(hDlg, IDC_CARDNUMBER), TEXT("") );
        SetWindowText( GetDlgItem(hDlg, IDC_LONGDISTANCE), TEXT("") );
        SetWindowText( GetDlgItem(hDlg, IDC_INTERNATIONAL), TEXT("") );
        SetWindowText( GetDlgItem(hDlg, IDC_LOCAL), TEXT("") );
    }

    // The button state depends on whether a card is selected
    BOOL bEnable = 0!=m_pCard;
    EnableWindow( GetDlgItem(hDlg, IDC_EDIT),       bEnable );
    HWND hwnd = GetDlgItem(hDlg, IDC_DELETE);
    if ( !bEnable && GetFocus() == hwnd )
    {
        HWND hwndDef = GetDlgItem(hDlg, IDC_NEW);
        SendMessage(hwnd, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE,0));
        SendMessage(hwndDef, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE,0));
        SetFocus(hwndDef);
    }
    EnableWindow( hwnd, bEnable );
    EnableWindow( GetDlgItem(hDlg, IDC_SETDEFAULT), bEnable );

    EnableWindow( GetDlgItem(hDlg, IDC_PIN), bEnable );
    EnableWindow( GetDlgItem(hDlg, IDC_CARDNUMBER), bEnable );
}

BOOL CLocationPropSheet::CallingCard_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl)
{
    switch ( wID )
    {
    case IDC_NEW:
    case IDC_EDIT:
        LaunchCallingCardPropSheet(IDC_NEW == wID, hwndParent);
        break;

    case IDC_DELETE:
        DeleteSelectedCard(GetDlgItem(hwndParent,IDC_LIST));
        break;

    case IDC_PIN:
    case IDC_CARDNUMBER:
        if ( EN_CHANGE == wNotifyCode )
        {
            SendMessage(GetParent(hwndParent),PSM_CHANGED,(WPARAM)hwndParent,0);
        }
        break;

    default:
        return 0;
    }
    return 1;
}

void CLocationPropSheet::LaunchCallingCardPropSheet(BOOL bNew, HWND hwndParent)
{
    CCallingCard * pCard;
    if ( bNew )
    {
        TCHAR szCardName[MAX_INPUT];
        WCHAR wszCardName[MAX_INPUT];

        pCard = new CCallingCard;
		if (NULL == pCard)
		{
			// Nothing much to do.
			return;
		}
        LoadString(GetUIInstance(), IDS_NEWCALLINGCARD, szCardName, ARRAYSIZE(szCardName));
        SHTCharToUnicode(szCardName, wszCardName, ARRAYSIZE(wszCardName));
        pCard->Initialize(
            0,
            wszCardName,
            0,
            L"",
            L"",
            L"",
            L"",
            L"",
            L"",
            L"",
            L"" );
    }
    else
    {
        pCard = m_pCard;
        if ( !pCard )
        {
            // must have clicked on the None card, do nothing.  We can only get
            // here when the user double clicks on an item.
            MessageBeep(0);
            return;
        }
    }

    CCallingCardPropSheet ccps( bNew, m_bShowPIN, pCard, &m_Cards );
    int iRes = ccps.DoPropSheet(hwndParent);

    if ( PSN_APPLY == iRes )
    {
        HWND hwndList = GetDlgItem(hwndParent,IDC_LIST);
        if ( bNew )
        {
            pCard->SetCardID(m_Cards.AllocNewCardID());
            m_Cards.AddCard(pCard);
            AddCardToList(hwndList, pCard, TRUE);
        }
        else
        {
            UpdateCardInList(hwndList, pCard);
        }
        ListView_SortItems(hwndList, CallingCard_ListSort, 0);

        EnsureVisible(hwndList, pCard);

		// It's safe to display the PIN number after an Apply in the detail dialog
		m_bShowPIN = TRUE;
        SetDataForSelectedCard(hwndParent);

        SendMessage(GetParent(hwndParent),PSM_CHANGED,(WPARAM)hwndParent,0);
    }
    else if (bNew)
    {
        delete pCard;
    }
}

BOOL CLocationPropSheet::CallingCard_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr)
{
    // Let the generic handler have a crack at it first
    OnNotify(hwndDlg, pnmhdr);

    switch (pnmhdr->idFrom)
    {
    case IDC_LIST:
        #define pnmlv ((LPNMLISTVIEW)pnmhdr)

        switch (pnmhdr->code)
        {
        case LVN_ITEMCHANGED:
            if ( (pnmlv->uChanged & LVIF_STATE) && (pnmlv->uNewState & LVIS_SELECTED) )
            {
                LVITEM lvi;
                lvi.iItem = pnmlv->iItem;
                lvi.iSubItem = pnmlv->iSubItem;
                lvi.mask = LVIF_PARAM;
                ListView_GetItem( pnmhdr->hwndFrom, &lvi );
                CCallingCard * pCard = (CCallingCard *)lvi.lParam;

                // update the location to reflect the selected card
                if ( 0!=pCard )
                {
                    m_dwDefaultCard = pCard->GetCardID();
                }
                else
                {
                    m_dwDefaultCard = 0;
                }

                // clear the previous check using the old m_pCard value
                SetCheck(pnmhdr->hwndFrom, m_pCard, FALSE);

                // Update m_pCard to the currently selected item
                m_pCard = pCard;

                // set the Edit and Delete button states and update the card info
                m_bShowPIN = TapiIsSafeToDisplaySensitiveData();
                SetDataForSelectedCard(hwndDlg);

                // set the newly selected card to checked
                SetCheck(pnmhdr->hwndFrom, m_pCard, TRUE);
            }
            break;

        case NM_DBLCLK:
            // Assert( pCard == m_pCard );
            if ( -1 != pnmlv->iItem )
            {
                // Do edit case
                LaunchCallingCardPropSheet(FALSE,hwndDlg);
            }
            else
            {
                // Do new case
                LaunchCallingCardPropSheet(TRUE,hwndDlg);
            }
            break;

        case NM_CUSTOMDRAW:
            #define lplvcd ((LPNMLVCUSTOMDRAW)pnmhdr)

            if(lplvcd->nmcd.dwDrawStage == CDDS_PREPAINT)
            {
                // Request prepaint notifications for each item.
                SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,CDRF_NOTIFYITEMDRAW);
                return CDRF_NOTIFYITEMDRAW;
            }

            if(lplvcd->nmcd.dwDrawStage == CDDS_ITEMPREPAINT)
            {
                LVITEM lvi;
                lvi.iItem = (int)lplvcd->nmcd.dwItemSpec;
                lvi.iSubItem = 0;
                lvi.mask = LVIF_PARAM;
                ListView_GetItem( pnmhdr->hwndFrom, &lvi );
                CCallingCard * pCard = (CCallingCard *)lvi.lParam;

                if( (!pCard && 0 == m_dwDefaultCard) || 
                    (pCard && pCard->GetCardID() == m_dwDefaultCard) )
                {
                    extern HFONT g_hfontBold;
                    if (g_hfontBold)
                    {
                        SelectObject(lplvcd->nmcd.hdc, g_hfontBold);
                        SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,CDRF_NEWFONT);
                        return CDRF_NEWFONT;
                    }
                }

                SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,CDRF_DODEFAULT);
                return CDRF_DODEFAULT;
            }
            return 0;
            #undef lplvcd

        default:
            break;
        }
        break;
        #undef pnmlv

    default:
        switch (pnmhdr->code)
        {
        case PSN_APPLY:
            return CallingCard_OnApply(hwndDlg);

        default:
            break;
        }
        return 0;
    }
    return 1;
}

BOOL CLocationPropSheet::CallingCard_OnApply(HWND hwndDlg)
{
    // if a calling card should be used make sure one is selected
    if ( m_dwDefaultCard != 0 )
    {
        CCallingCard * pCard = m_Cards.GetCallingCard(m_dwDefaultCard);

        if ( !pCard )
        {
            HWND hwndList = GetDlgItem(hwndDlg,IDC_LIST);
            // error, no card is set as the default
            PropSheet_SetCurSelByID(GetParent(hwndDlg),IDD_LOC_CALLINGCARD);
            ShowErrorMessage(hwndList, IDS_NOCARDSELECTED);
            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,PSNRET_INVALID_NOCHANGEPAGE);
            return TRUE;
        }

        // Store the original values before we change them:
        WCHAR wszOldCardNum[128];
        WCHAR wszOldPIN[128];
        StrCpyNW( wszOldCardNum, pCard->GetAccountNumber(), ARRAYSIZE(wszOldCardNum));
        StrCpyNW( wszOldPIN, pCard->GetPIN(), ARRAYSIZE(wszOldPIN));

        // get the current values:
        TCHAR szText[MAX_INPUT];
        WCHAR wszBuf[MAX_INPUT];

        GetWindowText(GetDlgItem(hwndDlg,IDC_CARDNUMBER), szText, ARRAYSIZE(szText));
        LOG((TL_INFO, "CallingCard_OnApply: Setting card number to %s", szText));
        SHTCharToUnicode(szText, wszBuf, ARRAYSIZE(wszBuf));
        pCard->SetAccountNumber(wszBuf);

        GetWindowText(GetDlgItem(hwndDlg,IDC_PIN), szText, ARRAYSIZE(szText));
        LOG((TL_INFO, "CallingCard_OnApply: Setting pin number to %s", szText));
        SHTCharToUnicode(szText, wszBuf, ARRAYSIZE(wszBuf));
        pCard->SetPIN(wszBuf);

        // check for validity:
        DWORD dwResult = pCard->Validate();
        if ( dwResult )
        {
            HWND hwnd;
            int iStrID;

            // something isn't valid, revert to old card Num and PIN in case
            // the user later decided to cancel
            pCard->SetAccountNumber(wszOldCardNum);
            pCard->SetPIN(wszOldPIN);

            if ( dwResult & CCVF_NOCARDNUMBER)
            {
                hwnd = GetDlgItem(hwndDlg, IDC_CARDNUMBER);
                iStrID = IDS_MUSTENTERCARDNUMBER;
            }
            else if ( dwResult & CCVF_NOPINNUMBER )
            {
                hwnd = GetDlgItem(hwndDlg, IDC_PIN);
                iStrID = IDS_MUSTENTERPINNUMBER;
            }
            else
            {
                hwnd = GetDlgItem(hwndDlg, IDC_LIST);
                iStrID = IDS_INVALIDCARD;
            }
            PropSheet_SetCurSelByID(GetParent(hwndDlg),IDD_LOC_CALLINGCARD);
            ShowErrorMessage(hwnd, iStrID);
            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,PSNRET_INVALID_NOCHANGEPAGE);
            return TRUE;
        }
    }

    m_pLoc->SetPreferredCardID(m_dwDefaultCard);
    m_pLoc->UseCallingCard(m_dwDefaultCard != 0);
    m_Cards.SaveToRegistry();
    m_bShowPIN = TRUE;
    m_bWasApplied = TRUE;
    return PSNRET_NOERROR;
}

int DeleteItemAndSelectFirst( HWND hwndParent, int iList, int iItem, int iDel, int iAdd )
{
    HWND hwnd = GetDlgItem(hwndParent, iList);
    ListView_DeleteItem(hwnd, iItem);

    // Try to select the first item, if possible
    iItem = 0;
    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    if ( ListView_GetItem(hwnd, &lvi) )
    {
        ListView_SetItemState(hwnd, iItem, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
        ListView_EnsureVisible(hwnd, iItem, FALSE);
    }
    else
    {
        iItem = -1;
    }

    hwnd = GetDlgItem(hwndParent,iDel);
    if ( -1 == iItem )
    {
        if ( GetFocus() == hwnd )
        {
            HWND hwndDef = GetDlgItem(hwndParent,iAdd);
            SendMessage(hwnd, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE,0));
            SendMessage(hwndDef, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE,0));
            SetFocus(hwndDef);
        }
    }
    EnableWindow(hwnd, -1!=iItem);

    return iItem;
}

void CLocationPropSheet::DeleteSelectedCard(HWND hwndList)
{
    // First we confirm the delete with the user
    TCHAR szText[1024];
    TCHAR szTitle[128];
    int result;
    HWND hwndParent = GetParent(hwndList);
    
    LoadString(GetUIInstance(), IDS_DELETECARDTEXT, szText, ARRAYSIZE(szText));
    LoadString(GetUIInstance(), IDS_CONFIRMDELETE, szTitle, ARRAYSIZE(szTitle));

    result = SHMessageBoxCheck( hwndParent, szText, szTitle, MB_YESNO, IDYES, TEXT("TAPIDeleteCallingCard") );
    if ( IDYES == result )
    {
        // remove the item corresponding to m_pCard from the list
        LVFINDINFO lvfi;
        lvfi.flags = LVFI_PARAM;
        lvfi.lParam = (LPARAM)m_pCard;
        int iItem = ListView_FindItem(hwndList, -1, &lvfi);
        if ( -1 != iItem )
        {
            HWND hwndParent = GetParent(hwndList);
            m_Cards.RemoveCard(m_pCard);
            iItem = DeleteItemAndSelectFirst( hwndParent, IDC_LIST, iItem, IDC_DELETE, IDC_ADD );

            if ( -1 != iItem )
            {
                LVITEM lvi;
                lvi.iItem = iItem;
                lvi.iSubItem = 0;
                lvi.mask = LVIF_PARAM;
                ListView_GetItem( hwndList, &lvi );

                // Store the currently selected item
                m_pCard = (CCallingCard*)lvi.lParam;
            }
            else
            {
                m_pCard = NULL;
            }

			m_bShowPIN = TapiIsSafeToDisplaySensitiveData();

            SetDataForSelectedCard(hwndParent);
            SendMessage(GetParent(hwndParent), PSM_CHANGED, (WPARAM)hwndParent, 0);
        }
        else
        {
            // It's really bad if this ever happens (which it shouldn't).  This means our
            // data is in an unknown state and we might do anything (even destroy data).
            LOG((TL_ERROR, "DeleteSelectedCard: Card Not Found!"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\cpldialingrulesps.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cpldialingrulesps.cpp
                                                              
       Author:  toddb - 10/06/98

****************************************************************************/


// Property Sheet stuff for the main page
#include "cplPreComp.h"
#include "cplLocationPS.h"

#include <setupapi.h>       // for HDEVINFO
#include <winuser.h>        // for HDEVNOTIFY


// Global Variables

HFONT g_hfontBold = NULL;
HINSTANCE g_hInstUI = NULL;

// Prototypes

BOOL CALLBACK SetToForegroundEnumProc( HWND hwnd, LPARAM lParam );
extern "C" INT_PTR CALLBACK LocWizardDlgProc( HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam );

extern "C" LONG EnsureOneLocation (HWND hwnd);

void CountryRunOnce();

class CDialingRulesPropSheet
{
public:
    CDialingRulesPropSheet(LPCWSTR pwszAddress, DWORD dwAPIVersion);
    ~CDialingRulesPropSheet();

#ifdef	TRACELOG
	DECLARE_TRACELOG_CLASS(CDialingRulesPropSheet)
#endif

    LONG DoPropSheet(HWND hwndParent, int iTab);

protected:
    LONG CheckForOtherInstances();

    static INT_PTR CALLBACK Dailing_DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    BOOL Dailing_OnInitDialog(HWND hDlg);
    BOOL Dailing_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl);
    BOOL Dailing_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr);
    void LaunchLocationPropSheet(BOOL bNew, HWND hwndParent);
    void DeleteSelectedLocation(HWND hwndList);
    void AddLocationToList(HWND hwndList, CLocation *pLoc, BOOL bSelect);
    void UpdateLocationInList(HWND hwndList, CLocation *pLocOld, CLocation *pLocNew);
    void UpdateControlStates(HWND hDlg);
    void SetCheck(HWND hwndList, CLocation * pLoc, int iImage);

    static INT_PTR CALLBACK Advanced_DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    BOOL Advanced_OnInitDialog(HWND hDlg);
    BOOL Advanced_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl);

    HANDLE      m_hMutex;
    DWORD       m_dwDefaultCountryID;
    CLocation * m_pLocSelected; // pointer the the CLocation for the selected item in the list view.
                                // can be NULL if no item is selected.

    CLocations  m_locs;         // The locations data used to build the locations list
    LPCWSTR     m_pwszAddress;  // The address (number) we are translating

    int         m_iSortCol;     // which column to sort by

    DWORD       m_dwAPIVersion; // The version of tapi used to call internalConfig
};


CDialingRulesPropSheet::CDialingRulesPropSheet(LPCWSTR pwszAddress, DWORD dwAPIVersion)
{
    m_pwszAddress = pwszAddress;
    m_hMutex = NULL;
    m_pLocSelected = NULL;
    m_dwDefaultCountryID = GetProfileInt(TEXT("intl"), TEXT("iCountry"), 1);
    m_iSortCol = 0;
    m_dwAPIVersion = dwAPIVersion;
}


CDialingRulesPropSheet::~CDialingRulesPropSheet()
{
    if ( m_hMutex )
        CloseHandle( m_hMutex );
}

typedef struct tagMODEMDLG
{
    HDEVINFO    hdi;
    HDEVNOTIFY  NotificationHandle;
    int         cSel;
    DWORD       dwFlags;
} MODEMDLG, FAR * LPMODEMDLG;


LONG CDialingRulesPropSheet::DoPropSheet(HWND hwndParent, int iTab)
{
    LONG result;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  ahpsp[3];
    PROPSHEETPAGE   apsp[3];
    HINSTANCE       hInstModemUI = NULL;

    DLGPROC         pfnModemDialogProc = NULL;
    MODEMDLG md;
    md.hdi = INVALID_HANDLE_VALUE;
    md.cSel  = 0;
    md.dwFlags = 0;

    result = CheckForOtherInstances();
    if ( result )
    {
        return result;
    }

    // if iTab is -1 then we only show the dialing rules tab and we hide the modem
    // and advanced tabs.  When lineTranslateDialog is called we pass -1 for iTab,
    // when the CPL is invoked we pass the starting page number as iTab.
    if ( -1 != iTab )
    {
        // we can't link directly to modemui.dll because we live inside TAPI,
        // so delay load all the required MODEMUI functions up front.
        hInstModemUI = LoadLibrary(TEXT("modemui.dll"));
		if (!hInstModemUI)
		{
			return FALSE;
		}
            // get proc the functions we need.
        pfnModemDialogProc = (DLGPROC)GetProcAddress(hInstModemUI,"ModemCplDlgProc");
		if ( !pfnModemDialogProc )
		{
			FreeLibrary(hInstModemUI);
			return FALSE;   // Review: Does this return code matter?
		}
    }

    // Review: The old dialing page had some pre-launch configuration to do.
    // Some sort of lineConfigure function or something.  Check if this is needed.

    // We delay the initialization until here
    result = (LONG)m_locs.Initialize();
    if (result && (result != LINEERR_INIFILECORRUPT))
    {
        TCHAR szCaption[MAX_INPUT];
        TCHAR szMessage[512];

        LoadString(GetUIInstance(), IDS_NAME, szCaption, ARRAYSIZE(szCaption));
        LoadString(GetUIInstance(), IDS_CANNOT_START_TELEPHONCPL, szMessage, ARRAYSIZE(szMessage));
        MessageBox(hwndParent, szMessage, szCaption, MB_OK | MB_ICONWARNING);
        return result;
    }

    // If there are no locations, launch the simple location dialog
    if ( 0 == m_locs.GetNumLocations() )
    {
        // if we are in lineTranslateDialog mode, then we display the simple
        int iRes;
        iRes = (int)DialogBoxParam(GetUIInstance(), MAKEINTRESOURCE(IDD_SIMPLELOCATION),NULL,
            LocWizardDlgProc, (LPARAM)m_dwAPIVersion);

        if ( IDOK == iRes )
        {
            // now we need to re-initalize to pick up the new location
            m_locs.Initialize();

            // Now we need to figure out the ID of the location we just created
            CLocation * pLoc;
            m_locs.Reset();
            if ( S_OK == m_locs.Next( 1, &pLoc, NULL ) )
            {
                // Set this ID as the default location
                m_locs.SetCurrentLocationID(pLoc->GetLocationID());
                CountryRunOnce();
            }

            // we've already made a commited change, so save the result
            m_locs.SaveToRegistry();
            result = NO_ERROR;
        }
        else
        {
            // If this was lineTranslateDialog and the user canceled the simple location
            // dialog then we have already warned them of what might happen.  If this is
            // a down level legacy call then we return an old error code
            if ( m_dwAPIVersion < TAPI_VERSION2_2 )
            {
                // return an old error code that legacy apps understand
                return LINEERR_OPERATIONFAILED;
            }
            else
            {
                // as of TAPI_VERSION2_2 we have a new error value just for this case:
                return LINEERR_USERCANCELLED;
            }
        }
    }

    // Initialize the header:
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_DEFAULT;
    psh.hwndParent = hwndParent;
    psh.hInstance = GetUIInstance();
    psh.hIcon = NULL;
    psh.pszCaption = MAKEINTRESOURCE(IDS_NAME);
    psh.nPages = (-1!=iTab)?3:1;
    psh.nStartPage = (-1!=iTab)?iTab:0;
    psh.pfnCallback = NULL;
    psh.phpage = ahpsp;


    // Now setup the Property Sheet Page
    apsp[0].dwSize = sizeof(apsp[0]);
    apsp[0].dwFlags = PSP_DEFAULT;
    apsp[0].hInstance = GetUIInstance();
    apsp[0].pszTemplate = MAKEINTRESOURCE(IDD_MAIN_DIALINGRULES);
    apsp[0].pfnDlgProc = CDialingRulesPropSheet::Dailing_DialogProc;
    apsp[0].lParam = (LPARAM)this;
    ahpsp[0] = CreatePropertySheetPage (&apsp[0]);

    if ( -1 != iTab )
    {
        apsp[1].dwSize = sizeof(apsp[1]);
        apsp[1].dwFlags = PSP_DEFAULT;
        apsp[1].hInstance = hInstModemUI;
        apsp[1].pszTemplate = MAKEINTRESOURCE(20011);
        apsp[1].pfnDlgProc = pfnModemDialogProc;
        apsp[1].lParam = (LPARAM)&md;
        ahpsp[1] = CreatePropertySheetPage (&apsp[1]);

        apsp[2].dwSize = sizeof(apsp[2]);
        apsp[2].dwFlags = PSP_DEFAULT;
        apsp[2].hInstance = GetUIInstance();
        apsp[2].pszTemplate = MAKEINTRESOURCE(IDD_MAIN_ADVANCED);
        apsp[2].pfnDlgProc = CDialingRulesPropSheet::Advanced_DialogProc;
        apsp[2].lParam = 0;
        ahpsp[2] = CreatePropertySheetPage (&apsp[2]);
    }

    if (-1 == PropertySheet( &psh ))
    {
        result = GetLastError ();
        LOG ((TL_ERROR, "PropertySheet failed, error 0x%x", result));
    }

    // now we're done with modemui, so release it.
    if(hInstModemUI)
        FreeLibrary(hInstModemUI);

    return result;
}

LONG CDialingRulesPropSheet::CheckForOtherInstances()
{
    TCHAR szCaption[MAX_INPUT];
    if ( !LoadString(GetUIInstance(), IDS_NAME, szCaption, 128) )
    {
        return LINEERR_OPERATIONFAILED;
    }

    m_hMutex = CreateMutex (NULL, FALSE, TEXT("tapi_dp_mutex"));
    if (!m_hMutex)
    {
        return LINEERR_OPERATIONFAILED;
    }
    else if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        EnumWindows( SetToForegroundEnumProc, (LPARAM)szCaption );
        return LINEERR_INUSE;
    }
    return 0;
}

BOOL CALLBACK SetToForegroundEnumProc( HWND hwnd, LPARAM lParam )
{
    TCHAR szBuf[MAX_INPUT];

    GetWindowText (hwnd, szBuf, 128);

    if (!lstrcmpi (szBuf, (LPTSTR)lParam))
    {
        SetForegroundWindow (hwnd);
        return FALSE;
    }

    return TRUE;
}

extern "C" LONG WINAPI internalConfig( HWND hwndParent, PCWSTR pwsz, INT iTab, DWORD dwAPIVersion )
{
    CDialingRulesPropSheet drps(pwsz, dwAPIVersion);

    return drps.DoPropSheet(hwndParent, iTab);
}


// ********************************************************************
//
// Dialing Rules Property Page functions
//
// ********************************************************************



INT_PTR CALLBACK CDialingRulesPropSheet::Dailing_DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CDialingRulesPropSheet* pthis = (CDialingRulesPropSheet*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        pthis = (CDialingRulesPropSheet*)(((PROPSHEETPAGE*)lParam)->lParam);
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis);
        return pthis->Dailing_OnInitDialog(hwndDlg);

    case WM_COMMAND:
        return pthis->Dailing_OnCommand(hwndDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam );

    case WM_NOTIFY:
        return pthis->Dailing_OnNotify(hwndDlg, (LPNMHDR)lParam);
   
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        WinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a101HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        WinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a101HelpIDs);
        break;
    }

    return 0;
}

int CALLBACK Dialing_ListSort(LPARAM lItem1, LPARAM lItem2, LPARAM lCol)
{
    if (!lItem1)
    {
        return -1;
    }
    if (!lItem2)
    {
        return 1;
    }

    CLocation * pLoc1 = (CLocation *)lItem1;
    CLocation * pLoc2 = (CLocation *)lItem2;

    if ( 1 == lCol)
    {
        // sort based on column 1, the area code
        int iAC1 = StrToIntW(pLoc1->GetAreaCode());
        int iAC2 = StrToIntW(pLoc2->GetAreaCode());

        if (iAC1!=iAC2)
            return iAC1-iAC2;

        // fall through if the area codes are identical
    }

    // sort based on column 0, the location name
    return StrCmpIW(pLoc1->GetName(), pLoc2->GetName());
}

BOOL CDialingRulesPropSheet::Dailing_OnInitDialog(HWND hDlg)
{
    // Setup the header for the list control
    RECT rc;
    TCHAR szText[MAX_INPUT];
    HWND hwndList = GetDlgItem(hDlg, IDC_LIST);

    GetClientRect(hwndList, &rc);

    int cxList = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    LVCOLUMN lvc;
    lvc.mask = LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    lvc.pszText = szText;

    struct {
        int iStrID;
        int cxPercent;
    } aData[] = {
        { IDS_LOCATION, 70 },
        { IDS_AREACODE, 30 },
    };

    for (int i=0; i<ARRAYSIZE(aData); i++)
    {
        LoadString(GetUIInstance(), aData[i].iStrID, szText, ARRAYSIZE(szText));
        lvc.iSubItem = i;
        lvc.cx = MulDiv(cxList, aData[i].cxPercent, 100);
        ListView_InsertColumn( hwndList, i, &lvc );
    }

    ListView_SetExtendedListViewStyleEx(hwndList,
        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT,
        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT);

    HIMAGELIST himl = ImageList_Create(16, 16, ILC_COLOR|ILC_MASK, 2, 2);
    HBITMAP hBmp = CreateMappedBitmap(GetUIInstance(), IDB_BUTTONS, 0, NULL, 0);
    if (NULL != hBmp)
    {
        ImageList_AddMasked( himl, hBmp, CLR_DEFAULT);
        DeleteObject( hBmp );
    }
    ListView_SetImageList(hwndList, himl, LVSIL_SMALL);

    m_locs.Reset();

    CLocation * pLoc;
    DWORD dwCurLocID = m_locs.GetCurrentLocationID();

    while ( S_OK == m_locs.Next( 1, &pLoc, NULL ) )
    {
        AddLocationToList( hwndList, pLoc, FALSE );

        if ( pLoc->GetLocationID() == dwCurLocID )
        {
            m_dwDefaultCountryID = pLoc->GetCountryID();
        }
    }

    int iItems = m_locs.GetNumLocations();

    UpdateControlStates(hDlg);

    ListView_SortItems( hwndList, Dialing_ListSort, m_iSortCol);

    SetCheck(hwndList, m_pLocSelected, TRUE);

    if (!m_pwszAddress)
    {
        ShowWindow(GetDlgItem(hDlg,IDC_PHONENUMBERTEXT), SW_HIDE);
    }
    else if (m_pLocSelected)
    {
        UpdateSampleString(GetDlgItem(hDlg, IDC_PHONENUMBERSAMPLE), m_pLocSelected, m_pwszAddress, NULL);
    }

    // Select the default item from the location list:
    SetFocus(hwndList);

    return 0;
}

void CDialingRulesPropSheet::UpdateControlStates(HWND hDlg)
{
    int iItems = m_locs.GetNumLocations();

    // Set the button states
    EnableWindow( GetDlgItem(hDlg, IDC_EDIT),   0!=m_pLocSelected );
    EnableWindow( GetDlgItem(hDlg, IDC_SETDEFAULT), 0!=m_pLocSelected );

    // if nothing is selected or there is only one item then you cannot
    // delete that item
    EnableWindow( GetDlgItem(hDlg, IDC_DELETE), ((m_pLocSelected)&&(1<iItems)) );
}

void CDialingRulesPropSheet::AddLocationToList(HWND hwndList, CLocation *pLoc, BOOL bSelected)
{
    TCHAR szText[MAX_INPUT];
    SHUnicodeToTChar( pLoc->GetName(), szText, ARRAYSIZE(szText) );

    LVITEM lvi;
    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    lvi.iItem = 0;
    lvi.iSubItem = 0;
    lvi.pszText = szText;
    lvi.iImage = 0;
    lvi.lParam = (LONG_PTR)pLoc;

    bSelected = bSelected || (pLoc->GetLocationID() == m_locs.GetCurrentLocationID());
    if ( bSelected )
    {
        // Set m_pLocSelected to the current location.  It will be selected later.
        lvi.mask |= LVIF_STATE;
        lvi.state = lvi.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
        lvi.iImage = 1;
        SetCheck(hwndList, m_pLocSelected, FALSE);
        m_pLocSelected = pLoc;
    }

    int iItem = ListView_InsertItem( hwndList, &lvi );

    SHUnicodeToTChar( pLoc->GetAreaCode(), szText, ARRAYSIZE(szText) );
    ListView_SetItemText( hwndList, iItem, 1, szText );
}

void CDialingRulesPropSheet::UpdateLocationInList(HWND hwndList, CLocation *pLocOld, CLocation *pLocNew)
{
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM)pLocOld;
    int iItem = ListView_FindItem(hwndList,-1,&lvfi);

    if (-1 != iItem && pLocNew)
    {
        TCHAR szText[MAX_INPUT];
        SHUnicodeToTChar( pLocNew->GetName(), szText, ARRAYSIZE(szText) );

        LVITEM lvi;
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iItem = iItem;
        lvi.iSubItem = 0;
        lvi.pszText = szText;
        lvi.lParam = (LONG_PTR)pLocNew;

        ListView_SetItem( hwndList, &lvi );

        SHUnicodeToTChar( pLocNew->GetAreaCode(), szText, ARRAYSIZE(szText) );
        ListView_SetItemText( hwndList, iItem, 1, szText );
    }
    else
    {
        ListView_DeleteItem(hwndList, iItem);
    }
}

BOOL CDialingRulesPropSheet::Dailing_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl)
{
    switch ( wID )
    {
    case IDC_NEW:
    case IDC_EDIT:
        LaunchLocationPropSheet(IDC_NEW == wID, hwndParent);
        break;

    case IDC_DELETE:
        DeleteSelectedLocation(GetDlgItem(hwndParent,IDC_LIST));
        break;

    default:
        return 0;
    }
    return 1;
}

void CDialingRulesPropSheet::LaunchLocationPropSheet( BOOL bNew, HWND hwndParent )
{
    CLocation * pLoc = new CLocation;

	if (NULL == pLoc)
	{
		return;
	}
 
    if ( bNew )
    {
        WCHAR wszNewLoc[MAX_INPUT];

        // We offer the default name "My Location" only if there are no locations alread defined.
        if ( m_locs.GetNumLocations() > 0 )
        {
            wszNewLoc[0] = TEXT('\0');
        }
        else
        {
            TCHAR szNewLoc[MAX_INPUT];

            LoadString(GetUIInstance(), IDS_MYLOCATION, szNewLoc, ARRAYSIZE(szNewLoc));
            SHTCharToUnicode(szNewLoc, wszNewLoc, ARRAYSIZE(wszNewLoc));
        }
        pLoc->Initialize(wszNewLoc,L"",L"",L"",L"",L"",L"",0,m_dwDefaultCountryID,0,LOCATION_USETONEDIALING);
    }
    else if (m_pLocSelected)
    {
        CAreaCodeRule * pRule;

        pLoc->Initialize(
                m_pLocSelected->GetName(),
                m_pLocSelected->GetAreaCode(),
                m_pLocSelected->GetLongDistanceCarrierCode(),
                m_pLocSelected->GetInternationalCarrierCode(),
                m_pLocSelected->GetLongDistanceAccessCode(),
                m_pLocSelected->GetLocalAccessCode(),
                m_pLocSelected->GetDisableCallWaitingCode(),
                m_pLocSelected->GetLocationID(),
                m_pLocSelected->GetCountryID(),
                m_pLocSelected->GetPreferredCardID(),
                0,
                m_pLocSelected->FromRegistry() );
        pLoc->UseCallingCard(m_pLocSelected->HasCallingCard());
        pLoc->UseCallWaiting(m_pLocSelected->HasCallWaiting());
        pLoc->UseToneDialing(m_pLocSelected->HasToneDialing());

        m_pLocSelected->ResetRules();
        while ( S_OK == m_pLocSelected->NextRule(1,&pRule,NULL) )
        {
            CAreaCodeRule * pNewRule = new CAreaCodeRule;

			if (NULL == pNewRule)
			{
				// No more memory, so get out of the loop.
				break;
			}
            pNewRule->Initialize(
                    pRule->GetAreaCode(),
                    pRule->GetNumberToDial(),
                    0,
                    pRule->GetPrefixList(),
                    pRule->GetPrefixListSize() );
            pNewRule->SetAppliesToAllPrefixes(pRule->HasAppliesToAllPrefixes());
            pNewRule->SetDialAreaCode(pRule->HasDialAreaCode());
            pNewRule->SetDialNumber(pRule->HasDialNumber());

            pLoc->AddRule(pNewRule);
            pLoc->Changed();
        }
    }
    else
    {
        // Out of memory, failed to create pLoc
        delete pLoc;
        return;
    }

    CLocationPropSheet nlps( bNew, pLoc, &m_locs, m_pwszAddress );
    int iRes = nlps.DoPropSheet(hwndParent);

    if ( PSN_APPLY == iRes )
    {
        HWND hwndList = GetDlgItem(hwndParent,IDC_LIST);
        if (bNew)
        {
            // we don't ask for an ID until we really need it to avoid hitting tapisrv
            // any more than we have to.
            pLoc->NewID();
            m_locs.Add(pLoc);
            AddLocationToList(hwndList, pLoc, TRUE);
            UpdateControlStates(hwndParent);
        }
        else
        {
            m_locs.Replace(m_pLocSelected, pLoc);
            UpdateLocationInList(hwndList, m_pLocSelected, pLoc);
            m_pLocSelected = pLoc;
        }
        ListView_SortItems( hwndList, Dialing_ListSort, m_iSortCol);

        if ( m_pwszAddress )
        {
            UpdateSampleString(GetDlgItem(hwndParent, IDC_PHONENUMBERSAMPLE), m_pLocSelected, m_pwszAddress, NULL);
        }
        SendMessage(GetParent(hwndParent),PSM_CHANGED,(WPARAM)hwndParent,0);
    }
    else
    {
        delete pLoc;
    }
}

void CDialingRulesPropSheet::DeleteSelectedLocation(HWND hwndList)
{
    // First we confirm the delete with the user
    TCHAR szText[1024];
    TCHAR szTitle[128];
    int result;
    HWND hwndParent = GetParent(hwndList);
    
    LoadString(GetUIInstance(), IDS_DELETELOCTEXT, szText, ARRAYSIZE(szText));
    LoadString(GetUIInstance(), IDS_CONFIRMDELETE, szTitle, ARRAYSIZE(szTitle));

    result = SHMessageBoxCheck( hwndParent, szText, szTitle, MB_YESNO, IDYES, TEXT("TAPIDeleteLocation") );
    if ( IDYES == result )
    {
        LVFINDINFO lvfi;
        lvfi.flags = LVFI_PARAM;
        lvfi.lParam = (LPARAM)m_pLocSelected;
        int iItem = ListView_FindItem(hwndList,-1,&lvfi);
        if ( -1 != iItem )
        {
            m_locs.Remove(m_pLocSelected);
            iItem = DeleteItemAndSelectPrevious( hwndParent, IDC_LIST, iItem, IDC_DELETE, IDC_ADD );

            if ( -1 != iItem )
            {
                LVITEM lvi;
                lvi.iItem = iItem;
                lvi.iSubItem = 0;
                lvi.mask = LVIF_PARAM;
                ListView_GetItem( hwndList, &lvi );

                // Store the currently selected item
                m_pLocSelected = (CLocation *)lvi.lParam;
            }
            else
            {
                m_pLocSelected = NULL;
            }

            UpdateControlStates(hwndParent);
            SendMessage(GetParent(hwndParent),PSM_CHANGED,(WPARAM)hwndParent,0);
        }
        else
        {
            // It's really bad if this ever happens (which it shouldn't).  This means our
            // data is in an unknown state and we might do anything (even destroy data).
            LOG((TL_ERROR, "DeleteSelectedLocation: Location Not Found!"));
        }
    }
}

void CDialingRulesPropSheet::SetCheck(HWND hwndList, CLocation * pLoc, int iImage)
{
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM)pLoc;
    int iItem = ListView_FindItem(hwndList,-1,&lvfi);

    if (-1 != iItem)
    {
        LVITEM lvi;
        lvi.mask = LVIF_IMAGE;
        lvi.iItem = iItem;
        lvi.iSubItem = 0;
        lvi.iImage = iImage;

        ListView_SetItem( hwndList, &lvi );
        ListView_EnsureVisible (hwndList, iItem, TRUE);
        ListView_Update( hwndList, iItem ); // need the font to be drawn non-bold
    }
}


BOOL CDialingRulesPropSheet::Dailing_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr)
{
    switch (pnmhdr->idFrom)
    {
    case IDC_LIST:
        #define pnmlv ((LPNMLISTVIEW)pnmhdr)

        switch (pnmhdr->code)
        {
        case LVN_ITEMCHANGED:
            if ( (pnmlv->uChanged & LVIF_STATE) && (pnmlv->uNewState & LVIS_SELECTED) )
            {
                LVITEM lvi;
                lvi.iItem = pnmlv->iItem;
                lvi.iSubItem = pnmlv->iSubItem;
                lvi.mask = LVIF_PARAM;
                ListView_GetItem( pnmhdr->hwndFrom, &lvi );
                CLocation * pLoc = (CLocation *)lvi.lParam;

                // pLoc can be NULL if this is our special "empty list item"
                if ( pLoc )
                {
                    m_dwDefaultCountryID = pLoc->GetCountryID();
                    m_locs.SetCurrentLocationID(pLoc->GetLocationID());

                    // clear the previous check
                    SetCheck( pnmhdr->hwndFrom, m_pLocSelected, FALSE );

                    // Store the currently selected item
                    m_pLocSelected = pLoc;

                    // Set the new check
                    SetCheck( pnmhdr->hwndFrom, m_pLocSelected, TRUE );

                    if (m_pwszAddress)
                    {
                        UpdateSampleString(GetDlgItem(hwndDlg, IDC_PHONENUMBERSAMPLE), m_pLocSelected, m_pwszAddress, NULL);
                    }
                }

                UpdateControlStates(hwndDlg);
                SendMessage(GetParent(hwndDlg),PSM_CHANGED,(WPARAM)hwndDlg,0);
            }
            break;

        case NM_DBLCLK:
            if ( !m_pLocSelected )
            {
                // Do new case
                LaunchLocationPropSheet(TRUE,hwndDlg);
            }
            else
            {
                // Do edit case
                LaunchLocationPropSheet(FALSE,hwndDlg);
            }
            break;

        case NM_CUSTOMDRAW:
            #define lplvcd ((LPNMLVCUSTOMDRAW)pnmhdr)

            if(lplvcd->nmcd.dwDrawStage == CDDS_PREPAINT)
            {
                // Request prepaint notifications for each item.
                SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,CDRF_NOTIFYITEMDRAW);
                return CDRF_NOTIFYITEMDRAW;
            }

            if(lplvcd->nmcd.dwDrawStage == CDDS_ITEMPREPAINT)
            {
                LVITEM lvi;
                lvi.iItem = (int)lplvcd->nmcd.dwItemSpec;
                lvi.iSubItem = 0;
                lvi.mask = LVIF_PARAM;
                ListView_GetItem( pnmhdr->hwndFrom, &lvi );
                CLocation * pLoc = (CLocation *)lvi.lParam;

                // pLoc can be NULL if this is our special item
                if(pLoc && pLoc->GetLocationID() == m_locs.GetCurrentLocationID())
                {
                    if (!g_hfontBold)
                    {
                        // we do lazy creation of the font because we need to match whatever
                        // font the listview control is using and we can't tell which font
                        // that is until we actually have the HDC for the listbox.
                        LOGFONT lf;
                        HFONT hfont = (HFONT)GetCurrentObject(lplvcd->nmcd.hdc, OBJ_FONT);
                        GetObject(hfont, sizeof(LOGFONT), &lf);
                        lf.lfWeight += FW_BOLD-FW_NORMAL;
                        g_hfontBold = CreateFontIndirect(&lf);
                    }
                    if (g_hfontBold)
                    {
                        SelectObject(lplvcd->nmcd.hdc, g_hfontBold);
                        SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,CDRF_NEWFONT);
                        return CDRF_NEWFONT;
                    }
                }

                SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,CDRF_DODEFAULT);
                return CDRF_DODEFAULT;
            }
            return 0;
            #undef lplvcd

        case LVN_COLUMNCLICK:
            m_iSortCol = pnmlv->iSubItem;
            ListView_SortItems( pnmhdr->hwndFrom, Dialing_ListSort, m_iSortCol);
            break;

        case LVN_GETEMPTYTEXT:
            #define pnmlvi (((NMLVDISPINFO *)pnmhdr)->item)
            LoadString(GetUIInstance(), IDS_CLICKNEW, pnmlvi.pszText, pnmlvi.cchTextMax);
            SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,TRUE);
            #undef pnmlvi
            break;

        default:
            break;
        }
        #undef pnmlv
        break;

    default:
        switch (pnmhdr->code)
        {
        case PSN_APPLY:
            // TODO: Ensure that a location is selected in the list
            m_locs.SaveToRegistry();
            break;
        }
        return 0;
    }
    return 1;
}


// ********************************************************************
//
// Advanced Property Page functions (formerly Telephony Drivers page)
//
// ********************************************************************



#include "drv.h"


INT_PTR CALLBACK CDialingRulesPropSheet::Advanced_DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CDialingRulesPropSheet* pthis = (CDialingRulesPropSheet*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        pthis = (CDialingRulesPropSheet*)(((PROPSHEETPAGE*)lParam)->lParam);
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis);
        return pthis->Advanced_OnInitDialog(hwndDlg);

    case WM_COMMAND:
        return pthis->Advanced_OnCommand(hwndDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam );
   
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        WinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a113HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        WinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a113HelpIDs);
        break;
    }

    return 0;
}

BOOL CDialingRulesPropSheet::Advanced_OnInitDialog(HWND hDlg)
{
    UINT  uUpdated;

    if ( !FillDriverList(GetDlgItem(hDlg, IDC_LIST)) )
    {
        EndDialog(hDlg, IDCANCEL);
        return FALSE;
    }

    // DWLP_USER is used to store state information about wheter we have disabled
    // the property sheet's cancel button.  For starters we have not done this.
    SetWindowLong( hDlg, DWLP_USER, FALSE );

    UpdateDriverDlgButtons (hDlg);

    return TRUE;
}

BOOL CDialingRulesPropSheet::Advanced_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl)
{
    switch (wID)
    {
    case IDC_ADD:
        // add a new driver
        if ( IDOK == DialogBoxParam(
                GetUIInstance(),
                MAKEINTRESOURCE( IDD_ADD_DRIVER ),
                hwndParent,
                AddDriver_DialogProc,
                0 ) )
        {
            FillDriverList(GetDlgItem(hwndParent, IDC_LIST));

            if (SetWindowLong(hwndParent, DWLP_USER, TRUE) == FALSE)
            {
                // We have performed a non-cancelable action, update the property sheet to reflect this
                PropSheet_CancelToClose( GetParent( hwndParent ) );
            }

            UpdateDriverDlgButtons(hwndParent);

        }  // end if

        break;

    case IDC_LIST:
        if ( LBN_SELCHANGE == wNotifyCode )
        {
            UpdateDriverDlgButtons(hwndParent);
            break;
        }
        else if ( LBN_DBLCLK != wNotifyCode || !IsWindowEnabled( GetDlgItem( hwndParent, IDC_EDIT ) ))
        {
            // we only fall through if the user double clicked on an editable item
            break;
        }

        // fall through

    case IDC_EDIT:
        if ( SetupDriver(hwndParent, GetDlgItem(hwndParent, IDC_LIST)) )
        {
            if ( SetWindowLong( hwndParent, DWLP_USER, TRUE ) == FALSE ) // modified
            {
                PropSheet_CancelToClose( GetParent(hwndParent) );
            }
        }

        break;

    case IDC_REMOVE:
        {
            TCHAR szCaption[MAX_INPUT];
            TCHAR szMessage[512];

            LoadString(GetUIInstance(), IDS_REMOVEPROVIDER, szCaption, ARRAYSIZE(szCaption));
            LoadString(GetUIInstance(), IDS_CONFIRM_DRIVER_REMOVE, szMessage, ARRAYSIZE(szMessage));
            MessageBeep( MB_ICONASTERISK );
            if ( IDYES == MessageBox(hwndParent, szMessage, szCaption, MB_YESNO | MB_DEFBUTTON2) )
            {
                if (SetWindowLong (hwndParent, DWLP_USER, TRUE) == FALSE) // modified
                {
                    PropSheet_CancelToClose( GetParent( hwndParent ) );
                }

                RemoveSelectedDriver( hwndParent, GetDlgItem(hwndParent, IDC_LIST) );

                UpdateDriverDlgButtons (hwndParent);
            }
        }
        break;
    }

    return 1;
}

HINSTANCE GetUIInstance()
{
    if ( NULL == g_hInstUI )
    {
        g_hInstUI = LoadLibrary(TEXT("tapiui.dll"));
        // g_hInstUI = GetModuleHandle(TEXT("tapi32.dll"));
    }

    return g_hInstUI;
}

LONG EnsureOneLocation (HWND hwnd)
{
    CLocations          locs;

    locs.Initialize();

    // If there are no locations, launch the simple location dialog
    if ( 0 == locs.GetNumLocations() )
    {
        // if we are in lineTranslateDialog mode, then we display the simple
        int iRes;
        iRes = (int)DialogBoxParam(GetUIInstance(), MAKEINTRESOURCE(IDD_SIMPLELOCATION),hwnd,
            LocWizardDlgProc, (LPARAM)TAPI_VERSION2_2);

        if ( IDOK == iRes )
        {
            // now we need to re-initalize to pick up the new location
            locs.Initialize();

            // Now we need to figure out the ID of the location we just created
            CLocation * pLoc;
            locs.Reset();
            if ( S_OK == locs.Next( 1, &pLoc, NULL ) )
            {
                // Set this ID as the default location
                locs.SetCurrentLocationID(pLoc->GetLocationID());
                CountryRunOnce();
            }

            // we've already made a commited change, so save the result
            locs.SaveToRegistry();
        }
        else
        {
            return LINEERR_USERCANCELLED;
        }
    }

    return S_OK;
}

void CountryRunOnce()
{
    //
    // This is soft modem workaround provided by unimodem team. 
    //
    //   1. Some vendors set the GCI code incorrectly based on the TAPI location
    //     key (which is a bad thing L)
    //   2. Some modems do not conform to GCI
    //   3. Some modems do not correctly accept AT+GCI commands.
    // (+GCI is Modems AT commands for setting country)
    //
    // The conformance check ensures the GCI value is properly sync
    // with the TAPI location. It disables GCI if the modem does not conform
    // to the GCI spec.
    //
    // This function can take as long as 15 seconds. We should make sure the UI
    // doesn't appear to hang during the call.
    //

typedef void (*COUNTRYRUNONCE)();
    
    HMODULE   hLib;

    hLib=LoadLibrary(TEXT("modemui.dll"));

    if (hLib != NULL)
    {

        COUNTRYRUNONCE  Proc;

        Proc=(COUNTRYRUNONCE)GetProcAddress(hLib,"CountryRunOnce");

        if (Proc != NULL)
        {
            Proc();
        }

        FreeLibrary(hLib);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\cpllocationps.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cpllocationps.cpp
                                                              
       Author:  toddb - 10/06/98

****************************************************************************/

// Property Sheet stuff for the main page
#include "cplPreComp.h"
#include "cplLocationPS.h"


CLocationPropSheet::CLocationPropSheet(BOOL bNew, CLocation * pLoc, CLocations * pLocList, LPCWSTR pwszAdd)
{
    m_bNew = bNew;
    m_pLoc = pLoc;
    m_pLocList = pLocList;
    m_dwCountryID = 0;
    m_pRule = NULL;
    m_pCard = NULL;
    m_bWasApplied = FALSE;
    m_bShowPIN = FALSE;
    m_pwszAddress = pwszAdd;
}


CLocationPropSheet::~CLocationPropSheet()
{
}


LONG CLocationPropSheet::DoPropSheet(HWND hwndParent)
{
    PROPSHEETHEADER psh;
    PROPSHEETPAGE   psp;
    HPROPSHEETPAGE  hpsp[3];

    // Initialize the header:
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_DEFAULT;
    psh.hwndParent = hwndParent;
    psh.hInstance = GetUIInstance();
    psh.hIcon = NULL;
    psh.pszCaption = MAKEINTRESOURCE(m_bNew?IDS_NEWLOCATION:IDS_EDITLOCATION);
    psh.nPages = 3;
    psh.nStartPage = 0;
    psh.pfnCallback = NULL;
    psh.phpage = hpsp;

    // Now setup the Property Sheet Page
    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = GetUIInstance();
    psp.lParam = (LPARAM)this;

    PSPINFO aData[3] =
    {
        { IDD_LOC_GENERAL,       CLocationPropSheet::General_DialogProc },
        { IDD_LOC_AREACODERULES, CLocationPropSheet::AreaCode_DialogProc },
        { IDD_LOC_CALLINGCARD,   CLocationPropSheet::CallingCard_DialogProc },
    };

    for (int i=0; i<3; i++)
    {
        psp.pszTemplate = MAKEINTRESOURCE(aData[i].iDlgID);
        psp.pfnDlgProc = aData[i].pfnDlgProc;
        hpsp[i] = CreatePropertySheetPage( &psp );
    }

    PropertySheet( &psh );

    return m_bWasApplied?PSN_APPLY:PSN_RESET;
}

BOOL CLocationPropSheet::OnNotify(HWND hwndDlg, LPNMHDR pnmhdr)
{
    switch (pnmhdr->code)
    {
    case PSN_APPLY:         // user pressed OK or Apply
    case PSN_RESET:         // user pressed Cancel
    case PSN_KILLACTIVE:    // user is switching pages
        HideToolTip();
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\cpllocationps.h ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cpllocationps.h
                                                              
       Author:  toddb - 10/06/98
              
****************************************************************************/

#pragma once

#include "cplAreaCodeDlg.h"
#include "cplCallingCardPS.h"

void UpdateSampleString(HWND hwnd, CLocation * pLoc, PCWSTR pwszAddress, CCallingCard * pCard);
class CLocationPropSheet
{
public:
    CLocationPropSheet(BOOL bNew, CLocation * pLoc, CLocations * pLocList, LPCWSTR pwszAdd);
    ~CLocationPropSheet();

#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CLocationPropSheet)
#endif

    
	LONG DoPropSheet(HWND hwndParent);

protected:
    BOOL OnNotify(HWND hwndDlg, LPNMHDR pnmhdr);

    static INT_PTR CALLBACK General_DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL General_OnInitDialog(HWND hwndDlg);
    BOOL General_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCtl);
    BOOL General_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr);
    BOOL General_OnApply(HWND hwndDlg);
    BOOL PopulateDisableCallWaitingCodes(HWND hwndCombo, LPTSTR szSelected);

    static INT_PTR CALLBACK AreaCode_DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL AreaCode_OnInitDialog(HWND hwndDlg);
    BOOL AreaCode_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl);
    BOOL AreaCode_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr);
    void PopulateAreaCodeRuleList(HWND hwndList);
    void LaunchNewRuleDialog(BOOL bNew, HWND hwndParent);
    void DeleteSelectedRule(HWND hwndList);
    void AddRuleToList(HWND hwndList, CAreaCodeRule * pRule, BOOL bSelect);
    void RemoveRuleFromList(HWND hwndList, BOOL bSelect);
    void SetDataForSelectedRule(HWND hDlg);

    static INT_PTR CALLBACK CallingCard_DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL CallingCard_OnInitDialog(HWND hwndDlg);
    BOOL CallingCard_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCrl);
    BOOL CallingCard_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr);
    BOOL CallingCard_OnApply(HWND hwndDlg);
    void PopulateCardList(HWND hwndList);
    void LaunchCallingCardPropSheet(BOOL bNew, HWND hwndParent);
    void DeleteSelectedCard(HWND hwndList);
    void AddCardToList(HWND hwndList, CCallingCard * pCard, BOOL bSelect);
    void UpdateCardInList(HWND hwndList, CCallingCard * pCard);
    void SetDataForSelectedCard(HWND hDlg);
    void SetCheck(HWND hwndList, CCallingCard * pCard, int iImage);
    void EnsureVisible(HWND hwndList, CCallingCard * pCard);

    BOOL        m_bWasApplied;      // Set to true if we are applied, false if we are canceled
    BOOL        m_bNew;             // True if this is a new location, false if we're editing an existing one
    BOOL		m_bShowPIN;			// True if it's safe to show the PIN
    CLocation * m_pLoc;             // pointer to the location object to use.
    CLocations* m_pLocList;         // pointer to the list of all locations, need to ensure a unique name
    PCWSTR      m_pwszAddress;
    
    // These tapi objects need to live for the life of the property sheet or we will AV.
    CCallingCards   m_Cards;        // Needed for the "Calling Card" page.

    // These pointers point into the above TAPI objects
    CAreaCodeRule * m_pRule;
    CCallingCard *  m_pCard;
    DWORD           m_dwDefaultCard;
    DWORD           m_dwCountryID;  // the selected countries ID
    int             m_iCityRule;    // We cache the result of calling IsCityRule on the currently selected country
    int             m_iLongDistanceCarrierCodeRule;     //We cache the result of calling isLongDistanceCarrierCodeRule
    int             m_iInternationalCarrierCodeRule;    //We cache the result of calling isInternationalCarrierCodeRule
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\cplinputlimiter.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplinputlimiter.cpp
                                                              
       Author:  toddb - 10/06/98

****************************************************************************/

#include "cplPreComp.h"

class CInputLimiter
{
public:
    BOOL SubclassWindow(HWND hwnd, DWORD dwFlags);
    static VOID HideToolTip();

protected:
    BOOL OnChar( HWND hwnd, TCHAR wParam );
    LRESULT OnPaste(HWND hwnd, WPARAM wParam, LPARAM lParam);
    BOOL IsValidChar(TCHAR ch, BOOL bPaste);
    BOOL UnsubclassWindow(HWND hwnd);
    void ShowToolTip(HWND hwnd);
    void CreateToolTipWindow(HWND hwnd);
    static LRESULT CALLBACK SubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK ListenerProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static VOID CALLBACK TimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime);

    DWORD           m_dwFlags;          // determines which characters are allowed
    WNDPROC         m_pfnSuperProc;     // the super class proc
    static HWND     s_hwndToolTip;      // shared by all instances
    static UINT_PTR s_uTimerID;         // shared timer
    static TCHAR    s_szTipText[512];   // the text to be shown in the tooltip
};

HWND     CInputLimiter::s_hwndToolTip = NULL;
UINT_PTR CInputLimiter::s_uTimerID = 0;
TCHAR    CInputLimiter::s_szTipText[512] = {0};

// Limiting the input on a combo box is a special case because you first
// have to find the edit box and then LimitInput on that.
BOOL CALLBACK FindTheEditBox( HWND hwnd, LPARAM lParam )
{
    // The combo box only has one child, subclass it
    LimitInput(hwnd,(DWORD)lParam);
    return FALSE;
}

BOOL LimitCBInput(HWND hwnd, DWORD dwFlags)
{
    return EnumChildWindows(hwnd, FindTheEditBox, dwFlags);
}

BOOL LimitInput(HWND hwnd, DWORD dwFlags)
{
    CInputLimiter * pil = new CInputLimiter;

    if (!pil)
    {
        return FALSE;
    }

    BOOL bResult = pil->SubclassWindow(hwnd, dwFlags);

    if (!bResult)
    {
        delete pil;
    }

    return bResult;
}

void HideToolTip()
{
    CInputLimiter::HideToolTip();
}

BOOL CInputLimiter::SubclassWindow(HWND hwnd, DWORD dwFlags)
{
    if ( !IsWindow(hwnd) )
        return FALSE;

    m_dwFlags = dwFlags;

    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)this);

    m_pfnSuperProc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
    SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)CInputLimiter::SubclassProc);

    return TRUE;
}

BOOL CInputLimiter::UnsubclassWindow(HWND hwnd)
{
    SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)m_pfnSuperProc);

    m_dwFlags = 0;

    delete this;

    return TRUE;
}

LRESULT CALLBACK CInputLimiter::SubclassProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CInputLimiter * pthis = (CInputLimiter*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    // cache pthis->m_pfnSuperProc because we always need in and
    // pthis might be deleted before we get around to using it
    WNDPROC pfn = pthis->m_pfnSuperProc;

    switch (uMsg)
    {
    case WM_CHAR:
        if (!pthis->OnChar(hwnd, (TCHAR)wParam))
        {
            return 0;
        }
        break;

    case WM_PASTE:
        return pthis->OnPaste(hwnd, wParam, lParam);

    case WM_KILLFOCUS:
        HideToolTip();
        break;

    case WM_DESTROY:
        pthis->UnsubclassWindow(hwnd);
        break;

    default:
        break;
    }

    return CallWindowProc(pfn, hwnd, uMsg, wParam, lParam);
}

BOOL CInputLimiter::OnChar( HWND hwnd, TCHAR ch )
{
    // if the char is a good one return TRUE, this will pass the char on to the
    // default window proc.  For a bad character do a beep and then display the
    // ballon tooltip pointing at the control.

    if ( IsValidChar(ch, FALSE) )
        return TRUE;

    // if we get here then an invalid character was entered
    MessageBeep(MB_OK);

    ShowToolTip(hwnd);

    return FALSE;
}

BOOL CInputLimiter::IsValidChar(TCHAR ch, BOOL bPaste)
{
    // certain characters get converted into WM_CHAR messages even though we don't want
    // to consider them.  We check for these characters first.  Currently, this list includes:
    //  backspace
    //  control characters, such as ctrl-x and ctrl-v
    if ( ch == TEXT('\b') )
        return TRUE;

    if ( !bPaste && (0x8000 & GetKeyState(VK_CONTROL)) )
        return TRUE;

    if ( m_dwFlags & LIF_ALLOWALPHA )
    {
        if ( (ch >= TEXT('a') && ch <= TEXT('z')) || (ch >= TEXT('A') && ch <= TEXT('Z')) )
        {
            return TRUE;
        }
    }
    if ( m_dwFlags & LIF_ALLOWNUMBER )
    {
        if ( ch >= TEXT('0') && ch <= TEXT('9') )
        {
            return TRUE;
        }
    }
    if ( m_dwFlags & LIF_ALLOWDASH )
    {
        if ( ch == TEXT('-') || ch == TEXT('(') || ch == TEXT(')'))
        {
            return TRUE;
        }
    }
    if ( m_dwFlags & LIF_ALLOWPOUND )
    {
        if ( ch == TEXT('#') )
        {
            return TRUE;
        }
    }
    if ( m_dwFlags & LIF_ALLOWSTAR )
    {
        if ( ch == TEXT('*') )
        {
            return TRUE;
        }
    }
    if ( m_dwFlags & LIF_ALLOWSPACE )
    {
        if ( ch == TEXT(' ') )
        {
            return TRUE;
        }
    }
    if ( m_dwFlags & LIF_ALLOWCOMMA )
    {
        if ( ch == TEXT(',') )
        {
            return TRUE;
        }
    }
    if ( m_dwFlags & LIF_ALLOWPLUS )
    {
        if ( ch == TEXT('+') )
        {
            return TRUE;
        }
    }
    if ( m_dwFlags & LIF_ALLOWBANG )
    {
        if ( ch == TEXT('!') )
        {
            return TRUE;
        }
    }
    if ( m_dwFlags & LIF_ALLOWATOD )
    {
        if ( (ch >= TEXT('a') && ch <= TEXT('d')) || (ch >= TEXT('A') && ch <= TEXT('D')) )
        {
            return TRUE;
        }
    }

    return FALSE;
}

void CInputLimiter::ShowToolTip(HWND hwnd)
{
    if ( !s_hwndToolTip )
    {
        CreateToolTipWindow(hwnd);
    }

    // Set the tooltip display point
    RECT rc;
    GetWindowRect(hwnd, &rc);
    SendMessage(s_hwndToolTip, TTM_TRACKPOSITION, 0, MAKELONG((rc.left+rc.right)/2,rc.bottom));

    TOOLINFO ti = {0};
    ti.cbSize = sizeof(ti);
    ti.hwnd = NULL;
    ti.uId = 1;

    // Set the tooltip text
    UINT iStrID;
    if ( m_dwFlags == LIF_ALLOWNUMBER )
    {
        // use the "0-9" text
        iStrID = IDS_DIGITSONLY;
    }
    else if ( m_dwFlags == (LIF_ALLOWNUMBER|LIF_ALLOWSPACE) )
    {
        // use the "0-9, ' '" text
        iStrID = IDS_DIGITLIST;
    }
    else if ( m_dwFlags == (LIF_ALLOWNUMBER|LIF_ALLOWSPACE|LIF_ALLOWCOMMA) )
    {
        // use the "0-9, ' ', ','" text
        iStrID = IDS_MULTIDIGITLIST;
    }
    else if ( m_dwFlags == (LIF_ALLOWNUMBER|LIF_ALLOWSTAR|LIF_ALLOWPOUND|LIF_ALLOWCOMMA) )
    {
        // use the "0-9, #, *, ','" text
        iStrID = IDS_PHONEPADCHAR;
    }
    else if ( m_dwFlags == (LIF_ALLOWNUMBER|LIF_ALLOWPOUND|LIF_ALLOWSTAR|LIF_ALLOWSPACE|LIF_ALLOWCOMMA) )
    {
        // use the "0-9, #, *, ' ', ','" text
        iStrID = IDS_PHONENUMBERCHAR;
    }
    else if ( m_dwFlags == (LIF_ALLOWNUMBER|LIF_ALLOWPOUND|LIF_ALLOWSTAR|LIF_ALLOWSPACE|LIF_ALLOWCOMMA|LIF_ALLOWPLUS|LIF_ALLOWBANG|LIF_ALLOWATOD) )
    {
        // use the "0-9, A-D, a-d, #, *, +, !, ' ', ',' " text
        iStrID = IDS_PHONENUMBERCHAREXT;
    }
    else
    {
        // We should never reach this point, but if we do then we display a generic invalid character dialog
        iStrID = IDS_ALLPHONECHARS;
    }
    LoadString(GetUIInstance(),iStrID,s_szTipText,ARRAYSIZE(s_szTipText));
    ti.lpszText = s_szTipText;
    SendMessage(s_hwndToolTip, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);

    // Show the tooltip
    SendMessage(s_hwndToolTip, TTM_TRACKACTIVATE, TRUE, (LPARAM)&ti);

    // Set a timer to hide the tooltip
    if ( s_uTimerID )
    {
        KillTimer(NULL,s_uTimerID);
    }
    s_uTimerID = SetTimer(NULL, 0, 10000, (TIMERPROC)CInputLimiter::TimerProc);
}

// CreateToolTipWindow
//
// Creates our tooltip control.  We share this one tooltip control and use it for all invalid
// input messages.  The control is hiden when not in use and then shown when needed.
//
void CInputLimiter::CreateToolTipWindow(HWND hwnd)
{
    HWND hwndParent;

    do
    {
        hwndParent = hwnd;
        hwnd = GetParent(hwnd);
    } while (hwnd);

    s_hwndToolTip = CreateWindow(TOOLTIPS_CLASS, NULL,
                                 WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP | TTS_BALLOON,
                                 CW_USEDEFAULT, CW_USEDEFAULT,
                                 CW_USEDEFAULT, CW_USEDEFAULT,
                                 hwndParent, NULL, GetUIInstance(),
                                 NULL);

    if (s_hwndToolTip)
    {
        SetWindowPos(s_hwndToolTip, HWND_TOPMOST,
                     0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

        TOOLINFO ti = {0};
        RECT     rc = {2,2,2,2};

        ti.cbSize = sizeof(ti);
        ti.uFlags = TTF_TRACK | TTF_TRANSPARENT;
        ti.hwnd = NULL;
        ti.uId = 1;
        ti.lpszText = s_szTipText;

        // set the version so we can have non buggy mouse event forwarding
        SendMessage(s_hwndToolTip, CCM_SETVERSION, COMCTL32_VERSION, 0);
        SendMessage(s_hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&ti);
        SendMessage(s_hwndToolTip, TTM_SETMAXTIPWIDTH, 0, 500);
        SendMessage(s_hwndToolTip, TTM_SETMARGIN, 0, (LPARAM)&rc);
    }
}

VOID CALLBACK CInputLimiter::TimerProc(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    // When the timer fires we hide the tooltip window
    HideToolTip();
}

void CInputLimiter::HideToolTip()
{
    if ( s_uTimerID )
    {
        KillTimer(NULL,s_uTimerID);
        s_uTimerID = 0;
    }
    if ( s_hwndToolTip )
    {
        PostMessage(s_hwndToolTip, TTM_TRACKACTIVATE, FALSE, 0);
    }
}

LRESULT CInputLimiter::OnPaste(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    // There are hundred of lines of code in user to successfully handle a paste into an edit control.
    // We need to leverage all that code while still disallowing invalid input to result from the paste.
    // As a result, what we need to do is to get the clip board data, validate that data, place the
    // valid data back onto the clipboard, call the default window proc to let user do it's thing, and
    // then restore the clipboard to it's original format.
    if ( OpenClipboard(hwnd) )
    {
        HANDLE hdata;
        UINT iFormat;
        DWORD cchBad = 0;           // count of the number of bad characters

        // REVIEW: Should this be based on the compile type or the window type?
        // Compile time check for the correct clipboard format to use:
        if ( sizeof(WCHAR) == sizeof(TCHAR) )
        {
            iFormat = CF_UNICODETEXT;
        }
        else
        {
            iFormat = CF_TEXT;
        }

        hdata = GetClipboardData(iFormat);

        if ( hdata )
        {
            LPTSTR pszData;
            pszData = (LPTSTR)GlobalLock(hdata);
            if ( pszData )
            {
                DWORD dwSize;
                HANDLE hClone;
                HANDLE hNew;

                // we need to copy the original data because the clipboard owns the hdata
                // pointer.  That data will be invalid after we call SetClipboardData.
                // We start by calculating the size of the data:
                dwSize = (DWORD)GlobalSize(hdata)+sizeof(TCHAR);

                // Use the prefered GlobalAlloc for clipboard data
                hClone = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE, dwSize);
                hNew = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE, dwSize);
                if ( hClone && hNew )
                {
                    LPTSTR pszClone;
                    LPTSTR pszNew;

                    pszClone = (LPTSTR)GlobalLock(hClone);
                    pszNew = (LPTSTR)GlobalLock(hNew);
                    if ( pszClone && pszNew )
                    {
                        int iNew = 0;

                        // copy the original data as-is
                        memcpy((LPVOID)pszClone, (LPVOID)pszData, (size_t)dwSize);
                        // ensure that it's NULL terminated
                        pszClone[ (dwSize/sizeof(TCHAR))-1 ] = NULL;

                        for ( LPTSTR psz = pszClone; *psz; psz++ )
                        {
                            if ( IsValidChar(*psz, TRUE) )
                            {
                                pszNew[iNew++] = *psz;
                            }
                            else
                            {
                                cchBad++;
                            }
                        }
                        pszNew[iNew] = NULL;

                        // If there are any characters in the paste buffer then we paste the validated string
                        if ( *pszNew )
                        {
                            // we always set the new string.  Worst case it's identical to the old string
                            GlobalUnlock(hNew);
                            pszNew = NULL;
                            SetClipboardData(iFormat, hNew);
                            hNew = NULL;

                            // call the super proc to do the paste
                            CallWindowProc(m_pfnSuperProc, hwnd, WM_PASTE, wParam, lParam);

                            // The above call will have closed the clipboard on us.  We try to re-open it.
                            // If this fails it's no big deal, that simply means the SetClipboardData
                            // call below will fail which is good if somebody else managed to open the
                            // clipboard in the mean time.
                            OpenClipboard(hwnd);

                            // and then we always set it back to the original value.
                            GlobalUnlock(hClone);
                            pszClone = NULL;
                            SetClipboardData(iFormat, hClone);
                            hClone = NULL;
                        }
                    }

                    if ( pszClone )
                    {
                        GlobalUnlock(hClone);
                    }

                    if ( pszNew )
                    {
                        GlobalUnlock(hNew);
                    }
                }

                if ( hClone )
                {
                    GlobalFree( hClone );
                }

                if ( hNew )
                {
                    GlobalFree( hNew );
                }

                // at this point we are done with hdata so unlock it
                GlobalUnlock(hdata);
            }
        }
        CloseClipboard();

        if ( cchBad )
        {
            // Show the error balloon
            MessageBeep(MB_OK);

            ShowToolTip(hwnd);
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\cplgeneraltab.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplgeneraltab.cpp
                                                              
       Author:  toddb - 10/06/98

****************************************************************************/


//
// Functions used only by the General tab of the New Location Property Sheet.
// Shared functions are in the Location.cpp file.
//
#include "cplPreComp.h"
#include "cplLocationPS.h"


void UpdateSampleString(HWND hwnd, CLocation * pLoc, PCWSTR pwszAddress, CCallingCard * pCard)
{
    CCallingCard cc;
    LPWSTR pwszDialable;
    LPWSTR pwszDisplayable;
    TCHAR szBuf[512];
    DWORD dwOptions = pLoc->HasCallWaiting() ? LINETRANSLATEOPTION_CANCELCALLWAITING : 0;

    if ( (NULL == pCard) && pLoc->HasCallingCard() )
    {
        if ( SUCCEEDED(cc.Initialize(pLoc->GetPreferredCardID())) )
        {
            pCard = &cc;
        }
    }

    if ( 0 == pLoc->TranslateAddress(pwszAddress, pCard, dwOptions, &dwOptions, NULL, &pwszDialable, &pwszDisplayable) )
    {
        SHUnicodeToTChar(pwszDisplayable, szBuf, ARRAYSIZE(szBuf));
        ClientFree(pwszDialable);
        ClientFree(pwszDisplayable);
    }
    else
    {
        LOG((TL_ERROR, "UpdateSampleString failed to call pLoc->TranslateAddress\n"));
        // REVIEW: Should we load some sort of error string instead?  Perhaps we should featch the
        // error text for the given error code from the message resources in tapiui?
        szBuf[0] = TEXT('\0');
    }
    SetWindowText(hwnd, szBuf);
}

INT_PTR CALLBACK CLocationPropSheet::General_DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CLocationPropSheet* pthis = (CLocationPropSheet*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        pthis = (CLocationPropSheet*)(((PROPSHEETPAGE*)lParam)->lParam);
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis); 
        return pthis->General_OnInitDialog(hwndDlg);

    case WM_COMMAND:
        return pthis->General_OnCommand(hwndDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam );

    case WM_NOTIFY:
        return pthis->General_OnNotify(hwndDlg, (LPNMHDR)lParam);
   
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        WinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a102HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        WinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a102HelpIDs);
        break;
    }

    return 0;
}

BOOL CLocationPropSheet::General_OnInitDialog(HWND hwndDlg)
{
    TCHAR szBuf[1024];
    HWND hwnd;
    hwnd = GetDlgItem( hwndDlg, IDC_LOCATIONNAME );
    SHUnicodeToTChar(m_pLoc->GetName(), szBuf, ARRAYSIZE(szBuf));
    SetWindowText(hwnd, szBuf);
    SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);

    hwnd = GetDlgItem( hwndDlg, IDC_COUNTRY );
    m_dwCountryID = m_pLoc->GetCountryID();
    PopulateCountryList( hwnd, m_dwCountryID );

    CCountry * pCountry;
    HRESULT hr;

    hr = CreateCountryObject(m_dwCountryID, &pCountry);
    if ( SUCCEEDED(hr) )
    {
        m_iCityRule = IsCityRule(pCountry->GetLongDistanceRule());
        m_iLongDistanceCarrierCodeRule = IsLongDistanceCarrierCodeRule( pCountry->GetLongDistanceRule() );
        m_iInternationalCarrierCodeRule = IsInternationalCarrierCodeRule( pCountry->GetInternationalRule() );
        delete pCountry;
    } else {
        LOG((TL_ERROR, "General_OnInitDialog failed to create country %d", m_dwCountryID));
        m_iCityRule = CITY_OPTIONAL;
        m_iLongDistanceCarrierCodeRule = LONG_DISTANCE_CARRIER_OPTIONAL;
        m_iInternationalCarrierCodeRule = INTERNATIONAL_CARRIER_OPTIONAL;
    }



    hwnd = GetDlgItem(hwndDlg,IDC_AREACODE);
    SHUnicodeToTChar(m_pLoc->GetAreaCode(), szBuf, ARRAYSIZE(szBuf));
    SetWindowText(hwnd, szBuf);
    SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);
    LimitInput(hwnd, LIF_ALLOWNUMBER);
    if ( m_iCityRule == CITY_NONE )
    {
        // The selected country does not have area codes
        EnableWindow(hwnd, FALSE);
    }

    hwnd = GetDlgItem(hwndDlg,IDC_LOCALACCESSNUM);
    SHUnicodeToTChar(m_pLoc->GetLocalAccessCode(), szBuf, ARRAYSIZE(szBuf));
    SetWindowText(hwnd, szBuf);
    SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);
    LimitInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWPOUND|LIF_ALLOWSTAR|LIF_ALLOWCOMMA);

    hwnd = GetDlgItem(hwndDlg,IDC_LONGDISTANCEACCESSNUM);
    SHUnicodeToTChar(m_pLoc->GetLongDistanceAccessCode(), szBuf, ARRAYSIZE(szBuf));
    SetWindowText(hwnd, szBuf);
    SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);
    LimitInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWPOUND|LIF_ALLOWSTAR|LIF_ALLOWCOMMA);

    hwnd = GetDlgItem(hwndDlg,IDC_LONGDISTANCECARRIERCODE);
    SHUnicodeToTChar(m_pLoc->GetLongDistanceCarrierCode(), szBuf, ARRAYSIZE(szBuf));
    SetWindowText(hwnd, szBuf);
    SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);
    LimitInput(hwnd, LIF_ALLOWNUMBER);
    if ( LONG_DISTANCE_CARRIER_NONE == m_iLongDistanceCarrierCodeRule )
    {
        // The selected country does not have long distance carrier codes
        EnableWindow(hwnd, FALSE);
        EnableWindow(GetDlgItem(hwndDlg, IDC_STATICLDC), FALSE);
    }

    hwnd = GetDlgItem(hwndDlg,IDC_INTERNATIONALCARRIERCODE);
    SHUnicodeToTChar(m_pLoc->GetInternationalCarrierCode(), szBuf, ARRAYSIZE(szBuf));
    SetWindowText(hwnd, szBuf);
    SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);
    LimitInput(hwnd, LIF_ALLOWNUMBER);
    if ( INTERNATIONAL_CARRIER_NONE == m_iInternationalCarrierCodeRule )
    {
        // The selected country does not have international carrier codes
        EnableWindow(hwnd, FALSE);
        EnableWindow(GetDlgItem(hwndDlg, IDC_STATICIC), FALSE);
    }

    hwnd = GetDlgItem(hwndDlg,IDC_DISABLESTRING);
    LPWSTR lpwsz = m_pLoc->GetDisableCallWaitingCode();
    SHUnicodeToTChar(lpwsz, szBuf, ARRAYSIZE(szBuf));
    SendMessage(hwnd, CB_LIMITTEXT, CPL_SETTEXTLIMIT, 0);
    PopulateDisableCallWaitingCodes(hwnd, szBuf);
    LimitCBInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWPOUND|LIF_ALLOWSTAR|LIF_ALLOWCOMMA);
    if ( NULL == *lpwsz || !m_pLoc->HasCallWaiting() )
    {
        EnableWindow(hwnd, FALSE);
    }
    else
    {
        hwnd = GetDlgItem(hwndDlg,IDC_DISABLECALLWAITING);
        SendMessage(hwnd,BM_SETCHECK, BST_CHECKED, 0);
    }

    CheckRadioButton(hwndDlg,IDC_TONE,IDC_PULSE,m_pLoc->HasToneDialing()?IDC_TONE:IDC_PULSE);

    if (!m_pwszAddress)
    {
        ShowWindow(GetDlgItem(hwndDlg,IDC_PHONENUMBERTEXT), SW_HIDE);
    }

    return 0;
}

BOOL PopulateCountryList(HWND hwndCombo, DWORD dwSelectedCountry)
{
    BOOL bResult = FALSE;
    CCountries CountryList;

    SendMessage(hwndCombo,CB_RESETCONTENT,0,0);

    if ( SUCCEEDED(CountryList.Initialize()) )
    {
        TCHAR szText[1024];
        CCountry * pC;
        DWORD dwCurCountryID;
        LRESULT iIndex;

        CountryList.Reset();
        while ( S_OK == CountryList.Next(1,&pC,NULL) )
        {
            SHUnicodeToTChar(pC->GetCountryName(), szText, ARRAYSIZE(szText));
            iIndex = SendMessage(hwndCombo,CB_ADDSTRING,0,(LPARAM)szText);
            dwCurCountryID = pC->GetCountryID();
            SendMessage(hwndCombo,CB_SETITEMDATA,iIndex,(LPARAM)dwCurCountryID);

            if ( dwCurCountryID == dwSelectedCountry )
            {
                SendMessage(hwndCombo,CB_SETCURSEL,iIndex,0);
                bResult = TRUE;
            }
        }
    }

    // REVIEW: If no country was selected (bResult == FALSE) should we simply select some
    // arbitrary country?  First in the list?  The USA?

    return bResult;
}

BOOL CLocationPropSheet::PopulateDisableCallWaitingCodes(HWND hwndCombo, LPTSTR szSelected)
{
    TCHAR cszTelephonyKey[] = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations");
    HKEY hkey;
    int i;

    // These get read from the registry
    // NOTE: This might fail on a tightly locked down system, but there's nothing I can do
    // about that.  Worst case the list of codes is empty and the user just types the code.
    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszTelephonyKey,
            0, KEY_QUERY_VALUE, &hkey) )
    {
        TCHAR szDisableCallWaiting[32];
        TCHAR szCode[32];
        DWORD dwType;
        DWORD dwSize;

        for ( i=0; ; i++ )
        {
            // This string is a reg value and is not localized
            wsprintf(szDisableCallWaiting, TEXT("DisableCallWaiting%d"), i);

            dwSize = sizeof(szCode);
            if ( ERROR_SUCCESS != RegQueryValueEx(hkey, szDisableCallWaiting, NULL, &dwType, (LPBYTE)szCode, &dwSize) )
            {
                // when we fail to read an item its most likely because their are no more items,
                // but even if it's some other error we don't know how to handle it anyhow.
                break;
            }

            if ( dwType != REG_SZ )
            {
                // I'll just skip any values that I don't know how to deal with
                continue;
            }

            SendMessage(hwndCombo,CB_ADDSTRING,0,(LPARAM)szCode);
        }
    }

    // and then we add a special one if the current code is not a standard code
    if ( szSelected && *szSelected )
    {
        LRESULT lResult;

        lResult = SendMessage(hwndCombo, CB_FINDSTRINGEXACT, -1, (LPARAM)szSelected);
        if ( lResult == (LRESULT)CB_ERR )
        {
            // if the item wasn't found, we add it
            lResult = SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)szSelected);
        }

        SendMessage(hwndCombo, CB_SETCURSEL, lResult, 0);
    }

    return TRUE;
}

BOOL CLocationPropSheet::General_OnCommand(HWND hwndParent, int wID, int wNotifyCode, HWND hwndCtl)
{
    WCHAR wszBuf[512];

    switch (wID)
    {
    case IDC_DISABLECALLWAITING:
        if ( BN_CLICKED == wNotifyCode )
        {
            BOOL bOn = SendMessage(hwndCtl, BM_GETCHECK, 0,0) == BST_CHECKED;
            HWND hwnd = GetDlgItem(hwndParent, IDC_DISABLESTRING);
            EnableWindow(hwnd, bOn);
            m_pLoc->UseCallWaiting(bOn);
            if ( bOn )
            {
                SetFocus(hwnd);
            }
            break;
        }
        return 1;

    case IDC_TONE:
    case IDC_PULSE:
        m_pLoc->UseToneDialing(IDC_TONE==wID);
        break;

    case IDC_COUNTRY:
        if ( CBN_SELCHANGE == wNotifyCode )
        {
            LRESULT lrSel = SendMessage(hwndCtl,CB_GETCURSEL,0,0);
            m_dwCountryID = (DWORD)SendMessage(hwndCtl,CB_GETITEMDATA,lrSel,0);
            m_pLoc->SetCountryID(m_dwCountryID);

            CCountry * pCountry;
            HRESULT hr;

            hr = CreateCountryObject(m_dwCountryID, &pCountry);
            if ( SUCCEEDED(hr) )
            {
                m_iCityRule = IsCityRule(pCountry->GetLongDistanceRule());
                m_iLongDistanceCarrierCodeRule = IsLongDistanceCarrierCodeRule( pCountry->GetLongDistanceRule() );
                m_iInternationalCarrierCodeRule = IsInternationalCarrierCodeRule( pCountry->GetInternationalRule() );
                delete pCountry;
            } else {
                LOG((TL_ERROR, "General_OnInitDialog failed to create country %d", m_dwCountryID));
                m_iCityRule = CITY_OPTIONAL;
                m_iLongDistanceCarrierCodeRule = LONG_DISTANCE_CARRIER_OPTIONAL;
                m_iInternationalCarrierCodeRule = INTERNATIONAL_CARRIER_OPTIONAL;
            }


            HWND hwnd = GetDlgItem(hwndParent,IDC_AREACODE);
            if ( m_iCityRule == CITY_NONE )
            {
                SetWindowText(hwnd, TEXT(""));
                m_pLoc->SetAreaCode(L"");
                EnableWindow(hwnd, FALSE);
            }
            else
            {
                EnableWindow(hwnd, TRUE);
            }

            hwnd = GetDlgItem(hwndParent,IDC_LONGDISTANCECARRIERCODE);
            if ( LONG_DISTANCE_CARRIER_NONE == m_iLongDistanceCarrierCodeRule ) 
            {
                SetWindowText(hwnd, TEXT(""));
                m_pLoc->SetLongDistanceAccessCode(L"");
                EnableWindow(hwnd, FALSE);
                EnableWindow(GetDlgItem(hwndParent,IDC_STATICLDC), FALSE);
            }
            else
            {
                EnableWindow(hwnd, TRUE);
                EnableWindow(GetDlgItem(hwndParent,IDC_STATICLDC), TRUE);
            }

            hwnd = GetDlgItem(hwndParent,IDC_INTERNATIONALCARRIERCODE);
            if ( INTERNATIONAL_CARRIER_NONE == m_iInternationalCarrierCodeRule ) 
            {
                SetWindowText(hwnd, TEXT(""));
                m_pLoc->SetInternationalCarrierCode(L"");
                EnableWindow(hwnd, FALSE);
                EnableWindow(GetDlgItem(hwndParent,IDC_STATICIC), FALSE);
            }
            else
            {
                EnableWindow(hwnd, TRUE);
                EnableWindow(GetDlgItem(hwndParent,IDC_STATICIC), TRUE);
            }
            
            break;
        }
        return 1;

    case IDC_LOCATIONNAME:
    case IDC_AREACODE:
    case IDC_LONGDISTANCECARRIERCODE:
    case IDC_INTERNATIONALCARRIERCODE:
    case IDC_LOCALACCESSNUM:
    case IDC_LONGDISTANCEACCESSNUM:
        if ( EN_CHANGE == wNotifyCode )
        {
            TCHAR szValue[512];
            GetWindowText(hwndCtl, szValue, ARRAYSIZE(szValue));
            SHTCharToUnicode(szValue, wszBuf, ARRAYSIZE(wszBuf));
            switch (wID)
            {
                case IDC_LOCATIONNAME:
                    m_pLoc->SetName(wszBuf);
                    break;

                case IDC_AREACODE:
                    m_pLoc->SetAreaCode(wszBuf);
                    break;

                case IDC_LONGDISTANCECARRIERCODE:
                    m_pLoc->SetLongDistanceCarrierCode(wszBuf);
                    break;

                case IDC_INTERNATIONALCARRIERCODE:
                    m_pLoc->SetInternationalCarrierCode(wszBuf);
                    break;

                case IDC_LOCALACCESSNUM:
                    m_pLoc->SetLocalAccessCode(wszBuf);
                    break;

                case IDC_LONGDISTANCEACCESSNUM:
                    m_pLoc->SetLongDistanceAccessCode(wszBuf);
                    break;
            }
            break;
        }
        return 1;

    case IDC_DISABLESTRING:
        switch ( wNotifyCode )
        {
        case CBN_SELCHANGE:
            {
                TCHAR szDisableCode[128];
                LRESULT lr = SendMessage(hwndCtl, CB_GETCURSEL, 0,0);

                SendMessage(hwndCtl, CB_GETLBTEXT, lr, (LPARAM)szDisableCode);
                SHTCharToUnicode(szDisableCode, wszBuf, ARRAYSIZE(wszBuf));
                m_pLoc->SetDisableCallWaitingCode(wszBuf);
            }
            break;

        case CBN_EDITCHANGE:
            {
                TCHAR szDisableCode[128];

                GetWindowText(hwndCtl, szDisableCode, ARRAYSIZE(szDisableCode));
                SHTCharToUnicode(szDisableCode, wszBuf, ARRAYSIZE(wszBuf));
                m_pLoc->SetDisableCallWaitingCode(wszBuf);
            }
            break;
        default:
            return 1;
        }
        break;

    default:
        return 0;
    }

    if (m_pwszAddress)
    {
        CCallingCard * pCard = NULL;
        if (m_pLoc->HasCallingCard())
        {
            pCard = m_Cards.GetCallingCard(m_pLoc->GetPreferredCardID());
        }
        UpdateSampleString(GetDlgItem(hwndParent, IDC_PHONENUMBERSAMPLE), m_pLoc, m_pwszAddress, pCard);
    }

    m_pLoc->Changed();
    SendMessage(GetParent(hwndParent),PSM_CHANGED,(WPARAM)hwndParent,0);

    return 1;
}

BOOL CLocationPropSheet::General_OnNotify(HWND hwndDlg, LPNMHDR pnmhdr)
{
    // Let the generic handler have a crack at it first
    OnNotify(hwndDlg, pnmhdr);

    switch (pnmhdr->code)
    {
    case PSN_APPLY:     // user pressed OK or Apply
        return General_OnApply(hwndDlg);
     
    case PSN_SETACTIVE:
        if (m_pwszAddress)
        {
            CCallingCard * pCard = NULL;
            if (m_pLoc->HasCallingCard())
            {
                pCard = m_Cards.GetCallingCard(m_pLoc->GetPreferredCardID());
            }
            UpdateSampleString(GetDlgItem(hwndDlg, IDC_PHONENUMBERSAMPLE), m_pLoc, m_pwszAddress, pCard);
        }
        break;
    default:
        break;
    }
    return FALSE;
}

// General_OnApply
//
// Called when the user selects OK or APPLY on the prop sheet.
// Return PSNRET_INVALID_NOCHANGEPAGE if anything is wrong.
// Return PSNRET_NOERROR if everything is OK.
BOOL CLocationPropSheet::General_OnApply(HWND hwndDlg)
{
    PWSTR   pwszName;
    int     iCtl;
    int     iErr;

    // First we do the sanity checks.  We return without changing the object if any of these fail.
    //  * The location must have a name
    //  * The location must have an area code if it's not a CityRule
    //  * If "Disable call waiting" is checked, a disable code must have been entered
    //  * A Country must be selected (it should be impossible for this not to be true, but we check to be safe).
    //  * The name, as entered, must be unique
    pwszName = m_pLoc->GetName();
    if ( !*pwszName )
    {
        iCtl = IDC_LOCATIONNAME;
        iErr = IDS_NEEDALOCATIONNAME;
        goto ExitWithError;
    }

    if ( (CITY_MANDATORY==m_iCityRule) && !*(m_pLoc->GetAreaCode()) )
    {
        iCtl = IDC_AREACODE;
        iErr = IDS_NEEDANAREACODE;
        goto ExitWithError;
    }

    if ( (LONG_DISTANCE_CARRIER_MANDATORY == m_iLongDistanceCarrierCodeRule) && 
         !*(m_pLoc->GetLongDistanceCarrierCode()) )
    {
        iCtl = IDC_LONGDISTANCECARRIERCODE;
        iErr = IDS_NEEDALONGDISTANCECARRIERCODE;
        goto ExitWithError;
    }

    if ( (INTERNATIONAL_CARRIER_MANDATORY == m_iInternationalCarrierCodeRule) && 
         !*(m_pLoc->GetInternationalCarrierCode()) )
    {
        iCtl = IDC_INTERNATIONALCARRIERCODE;
        iErr = IDS_NEEDANINTERNATIONALCARRIERCODE;
        goto ExitWithError;
    }

    if ( m_pLoc->HasCallWaiting() && !*(m_pLoc->GetDisableCallWaitingCode()) )
    {
        iCtl = IDC_DISABLESTRING;
        iErr = IDS_NEEDADISABLESTRING;
        goto ExitWithError;
    }

    if ( !m_dwCountryID )
    {
        iCtl = IDC_COUNTRY;
        iErr = IDS_NEEDACOUNTRY;
        goto ExitWithError;
    }

    // We need to ensure that the name is unique.
    CLocation * pLoc;
    m_pLocList->Reset();
    while (S_OK == m_pLocList->Next(1, &pLoc, NULL))
    {
        // exclude ourselves from this comparision.
        if ( pLoc->GetLocationID() != m_pLoc->GetLocationID() )
        {
            // see if the names are identical
            if ( 0 == StrCmpIW(pLoc->GetName(), pwszName))
            {
                // yes, the name is in conflict
                iCtl = IDC_LOCATIONNAME;
                iErr = IDS_NEEDUNIQUENAME;
                goto ExitWithError;
            }
        }
    }

    // everything is OK
    m_bWasApplied = TRUE;

    return PSNRET_NOERROR;

ExitWithError:
    PropSheet_SetCurSelByID(GetParent(hwndDlg),IDD_LOC_GENERAL);
    ShowErrorMessage(GetDlgItem(hwndDlg,iCtl), iErr);
    SetWindowLongPtr(hwndDlg,DWLP_MSGRESULT,PSNRET_INVALID_NOCHANGEPAGE);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\cplsimpledialogs.h ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplsimpledialogs.h
                                                              
       Author:  toddb - 10/06/98
              
****************************************************************************/

#pragma once

// Simple dialog class that shows a dialog with a title, a string, and an edit box.
// Input into the edit box is limited according to the flags.  The text from the
// edit box is available to the class creator after the dialog is dismissed.  This
// class is used for "Specify Digits" and "Add Prefix".
//
// Sample usage:
//  CEditDialog ed;
//  ed.DoModal(hwnd,IDS_TITLE,IDS_TEXT,LIF_NUMBER);
//  ed.GetString();

class CEditDialog
{
public:
    CEditDialog();
    ~CEditDialog();

    INT_PTR DoModal(HWND hwndParent, int iTitle, int iText, int iDesc, DWORD dwFlags);
    LPTSTR GetString();
protected:
    LPTSTR  m_psz;      // pointer to allocated buffer for string result
    int     m_iTitle;   // resource id to load for title
    int     m_iText;    // resource id to load for body text
    int     m_iDesc;    // resource id to load for description of edit field (should contain a "&")
    DWORD   m_dwFlags;  // limit input flags, or zero to allow all input

    static INT_PTR CALLBACK DialogProc(HWND, UINT, WPARAM, LPARAM);
    BOOL OnInitDialog(HWND hwnd);
    void OnOK(HWND hwnd);
};

// The simple dialog that pops up to ask what we are waiting for.  It presents
// a bunch of radio buttons for each choice and a spin button for the seconds.

class CWaitForDialog
{
public:
    CWaitForDialog();
    ~CWaitForDialog();

    INT_PTR DoModal(HWND hwndParent);
    int GetWaitType();
protected:
    int     m_iRes;     // Integer return value

    static INT_PTR CALLBACK DialogProc(HWND, UINT, WPARAM, LPARAM);
    BOOL OnInitDialog(HWND hwnd);
    void OnOK(HWND hwnd);
};

// This dialog presents the user with choices for what parts of the destination
// number need to be dialed.  It cat's the results into a WCHAR buffer which
// can then be retreived.

class CDestNumDialog
{
public:
    CDestNumDialog(BOOL bDialCountryCode, BOOL bDialAreaCode);
    ~CDestNumDialog();

    INT_PTR DoModal(HWND hwndParent);
    PWSTR GetResult();
protected:
    WCHAR   m_wsz[4];     // return value is from 1 to 3 wide characters, null terminated
    BOOL    m_bDialCountryCode; // initial value for "Dial Country Code" checkbox
    BOOL    m_bDialAreaCode;    // initial value for "Dial Area Code" checkbox

    static INT_PTR CALLBACK DialogProc(HWND, UINT, WPARAM, LPARAM);
    BOOL OnInitDialog(HWND hwnd);
    void OnOK(HWND hwnd);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\cplprecomp.h ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplprecomp.h
                                                              
       Author:  toddb - 10/06/98
              
****************************************************************************/

#pragma once

#define TAPI_CURRENT_VERSION 0x00030000

#include <windows.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <cpl.h>
#include <prsht.h>
#include <commctrl.h>
#include <comctrlp.h>

#include "cplResource.h"
#include "HelpArray.h"

// TAPI class definitions
#include "tapi.h"
#include "tspi.h"
#include "utils.h"
#include "card.h"
#include "rules.h"
#include "location.h"
// for TapiIsSafeToDisplaySensitiveData
#include "tregupr2.h"


typedef struct tagPSPINFO
{
    int     iDlgID;
    DLGPROC pfnDlgProc;
} PSPINFO;

// we limit all input strings to 128 characters.  This includes phone numbers, area codes, pin numbers,
// access numbers, any type of input field.  This was chosen simply for versatility and simplicity.
#define MAX_INPUT           128
#define CPL_SETTEXTLIMIT    (MAX_INPUT-1)

#define LIF_ALLOWALPHA      0x00000001  // a-z, A-Z
#define LIF_ALLOWNUMBER     0x00000002  // 0-9
#define LIF_ALLOWDASH       0x00000004  // "-", "(", and ")"
#define LIF_ALLOWPOUND      0x00000008  // "#"
#define LIF_ALLOWSTAR       0x00000010  // "*"
#define LIF_ALLOWSPACE      0x00000020  // " "
#define LIF_ALLOWCOMMA      0x00000040  // ","
#define LIF_ALLOWPLUS       0x00000080  // "+"
#define LIF_ALLOWBANG       0x00000100  // "!"
#define LIF_ALLOWATOD       0x00000200  // a-d, A-D

BOOL LimitInput(HWND hwnd, DWORD dwFalgs);      // edit (or whatever) control version
BOOL LimitCBInput(HWND hwnd, DWORD dwFlags);    // ComboBox version
void HideToolTip();                             // called to ensure that any visable LimitInput tooltip is hidden
void ShowErrorMessage(HWND hwnd, int iErr);     // beeps, displays a message box with an error string, and set focus to the given window
HINSTANCE GetUIInstance();                      // returns a handle to the UI module

HRESULT CreateCountryObject(DWORD dwCountryID, CCountry **ppCountry);
// return values for IsCityRule
#define CITY_MANDATORY  (1)
#define CITY_OPTIONAL   (-1)
#define CITY_NONE       (0)

int IsCityRule(PWSTR lpRule);              // sees if an area code is required
BOOL  IsEmptyOrHasOnlySpaces(PTSTR);            // sees if a string is empty or has only spaces
BOOL  HasOnlyCommasW(PWSTR);                    // sees if a string has only commas

BOOL IsLongDistanceCarrierCodeRule(LPWSTR lpRule);
BOOL IsInternationalCarrierCodeRule(LPWSTR lpRule);
// PopulateCountryList
//
// Used to fill a combo box with the list of available countries.  The item
// data for each item will countain the countries ID (not a CCountry object pointer)
BOOL PopulateCountryList(HWND hwndCombo, DWORD dwSelectedCountry);

// DeleteItemAndSelectPrevious
//
// In all of our list boxes we have to worry about deleting the selected item and then moving the
// selection to the previous item in the list.  This usually happens in response to pressing a
// delete button, which often causes that delete button to become disabled, so we also have to
// worry about moving focus away from the delete button and onto a good default location.
//
// Deletes iItem from listbox iList in dialog hwndParent.  If the listbox becomes empty it moves
// focus to iAdd if iDel currently has the focus.
int DeleteItemAndSelectPrevious( HWND hwndParent, int iList, int iItem, int iDel, int iAdd );

#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))

extern TCHAR gszHelpFile[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\cplsimpledialogs.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplsimpledialogs.cpp
                                                              
       Author:  toddb - 10/06/98

****************************************************************************/

#include "cplPreComp.h"
#include "cplSimpleDialogs.h"

// ****************************************************
//
// CEditDialog
//
// ****************************************************

CEditDialog::CEditDialog()
{
    m_psz = NULL;
}

CEditDialog::~CEditDialog()
{
    if ( m_psz )
    {
        delete m_psz;
    }
}

INT_PTR CEditDialog::DoModal(HWND hwndParent, int iTitle, int iText, int iDesc, DWORD dwFlags)
{
    m_iTitle = iTitle;
    m_iText = iText;
    m_iDesc = iDesc;
    m_dwFlags = dwFlags;

    return DialogBoxParam(GetUIInstance(),
                          MAKEINTRESOURCE(IDD_EDITDIALOG),
                          hwndParent,
                          CEditDialog::DialogProc,
                          (LPARAM)this);
}

LPTSTR CEditDialog::GetString()
{
    return m_psz;
}

INT_PTR CALLBACK CEditDialog::DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CEditDialog * ped = (CEditDialog *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        ped = (CEditDialog *)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);
        return ped->OnInitDialog(hwnd);

    case WM_COMMAND:
        switch ( LOWORD(wParam) )
        {
        case IDOK:
            ped->OnOK(hwnd);
            // fall through

        case IDCANCEL:
            HideToolTip();
            EndDialog(hwnd, LOWORD(wParam));
            break;
        }
        break;
   
#define aIDs ((ped->m_iTitle == IDS_SPECIFYDIGITS)?a117HelpIDs:a116HelpIDs)
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        WinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) aIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        WinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) aIDs);
        break;
#undef aIDs
    }

    return 0;
}

BOOL CEditDialog::OnInitDialog(HWND hwnd)
{
    TCHAR szText[512];

    LoadString(GetUIInstance(), m_iTitle, szText, ARRAYSIZE(szText));
    SetWindowText(hwnd, szText);

    LoadString(GetUIInstance(), m_iText, szText, ARRAYSIZE(szText));
    SetWindowText(GetDlgItem(hwnd,IDC_TEXT), szText);

    LoadString(GetUIInstance(), m_iDesc, szText, ARRAYSIZE(szText));
    SetWindowText(GetDlgItem(hwnd,IDC_DESCRIPTIONTEXT), szText);

    HWND hwndEdit = GetDlgItem(hwnd,IDC_EDIT);
    SendMessage(hwndEdit, EM_SETLIMITTEXT, CPL_SETTEXTLIMIT, 0);
    SetFocus(hwndEdit);
    LimitInput(hwndEdit,m_dwFlags);

    return 0;
}

void CEditDialog::OnOK(HWND hwnd)
{
    DWORD dwStart;
    DWORD dwEnd;

    HWND hwndEdit = GetDlgItem(hwnd,IDC_EDIT);
    SendMessage(hwndEdit,EM_SETSEL,0,-1);
    SendMessage(hwndEdit,EM_GETSEL,(WPARAM)&dwStart,(LPARAM)&dwEnd);

    dwEnd++;                                // add room for a NULL terminator
    m_psz = new TCHAR[dwEnd];               // allocate the buffer
	if (NULL != m_psz)
	{
		GetWindowText(hwndEdit,m_psz,dwEnd);    // and read in the string
	}
}

// ****************************************************
//
// CWaitForDialog
//
// ****************************************************

CWaitForDialog::CWaitForDialog()
{
    m_iRes = -1;
}

CWaitForDialog::~CWaitForDialog()
{
}

INT_PTR CWaitForDialog::DoModal(HWND hwndParent)
{
    return DialogBoxParam(GetUIInstance(),
                          MAKEINTRESOURCE(IDD_WAITFORDIALOG),
                          hwndParent,
                          CWaitForDialog::DialogProc,
                          (LPARAM)this);
}

int CWaitForDialog::GetWaitType()
{
    return m_iRes;
}

INT_PTR CALLBACK CWaitForDialog::DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CWaitForDialog * pwd = (CWaitForDialog *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pwd = (CWaitForDialog *)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);
        return pwd->OnInitDialog(hwnd);

    case WM_COMMAND:
        switch ( LOWORD(wParam) )
        {
        case IDC_WAITFORDIALTONE:
        case IDC_WAITFORVOICE:
            EnableWindow(GetDlgItem(hwnd, IDC_TIME), FALSE);
            break;

        case IDC_WAITFORTIME:
            EnableWindow(GetDlgItem(hwnd, IDC_TIME), TRUE);
            break;

        case IDOK:
            pwd->OnOK(hwnd);
            // fall through

        case IDCANCEL:
            EndDialog(hwnd, LOWORD(wParam));
            break;
        }
        break;
   
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        WinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a111HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        WinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a111HelpIDs);
        break;
    }

    return 0;
}

BOOL CWaitForDialog::OnInitDialog(HWND hwndDlg)
{
    HWND hwnd;

    SendMessage(GetDlgItem(hwndDlg,IDC_WAITFORDIALTONE),BM_SETCHECK,BST_CHECKED,0);

    hwnd = GetDlgItem(hwndDlg, IDC_TIME);
    SetDlgItemInt(hwndDlg, IDC_TIME, 2, FALSE);
    SendMessage(hwnd, EM_SETLIMITTEXT, 2, 0);
    EnableWindow(hwnd, FALSE);
    LimitInput(hwnd, LIF_ALLOWNUMBER);

    hwnd = GetDlgItem(hwndDlg, IDC_TIMESPIN);
    SendMessage(hwnd, UDM_SETRANGE32, 2, 98);
    SendMessage(hwnd, UDM_SETPOS, 0, MAKELONG(2, 0) );
    UDACCEL accel;
    accel.nSec = 0;
    accel.nInc = 2;
    SendMessage(hwnd, UDM_SETACCEL, 1, (LPARAM)&accel );

    return 0;
}

void CWaitForDialog::OnOK(HWND hwnd)
{
    if ( BST_CHECKED == SendMessage(GetDlgItem(hwnd,IDC_WAITFORDIALTONE),BM_GETCHECK,0,0) )
    {
        m_iRes = 0;
    }
    else if ( BST_CHECKED == SendMessage(GetDlgItem(hwnd,IDC_WAITFORVOICE),BM_GETCHECK,0,0) )
    {
        m_iRes = 1;
    }
    else
    {
        m_iRes = GetDlgItemInt(hwnd, IDC_TIME, NULL, FALSE);
        if ( m_iRes < 2 )
        {
            m_iRes = 2;
        }
    }
}

// ****************************************************
//
// CDestNumDialog
//
// ****************************************************

CDestNumDialog::CDestNumDialog(BOOL bDialCountryCode, BOOL bDialAreaCode)
{
    m_wsz[0] = NULL;
    m_bDialCountryCode = bDialCountryCode;
    m_bDialAreaCode = bDialAreaCode;
}

CDestNumDialog::~CDestNumDialog()
{
}

INT_PTR CDestNumDialog::DoModal(HWND hwndParent)
{
    return DialogBoxParam(GetUIInstance(),
                          MAKEINTRESOURCE(IDD_DESTNUMDIALOG),
                          hwndParent,
                          CDestNumDialog::DialogProc,
                          (LPARAM)this);
}

PWSTR CDestNumDialog::GetResult()
{
    return m_wsz;
}

INT_PTR CALLBACK CDestNumDialog::DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDestNumDialog * pwd = (CDestNumDialog *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pwd = (CDestNumDialog *)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);
        return pwd->OnInitDialog(hwnd);

    case WM_COMMAND:
        switch ( LOWORD(wParam) )
        {
        case IDOK:
            pwd->OnOK(hwnd);
            // fall through

        case IDCANCEL:
            EndDialog(hwnd, LOWORD(wParam));
            break;
        }
        break;
   
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        WinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a112HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        WinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a112HelpIDs);
        break;
    }

    return 0;
}

BOOL CDestNumDialog::OnInitDialog(HWND hwnd)
{
    SendMessage(GetDlgItem(hwnd,IDC_AREACODE),BM_SETCHECK,m_bDialAreaCode ? BST_CHECKED : BST_UNCHECKED,0);
    SendMessage(GetDlgItem(hwnd,IDC_COUNTRYCODE),BM_SETCHECK,m_bDialCountryCode ? BST_CHECKED : BST_UNCHECKED,0);
    SendMessage(GetDlgItem(hwnd,IDC_LOCALNUMBER),BM_SETCHECK,BST_CHECKED,0);
    return 0;
}

void CDestNumDialog::OnOK(HWND hwnd)
{
    int i = 0;

    if ( BST_CHECKED == SendMessage(GetDlgItem(hwnd,IDC_COUNTRYCODE),BM_GETCHECK,0,0) )
    {
        m_wsz[i++] = L'E';
    }

    if ( BST_CHECKED == SendMessage(GetDlgItem(hwnd,IDC_AREACODE),BM_GETCHECK,0,0) )
    {
        m_wsz[i++] = L'F';
    }

    if ( BST_CHECKED == SendMessage(GetDlgItem(hwnd,IDC_LOCALNUMBER),BM_GETCHECK,0,0) )
    {
        m_wsz[i++] = L'G';
    }

    m_wsz[i] = NULL;
}

void ShowErrorMessage(HWND hwnd, int iErr)
{
    TCHAR szCaption[128];
    TCHAR szText[1024];

    LoadString(GetUIInstance(), IDS_ERRORCAPTION, szCaption, ARRAYSIZE(szCaption));
    LoadString(GetUIInstance(), iErr, szText, ARRAYSIZE(szText));

    MessageBeep(MB_ICONEXCLAMATION);
    MessageBox(hwnd, szText, szCaption, MB_OK | MB_ICONEXCLAMATION);
    SetFocus(hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\dial.cpp ===
/****************************************************************************
 
  Copyright (c) 1995-1999 Microsoft Corporation
                                                              
  Module Name:  dial.cpp
                                                              
****************************************************************************/

#include <windows.h>
#include <windowsx.h>

#if WINNT
#else
#include <help.h>
#endif

#include "tchar.h"
#include "prsht.h"
#include "stdlib.h"
#include "tapi.h"
#include "tspi.h"
#include "client.h"
#include "clntprivate.h"
#include "card.h"
#include "location.h"
#include "rules.h"
#include "countrygroup.h"
#include <shlwapi.h>
#include <shlwapip.h>   // from private\inc


#undef   lineGetTranslateCaps
#undef   lineSetTollList
#undef   lineTranslateAddress
#undef   tapiGetLocationInfo
#undef   lineGetCountry
#undef   lineTranslateDialog



// moved here from loc_comn.h
#define     MAXLEN_NAME     96

#ifdef __cplusplus
extern "C"{
#endif

BOOL    gbTranslateSimple = FALSE;
BOOL    gbTranslateSilent = FALSE;


TCHAR gszTelephonyKey[]    = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony");
TCHAR gszRegKeyNTServer[]  = TEXT("System\\CurrentControlSet\\Control\\ProductOptions");

TCHAR gszLocation[]        = TEXT("Location");
TCHAR gszLocations[]       = TEXT("Locations");
const TCHAR gszNullString[]      = TEXT("");

TCHAR gszNumEntries[]      = TEXT("NumEntries");
TCHAR gszCurrentID[]       = TEXT("CurrentID");
TCHAR gszNextID[]          = TEXT("NextID");

TCHAR gszID[]              = TEXT("ID");
TCHAR gszFlags[]           = TEXT("Flags");
TCHAR gszCallingCard[]     = TEXT("CallingCard");
TCHAR gszCards[]           = TEXT("Cards");
TCHAR gszCard[]            = TEXT("Card");

#ifdef __cplusplus
}
#endif

LONG CreateCurrentLocationObject(CLocation **pLocation,
                       HLINEAPP hLineApp,
                       DWORD dwDeviceID,
                       DWORD dwAPIVersion,
                       DWORD dwOptions);

HRESULT ReadLocations( PLOCATIONLIST *ppLocationList,
                       HLINEAPP hLineApp,
                       DWORD dwDeviceID,
                       DWORD dwAPIVersion,
                       DWORD dwOptions
                     );
LONG PASCAL ReadCountries( LPLINECOUNTRYLIST *ppLCL,
                           UINT nCountryID,
                           DWORD dwDestCountryID
                         );



LONG BreakupCanonicalW( PWSTR  pAddressIn,
                        PWSTR  *pCountry,
                        PWSTR  *pCity,
                        PWSTR  *pSubscriber
                        );

static LONG  GetTranslateCapsCommon(
    HLINEAPP            hLineApp,
    DWORD               dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps,
    BOOL                bUnicode
    );

static  void   LayDownTollList(CLocation *pLocation,
                           PBYTE     pBuffer,
                           PBYTE     *ppCurrentIndex,
                           PDWORD   pPair, 
                           BOOL     bUnicode,
                           PBYTE    pFirstByteAfter
                         );
static void LayDownString( PCWSTR   pInString,
                           PBYTE     pBuffer,
                           PBYTE     *ppCurrentIndex,
                           PDWORD   pPair, 
                           BOOL     bUnicode,
                           PBYTE    pFirstByteAfter
                         );

static PWSTR    CopyStringWithExpandJAndK(PWSTR pszRule, PWSTR pszAccessNr, PWSTR pszAccountNr);
static BOOL     IsATollListAreaCodeRule(CAreaCodeRule *pRule, PWSTR pszLocationAreaCode);
static BOOL     FindTollPrefixInLocation(CLocation *pLocation,
                                         PWSTR  pPrefix,
                                         CAreaCodeRule **ppRule, 
                                         PWSTR *ppWhere);
static PWSTR    FindPrefixInMultiSZ(PWSTR pPrefixList, PWSTR pPrefix);

LONG PASCAL  WriteLocations( PLOCATIONLIST  pLocationList,
                             DWORD      dwChangedFlags
                           );


extern "C" char * PASCAL
MapResultCodeToText(
    LONG    lResult,
    char   *pszResult
    );



LONG
PASCAL
IsThisAPIVersionInvalid(
    DWORD dwAPIVersion
    )
{
   switch (dwAPIVersion)
   {
   case TAPI_VERSION3_1:
   case TAPI_VERSION3_0:
   case TAPI_VERSION2_2:
   case TAPI_VERSION2_1:
   case TAPI_VERSION2_0:
   case TAPI_VERSION1_4:
   case TAPI_VERSION1_0:

       return 0;

   default:

       break;
   }

   return LINEERR_INCOMPATIBLEAPIVERSION;
}


//***************************************************************************
//
//  TAPI API Interfaces
//
//***************************************************************************




//***************************************************************************
LONG
WINAPI
lineTranslateDialogA(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    HWND        hwndOwner,
    LPCSTR      lpszAddressIn
    )
{
    PWSTR szAddressInW = NULL;
    LONG  lResult;


    LOG((TL_TRACE, "Entering lineTranslateDialogA"));
    LOG((TL_INFO, "   hLineApp=x%lx", hLineApp));
    LOG((TL_INFO, "   dwAPIVersion=0x%08lx", dwAPIVersion));
    LOG((TL_INFO, "   hwndOwner=x%p", hwndOwner));
    LOG((TL_INFO, "   lpszAddressIn=x%p", lpszAddressIn));


    if ( lpszAddressIn )
    {
        if ( IsBadStringPtrA(lpszAddressIn, 512) )
        {
            LOG((TL_ERROR, "Bad string pointer passed to lineTranslateDialog"));
            return LINEERR_INVALPOINTER;
        }
        else
        {
            szAddressInW = MultiToWide( lpszAddressIn );
        }
    }

    //
    // Win9x ?
    //

#ifndef _WIN64

    if ((GetVersion() & 0x80000000) &&
        (0xffff0000 == ((DWORD) hwndOwner & 0xffff0000)))
    {
       //
       // Yeah.  It don't play no ffff.
       //

       hwndOwner = (HWND) ( (DWORD)hwndOwner & 0x0000ffff );
    }

#endif

    lResult = lineTranslateDialogW(
        hLineApp,
        dwDeviceID,
        dwAPIVersion,
        hwndOwner,
        szAddressInW
        );

    if ( szAddressInW )
    {
       ClientFree( szAddressInW );
    }

    return lResult;
}




//***************************************************************************
LONG
WINAPI
lineTranslateDialog(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    HWND        hwndOwner,
    LPCSTR      lpszAddressIn
    )
{
    return lineTranslateDialogA(
                 hLineApp,
                 dwDeviceID,
                 dwAPIVersion,
                 hwndOwner,
                 lpszAddressIn
    );
}


extern "C" LONG WINAPI internalConfig( HWND hwndParent, PCWSTR pwsz, INT iTab, DWORD dwAPIVersion );

//***************************************************************************
LONG
WINAPI
lineTranslateDialogW(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    DWORD       dwAPIVersion,
    HWND        hwndOwner,
    LPCWSTR     lpszAddressIn
    )
{
    PLOCATIONLIST       pLocTest = NULL;
    LONG                lResult = 0;


    LOG((TL_TRACE, "Entering lineTranslateDialogW"));
    LOG((TL_INFO, "   hLineApp=x%lx", hLineApp));
    LOG((TL_INFO, "   dwAPIVersion=0x%08lx", dwAPIVersion));
    LOG((TL_INFO, "   hwndOwner=x%p", hwndOwner));
    LOG((TL_INFO, "   lpszAddressIn=x%p", lpszAddressIn));

    // stuff that the old lineTranslateDialog did so I'm just copying it:
    lResult = IsThisAPIVersionInvalid( dwAPIVersion );
    if ( lResult )
    {
        LOG((TL_ERROR, "Bad dwAPIVersion - 0x%08lx", dwAPIVersion));
        return lResult;
    }


    if ( lpszAddressIn && TAPIIsBadStringPtrW(lpszAddressIn, (UINT)-1) )
    {
        LOG((TL_ERROR, "Bad lpszAddressIn pointer (0x%p)", lpszAddressIn));
        return LINEERR_INVALPOINTER;
    }


    if (hwndOwner && !IsWindow (hwndOwner))
    {
        LOG((TL_ERROR, "  hwndOwner is bogus"));
        return LINEERR_INVALPARAM;
    }

    // Let TAPISRV test the params for us
    lResult = ReadLocations(&pLocTest,
                            hLineApp,
                            dwDeviceID,
                            dwAPIVersion,
                            CHECKPARMS_DWHLINEAPP|
                            CHECKPARMS_DWDEVICEID|
                            CHECKPARMS_DWAPIVERSION|
                            CHECKPARMS_ONLY);

    if (pLocTest != NULL)
    {
        ClientFree( pLocTest);
    }
    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    return internalConfig(hwndOwner, lpszAddressIn, -1, dwAPIVersion);
}



//***************************************************************************
LONG
WINAPI
lineGetTranslateCaps(
    HLINEAPP            hLineApp,
    DWORD               dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    )
{
    LONG lResult;

    lResult = lineGetTranslateCapsA(
        hLineApp,
        dwAPIVersion,
        lpTranslateCaps
        );

    //
    // Some 1.x apps like Applink (as of version 7.5b) don't call
    // lineTranslateDialog when they get a LINEERR_INIFILECORRUPT
    // result back from the request (spec says they should call
    // lineTranslateDialog), so we do that here for them, otherwise
    // some (like Applink) blow up
    //
    // While it's kind of ugly & intrusive, this is a less awkward
    // fix than placing a bogus location entry in the registry &
    // setting an Inited flag == 0 like tapi 1.x does
    //
    // There are cases in which this hack can break the caller (ex. MSWORKS)
    // The gbDisableGetTranslateCapsHack flag set to TRUE prevents the hack to be applied
    // See bug 306143
 
    if (lResult == LINEERR_INIFILECORRUPT && !gbDisableGetTranslateCapsHack)
    {
        lineTranslateDialog(
            hLineApp,
            0,
            dwAPIVersion,
            GetActiveWindow(),
            NULL
            );

        lResult = lineGetTranslateCapsA(
            hLineApp,
            dwAPIVersion,
            lpTranslateCaps
            );
    }

    return lResult;


}



//***************************************************************************
LONG
WINAPI
lineGetTranslateCapsA(
    HLINEAPP            hLineApp,
    DWORD               dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    )
{
    LONG    lResult = 0;    
    
    LOG((TL_TRACE, "Entering lineGetTranslateCapsA"));
    LOG((TL_INFO, "   hLineApp=x%lx", hLineApp));
    LOG((TL_INFO, "   dwAPIVersion=0x%08lx", dwAPIVersion));
    LOG((TL_INFO, "   lpTranslateCaps=x%p", lpTranslateCaps));

    lResult = GetTranslateCapsCommon(hLineApp, dwAPIVersion, lpTranslateCaps, FALSE);
    
    #if DBG
    {
        char szResult[32];


        LOG((TL_TRACE,
            "lineGetTranslateCapsA: result = %hs",
            MapResultCodeToText (lResult, szResult)
            ));
    }
    #else
        LOG((TL_TRACE,
            "lineGetTranslateCapsA: result = x%x",
            lResult
            ));
    #endif
    return lResult;
}

//***************************************************************************
LONG
WINAPI
lineGetTranslateCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    )
{
    LONG    lResult = 0;
    
    LOG((TL_TRACE, "Entering lineGetTranslateCapsW"));
    LOG((TL_INFO, "   hLineApp=x%lx", hLineApp));
    LOG((TL_INFO, "   dwAPIVersion=0x%08lx", dwAPIVersion));
    LOG((TL_INFO, "   lpTranslateCaps=x%p", lpTranslateCaps));

    lResult =  GetTranslateCapsCommon(  hLineApp,
                                        dwAPIVersion,
                                        lpTranslateCaps,
                                        TRUE);
    

    #if DBG
    {
        char szResult[32];


        LOG((TL_TRACE,
            "lineGetTranslateCapsW: result = %hs",
            MapResultCodeToText (lResult, szResult)
            ));
    }
    #else
        LOG((TL_TRACE,
            "lineGetTranslateCapsW: result = x%x",
            lResult
            ));
    #endif

    return lResult;
}





//***************************************************************************


LONG
WINAPI
lineTranslateAddressA(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCSTR                  lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    )
{
    WCHAR szTempStringW[512];
    LONG  lResult;


    if ( IsBadStringPtrA(lpszAddressIn, 512) )
    {
        LOG((TL_ERROR,
            "Invalid pszAddressIn pointer passed into lineTranslateAddress"
            ));

        return LINEERR_INVALPOINTER;
    }

    MultiByteToWideChar(
        GetACP(),
        MB_PRECOMPOSED,
        lpszAddressIn,
        -1,
        szTempStringW,
        512
        );

    lResult = lineTranslateAddressW(
        hLineApp,
        dwDeviceID,
        dwAPIVersion,
        szTempStringW,
        dwCard,
        dwTranslateOptions,
        lpTranslateOutput
        );

    if ( 0 == lResult )
    {
        WideStringToNotSoWideString(
            (LPBYTE)lpTranslateOutput,
            &lpTranslateOutput->dwDialableStringSize
            );

        WideStringToNotSoWideString(
            (LPBYTE)lpTranslateOutput,
            &lpTranslateOutput->dwDisplayableStringSize
            );
    }

    return lResult;
}


LONG
WINAPI
lineTranslateAddress(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCSTR                  lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    )
{
    LONG lResult;


    lResult = lineTranslateAddressA(
        hLineApp,
        dwDeviceID,
        dwAPIVersion,
        lpszAddressIn,
        dwCard,
        dwTranslateOptions,
        lpTranslateOutput
        );

    //
    // Some 1.x apps like Applink (as of version 7.5b) don't call
    // lineTranslateDialog when they get a LINEERR_INIFILECORRUPT
    // result back from the request (spec says they should call
    // lineTranslateDialog), so we do that here for them, otherwise
    // some (like Applink) blow up
    //
    // While it's kind of ugly & intrusive, this is a less awkward
    // fix than placing a bogus location entry in the registry &
    // setting an Inited flag == 0 like tapi 1.x does
    //

    if (lResult == LINEERR_INIFILECORRUPT)
    {
        lineTranslateDialog(
            hLineApp,
            0,
            dwAPIVersion,
            GetActiveWindow(),
            NULL
            );

        lResult = lineTranslateAddressA(
            hLineApp,
            dwDeviceID,
            dwAPIVersion,
            lpszAddressIn,
            dwCard,
            dwTranslateOptions,
            lpTranslateOutput
            );
    }

    return lResult;

}




//***************************************************************************
LONG
WINAPI
lineTranslateAddressW(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCWSTR                 lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    )
{                   
    CLocation    *  pLocation = NULL;
    CCallingCard *  pCallingCard = NULL;
    DWORD           dwTranslateResults;
    DWORD           dwDestCountryCode;
    PWSTR           pszDialableString = NULL;
    PWSTR           pszDisplayableString = NULL;
    LONG            lResult = 0;
    HRESULT         hr=S_OK;    

    DWORD           dwCardToUse = 0;

    DWORD           dwDialableSize;
    DWORD           dwDisplayableSize;
    DWORD           dwNeededSize;
    
    LOG((TL_TRACE,  "Entering lineTranslateAddress"));



    lResult = IsThisAPIVersionInvalid( dwAPIVersion );
    if ( lResult )
    {
        LOG((TL_ERROR, "Bad dwAPIVersion - 0x%08lx", dwAPIVersion));
        return lResult;
    }


    if ( TAPIIsBadStringPtrW(lpszAddressIn,256) )
    {
        LOG((TL_ERROR, "Invalid pointer - lpszAddressInW"));
        lResult = LINEERR_INVALPOINTER;
        return lResult;
    }


    if ( dwTranslateOptions &
              ~(LINETRANSLATEOPTION_CARDOVERRIDE |
                LINETRANSLATEOPTION_CANCELCALLWAITING |
                LINETRANSLATEOPTION_FORCELOCAL |
                LINETRANSLATEOPTION_FORCELD) )
    {
        LOG((TL_ERROR, "  Invalid dwTranslateOptions (unknown flag set)"));
        lResult = LINEERR_INVALPARAM;
        return lResult;
    }


    if (  ( dwTranslateOptions & ( LINETRANSLATEOPTION_FORCELOCAL |
                                   LINETRANSLATEOPTION_FORCELD) )
                               ==
                                 ( LINETRANSLATEOPTION_FORCELOCAL |
                                   LINETRANSLATEOPTION_FORCELD)
      )
    {
        LOG((TL_ERROR, "  Invalid dwTranslateOptions (both FORCELOCAL & FORCELD set!)"));
        lResult = LINEERR_INVALPARAM;
        return lResult;
    }


    //
    // Is the structure at least a minimum size?
    //

    if (IsBadWritePtr(lpTranslateOutput, sizeof(LINETRANSLATEOUTPUT)))
    {
        LOG((TL_ERROR, "  Leaving lineTranslateAddress  INVALIDPOINTER"));
        lResult = LINEERR_INVALPOINTER;
        return lResult;
    }

    if (lpTranslateOutput->dwTotalSize < sizeof(LINETRANSLATEOUTPUT))
    {
        LOG((TL_ERROR, "  Leaving lineTranslateAddress  STRUCTURETOOSMALL"));
        lResult = LINEERR_STRUCTURETOOSMALL;
        return lResult;
    }

    if (IsBadWritePtr(lpTranslateOutput, lpTranslateOutput->dwTotalSize) )
    {
        LOG((TL_ERROR,
            "  Leaving lineTranslateAddress lpTanslateOutput->dwTotalSize bad"
            ));

        lResult = LINEERR_INVALPOINTER;
        return lResult;
    }


    //
    // Should we let some bad stuff slide?
    //

    if ( dwAPIVersion < 0x00020000 )
    {
        hLineApp = NULL;
    }





    lResult = CreateCurrentLocationObject(&pLocation,
                                          hLineApp,
                                          dwDeviceID,
                                          dwAPIVersion,
                                          CHECKPARMS_DWHLINEAPP|
                                          CHECKPARMS_DWDEVICEID|
                                          CHECKPARMS_DWAPIVERSION);
    if(FAILED(lResult))
    {
        //lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
        return lResult;
    }

    if ( dwTranslateOptions & LINETRANSLATEOPTION_CARDOVERRIDE)
    {
        dwCardToUse = dwCard;
    }
    else
    {
        if(pLocation->HasCallingCard() )
        {
            dwCardToUse = pLocation->GetPreferredCardID();
        }
    }
    if (dwCardToUse != 0)
    {
        pCallingCard = new CCallingCard;
        if(pCallingCard)
        {
            if( FAILED(pCallingCard->Initialize(dwCardToUse)) )
            {
                delete pCallingCard;
                delete pLocation;
                lResult = LINEERR_INVALCARD;
                return lResult;
            }
        }
    }

    lResult = pLocation->TranslateAddress((PWSTR)lpszAddressIn,
                                          pCallingCard,
                                          dwTranslateOptions,
                                          &dwTranslateResults,
                                          &dwDestCountryCode,
                                          &pszDialableString,
                                          &pszDisplayableString
                                         );

    if (lResult == 0)

    {
        dwDialableSize = sizeof(WCHAR) * (lstrlenW(pszDialableString) + 1);
        dwDisplayableSize = sizeof(WCHAR) * (lstrlenW(pszDisplayableString) + 1);

        dwNeededSize = dwDialableSize +
                       dwDisplayableSize +
                       3 + // For potential alignment problem
                       sizeof(LINETRANSLATEOUTPUT);


        lpTranslateOutput->dwNeededSize = dwNeededSize;

        lpTranslateOutput->dwCurrentCountry = pLocation->GetCountryID();

        lpTranslateOutput->dwDestCountry    = dwDestCountryCode; // country code, not the ID !!

        if (dwNeededSize <= lpTranslateOutput->dwTotalSize)
        {
            lpTranslateOutput->dwUsedSize = dwNeededSize;

            lpTranslateOutput->dwDialableStringSize      = dwDialableSize;

            lpTranslateOutput->dwDialableStringOffset    =
                sizeof(LINETRANSLATEOUTPUT);

            lpTranslateOutput->dwDisplayableStringSize   = dwDisplayableSize;

            lpTranslateOutput->dwDisplayableStringOffset =
                sizeof(LINETRANSLATEOUTPUT) + dwDialableSize;

            // lpTranslateOutput->dwDisplayableStringOffset =
            //     (sizeof(LINETRANSLATEOUTPUT) + dwDialableSize
            //     + 3) & 0xfffffffc;

            lpTranslateOutput->dwTranslateResults        = dwTranslateResults;

            wcscpy ((WCHAR *)(lpTranslateOutput + 1), pszDialableString);

            //
            // Be ultra paranoid and make sure the string is DWORD aligned
            //

            wcscpy(
                (LPWSTR)(((LPBYTE)(lpTranslateOutput + 1) +
                    dwDialableSize)),
                    // + 3 )     & 0xfffffffc)
                 pszDisplayableString
                 );
        }
        else
        {
            lpTranslateOutput->dwUsedSize = sizeof(LINETRANSLATEOUTPUT);

            lpTranslateOutput->dwTranslateResults =
            lpTranslateOutput->dwDialableStringSize =
            lpTranslateOutput->dwDialableStringOffset =
            lpTranslateOutput->dwDisplayableStringSize =
            lpTranslateOutput->dwDisplayableStringOffset = 0;
         }
    }

//cleanup:


    if ( pszDisplayableString )
    {
        ClientFree( pszDisplayableString );
    }
    if ( pszDialableString )
    {   
        ClientFree( pszDialableString );
    }
    if (pLocation != NULL)
    {
        delete pLocation;
    }
    if (pCallingCard != NULL)
    {
        delete pCallingCard;
    }

/*
    //
    // If success & there's an LCR hook for this function then call it
    // & allow it to override our results if it wants to
    //

    if (lResult == 0  &&
        IsLeastCostRoutingEnabled()  &&
        pfnLineTranslateAddressWLCR)
    {
        lResult = (*pfnLineTranslateAddressWLCR)(
            hLineApp,
            dwDeviceID,
            dwAPIVersion,
            lpszAddressIn,
            dwCard,
            dwTranslateOptions,
            lpTranslateOutput
            );
    }
 */
    return (lResult);
}





//***************************************************************************
LONG
WINAPI
lineSetCurrentLocation(
    HLINEAPP    hLineApp,
    DWORD       dwLocationID
    )
{

    UINT n;
    PUINT pnStuff;
    PLOCATIONLIST pLocationList;
    PLOCATION  pEntry;
    LONG lResult = 0;
    HRESULT hr;
    DWORD dwCurrentLocationID = 0;
    DWORD dwNumEntries = 0;
    DWORD dwCount = 0;


    LOG((TL_TRACE,
        "lineSetCurrentLocation: enter, hApp=x%x, dwLoc=x%x",
        hLineApp,
        dwLocationID
        ));

    // Let TAPISRV test the params for us
     hr = ReadLocations(&pLocationList,       
                       hLineApp,                   
                       0,                   
                       0,                  
                       CHECKPARMS_DWHLINEAPP      
                      );

    if SUCCEEDED( hr) 
    {
        // current location
        dwCurrentLocationID  = pLocationList->dwCurrentLocationID;   

        
        
        //
        // If (specified loc == current loc) then simply return SUCCESS.
        //
        // Ran into a problem with the Equis (Reuters) DownLoader app in
        // which it would call this func, we'd pass the info to tapisrv,
        // tapisrv would send a LINE_LINEDEVSTATE\TRANSLATECHANGE msg,
        // and the app would respond by doing a lineSetCurrentLocation
        // again, effectively winding up in an infinite loop.  Fyi, tapi
        // 1.x did not send a DEVSTATE\TRANSLATECHANGE msg if the
        // specified locationID == the current location ID.
        //
    
        if (dwLocationID == dwCurrentLocationID)
        {
            lResult = 0;
        }
        else
        {
            hr = E_FAIL;  // fail if we don't find the requested loc
    
            // Find position of 1st LOCATION structure in the LOCATIONLIST structure 
            pEntry = (PLOCATION) ((BYTE*)(pLocationList) + pLocationList->dwLocationListOffset );           
    
            // Number of locations ?
            dwNumEntries =  pLocationList->dwNumLocationsInList;
    
            // Find the current location
            for (dwCount = 0; dwCount < dwNumEntries ; dwCount++)
            {
        
                if(pEntry->dwPermanentLocationID == dwLocationID)
                {
                    hr = S_OK;
                    break;
                }
    
                // Try next location in list
                //pEntry++;
                pEntry = (PLOCATION) ((BYTE*)(pEntry) + pEntry->dwUsedSize);           
    
            }

            if SUCCEEDED( hr) 
            {
                LOG((TL_INFO, "lineSetCurrentLocation - reqired location found %d",
                        dwCurrentLocationID));


                // write new value
                // finished with TAPI memory block so release
                if ( pLocationList != NULL )
                        ClientFree( pLocationList );


                // Allocate the memory buffer;
                pLocationList = (PLOCATIONLIST) ClientAlloc( sizeof(LOCATIONLIST) );
                if (pLocationList != NULL)
                {
                    // buffer size 
                    pLocationList->dwTotalSize  = sizeof(LOCATIONLIST);
                    pLocationList->dwNeededSize = sizeof(LOCATIONLIST);
                    pLocationList->dwUsedSize   = sizeof(LOCATIONLIST);
            
                    pLocationList->dwCurrentLocationID     = dwLocationID;
                    pLocationList->dwNumLocationsAvailable = 0;
                    
                    pLocationList->dwNumLocationsInList = 0;
                    pLocationList->dwLocationListSize   = 0;
                    pLocationList->dwLocationListOffset = 0;
            
                    WriteLocations( pLocationList, CHANGEDFLAGS_CURLOCATIONCHANGED);
                }


            }
            else
            {
                LOG((TL_ERROR, "lineSetCurrentLocation - required location not found "));
                lResult = LINEERR_INVALLOCATION;
            }
        }
    }
    else
    {
        lResult = hr;
    }
    

        
    // finished with TAPI memory block so release
    if ( pLocationList != NULL )
            ClientFree( pLocationList );


    LOG((TL_TRACE, "Leaving lineSetCurrentLocation"));
    return lResult;
}





//***************************************************************************
LONG
WINAPI
lineSetTollList(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    LPCSTR      lpszAddressIn,
    DWORD       dwTollListOption
    )
{
    return lineSetTollListA(
                    hLineApp,
                    dwDeviceID,
                    lpszAddressIn,
                    dwTollListOption
    );
}



//***************************************************************************
LONG
WINAPI
lineSetTollListA(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    LPCSTR      lpszAddressIn,
    DWORD       dwTollListOption
    )
{
    WCHAR  szAddressInW[512];

    if ( IsBadStringPtrA(lpszAddressIn, 512) )
    {
        LOG((TL_ERROR, "Bad string pointer passed to lineSetTollListA"));
        return LINEERR_INVALPOINTER;
    }

    MultiByteToWideChar(
                        GetACP(),
                        MB_PRECOMPOSED,
                        lpszAddressIn,
                        -1,
                        szAddressInW,
                        512
                      );

    return lineSetTollListW(
                           hLineApp,
                           dwDeviceID,
                           szAddressInW,
                           dwTollListOption
                         );
}


//***************************************************************************
LONG
WINAPI
lineSetTollListW(
    HLINEAPP    hLineApp,
    DWORD       dwDeviceID,
    PCWSTR      pszAddressIn,
    DWORD       dwTollListOption
    )
{
    
    PWSTR       pAddressIn = NULL;
    
    PWSTR       pAreaCode;
    PWSTR       pCountryCode;
    PWSTR       pSubscriber;

    CLocation   *pLocation = NULL;

    BOOL        bPrefixPresent;
    CAreaCodeRule   *pRule = NULL;
    PWSTR       pWhere = NULL;

    LONG        lResult;

    // Test the parameters
    if ((dwTollListOption != LINETOLLLISTOPTION_ADD) &&
        (dwTollListOption != LINETOLLLISTOPTION_REMOVE))
    {
        LOG((TL_ERROR, "Bad dwTollListOption in lineSetTollListW"));
        return LINEERR_INVALPARAM;
    }

    if ( TAPIIsBadStringPtrW(pszAddressIn, 256) )
    {
       LOG((TL_ERROR, "Bad pszAddressIn (0x%p)in lineSetTollListW", pszAddressIn));
       return LINEERR_INVALPOINTER;
    }
   //
   // Now, do we have a canonical number to deal with ?
   //
    if ( *pszAddressIn != L'+' )  // Check the first char
    {
        //
        // Nope, not canonical
        //
        LOG((TL_ERROR, "Address not canonical in lineSetTollListW"));
        return LINEERR_INVALADDRESS;
    }
    
    // Alloc a copy of the string
    pAddressIn = ClientAllocString((PWSTR)pszAddressIn);
    if ( !pAddressIn )
    {
       LOG((TL_ERROR, "Memory allocation failed"));
       return LINEERR_NOMEM;
    }
    // separate the string components
    lResult = BreakupCanonicalW(pAddressIn + 1,
                                &pCountryCode,
                                &pAreaCode,
                                &pSubscriber
                                );
    if(lResult)
    {
        goto forced_exit;
    }
    // test the prefix validity.
    // assuming 3 digits..
    if(! (iswdigit(pSubscriber[0]) &&
          iswdigit(pSubscriber[1]) &&
          iswdigit(pSubscriber[2]) &&
          pSubscriber[3]         ))
    {
        LOG((TL_ERROR, "lineSetTollListW: The prefix is not valid"));
        lResult = LINEERR_INVALADDRESS;
        goto forced_exit;
    }
    
    // get the current location object
    lResult = CreateCurrentLocationObject(&pLocation,
                                          hLineApp,
                                          dwDeviceID,
                                          0,
                                          CHECKPARMS_DWHLINEAPP|
                                          CHECKPARMS_DWDEVICEID);
    if(FAILED(lResult))
    {
        //lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
        goto forced_exit;
    }

    // are the number and the current location with country code 1 ? 
    // is this number in the same area code ?
    if(pLocation->GetCountryCode() != 1 ||
       pCountryCode[0] != L'1' ||
       pCountryCode[1] != L'\0' ||
       wcscmp(pLocation->GetAreaCode(), pAreaCode) !=0 )
    {
        lResult = 0;
        goto forced_exit;
    }

    // terminate the 3 digit prefix
    pSubscriber[3] = L'\0';
    pSubscriber[4] = L'\0';

    // is there the prefix in any location toll rules ?
    bPrefixPresent = FindTollPrefixInLocation(  pLocation,
                                                pSubscriber,
                                                &pRule,
                                                &pWhere);

    if(dwTollListOption == LINETOLLLISTOPTION_ADD)
    {
        // add toll prefix
        if(bPrefixPresent)
        {
            ;// Do nothing
            lResult = 0;
        }
        else
        {
            // if we have already a toll rule, try to add the prefix to it
            if(pRule)
            {
                PWSTR   pList;
                DWORD   dwSize = pRule->GetPrefixListSize();
                // alloc a bigger list
                pList = (PWSTR)ClientAlloc(dwSize + 4*sizeof(WCHAR));
                if(pList==NULL)
                {
                    lResult = LINEERR_NOMEM;
                    goto forced_exit;
                }
                // copy the old one
                memcpy((PBYTE)pList, (PBYTE)pRule->GetPrefixList(), dwSize);
                // add our prefix
                memcpy((PBYTE)pList + dwSize-sizeof(WCHAR), (PBYTE)pSubscriber, 5*sizeof(WCHAR));
                // set the new list
                lResult = pRule->SetPrefixList(pList, dwSize + 4*sizeof(WCHAR));

                ClientFree(pList);
                if(FAILED(lResult))
                {
                    lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
                    goto forced_exit;
                }
            }
            // else a new rule must be created
            else
            {
                pRule = new CAreaCodeRule();
                if(pRule == NULL)
                {
                    lResult = LINEERR_NOMEM;
                    goto forced_exit;
                }

                lResult = pRule->Initialize(  pAreaCode,
                                    L"1",
                                    RULE_DIALNUMBER | RULE_DIALAREACODE,
                                    pSubscriber,
                                    5*sizeof(WCHAR)
                                    );
                if(FAILED(lResult))
                {
                    delete pRule;
                    lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
                    goto forced_exit;
                }
                // add the rule to the location
                pLocation->AddRule(pRule);
            }
        }
    }
    else
    {
        // delete the toll prefix
        if(bPrefixPresent)
        {
            DWORD   dwSize = pRule->GetPrefixListSize();
            // we have at least a toll rule present. If our prefix is the only one in that rule,
            // delete the entire rule
            if(dwSize<=5*sizeof(WCHAR)) 
            {
                // Delete the rule
                pLocation->RemoveRule(pRule);

                lResult = 0;
            }
            else
            {
                PWSTR   pList;
                PWSTR   pOld;
                DWORD   dwHeadSize;
                DWORD   dwTailSize;
                        
                pList = (PWSTR)ClientAlloc(dwSize - 4*sizeof(WCHAR));
                if(pList==NULL)
                {
                    lResult = LINEERR_NOMEM;
                    goto forced_exit;
                }

                pOld = pRule->GetPrefixList();

                dwHeadSize = (DWORD)((PBYTE)pWhere - (PBYTE)pOld);
                dwTailSize = dwSize - dwHeadSize - 4*sizeof(WCHAR);

                // copy the first part of the old list
                memcpy((PBYTE)pList, (PBYTE)pOld, dwHeadSize);
                // copy the rest of the list
                memcpy((PBYTE)pList+dwHeadSize, (PBYTE)pWhere + 4*sizeof(WCHAR), dwTailSize);
                // set the new list
                lResult = pRule->SetPrefixList(pList, dwSize - 4*sizeof(WCHAR));

                ClientFree(pList);
                if(FAILED(lResult))
                {
                    lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
                    goto forced_exit;
                }

            }

        }
        else
        {
            // prefix not present. Do nothing.
            lResult = 0;
        }
    }

    // Save
    lResult = pLocation->WriteToRegistry();
    if(FAILED(lResult))
    {
        lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
        goto forced_exit;
    }


    
forced_exit:

    if(pLocation)
        delete pLocation;
    if(pAddressIn)
        ClientFree(pAddressIn);

    return lResult;
}





//***************************************************************************
LONG
WINAPI
tapiGetLocationInfoW(
                     LPWSTR   lpszCountryCode,
                     LPWSTR   lpszCityCode
                     )
{
    CLocation * pLocation;
    LONG        lResult = 0;
    WCHAR     * p;
    WCHAR     * q;
    DWORD       i;
    
    if (IsBadWritePtr( lpszCountryCode, 16) )
    {
        LOG((TL_ERROR,
            "tapiGetLocationInfoW: lpszCountryCode is not a valid, 8-byte pointer"
            ));
        
        return TAPIERR_REQUESTFAILED;
    }
    
    if (IsBadWritePtr( lpszCityCode, 16) )
    {
        LOG((TL_ERROR,
            "tapiGetLocationInfoW: lpszCityCode is not a valid, 8-byte pointer"
            ));
        
        return TAPIERR_REQUESTFAILED;
    }
    
    lResult = CreateCurrentLocationObject(&pLocation,0,0,0,0);
    if(FAILED(lResult))
    {
        return TAPIERR_REQUESTFAILED;
    }
    
    TCHAR szTempChar[8];
    
    wsprintf(
        szTempChar,
        TEXT("%d"),
        pLocation->GetCountryCode()
        );
    
    SHTCharToUnicode(szTempChar, lpszCountryCode, 8);
    
    //
    // Make sure not to return > (7 chars + NULL char)
    //
    p = (WCHAR *) lpszCityCode;
    q = (WCHAR *) pLocation->GetAreaCode();
    
    for (i = 0; (i < 7) && ((p[i] = q[i]) != L'\0'); i++);
    p[7] = L'\0';
    
    delete pLocation;
    
    return 0;
}



//***************************************************************************
LONG
WINAPI
tapiGetLocationInfoA(
    LPSTR   lpszCountryCode,
    LPSTR   lpszCityCode
    )
{

   WCHAR szCountryCodeW[8];
   WCHAR szCityCodeW[8];
   LONG lResult;


   LOG((TL_TRACE, "Entering tapiGetLocationInfoA"));
   LOG((TL_INFO, "   lpszCountryCode=%p", lpszCountryCode ));
   LOG((TL_INFO, "   lpszCityCode=%p", lpszCityCode ));


   if (IsBadWritePtr( lpszCountryCode, 8) )
   {
      LOG((TL_ERROR, "tapiGetLocationInfo: lpszCountryCode is not a valid, 8-byte pointer"));
      return TAPIERR_REQUESTFAILED;
   }


   if (IsBadWritePtr( lpszCityCode, 8) )
   {
      LOG((TL_ERROR, "tapiGetLocationInfo: lpszCityCode is not a valid, 8-byte pointer"));
      return TAPIERR_REQUESTFAILED;
   }

   lResult = tapiGetLocationInfoW(
                                   szCountryCodeW,
                                   szCityCodeW
                                  );

   if ( 0 == lResult )
   {
      WideCharToMultiByte(
                           GetACP(),
                           0,
                           szCountryCodeW,
                           -1,
                           lpszCountryCode,
                           8,
                           NULL,
                           NULL
                         );

      WideCharToMultiByte(
                           GetACP(),
                           0,
                           szCityCodeW,
                           -1,
                           lpszCityCode,
                           8,
                           NULL,
                           NULL
                         );
   }

   return lResult;
}


//***************************************************************************
LONG
WINAPI
tapiGetLocationInfo(
    LPSTR   lpszCountryCode,
    LPSTR   lpszCityCode
    )
{
    return tapiGetLocationInfoA(
               lpszCountryCode,
               lpszCityCode
    );
}







//***************************************************************************
//
//  RAS Private Interfaces
//
//***************************************************************************

#ifndef NORASPRIVATES

//***************************************************************************
LOCATION*
LocationFromID(
    IN LOCATION* pLocs,
    IN UINT      cLocs,
    IN DWORD     dwID )
{
return NULL;
}



//***************************************************************************
LOCATION*
LocationFromName(
    IN LOCATION* pLocs,
    IN UINT      cLocs,
    IN WCHAR*    pszName )
{
return NULL;
}


//***************************************************************************
//
//  internalCreateDefLocation
//
//      This API is created to be used by OOBE team internally.
//  It expectes a LOCATIONLIST with at least one LOCATION
//  specified in it. and pLocation->dwCurrentLocationID needs to
//  match dwPermanentLocationID of at least one of the location
//  entries specified in the location list.
//
extern "C"
HRESULT APIENTRY
internalCreateDefLocation(
    PLOCATIONLIST  pLocationList
    )
{
    HRESULT                 hr = S_OK;
    DWORD                   dw;
    PLOCATION               pEntry;

    //  Basic parameter check
    if (pLocationList == NULL ||
        pLocationList->dwNumLocationsInList < 1 ||
        pLocationList->dwUsedSize == 0 ||
        pLocationList->dwUsedSize > pLocationList->dwTotalSize ||
        pLocationList->dwTotalSize < 
            sizeof(LOCATIONLIST) + sizeof(LOCATION) ||
        pLocationList->dwLocationListSize < sizeof(LOCATION)
        )
    {
        hr = E_INVALIDARG;
        goto ExitHere;
    }

    //  Check the validity of the dwCurrentLocationID
    pEntry = (PLOCATION)((LPBYTE)pLocationList +
        pLocationList->dwLocationListOffset);
    for (dw = 0; dw < pLocationList->dwNumLocationsInList; ++dw)
    {
        if (pEntry->dwPermanentLocationID == 
            pLocationList->dwCurrentLocationID)
        {
            break;
        }
        pEntry = (PLOCATION)((LPBYTE)pEntry + pEntry->dwUsedSize);
    }
    if (dw >= pLocationList->dwNumLocationsInList)
    {
        hr = E_INVALIDARG;
        goto ExitHere;
    }

    hr = (HRESULT) WriteLocations (
        pLocationList, 
        CHANGEDFLAGS_CURLOCATIONCHANGED
        );

ExitHere:
    return hr;
}

extern "C"
DWORD APIENTRY
internalNewLocationW(
    IN WCHAR* pszName )

{
    LONG            lResult = 0;

    CLocation       *pLocation = NULL; 
    CLocation       *pNewLocation = NULL;
    CAreaCodeRule   *pAreaCodeRule = NULL;
    CAreaCodeRule   *pNewRule = NULL;
        
    // Validate    
    if (!pszName || lstrlenW( pszName ) > MAXLEN_NAME)
        return LINEERR_INVALPARAM;

    // Read the current location
    lResult = CreateCurrentLocationObject(&pLocation,0,0,0,0);
    if(FAILED(lResult))
    {
        //lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
        return lResult;
    }

    // Create the new object
    pNewLocation = new CLocation();
    if(pNewLocation==NULL)
    {
        delete pLocation;
        LOG((TL_ERROR, "Cannot allocate a CLocation object"));
        return LINEERR_NOMEM;
    }
    // Clone the location (w/o the ID)
    lResult = pNewLocation->Initialize( pszName,
                                        pLocation->GetAreaCode(),
                                        pLocation->GetLongDistanceCarrierCode(),
                                        pLocation->GetInternationalCarrierCode(),
                                        pLocation->GetLongDistanceAccessCode(),
                                        pLocation->GetLocalAccessCode(),
                                        pLocation->GetDisableCallWaitingCode(),
                                        0,
                                        pLocation->GetCountryID(),
                                        pLocation->GetPreferredCardID(),
                                        (pLocation->HasCallingCard() ? LOCATION_USECALLINGCARD : 0) |
                                        (pLocation->HasCallWaiting() ? LOCATION_HASCALLWAITING : 0) |
                                        (pLocation->HasToneDialing() ? LOCATION_USETONEDIALING : 0) ,
                                        FALSE);
    if(FAILED(lResult))
    {
        delete pLocation;
        delete pNewLocation;
        lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
        return lResult;
    }

    // Set the ID
    lResult = pNewLocation->NewID();
    if(FAILED(lResult))
    {
        delete pLocation;
        delete pNewLocation;
        lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
        return lResult;
    }
    // Copy the area code rules
    pLocation->ResetRules();
    while(S_OK == pLocation->NextRule(1, &pAreaCodeRule, NULL))
    {    
        pNewRule = new CAreaCodeRule;
        pNewRule->Initialize(pAreaCodeRule->GetAreaCode(),
                             pAreaCodeRule->GetNumberToDial(),
                             pAreaCodeRule->GetOptions(),
                             pAreaCodeRule->GetPrefixList(),
                             pAreaCodeRule->GetPrefixListSize()
                            );
        pNewLocation->AddRule(pNewRule);
    }

    // Save the new location
    lResult = pNewLocation->WriteToRegistry();
    if(FAILED(lResult))
    {
        delete pLocation;
        delete pNewLocation;
        lResult = lResult==E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
        return lResult;
    }
    
    delete pLocation;

    delete pNewLocation;

    return 0;
}



//***************************************************************************
extern "C"
DWORD APIENTRY
internalRemoveLocation(
    IN DWORD dwID )
{
    CLocations *pLocationList = NULL;
    DWORD       dwCurID;

    HRESULT         Result;

    LOG((TL_TRACE, "Entering internalRemoveLocation"));
    LOG((TL_INFO, "   dwID=0x%d", dwID));

    // Read the location list
    pLocationList = new CLocations();
    if(pLocationList==NULL)
    { 
        LOG((TL_ERROR, "Cannot allocate a CLocations object"));
        return LINEERR_NOMEM;
    }

    Result = pLocationList->Initialize();
    if(FAILED(Result))
    {
        delete pLocationList;
        LOG((TL_ERROR, "CLocations.Initialize() failed - HRESULT=0x%08lx", Result));
        return Result == E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_INIFILECORRUPT;
    }

    // Cannot delete the last location
    if(pLocationList->GetNumLocations() <2)
    {
        delete pLocationList;
        return LINEERR_INVALPARAM;
    }

    // If we're deleting the current location make the first location the
    //    current location, or if we're deleting the first the second.
    dwCurID = pLocationList->GetCurrentLocationID();

    if(dwCurID==dwID)
    {
        CLocation   *pLocation;
        // find the first location
        pLocationList->Reset();
        pLocationList->Next(1, &pLocation, NULL);
        
        // are we deleting the first
        if(pLocation->GetLocationID()==dwID)
            // try the second
            pLocationList->Next(1, &pLocation, NULL);
        
        // change the current location
        pLocationList->SetCurrentLocationID(pLocation->GetLocationID());
    }

    // Delete the location
    pLocationList->Remove(dwID);

    // Save
    Result = pLocationList->SaveToRegistry();
    if(FAILED(Result))
    {
        delete pLocationList;
        LOG((TL_ERROR, "CLocations.SaveToRegistry() failed - HRESULT=0x%08lx", Result));
        return Result == E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
    }

    delete pLocationList;

    return 0;
    
}



//***************************************************************************
extern "C"
DWORD APIENTRY
internalRenameLocationW(
    IN WCHAR* pszOldName,
    IN WCHAR* pszNewName )
{

    CLocations      *pLocationList;
    CLocation       *pLocation;

    HRESULT         Result;
    DWORD           dwError;

    // Test the arguments
    if(!pszOldName || !pszNewName || wcslen(pszNewName) > MAXLEN_NAME)
        return LINEERR_INVALPARAM;

    // Read the locations
    pLocationList = new CLocations();
    if(pLocationList==NULL)
    { 
        LOG((TL_ERROR, "Cannot allocate a CLocations object"));
        return LINEERR_NOMEM;
    }

    Result = pLocationList->Initialize();
    if(FAILED(Result))
    {
        delete pLocationList;
        LOG((TL_ERROR, "CLocations.Initialize() failed - HRESULT=0x%08lx", Result));
        return Result == E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_INIFILECORRUPT;
    }

    // find the specified location
    dwError = LINEERR_INVALPARAM;   // skeptical approach
    pLocationList->Reset();
    while(pLocationList->Next(1, &pLocation, NULL)==S_OK)
    {
        if(wcscmp(pLocation->GetName(), pszOldName)==0)
        {
            // found it, change it
            Result = pLocation->SetName(pszNewName);
            if(FAILED(Result))
            {
                delete pLocationList;
                LOG((TL_ERROR, "CLocations.SetName(Name) failed - HRESULT=0x%08lx", Result));
                return Result == E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
            }
            // save
            Result = pLocationList->SaveToRegistry();
            if(FAILED(Result))
            {
                delete pLocationList;
                LOG((TL_ERROR, "CLocations.SetName(Name) failed - HRESULT=0x%08lx", Result));
                return Result == E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
            }
            
            dwError = 0;

            break;
        }
    }

    delete pLocationList;

    return dwError;

}

#endif // !NORASPRIVATES



//***************************************************************************
//
//  Helper functions
//
//***************************************************************************

LONG BreakupCanonicalW( PWSTR  pAddressIn,
                        PWSTR  *pCountry,
                        PWSTR  *pCity,
                        PWSTR  *pSubscriber
                        )
{
    LONG  lResult = 0;
    PWSTR pCountryEnd;
    PWSTR pAreaEnd;


    //
    // Get past any (illegal) leading spaces
    //
    while ( *pAddressIn == L' ' )
    {
        pAddressIn++;
    }


    //
    // Leading zeros are very bad.  Don't allow them.
    // We're now at the first non-space.  Better not be a '0'.
    //
    if ( *pAddressIn == L'0' )
    {
        //
        // There are leading zeros!
        //
        LOG((TL_ERROR, "   Canonical numbers are not allowed to have leading zeros"));
        lResult = LINEERR_INVALADDRESS;
        goto cleanup;
    }


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    //
    // Parse the canonical number into its component pieces
    //

    //
    // Do country first
    //
    *pCountry = pAddressIn;

    // At least one digit must be present
    if(!(iswdigit(*pAddressIn)))
    {
        LOG((TL_ERROR, "   Canonical numbers must have a valid country code"));
        lResult = LINEERR_INVALADDRESS;
        goto cleanup;
    }

    //
    // Now get to past this
    //
    while (iswdigit(*pAddressIn) )
    {
          pAddressIn++;
    }

    // Save the end of the country code 
    pCountryEnd = pAddressIn;

    //
    // We hit something that's not a digit...
    // There must be only one space here, but we allow any number of spaces (including none)
    //
    while (*pAddressIn == L' ')
    {
        pAddressIn++;
    }

    // Test the area code delimiter
    if ( *pAddressIn == L'(')
    {
        pAddressIn++;

        // Skip any illegal spaces
        while (*pAddressIn == L' ')
        {
            pAddressIn++;
        }
/*
        // At least one digit must be present
        if(!(iswdigit(*pAddressIn)))
        {
            LOG((TL_ERROR, TEXT("   Canonical numbers must have a valid area code between ()")));
            lResult = LINEERR_INVALADDRESS;
            goto cleanup;
        }
*/
        //
        // This must be the beginning of the area code
        //
        *pCity = pAddressIn;

        //
        // Now get to past this
        //
        while (iswdigit(*pAddressIn) )
        {
            pAddressIn++;
        }

        // Save the end pointer
        pAreaEnd = pAddressIn;

        // Skip any illegal spaces
        while (*pAddressIn == L' ')
        {
            pAddressIn++;
        }

        if(*pAddressIn != L')')
        {
            LOG((TL_ERROR, "   Canonical numbers must have a ')' after the area code"));
            lResult = LINEERR_INVALADDRESS;
            goto cleanup;
        }

        pAddressIn++;

        *pAreaEnd = L'\0';

        // Return the same NULL string for an empty area code
        if(*pCity == pAreaEnd)
            *pCity = NULL;
        
    }
    else
    {
        // there's no area code
        *pCity = NULL;

    }

    // Skip spaces
    while (*pAddressIn == L' ')
    {
        pAddressIn++;
    }

    *pCountryEnd = L'\0';

    //
    // Nothing left to do but put the icing on the cake
    //
    *pSubscriber = pAddressIn;

    if (
        TAPIIsBadStringPtrW( *pSubscriber, 512 )
       ||
        lstrlenW( *pSubscriber ) == 0
       )
    {
        //
        // Obviously not canonical
        //
        LOG((TL_ERROR, "   Canonical numbers must have a subscriber number"));
        lResult = LINEERR_INVALADDRESS;
        goto cleanup;
    }


cleanup:

    return lResult;
}


static void LayDownString( PCWSTR   pInString,
                           PBYTE     pBuffer,
                           PBYTE     *ppCurrentIndex,
                           PDWORD   pPair,     // this is the Len & Offset pair
                           BOOL     bUnicode,
                           PBYTE    pFirstByteAfter
                         )
{

#define LDS_FAST_BUF_SIZE 48

    DWORD   dwLength;
    PSTR    pTempString = NULL;
    char    achFastBuf[LDS_FAST_BUF_SIZE];
 
    if(bUnicode)
    {
        dwLength = (lstrlenW( pInString ) + 1)*sizeof(WCHAR);
    }
    else
    {


        dwLength = WideCharToMultiByte(
                        GetACP(),
                        0,
                        pInString,
                        -1,
                        NULL,
                        0,
                        NULL,
                        NULL
                      );

        if (dwLength == 0)
        {
            return;
        }


    }

    
    // Make sure we're starting on some boundary
    //
    *ppCurrentIndex = (PBYTE) (((ULONG_PTR)( *ppCurrentIndex + TALIGN_COUNT))  &  (~TALIGN_COUNT));

    if(*ppCurrentIndex + dwLength <= pFirstByteAfter)
    {
        pPair[0] = dwLength;
        pPair[1] = (DWORD)(*ppCurrentIndex - pBuffer);

        if(bUnicode)
        {
            wcscpy( (PWSTR)*ppCurrentIndex, pInString );
        }
        else
        {
            //
            // Get some space in which to convert Unicode to local
            //
            pTempString = (dwLength > LDS_FAST_BUF_SIZE ?
                (PSTR)ClientAlloc (dwLength) : (PSTR) achFastBuf);


            if ( !pTempString )
            {
                pPair[0] = 0;
                pPair[1] = 0;
                return;
            }

            WideCharToMultiByte(
                               GetACP(),
                               0,
                               pInString,
                               -1,
                               pTempString,
                               dwLength,
                               NULL,
                               NULL
                             );

            lstrcpyA( (PSTR)*ppCurrentIndex, pTempString );

            if (pTempString != (PSTR) achFastBuf)
            {
                ClientFree (pTempString);
            }
        }
    }
    
    *ppCurrentIndex += dwLength;

}

static PWSTR    CopyStringWithExpandJAndK(PWSTR pszRule, PWSTR pszAccessNr, PWSTR pszAccountNr)
{
    DWORD   dwLength=0;
    PWSTR   pResult = NULL;

    PWCHAR  pCrt, pOut;
    WCHAR   c;

    DWORD   dwAccessNrLen, dwAccountNrLen;

    dwAccessNrLen = wcslen(pszAccessNr);
    dwAccountNrLen = wcslen(pszAccountNr);

    // Find the space to alloc
    pCrt = pszRule;
    
    while(*pCrt)
    {
        c = *pCrt++;

        if(c == L'J' || c == L'j')
        {
            dwLength += dwAccessNrLen;
        }
        else if (c == L'K' || c == L'k')
        {
            dwLength += dwAccountNrLen;
        }
        else
            dwLength++;
    }
    // WCHARs and NULL term
    dwLength = (dwLength+1)*sizeof(WCHAR);

    // Alloc
    pResult = (PWSTR)ClientAlloc(dwLength); // allocates zeroed memory
    if(pResult == NULL)
        return NULL;

    // Create result
    pCrt = pszRule;
    pOut = pResult;

    while(*pCrt)
    {
        c = *pCrt++;

        if(c == L'J' || c == L'j')
        {
            wcscat(pOut, pszAccessNr);
            pOut += dwAccessNrLen;
        }
        else if (c == L'K' || c == L'k')
        {
            wcscat(pOut, pszAccountNr);
            pOut += dwAccountNrLen;
        }
        else
            *pOut++ = c;
    }
 
    return pResult;
}


static  void   LayDownTollList(CLocation *pLocation,
                           PBYTE     pBuffer,
                           PBYTE     *ppCurrentIndex,
                           PDWORD   pPair, 
                           BOOL     bUnicode,
                           PBYTE    pFirstByteAfter
                         )
{
    DWORD   dwLength;
    DWORD   dwTotalLength;
    DWORD   dwListLength;
    PBYTE   pDest;
    AreaCodeRulePtrNode     *pNode;
    PWSTR   pszLocationAreaCode;
    DWORD   dwCountryCode;
    BOOL    bFirst;
    CAreaCodeRule           *pRule;
    DWORD   dwIndex;


    pszLocationAreaCode = pLocation->GetAreaCode();
    dwCountryCode = pLocation->GetCountryCode();

    // Make sure we're starting on some boundary
    //
    *ppCurrentIndex = (PBYTE) (((ULONG_PTR)( *ppCurrentIndex + TALIGN_COUNT ))  &  (~TALIGN_COUNT));

    // Save the destination pointer
    pDest = *ppCurrentIndex;

    bFirst = TRUE;
    dwTotalLength = 0;

    // Only for US, Canada, Antigua etc.
    if(pLocation->GetCountryCode() == 1)
    {
        // Find all rules which could be considered toll rules
        pNode = pLocation->m_AreaCodeRuleList.head();

        while( !pNode->beyond_tail() )
        {
        
            pRule = pNode->value();

            if( IsATollListAreaCodeRule(pRule, pszLocationAreaCode)) 
            {
                // Get the size of the prefixes, in bytes
                dwListLength = pRule->GetPrefixListSize();

                if(bUnicode)
                {
                    WCHAR   *pCrt;
                    WCHAR   *pOut;
                    // we strip the last two nulls
                    dwLength = dwListLength - 2*sizeof(WCHAR);
                    // if this is not the first rule, a comma should be added
                    if(!bFirst)
                        dwLength += sizeof(WCHAR);
                    
                    dwTotalLength += dwLength;

                    // we have to convert the single nulls in commas
                    if(*ppCurrentIndex + dwLength  <= pFirstByteAfter)
                    {
                        
                        if(!bFirst)
                        {
                            *(WCHAR *)(*ppCurrentIndex) = L',';
                            *ppCurrentIndex += sizeof(WCHAR);
                        }

                        pCrt = pRule->GetPrefixList();

                        dwListLength /= sizeof(WCHAR);
                        dwListLength--;
                        dwListLength--;
                        // now dwListLength is the length in characters without the two ending nulls
                        // replace nulls with commas
                        for (dwIndex =0; dwIndex<dwListLength; dwIndex++)
                        {
                            if(*pCrt)
                                *(WCHAR *)(*ppCurrentIndex) = *pCrt;
                            else
                                *(WCHAR *)(*ppCurrentIndex) = L',';
                            pCrt++;
                            *ppCurrentIndex += sizeof(WCHAR);
                        }
                    }

                }
                else
                {
                    WCHAR   *pList;
                    
                    dwListLength /= sizeof(WCHAR);
                    dwListLength--;
                    dwListLength--;
                    // now dwListLength is the length in characters without the two ending nulls


                    // Length needed
                    pList = pRule->GetPrefixList();
                    dwLength = WideCharToMultiByte(
                                        GetACP(),
                                        0,
                                        pList,
                                        dwListLength,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL
                                        );

                    // if this is not the first rule, a comma should be added
                    if(!bFirst)
                        dwLength+=sizeof(CHAR);
                    
                    dwTotalLength += dwLength;

                    if(*ppCurrentIndex + dwLength  <= pFirstByteAfter)
                    {
                     
                        if(!bFirst)
                        {
                            *(CHAR *)(*ppCurrentIndex) = ',';
                            *ppCurrentIndex += sizeof(CHAR);

                            dwLength-=sizeof(CHAR); // temporary - the conversion and the null filling routines
                                                    // should'nt take into account the space for the separating comma

                        }
                        
                        // convert
                        WideCharToMultiByte(GetACP(),
                                            0,
                                            pList,
                                            dwListLength,
                                            (PSTR)(*ppCurrentIndex),
                                            dwLength,
                                            NULL,
                                            NULL
                                            );
                       
                        // Replace inplace the nulls with commas
                                           
                        for (dwIndex =0; dwIndex<dwLength; dwIndex++)
                        {
                            if(*(CHAR *)(*ppCurrentIndex)=='\0')
                                    *(CHAR *)(*ppCurrentIndex) = ',';

                            *ppCurrentIndex += sizeof(CHAR);
                        }

                        if(!bFirst)
                            dwLength+=sizeof(CHAR); // restore

                    }

                }

                bFirst = FALSE;
            }

            pNode = pNode->next();
        }

    }

    // space for a terminating NULL
    dwLength = bUnicode ? sizeof(WCHAR) : 1;
    
    dwTotalLength += dwLength;

    if(*ppCurrentIndex + dwLength <= pFirstByteAfter)
    {
        if(bUnicode)    
            *(WCHAR *)(*ppCurrentIndex) = L'\0';
        else
            *(CHAR *)(*ppCurrentIndex) = '\0';

        *ppCurrentIndex += dwLength;
        
        pPair[0] = (DWORD)(*ppCurrentIndex - pDest);
        pPair[1] = (DWORD)(pDest - pBuffer);
    }

    // Update the current pointer whatever the buffer size is
    *ppCurrentIndex = pDest + dwTotalLength;

}




static LONG
GetTranslateCapsCommon(
    HLINEAPP            hLineApp,
    DWORD               dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps,
    BOOL                bUnicode
    )
{

    LONG                lResult = 0; // good for HRESULTs too
    CLocations          *pLocationList = NULL; 
    CCallingCards       *pCardList = NULL;
    
    DWORD               dwNumLocations;
    DWORD               dwNumCards;

    DWORD               dwLenChar;

    CCallingCard        *pCard = NULL;
    CLocation           *pLocation;

    DWORD               dwTotalSize;
    DWORD               dwFinalSize;
    DWORD               dwLocationsSize;
    DWORD               dwLocationsStart;
    DWORD               dwCardsSize;
    DWORD               dwCardsStart;

    DWORD               dwCurrentLocationID;
    DWORD               dwPreferredCardID;
    DWORD               dwTempCardID;

    BOOL                bOldTapi;
    BOOL                bBufferTooSmall;

    LINELOCATIONENTRY   *pLineLocationEntry;
    LINECARDENTRY       *pLineCardEntry;
    PBYTE               pCurrentIndex;
    PBYTE               pCurrentIndexSave;
    PBYTE               pFirstByteAfter;

    DWORD               dwLocEntryLength;
    DWORD               dwCardEntryLength;

    DWORD               dwIndex;
    DWORD               dwAlignOffset;
    PLOCATIONLIST       pLocTest;


    lResult = IsThisAPIVersionInvalid( dwAPIVersion );
    if ( lResult )
    {
       LOG((TL_ERROR, "Bad dwAPIVersion - 0x%08lx", dwAPIVersion));
       return lResult;
    }

    if ( IsBadWritePtr(lpTranslateCaps, sizeof(DWORD)*3) )
    {
        LOG((TL_ERROR, "lpTranslateCaps not a valid pointer"));
        return LINEERR_INVALPOINTER;
    }

    if ( IsBadWritePtr(lpTranslateCaps, lpTranslateCaps->dwTotalSize) )
    {
        LOG((TL_ERROR, "lpTranslateCaps not a valid pointer (dwTotalSize)"));
        return LINEERR_INVALPOINTER;
    }

    LOG((TL_INFO, "lpTranslateCaps->dwTotalSize = %d",lpTranslateCaps->dwTotalSize));

    if ( lpTranslateCaps->dwTotalSize < sizeof(LINETRANSLATECAPS))
    {
        LOG((TL_ERROR, "Not even enough room for the fixed portion"));
        return LINEERR_STRUCTURETOOSMALL;
    }

    // Let TAPISRV test the params for us
    lResult = ReadLocations(&pLocTest,
                            hLineApp,
                            0,
                            dwAPIVersion,
                            CHECKPARMS_DWHLINEAPP|
                            CHECKPARMS_DWAPIVERSION|
                            CHECKPARMS_ONLY);

    if (pLocTest != NULL)
    {
        ClientFree( pLocTest);
    }
    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    // Read the location list
    pLocationList = new CLocations();
    if(pLocationList==NULL)
    {
        LOG((TL_ERROR, "Cannot allocate a CLocations object"));
        return LINEERR_NOMEM;
    }

    lResult = pLocationList->Initialize();
    if(lResult != ERROR_SUCCESS)
    {
        delete pLocationList;
        LOG((TL_ERROR, "CLocations.Initialize() failed - HRESULT=0x%08lx", lResult));
        return lResult == E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_INIFILECORRUPT;
    }

    // Read the calling card list
    pCardList = new CCallingCards();
    if(pCardList==NULL)
    {
        delete pLocationList;
        LOG((TL_ERROR, "Cannot allocate a CCallingCards object"));
        return LINEERR_NOMEM;
    }

    lResult = pCardList->Initialize();
    if(lResult != ERROR_SUCCESS)
    {
        delete pCardList;
        delete pLocationList;
        LOG((TL_ERROR, "CCallingCards.Initialize() failed - HRESULT=0x%08lx", lResult));
        return lResult == E_OUTOFMEMORY ? LINEERR_NOMEM : LINEERR_OPERATIONFAILED;
    }

    // The char length in bytes depends on bUnicode
    dwLenChar = bUnicode ? sizeof(WCHAR) : sizeof(CHAR);
    // The structures for TAPI<=1.3 ar smaller
    bOldTapi = (dwAPIVersion<0x00010004);

    dwLocEntryLength = (DWORD)(bOldTapi ? 7*sizeof(DWORD) : sizeof(LINELOCATIONENTRY));
    dwCardEntryLength = (DWORD)(bOldTapi ? 3*sizeof(DWORD) : sizeof(LINECARDENTRY));

    dwNumLocations = pLocationList->GetNumLocations();
    dwNumCards = pCardList->GetNumCards();

    dwCurrentLocationID = pLocationList->GetCurrentLocationID();
    dwPreferredCardID = 0;
    // Size provided by the caller  
    dwTotalSize = lpTranslateCaps->dwTotalSize;
    // First byte after the buffer provided by the caller
    pFirstByteAfter = (PBYTE)lpTranslateCaps + dwTotalSize;
    bBufferTooSmall = FALSE;

    dwLocationsStart = sizeof(LINETRANSLATECAPS);
    // The size of the locations part
    dwLocationsSize = dwNumLocations * dwLocEntryLength;
    // The strings included in locations are stored after the array of LINELOCATIONENTRY structures
    pCurrentIndex = ((PBYTE)lpTranslateCaps)+
                        dwLocationsStart + 
                        dwLocationsSize;

    // do the first pointer alignment here. This initial offset will help at the end
    pCurrentIndexSave = pCurrentIndex;
    pCurrentIndex = (PBYTE) (((ULONG_PTR)( pCurrentIndex + TALIGN_COUNT ))  &  (~TALIGN_COUNT));
    dwAlignOffset = (DWORD)(pCurrentIndex - pCurrentIndexSave);

    // Test the space for the array
    if(pCurrentIndex > pFirstByteAfter)
        bBufferTooSmall = TRUE;

    // First, process the locations
    pLocationList->Reset();
    dwIndex = 0;
    while(S_OK==pLocationList->Next(1, &pLocation, NULL))
    {
        pLineLocationEntry = (LINELOCATIONENTRY *)(((PBYTE)lpTranslateCaps)+dwLocationsStart+dwIndex*dwLocEntryLength);
        
        // string values
        LayDownString(  pLocation->GetName(),
                        (PBYTE)lpTranslateCaps,
                        &pCurrentIndex,
                        &pLineLocationEntry->dwLocationNameSize,
                        bUnicode,
                        pFirstByteAfter
                        );
        
        LayDownString(  pLocation->GetAreaCode(),
                        (PBYTE)lpTranslateCaps,
                        &pCurrentIndex,
                        &pLineLocationEntry->dwCityCodeSize,
                        bUnicode,
                        pFirstByteAfter
                        );

        
        if(!bOldTapi)
        {
            LayDownString(  pLocation->GetLocalAccessCode(),
                            (PBYTE)lpTranslateCaps,
                            &pCurrentIndex,
                            &pLineLocationEntry->dwLocalAccessCodeSize,
                            bUnicode,
                            pFirstByteAfter
                            );

            LayDownString(  pLocation->GetLongDistanceAccessCode(),
                            (PBYTE)lpTranslateCaps,
                            &pCurrentIndex,
                            &pLineLocationEntry->dwLongDistanceAccessCodeSize,
                            bUnicode,
                            pFirstByteAfter
                            );
            // Toll list
            LayDownTollList(pLocation,
                            (PBYTE)lpTranslateCaps,
                            &pCurrentIndex,
                            &pLineLocationEntry->dwTollPrefixListSize,
                            bUnicode,
                            pFirstByteAfter
                            );

            LayDownString(  pLocation->GetDisableCallWaitingCode(),
                            (PBYTE)lpTranslateCaps,
                            &pCurrentIndex,
                            &pLineLocationEntry->dwCancelCallWaitingSize,
                            bUnicode,
                            pFirstByteAfter
                            );

        }

        if(pLocation->HasCallingCard())
        {
           dwTempCardID = pLocation->GetPreferredCardID();
            // Extract the preferred calling card if current location
            if(pLocation->GetLocationID() == dwCurrentLocationID)
                dwPreferredCardID = dwTempCardID;
        }
        else
            dwTempCardID =0;
   
        //Other non string values
        if(!bBufferTooSmall)
        {
            
            pLineLocationEntry->dwPermanentLocationID = pLocation->GetLocationID();
            
            pLineLocationEntry->dwPreferredCardID = dwTempCardID;

            pLineLocationEntry->dwCountryCode = pLocation->GetCountryCode();

            if(!bOldTapi)
            {
                pLineLocationEntry->dwCountryID = pLocation->GetCountryID();
                pLineLocationEntry->dwOptions = pLocation->HasToneDialing() ? 0 : LINELOCATIONOPTION_PULSEDIAL;
            }
        }

        dwIndex++;
    }

    // Align the pointer
    pCurrentIndex = (PBYTE) (((ULONG_PTR)( pCurrentIndex + TALIGN_COUNT ))  &  (~TALIGN_COUNT));

    // Process the cards
    dwCardsStart = (DWORD)(pCurrentIndex - ((PBYTE)lpTranslateCaps));
    // The size of the cards part
    dwCardsSize = dwCardEntryLength * dwNumCards;

    pCurrentIndex += dwCardsSize;
    // Test the space for the array
    if(pCurrentIndex > pFirstByteAfter)
        bBufferTooSmall = TRUE;

    // including the hidden cards
    pCardList->Reset(TRUE);
    dwIndex = 0;
    while(S_OK==pCardList->Next(1, &pCard, NULL))
    {
        PWSTR   pszTemp = NULL;
        
        pLineCardEntry = (LINECARDENTRY *)(((PBYTE)lpTranslateCaps)+dwCardsStart+dwIndex*dwCardEntryLength);
        
        // String values
        LayDownString(  pCard->GetCardName(),
                        (PBYTE)lpTranslateCaps,
                        &pCurrentIndex,
                        &pLineCardEntry->dwCardNameSize,
                        bUnicode,
                        pFirstByteAfter
                        );
        if(!bOldTapi)
        {
            // Convert rules to old format (w/o J and K spec)    
            pszTemp = CopyStringWithExpandJAndK(pCard->GetLocalRule(), 
                                                pCard->GetLocalAccessNumber(),
                                                pCard->GetAccountNumber());
            if(pszTemp==NULL)
            {
                delete pCardList;
                delete pLocationList;
                LOG((TL_ERROR, "CopyStringWithExpandJAndK failed to allocate memory"));
                return LINEERR_NOMEM;
            }

            LayDownString(  pszTemp,
                            (PBYTE)lpTranslateCaps,
                            &pCurrentIndex,
                            &pLineCardEntry->dwSameAreaRuleSize,
                            bUnicode,
                            pFirstByteAfter
                            );

            ClientFree(pszTemp);

            LOG((TL_INFO, "About to do CopyStringWithExpandJAndK"));
            pszTemp = CopyStringWithExpandJAndK(   pCard->GetLongDistanceRule(),
                                                   pCard->GetLongDistanceAccessNumber(),
                                                   pCard->GetAccountNumber() );
            LOG((TL_INFO, "Did CopyStringWithExpandJAndK"));

            if(pszTemp==NULL)
            {
                delete pCardList;
                delete pLocationList;
                LOG((TL_ERROR, "CopyStringWithExpandJAndK failed to allocate memory"));
                return LINEERR_NOMEM;
            }

            LayDownString(  pszTemp,
                            (PBYTE)lpTranslateCaps,
                            &pCurrentIndex,
                            &pLineCardEntry->dwLongDistanceRuleSize,
                            bUnicode,
                            pFirstByteAfter
                            );

            ClientFree(pszTemp);
           
            pszTemp = CopyStringWithExpandJAndK(pCard->GetInternationalRule(),
                                                pCard->GetInternationalAccessNumber(),
                                                pCard->GetAccountNumber());
            if(pszTemp==NULL)
            {
                delete pCardList;
                delete pLocationList;
                LOG((TL_ERROR, "CopyStringWithExpandJAndK failed to allocate memory"));
                return LINEERR_NOMEM;
            }

            LayDownString(  pszTemp,
                            (PBYTE)lpTranslateCaps,
                            &pCurrentIndex,
                            &pLineCardEntry->dwInternationalRuleSize,
                            bUnicode,
                            pFirstByteAfter
                            );
            
            ClientFree(pszTemp);
        }

        // Other non-string fields
        if(!bBufferTooSmall)
        {
            pLineCardEntry->dwPermanentCardID = pCard->GetCardID();

            if(!bOldTapi)
            {
                pLineCardEntry->dwCardNumberDigits = wcslen(pCard->GetPIN());
                pLineCardEntry->dwOptions = (pCard->IsMarkedPermanent() ? LINECARDOPTION_PREDEFINED : 0)
                                          | (pCard->IsMarkedHidden() ?  LINECARDOPTION_HIDDEN : 0);
            }

        }

        dwIndex++;
    }

    dwFinalSize = (DWORD)(pCurrentIndex - (PBYTE)lpTranslateCaps);

    //   Uhh, the goal is to have the same needed size whatever the alignment of the lpTranslateCaps is..
    //   A nongoal is to provide similar returned content (in terms of alignments, pads etc) for 
    // different alignment of lpTranslateCaps
    //   
    dwFinalSize += (TALIGN_COUNT - dwAlignOffset);

    
    if(dwFinalSize>dwTotalSize)
    {
        lpTranslateCaps->dwUsedSize   = sizeof (LINETRANSLATECAPS);
        // Fix for alignment problems
        lpTranslateCaps->dwNeededSize = dwFinalSize;

        ZeroMemory(
            &lpTranslateCaps->dwNumLocations,
            dwTotalSize - 3 * sizeof (DWORD)
            );
        lpTranslateCaps->dwCurrentLocationID = dwCurrentLocationID;
        lpTranslateCaps->dwCurrentPreferredCardID = dwPreferredCardID;

        LOG((TL_ERROR, "Buffer too small"));
        LOG((TL_ERROR, "lpTranslateCaps->dwTotalSize = %d",lpTranslateCaps->dwTotalSize));
        LOG((TL_ERROR, "lpTranslateCaps->dwNeededSize = %d",lpTranslateCaps->dwNeededSize));


    }
    else
    {
        lpTranslateCaps->dwUsedSize   = dwFinalSize;
        lpTranslateCaps->dwNeededSize = dwFinalSize;


        lpTranslateCaps->dwNumLocations = dwNumLocations;
        lpTranslateCaps->dwNumCards = dwNumCards;
        lpTranslateCaps->dwCurrentLocationID = dwCurrentLocationID;

        lpTranslateCaps->dwLocationListOffset = dwLocationsStart;
        lpTranslateCaps->dwLocationListSize = dwLocationsSize;

        lpTranslateCaps->dwCardListOffset = dwCardsStart;
        lpTranslateCaps->dwCardListSize = dwCardsSize;

        lpTranslateCaps->dwCurrentPreferredCardID = dwPreferredCardID;

        LOG((TL_INFO, "Buffer OK"));
        LOG((TL_INFO, "lpTranslateCaps->dwTotalSize = %d",lpTranslateCaps->dwTotalSize));
        LOG((TL_INFO, "lpTranslateCaps->dwNeededSize = %d",lpTranslateCaps->dwNeededSize));
    }

    delete pCardList;
    delete pLocationList;

    return 0;
}


static  BOOL    FindTollPrefixInLocation(CLocation *pLocation,
                                         PWSTR  pPrefix,
                                         CAreaCodeRule **ppRule, 
                                         PWSTR *ppWhere)
{
    BOOL    bPrefixFound = FALSE;
    AreaCodeRulePtrNode     *pNode;
    CAreaCodeRule           *pCrtRule = NULL;
    PWSTR                   pLocationAreaCode;
    PWSTR                   pWhere;

    pLocationAreaCode = pLocation->GetAreaCode();

    // Enumerate the area code rules
    // If a rule is appropriate for a toll list, we search the prefix
    pNode = pLocation->m_AreaCodeRuleList.head();

    while( !pNode->beyond_tail() )
    {
        pCrtRule = pNode->value();

        if(IsATollListAreaCodeRule(pCrtRule, pLocationAreaCode))
        { 
            // Set this even we don't find the prefix.
            // The caller could be interested in the presence of toll rules
            *ppRule = pCrtRule;
            // Try to find the prefix
            pWhere = FindPrefixInMultiSZ(pCrtRule->GetPrefixList(), pPrefix);
            if(pWhere)
            {
                *ppWhere = pWhere;
                return TRUE;
            }

        }
        pNode = pNode->next();
    }

    return FALSE;
}





static BOOL IsATollListAreaCodeRule(CAreaCodeRule *pRule, PWSTR pszLocationAreaCode)
{
    // conditions for toll rules:
    //
    // location.Country code == 1 (to be tested outside) AND
    // Area Code to dial == Current Area Code AND
    // NumberToDial == 1   AND
    // BeforeDialingDialNumberToDial == TRUE AND
    // BeforeDialingDialAreaCode == TRUE AND
    // IncludeAllPrefixesForThisAreaCode == FALSE
    return  pRule->HasDialNumber() 
         && !pRule->HasAppliesToAllPrefixes()
         && pRule->HasDialAreaCode()
         && 0==wcscmp(pszLocationAreaCode, pRule->GetAreaCode()) 
         && 0==wcscmp(pRule->GetNumberToDial(), L"1") 
             ;
}

static PWSTR FindPrefixInMultiSZ(PWSTR pPrefixList, PWSTR pPrefix)
{

    PWSTR   pCrt;
    PWSTR   pListCrt;
    PWSTR   pStart;

    pListCrt = pPrefixList;

    while(TRUE)
    {
        pCrt = pPrefix;
        pStart = pListCrt;

        while(*pCrt == *pListCrt)
        {
            if(!*pCrt)
                // found
                return pStart;

            pCrt++;
            pListCrt++;
        }
        
        while(*pListCrt++);

        if(!*pListCrt)
            // not found
            return NULL;
    }    

}




/****************************************************************************

 Function : CreateCurrentLocationObject

****************************************************************************/
LONG CreateCurrentLocationObject(CLocation **pLocation,
                       HLINEAPP hLineApp,
                       DWORD dwDeviceID,
                       DWORD dwAPIVersion,
                       DWORD dwOptions)
{
    PLOCATIONLIST   pLocationList = NULL;
    
    PLOCATION       pEntry = NULL;
    PWSTR           pszLocationName = NULL;            
    PWSTR           pszAreaCode = NULL;
    PWSTR           pszLongDistanceCarrierCode = NULL;         
    PWSTR           pszInternationalCarrierCode = NULL;         
    PWSTR           pszLocalAccessCode = NULL;         
    PWSTR           pszLongDistanceAccessCode = NULL;  
    PWSTR           pszCancelCallWaitingCode = NULL;   
    DWORD           dwPermanentLocationID = 0;   
    CLocation     * pNewLocation = NULL;
    
    PAREACODERULE   pAreaCodeRuleEntry = NULL;
    PWSTR           pszNumberToDial = NULL;
    PWSTR           pszzPrefixesList = NULL;
    DWORD           dwNumRules = 0; 
    CAreaCodeRule * pAreaCodeRule = NULL;

    DWORD           dwCount = 0;
    DWORD           dwNumEntries = 0;
    DWORD           dwCurrentLocationID = 0;

    HRESULT         hr;

    
    // Let TAPISRV test the params for us
    hr = ReadLocations(&pLocationList,       
                       hLineApp,                   
                       dwDeviceID,                   
                       dwAPIVersion,                  
                       dwOptions      
                      );

    if SUCCEEDED( hr) 
    {
        hr = E_FAIL;  // fail if we don't find the current loc

        // current location
        dwCurrentLocationID  = pLocationList->dwCurrentLocationID;   
         
        // Find position of 1st LOCATION structure in the LOCATIONLIST structure 
        pEntry = (PLOCATION) ((BYTE*)(pLocationList) + pLocationList->dwLocationListOffset );           

        // Number of locations ?
        dwNumEntries =  pLocationList->dwNumLocationsInList;

        // Find the current location
        for (dwCount = 0; dwCount < dwNumEntries ; dwCount++)
        {
    
            if(pEntry->dwPermanentLocationID == dwCurrentLocationID)
            {
                hr = S_OK;
                break;
            }

            // Try next location in list
            //pEntry++;
            pEntry = (PLOCATION) ((BYTE*)(pEntry) + pEntry->dwUsedSize);           

        }
        if SUCCEEDED( hr) 
        {
            LOG((TL_INFO, "CreateCurrentLocationObject - current location found %d",
                    dwCurrentLocationID));

            // Pull Location Info out of LOCATION structure
            pszLocationName           = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwLocationNameOffset);
            pszAreaCode               = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwAreaCodeOffset);
            pszLongDistanceCarrierCode= (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwLongDistanceCarrierCodeOffset);
            pszInternationalCarrierCode= (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwInternationalCarrierCodeOffset);
            pszLocalAccessCode        = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwLocalAccessCodeOffset);
            pszLongDistanceAccessCode = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwLongDistanceAccessCodeOffset);
            pszCancelCallWaitingCode  = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwCancelCallWaitingOffset);
        
        
            // create our new Location Object                
            pNewLocation = new CLocation;
            if (pNewLocation)
            {
                // initialize the new Location Object
                hr = pNewLocation->Initialize(
                                            pszLocationName, 
                                            pszAreaCode,
                                            pszLongDistanceCarrierCode,
                                            pszInternationalCarrierCode,
                                            pszLongDistanceAccessCode, 
                                            pszLocalAccessCode, 
                                            pszCancelCallWaitingCode , 
                                            pEntry->dwPermanentLocationID,
                                            pEntry->dwCountryID,
                                            pEntry->dwPreferredCardID,
                                            pEntry->dwOptions
                                            );
                    
                if( SUCCEEDED(hr) )
                {
                    // Find position of 1st AREACODERULE structure in the LOCATIONLIST structure 
                    pAreaCodeRuleEntry = (PAREACODERULE) ((BYTE*)(pEntry) 
                                                          + pEntry->dwAreaCodeRulesListOffset );           
                   
                    dwNumRules = pEntry->dwNumAreaCodeRules;           
                
                    for (dwCount = 0; dwCount != dwNumRules; dwCount++)
                    {
                        // Pull Rule Info out of AREACODERULE structure
                        pszAreaCode      = (PWSTR) ((BYTE*)(pEntry) 
                                                    + pAreaCodeRuleEntry->dwAreaCodeOffset);
                        pszNumberToDial  = (PWSTR) ((BYTE*)(pEntry) 
                                                    + pAreaCodeRuleEntry->dwNumberToDialOffset);
                        pszzPrefixesList = (PWSTR) ((BYTE*)(pEntry) 
                                                    + pAreaCodeRuleEntry->dwPrefixesListOffset);
        
                        // create our new AreaCodeRule Object                
                        pAreaCodeRule = new CAreaCodeRule;
                        if (pAreaCodeRule)
                        {
                            // initialize the new AreaCodeRule Object
                            hr = pAreaCodeRule->Initialize ( pszAreaCode,
                                                             pszNumberToDial,
                                                             pAreaCodeRuleEntry->dwOptions,
                                                             pszzPrefixesList, 
                                                             pAreaCodeRuleEntry->dwPrefixesListSize
                                                           );
                            if( SUCCEEDED(hr) )
                            {
                                pNewLocation->AddRule(pAreaCodeRule);
                            }
                            else // rule initialization failed
                            {
                                delete pAreaCodeRule;
                                LOG((TL_ERROR, "CreateCurrentLocationObject - rule create failed"));
                            }
                        } 
                        else // new CAreaCodeRule failed
                        {
                            LOG((TL_ERROR, "CreateCurrentLocationObject - rule create failed"));
                        }
    
                        // Try next rule in list
                        pAreaCodeRuleEntry++;
                        
                    }
                }
                else // location initialize failed
                {
                    delete pNewLocation;
                    pNewLocation = NULL;
    
                    LOG((TL_ERROR, "CreateCurrentLocationObject - location create failed"));
                    hr =LINEERR_OPERATIONFAILED;
                    // hr = E_FAIL;
                }
            }
            else // new CLocation failed
            {
                LOG((TL_ERROR, "CreateCurrentLocationObject - location create failed"));
                hr = LINEERR_NOMEM;
                //hr = E_OUTOFMEMORY;
    
            }
        }
        else
        {
            LOG((TL_ERROR, "CreateCurrentLocationObject - current location not found"));
            hr =LINEERR_OPERATIONFAILED;
            //hr = E_FAIL;
        }
    }
    else // ReadLocations failed
    {
        LOG((TL_ERROR, "CreateCurrentLocationObject - ReadLocation create failed"));
        // hr = E_FAIL;
    }

    // finished with TAPI memory block so release
    if ( pLocationList != NULL )
            ClientFree( pLocationList );


    *pLocation = pNewLocation;
    return hr;
}    



/****************************************************************************

 Function : CreateCountryObject

****************************************************************************/

HRESULT CreateCountryObject(DWORD dwCountryID, CCountry **ppCountry)
{
    LPLINECOUNTRYLIST_INTERNAL   pCountryList = NULL;
    
    LPLINECOUNTRYENTRY_INTERNAL  pEntry = NULL;
    PWSTR               pszCountryName = NULL;          
    PWSTR               pszInternationalRule = NULL;     
    PWSTR               pszLongDistanceRule = NULL;     
    PWSTR               pszLocalRule = NULL;            
    CCountry          * pCountry = NULL;
    
    DWORD               dwCount = 0;
    DWORD               dwNumEntries = 0;
    LONG                lResult;
    HRESULT             hr;
    


    lResult = ReadCountriesAndGroups( &pCountryList, dwCountryID, 0);
    if (lResult == 0) 
    {
         
        // Find position of 1st LINECOUNTRYENTRY structure in the LINECOUNTRYLIST structure 
        pEntry = (LPLINECOUNTRYENTRY_INTERNAL) ((BYTE*)(pCountryList) + pCountryList->dwCountryListOffset );           
        // Pull Country Info out of LINECOUNTRYENTRY structure
        pszCountryName       = (PWSTR) ((BYTE*)(pCountryList) 
                                               + pEntry->dwCountryNameOffset);
        pszInternationalRule = (PWSTR) ((BYTE*)(pCountryList) 
                                               + pEntry->dwInternationalRuleOffset);
        pszLongDistanceRule  = (PWSTR) ((BYTE*)(pCountryList) 
                                             + pEntry->dwLongDistanceRuleOffset);
        pszLocalRule         = (PWSTR) ((BYTE*)(pCountryList) 
                                               + pEntry->dwSameAreaRuleOffset);
    
    
        // create our new CCountry Object                
        pCountry = new CCountry;
        if (pCountry)
        {
            // initialize the new CCountry Object
            hr = pCountry->Initialize(pEntry->dwCountryID,
                                      pEntry->dwCountryCode,
                                      pEntry->dwCountryGroup,
                                      pszCountryName,
                                      pszInternationalRule,
                                      pszLongDistanceRule,
                                      pszLocalRule
                                     );

            if( SUCCEEDED(hr) )
            {
                *ppCountry = pCountry;
            }
            else // country initialization failed
            {
                delete pCountry;
                LOG((TL_ERROR, "CreateCountryObject - country create failed"));
            }
        } 
        else // new CCountry failed
        {
            LOG((TL_ERROR, "CreateCountryObject - country create failed"));
        }

    }
    else // ReadLocations failed
    {
        LOG((TL_ERROR, "CreateCountryObject - ReadCountries failed"));
        hr = E_FAIL;
    }

    // finished with TAPI memory block so release
    if ( pCountryList != NULL )
    {
        ClientFree( pCountryList );
    }

    return hr;
    

}    

/****************************************************************************

 Function : ReadLocations

****************************************************************************/
HRESULT ReadLocations( PLOCATIONLIST *ppLocationList,
                       HLINEAPP hLineApp,
                       DWORD dwDeviceID,
                       DWORD dwAPIVersion,
                       DWORD dwOptions
                     )
{
    HRESULT     hr = S_OK;
    long        lResult;
    DWORD       dwSize = sizeof(LOCATIONLIST) + 500;

    
    *ppLocationList = (PLOCATIONLIST) ClientAlloc( dwSize );

    if (NULL == *ppLocationList)
    {
        return E_OUTOFMEMORY;
    }

    (*ppLocationList)->dwTotalSize = dwSize;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 5, tReadLocations),

        {
            (ULONG_PTR)hLineApp,
            (ULONG_PTR)dwDeviceID,
            (ULONG_PTR)dwAPIVersion,
            (ULONG_PTR)dwOptions,
            (ULONG_PTR)*ppLocationList     // (DWORD) pLocationSpace
        },

        {
            hXxxApp_NULLOK,
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    while (TRUE)
    {
        lResult =  (DOFUNC (&funcArgs, "TReadLocations"));
    
        if ((lResult == 0) && ((*ppLocationList)->dwNeededSize > (*ppLocationList)->dwTotalSize))
        {
            // Didn't Work , adjust buffer size & try again    
            LOG((TL_ERROR, "ReadLocations failed - buffer too small"));
            dwSize = (*ppLocationList)->dwNeededSize;
    
            ClientFree( *ppLocationList );
    
            *ppLocationList = (PLOCATIONLIST) ClientAlloc( dwSize );
            if (*ppLocationList == NULL)
            {
                LOG((TL_ERROR, "ReadLocations failed - repeat ClientAlloc failed"));
                hr =  E_OUTOFMEMORY;
                break;
            }
            else
            {
                (*ppLocationList)->dwTotalSize = dwSize;
                funcArgs.Args[4] = (ULONG_PTR)*ppLocationList;
            }
        }
        else
        {
            hr = (HRESULT)lResult;    
            break;
        }
    } // end while(TRUE)

    
    
    return hr;

}

/****************************************************************************

 Function : WriteLocations

****************************************************************************/
    
LONG PASCAL  WriteLocations( PLOCATIONLIST  pLocationList,
                             DWORD      dwChangedFlags
                           )
{
    PSTR     pString;
    UINT  n;
    LONG  lResult;


    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, tWriteLocations),
        {
            (ULONG_PTR)pLocationList->dwNumLocationsInList,
            (ULONG_PTR)dwChangedFlags,
            (ULONG_PTR)pLocationList->dwCurrentLocationID,
            (ULONG_PTR)pLocationList
        },

        {
            Dword,
            Dword,
            Dword,
            lpSet_Struct
        }
    };


    lResult =  (DOFUNC (&funcArgs, "TWriteLocations"));

    return lResult;
}



/****************************************************************************

 Function : ReadCountries

****************************************************************************/
LONG PASCAL ReadCountries( LPLINECOUNTRYLIST *ppLCL,
                           UINT nCountryID,
                           DWORD dwDestCountryID
                         )
{
    LONG lTapiResult;
    UINT nBufSize = 0x8000;   //Start with a buffer of 16K
    UINT n;
    LPLINECOUNTRYLIST pNewLCL;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 4, lGetCountry),

        {
            0,
            TAPI_VERSION_CURRENT,
            (ULONG_PTR)dwDestCountryID,
            0
        },

        {
            Dword,
            Dword,
            Dword,
            lpGet_Struct
        }
    };


    //
    // Try until success or the buffer is huge
    //
    for ( lTapiResult = 1, n = 0;
          lTapiResult && (n < 5);
          n++ )
    {

        pNewLCL = (LPLINECOUNTRYLIST)ClientAlloc( nBufSize );

        if(!pNewLCL)
            return LINEERR_NOMEM;


        pNewLCL->dwTotalSize = nBufSize;


        //
        // Put new values in structure for TAPISRV
        //
        funcArgs.Args[0] = (ULONG_PTR)nCountryID;
        funcArgs.Args[3] = (ULONG_PTR)pNewLCL;


        //
        // Call TAPISRV to get the country list
        //
        lTapiResult =  DOFUNC (&funcArgs, "lineGetCountry");


        //
        // If the call succeeded, but the buffer was too small, or if the
        // call failed, do it again...
        //
        if (
              (lTapiResult == LINEERR_STRUCTURETOOSMALL)
            ||
              (pNewLCL->dwNeededSize > nBufSize)
           )
        {
            //
            // Complain to anyone who'll listen that this should be tuned
            // to start with a larger buffer so we don't have to do this multiple
            // times....
            //
            LOG((TL_ERROR, "  TUNING PROBLEM: We're about to call lineGetCountry()"));
            LOG((TL_ERROR, "                  _again_ because the buffer wasn't big enough"));
            LOG((TL_ERROR, "                  the last time.  FIX THIS!!!  (0x%lx)", nBufSize));


            lTapiResult = 1; // Force error condition if size was bad...
            nBufSize += 0x4000;  // Try a bit bigger
            ClientFree( pNewLCL );
        }
        else
        {
           //
           // We didn't work for some other reason
           //
           break;
        }
    }

    *ppLCL = pNewLCL;

    return lTapiResult;
}

/****************************************************************************

 Function : ReadCountriesAndGroups

****************************************************************************/
LONG PASCAL ReadCountriesAndGroups( LPLINECOUNTRYLIST_INTERNAL *ppLCL,
                           UINT nCountryID,
                           DWORD dwDestCountryID
                         )
{
    LPLINECOUNTRYLIST_INTERNAL  pLCL = NULL;
    LPLINECOUNTRYENTRY_INTERNAL pLCountry;
    LONG                        lResult;
    LPDWORD                     pCountryIDs;
    FUNC_ARGS                   funcArgs =
    {   
        MAKELONG (LINE_FUNC | SYNC | 4, lGetCountryGroup),
        {
            (ULONG_PTR) 0,
            (ULONG_PTR) 0,
            (ULONG_PTR) 0,
            (ULONG_PTR) 0
        },

        {
            lpSet_SizeToFollow,
            Size,
            lpGet_SizeToFollow,
            Size
        }
    };

    //
    // read the countries
    //
    lResult = ReadCountries( (LPLINECOUNTRYLIST *)&pLCL, nCountryID, dwDestCountryID );
    if (lResult)
    {
        LOG((TL_ERROR, "ReadCountriesAndGroups: ReadCountries failed with %d", lResult));
        return lResult;        

    }
    
    //
    // create the array of country IDs
    //
    pCountryIDs = (LPDWORD)ClientAlloc( sizeof(DWORD) * pLCL->dwNumCountries );
    if(!pCountryIDs)
    {
        ClientFree( pLCL );
        return LINEERR_NOMEM;
    }
    
    pLCountry = (LPLINECOUNTRYENTRY_INTERNAL) ((LPBYTE)pLCL + pLCL->dwCountryListOffset);
    for( DWORD dwIdx = 0; dwIdx < pLCL->dwNumCountries; dwIdx++, pLCountry++ )
    {
        *(pCountryIDs + dwIdx) = pLCountry->dwCountryID;
    }
    
    funcArgs.Args[0] = funcArgs.Args[2] = (ULONG_PTR)pCountryIDs;
    funcArgs.Args[1] = funcArgs.Args[3] = (ULONG_PTR)(sizeof(DWORD) * pLCL->dwNumCountries);

    //
    // Call TAPISRV to get the country groups
    // At return pCountryIDs will have the country groups
    //
    lResult =  DOFUNC (&funcArgs, "lineGetCountryGroups");

    if (lResult)
    {
        LOG((TL_TRACE, "ReadCountriesAndGroups: lineGetCountryGroups failed with %d", lResult));
        //
        // consider all the country groups undefined (0)
        //
        memset( pCountryIDs, 0, sizeof(DWORD) * pLCL->dwNumCountries );

        lResult = ERROR_SUCCESS;
    }
    
    pLCountry = (LPLINECOUNTRYENTRY_INTERNAL) ((LPBYTE)pLCL + pLCL->dwCountryListOffset);
    for( DWORD dwIdx = 0; dwIdx < pLCL->dwNumCountries; dwIdx++, pLCountry++ )
    {
        pLCountry->dwCountryGroup = *(pCountryIDs + dwIdx);
    }

    *ppLCL = pLCL;
    ClientFree( pCountryIDs );
    return lResult;
}


//***************************************************************************
//   Returns LONG_DISTANCE_CARRIER_MANDATORY if rule contains an 'L' or 'l' 
//          (ie long distance carrier code - mandatory),
//   Returns LONG_DISTANCE_CARRIER_OPTIONAL if rule contains an 'N' or 'n'
//          (ie long distance carrier code - optional),
//   Returns LONG_DISTANCE_CARRIER_NONE if rule contains neither
//
int IsLongDistanceCarrierCodeRule(LPWSTR lpRule)
{
   WCHAR c;

   while ((c = *lpRule++) != '\0')
   {
      if (c == 'L' || c == 'l') return LONG_DISTANCE_CARRIER_MANDATORY;
      if (c == 'N' || c == 'n') return LONG_DISTANCE_CARRIER_OPTIONAL;
   }
   return LONG_DISTANCE_CARRIER_NONE;
}


//***************************************************************************
//   Returns INTERNATIONAL_CARRIER_MANDATORY if rule contains an 'M' or 'm' 
//          (ie international carrier code - mandatory),
//   Returns INTERNATIONAL_CARRIER_OPTIONAL if rule contains an 'S' or 's' 
//          (ie international carrier code - optional),
//   Returns INTERNATIONAL_CARRIER_NONE if rule contains neither
//
int IsInternationalCarrierCodeRule(LPWSTR lpRule)
{
   WCHAR c;

   while ((c = *lpRule++) != '\0')
   {
      if (c == 'M' || c == 'm') return INTERNATIONAL_CARRIER_MANDATORY;
      if (c == 'S' || c == 's') return INTERNATIONAL_CARRIER_OPTIONAL;
   }
   return INTERNATIONAL_CARRIER_NONE;
}


//***************************************************************************
//***************************************************************************
//***************************************************************************
//   Returns CITY_MANDATORY if rule contains an F (ie city code mandatory),
//   Returns CITY_OPTIONAL if rule contains an I (ie city code optional)
//   Returns CITY_NONE if rule contains neither
//
int IsCityRule(LPWSTR lpRule)
{
   WCHAR c;

   while ((c = *lpRule++) != '\0')
   {
      if (c == 'F') return CITY_MANDATORY;
      if (c == 'I') return CITY_OPTIONAL;
   }
   return CITY_NONE;
}


// Initializes/uninitializes the defined node pools based on the templates from list.h
//

void ListNodePoolsInitialize(void)
{
    NodePool<CCallingCard *>::initialize();
    NodePool<CCountry *>::initialize();
    NodePool<CLocation *>::initialize();
    NodePool<CAreaCodeRule*>::initialize();
}



void ListNodePoolsUninitialize(void)
{
    NodePool<CCallingCard *>::uninitialize();
    NodePool<CCountry *>::uninitialize();
    NodePool<CLocation *>::uninitialize();
    NodePool<CAreaCodeRule*>::uninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\drv.h ===
/*--------------------------------------------------------------------------*\
   Include File:  drv.h

   Public header for dealing with service prodivers, or drivers in english

   Copyright (c) 1995-1999 Microsoft Corporation
      
\*--------------------------------------------------------------------------*/

#ifndef  PH_DRV
#define  PH_DRV

#include <tapi.h>

//----------            
// Constants
//----------
#define TAPI_VERSION               0x00010004
#define INITIAL_PROVIDER_LIST_SIZE 1024
//#define INITIAL_PROVIDER_LIST_SIZE sizeof(LINEPROVIDERLIST)



//----------------------------
// Public Function Prototypes
//----------------------------
BOOL RemoveSelectedDriver( HWND hwndParent, HWND hwndList );
BOOL FillDriverList(  HWND hwndList );
BOOL SetupDriver( HWND hwndParent, HWND hwndList );
VOID UpdateDriverDlgButtons( HWND hwnd );
INT_PTR AddDriver_DialogProc( HWND hWnd, UINT wMessage, WPARAM wParam, LPARAM lParam );


#define CPL_MAX_STRING  132      // biggest allowed string


#endif   // PH_DRV
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\cplsimplelocation.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  cplsimplelocation.cpp
                                                              
       Author:  toddb - 10/06/98

****************************************************************************/
//
// The dialog proc for the SimpleLocation page.  This is used as a page
// inside the Modem wizard (in modemui.dll) and as a dialog from tapi
// when there are no locations.
//

#include "cplPreComp.h"
#include "cplResource.h"

HRESULT CreateCountryObject(DWORD dwCountryID, CCountry **ppCountry);
int IsCityRule(LPWSTR lpRule);

int IsCityRule(DWORD dwCountryID)
{
    CCountry * pCountry;
    HRESULT hr;

    hr = CreateCountryObject(dwCountryID, &pCountry);
    if ( SUCCEEDED(hr) )
    {
        int ret = IsCityRule(pCountry->GetLongDistanceRule());
        delete pCountry;
        return ret;
    }
    
    // in the error case we return optional as a compromise that works
    // for any possible case (though no optimally).
    LOG((TL_ERROR, "IsCityRule(DWORD dwCountryID) failed to create country %d", dwCountryID ));
    return CITY_OPTIONAL;
}

//***************************************************************************
extern "C"
INT_PTR
CALLBACK
LocWizardDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    static DWORD dwVersion;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            HWND hwnd;

            // we either pass in zero or the TAPI version as the lParam.
            dwVersion = (DWORD)lParam;

            DWORD dwDefaultCountryID = GetProfileInt(TEXT("intl"), TEXT("iCountry"), 1);
            hwnd = GetDlgItem(hwndDlg, IDC_COUNTRY);
            PopulateCountryList(hwnd, dwDefaultCountryID);

            CCountry * pCountry;
            HRESULT hr;
            int     iCityRule;
            int     iLongDistanceCarrierCodeRule;
            int     iInternationalCarrierCodeRule;

            hr = CreateCountryObject(dwDefaultCountryID, &pCountry);
            if ( SUCCEEDED(hr) )
            {
                iCityRule = IsCityRule( pCountry->GetLongDistanceRule() );
                iLongDistanceCarrierCodeRule = IsLongDistanceCarrierCodeRule( pCountry->GetLongDistanceRule() );
                iInternationalCarrierCodeRule = IsInternationalCarrierCodeRule( pCountry->GetInternationalRule() );
                delete pCountry;
            } else 
            {
                LOG((TL_ERROR, "LocWizardDlgProc failed to create country %d", dwDefaultCountryID));
                iCityRule = CITY_OPTIONAL;
                iLongDistanceCarrierCodeRule = LONG_DISTANCE_CARRIER_OPTIONAL;
                iInternationalCarrierCodeRule = INTERNATIONAL_CARRIER_OPTIONAL;
            }

            hwnd = GetDlgItem(hwndDlg,IDC_AREACODE);
            SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);
            LimitInput(hwnd, LIF_ALLOWNUMBER);
            if ( iCityRule == CITY_NONE )
            {
                SetWindowText(hwnd, TEXT(""));
                EnableWindow(hwnd, FALSE);
            }

            hwnd = GetDlgItem(hwndDlg,IDC_CARRIERCODE);
            SendMessage(hwnd,EM_SETLIMITTEXT,CPL_SETTEXTLIMIT,0);
            LimitInput(hwnd, LIF_ALLOWNUMBER);
            if ( (LONG_DISTANCE_CARRIER_NONE == iLongDistanceCarrierCodeRule) &&
                 (INTERNATIONAL_CARRIER_NONE == iInternationalCarrierCodeRule) )
            {
                SetWindowText(hwnd, TEXT(""));
                EnableWindow(GetDlgItem(hwndDlg, IDC_STATICCC), FALSE);
                EnableWindow(hwnd, FALSE);
            }

            hwnd = GetDlgItem(hwndDlg,IDC_LOCALACCESSNUM);
            SendMessage(hwnd, EM_SETLIMITTEXT, CPL_SETTEXTLIMIT, 0);
            LimitInput(hwnd, LIF_ALLOWNUMBER|LIF_ALLOWPOUND|LIF_ALLOWSTAR|LIF_ALLOWCOMMA);

            BOOL bUseToneDialing = TRUE;
            CheckRadioButton(hwndDlg,IDC_TONE,IDC_PULSE,bUseToneDialing?IDC_TONE:IDC_PULSE);

            SetForegroundWindow (hwndDlg);

            return TRUE; // auto set focus
        }

    case WM_NOTIFY:
        // If we are controlling the property page then we will recieve WM_NOTIFY
        // messages from it.
        switch (((LPNMHDR)lParam)->code)
        {
        case PSN_WIZFINISH:
        case PSN_KILLACTIVE:
            // This dialog is shown in different places depending on if this is a legacy modem install
            // or a PNP modem install.  In the PNP case, the dialog shows on a single page wizard that
            // has a "finsih" button, in the legacy case it shows in the middle of a series of pages and
            // has a "next" button.  We get different notify messages based on which case we are in, but
            // luckly both of those notifies can be handled with the same code (ie they use the same
            // return codes to mean "don't leave this page yet").  This is why we treat both PSN_WIZFINISH
            // and PSN_KILLACTIVE in the same mannor.
            wParam = IDOK;
            break;

        case PSN_SETACTIVE:
            return TRUE;

        default:
            return FALSE;
        }

        // fall through.  This causes WM_NOTIFY:PSN_KILLACTIVE to be treated exactly
        // the same as WM_COMMAND:IDOK.

    case WM_COMMAND:
        // we get lots of WM_COMMAND messages, but the only one we care about is the
        // "OK" button that dismisses us in dialog mode
        switch ( LOWORD(wParam) )
        {
        case IDOK:
            {
                HWND    hwnd;
                TCHAR   szBuffer[128];
                WCHAR   wszAreaCode[32];
                WCHAR   wszCarrierCode[32];
                DWORD   dwCountryID;

                // verify all the input
                hwnd = GetDlgItem( hwndDlg, IDC_COUNTRY );
                LRESULT lr = SendMessage( hwnd, CB_GETCURSEL, 0, 0 );
                dwCountryID = (DWORD)SendMessage( hwnd, CB_GETITEMDATA, lr, 0 );

                if ( CB_ERR == dwCountryID )
                {
                    // No country is selected
                    ShowErrorMessage(hwnd, IDS_NEEDACOUNTRY);

                    // if we are a wizard page, prevent swicthing pages
                    if ( uMsg == WM_NOTIFY )
                    {
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                    }
                    return TRUE;
                }

                CCountry * pCountry;
                HRESULT hr;
                int     iCityRule;
                int     iLongDistanceCarrierCodeRule;
                int     iInternationalCarrierCodeRule;

                hr = CreateCountryObject(dwCountryID, &pCountry);
                if ( SUCCEEDED(hr) )
                {
                    iCityRule = IsCityRule(pCountry->GetLongDistanceRule());
                    iLongDistanceCarrierCodeRule = IsLongDistanceCarrierCodeRule( pCountry->GetLongDistanceRule() );
                    iInternationalCarrierCodeRule = IsInternationalCarrierCodeRule( pCountry->GetInternationalRule() );
                    delete pCountry;
                } else {
                    LOG((TL_ERROR, "LocWizardDlgProc failed to create country %d", dwCountryID));
                    iCityRule = CITY_OPTIONAL;
                    iLongDistanceCarrierCodeRule = LONG_DISTANCE_CARRIER_OPTIONAL;
                    iInternationalCarrierCodeRule = INTERNATIONAL_CARRIER_OPTIONAL;
                }


                hwnd = GetDlgItem(hwndDlg, IDC_AREACODE);
                GetWindowText( hwnd, szBuffer, ARRAYSIZE(szBuffer) );
                SHTCharToUnicode( szBuffer, wszAreaCode, ARRAYSIZE(wszAreaCode) );

                // if the selected country requires an area code && no area code is given
                if ( (CITY_MANDATORY==iCityRule) && !*wszAreaCode )
                {
                    // complain that the area code is missing.
                    ShowErrorMessage(hwnd, IDS_NEEDANAREACODE);

                    // if we are a wizard page, prevent swicthing pages
                    if ( uMsg == WM_NOTIFY )
                    {
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                    }
                    return TRUE;
                }


                hwnd = GetDlgItem(hwndDlg, IDC_CARRIERCODE);
                GetWindowText( hwnd, szBuffer, ARRAYSIZE(szBuffer) );
                SHTCharToUnicode( szBuffer, wszCarrierCode, ARRAYSIZE(wszCarrierCode) );

                // if the selected country requires a carrier code && no carrier code is given
                if ( ((LONG_DISTANCE_CARRIER_MANDATORY == iLongDistanceCarrierCodeRule) ||
                      (INTERNATIONAL_CARRIER_MANDATORY == iInternationalCarrierCodeRule)) &&
                     !*wszCarrierCode )
                {
                    // complain that the carrier code is missing.
                    ShowErrorMessage(hwnd, IDS_NEEDACARRIERCODE);

                    // if we are a wizard page, prevent swicthing pages
                    if ( uMsg == WM_NOTIFY )
                    {
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                    }
                    return TRUE;
                }

                // if we get here then the input is all valid
                WCHAR       wszLocationName[128];
                WCHAR       wszAccessCode[32];
                BOOL        bUseTone;

                LoadString( GetUIInstance(), IDS_MYLOCATION, szBuffer, ARRAYSIZE(szBuffer) );
                SHTCharToUnicode( szBuffer, wszLocationName, ARRAYSIZE(wszLocationName) );


                hwnd = GetDlgItem(hwndDlg, IDC_LOCALACCESSNUM);
                GetWindowText( hwnd, szBuffer, ARRAYSIZE(szBuffer) );
                SHTCharToUnicode( szBuffer, wszAccessCode, ARRAYSIZE(wszAccessCode) );

                hwnd = GetDlgItem( hwndDlg, IDC_TONE );
                bUseTone = (BST_CHECKED == SendMessage(hwnd, BM_GETCHECK, 0,0));

                // Create a location.
                CLocation location;

                // Initialize it with the values from the dialog
                location.Initialize(
                        wszLocationName,
                        wszAreaCode,
                        iLongDistanceCarrierCodeRule?wszCarrierCode:L"",
                        iInternationalCarrierCodeRule?wszCarrierCode:L"",
                        wszAccessCode,
                        wszAccessCode,
                        L"",
                        0,
                        dwCountryID,
                        0,
                        bUseTone?LOCATION_USETONEDIALING:0 );
                location.NewID();

                // Write it to the registry
                location.WriteToRegistry();

                if ( uMsg == WM_COMMAND )
                {
                    EndDialog(hwndDlg, IDOK);
                }
            }
            break;

        case IDCANCEL:
            // Do a version check, if the version is < 2.2 then we 
            // need to provide a strong warning message about legacy apps
            // not working correctly without this information.  Only upon
            // a confirmation from the user will we then end the dialog.
            if ( dwVersion < TAPI_VERSION2_2 )
            {
                int ret;
                TCHAR szText[1024];
                TCHAR szCaption[128];

                LoadString( GetUIInstance(), IDS_NOLOCWARNING, szText, ARRAYSIZE(szText) );
                LoadString( GetUIInstance(), IDS_NOLOCCAPTION, szCaption, ARRAYSIZE(szCaption) );

                ret = MessageBox(hwndDlg, szText, szCaption, MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2 );
                if ( IDYES != ret )
                {
                    return TRUE;
                }
            }
            EndDialog(hwndDlg, IDCANCEL);
            break;

        case IDC_COUNTRY:
            if ( CBN_SELCHANGE == HIWORD(wParam) )
            {
                HWND    hwnd;
                DWORD   dwCountryID;
                int     iCityRule;

                hwnd = GetDlgItem( hwndDlg, IDC_COUNTRY );
                LRESULT lr = SendMessage( hwnd, CB_GETCURSEL, 0, 0 );
                dwCountryID = (DWORD)SendMessage( hwnd, CB_GETITEMDATA, lr, 0 );

                CCountry * pCountry;
                HRESULT hr;
                int     iLongDistanceCarrierCodeRule;
                int     iInternationalCarrierCodeRule;

                hr = CreateCountryObject(dwCountryID, &pCountry);
                if ( SUCCEEDED(hr) )
                {
                    iCityRule = IsCityRule( pCountry->GetLongDistanceRule() );
                    iLongDistanceCarrierCodeRule = IsLongDistanceCarrierCodeRule( pCountry->GetLongDistanceRule() );
                    iInternationalCarrierCodeRule = IsInternationalCarrierCodeRule( pCountry->GetInternationalRule() );
                    delete pCountry;
                } else 
                {
                    LOG((TL_ERROR, "LocWizardDlgProc failed to create country %d", dwCountryID));
                    iCityRule = CITY_OPTIONAL;
                    iLongDistanceCarrierCodeRule = LONG_DISTANCE_CARRIER_OPTIONAL;
                    iInternationalCarrierCodeRule = INTERNATIONAL_CARRIER_OPTIONAL;
                }

                hwnd = GetDlgItem(hwndDlg,IDC_AREACODE);
                if ( iCityRule == CITY_NONE )
                {
                    SetWindowText(hwnd, TEXT(""));
                    EnableWindow(hwnd, FALSE);
                }
                else
                {
                    EnableWindow(hwnd, TRUE);
                }

                hwnd = GetDlgItem(hwndDlg, IDC_CARRIERCODE);
                if ( (LONG_DISTANCE_CARRIER_NONE == iLongDistanceCarrierCodeRule) &&
                     (INTERNATIONAL_CARRIER_NONE == iInternationalCarrierCodeRule) )
                {
                    SetWindowText(hwnd, TEXT(""));
                    EnableWindow(hwnd, FALSE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_STATICCC), FALSE);
                }
                else
                {
                    EnableWindow(hwnd, TRUE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_STATICCC), TRUE);
                }
            }
            break;
        }
        break;
   
    case WM_HELP:
        // Process clicks on controls after Context Help mode selected
        WinHelp ((HWND)((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (DWORD_PTR)(LPTSTR) a115HelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        // Process right-clicks on controls
        WinHelp ((HWND) wParam, gszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID) a115HelpIDs);
        break;

    default:
        // message is not handled, return FALSE.
        return FALSE;
    }

    // message was handled. return TRUE.
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\helparray.h ===
/****************************************************************************
 
  Copyright (c) 1995-1999 Microsoft Corporation
                                                              
  Module Name:  helparray.h
                                                              
****************************************************************************/

// a-jmike 2/4/99 VER: HR2
#define IDH_NOHELP	((DWORD) -1)
#define IDH_ADD_PROVIDER_ADD	1001
#define IDH_ADD_PROVIDER_LIST	1002
#define IDH_ADDPREFIX_PREFIXES	1003
#define IDH_AREACODERULE_ADD	1004
#define IDH_AREACODERULE_ALLPREFIXES	1005
#define IDH_AREACODERULE_AREACODE	1006
#define IDH_AREACODERULE_DIALAREACODE	1007
#define IDH_AREACODERULE_DIALNUMBER	1008
#define IDH_AREACODERULE_LIST	1009
#define IDH_AREACODERULE_LISTEDPREFIXES	1010
#define IDH_AREACODERULE_REMOVE	1011
#define IDH_AREACODERULE_SAMPLENUMBER	1012
#define IDH_CARD_ACCESSNUMBER	1013
#define IDH_CARD_CARDNUMBER	1014
#define IDH_CARD_DESTNUMBER	1015
#define IDH_CARD_GENERAL_CARDDETAILS	1016
#define IDH_CARD_GENERAL_CARDNAME	1017
#define IDH_CARD_GENERAL_CARDNUMBER	1018
#define IDH_CARD_GENERAL_PIN	1019
#define IDH_CARD_INTERNATIONALNUMBER	1020
#define IDH_CARD_LIST	1021
#define IDH_CARD_LOCALNUMBER	1022
#define IDH_CARD_LONGDISTANCENUMBER	1023
#define IDH_CARD_MOVEDOWN	1024
#define IDH_CARD_MOVEUP	1025
#define IDH_CARD_PIN	1026
#define IDH_CARD_REMOVE	1027
#define IDH_CARD_SPECIFYDIGITS	1028
#define IDH_CARD_WAITFORPROMPT	1029
#define IDH_DESTNUMBER_AREACODE	1030
#define IDH_DESTNUMBER_COUNTRYCODE	1031
#define IDH_DESTNUMBER_LOCALNUMBER	1032
#define IDH_EDITDIALOG_DIGITS	1033
#define IDH_LOC_AREACODERULES_DELETE	1034
#define IDH_LOC_AREACODERULES_DESCRIPTIONTEXT	1035
#define IDH_LOC_AREACODERULES_EDIT	1036
#define IDH_LOC_AREACODERULES_LIST	1037
#define IDH_LOC_AREACODERULES_NEW	1038
#define IDH_LOC_CALLINGCARD_ACCESSNUMBERS	1039
#define IDH_LOC_CALLINGCARD_ACCESSNUMBERS_INTERNATIONAL	1040
#define IDH_LOC_CALLINGCARD_ACCESSNUMBERS_LOCAL	1041
#define IDH_LOC_CALLINGCARD_ACCESSNUMBERS_LONG	1042
#define IDH_LOC_CALLINGCARD_CARDNUMBER	1043
#define IDH_LOC_CALLINGCARD_DELETE	1044
#define IDH_LOC_CALLINGCARD_EDIT	1045
#define IDH_LOC_CALLINGCARD_LIST	1046
#define IDH_LOC_CALLINGCARD_NEW	1047
#define IDH_LOC_CALLINGCARD_PIN	1048
#define IDH_LOC_GENERAL_ACCESS_LOCAL	1049
#define IDH_LOC_GENERAL_ACCESS_LONG	1050
#define IDH_LOC_GENERAL_AREACODE	1051
#define IDH_LOC_GENERAL_COUNTRY	1052
#define IDH_LOC_GENERAL_DIALINGRULES_GRP	1053
#define IDH_LOC_GENERAL_DIALUSING	1054
#define IDH_LOC_GENERAL_DISABLECALLWAITING	1055
#define IDH_LOC_GENERAL_LOCATIONNAME	1056
#define IDH_LOC_GENERAL_PHONENUMBERSAMPLE	1057
#define IDH_MAIN_ADVANCED_ADD	1058
#define IDH_MAIN_ADVANCED_EDIT	1059
#define IDH_MAIN_ADVANCED_LIST	1060
#define IDH_MAIN_ADVANCED_REMOVE	1061
#define IDH_MAIN_DIALINGRULES_DELETE	1062
#define IDH_MAIN_DIALINGRULES_EDIT	1063
#define IDH_MAIN_DIALINGRULES_LIST	1064		
#define IDH_MAIN_DIALINGRULES_NEW	1065		
#define IDH_MAIN_DIALINGRULES_PHONENUMBERSAMPLE	1066		
#define IDH_SPECIFYDIGITS_EDIT	1067		
#define IDH_WAITFORDIALOG_WAITFORDIALTONE	1068		
#define IDH_WAITFORDIALOG_WAITFORTIME	1069		
#define IDH_WAITFORDIALOG_WAITFORVOICE	1070		
#define IDH_LOC_LONGDISTANCE_CARRIERCODE 1071
#define IDH_LOC_INTERNATIONAL_CARRIERCODE 1072
#define IDH_LOC_GENERAL_CARRIERCODE 1073

// Dialing Rules Dialog Box (IDD_MAIN_DIALINGRULES == 101)			
const DWORD a101HelpIDs[]=			
{			
	IDC_PHONENUMBERTEXT,	IDH_MAIN_DIALINGRULES_PHONENUMBERSAMPLE,	// Dialing Rules: Phone number will be dialed as: (Static)
	IDC_PHONENUMBERSAMPLE,	IDH_MAIN_DIALINGRULES_PHONENUMBERSAMPLE,	// Dialing Rules:  (Static)
	IDC_NEW,	IDH_MAIN_DIALINGRULES_NEW,	// Dialing Rules: &New... (Button)
	IDC_EDIT,	IDH_MAIN_DIALINGRULES_EDIT,	// Dialing Rules: &Edit... (Button)
	IDC_DELETE,	IDH_MAIN_DIALINGRULES_DELETE,	// Dialing Rules: &Delete (Button)
	IDC_LIST,	IDH_MAIN_DIALINGRULES_LIST,	// Dialing Rules:  (SysListView32)
	IDC_NOHELP,	IDH_NOHELP,	// Dialing Rules:  (Static)
	0, 0		
};			

// General Dialog Box (IDD_LOC_GENERAL == 102)			
const DWORD a102HelpIDs[]=			
{			
	IDC_TONE,	IDH_LOC_GENERAL_DIALUSING,	// General: &Tone (Button)
	IDC_DISABLESTRING,	IDH_LOC_GENERAL_DISABLECALLWAITING,	// General:  (ComboBox)
	2003,	IDH_LOC_GENERAL_DIALINGRULES_GRP,	// General: When dialing from this location, use the following rules: (Static)
	IDC_PULSE,	IDH_LOC_GENERAL_DIALUSING,	// General: &Pulse (Button)
	IDC_LOCATIONNAME,	IDH_LOC_GENERAL_LOCATIONNAME,	// General:  (Edit)
	IDC_PHONENUMBERTEXT,	IDH_LOC_GENERAL_PHONENUMBERSAMPLE,	// General: Phone number will be dialed as: (Static)
	IDC_COUNTRY,	IDH_LOC_GENERAL_COUNTRY,	// General:  (ComboBox)
	IDC_PHONENUMBERSAMPLE,	IDH_LOC_GENERAL_PHONENUMBERSAMPLE,	// General:  (Static)
	IDC_LOCALACCESSNUM,	IDH_LOC_GENERAL_ACCESS_LOCAL,	// General:  (Edit)
	IDC_NOHELP,	IDH_NOHELP,	// General:  (Static)
	IDC_AREACODE,	IDH_LOC_GENERAL_AREACODE,	// General:  (Edit)
	IDC_LONGDISTANCEACCESSNUM,	IDH_LOC_GENERAL_ACCESS_LONG,	// General:  (Edit)
	IDC_INTERNATIONALCARRIERCODE, IDH_LOC_INTERNATIONAL_CARRIERCODE, 
	IDC_LONGDISTANCECARRIERCODE, IDH_LOC_LONGDISTANCE_CARRIERCODE,
	2001,	IDH_NOHELP,	// General: Specify the location from which you will be dialing. (Static)
	IDC_DISABLECALLWAITING,	IDH_LOC_GENERAL_DISABLECALLWAITING,	// General: To disable call &waiting, dial: (Button)
	2002,	IDH_LOC_GENERAL_DIALINGRULES_GRP,	// General: Dialing rules (Button)
	0, 0		
};			

// Area Code Rules Dialog Box (IDD_LOC_AREACODERULES == 103)			
const DWORD a103HelpIDs[]=			
{			
	IDC_DESCRIPTIONTEXT,	IDH_LOC_AREACODERULES_DESCRIPTIONTEXT,	// Area Code Rules:  (Static)
	2006,	IDH_LOC_AREACODERULES_DESCRIPTIONTEXT,	// Area Code Rules: Description (Button)
	IDC_NEW,	IDH_LOC_AREACODERULES_NEW,	// Area Code Rules: &New... (Button)
	IDC_EDIT,	IDH_LOC_AREACODERULES_EDIT,	// Area Code Rules: &Edit... (Button)
	IDC_DELETE,	IDH_LOC_AREACODERULES_DELETE,	// Area Code Rules: &Delete (Button)
	IDC_LIST,	IDH_LOC_AREACODERULES_LIST,	// Area Code Rules:  (SysListView32)
	IDC_NOHELP,	IDH_NOHELP,	// Area Code Rules: An area code rule determines how phone numbers are dialed from your current area code to other area codes and within your area code. (Static)
	0, 0		
};			

// Calling Card Dialog Box (IDD_LOC_CALLINGCARD == 104)			
const DWORD a104HelpIDs[]=			
{			
	IDC_CARDNUMBER,	IDH_LOC_CALLINGCARD_CARDNUMBER,	// Calling Card:  (Edit)
	IDC_LONGDISTANCE,	IDH_LOC_CALLINGCARD_ACCESSNUMBERS_LONG,	// Calling Card:  (Static)
	IDC_PIN,	IDH_LOC_CALLINGCARD_PIN,	// Calling Card:  (Edit)
	IDC_INTERNATIONAL,	IDH_LOC_CALLINGCARD_ACCESSNUMBERS_INTERNATIONAL,	// Calling Card:  (Static)
	IDC_LOCAL,	IDH_LOC_CALLINGCARD_ACCESSNUMBERS_LOCAL,	// Calling Card:  (Static)
	IDC_NEW,	IDH_LOC_CALLINGCARD_NEW,	// Calling Card: &New... (Button)
	IDC_EDIT,	IDH_LOC_CALLINGCARD_EDIT,	// Calling Card: &Edit... (Button)
	IDC_DELETE,	IDH_LOC_CALLINGCARD_DELETE,	// Calling Card: &Delete (Button)
	IDC_LIST,	IDH_LOC_CALLINGCARD_LIST,	// Calling Card:  (SysListView32)
	IDC_NOHELP,	IDH_NOHELP,	// Calling Card: Select the calling card you will use, or click New to add a different card. (Static)
	2001,	IDH_LOC_CALLINGCARD_ACCESSNUMBERS,	// Calling Card: Access phone numbers for: (Button)
	0, 0		
};			

// General Dialog Box (IDD_CARD_GENERAL == 105)			
const DWORD a105HelpIDs[]=			
{			
	IDC_CARDNUMBER,	IDH_CARD_GENERAL_CARDNUMBER,	// General:  (Edit)
	IDC_PIN,	IDH_CARD_GENERAL_PIN,	// General:  (Edit)
	IDC_CARDNAME,	IDH_CARD_GENERAL_CARDNAME,	// General:  (Edit)
	IDC_CARDUSAGE,	IDH_CARD_GENERAL_CARDDETAILS,	
	IDC_CARDUSAGE1,	IDH_CARD_GENERAL_CARDDETAILS,	
	IDC_CARDUSAGE2,	IDH_CARD_GENERAL_CARDDETAILS,	// General:  (Static)
	IDC_CARDUSAGE3,	IDH_CARD_GENERAL_CARDDETAILS,	// General:  (Static)
	IDC_NOHELP,	IDH_NOHELP,	// General:  (Static)
	2001,	IDH_CARD_GENERAL_CARDDETAILS,	// General: Calling card details: (Button)
	0, 0		
};			

// Long Distance Dialog Box (IDD_CARD_LONGDISTANCE == 106)			
const DWORD a106HelpIDs[]=			
{			
	IDC_WAITFOR,	IDH_CARD_WAITFORPROMPT,	// Long Distance: &Wait for Prompt... (Button)
	IDC_CARDNUMBER,	IDH_CARD_CARDNUMBER,	// Long Distance: A&ccount Number (Button)
	IDC_PIN,	IDH_CARD_PIN,	// Long Distance: &PIN (Button)
	IDC_DESTNUMBER,	IDH_CARD_DESTNUMBER,	// Long Distance: &Destination Number... (Button)
	IDC_LONGDISTANCENUMBER,	IDH_CARD_LONGDISTANCENUMBER,	// Long Distance:  (Edit)
	IDC_SPECIFYDIGITS,	IDH_CARD_SPECIFYDIGITS,	// Long Distance: &Specify Digits... (Button)
	IDC_MOVEUP,	IDH_CARD_MOVEUP,	// Long Distance: Move &Up (Button)
	IDC_MOVEDOWN,	IDH_CARD_MOVEDOWN,	// Long Distance: &Move Down (Button)
	IDC_REMOVE,	IDH_CARD_REMOVE,	// Long Distance: &Delete (Button)
	IDC_ACCESSNUMBER,	IDH_CARD_ACCESSNUMBER,	// Long Distance: Access &Number (Button)
	IDC_LIST,	IDH_CARD_LIST,	// Long Distance: List1 (SysListView32)
	IDC_NOHELP,	IDH_NOHELP,	// Long Distance: Use the buttons below to enter the dialing steps for making long-distance calls.  Enter these steps in the exact order as they appear on your calling card. (Static)
	0, 0		
};			

// International Dialog Box (IDD_CARD_INTERNATIONAL == 107)			
const DWORD a107HelpIDs[]=			
{			
	IDC_WAITFOR,	IDH_CARD_WAITFORPROMPT,	// International: &Wait for Prompt... (Button)
	IDC_CARDNUMBER,	IDH_CARD_CARDNUMBER,	// International: A&ccount Number (Button)
	IDC_PIN,	IDH_CARD_PIN,	// International: &PIN (Button)
	IDC_DESTNUMBER,	IDH_CARD_DESTNUMBER,	// International: D&estination Number... (Button)
	IDC_SPECIFYDIGITS,	IDH_CARD_SPECIFYDIGITS,	// International: &Specify Digits... (Button)
	IDC_INTERNATIONALNUMBER,	IDH_CARD_INTERNATIONALNUMBER,	// International:  (Edit)
	IDC_MOVEUP,	IDH_CARD_MOVEUP,	// International: Move &Up (Button)
	IDC_MOVEDOWN,	IDH_CARD_MOVEDOWN,	// International: &Move Down (Button)
	IDC_REMOVE,	IDH_CARD_REMOVE,	// International: &Delete (Button)
	IDC_ACCESSNUMBER,	IDH_CARD_ACCESSNUMBER,	// International: Access &Number (Button)
	IDC_LIST,	IDH_CARD_LIST,	// International: List1 (SysListView32)
	IDC_NOHELP,	IDH_NOHELP,	// International: Use the buttons below to enter the dialing steps for making international calls.  Enter these steps in the exact order as they appear on your calling card. (Static)
	0, 0		
};			

// Local Calls Dialog Box (IDD_CARD_LOCALCALLS == 108)			
const DWORD a108HelpIDs[]=			
{			
	IDC_WAITFOR,	IDH_CARD_WAITFORPROMPT,	// Local Calls: &Wait for Prompt... (Button)
	IDC_CARDNUMBER,	IDH_CARD_CARDNUMBER,	// Local Calls: A&ccount Number (Button)
	IDC_PIN,	IDH_CARD_PIN,	// Local Calls: &PIN (Button)
	IDC_DESTNUMBER,	IDH_CARD_DESTNUMBER,	// Local Calls: D&estination Number... (Button)
	IDC_SPECIFYDIGITS,	IDH_CARD_SPECIFYDIGITS,	// Local Calls: &Specify Digits... (Button)
	IDC_MOVEUP,	IDH_CARD_MOVEUP,	// Local Calls: Move &Up (Button)
	IDC_MOVEDOWN,	IDH_CARD_MOVEDOWN,	// Local Calls: &Move Down (Button)
	IDC_REMOVE,	IDH_CARD_REMOVE,	// Local Calls: &Delete (Button)
	IDC_ACCESSNUMBER,	IDH_CARD_ACCESSNUMBER,	// Local Calls: Access &Number (Button)
	IDC_LOCALNUMBER,	IDH_CARD_LOCALNUMBER,	// Local Calls:  (Edit)
	IDC_LIST,	IDH_CARD_LIST,	// Local Calls: List1 (SysListView32)
	IDC_NOHELP,	IDH_NOHELP,	// Local Calls: Use the buttons below to enter the dialing steps for making local calls. Enter these steps in the exact order as they appear on your calling card. To make local calls without using your calling card, leave this section blank. (Static)
	0, 0		
};			

// New Area Code Rule Dialog Box (IDD_NEWAREACODERULE == 109)			
const DWORD a109HelpIDs[]=			
{			
	2001,	IDH_AREACODERULE_SAMPLENUMBER,	// New Area Code Rule: Area code (Static)
	2002,	IDH_AREACODERULE_SAMPLENUMBER,	// New Area Code Rule: Prefix (Static)
	2003,	IDH_AREACODERULE_SAMPLENUMBER,	// New Area Code Rule:  (Static)
	2004,	IDH_AREACODERULE_SAMPLENUMBER,	// New Area Code Rule:  (Static)
	2005,	IDH_AREACODERULE_SAMPLENUMBER,	// New Area Code Rule: X - X X X - X X X - X X X X (Static)
	IDC_ALLPREFIXES,	IDH_AREACODERULE_ALLPREFIXES,	// New Area Code Rule: &Include all the prefixes within this area code (Button)
	IDC_LISTEDPREFIXES,	IDH_AREACODERULE_LISTEDPREFIXES,	// New Area Code Rule: Include &only the prefixes in the list below: (Button)
	IDC_REMOVE,	IDH_AREACODERULE_REMOVE,	// New Area Code Rule: D&elete (Button)
	IDC_ADD,	IDH_AREACODERULE_ADD,	// New Area Code Rule: &Add... (Button)
	IDC_DIALAREACODE,	IDH_AREACODERULE_DIALAREACODE,	// New Area Code Rule: Include the area &code (Button)
	IDC_DIALNUMBER,	IDH_AREACODERULE_DIALNUMBER,	// New Area Code Rule:  (Edit)
	IDC_LIST,	IDH_AREACODERULE_LIST,	// New Area Code Rule: List1 (SysListView32)
	IDC_NOHELP,	IDH_NOHELP,	// New Area Code Rule: This area code rule will only apply to calls made to the area code and prefix combination you specify below. (Static)
	IDC_AREACODE,	IDH_AREACODERULE_AREACODE,	// New Area Code Rule:  (Edit)
	IDC_DIALCHECK,	IDH_AREACODERULE_DIALNUMBER,	// New Area Code Rule: &Dial: (Button)
	0, 0		
};			

// Wait for Dialog Box (IDD_WAITFORDIALOG == 111)			
const DWORD a111HelpIDs[]=			
{			
	IDC_WAITFORVOICE,	IDH_WAITFORDIALOG_WAITFORVOICE,	// Wait for: Wait for a &voice message to complete (Button)
	IDC_WAITFORTIME,	IDH_WAITFORDIALOG_WAITFORTIME,	// Wait for: Wait for a specific length of &time: (Button)
	IDC_TIMESPIN,	IDH_WAITFORDIALOG_WAITFORTIME,	// Wait for: Spin1 (msctls_updown32)
	IDC_TIME,	IDH_WAITFORDIALOG_WAITFORTIME,	// Wait for: 0 (Edit)
	IDC_WAITFORDIALTONE,	IDH_WAITFORDIALOG_WAITFORDIALTONE,	// Wait for: Wait for a &dial tone (Button)
	IDC_NOHELP,	IDH_NOHELP,	// Wait for: Select the type of prompt to wait for before continuing with the dialing sequence. (Static)
	0, 0		
};			

// Destination number Dialog Box (IDD_DESTNUMDIALOG == 112)			
const DWORD a112HelpIDs[]=			
{			
	IDC_COUNTRYCODE,	IDH_DESTNUMBER_COUNTRYCODE,	// Destination number: Dial the &country code (Button)
	IDC_LOCALNUMBER,	IDH_DESTNUMBER_LOCALNUMBER,	// Destination number: Dial the &number (Button)
	IDC_NOHELP,	IDH_NOHELP,	// Destination number: This step will place the destination number that you will be dialing into the calling card sequence.  When dialing the destination number, which parts of the number do you want to dial? (Static)
	IDC_AREACODE,	IDH_DESTNUMBER_AREACODE,	// Destination number: Dial the &area code (Button)
	0, 0		
};			

// Advanced Dialog Box (IDD_MAIN_ADVANCED == 113)			
const DWORD a113HelpIDs[]=			
{			
	IDC_REMOVE,	IDH_MAIN_ADVANCED_REMOVE,	// Advanced: &Remove (Button)
	IDC_ADD,	IDH_MAIN_ADVANCED_ADD,	// Advanced: A&dd... (Button)
	IDC_EDIT,	IDH_MAIN_ADVANCED_EDIT,	// Advanced: &Configure... (Button)
	IDC_LIST,	IDH_MAIN_ADVANCED_LIST,	// Advanced:  (ListBox)
	IDC_NOHELP,	IDH_NOHELP,	// Advanced:  (Static)
	0, 0		
};			

// Add Driver Dialog Box (IDD_ADD_DRIVER == 114)			
const DWORD a114HelpIDs[]=			
{			
	IDC_ADD,	IDH_ADD_PROVIDER_ADD,	// Add Driver: &Add (Button)
	IDC_DRIVER_LIST,	IDH_ADD_PROVIDER_LIST,	// Add Driver:  (ListBox)
	IDC_NOHELP,	IDH_NOHELP,	// Add Driver: Select the driver you wish to install from the list below, and click Add. (Static)
	0, 0		
};			

// Location Information Dialog Box (IDD_SIMPLELOCATION == 115)			
const DWORD a115HelpIDs[]=			
{			
	IDC_TONE,	IDH_LOC_GENERAL_DIALUSING,	// Location Information: &Tone dialing (Button)
	IDC_PULSE,	IDH_LOC_GENERAL_DIALUSING,	// Location Information: &Pulse dialing (Button)
	IDB_SIMPLELOCATION,	IDH_NOHELP,	// Location Information:  (Static)
	IDC_COUNTRY,	IDH_LOC_GENERAL_COUNTRY,	// Location Information:  (ComboBox)
	IDC_LOCALACCESSNUM,	IDH_LOC_GENERAL_ACCESS_LOCAL,	// Location Information:  (Edit)
	IDC_NOHELP,	IDH_NOHELP,	// Location Information: Before you can make any phone or modem connections, Windows needs the following information about your current location. (Static)
	IDC_AREACODE,	IDH_LOC_GENERAL_AREACODE,	// Location Information:  (Edit)
	IDC_CARRIERCODE, IDH_LOC_GENERAL_CARRIERCODE,
	0, 0		
};		

// Untitled Dialog Box (IDD_EDITPREFIX == 116) for editing the prefix		
const DWORD a116HelpIDs[]=		
{		
	IDC_DESCRIPTIONTEXT,	IDH_ADDPREFIX_PREFIXES,
	IDC_TEXT,	IDH_ADDPREFIX_PREFIXES,
	IDC_EDIT,	IDH_ADDPREFIX_PREFIXES,
	0, 0	
};		

// Untitled Dialog Box (IDD_EDITDIGITS == 117) for editing the digits		
const DWORD a117HelpIDs[]=		
{		
	IDC_DESCRIPTIONTEXT,	IDH_SPECIFYDIGITS_EDIT,
	IDC_TEXT,	IDH_SPECIFYDIGITS_EDIT,	
	IDC_EDIT,	IDH_SPECIFYDIGITS_EDIT,	
	0, 0		
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\makefile.inc ===
$(O)\tapsrvrpc.c: ..\idl\$(O)\tapsrv_c.c
    -copy /v $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\location.h ===
/****************************************************************************
 
  Copyright (c) 1998  Microsoft Corporation
                                                              
  Module Name:  location.h
                                                              
     Abstract:  Location Object definitions
                                                              
       Author:  noela - 09/11/98
              

        Notes:

        
  Rev History:

****************************************************************************/

#ifndef __LOCATION_H_
#define __LOCATION_H_


#include "utils.h"
#include "loc_comn.h"                                                   
#include "rules.h"
#include "card.h"


#define CITY_MANDATORY (1)
#define CITY_OPTIONAL (-1)
#define CITY_NONE (0)

#define LONG_DISTANCE_CARRIER_MANDATORY (1)
#define LONG_DISTANCE_CARRIER_OPTIONAL (-1)
#define LONG_DISTANCE_CARRIER_NONE (0)

#define INTERNATIONAL_CARRIER_MANDATORY (1)
#define INTERNATIONAL_CARRIER_OPTIONAL (-1)
#define INTERNATIONAL_CARRIER_NONE (0)


//***************************************************************************
//
//  Class Definition - CCountry
//
//***************************************************************************
class CCountry
{

private:
    DWORD       m_dwCountryID;
    DWORD       m_dwCountryCode;
    DWORD       m_dwCountryGroup;
    PWSTR       m_pszCountryName;
    CRuleSet    m_Rules;



public:
    CCountry();
    ~CCountry();

#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CCountry)
#endif

    STDMETHOD(Initialize) ( DWORD dwCountryID,
                            DWORD dwCountryCode,
                            DWORD dwCountryGroup,
                            PWSTR pszCountryName,
                            PWSTR pszInternationalRule,
                            PWSTR pszLongDistanceRule,
                            PWSTR pszLocalRule
                          ); 

    PWSTR GetInternationalRule(){return m_Rules.m_pszInternationalRule;}
    PWSTR GetLongDistanceRule(){return m_Rules.m_pszLongDistanceRule;}
    PWSTR GetLocalRule(){return m_Rules.m_pszLocalRule;}
    CRuleSet * GetRuleSet(){return &m_Rules;}
    DWORD GetCountryID(){return m_dwCountryID;}
    DWORD GetCountryCode(){return m_dwCountryCode;}
    DWORD GetCountryGroup(){return m_dwCountryGroup;}
    PWSTR GetCountryName(){return m_pszCountryName;}

};


//***************************************************************************
// Fill out the list template

typedef LinkedList<CCountry *> CCountryList;
typedef ListNode<CCountry *> CCountryNode;


//***************************************************************************
//
//  Class Definition - CCountries
//
//***************************************************************************
class CCountries
{
private:

    DWORD               m_dwNumEntries;
    CCountryList        m_CountryList;

    CCountryNode      * m_hEnumNode;

    

public:
    CCountries();
    ~CCountries();

#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CCountries)
#endif

    HRESULT     Initialize(void);

    // a sort of enumerator
    HRESULT     Reset(void);
    HRESULT     Next(DWORD  NrElem, CCountry ** ppCountry, DWORD *pNrElemFetched);
    HRESULT     Skip(DWORD  NrElem);
    

};




//***************************************************************************
//
//  Class Definition - CLocation
//
//***************************************************************************
class CLocation
{
private:
        
    PWSTR            m_pszLocationName;
    PWSTR            m_pszAreaCode;

    PWSTR            m_pszLongDistanceCarrierCode;
    PWSTR            m_pszInternationalCarrierCode;
    PWSTR            m_pszLongDistanceAccessCode;
    PWSTR            m_pszLocalAccessCode;
    PWSTR            m_pszDisableCallWaitingCode;

    DWORD            m_dwLocationID;
    DWORD            m_dwCountryID;
    DWORD            m_dwCountryCode;
    DWORD            m_dwPreferredCardID;
    DWORD            m_dwOptions;
    BOOL             m_bFromRegistry;    // Was this read from the registry
                                         //  or only existed in memory, i.e
                                         //  how do we delete it.

    BOOL             m_bChanged;         // has this entry changed while in
                                         //  memory, if not we don't write it
                                         //  back to server.
    DWORD            m_dwNumRules;


    PWSTR            m_pszTAPIDialingRule;   // temp store used when processing rules

    AreaCodeRulePtrNode * m_hEnumNode;

public:
    AreaCodeRulePtrList m_AreaCodeRuleList;


public:
    CLocation(); 
    ~CLocation();

#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CLocation)
#endif

    STDMETHOD(Initialize) ( PWSTR pszLocationName,
                            PWSTR pszAreaCode,
                            PWSTR pszLongDistanceCarrierCode,
                            PWSTR pszInternationalCarrierCode,
                            PWSTR pszLongDistanceAccessCode,
                            PWSTR pszLocalAccessCode,
                            PWSTR pszDisableCallWaitingCode,
                            DWORD dwLocationID,
                            DWORD dwCountryID,
                            DWORD dwPreferredCardID,
                            DWORD dwOptions,
                            BOOL  bFromRegistry = FALSE
                           );


    BOOL HasCallWaiting() {return  m_dwOptions & LOCATION_HASCALLWAITING;}
    void UseCallWaiting(BOOL bCw);

    BOOL HasCallingCard(){return  m_dwOptions & LOCATION_USECALLINGCARD;}                        
    void UseCallingCard(BOOL bCc);

    BOOL HasToneDialing(){return  m_dwOptions & LOCATION_USETONEDIALING;}                        
    void UseToneDialing(BOOL bCc);
   
    PWSTR GetName(){return m_pszLocationName;}
    STDMETHOD (SetName)(PWSTR pszLocationName);

    PWSTR GetAreaCode(){return m_pszAreaCode;}
    STDMETHOD (SetAreaCode)(PWSTR pszAreaCode);

    PWSTR GetLongDistanceCarrierCode(){return m_pszLongDistanceCarrierCode;}
    STDMETHOD (SetLongDistanceCarrierCode)(PWSTR pszLongDistanceCarrierCode);

    PWSTR GetInternationalCarrierCode(){return m_pszInternationalCarrierCode;}
    STDMETHOD (SetInternationalCarrierCode)(PWSTR pszInternationalCarrierCode);

    PWSTR GetLongDistanceAccessCode(){return m_pszLongDistanceAccessCode;}
    STDMETHOD (SetLongDistanceAccessCode)(PWSTR pszLongDistanceAccessCode);
   
    PWSTR GetLocalAccessCode(){return m_pszLocalAccessCode;}
    STDMETHOD (SetLocalAccessCode)(PWSTR pszLocalAccessCode);
   
    PWSTR GetDisableCallWaitingCode(){return m_pszDisableCallWaitingCode;}
    STDMETHOD (SetDisableCallWaitingCode)(PWSTR pszDisableCallWaitingCode);


    DWORD GetLocationID() {return m_dwLocationID;}
    
    DWORD GetCountryID() {return m_dwCountryID;}
    void SetCountryID(DWORD dwID) {m_dwCountryID = dwID;}

    DWORD GetCountryCode();
    //void SetCountryCode(DWORD dwCode) {m_dwCountryCode = dwCode;}

    DWORD GetPreferredCardID() {return m_dwPreferredCardID;}
    void SetPreferredCardID(DWORD dwID) {m_dwPreferredCardID = dwID;}

    BOOL FromRegistry(){return  m_bFromRegistry;}
             

    LONG TranslateAddress(PCWSTR         pszAddressIn,
                          CCallingCard * pCallingCard,
                          DWORD          dwTranslateOptions,
                          PDWORD         pdwTranslateResults,
                          PDWORD         pdwDestCountryCode,
                          PWSTR        * pszDialableString,
                          PWSTR        * pszDisplayableString
                         );

    void CLocation::FindRule(
                             DWORD          dwTranslateResults, 
                             DWORD          dwTranslateOptions,
                             CCallingCard * pCard,  
                             CCountry     * pCountry,
                             PWSTR          AreaCodeString, 
                             PWSTR          SubscriberString,
                             PWSTR        * ppRule,
                             PDWORD         dwAccess
                            );




    STDMETHOD(WriteToRegistry)();

    void AddRule(CAreaCodeRule *pNewRule) {m_AreaCodeRuleList.tail()->insert_after(pNewRule);
                                           m_dwNumRules++;
                                           m_bChanged = TRUE;
                                           }
    void RemoveRule(CAreaCodeRule *pRule);
    HRESULT ResetRules(void);
    HRESULT NextRule(DWORD  NrElem, CAreaCodeRule **ppRule, DWORD *pNrElemFetched);
    HRESULT SkipRule(DWORD  NrElem);

    DWORD TapiSize();
    DWORD TapiPack(PLOCATION pLocation, DWORD dwTotalSize);
    DWORD GetNumRules(){return m_dwNumRules;}
    void  Changed(){m_bChanged=TRUE;}
    HRESULT NewID();  // gets new ID from server


};


typedef LinkedList<CLocation *> CLocationList;
typedef ListNode<CLocation *> CLocationNode;


//***************************************************************************
//
//  Class Definition - CLocations
//
//***************************************************************************
class CLocations
{
private:
    
    DWORD           m_dwCurrentLocationID;

    DWORD           m_dwNumEntries;
    CLocationList   m_LocationList;
    CLocationList   m_DeletedLocationList;  // we need to remember these, so we 
                                            //   can delete their reistry entry

    CLocationNode * m_hEnumNode;

    

public:
    CLocations();
    ~CLocations();

#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CLocations)
#endif

    HRESULT Initialize(void);
    void Remove(CLocation * pLocation);
    void Remove(DWORD dwID);
    void Replace(CLocation * pLocOld, CLocation * pLocNew);
    void Add(CLocation * pLocation);
    HRESULT SaveToRegistry(void);

    DWORD GetCurrentLocationID() {return m_dwCurrentLocationID;}
    void SetCurrentLocationID(DWORD dwLocationID) {m_dwCurrentLocationID = dwLocationID;}

    DWORD GetNumLocations(void) const { return m_dwNumEntries; } ;

    HRESULT Reset(void);
    HRESULT Next(DWORD  NrElem, CLocation **ppLocation, DWORD *pNrElemFetched);
    HRESULT Skip(DWORD  NrElem);
    

};








#endif //__LOCATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\list.h ===
/*
 *	File:	list.h
 *	Author:	John R. Douceur
 *	Date:	19 November 1997
 *  Copyright (c) 1997-1999 Microsoft Corporation
 */

#ifndef _INC_LIST

#define _INC_LIST

#include <malloc.h>

template<class Class> class LinkedList;
template<class Class> class NodePool;

template<class Class> class ListNode
{
public:

	bool before_head() const {return previous_node == 0;}
	bool beyond_tail() const {return next_node == 0;}

	Class &value() {return node_value;}

	ListNode<Class> *next() const {return next_node;}
	ListNode<Class> *previous() const {return previous_node;}

	ListNode<Class> *insert_before();
	ListNode<Class> *insert_after();

	ListNode<Class> *insert_before(Class object);
	ListNode<Class> *insert_after(Class object);

	ListNode<Class> *insert_before(ListNode<Class> *node);
	ListNode<Class> *insert_after(ListNode<Class> *node);

	ListNode<Class> *insert_before(LinkedList<Class> *list);
	ListNode<Class> *insert_after(LinkedList<Class> *list);

	void remove();
	ListNode<Class> *remove_forward();
	ListNode<Class> *remove_backward();

	friend class LinkedList<Class>;
	friend class NodePool<Class>;

	~ListNode() {}

private:
	ListNode() {}

	Class node_value;
	ListNode *next_node;
	ListNode *previous_node;
};

template<class Class> class LinkedList
{
public:

	LinkedList();

	~LinkedList();

	ListNode<Class> *head() const {return list_head.next_node;}

	ListNode<Class> *tail() const {return list_tail.previous_node;}

	bool is_empty() const {return list_head.next_node->next_node == 0;}

	void flush();

	friend class ListNode<Class>;
	friend class NodePool<Class>;

private:

	ListNode<Class> list_head;
	ListNode<Class> list_tail;
};

template<class Class> struct NodeGroup
{
	NodeGroup<Class> *next_group;
	ListNode<Class> nodes[1];
};

template<class Class> class NodePool
{
public:

	friend class ListNode<Class>;
	friend class LinkedList<Class>;

	static void initialize(void);
	static void uninitialize(void);

private:

	static ListNode<Class> *allocate();

	static void deallocate(ListNode<Class> *node);
	static void deallocate(LinkedList<Class> *list);

	static	CRITICAL_SECTION	critical_section;

	static int group_size;
	static const int max_group_size;
	static NodeGroup<Class> *group_list;
	static ListNode<Class> *node_list;
};

template<class Class> const int NodePool<Class>::max_group_size = 1024;


template<class Class>
ListNode<Class> *
ListNode<Class>::insert_before()
{
	ListNode<Class> *node = NodePool<Class>::allocate();
	if (node == 0)
	{
		return 0;
	}
	node->previous_node = previous_node;
	node->next_node = this;
	previous_node->next_node = node;
	previous_node = node;
	return node;
}

template<class Class>
ListNode<Class> *
ListNode<Class>::insert_after()
{
	ListNode<Class> *node = NodePool<Class>::allocate();
	if (node == 0)
	{
		return 0;
	}
	node->next_node = next_node;
	node->previous_node = this;
	next_node->previous_node = node;
	next_node = node;
	return node;
}

template<class Class>
ListNode<Class> *
ListNode<Class>::insert_before(
	Class object)
{
	ListNode<Class> *node = NodePool<Class>::allocate();
	if (node == 0)
	{
		return 0;
	}
	node->previous_node = previous_node;
	node->next_node = this;
	node->node_value = object;
	previous_node->next_node = node;
	previous_node = node;
	return node;
}

template<class Class>
ListNode<Class> *
ListNode<Class>::insert_after(
	Class object)
{
	ListNode<Class> *node = NodePool<Class>::allocate();
	if (node == 0)
	{
		return 0;
	}
	node->next_node = next_node;
	node->previous_node = this;
	node->node_value = object;
	next_node->previous_node = node;
	next_node = node;
	return node;
}

template<class Class>
ListNode<Class> *
ListNode<Class>::insert_before(
	ListNode<Class> *node)
{
	node->previous_node->next_node = node->next_node;
	node->next_node->previous_node = node->previous_node;
	node->previous_node = previous_node;
	node->next_node = this;
	previous_node->next_node = node;
	previous_node = node;
	return node;
}

template<class Class>
ListNode<Class> *
ListNode<Class>::insert_after(
	ListNode<Class> *node)
{
	node->previous_node->next_node = node->next_node;
	node->next_node->previous_node = node->previous_node;
	node->next_node = next_node;
	node->previous_node = this;
	next_node->previous_node = node;
	next_node = node;
	return node;
}

template<class Class>
ListNode<Class> *
ListNode<Class>::insert_before(
	LinkedList<Class> *list)
{
	if (!list->is_empty())
	{
		ListNode<Class> *old_head = list->list_head.next_node;
		previous_node->next_node = old_head;
		old_head->previous_node = previous_node;
		previous_node = list->list_tail.previous_node;
		previous_node->next_node = this;
		list->list_head.next_node = &list->list_tail;
		list->list_tail.previous_node = &list->list_head;
		return old_head;
	}
	else
	{
		return this;
	}
}

template<class Class>
ListNode<Class> *
ListNode<Class>::insert_after(
	LinkedList<Class> *list)
{
	if (!list->is_empty())
	{
		ListNode<Class> *old_tail = list->list_tail.previous_node;
		next_node->previous_node = old_tail;
		old_tail->next_node = next_node;
		next_node = list->list_head.next_node;
		next_node->previous_node = this;
		list->list_tail.previous_node = &list->list_head;
		list->list_head.next_node = &list->list_tail;
		return old_tail;
	}
	else
	{
		return this;
	}
}

template<class Class>
void
ListNode<Class>::remove()
{
	previous_node->next_node = next_node;
	next_node->previous_node = previous_node;
	NodePool<Class>::deallocate(this);
}

template<class Class>
ListNode<Class> *
ListNode<Class>::remove_forward()
{
	ListNode<Class> *node = next_node;
	previous_node->next_node = next_node;
	next_node->previous_node = previous_node;
	NodePool<Class>::deallocate(this);
	return node;
}

template<class Class>
ListNode<Class> *
ListNode<Class>::remove_backward()
{
	ListNode<Class> *node = previous_node;
	previous_node->next_node = next_node;
	next_node->previous_node = previous_node;
	NodePool<Class>::deallocate(this);
	return node;
}


template<class Class>
LinkedList<Class>::LinkedList()
{
	list_head.next_node = &list_tail;
	list_head.previous_node = 0;
	list_tail.next_node = 0;
	list_tail.previous_node = &list_head;
}

template<class Class>
LinkedList<Class>::~LinkedList()
{
	NodePool<Class>::deallocate(this);
}

template<class Class>
void
LinkedList<Class>::flush()
{
	NodePool<Class>::deallocate(this);
}


template<class Class> int NodePool<Class>::group_size = 1;
template<class Class> NodeGroup<Class> * NodePool<Class>::group_list = 0;
template<class Class> ListNode<Class> * NodePool<Class>::node_list = 0;
template<class Class> CRITICAL_SECTION NodePool<Class>::critical_section = {0};

template<class Class>
void NodePool<Class>::initialize()
{
	InitializeCriticalSection(&critical_section);
}

template<class Class>
void NodePool<Class>::uninitialize()
{
	DeleteCriticalSection(&critical_section);
}

template<class Class>
ListNode<Class> *
NodePool<Class>::allocate()
{

	EnterCriticalSection(&critical_section);
	
	if (node_list == 0)
	{
		NodeGroup<Class> *node_group =
			(NodeGroup<Class> *)malloc(sizeof(NodeGroup<Class>) +
			(group_size - 1) * sizeof(ListNode<Class>));
		while (node_group == 0 && group_size > 1)
		{
			group_size /= 2;
			node_group =
				(NodeGroup<Class> *)malloc(sizeof(NodeGroup<Class>) +
				(group_size - 1) * sizeof(ListNode<Class>));
		}
		if (node_group == 0)
		{
			LeaveCriticalSection(&critical_section);
			return 0;
		}
		node_group->next_group = group_list;
		group_list = node_group;
		for (int index = 0; index < group_size; index++)
		{
			node_group->nodes[index].next_node = node_list;
			node_list = &node_group->nodes[index];
		}
		group_size *= 2;
		if (group_size > max_group_size)
		{
			group_size = max_group_size;
		}
	}
	ListNode<Class> *node = node_list;
	node_list = node->next_node;
	
	LeaveCriticalSection(&critical_section);
	
	return node;
}

template<class Class>
void
NodePool<Class>::deallocate(
	ListNode<Class> *node)
{
	EnterCriticalSection(&critical_section);

	node->next_node = node_list;
	node_list = node;

	LeaveCriticalSection(&critical_section);
}

template<class Class>
void
NodePool<Class>::deallocate(
	LinkedList<Class> *list)
{
	EnterCriticalSection(&critical_section);
	
	if (!list->is_empty())
	{
		list->list_tail.previous_node->next_node = node_list;
		node_list = list->list_head.next_node;
		list->list_tail.previous_node = &list->list_head;
		list->list_head.next_node = &list->list_tail;
	}
	
	LeaveCriticalSection(&critical_section);

}

#endif	/* _INC_LIST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\location.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  location.cpp
                                                              
     Abstract:  Location Object implementation
                                                              
       Author:  noela - 09/11/98
              

        Notes:

        
  Rev History:

****************************************************************************/

#include <windows.h>
#include <objbase.h>

#include "tapi.h"
#include "tspi.h"
#include "client.h"
#include "location.h"
#include "clntprivate.h"
#include "countrygroup.h"
#include <strsafe.h>

#define MaxDialStringSize 500

LONG PASCAL ReadCountries( LPLINECOUNTRYLIST *ppLCL,
                           UINT nCountryID,
                           DWORD dwDestCountryID
                         );

HRESULT ReadLocations( PLOCATIONLIST *ppLocationList,
                       HLINEAPP hLineApp,
                       DWORD dwDeviceID,
                       DWORD dwAPIVersion,
                       DWORD dwOptions
                     );
LONG PASCAL  WriteLocations( PLOCATIONLIST  pLocationList,
                             DWORD      dwChangedFlags
                           );

LONG BreakupCanonicalW( PWSTR  pAddressIn,
                       PWSTR  *pCountry,
                       PWSTR  *pCity,
                       PWSTR  *pSubscriber
                       );


DWORD TapiPackString(LPBYTE pStructure, 
                     DWORD dwOffset, 
                     DWORD dwTotalSize,
                     PWSTR pszString,
                     PDWORD pdwOffset,
                     PDWORD pdwSize
                     );

LONG AppendDigits( PWSTR pDest,
                   PWSTR pSrc,
                   PWSTR pValidChars
                 );


HRESULT CreateCountryObject(DWORD dwCountryID, CCountry **ppCountry);
int IsCityRule(LPWSTR lpRule);


LONG ApplyRule (PWSTR pszDialString,
                PWSTR pszDisplayString, 
                PWSTR pszRule,
                PWSTR pszDestLDRule,    // used for Area code adjustments
                PWSTR pszLongDistanceCarrier,
                PWSTR pszInternationalCarrier,
                PWSTR pszCountry,     
                PWSTR pszCity,        
                PWSTR pszSubscriber,
                PWSTR pCardName,
                PWSTR pCardAccessNumber,
                PWSTR pCardAccountNumber,
                PWSTR pCardPINNumber
                );


BOOL PrefixMatch(PWSTR pszPrefix,PWSTR pszSubscriberString, PDWORD pdwMatched);
BOOL AreaCodeMatch(PWSTR pszAreaCode1, PWSTR pszAreaCode2, PWSTR pszRule);
PWSTR SkipLDAccessDigits(PWSTR pszAreaCode, PWSTR pszLDRule);

#define LOCAL           1
#define LONG_DISTANCE   2
#define INTERNATIONAL   3



const WCHAR  csSCANTO[]      = L"\r";
const WCHAR  csDISPSUPRESS[] = L"TtPp,Ww@?!$";
const WCHAR  csBADCO[]       = L"AaBbCcDdPpTtWw*#!,@$?;()";
const WCHAR  csSCANSUB[]     = L"^|/";




/*
 ***************************************************************************
 *********************                          ****************************
 ********************     CLocation Class        ***************************
 ********************       Definitions          ***************************
 *********************                          ****************************
 ***************************************************************************
*/



/****************************************************************************

    Class : CLocation         
   Method : Constructer

****************************************************************************/
CLocation::CLocation()
{
    m_pszLocationName = NULL;

    m_pszLongDistanceAccessCode = NULL;
    m_pszLocalAccessCode = NULL;
    m_pszDisableCallWaitingCode = NULL;
    m_pszAreaCode = NULL;
    m_bFromRegistry = FALSE;
    m_bChanged = FALSE;
    m_dwNumRules = 0;
    m_hEnumNode = m_AreaCodeRuleList.head();
    m_pszTAPIDialingRule = NULL;
}



/****************************************************************************

    Class : CLocation         
   Method : Destructer

            Clean up memory allocations

****************************************************************************/
CLocation::~CLocation()
{
    if ( m_pszLocationName != NULL )
    {
         ClientFree(m_pszLocationName);
    }   

    if ( m_pszLongDistanceAccessCode != NULL )
    {
         ClientFree(m_pszLongDistanceAccessCode);
    }   

    if ( m_pszLocalAccessCode != NULL )
    {
         ClientFree(m_pszLocalAccessCode);
    }   

    if ( m_pszDisableCallWaitingCode != NULL )
    {
         ClientFree(m_pszDisableCallWaitingCode);
    }   

    if ( m_pszAreaCode != NULL )
    {
         ClientFree(m_pszAreaCode);
    }   

    if ( m_pszTAPIDialingRule != NULL )
    {
         ClientFree(m_pszTAPIDialingRule);
    }   

    if (m_pszLongDistanceCarrierCode != NULL)
    {
        ClientFree (m_pszLongDistanceCarrierCode);
    }

    if (m_pszInternationalCarrierCode != NULL)
    {
        ClientFree (m_pszInternationalCarrierCode);
    }
    
    // clean up Area Code List
    AreaCodeRulePtrNode *node;

    node = m_AreaCodeRuleList.head(); 

    while( !node->beyond_tail() )
    {
        delete node->value();
        node = node->next();
    }
    m_AreaCodeRuleList.flush();

}



/****************************************************************************

    Class : CLocation         
   Method : Initialize

****************************************************************************/
STDMETHODIMP CLocation::Initialize
                  (                                         
                    PWSTR pszLocationName,                  
                    PWSTR pszAreaCode,
                    PWSTR pszLongDistanceCarrierCode,
                    PWSTR pszInternationalCarrierCode,
                    PWSTR pszLongDistanceAccessCode,        
                    PWSTR pszLocalAccessCode,               
                    PWSTR pszDisableCallWaitingCode,        
                    DWORD dwLocationID,                     
                    DWORD dwCountryID,  
                    DWORD dwPreferredCardID,                
                    DWORD dwOptions ,
                    BOOL  bFromRegistry
                    
                   )
{
    
    m_pszLocationName = ClientAllocString( pszLocationName );
    if (m_pszLocationName == NULL)
    {
        LOG(( TL_ERROR, "Initialize - alloc m_pszLocationName failed" ));
        return E_OUTOFMEMORY;
    }

    m_pszLongDistanceAccessCode = ClientAllocString( pszLongDistanceAccessCode );
    if (m_pszLongDistanceAccessCode == NULL)
    {
        ClientFree(m_pszLocationName);

        LOG(( TL_ERROR, "Initialize - alloc m_pszLongDistanceAccessCode failed" ));
        return E_OUTOFMEMORY;
    }

    m_pszLocalAccessCode = ClientAllocString( pszLocalAccessCode );
    if (m_pszLocalAccessCode == NULL)
    {
        ClientFree(m_pszLocationName);
        ClientFree(m_pszLongDistanceAccessCode);

        LOG(( TL_ERROR, "Initialize - alloc m_pszLocalAccessCode failed" ));
        return E_OUTOFMEMORY;
    }
    
    m_pszDisableCallWaitingCode = ClientAllocString( pszDisableCallWaitingCode );
    if (m_pszDisableCallWaitingCode == NULL)
    {
        ClientFree(m_pszLocationName);
        ClientFree(m_pszLongDistanceAccessCode);
        ClientFree(m_pszLocalAccessCode);

        LOG(( TL_ERROR, "Initialize - alloc m_pszDisableCallWaitingCode failed" ));
        return E_OUTOFMEMORY;
    }

    m_pszAreaCode = ClientAllocString( pszAreaCode );
    if (m_pszAreaCode == NULL)
    {
        ClientFree(m_pszLocationName);
        ClientFree(m_pszLongDistanceAccessCode);
        ClientFree(m_pszLocalAccessCode);
        ClientFree(m_pszDisableCallWaitingCode);

        LOG(( TL_ERROR, "Initialize - alloc m_pszAreaCode failed" ));
        return E_OUTOFMEMORY;
    }

    m_pszLongDistanceCarrierCode = ClientAllocString( pszLongDistanceCarrierCode );
    if (m_pszLongDistanceCarrierCode == NULL)
    {
        ClientFree(m_pszLocationName);
        ClientFree(m_pszLongDistanceAccessCode);
        ClientFree(m_pszLocalAccessCode);
        ClientFree(m_pszDisableCallWaitingCode);
        ClientFree(m_pszAreaCode);

        LOG(( TL_ERROR, "Initialize - alloc m_pszLongDistanceCarrierCode failed" ));
        return E_OUTOFMEMORY;
    }

    m_pszInternationalCarrierCode = ClientAllocString( pszInternationalCarrierCode );
    if (m_pszInternationalCarrierCode == NULL)
    {
        ClientFree(m_pszLocationName);
        ClientFree(m_pszLongDistanceAccessCode);
        ClientFree(m_pszLocalAccessCode);
        ClientFree(m_pszDisableCallWaitingCode);
        ClientFree(m_pszAreaCode);
        ClientFree(m_pszLongDistanceCarrierCode);

        LOG(( TL_ERROR, "Initialize - alloc m_pszInternationalCarrierCode failed" ));
        return E_OUTOFMEMORY;
    }

    m_dwLocationID = dwLocationID;
    m_dwCountryID = dwCountryID ? dwCountryID : 1; // workaround for a bogus country ID
    m_dwPreferredCardID = dwPreferredCardID; 
    m_dwOptions = dwOptions; 
    m_bFromRegistry = bFromRegistry;
    if (m_bFromRegistry == FALSE)
    {
        m_bChanged = TRUE;
    }

    return S_OK;
}



/****************************************************************************

    Class : CLocation         
   Method : UseCallWaiting

****************************************************************************/
void CLocation::UseCallWaiting(BOOL bCw) 
{
    if(bCw)
    {    
        m_dwOptions |= LOCATION_HASCALLWAITING;
    }
    else
    {
        m_dwOptions &= ~LOCATION_HASCALLWAITING;
    }
    m_bChanged = TRUE;
}



/****************************************************************************

    Class : CLocation         
   Method : UseCallingCard

****************************************************************************/
void CLocation::UseCallingCard(BOOL bCc) 
{
    if(bCc)
    {    
        m_dwOptions |= LOCATION_USECALLINGCARD;
    }
    else
    {
        m_dwOptions &= ~LOCATION_USECALLINGCARD;
    }
    m_bChanged = TRUE;
}
   


/****************************************************************************

    Class : CLocation         
   Method : UseToneDialing

****************************************************************************/
void CLocation::UseToneDialing(BOOL bCc) 
{
    if(bCc)
    {    
        m_dwOptions |= LOCATION_USETONEDIALING;
    }
    else
    {
        m_dwOptions &= ~LOCATION_USETONEDIALING;
    }
    m_bChanged = TRUE;
}



/****************************************************************************

    Class : CLocation         
   Method : setName

****************************************************************************/
STDMETHODIMP CLocation::SetName(PWSTR pszLocationName)
{
    HRESULT hr = S_OK;


    if (m_pszLocationName != NULL)
        {
        ClientFree(m_pszLocationName);
        m_pszLocationName = NULL;
        }

    if(pszLocationName != NULL)
    {
        m_pszLocationName = ClientAllocString( pszLocationName );
        if (m_pszLocationName == NULL)
        {
    
            LOG(( TL_ERROR, "setName - alloc failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    m_bChanged = TRUE;
    
    return hr;
}



/****************************************************************************

    Class : CLocation         
   Method : setAreaCode

****************************************************************************/
STDMETHODIMP CLocation::SetAreaCode(PWSTR pszAreaCode)
{
    HRESULT hr = S_OK;


    if (m_pszAreaCode != NULL)
        {
        ClientFree(m_pszAreaCode);
        m_pszAreaCode = NULL;
        }

    if(pszAreaCode != NULL)
    {
        m_pszAreaCode = ClientAllocString( pszAreaCode );
        if (m_pszAreaCode == NULL)
        {
    
            LOG(( TL_ERROR, "setAreaCode - alloc failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    m_bChanged = TRUE;
    
    return hr;
}





/****************************************************************************

    Class : CLocation         
   Method : SetLongDistanceCarrierCode

****************************************************************************/
STDMETHODIMP CLocation::SetLongDistanceCarrierCode(PWSTR pszLongDistanceCarrierCode)
{
    HRESULT hr = S_OK;


    if (m_pszLongDistanceCarrierCode != NULL)
        {
        ClientFree(m_pszLongDistanceCarrierCode);
        m_pszLongDistanceCarrierCode = NULL;
        }

    if(pszLongDistanceCarrierCode != NULL)
    {
        m_pszLongDistanceCarrierCode = ClientAllocString( pszLongDistanceCarrierCode );
        if (m_pszLongDistanceCarrierCode == NULL)
        {
    
            LOG(( TL_ERROR, "setLongDistanceCarrierCode - alloc failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    m_bChanged = TRUE;

    return hr;

}



/****************************************************************************

    Class : CLocation         
   Method : SetInternationalCarrierCode

****************************************************************************/
STDMETHODIMP CLocation::SetInternationalCarrierCode(PWSTR pszInternationalCarrierCode)
{
    HRESULT hr = S_OK;


    if (m_pszInternationalCarrierCode != NULL)
        {
        ClientFree(m_pszInternationalCarrierCode);
        m_pszInternationalCarrierCode = NULL;
        }

    if(pszInternationalCarrierCode != NULL)
    {
        m_pszInternationalCarrierCode = ClientAllocString( pszInternationalCarrierCode );
        if (m_pszInternationalCarrierCode == NULL)
        {
    
            LOG(( TL_ERROR, "setInternationalCarrierCode - alloc failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    m_bChanged = TRUE;

    return hr;

}



/****************************************************************************

    Class : CLocation         
   Method : setLongDistanceAccessCode

****************************************************************************/
STDMETHODIMP CLocation::SetLongDistanceAccessCode(PWSTR pszLongDistanceAccessCode)
{
    HRESULT hr = S_OK;


    if (m_pszLongDistanceAccessCode != NULL)
        {
        ClientFree(m_pszLongDistanceAccessCode);
        m_pszLongDistanceAccessCode = NULL;
        }

    if(pszLongDistanceAccessCode != NULL)
    {
        m_pszLongDistanceAccessCode = ClientAllocString( pszLongDistanceAccessCode );
        if (m_pszLongDistanceAccessCode == NULL)
        {
    
            LOG(( TL_ERROR, "setLongDistanceAccessCode - alloc failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    m_bChanged = TRUE;

    return hr;

}



/****************************************************************************

    Class : CLocation         
   Method : setLocalAccessCode

****************************************************************************/
STDMETHODIMP CLocation::SetLocalAccessCode(PWSTR pszLocalAccessCode)
{
    HRESULT hr = S_OK;


    if (m_pszLocalAccessCode != NULL)
        {
        ClientFree(m_pszLocalAccessCode);
        m_pszLocalAccessCode = NULL;
        }

    if(pszLocalAccessCode != NULL)
    {
        m_pszLocalAccessCode = ClientAllocString( pszLocalAccessCode );
        if (m_pszLocalAccessCode == NULL)
        {
    
            LOG(( TL_ERROR, "setLocalAccessCode - alloc failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    m_bChanged = TRUE;

    return hr;

}



/****************************************************************************

    Class : CLocation         
   Method : SetDisableCallWaitingCode

****************************************************************************/
STDMETHODIMP CLocation::SetDisableCallWaitingCode(PWSTR pszDisableCallWaitingCode)
{
    HRESULT hr = S_OK;


    if (m_pszDisableCallWaitingCode != NULL)
        {
        ClientFree(m_pszDisableCallWaitingCode);
        m_pszDisableCallWaitingCode = NULL;
        }

    if(pszDisableCallWaitingCode != NULL)
    {
        m_pszDisableCallWaitingCode = ClientAllocString( pszDisableCallWaitingCode );
        if (m_pszDisableCallWaitingCode == NULL)
        {
    
            LOG(( TL_ERROR, "SetDisableCallWaitingCodee - alloc failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    m_bChanged = TRUE;

    return hr;

}




/****************************************************************************

    Class : CLocation         
   Method : WriteToRegistry

****************************************************************************/
STDMETHODIMP CLocation::WriteToRegistry()
{
    HRESULT         hr = S_OK;
     
    DWORD           dwTotalSizeNeeded = 0 ;
    DWORD           dwSize=0, dwOffset = 0;
    PLOCATIONLIST   pLocationList = NULL;
    PLOCATION       pEntry = NULL;

    // static size
    dwTotalSizeNeeded = sizeof(LOCATIONLIST);

    dwSize = TapiSize();
    dwTotalSizeNeeded += dwSize;

    // Allocate the memory buffer;
    pLocationList = (PLOCATIONLIST) ClientAlloc( dwTotalSizeNeeded );
    if (pLocationList != NULL)
    {
        // buffer size 
        pLocationList->dwTotalSize  = dwTotalSizeNeeded;
        pLocationList->dwNeededSize = dwTotalSizeNeeded;
        pLocationList->dwUsedSize   = dwTotalSizeNeeded;

        pLocationList->dwCurrentLocationID     = 0;
        pLocationList->dwNumLocationsAvailable = 1;
        
        //list size & offset
        dwOffset   = sizeof(LOCATIONLIST);

        pLocationList->dwNumLocationsInList = 1;
        pLocationList->dwLocationListSize   = dwSize;
        pLocationList->dwLocationListOffset = dwOffset;

        // point to the location entry in list
        pEntry = (PLOCATION)(((LPBYTE)pLocationList) + dwOffset);
        // fill out structure
        TapiPack(pEntry, dwSize);

        WriteLocations( pLocationList, 0);

        // finished with TAPI memory block so release
        if ( pLocationList != NULL )
        {
            ClientFree( pLocationList );
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



/****************************************************************************

    Class : CLocation
   Method : RemoveRule

****************************************************************************/
void CLocation::RemoveRule(CAreaCodeRule *pRule)
{
    AreaCodeRulePtrNode * node = m_AreaCodeRuleList.head();

    while( !node->beyond_tail() )
    {
        if ( pRule == node->value() )
        {
            node->remove();
            delete pRule;
            m_dwNumRules--;
            break;
        }
        node = node->next();
    }
    m_bChanged = TRUE;
}



/****************************************************************************

    Class : CLocation
   Method : ResetRules

****************************************************************************/
HRESULT CLocation::ResetRules(void)
{
    m_hEnumNode = m_AreaCodeRuleList.head();
    return S_OK;
}



/****************************************************************************

    Class : CLocation
   Method : NextRule

****************************************************************************/
HRESULT CLocation::NextRule(DWORD  NrElem, CAreaCodeRule **ppRule, DWORD *pNrElemFetched)
{
    DWORD   dwIndex = 0;

    if(pNrElemFetched == NULL && NrElem != 1)
        return E_INVALIDARG;

    if(ppRule==NULL)
        return E_INVALIDARG;

    while( !m_hEnumNode->beyond_tail() && dwIndex<NrElem )
    {
        *ppRule++ = m_hEnumNode->value();
        m_hEnumNode = m_hEnumNode->next();

        dwIndex++;
    }

    if(pNrElemFetched!=NULL)
        *pNrElemFetched = dwIndex;

    return dwIndex<NrElem ? S_FALSE : S_OK;
}



/****************************************************************************

    Class : CLocation
   Method : SkipRule

****************************************************************************/
HRESULT CLocation::SkipRule(DWORD  NrElem)
{
    DWORD   dwIndex = 0;

    while( !m_hEnumNode->beyond_tail() && dwIndex<NrElem )
    {
        m_hEnumNode = m_hEnumNode->next();

        dwIndex++;
    }

    return dwIndex<NrElem ? S_FALSE : S_OK;
}



/****************************************************************************

    Class : CLocation
   Method : TapiSize
            Number of bytes needed to pack this into a TAPI structure to send
            to TAPISRV.
            If the object has not changed while in memory, we won't save it so
            return a zero size.

****************************************************************************/
DWORD CLocation::TapiSize()
{
    AreaCodeRulePtrNode * node = m_AreaCodeRuleList.head();
    CAreaCodeRule       * pRule = NULL;
    DWORD                 dwSize=0;

    if(m_bChanged)
    {
        // Calc size of Location info
        dwSize = sizeof(LOCATION);
        dwSize += ALIGN((lstrlenW(m_pszLocationName) + 1) * sizeof(WCHAR));
        dwSize += ALIGN((lstrlenW(m_pszAreaCode) + 1) * sizeof(WCHAR));
        dwSize += ALIGN((lstrlenW(m_pszLongDistanceCarrierCode) + 1) * sizeof(WCHAR));
        dwSize += ALIGN((lstrlenW(m_pszInternationalCarrierCode) + 1) * sizeof(WCHAR));
        dwSize += ALIGN((lstrlenW(m_pszLongDistanceAccessCode) + 1) * sizeof(WCHAR));
        dwSize += ALIGN((lstrlenW(m_pszLocalAccessCode) + 1) * sizeof(WCHAR));
        dwSize += ALIGN((lstrlenW(m_pszDisableCallWaitingCode) + 1) * sizeof(WCHAR));


        while( !node->beyond_tail() )
        {
            // Add in size of each Area Code Rule
            pRule = node->value();
            if (pRule != NULL)
            {
                dwSize += pRule->TapiSize();
            }
            node = node->next();
        }
    }
    else  // no change so don't save this
    {
        dwSize = 0;
    }
    return dwSize;
}



/****************************************************************************

    Class : CLocation
   Method : TapiPack
            Pack this object into a TAPI structure.
            Return number of bytes used.
            If the object has not changed while in memory, we won't save it so
            do mothing except return a zero size.

****************************************************************************/
DWORD CLocation::TapiPack(PLOCATION pLocation, DWORD dwTotalSize)
{
    AreaCodeRulePtrNode * node;
    CAreaCodeRule       * pRule = NULL;
    DWORD                 dwSize =0, dwOffSet =0;
    PAREACODERULE         pEntry = NULL;

    if(m_bChanged)
    {
        m_bFromRegistry = TRUE;

        /////////////////////////////////////////////////////////////////////
        // Process fized part of Location info

        dwOffSet = sizeof(LOCATION);
        pLocation->dwPermanentLocationID= m_dwLocationID;
        pLocation->dwCountryCode = m_dwCountryCode;
        pLocation->dwCountryID = m_dwCountryID;
        pLocation->dwPreferredCardID = m_dwPreferredCardID;
        pLocation->dwOptions = m_dwOptions;

        /////////////////////////////////////////////////////////////////////
        // Process strings

        // name
        dwOffSet += TapiPackString((LPBYTE)pLocation,
                                   dwOffSet,
                                   dwTotalSize,
                                   m_pszLocationName,
                                   &pLocation->dwLocationNameOffset,
                                   &pLocation->dwLocationNameSize
                                  );

        //area code
        dwOffSet += TapiPackString((LPBYTE)pLocation,
                                   dwOffSet,
                                   dwTotalSize,
                                   m_pszAreaCode,
                                   &pLocation->dwAreaCodeOffset,
                                   &pLocation->dwAreaCodeSize
                                  );

        //LD carrier code
        dwOffSet += TapiPackString((LPBYTE)pLocation,
                                   dwOffSet,
                                   dwTotalSize,
                                   m_pszLongDistanceCarrierCode,
                                   &pLocation->dwLongDistanceCarrierCodeOffset,
                                   &pLocation->dwLongDistanceCarrierCodeSize
                                  );
        
        //International carrier code
        dwOffSet += TapiPackString((LPBYTE)pLocation,
                                   dwOffSet,
                                   dwTotalSize,
                                   m_pszInternationalCarrierCode,
                                   &pLocation->dwInternationalCarrierCodeOffset,
                                   &pLocation->dwInternationalCarrierCodeSize
                                  );

        //LD access
        dwOffSet += TapiPackString((LPBYTE)pLocation,
                                   dwOffSet,
                                   dwTotalSize,
                                   m_pszLongDistanceAccessCode,
                                   &pLocation->dwLongDistanceAccessCodeOffset,
                                   &pLocation->dwLongDistanceAccessCodeSize
                                  );
        
        // Local access
        dwOffSet += TapiPackString((LPBYTE)pLocation, 
                                   dwOffSet, 
                                   dwTotalSize,
                                   m_pszLocalAccessCode,
                                   &pLocation->dwLocalAccessCodeOffset,
                                   &pLocation->dwLocalAccessCodeSize
                                  );
    
        // CallWaiting
        dwOffSet += TapiPackString((LPBYTE)pLocation, 
                                   dwOffSet, 
                                   dwTotalSize,
                                   m_pszDisableCallWaitingCode,
                                   &pLocation->dwCancelCallWaitingOffset,
                                   &pLocation->dwCancelCallWaitingSize
                                  );
    
    
        /////////////////////////////////////////////////////////////////////
        // Process Area Code Rules
    
        pLocation->dwNumAreaCodeRules = m_dwNumRules;
        pLocation->dwAreaCodeRulesListOffset = dwOffSet;
        //pLocation->dwAreaCodeRulesListSize;
    
        // point to the 1st rule
        pEntry = (PAREACODERULE)(((LPBYTE)pLocation) + dwOffSet);
        
        //point strings past rule area
        dwOffSet += ALIGN(( sizeof(AREACODERULE) * m_dwNumRules )); 
    
        // run through list
        node = m_AreaCodeRuleList.head(); 
        while( !node->beyond_tail() )
        {
            
            // Add in size of each Area Code Rule
            pRule = node->value();
            if (pRule != NULL)
            {
                pEntry->dwOptions = pRule->GetOptions();
    
                // Area code
                dwOffSet += TapiPackString((LPBYTE)pLocation, 
                                           dwOffSet, 
                                           dwTotalSize,
                                           pRule->GetAreaCode(),
                                           &pEntry->dwAreaCodeOffset,
                                           &pEntry->dwAreaCodeSize
                                          );
            
                // num to Call
                dwOffSet += TapiPackString((LPBYTE)pLocation, 
                                           dwOffSet, 
                                           dwTotalSize,
                                           pRule->GetNumberToDial(),
                                           &pEntry->dwNumberToDialOffset,
                                           &pEntry->dwNumberToDialSize
                                          );
                
                // prefix list
                dwSize = pRule->GetPrefixListSize();
                pEntry->dwPrefixesListSize = dwSize;
                pEntry->dwPrefixesListOffset = dwOffSet;
                
                CopyMemory((PVOID)(((LPBYTE)pLocation) + dwOffSet),
                                   pRule->GetPrefixList() ,
                                   dwSize);
                dwOffSet += ALIGN(dwSize);
    
            }
    
    
            node = node->next();
            pEntry++;

        }
    
        // offset gives how many bytes we used
        pLocation->dwUsedSize = dwOffSet;
    }
    else  // no change so don't save this
    {
        dwOffSet = 0;
    }
    return  dwOffSet;
}




/****************************************************************************

    Class : CLocation         
   Method : NewID
            gets new ID from server

****************************************************************************/
HRESULT CLocation::NewID()
{
    LONG lResult;
    DWORD dwId = 0;

    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 1, tAllocNewID),
        {
            (DWORD_PTR)&dwId
        },

        {
            lpDword
        }
    };

   //
   // Yes, let TAPISRV do it without danger of AV interruption from
   // another thread
   //

   lResult = DOFUNC (&funcArgs, "TAllocNewID");
   if(lResult == 0)
   {
        m_dwLocationID = dwId;
   }

   return (HRESULT)lResult;
}


/****************************************************************************

    Class : CLocation         
   Method : GetCountryCode
            gets GetCountryCode from server

****************************************************************************/
DWORD CLocation::GetCountryCode() 
{
    CCountry * pCountry = NULL;        
    
    if(SUCCEEDED( CreateCountryObject(m_dwCountryID, &pCountry)) )
    {
        m_dwCountryCode = pCountry->GetCountryCode();
        delete pCountry;
    }

    return m_dwCountryCode;
}



/****************************************************************************

    Class : CLocation         
   Method : TranslateAddress
            This is what its all there for, take a input number & figure out
            the dialable & display strings

****************************************************************************/
LONG CLocation::TranslateAddress(PCWSTR       pszAddressIn,
                                 CCallingCard *pCallingCard,
                                 DWORD        dwTranslateOptions,
                                 PDWORD       pdwTranslateResults,
                                 PDWORD       pdwDestCountryCode,
                                 PWSTR      * pszDialableString,
                                 PWSTR      * pszDisplayableString
                                )
{
    PWSTR       pszDialString = NULL;
    PWSTR       pszDisplayString = NULL;
    PWSTR       pszInputString = NULL;
    PWSTR       pszRule = NULL;
    PWSTR       pszDestLDRule = NULL;
    PWSTR       pszCountry = NULL;     
    PWSTR       pszCity = NULL;        
    PWSTR       pszSubscriber = NULL;  
    
    PWSTR       pCardName = NULL;
    PWSTR       pCardAccessNumber = NULL;
    PWSTR       pCardAccountNumber = NULL;
    PWSTR       pCardPINNumber = NULL;


    LONG        lResult = 0;
    HRESULT     hr= S_OK;
    CCountry  * pCountry = NULL;
    CCountry  * pDestCountry = NULL;
    DWORD       dwAccess;
    DWORD       dwDestCountryCode;

    BOOL        bSpaceExists, bOutOfMem = FALSE;

    *pdwTranslateResults = 0;
    if(pdwDestCountryCode)
        *pdwDestCountryCode = 0;


    //////////////////////////////////////////////////////////////
    // Allocate space for our strings
    //
    
    pszDialString = (PWSTR)ClientAlloc( MaxDialStringSize * sizeof(WCHAR) );
    if (pszDialString == NULL)
    {
       LOG((TL_TRACE, "TranslateAddress DialString alloc failed"));
       return LINEERR_NOMEM;
    }
  
    pszDisplayString = (PWSTR)ClientAlloc( MaxDialStringSize * sizeof(WCHAR) );
    if (pszDisplayString == NULL)
    {
       LOG((TL_TRACE, "TranslateAddress DisplayString alloc failed"));
  
       ClientFree(pszDialString);
  
       return LINEERR_NOMEM;
    }

    
    *pszDialableString = pszDialString;

    *pszDisplayableString = pszDisplayString;
  
    bSpaceExists = TRUE;    // for suppressing a first space
    
    //////////////////////////////////////////////////////////////
    // Copy the string to our local buffer so we can mangle it
    //
    pszInputString = ClientAllocString(pszAddressIn);
    if (pszInputString == NULL)
    {
       LOG((TL_TRACE, "TranslateAddress InputString alloc failed"));
  
       ClientFree(pszDialString);
       ClientFree(pszDisplayString);
  
       return LINEERR_NOMEM;
    }
  
  
  
    //////////////////////////////////////////////////////////////
    // Mark off the end
    //
    // Isolate the piece of pszInputString that we will operate upon in
    // This piece stops at first CR or \0.
    //
    pszInputString[wcscspn(pszInputString,csSCANTO)] = L'\0';
  

    ////////////////////////////////
    // Set T or P, if not set in input
    //////////////////////////////////////////////////////////////
    // Easy case: first put the T or P in the beginning of the
    // dialable string
    //
    if ( HasToneDialing() )
    {
        *pszDialString = L'T';
    }
    else
    {
        *pszDialString = L'P';
    }

    pszDialString++; 


    

    //////////////////////////////////////////////////////////////
    // Set Call Waiting
    //if  location supports call Waiting AND (TranslateOptions | LINETRANSLATIONOPTION_CANCELCALLWAIT)
    if((dwTranslateOptions & LINETRANSLATEOPTION_CANCELCALLWAITING)  && HasCallWaiting() )
    {
    
        hr = StringCchCatExW(pszDialString, MaxDialStringSize, m_pszDisableCallWaitingCode, NULL, NULL, STRSAFE_NO_TRUNCATION);
        bOutOfMem = bOutOfMem && FAILED(hr);
        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, m_pszDisableCallWaitingCode, NULL, NULL, STRSAFE_NO_TRUNCATION);
        bOutOfMem = bOutOfMem && FAILED(hr);

        bSpaceExists = FALSE;
    }

    

    //////////////////////////////////////////////////////////////
    // Now, do we have a canonical number to deal with, or is it junk?
    //
    if ( *pszInputString == L'+' )  // Check the real _first_ char
    {
      //
      // Ok, it's canonical
      //
      
      //
      // Skip the plus
      //
    
        lResult = BreakupCanonicalW( pszInputString + 1,    
                                     &pszCountry,
                                     &pszCity,
                                     &pszSubscriber   
                                    );                        
    
        if (lResult == 0)
        {
            // It's canonical
            *pdwTranslateResults |= LINETRANSLATERESULT_CANONICAL;
    
            
            hr = CreateCountryObject(m_dwCountryID, &pCountry);
            if(SUCCEEDED( hr) )
            {
                //////////////////////////////////////////////////////////////
                // set LINETRANSLATERESULT result codes
                dwDestCountryCode = (DWORD)_wtol((const wchar_t*) pszCountry);
                if (dwDestCountryCode == pCountry->GetCountryCode() )
                {
                    // In country Call
                  
                    pszDestLDRule = pCountry->GetLongDistanceRule();
                    //if ( ( 
                    //      CurrentCountry.LongDistanceRule.AreaCodes == Optional  
                    //      OR  CurrentCountry.LongDistanceRule.AreaCodes == Manditory && cityCode != NULL
                    //     )  
                    //    AND AreaCodeString != CurrentLocation.AreaCodeString )
                    if ( ( (IsCityRule(pszDestLDRule) == CITY_OPTIONAL) ||
                           ( (IsCityRule(pszDestLDRule) == CITY_MANDATORY) && (pszCity != NULL) ) ) &&
                         (!AreaCodeMatch(pszCity, m_pszAreaCode, pszDestLDRule))
                       )
                    {
                        // Long Distance Call
                        *pdwTranslateResults |= LINETRANSLATERESULT_LONGDISTANCE;
                    }
                    else // Local Call
                    {
                        *pdwTranslateResults |= LINETRANSLATERESULT_LOCAL;
                    }
                    
                }
                else // International Call
                {
                    // find the LD rule of the destination country using the country code (we don't have the country ID)
                    hr = CreateCountryObject(dwDestCountryCode, &pDestCountry);
                    if(SUCCEEDED(hr))
                    {
                        if ( pCountry->GetCountryGroup() != 0 &&
                             pCountry->GetCountryGroup() == pDestCountry->GetCountryGroup()
                           )
                        {
                            // if countries are in the same group, we need to
                            // apply long distance rule instead of international
                            *pdwTranslateResults |= LINETRANSLATERESULT_LONGDISTANCE;
                        }
                        else
                        {
                            *pdwTranslateResults |= LINETRANSLATERESULT_INTERNATIONAL;
                        }

                        pszDestLDRule = pDestCountry->GetLongDistanceRule();
                    }
                    else
                    {
                        *pdwTranslateResults |= LINETRANSLATERESULT_INTERNATIONAL;
                        // FALL THROUGH if error    
                    }
                }
            }
            if(SUCCEEDED( hr) )
            {
                // If the caller needs the destination country code
                if(pdwDestCountryCode)
                    *pdwDestCountryCode = dwDestCountryCode;
                
                //////////////////////////////////////////////////////////////
                // Now we no what type of call, find the correct rule
                // Take in to account LINETRANSLATIONOPTION over-rides
                FindRule(
                        *pdwTranslateResults, 
                        dwTranslateOptions,
                        pCallingCard,  
                        pCountry,
                        pszCity, 
                        pszSubscriber,
                        &pszRule,
                        &dwAccess
                        );
    

    
                //////////////////////////////////////////////////////////////
                // Add access String to output string
                if (dwAccess == LOCAL)
                {
                    hr = StringCchCatExW(pszDialString, MaxDialStringSize, m_pszLocalAccessCode, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);

                    if(*m_pszLocalAccessCode)
                    {
                        if(!bSpaceExists)
                        {
                            hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                            bOutOfMem = bOutOfMem && FAILED(hr);
                        }
                        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, m_pszLocalAccessCode, NULL, NULL, STRSAFE_NO_TRUNCATION);
                        bOutOfMem = bOutOfMem && FAILED(hr);
                        bSpaceExists = FALSE;
                    }

                }
                else // LONG_DISTANCE or INTERNATIONAL
                {
                    hr = StringCchCatExW(pszDialString, MaxDialStringSize, m_pszLongDistanceAccessCode, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);
                    if(*m_pszLongDistanceAccessCode)
                    {
                        if(!bSpaceExists)
                        {
                            hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                            bOutOfMem = bOutOfMem && FAILED(hr);
                        }
                        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, m_pszLongDistanceAccessCode, NULL, NULL, STRSAFE_NO_TRUNCATION);
                        bOutOfMem = bOutOfMem && FAILED(hr);
                        bSpaceExists = FALSE;
                    }
                }


                
                //////////////////////////////////////////////////////////////
                // If there's a card get its values
                if(pCallingCard != NULL)
                {
                    switch(dwAccess)
                    {
                        case INTERNATIONAL:  
                            pCardAccessNumber = pCallingCard->GetInternationalAccessNumber();
                            break;
                        case LONG_DISTANCE:  
                            LOG((TL_TRACE, "TranslateAddress: About to do pCallingCard->GetLongDistanceAccessNumber"));
                            pCardAccessNumber = pCallingCard->GetLongDistanceAccessNumber();
                            LOG((TL_TRACE, "TranslateAddress: Did pCallingCard->GetLongDistanceAccessNumber"));
                            break;
                        default:  
                            pCardAccessNumber = pCallingCard->GetLocalAccessNumber();
                            break;
                    }
                    pCardName = pCallingCard->GetCardName();
                    pCardAccountNumber = pCallingCard->GetAccountNumber();
                    pCardPINNumber = pCallingCard->GetPIN();
                
                }
                
                if(!bSpaceExists)
                {
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);
                }

                //////////////////////////////////////////////////////////////
                // Got the rule , now apply it
                if (ApplyRule (pszDialString,
                           pszDisplayString, 
                           pszRule,
                           pszDestLDRule,
                           m_pszLongDistanceCarrierCode,
                           m_pszInternationalCarrierCode,
                           pszCountry,     
                           pszCity,        
                           pszSubscriber,
                           pCardName,
                           pCardAccessNumber,
                           pCardAccountNumber,
                           pCardPINNumber
                          ))
                {
                    bOutOfMem = TRUE;
                }
                else
                {

                    //
                    // Set LINETRANSLATERESULT_consts based on translation
                    // results
                    //
                    if (wcschr (pszDialString, L'$'))
                    {
                        *pdwTranslateResults |= LINETRANSLATERESULT_DIALBILLING;
                    }
                    if (wcschr (pszDialString, L'W'))
                    {
                        *pdwTranslateResults |= LINETRANSLATERESULT_DIALDIALTONE;
                    }
                    if (wcschr (pszDialString, L'?'))
                    {
                        *pdwTranslateResults |= LINETRANSLATERESULT_DIALPROMPT;
                    }
                    if (wcschr (pszDialString, L'@'))
                    {
                        *pdwTranslateResults |= LINETRANSLATERESULT_DIALQUIET;
                    }
                    if (wcschr (pszDialString, L':'))
                    {
                        *pdwTranslateResults |= LINETRANSLATERESULT_VOICEDETECT;
                    }
                }
            }
            else // bad country code
            {
                lResult = LINEERR_INVALCOUNTRYCODE;

                ClientFree(*pszDialableString);
                ClientFree(*pszDisplayableString);

                *pszDialableString = *pszDisplayableString =  NULL;
            }

            if(pCountry)
                delete pCountry;
            if(pDestCountry)
                delete pDestCountry;
            
        }
        else // bad canonical address
        {
            lResult = LINEERR_INVALADDRESS;

            ClientFree(*pszDialableString);
            ClientFree(*pszDisplayableString);

            *pszDialableString = *pszDisplayableString =  NULL;
        }
    }
    else  // non-canonical string
    {
     PWSTR pszInputStringLocal = pszInputString;

        // if the string starts with T,P,t or p, skip the
        // first character.
        if (*pszInputString == L'T' ||
            *pszInputString == L'P' ||
            *pszInputString == L't' ||
            *pszInputString == L'p')
        {
            pszInputStringLocal++;
        }

        hr = StringCchCatExW(pszDialString, MaxDialStringSize, pszInputStringLocal, NULL, NULL, STRSAFE_NO_TRUNCATION);
        bOutOfMem = bOutOfMem && FAILED(hr);
        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, pszInputString, NULL, NULL, STRSAFE_NO_TRUNCATION);
        bOutOfMem = bOutOfMem && FAILED(hr);
    }


    /////////////////////////////////////////////////////////////////////
    // Clean up
    //
    if (bOutOfMem)
    {
        lResult = LINEERR_NOMEM;
        ClientFree(pszDialString);
        ClientFree(pszDisplayString);
    }

    if(pszInputString != NULL)
    {
        ClientFree(pszInputString);
    }

    return lResult;
}



/****************************************************************************

    Class : CLocation         
   Method : FindRule
            Decide which TAPI dial string rule to apply

            in                      
              dwTranslateResults      
              dwTranslateOptions              
              pCard           
              pCountry      
              AreaCodeString        
              SubscriberString      
            out                     
              ppRule                  
              dwAccess               

****************************************************************************/
void CLocation::FindRule(
                        DWORD          dwTranslateResults, 
                        DWORD          dwTranslateOptions,
                        CCallingCard * pCard,  
                        CCountry     * pCountry,
                        PWSTR          pszAreaCodeString, 
                        PWSTR          pszSubscriberString,
                        PWSTR        * ppszRule,
                        PDWORD         dwAccess
                        )           
{                       
    CRuleSet * pCardRuleSet;
    CRuleSet * pCountryRuleSet;

    //if using Card
    if(pCard != NULL)
    {
        // Apply card rules
        pCardRuleSet = pCard->GetRuleSet();
        LOG((TL_INFO, "FindRule - using (eventually) card %ls", pCard->GetCardName() ));
    }
    else
    {
        pCardRuleSet = NULL;
    }

    pCountryRuleSet =  pCountry->GetRuleSet();

// use card rule if card is specified. If a specific rule is empty, fallback to country rule
#define     SUITABLE_RULE(x)     \
    ( (pCard && pCardRuleSet->x && *(pCardRuleSet->x) ) ? \
       pCardRuleSet->x : pCountryRuleSet->x )


    // Forced Long Distance Call
    if (dwTranslateOptions & LINETRANSLATEOPTION_FORCELD)
    {
        *dwAccess = LONG_DISTANCE;
    
        *ppszRule = SUITABLE_RULE(m_pszLongDistanceRule);
        
        LOG((TL_INFO, "FindRule - force long distance"));
    }
    
    
    // Force Local Call
    else if (dwTranslateOptions & LINETRANSLATEOPTION_FORCELOCAL)
    {
        *dwAccess = LOCAL;
     
        *ppszRule = SUITABLE_RULE(m_pszLocalRule);
        
        LOG((TL_INFO, "FindRule - force local"));
    }
    
    
    // International Call
    else if (dwTranslateResults & LINETRANSLATERESULT_INTERNATIONAL)
    {
        *dwAccess = INTERNATIONAL;
      
        *ppszRule = SUITABLE_RULE(m_pszInternationalRule);
        
        LOG((TL_INFO, "FindRule - international"));
    }
    

    // In Country, Long Distance Call or Local
    else 
    {
        CAreaCodeRule       * pCrtRule = NULL;
        AreaCodeRulePtrNode * pNode = NULL;
        PWSTR                 pszPrefix = NULL;
        DWORD                 dwNumMatchedDigits = 0;
        DWORD                 dwBestMatchedDigits = 0;
        DWORD                 dwBestThisRule = 0;
        BOOL                  bFoundApplicableRule = FALSE;
        BOOL                  bMatchThisRule = FALSE;
        BOOL                  bThisPrefixMatchThisRule = FALSE;
        
        // Enumerate the area code rules
        pNode = m_AreaCodeRuleList.head();
        while( !pNode->beyond_tail() )
        {
            pCrtRule = pNode->value();
            if(pCrtRule!=NULL)
            {
                // does this rule match the area code we're calling ?
                if(AreaCodeMatch(pszAreaCodeString, pCrtRule->GetAreaCode(), pCountry->GetLongDistanceRule()))
                { 
                    LOG((TL_INFO, "FindRule - ACRule applies"));
                    bMatchThisRule = FALSE;
                    dwBestThisRule = 0;
                    if( pCrtRule->HasAppliesToAllPrefixes() )
                    {
                        bMatchThisRule = TRUE;
                        dwNumMatchedDigits = 0;   
                        LOG((TL_INFO, "FindRule - there's a all prefix rule"));
                    }
                    else  // is there a specific prefix rule ?
                    {
                        pszPrefix = pCrtRule->GetPrefixList();
                        while(*pszPrefix != '\0')
                        {
                            bThisPrefixMatchThisRule= PrefixMatch(pszPrefix,
                                                        pszSubscriberString,
                                                    &dwNumMatchedDigits);
                            if(bThisPrefixMatchThisRule)
                            {
                                LOG((TL_INFO, "FindRule:   there's a specific prefix rule %d digit match"
                                            ,dwNumMatchedDigits));
                                            
                                bMatchThisRule = TRUE;
                                if(dwNumMatchedDigits > dwBestThisRule )
                                {
                                    dwBestThisRule= dwNumMatchedDigits;
                                }
                            }
                            pszPrefix = wcschr( pszPrefix, '\0');
                            pszPrefix++;
                        }
                    }
                    
                    // have we got a better match than we've had before ?
                    if(bMatchThisRule && (dwBestThisRule >= dwBestMatchedDigits) )
                    {
                        // We have the best prefix match so far so use this rule
                        dwBestMatchedDigits = dwBestThisRule;
                        bFoundApplicableRule = TRUE;

                        
                        LOG((TL_INFO, "FindRule:  going with the %d digit match" ,dwBestMatchedDigits));

                        *ppszRule = NULL;

                        // Card overides, so if using Card
                        if(pCard != NULL)
                        {
                            LOG((TL_INFO, "FindRule:  card override (eventually)"));
                            if ( pCrtRule->HasDialNumber() )
                            {
                                *ppszRule = pCardRuleSet->m_pszLongDistanceRule;
                            }
                            else
                            {
                                *ppszRule = pCardRuleSet->m_pszLocalRule;
                            }  
                        }
                        if(!(*ppszRule && **ppszRule))
                        // build a tapirulestring for this rule entry
                        // this might be necessary if the calling card has no suitable rule
                        {
                            if(m_pszTAPIDialingRule != NULL)
                            {
                                ClientFree(m_pszTAPIDialingRule);
                            }
                            if (S_OK ==
                                CreateDialingRule(&m_pszTAPIDialingRule,
                                                  pCrtRule->HasDialNumber()?pCrtRule->GetNumberToDial():NULL,
                                                  pCrtRule->HasDialAreaCode() 
                                                 ))
                            {
                                *ppszRule = m_pszTAPIDialingRule;
                                LOG((TL_INFO, "FindRule:  built a rule string - %ls",m_pszTAPIDialingRule));
                            }

                        }

                        // Set the correct access, based on the selected rule
                        if ( pCrtRule->HasDialNumber() )
                        {
                            *dwAccess = LONG_DISTANCE;
                        }
                        else
                        {
                            *dwAccess = LOCAL;
                        }
                    } // no better match

                }  // no not calling this area code
    
            }
            pNode = pNode->next();

        }
    
        // Did we have a match at all ?
        if(bFoundApplicableRule == FALSE) 
        {
            // No area code rule matched, so go with country default rule
            if (dwTranslateResults & LINETRANSLATERESULT_LONGDISTANCE)
            {
                // long Distance
                *dwAccess = LONG_DISTANCE;
                *ppszRule = SUITABLE_RULE(m_pszLongDistanceRule);
        
                LOG((TL_TRACE, "FindRule - long distance default"));
            }
            else  // Local
            {
                *dwAccess = LOCAL;
                *ppszRule = SUITABLE_RULE(m_pszLocalRule);
        
                LOG((TL_TRACE, "FindRule - local default"));
            }
    
        }
    
    }

}

#undef SUITABLE_RULE


/*
 ***************************************************************************
 *********************                          ****************************
 ********************    CLocations  Class       ***************************
 ********************       Definitions          ***************************
 *********************                          ****************************
 ***************************************************************************
*/


/****************************************************************************

    Class : CLocations         
   Method : Constructer

****************************************************************************/
CLocations::CLocations()
{
    m_dwNumEntries = 0;
    m_hEnumNode = m_LocationList.head();
    
}


/****************************************************************************

    Class : CLocations         
   Method : Destructer

****************************************************************************/
CLocations::~CLocations()
{
    CLocationNode *node;

    node = m_LocationList.head(); 

    while( !node->beyond_tail() )
    {
        delete node->value();
        node = node->next();
    }
    m_LocationList.flush();

    node = m_DeletedLocationList.head(); 

    while( !node->beyond_tail() )
    {
        delete node->value();
        node = node->next();
    }
    m_DeletedLocationList.flush();

}



/****************************************************************************

    Class : CLocations         
   Method : Initialize
            Read the location list from registry via TAPISRV & build our 
            object list.

****************************************************************************/
HRESULT CLocations::Initialize(void)
{
    PLOCATIONLIST   pLocationList = NULL;
    
    PLOCATION       pEntry = NULL;
    PWSTR           pszLocationName = NULL;            
    PWSTR           pszAreaCode = NULL;                
    PWSTR           pszLongDistanceCarrierCode = NULL;         
    PWSTR           pszInternationalCarrierCode = NULL;         
    PWSTR           pszLocalAccessCode = NULL;         
    PWSTR           pszLongDistanceAccessCode = NULL;  
    PWSTR           pszCancelCallWaitingCode = NULL;   
    DWORD           dwPermanentLocationID = 0;   
    CLocation     * pNewLocation = NULL;
    
    PAREACODERULE   pAreaCodeRuleEntry = NULL;
    PWSTR           pszNumberToDial = NULL;
    PWSTR           pszzPrefixesList = NULL;
    DWORD           dwNumRules = 0; 
    CAreaCodeRule * pAreaCodeRule = NULL;

    DWORD           dwNumEntries = 0;
    DWORD           dwCount,dwCount2 = 0;
    HRESULT         hr;
    

    
    hr = ReadLocations(&pLocationList,       
                       0,                   
                       0,                   
                       0,                  
                       0      
                      );

    if SUCCEEDED( hr) 
    {
        // current location
        m_dwCurrentLocationID  = pLocationList->dwCurrentLocationID;   
         
        // Find position of 1st LOCATION structure in the LOCATIONLIST structure 
        pEntry = (PLOCATION) ((BYTE*)(pLocationList) + pLocationList->dwLocationListOffset );           

        // Number of locations ?
        dwNumEntries =  pLocationList->dwNumLocationsInList;

        for (dwCount = 0; dwCount < dwNumEntries ; dwCount++)
        {
    
            // Pull Location Info out of LOCATION structure
            pszLocationName           = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwLocationNameOffset);
            pszAreaCode               = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwAreaCodeOffset);
            pszLongDistanceCarrierCode        = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwLongDistanceCarrierCodeOffset);
            pszInternationalCarrierCode        = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwInternationalCarrierCodeOffset);
            pszLocalAccessCode        = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwLocalAccessCodeOffset);
            pszLongDistanceAccessCode = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwLongDistanceAccessCodeOffset);
            pszCancelCallWaitingCode  = (PWSTR) ((BYTE*)(pEntry) 
                                                 + pEntry->dwCancelCallWaitingOffset);
        
        
            // create our new Location Object                
            pNewLocation = new CLocation;
            if (pNewLocation)
            {
                // initialize the new Location Object
                hr = pNewLocation->Initialize(
                                            pszLocationName, 
                                            pszAreaCode,
                                            pszLongDistanceCarrierCode,
                                            pszInternationalCarrierCode,
                                            pszLongDistanceAccessCode, 
                                            pszLocalAccessCode, 
                                            pszCancelCallWaitingCode , 
                                            pEntry->dwPermanentLocationID,
                                            pEntry->dwCountryID,
                                            pEntry->dwPreferredCardID,
                                            pEntry->dwOptions,
                                            TRUE
                                            );
                    
                if( SUCCEEDED(hr) )
                {
                    // Find position of 1st AREACODERULE structure in the LOCATIONLIST structure 
                    pAreaCodeRuleEntry = (PAREACODERULE) ((BYTE*)(pEntry) 
                                                          + pEntry->dwAreaCodeRulesListOffset );           
                   
                    dwNumRules = pEntry->dwNumAreaCodeRules;           
                
                    for (dwCount2 = 0; dwCount2 != dwNumRules; dwCount2++)
                    {
                        // Pull Rule Info out of AREACODERULE structure
                        pszAreaCode      = (PWSTR) ((BYTE*)(pEntry) 
                                                    + pAreaCodeRuleEntry->dwAreaCodeOffset);
                        pszNumberToDial  = (PWSTR) ((BYTE*)(pEntry) 
                                                    + pAreaCodeRuleEntry->dwNumberToDialOffset);
                        pszzPrefixesList = (PWSTR) ((BYTE*)(pEntry) 
                                                    + pAreaCodeRuleEntry->dwPrefixesListOffset);
        
                        // create our new AreaCodeRule Object                
                        pAreaCodeRule = new CAreaCodeRule;
                        if (pAreaCodeRule)
                        {
                            // initialize the new AreaCodeRule Object
                            hr = pAreaCodeRule->Initialize ( pszAreaCode,
                                                             pszNumberToDial,
                                                             pAreaCodeRuleEntry->dwOptions,
                                                             pszzPrefixesList, 
                                                             pAreaCodeRuleEntry->dwPrefixesListSize
                                                           );
                            if( SUCCEEDED(hr) )
                            {
                                pNewLocation->AddRule(pAreaCodeRule);
                            }
                            else // rule initialization failed
                            {
                                delete pAreaCodeRule;
                                LOG((TL_ERROR, "Initialize: CreateCurrentLoctionObject - rule create failed"));
                            }
                        } 
                        else // new CAreaCodeRule failed
                        {
                            LOG((TL_ERROR, "CreateCurrentLoctionObject - rule create failed"));
                        }
    
                        // Try next rule in list
                        pAreaCodeRuleEntry++;
                        
                    }

                    Add(pNewLocation);             

                }
                else // location initialize failed
                {
                    delete pNewLocation;
                    pNewLocation = NULL;
    
                    LOG((TL_ERROR, "CreateCurrentLoctionObject - location create failed"));
                }
            }
            else // new CLocation failed
            {
                LOG((TL_ERROR, "CreateCurrentLoctionObject - location create failed"));
    
            }

            // Try next location in list
            //pEntry++;
            pEntry = (PLOCATION) ((BYTE*)(pEntry) + pEntry->dwUsedSize);           

        }

    }
    else // ReadLocations failed
    {
        LOG((TL_ERROR, "CreateCurrentLoctionObject - ReadLocation create failed"));
    }

    // finished with TAPI memory block so release
    if ( pLocationList != NULL )
            ClientFree( pLocationList );

    return hr;
}


/****************************************************************************

    Class : CLocations         
   Method : SaveToRegistry
            Save object list back to registry via TAPISRV again

****************************************************************************/
HRESULT CLocations::SaveToRegistry(void)
{
    HRESULT         hr = S_OK;
     
    DWORD           dwTotalSizeNeeded = 0, dwNumEntries= 0 ;
    DWORD           dwSize=0, dwOffset = 0;
    CLocationNode * node = NULL; 
    CLocation     * pLocation = NULL;

    PLOCATIONLIST   pLocationList = NULL;
    PLOCATION       pEntry = NULL;

    // static size
    dwTotalSizeNeeded = sizeof(LOCATIONLIST);
    dwNumEntries = 0;

    // Now add in size of each Location (includes rules)
    node = m_LocationList.head(); 
    while( !node->beyond_tail() )
    {
        pLocation = node->value();
        if (pLocation != NULL)
        {
            dwSize= pLocation->TapiSize();
            dwTotalSizeNeeded += dwSize;
            if(dwSize)
            {
                // only save if dwSize >0, i.e. object has changed
                dwNumEntries++;
            }
        }
        node = node->next();
    }

    // Now add in size of each deleted Location
    node = m_DeletedLocationList.head(); 
    while( !node->beyond_tail() )
    {
        pLocation = node->value();
        if (pLocation != NULL)
        {
            dwSize= pLocation->TapiSize();
            dwTotalSizeNeeded += dwSize;
            if(dwSize)
            {
                // only save if dwSize > 0, i.e. object has changed
                dwNumEntries++;
            }
        }
        node = node->next();
    }


    // Allocate the memory buffer;
    pLocationList = (PLOCATIONLIST) ClientAlloc( dwTotalSizeNeeded );
    if (pLocationList != NULL)
    {
    
        // buffer size 
        pLocationList->dwTotalSize  = dwTotalSizeNeeded;
        pLocationList->dwNeededSize = dwTotalSizeNeeded;
        pLocationList->dwUsedSize   = dwTotalSizeNeeded;

        pLocationList->dwCurrentLocationID     = m_dwCurrentLocationID;
        pLocationList->dwNumLocationsAvailable = dwNumEntries;
        
        //list size & offset
        dwOffset   = sizeof(LOCATIONLIST);

        pLocationList->dwNumLocationsInList = dwNumEntries;
        pLocationList->dwLocationListSize   = dwTotalSizeNeeded - sizeof(LOCATIONLIST);
        pLocationList->dwLocationListOffset = dwOffset;



        // Now add in each Location (includes rules)
        node = m_LocationList.head(); 
        while( !node->beyond_tail() )
        {
            // point to the location entry in list
            pEntry = (PLOCATION)(((LPBYTE)pLocationList) + dwOffset);

            pLocation = node->value();
            if (pLocation != NULL)
            {
                // fill out structure
                dwOffset += pLocation->TapiPack(pEntry, dwTotalSizeNeeded - dwOffset);
            }

            node = node->next();
        }


        // Now add in each deleted Location 
        node = m_DeletedLocationList.head(); 
        while( !node->beyond_tail() )
        {
            // point to the location entry in list
            pEntry = (PLOCATION)(((LPBYTE)pLocationList) + dwOffset);

            pLocation = node->value();
            if (pLocation != NULL)
            {
                // fill out structure
                dwOffset += pLocation->TapiPack(pEntry, dwTotalSizeNeeded - dwOffset);
            }

            node = node->next();
        }


        WriteLocations( pLocationList,CHANGEDFLAGS_CURLOCATIONCHANGED);
    
        // finished with TAPI memory block so release
        if ( pLocationList != NULL )
        {
            ClientFree( pLocationList );
        }

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;

}


/****************************************************************************

    Class : CLocations         
   Method : Remove (with CLocation *)
            If location object was read from the registry we must keep it
            around so we can remove its entry when writing back to the registry.
            If it only existed in memory we can just delete it.

****************************************************************************/
void CLocations::Remove(CLocation * pLocation)
{
    CLocationNode *node = m_LocationList.head(); 

    while( !node->beyond_tail() )
    {
        if ( pLocation == node->value() ) 
        {
            node->remove();
            m_dwNumEntries--;
            
            pLocation->Changed();

            if( pLocation->FromRegistry() )
            {
                // set name to null so server knows to delete it
                pLocation->SetName(NULL);
                m_DeletedLocationList.tail()->insert_after(pLocation);
            }
            else
            {
                delete pLocation;
            }
            break;
        }

        node = node->next();
    }
    
}

/****************************************************************************

    Class : CLocations         
   Method : Remove (with DWORD)
            If location object was read from the registry we must keep it
            around so we can remove its entry when writing back to the registry.
            If it only existed in memory we can just delete it.

****************************************************************************/
void CLocations::Remove(DWORD dwID)
{
    CLocationNode *node = m_LocationList.head(); 
    CLocation   *pLocation;

    while( !node->beyond_tail() )
    {
        if ( dwID == node->value()->GetLocationID() ) 
        {
            pLocation = node->value();

            node->remove();
            m_dwNumEntries--;
            
            pLocation->Changed();

            if( pLocation->FromRegistry() )
            {
                // set name to null so server knows to delete it
                pLocation->SetName(NULL);
                m_DeletedLocationList.tail()->insert_after(pLocation);
            }
            else
            {
                delete pLocation;
            }
            break;
        }

        node = node->next();
    }
    
}



/****************************************************************************

    Class : CLocations         
   Method : Replace
            Replace pLocOld with pLocNew.  These locations must have the same
            location ID.

****************************************************************************/
void CLocations::Replace(CLocation * pLocOld, CLocation * pLocNew)
{
    if ( pLocOld->GetLocationID() != pLocNew->GetLocationID() )
    {
        LOG((TL_ERROR, "Replace: Illegal"));
        return;
    }

    CLocationNode *node = m_LocationList.head(); 

    while( !node->beyond_tail() )
    {
        if ( pLocOld == node->value() ) 
        {
//            node->remove();
//            m_LocationList.tail()->insert_after(pLocNew);
            node->value() = pLocNew;

            delete pLocOld;
            break;
        }

        node = node->next();
    }
}



/****************************************************************************

    Class : CLocations         
   Method : Add
            Put it in the list

****************************************************************************/
void CLocations::Add(CLocation * pLocation)
{
    m_LocationList.tail()->insert_after(pLocation); 
    m_dwNumEntries++;
    
}



/****************************************************************************

    Class : CLocations         
   Method : Reset
            Set enumerator to start    

****************************************************************************/
HRESULT CLocations::Reset(void)
{
    m_hEnumNode = m_LocationList.head();
    return S_OK;
}



/****************************************************************************

    Class : CLocations         
   Method : Next
            get next location in list

****************************************************************************/
HRESULT CLocations::Next(DWORD  NrElem, CLocation **ppLocation, DWORD *pNrElemFetched)
{
    DWORD   dwIndex = 0;
    
    if(pNrElemFetched == NULL && NrElem != 1)
        return E_INVALIDARG;

    if(ppLocation==NULL)
        return E_INVALIDARG;

    while( !m_hEnumNode->beyond_tail() && dwIndex<NrElem )
    {
        *ppLocation++ = m_hEnumNode->value();
        m_hEnumNode = m_hEnumNode->next();

        dwIndex++;
    }
    
    if(pNrElemFetched!=NULL)
        *pNrElemFetched = dwIndex;

    return dwIndex<NrElem ? S_FALSE : S_OK;
    
}



/****************************************************************************

    Class : CLocations         
   Method : Skip
            Miss a few    

****************************************************************************/
HRESULT CLocations::Skip(DWORD  NrElem)
{
    DWORD   dwIndex = 0;
    
    while( !m_hEnumNode->beyond_tail() && dwIndex<NrElem )
    {
        m_hEnumNode = m_hEnumNode->next();

        dwIndex++;
    }

    return dwIndex<NrElem ? S_FALSE : S_OK;
}





/*
 ***************************************************************************
 *********************                          ****************************
 ********************     CCountry Class         ***************************
 ********************       Definitions          ***************************
 *********************                          ****************************
 ***************************************************************************
*/


/****************************************************************************

    Class : CCountry         
   Method : Constructer

****************************************************************************/
CCountry::CCountry()
{
    m_dwCountryID = 0;
    m_dwCountryCode = 0;
    m_dwCountryGroup = 0;
    m_pszCountryName = NULL;
}



/****************************************************************************

    Class : CCountry         
   Method : Destructer

            Clean up memory allocations

****************************************************************************/
CCountry::~CCountry()
{
    if ( m_pszCountryName != NULL )
    {
         ClientFree(m_pszCountryName);
    }   
}



/****************************************************************************

    Class : CCountry         
   Method : Initialize

****************************************************************************/
STDMETHODIMP CCountry::Initialize
                  (                                         
                   DWORD dwCountryID,
                   DWORD dwCountryCode,
                   DWORD dwCountryGroup,
                   PWSTR pszCountryName,
                   PWSTR pszInternationalRule,
                   PWSTR pszLongDistanceRule,
                   PWSTR pszLocalRule
                  )
{
    HRESULT hr = S_OK;


    m_dwCountryID = dwCountryID;
    m_dwCountryCode = dwCountryCode; 
    m_dwCountryGroup = dwCountryGroup;
    
    m_pszCountryName = ClientAllocString( pszCountryName );
    if (m_pszCountryName == NULL)
    {
        LOG(( TL_ERROR, "Initialize - alloc pszLocationName failed" ));
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = m_Rules.Initialize(pszInternationalRule,
                           pszLongDistanceRule,
                           pszLocalRule
                          );
    
        if(FAILED(hr) )
        {    
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
                                                        




/*
 ***************************************************************************
 *********************                          ****************************
 ********************    CCountries Class        ***************************
 ********************       Definitions          ***************************
 *********************                          ****************************
 ***************************************************************************
*/


/****************************************************************************

    Class : CCountries         
   Method : Constructer

****************************************************************************/
CCountries::CCountries()
{
    m_dwNumEntries = 0;
    m_hEnumNode = m_CountryList.head();
    
}


/****************************************************************************

    Class : CCountries         
   Method : Destructer

****************************************************************************/
CCountries::~CCountries()
{
    CCountryNode *node;

    node = m_CountryList.head(); 

    while( !node->beyond_tail() )
    {
        delete node->value();
        node = node->next();
    }
    m_CountryList.flush();

}



/****************************************************************************

    Class : CCountries         
   Method : Initialize
            Read the countries list from registry via TAPISRV & build our 
            object list.


****************************************************************************/
HRESULT CCountries::Initialize(void)
{

    LPLINECOUNTRYLIST_INTERNAL pCountryList = NULL;
    
    LPLINECOUNTRYENTRY_INTERNAL pEntry = NULL;
    PWSTR               pszCountryName = NULL;          
    PWSTR               pszInternationalRule = NULL;     
    PWSTR               pszLongDistanceRule = NULL;     
    PWSTR               pszLocalRule = NULL;            
    CCountry          * pCountry = NULL;
    
    DWORD               dwCount = 0;
    DWORD               dwNumEntries = 0;
    LONG                lResult;
    HRESULT             hr;
    


    lResult = ReadCountriesAndGroups( &pCountryList, 0, 0);
    if (lResult == 0) 
    {
         
        // Find position of 1st LINECOUNTRYENTRY structure in the LINECOUNTRYLIST structure 
        pEntry = (LPLINECOUNTRYENTRY_INTERNAL) ((BYTE*)(pCountryList) + pCountryList->dwCountryListOffset );           
    
        dwNumEntries =  pCountryList->dwNumCountries;
        for (dwCount = 0; dwCount < dwNumEntries ; dwCount++)
        {

            // Pull Country Info out of LINECOUNTRYENTRY structure
            pszCountryName       = (PWSTR) ((BYTE*)(pCountryList) 
                                                   + pEntry->dwCountryNameOffset);
            pszInternationalRule = (PWSTR) ((BYTE*)(pCountryList) 
                                                   + pEntry->dwInternationalRuleOffset);
            pszLongDistanceRule  = (PWSTR) ((BYTE*)(pCountryList) 
                                                 + pEntry->dwLongDistanceRuleOffset);
            pszLocalRule         = (PWSTR) ((BYTE*)(pCountryList) 
                                                   + pEntry->dwSameAreaRuleOffset);
        
        
            // create our new CCountry Object                
            pCountry = new CCountry;
            if (pCountry)
            {
                // initialize the new CCountry Object
                hr = pCountry->Initialize(pEntry->dwCountryID,
                                          pEntry->dwCountryCode,
                                          pEntry->dwCountryGroup,
                                          pszCountryName,
                                          pszInternationalRule,
                                          pszLongDistanceRule,
                                          pszLocalRule
                                         );

                if( SUCCEEDED(hr) )
                {
                    m_CountryList.tail()->insert_after(pCountry);
                    m_dwNumEntries++;
                }
                else // country initialization failed
                {
                    delete pCountry;
                    LOG((TL_ERROR, "Initialize - country create failed"));
                }
            } 
            else // new CCountry failed
            {
                LOG((TL_ERROR, "Initialize - country create failed"));
            }

            // Try next country in list
            pEntry++;
        }
    }
    else // ReadLocations failed
    {
        LOG((TL_ERROR, "Initialize - ReadCountries failed"));
        hr = (HRESULT)lResult;
    }

    // finished with TAPI memory block so release
    if ( pCountryList != NULL )
    {
        ClientFree( pCountryList );
    }

    return hr;

}



/****************************************************************************

    Class : CCountries         
   Method : Reset

****************************************************************************/
HRESULT CCountries::Reset(void)
{
    m_hEnumNode = m_CountryList.head();
    return S_OK;
}



/****************************************************************************

    Class : CCountries         
   Method : Next

****************************************************************************/
HRESULT CCountries::Next(DWORD  NrElem, CCountry **ppCcountry, DWORD *pNrElemFetched)
{
    DWORD   dwIndex = 0;
    
    if(pNrElemFetched == NULL && NrElem != 1)
        return E_INVALIDARG;

    if(ppCcountry==NULL)
        return E_INVALIDARG;

    while( !m_hEnumNode->beyond_tail() && dwIndex<NrElem )
    {
        *ppCcountry++ = m_hEnumNode->value();
        m_hEnumNode = m_hEnumNode->next();

        dwIndex++;
    }
    
    if(pNrElemFetched!=NULL)
        *pNrElemFetched = dwIndex;

    return dwIndex<NrElem ? S_FALSE : S_OK;
    
}



/****************************************************************************

    Class : CCountries         
   Method : Skip

****************************************************************************/
HRESULT CCountries::Skip(DWORD  NrElem)
{
    DWORD   dwIndex = 0;
    
    while( !m_hEnumNode->beyond_tail() && dwIndex<NrElem )
    {
        m_hEnumNode = m_hEnumNode->next();

        dwIndex++;
    }

    return dwIndex<NrElem ? S_FALSE : S_OK;
}
























/*
 ***************************************************************************
 *********************                          ****************************
 ********************          Helper            ***************************
 ********************         Functions          ***************************
 *********************                          ****************************
 ***************************************************************************
*/






/****************************************************************************

 Function : ApplyRule
            Parse though a tapi rule string & build dialable & displayable
            strings from the required components.

            out pszDialString      
                pszDisplayString
            
            in  pszRule
                pszLongDistanceCarrier
                pszInternationalCarrier
                pszCountry
                pszCity
                pszSubscriber
                pszCardName
                pszCardAccessNumber
                pszCardAccountNumber
                pszCardPINNumber

****************************************************************************/
LONG ApplyRule (PWSTR pszDialString,
                PWSTR pszDisplayString,
                PWSTR pszRule,
                PWSTR pszDestLDRule,
                PWSTR pszLongDistanceCarrier,
                PWSTR pszInternationalCarrier,
                PWSTR pszCountry,
                PWSTR pszCity,     
                PWSTR pszSubscriber,
                PWSTR pszCardName,
                PWSTR pszCardAccessNumber,
                PWSTR pszCardAccountNumber,
                PWSTR pszCardPINNumber
                )
{
    WCHAR  * pRuleChar;
    DWORD    dwEndString;
    PWSTR    pszAdjustedCity;
    PWSTR    pszSubaddress;
    WCHAR    wcSubaddrSep;

    BOOL    bSpaceExists, bOutOfMem = FALSE;
    
    bSpaceExists = TRUE;

    HRESULT hr;

    for (pRuleChar = pszRule; *pRuleChar != '\0' && !bOutOfMem; pRuleChar++)
    {
        switch(*pRuleChar)
        {
            //Dial the Long Distance Carrier Code
            case 'L':
            case 'l':
            case 'N':
            case 'n':
            {
                if (pszLongDistanceCarrier)
                {
                    hr = StringCchCatExW(pszDialString, MaxDialStringSize, pszLongDistanceCarrier, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);

                    if (!bSpaceExists)
                    {
                        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                        bOutOfMem = bOutOfMem && FAILED(hr);
                    }
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, pszLongDistanceCarrier, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);
                    bSpaceExists = TRUE;
                }
                break;
            }
            //Dial the International Carrier Code
            case 'M':
            case 'm':
            case 'S':
            case 's':
            {
                if (pszInternationalCarrier)
                {
                    hr = StringCchCatExW(pszDialString, MaxDialStringSize, pszInternationalCarrier, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);

                    if (!bSpaceExists)
                    {
                        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                        bOutOfMem = bOutOfMem && FAILED(hr);
                    }
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, pszInternationalCarrier, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);
                    bSpaceExists = TRUE;
                }
                break;
            }
            // Dial the Country Code
            case 'E':
            case 'e':
            {
                hr = StringCchCatExW(pszDialString, MaxDialStringSize, pszCountry, NULL, NULL, STRSAFE_NO_TRUNCATION);
                bOutOfMem = bOutOfMem && FAILED(hr);

                if(!bSpaceExists)
                {
                     hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                     bOutOfMem = bOutOfMem && FAILED(hr);
                }
                hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, pszCountry, NULL, NULL, STRSAFE_NO_TRUNCATION);
                bOutOfMem = bOutOfMem && FAILED(hr);
                hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                bOutOfMem = bOutOfMem && FAILED(hr);
                bSpaceExists = TRUE;
                break;
            }

            // Dial the City/Area Code
            case 'F':
            case 'f':
            case 'I':
            case 'i':
            {
                // adjust the area code (see bug 279092)
                pszAdjustedCity = SkipLDAccessDigits(pszCity, pszDestLDRule);

                if(pszAdjustedCity && *pszAdjustedCity!=L'\0')
                {
                    hr = StringCchCatExW(pszDialString, MaxDialStringSize, pszAdjustedCity, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);
                
                    if(!bSpaceExists)
                    {
                        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                        bOutOfMem = bOutOfMem && FAILED(hr);
                    }
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, pszAdjustedCity, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);
                    bSpaceExists = TRUE;
                }
                break;
            }
            
            // Dial the Subscriber Number
            case 'G':
            case 'g':
            {
                // we let through digits & "AaBbCcDdPpTtWw*#!,@$?;()"
                // but after a '|' or '^' we let all through

                pszSubaddress = pszSubscriber + wcscspn(pszSubscriber, (PWSTR)csSCANSUB);
                wcSubaddrSep = *pszSubaddress;
                *pszSubaddress = L'\0';
                
                if(AppendDigits( pszDialString, pszSubscriber, (PWSTR)csBADCO))
                {
                    bOutOfMem = TRUE;
                }
                else
                {
                    if(wcSubaddrSep != L'\0')
                    {
                        *pszSubaddress = wcSubaddrSep;
                        hr = StringCchCatExW(pszDialString, MaxDialStringSize, pszSubaddress, NULL, NULL, STRSAFE_NO_TRUNCATION);
                        bOutOfMem = bOutOfMem && FAILED(hr);
                    }
                    
                    if(!bSpaceExists)
                    {
                        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                        bOutOfMem = bOutOfMem && FAILED(hr);
                    }
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, pszSubscriber, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);
                    bSpaceExists = FALSE;
                }
                break;
            }

            // Dial the Calling Card Access Number
            case 'J':
            case 'j':
            {
                // just let through digits
                if (AppendDigits( pszDialString, pszCardAccessNumber, L""))
                {
                    bOutOfMem = TRUE;
                }
                else
                {
                    if(!bSpaceExists)
                    {
                        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                        bOutOfMem = bOutOfMem && FAILED(hr);
                    }
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, pszCardAccessNumber, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);
                    bSpaceExists = TRUE;
                }
                break;
            }

            // Dial the Calling Card Account Number
            case 'K':
            case 'k':
            {
                // just let through digits
                if (AppendDigits( pszDialString, pszCardAccountNumber, L""))
                {
                    bOutOfMem = TRUE;
                }
                else
                {
                    if(!bSpaceExists)
                    {
                        hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                        bOutOfMem = bOutOfMem && FAILED(hr);
                    }
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L"[", NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, pszCardName, NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L"] ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);
                    bSpaceExists = TRUE;
                }
                break;
            }

            // Dial the Calling Card PIN Number
            case 'H':
            case 'h':
            {
                hr = StringCchCatExW(pszDialString, MaxDialStringSize, pszCardPINNumber, NULL, NULL, STRSAFE_NO_TRUNCATION);
                bOutOfMem = bOutOfMem && FAILED(hr);

                if(!bSpaceExists)
                {
                    hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L" ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                    bOutOfMem = bOutOfMem && FAILED(hr);
                }
                hr = StringCchCatExW(pszDisplayString, MaxDialStringSize, L"**** ", NULL, NULL, STRSAFE_NO_TRUNCATION);
                bOutOfMem = bOutOfMem && FAILED(hr);
                bSpaceExists = TRUE;
                break;
            }

            // Just append the character to the dial/display string
            default:
            {
                dwEndString = lstrlenW(pszDialString);
                if (dwEndString < MaxDialStringSize - 1)
                {
                    pszDialString[dwEndString] = *pRuleChar;
                    pszDialString[dwEndString+1] = '\0';
                }
                else
                {
                    bOutOfMem = TRUE;
                }

                // don't display certain chars
                if (!wcschr(csDISPSUPRESS,*pRuleChar))
                {
                    dwEndString = lstrlenW(pszDisplayString);
                    if (dwEndString < MaxDialStringSize - 1)
                    {
                        pszDisplayString[dwEndString] = *pRuleChar;
                        pszDisplayString[dwEndString+1] = '\0';
                    }
                    else
                    {
                        bOutOfMem = TRUE;
                    }
                }
                bSpaceExists = FALSE;
                break;
            }
        }

        
    }

    if (bOutOfMem)
    {
        return LINEERR_NOMEM;
    }

    return 0;
}



/****************************************************************************

 Function : TapiPackString
            Takes a string & copys it to a tapi location + offset
            updates the entry offset & size dwords
            returns size of copied string (used to adjust offset for next string)

****************************************************************************/
DWORD TapiPackString(LPBYTE pStructure, 
                     DWORD dwOffset, 
                     DWORD dwTotalSize,
                     PWSTR pszString,
                     PDWORD pdwOffset,
                     PDWORD pdwSize
                     )
{
    DWORD dwSize;

    dwSize = ALIGN((lstrlenW(pszString) + 1) * sizeof(WCHAR));
    if (NULL != pszString)
    {
        StringCchCopyEx((PWSTR)(pStructure + dwOffset), (dwTotalSize - dwOffset)/sizeof(WCHAR), pszString, NULL, NULL, STRSAFE_NO_TRUNCATION);
    }
    else
    {
        *(PWSTR)(pStructure + dwOffset) = L'\0';        
    }

    *pdwOffset = dwOffset;
    *pdwSize = dwSize;

    return dwSize;
}



/****************************************************************************

 Function : PrefixMatch
            Checks if Subscriber number starts with the given prefix
            Takes into account the only the digits.
            returns FALSE if not matched, else TRUE & number of matched chars

****************************************************************************/
BOOL PrefixMatch(PWSTR pszPrefix,PWSTR pszSubscriberString, PDWORD pdwMatched)
{
    DWORD dwCount =0;
    PWSTR pPrefixChar = pszPrefix;
    PWSTR pSSChar = pszSubscriberString;

    // The prefix must be contiguous (without commas etc.)
    while( (*pPrefixChar != '\0') && (*pSSChar != '\0') )
    {

        if(iswdigit(*pSSChar))
        {
            if(*pPrefixChar == *pSSChar) 
            {
                dwCount++;
                pPrefixChar++;
                pSSChar++;
            }
            else // no match
            {
                dwCount= 0;
                break;
            }
        }
        else
        {
            // This was not a digit, skip it
            pSSChar++;
        }
    }

    // just in case subscriber string was shorter than the prefix
    if(*pPrefixChar != '\0')
    {
        dwCount = 0;
    }

    // return values
    *pdwMatched = dwCount;

    if(dwCount !=0)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}





/****************************************************************************

 Function : AppendDigits
            Copies only digits up to end of string. 
            Simply exit if string is NULL

****************************************************************************/
LONG AppendDigits( PWSTR pDest,
                   PWSTR pSrc,
                   PWSTR pValidChars
                 )
{
    WCHAR  * pSrcChar;
    WCHAR  * pDestChar;
    LONG     lReturn = 0;

    if (pSrc != NULL)
    {
        pDestChar = pDest + lstrlenW(pDest);
        pSrcChar  = pSrc;

        while (*pSrcChar != '\0' && (pDestChar - pDest < MaxDialStringSize - 1))
        {
            if ( iswdigit(*pSrcChar) || (wcschr(pValidChars, *pSrcChar)) )
            {
                *pDestChar++ = *pSrcChar;
            }
            pSrcChar++;
        }
        if (*pSrcChar != '\0')
        {
            lReturn = LINEERR_NOMEM;
        }
    }
    return lReturn;
}


/****************************************************************************

 Function : AreaCodeMatch
            Compares two areas codes. Returns TRUE if they are the same.
            Adjusts internally the area codes using the LD rule given as a parameter. 
            See bug 279092

****************************************************************************/
BOOL AreaCodeMatch(PWSTR pszAreaCode1, PWSTR pszAreaCode2, PWSTR pszRule)
{
    PWSTR   pszAdjustedAreaCode1;
    PWSTR   pszAdjustedAreaCode2;
	BOOL	bRet = FALSE;

    pszAdjustedAreaCode1 = SkipLDAccessDigits(pszAreaCode1, pszRule);
    pszAdjustedAreaCode2 = SkipLDAccessDigits(pszAreaCode2, pszRule);

	if (NULL != pszAdjustedAreaCode1 &&
		NULL != pszAdjustedAreaCode2)
	{
		bRet = (0==lstrcmpW(pszAdjustedAreaCode1, pszAdjustedAreaCode2));
	}

	return bRet;
}



/****************************************************************************

 Function : SkipLDAccessDigits
            Skips the characters from an area code which corespond to a LD access prefix
            Returns a pointer to the correct area code.
            Presumes that the first digits of the rule are in fact the LD acces prefix.
            See bug 279092

****************************************************************************/

PWSTR SkipLDAccessDigits(PWSTR pszAreaCode, PWSTR pszLDRule)
{

    if(pszAreaCode!=NULL)
    {

        // A space in the rule prevents the matching/striping mechanism
        // Uncomment if you don't want that.
        // while(*pszLDRule == L' ')
        //  pszLDRule++;

        //
        // A long distance rule may have a L/l or N/n at the beginning, need to skip it
        //
        if (*pszLDRule == L'L' ||
            *pszLDRule == L'l' ||
            *pszLDRule == L'N' ||
            *pszLDRule == L'n'
           )
        {
            pszLDRule++;
        }

        while(*pszLDRule && iswdigit(*pszLDRule) && *pszAreaCode==*pszLDRule)
        {
            pszAreaCode++;
            pszLDRule++;
        }
    }
    return pszAreaCode;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\resource.h ===
/****************************************************************************
 
  Copyright (c) 1999 Microsoft Corporation
                                                              
  Module Name:  resource.h
                                                
***************************************************************************/


#ifndef CLIENT_RESOURCE
#define CLIENT_RESOURCE

#define IDS_DEFAULT_STATUS 1000
#define IDS_LOGONDESKNAME  1001

#endif // CLIENT_RESOURCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\perfctr.h ===
/****************************************************************************
 
  Copyright (c) 1996-1999 Microsoft Corporation
                                                              
  Module Name:  perfctr.h
              
****************************************************************************/

//
//  Offset definition file for extensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the 
//  "First Counter" and "First Help" values for the device they belong to, 
//  in order to determine the absolute location of the counter and 
//  object names and corresponding Explain text in the registry.
//
//  This file is used by the extensible counter DLL code as well as the 
//  counter name and Explain text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define TAPIOBJ                 0
#define NUMLINES                2
#define CURRENTOPENS            4
#define TOTALOUTGOINGCALLS      6
#define TOTALINCOMINGCALLS      8
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\rules.h ===
/****************************************************************************
 
  Copyright (c) 1998  Microsoft Corporation
                                                              
  Module Name:  rules.h
                                                              
     Abstract:  Rules Object definitions
                                                              
       Author:  noela - 09/11/98
              

        Notes:

        
  Rev History:

****************************************************************************/

#ifndef __RULES_H_
#define __RULES_H_

#include "utils.h"
#include "list.h"
#include "loc_comn.h"
#include "client.h"
#include "clntprivate.h"
class CAreaCodeProcessingRule;



//***************************************************************************
//
//  Class Definition - CRuleSet
//
//***************************************************************************
class CRuleSet
{

public:
    PWSTR   m_pszInternationalRule;
    PWSTR   m_pszLongDistanceRule;
    PWSTR   m_pszLocalRule;


    CRuleSet();
    ~CRuleSet();

#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CRuleSet)
#endif

    STDMETHOD(Initialize) ( PWSTR pszInternationalRule,
                            PWSTR pszLongDistanceRule,
                            PWSTR pszLocalRule
                          ); 

};



//***************************************************************************
//
//  Class Definition - CAreaCodeRule
//
//***************************************************************************
class CAreaCodeRule
{
private:

    PWSTR               m_pszAreaCode;
    PWSTR               m_pszNumberToDial;
    DWORD               m_dwOptions;
    PWSTR               m_pszzPrefixList;   // contains  REG_MULTI_SZ  data
                                            // An array of null-terminated strings,
                                            //  terminated by two null characters. 
    DWORD               m_dwPrefixListSize; // Size, in bytes, of the prefix list



public:
    CAreaCodeRule(); 
    ~CAreaCodeRule();

#ifdef TRACELOG
	DECLARE_TRACELOG_CLASS(CAreaCodeRule)
#endif

    STDMETHOD(Initialize) ( PWSTR pszAreaCode,
                            PWSTR pszNumberToDial,
                            DWORD dwOptions,
                            PWSTR pszzPrefixList, 
                            DWORD dwPrefixListSize
                           );


    BOOL HasDialAreaCode() {return  m_dwOptions & RULE_DIALAREACODE;}
    void SetDialAreaCode(BOOL bDa);

    BOOL HasDialNumber() {return  m_dwOptions & RULE_DIALNUMBER;}
    void SetDialNumber(BOOL bDn);

    BOOL HasAppliesToAllPrefixes(){return  m_dwOptions & RULE_APPLIESTOALLPREFIXES;}                        
    void SetAppliesToAllPrefixes(BOOL bApc);
   
    PWSTR GetAreaCode(){return m_pszAreaCode;}
    STDMETHOD (SetAreaCode)(PWSTR pszAreaCode);

    PWSTR GetNumberToDial(){return m_pszNumberToDial;}
    STDMETHOD (SetNumberToDial)(PWSTR pszNumberToDial);
   
    DWORD GetPrefixListSize(){return m_dwPrefixListSize;}
    PWSTR GetPrefixList(){return m_pszzPrefixList;}
    STDMETHOD (SetPrefixList)(PWSTR pszzPrefixList, DWORD dwSize);
    DWORD TapiSize();
    DWORD GetOptions(){return m_dwOptions;}

    void BuildProcessingRule(CAreaCodeProcessingRule * pRule);

    
};

/////////////////////////////////////////////
// Fill out the list template
//
 
typedef LinkedList<CAreaCodeRule*> AreaCodeRulePtrList;
typedef ListNode<CAreaCodeRule*>   AreaCodeRulePtrNode;









//***************************************************************************

STDMETHODIMP CreateDialingRule
                            ( 
                              PWSTR *pszRule,
                              PWSTR pszNumberToDial,
                              BOOL bDialAreaCode
                            );


                            

#if DBG
#define ClientAllocString( __psz__ ) ClientAllocStringReal( __psz__, __LINE__, __FILE__ )
PWSTR ClientAllocStringReal(PCWSTR psz, 
                            DWORD dwLine,
                            PSTR  pszFile
                           );

#else

#define ClientAllocString( __psz__ ) ClientAllocStringReal( __psz__ )
PWSTR ClientAllocStringReal(PCWSTR psz );

#endif


#endif //__RULES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\rules.cpp ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  rules.cpp
                                                              
     Abstract:  Rules Object implementation
                                                              
       Author:  noela - 09/11/98
              

        Notes:

        
  Rev History:

****************************************************************************/

//#define unicode
#include <windows.h>
#include <objbase.h>

#include "tapi.h"
#include "tspi.h"
#include "utils.h"
#include "client.h"
#include "rules.h"





/****************************************************************************

    Class : CRuleSet         
   Method : Constructer

****************************************************************************/
CRuleSet::CRuleSet()
{
    m_pszInternationalRule = NULL;
    m_pszLongDistanceRule = NULL;
    m_pszLocalRule = NULL;
}



/****************************************************************************

    Class : CRuleSet         
   Method : Destructer

            Clean up memory allocations

****************************************************************************/
CRuleSet::~CRuleSet()
{
    if ( m_pszInternationalRule != NULL )
    {
         ClientFree(m_pszInternationalRule);
    }   

    if ( m_pszLongDistanceRule != NULL )
    {
         ClientFree(m_pszLongDistanceRule);
    }   

    if ( m_pszLocalRule != NULL )
    {
         ClientFree(m_pszLocalRule);
    }   
}



/****************************************************************************

    Class : CRuleSet         
   Method : Initialize

****************************************************************************/
STDMETHODIMP CRuleSet::Initialize
                  (
                   PWSTR pszInternationalRule,
                   PWSTR pszLongDistanceRule,
                   PWSTR pszLocalRule
                  )
{
    //////////////////////////////////////////////////
    // copy the international Rule
    //
    m_pszInternationalRule = ClientAllocString( pszInternationalRule );
    if (m_pszInternationalRule == NULL)
    {
        LOG(( TL_ERROR, "Initialize create m_pszInternationalRule failed" ));
        return E_OUTOFMEMORY;
    }


    //////////////////////////////////////////////////
    // copy the long Distance Rule
    //
    m_pszLongDistanceRule = ClientAllocString( pszLongDistanceRule );
    if (m_pszLongDistanceRule == NULL)
    {
        ClientFree(m_pszInternationalRule);

        LOG(( TL_ERROR, "Initialize create m_pszLongDistanceRule failed" ));
        return E_OUTOFMEMORY;
    }

    
    //////////////////////////////////////////////////
    // copy the local Rule
    //
    m_pszLocalRule = ClientAllocString( pszLocalRule );
    if (m_pszLocalRule == NULL)
    {
        ClientFree(m_pszInternationalRule);
        ClientFree(m_pszLongDistanceRule);
        
        LOG(( TL_ERROR, "Initialize create m_pszLocalRule failed" ));
        return E_OUTOFMEMORY;
    }
        

    return S_OK;
    
}



/****************************************************************************
/****************************************************************************


/****************************************************************************

    Class : CAreaCodeRule         
   Method : Constructer

****************************************************************************/
CAreaCodeRule::CAreaCodeRule()
{
    m_pszAreaCode = NULL;
    m_pszNumberToDial = NULL;
    m_pszzPrefixList = NULL;
}



/****************************************************************************

    Class : CAreaCodeRule         
   Method : Destructer

            Clean up memory allocations

****************************************************************************/
CAreaCodeRule::~CAreaCodeRule()
{
    if ( m_pszAreaCode != NULL )
    {
         ClientFree(m_pszAreaCode);
    }   

    if ( m_pszNumberToDial != NULL )
    {
         ClientFree(m_pszNumberToDial);
    }   

    if ( m_pszzPrefixList != NULL )
    {
         ClientFree(m_pszzPrefixList);
    }   

}



/****************************************************************************

    Class : CAreaCodeRule         
   Method : Initialize

****************************************************************************/
STDMETHODIMP CAreaCodeRule::Initialize
                                    ( 
                                      PWSTR pszAreaCode,
                                      PWSTR pszNumberToDial,
                                      DWORD dwOptions,
                                      PWSTR pszzPrefixList, 
                                      DWORD dwPrefixListSize
                                    )
{
    
    HRESULT hr = S_OK;

    
    //////////////////////////////////////////////////
    // copy the AreaCode
    //
    m_pszAreaCode = ClientAllocString( pszAreaCode );
    if (m_pszAreaCode == NULL)
    {
        LOG(( TL_ERROR, "Initialize create m_pszAreaCode failed" ));
        return E_OUTOFMEMORY;
    }

    m_pszNumberToDial = ClientAllocString( pszNumberToDial );
    if (m_pszNumberToDial == NULL)
    {
        LOG(( TL_ERROR, "Initialize create m_pszNumberToDial failed" ));
        return E_OUTOFMEMORY;
    }

    m_dwOptions = dwOptions;

    SetPrefixList(pszzPrefixList, dwPrefixListSize);

    return hr;

}




/****************************************************************************

    Class : CAreaCodeRule         
   Method : SetAreaCode

****************************************************************************/
STDMETHODIMP CAreaCodeRule::SetAreaCode(PWSTR pszAreaCode)
{
    HRESULT hr = S_OK;


    if (m_pszAreaCode != NULL)
        {
        ClientFree(m_pszAreaCode);
        m_pszAreaCode = NULL;
        }

    if(pszAreaCode != NULL)
    {
        m_pszAreaCode = ClientAllocString( pszAreaCode );
        if (m_pszAreaCode == NULL)
        {
            LOG(( TL_ERROR, "SetAreaCode - alloc failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;

}


/****************************************************************************

    Class : CAreaCodeRule         
   Method : SetAreaCode

****************************************************************************/
STDMETHODIMP CAreaCodeRule::SetNumberToDial(PWSTR pszNumberToDial)
{
    HRESULT hr = S_OK;


    if (m_pszNumberToDial != NULL)
        {
        ClientFree(m_pszNumberToDial);
        m_pszNumberToDial = NULL;
        }

    if(pszNumberToDial != NULL)
    {
        m_pszNumberToDial = ClientAllocString( pszNumberToDial );
        if (m_pszNumberToDial == NULL)
        {
            LOG(( TL_ERROR, "SetNumberToDial - alloc failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;

}
   


/****************************************************************************

    Class : CAreaCodeRule         
   Method : SetPrefixList

****************************************************************************/
STDMETHODIMP CAreaCodeRule::SetPrefixList(PWSTR pszzPrefixList, DWORD dwSize)
{
    HRESULT hr = S_OK;


    if (m_pszzPrefixList != NULL)
        {
        ClientFree(m_pszzPrefixList);
        m_pszzPrefixList = NULL;
        m_dwPrefixListSize = 0;
        }

    if(pszzPrefixList != NULL)
    {
        m_pszzPrefixList = (PWSTR) ClientAlloc(dwSize);
        if (m_pszzPrefixList != NULL)
        {
            CopyMemory(m_pszzPrefixList, pszzPrefixList, dwSize);
            // set the size !
            m_dwPrefixListSize = dwSize;

        }
        else    
        {
            LOG(( TL_ERROR, "SetPrefixList - alloc  failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;

}



/****************************************************************************

    Class : CAreaCodeRule         
   Method : UseCallingCard

****************************************************************************/
void CAreaCodeRule::SetDialAreaCode(BOOL bDa) 
{
    if(bDa)
    {    
        m_dwOptions |= RULE_DIALAREACODE;
    }
    else
    {
        m_dwOptions &= ~RULE_DIALAREACODE;
    }
}



/****************************************************************************

    Class : CAreaCodeRule         
   Method : UseCallingCard

****************************************************************************/
void CAreaCodeRule::SetDialNumber(BOOL bDn) 
{
    if(bDn)
    {    
        m_dwOptions |= RULE_DIALNUMBER;
    }
    else
    {
        m_dwOptions &= ~RULE_DIALNUMBER;
    }
}



/****************************************************************************

    Class : CAreaCodeRule         
   Method : UseCallingCard

****************************************************************************/
void CAreaCodeRule::SetAppliesToAllPrefixes(BOOL bApc) 
{
    if(bApc)
    {    
        m_dwOptions |= RULE_APPLIESTOALLPREFIXES;
    }
    else
    {
        m_dwOptions &= ~RULE_APPLIESTOALLPREFIXES;
    }
}


/****************************************************************************

    Class : CAreaCodeRule         
   Method : TapiSize
            Number of bytes needed to pack this into a TAPI structure to send
            to TAPISRV

****************************************************************************/
DWORD CAreaCodeRule::TapiSize()
{
    DWORD dwSize=0;

    // Calc size ofArea Code Rule
    dwSize = sizeof(AREACODERULE);
    dwSize += ALIGN((lstrlenW(m_pszAreaCode) + 1) * sizeof(WCHAR));
    dwSize += ALIGN((lstrlenW(m_pszNumberToDial) + 1) * sizeof(WCHAR));
    dwSize += ALIGN(m_dwPrefixListSize);

    return dwSize;
}









/****************************************************************************
/****************************************************************************



/****************************************************************************

 Function : CreateDialingRule
            Create TAPI dialing rule - "xxxxFG" from number to dial
            & area code if required & subcriber number

****************************************************************************/
STDMETHODIMP CreateDialingRule
                            ( 
                              PWSTR * pszRule,
                              PWSTR pszNumberToDial,
                              BOOL bDialAreaCode
                            )

{
    HRESULT hr = S_OK;
	PWSTR pszRule1= NULL;

    //////////////////////////////////////////////////
    // Create the dialing Rule
    // alloc enough space for number + "FG"
    //
    pszRule1 = (PWSTR) ClientAlloc(
                                  (lstrlenW(pszNumberToDial) + 3 ) 
                                  * sizeof (WCHAR)
                                 );
    if (pszRule1 != NULL)
    {
        // copy number "xxxx"
        if(pszNumberToDial != NULL)                                         
        {
            lstrcpyW(pszRule1, pszNumberToDial);
        }
        
        // Area code ?  "xxxxF"
        if (bDialAreaCode)
        {
            lstrcatW(pszRule1, L"F");   
        }
        
        // Subcriber Nmber "xxxxFG" or "xxxxG"
        lstrcatW(pszRule1, L"G");  

    }
    else    
    {
        LOG(( TL_ERROR, "CreateDialingRule - Alloc pszRule failed" ));
        hr = E_OUTOFMEMORY;
    }

	*pszRule = pszRule1;
    return hr;
}




/****************************************************************************

 Function : ClientAllocString
            Copys string.         
            Allocate space for new string using ClientAlloc
            Returns pointer to new string or NULL

****************************************************************************/
#if DBG
    PWSTR ClientAllocStringReal(PCWSTR psz, 
                                DWORD dwLine,
                                PSTR  pszFile
                               )
#else
    PWSTR ClientAllocStringReal(PCWSTR psz )
#endif
{
    PWSTR pszNewString = NULL;

    if (psz != NULL)
    {
        #if DBG
            pszNewString = (PWSTR) ClientAllocReal((lstrlenW(psz)+1)* sizeof (WCHAR),dwLine,pszFile );
        #else
            pszNewString = (PWSTR) ClientAlloc((lstrlenW(psz)+1)* sizeof (WCHAR) );
        #endif
        if (pszNewString != NULL)
        {
            lstrcpyW(pszNewString, psz);
        }
        else    
        {
            LOG(( TL_ERROR, "ClientAllocString Alloc string failed" ));
        }
    }

    return pszNewString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\tapimmc.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    tapimmc.c

Abstract:

    Client-side implementation of TAPI MMC support APIs

Author:

    Dan Knudson (DanKn)    10-Dec-1997

Revision History:


Notes:

--*/

#include "windows.h"
#include "stdarg.h"
#include "stdio.h"
#include "tapi.h"
#include "tspi.h"
#include "utils.h"
#include "tapimmc.h"
#include "client.h"
#include "clntprivate.h"
#include "tapsrv.h"
#include "lmcons.h"
#include "resource.h"

#define MMCAPP_KEY ((DWORD) 'CmMt')


typedef struct _MMCAPP
{
    DWORD       dwKey;

    BOOL        bLocal;

    HLINEAPP                hLineApp;

    DWORD       dwAPIVersion;

    HANDLE      hReinitializeEvent;

    PCONTEXT_HANDLE_TYPE    phCtx;       //  RPC handle context

    BOOL        bNoServiceControl;

} MMCAPP, *PMMCAPP;


LONG
WINAPI
FreeClientResources(
    void
    );


PMMCAPP
PASCAL
IsValidMmcApp(
    HMMCAPP hMmcApp
    )
{
    PMMCAPP pMmcApp = NULL;

    try
    {
        if (((PMMCAPP) hMmcApp)->dwKey == MMCAPP_KEY)
        {
            pMmcApp = (PMMCAPP) hMmcApp;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        // do nothing
    }

    return pMmcApp;
}


LONG
WINAPI
MMCAddProvider(
    HMMCAPP hMmcApp,
    HWND    hwndOwner,
    LPCWSTR lpszProviderFilename,
    LPDWORD lpdwProviderID
    )
{
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        lResult = lineAddProviderW(
            lpszProviderFilename,
            hwndOwner,
            lpdwProviderID
            );
    }
    else
    {
        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = lineAddProviderW(
            lpszProviderFilename,
            hwndOwner,
            lpdwProviderID
            );
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}


LONG
WINAPI
MMCConfigProvider(
    HMMCAPP hMmcApp,
    HWND    hwndOwner,
    DWORD   dwProviderID
    )
{
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        lResult = lineConfigProvider (hwndOwner, dwProviderID);
    }
    else
    {
        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = lineConfigProvider (hwndOwner, dwProviderID);
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}


LONG
WINAPI
MMCGetAvailableProviders(
    HMMCAPP                 hMmcApp,
    LPAVAILABLEPROVIDERLIST lpProviderList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, mGetAvailableProviders),

        {
            (ULONG_PTR) 0,
            (ULONG_PTR) lpProviderList
        },

        {
            hXxxApp,
            lpGet_Struct
        }
    };
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        lResult = DOFUNC (&funcArgs, "GetAvailableProviders");
    }
    else
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = DOFUNC (&funcArgs, "GetAvailableProviders");
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}


LONG
WINAPI
MMCGetLineInfo(
    HMMCAPP             hMmcApp,
    LPDEVICEINFOLIST    lpDeviceInfoList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, mGetLineInfo),

        {
            (ULONG_PTR) 0,
            (ULONG_PTR) lpDeviceInfoList
        },

        {
            hXxxApp,
            lpGet_Struct
        }
    };
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        lResult = DOFUNC (&funcArgs, "GetLineInfo");
    }
    else
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = DOFUNC (&funcArgs, "GetLineInfo");
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}


#define MAX_DEFAULT_STATUS 64

extern HINSTANCE  g_hInst;

LONG
WINAPI
MMCGetLineStatus(
    HMMCAPP     hMmcApp,
    HWND        hwndOwner,
    DWORD       dwStatusLevel,
    DWORD       dwProviderID,
    DWORD       dwPermanentLineID,
    LPVARSTRING lpStatusBuffer
    )
{
    static WCHAR szDefStatus[MAX_DEFAULT_STATUS] = L"";
    static int cbCount;

    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        return LINEERR_INVALAPPHANDLE;
    }

    if (!lpStatusBuffer ||
        IsBadWritePtr (lpStatusBuffer, sizeof (*lpStatusBuffer)))
    {
        return LINEERR_INVALPOINTER;
    }

    if (lpStatusBuffer->dwTotalSize < sizeof (*lpStatusBuffer))
    {
        return LINEERR_STRUCTURETOOSMALL;
    }

    if (0 == cbCount ||
        0 == szDefStatus[0])
    {
        cbCount = LoadString (g_hInst, IDS_DEFAULT_STATUS, szDefStatus, MAX_DEFAULT_STATUS);
        cbCount = (cbCount+1)<<1;   // + 1 because LoadString does not count the terminating NULL;
                                    // <<1 because we need the size in bytes, not characters, and WCHAR is 2 bytes.
    }

    lpStatusBuffer->dwNeededSize = sizeof (*lpStatusBuffer) + cbCount;

    if (lpStatusBuffer->dwTotalSize >= lpStatusBuffer->dwNeededSize)
    {
        lpStatusBuffer->dwStringFormat = STRINGFORMAT_UNICODE;
        lpStatusBuffer->dwStringSize   = cbCount;
        lpStatusBuffer->dwStringOffset = sizeof (*lpStatusBuffer);

        wcscpy ((WCHAR *) (lpStatusBuffer + 1), szDefStatus);
    }
    else
    {
        lpStatusBuffer->dwUsedSize = sizeof (*lpStatusBuffer);

        lpStatusBuffer->dwStringFormat =
        lpStatusBuffer->dwStringSize   =
        lpStatusBuffer->dwStringOffset = 0;
    }

    return 0;
}


LONG
WINAPI
MMCGetPhoneInfo(
    HMMCAPP             hMmcApp,
    LPDEVICEINFOLIST    lpDeviceInfoList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, mGetPhoneInfo),

        {
            (ULONG_PTR) 0,
            (ULONG_PTR) lpDeviceInfoList
        },

        {
            hXxxApp,
            lpGet_Struct
        }
    };
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        lResult = DOFUNC (&funcArgs, "GetPhoneInfo");
    }
    else
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = DOFUNC (&funcArgs, "GetPhoneInfo");
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}


LONG
WINAPI
MMCGetPhoneStatus(
    HMMCAPP     hMmcApp,
    HWND        hwndOwner,
    DWORD       dwStatusLevel,
    DWORD       dwProviderID,
    DWORD       dwPermanentLineID,
    LPVARSTRING lpStatusBuffer
    )
{
    static WCHAR szDefStatus[MAX_DEFAULT_STATUS] = L"";
    static int cbCount;

    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        return LINEERR_INVALAPPHANDLE;
    }

    if (!lpStatusBuffer ||
        IsBadWritePtr (lpStatusBuffer, sizeof (*lpStatusBuffer)))
    {
        return LINEERR_INVALPOINTER;
    }

    if (lpStatusBuffer->dwTotalSize < sizeof (*lpStatusBuffer))
    {
        return LINEERR_STRUCTURETOOSMALL;
    }

    if (0 == cbCount ||
        0 == szDefStatus[0])
    {
        cbCount = LoadString (g_hInst, IDS_DEFAULT_STATUS, szDefStatus, MAX_DEFAULT_STATUS);
        cbCount = (cbCount+1)<<1;   // + 1 because LoadString does not count the terminating NULL;
                                    // <<1 because we need the size in bytes, not characters, and WCHAR is 2 bytes.
    }

    lpStatusBuffer->dwNeededSize = sizeof (*lpStatusBuffer) + cbCount;

    if (lpStatusBuffer->dwTotalSize >= lpStatusBuffer->dwNeededSize)
    {
        lpStatusBuffer->dwStringFormat = STRINGFORMAT_UNICODE;
        lpStatusBuffer->dwStringSize   = cbCount;
        lpStatusBuffer->dwStringOffset = sizeof (*lpStatusBuffer);

        wcscpy ((WCHAR *) (lpStatusBuffer + 1), szDefStatus);
    }
    else
    {
        lpStatusBuffer->dwUsedSize = sizeof (*lpStatusBuffer);

        lpStatusBuffer->dwStringFormat =
        lpStatusBuffer->dwStringSize   =
        lpStatusBuffer->dwStringOffset = 0;
    }

    return 0;
}


LONG
WINAPI
MMCGetProviderList(
    HMMCAPP             hMmcApp,
    LPLINEPROVIDERLIST  lpProviderList
    )
{
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        lResult = lineGetProviderListW(
            pMmcApp->dwAPIVersion,
            lpProviderList
            );
    }
    else
    {
        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = lineGetProviderListW(
            pMmcApp->dwAPIVersion,
            lpProviderList
            );
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}


LONG
WINAPI
MMCGetServerConfig(
    HMMCAPP             hMmcApp,
    LPTAPISERVERCONFIG  lpConfig
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, mGetServerConfig),

        {
            (ULONG_PTR) 0,
            (ULONG_PTR) lpConfig
        },

        {
            hXxxApp,
            lpGet_Struct
        }
    };
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        lResult = DOFUNC (&funcArgs, "GetServerConfig");
    }
    else
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = DOFUNC (&funcArgs, "GetServerConfig");
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

    if (lpConfig && pMmcApp && pMmcApp->bNoServiceControl)
    {
        lpConfig->dwFlags |= TAPISERVERCONFIGFLAGS_NOSERVICECONTROL;
    }

ExitHere:
    return lResult;
}

LONG
WINAPI
EnsureTapiService(LPCWSTR lpszComputerName, DWORD * pdwServiceState)
{
    SC_HANDLE       hSCMgr = NULL; 
    SC_HANDLE       hTapiSrv = NULL;
    LONG            lResult = 0;
    DWORD           dwNumSecondsSleptStartPending = 0,
                    dwNumSecondsSleptStopPending = 0;
    SERVICE_STATUS  status;
    BOOL            bBreakOut = FALSE;

    if ((hSCMgr = OpenSCManagerW(
                    lpszComputerName,   // Machine name
                    NULL,               // ServicesActive database
                    SC_MANAGER_CONNECT  // desired access
                    )) == NULL)
    {
        lResult = GetLastError();
        LOG((TL_ERROR, "OpenSCManager failed, err=%d", lResult));
        goto ExitHere;
    }

    if ((hTapiSrv = OpenServiceW(
                    hSCMgr,                 // SC mgr handle
                    L"TAPISRV",             // name of service to open
                    SERVICE_START |         // desired access
                    SERVICE_QUERY_STATUS |
                    SERVICE_STOP |
                    SERVICE_CHANGE_CONFIG
                    )) == NULL)
    {
        lResult = GetLastError() | 0x80000000;
        LOG((TL_ERROR, "OpenService failed, err=%d", GetLastError()));
        goto ExitHere;
    }

    while (1)
    {
        QueryServiceStatus (hTapiSrv, &status);

        switch (status.dwCurrentState)
        {
        case SERVICE_RUNNING:
            LOG((TL_INFO, "Tapisrv running"));
            bBreakOut = TRUE;
            break;

        case SERVICE_START_PENDING:
            Sleep (1000);
            if (++dwNumSecondsSleptStartPending > 180)
            {
                //  Wait for no longer than 3 minutes
                LOG((TL_ERROR, "ERROR: Tapisrv stuck SERVICE_START_PENDING"));
                bBreakOut = TRUE;
            }
            break;

        case SERVICE_STOP_PENDING:
            Sleep (1000);
            if (++dwNumSecondsSleptStopPending > 180)
            {
                //  Wait for no more than 3 minutes
                LOG((TL_ERROR, "ERROR: Tapisrv stuck SERVICE_STOP_PENDING"));
                bBreakOut = TRUE;
            }
            break;

        case SERVICE_STOPPED:
            LOG((TL_INFO, "Starting tapisrv (NT)..."));
            if (!StartService(
                        hTapiSrv,   // service handle
                        0,          // num args
                        NULL        // args
                        ))
            {
                lResult = GetLastError();
                if (lResult != ERROR_SERVICE_ALREADY_RUNNING)
                {
                    LOG((TL_ERROR,
                        "StartService(TapiSrv) failed, err=%d",
                        lResult
                        ));
                    bBreakOut = TRUE;
                }
                else
                {
                    lResult = 0;
                }
            }
            break;

        default:
            LOG((TL_ERROR, "error, service status=%d",
                    status.dwCurrentState));
            lResult = GetLastError();
            bBreakOut = TRUE;
            break;
        }

        if (bBreakOut)
        {
            break;
        }
    }
    if (pdwServiceState)
    {
        *pdwServiceState = status.dwCurrentState;
    }

ExitHere:
    if (hSCMgr)
        CloseServiceHandle(hSCMgr);
    if (hTapiSrv)
        CloseServiceHandle(hTapiSrv);
    return lResult;
}

LONG
WINAPI
MMCInitialize(
    LPCWSTR     lpszComputerName,
    LPHMMCAPP   lphMmcApp,
    LPDWORD     lpdwAPIVersion,
    HANDLE      hReinitializeEvent
    )
{
    LONG            lResult = 0;
    LONG            lSrvResult = 0;
    DWORD           dwSize;
    WCHAR           szComputerName[MAX_COMPUTERNAME_LENGTH + 1] = L"";
    PMMCAPP         pMmcApp;


    if ((lpszComputerName  &&
            IsBadStringPtrW (lpszComputerName, 0xffffffff)) ||
        IsBadWritePtr (lphMmcApp, sizeof (*lphMmcApp)) ||
        IsBadWritePtr (lpdwAPIVersion, sizeof (*lpdwAPIVersion)))
    {
        return LINEERR_INVALPOINTER;
    }

    if (!(pMmcApp = ClientAlloc (sizeof (*pMmcApp))))
    {
        return LINEERR_NOMEM;
    }

    dwSize = sizeof (szComputerName) / sizeof (WCHAR);

    GetComputerNameW (szComputerName, &dwSize);

    lSrvResult = EnsureTapiService(lpszComputerName, NULL);

    if (!lpszComputerName || _wcsicmp (lpszComputerName, szComputerName) == 0)
    {
        pMmcApp->bLocal = TRUE;
    }
    else
    {
        //  We need to manage another computer
        
        RPC_STATUS      status, status2;
        BOOL            bRet;
        BOOL            bException = FALSE;
        HANDLE          hAsyncEventsEvent = NULL;
        LPWSTR          pszStringBinding;
        WCHAR           szUserName[UNLEN + 1];

        dwSize = sizeof(szUserName) / sizeof(WCHAR);
        bRet = GetUserNameW(szUserName, &dwSize);
        if (!bRet)
        {
            lResult = GetLastError();
            LOG((TL_ERROR, "GetUserNameW failed: err=%d", lResult));
            goto ExitHere;
        }
        

        //  Init the RPC connection with the server
        status = RpcStringBindingComposeW (
                                    NULL,               //  ObjUuid
                                    L"ncacn_np",        //  ProtSeq
                                    (LPWSTR)lpszComputerName,   //  NetworkAddr
                                    L"\\pipe\\tapsrv",  //  EndPoint
                                    NULL,               //  Options
                                    &pszStringBinding); //  StringBinding
        if (status)
        {
            LOG((TL_ERROR, "RpcStringBindingCompose failed: err=%d", status));
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }

        status = RpcBindingFromStringBindingW(
                                    pszStringBinding,   //  StringBinding
                                    &hTapSrv);          //  Binding
        status2 = RpcStringFreeW(&pszStringBinding);
        if (status || status2)
        {
            LOG((TL_ERROR, "RpcBindingFromStringBinding failed: err=%d", status));
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }

        status = RpcBindingSetAuthInfoW (
                                    hTapSrv,            //  hBinding
                                    NULL,               //  ServerPrincName
                                    RPC_C_AUTHN_LEVEL_DEFAULT, //  AuthnLevel
                                    RPC_C_AUTHN_WINNT,  //  AuthService
                                    NULL,               //  AuthIdentity
                                    0);                 //  AuthzService
        if (status)
        {
            LOG((TL_ERROR, "RpcBindingSetAuthInfo failed: err=%d", status));
            RpcBindingFree(hTapSrv);
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }

        RpcTryExcept
        {
            LOG((TL_TRACE,  "MMCInitialize: calling ClientAttach..."));

            lResult = ClientAttach(
                &(pMmcApp->phCtx),
                0xfffffffd,         //  Indicate to the server this is from MMC client
                                    //  on another machine
                (long *)&hAsyncEventsEvent,
                szUserName,
                szComputerName
                );

            LOG((TL_TRACE,  "MMCInitialize: ClientAttach returned x%x", lResult));
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
        {
            LOG((TL_TRACE, 
                "MMCInitialize: ClientAttach caused except=%d",
                RpcExceptionCode()
                ));
            bException = TRUE;
        }
        RpcEndExcept

        status = RpcBindingFree(&hTapSrv);
        if (status || bException)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }

        if (lResult)
        {
            goto ExitHere;
        }
        
        pMmcApp->bLocal = FALSE;
    }

    //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
    if (!(pMmcApp->bLocal) && !SetTlsPCtxHandle(pMmcApp->phCtx))
    {
        lResult = LINEERR_OPERATIONUNAVAIL;
        goto ExitHere;
    }

    {
        DWORD                   dwNumLines;
        LINEINITIALIZEEXPARAMS  initExParams;


        initExParams.dwTotalSize = sizeof (initExParams);
        initExParams.dwOptions   = LINEINITIALIZEEXOPTION_USEEVENT;

        lResult = lineInitializeExW(
            &pMmcApp->hLineApp,
            NULL,
            NULL,
            NULL,
            &dwNumLines,
            lpdwAPIVersion,
            &initExParams
            );

        pMmcApp->dwAPIVersion = *lpdwAPIVersion;
    }

    //  Clear the PCONTEXT_TYPE_HANDLE in TLS
    if (!(pMmcApp->bLocal) && !SetTlsPCtxHandle(NULL))
    {
        lResult = LINEERR_OPERATIONUNAVAIL;
    }
    
ExitHere:
    if (lResult == 0)
    {
        pMmcApp->dwKey = MMCAPP_KEY;

        *lphMmcApp = (HMMCAPP) pMmcApp;
    }
    else
    {
        ClientFree (pMmcApp);
    }

    if (lSrvResult && (lResult == 0))
    {
        //
        //  We have no problem in connecting to the remote computer
        //  but we can not manipulate its TAPI service, i.e start service
        //  tell the app about it.
        //
        pMmcApp->bNoServiceControl = TRUE;
        
    }

    return lResult;
}


LONG
WINAPI
MMCRemoveProvider(
    HMMCAPP hMmcApp,
    HWND    hwndOwner,
    DWORD   dwProviderID
    )
{
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        lResult = lineRemoveProvider (dwProviderID, hwndOwner);
    }
    else
    {
        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = lineRemoveProvider (dwProviderID, hwndOwner);
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}


LONG
WINAPI
MMCSetLineInfo(
    HMMCAPP             hMmcApp,
    LPDEVICEINFOLIST    lpDeviceInfoList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, mSetLineInfo),

        {
            (ULONG_PTR) 0,
            (ULONG_PTR) lpDeviceInfoList
        },

        {
            hXxxApp,
            lpSet_Struct
        }
    };
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        lResult = DOFUNC (&funcArgs, "SetLineInfo");
    }
    else
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = DOFUNC (&funcArgs, "SetLineInfo");
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}


LONG
WINAPI
MMCSetPhoneInfo(
    HMMCAPP             hMmcApp,
    LPDEVICEINFOLIST    lpDeviceInfoList
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, mSetPhoneInfo),

        {
            (ULONG_PTR) 0,
            (ULONG_PTR) lpDeviceInfoList
        },

        {
            hXxxApp,
            lpSet_Struct
        }
    };
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        lResult = DOFUNC (&funcArgs, "SetPhoneInfo");
    }
    else
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = DOFUNC (&funcArgs, "SetPhoneInfo");
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}


LONG
WINAPI
MMCSetServerConfig(
    HMMCAPP             hMmcApp,
    LPTAPISERVERCONFIG  lpConfig
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 2, mSetServerConfig),

        {
            (ULONG_PTR) 0,
            (ULONG_PTR) lpConfig
        },

        {
            hXxxApp,
            lpSet_Struct
        }
    };
    LONG    lResult;
    DWORD   dwFlags;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (lpConfig && pMmcApp)
    {
        dwFlags = lpConfig->dwFlags;
        lpConfig->dwFlags &= (~TAPISERVERCONFIGFLAGS_NOSERVICECONTROL);
    }

    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        lResult = DOFUNC (&funcArgs, "SetServerConfig");
    }
    else
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = DOFUNC (&funcArgs, "SetServerConfig");
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

    if (lpConfig && pMmcApp)
    {
        lpConfig->dwFlags = dwFlags;
    }

ExitHere:
    return lResult;
}

LONG
WINAPI
MMCGetDeviceFlags(
    HMMCAPP             hMmcApp,
    BOOL                bLine,
    DWORD               dwProviderID,
    DWORD               dwPermanentDeviceID,
    DWORD               * pdwFlags,
    DWORD               * pdwDeviceID
    )
{
    FUNC_ARGS funcArgs =
    {
        MAKELONG (LINE_FUNC | SYNC | 6, mGetDeviceFlags),

        {
            (ULONG_PTR) 0,
            (ULONG_PTR) bLine,
            (ULONG_PTR) dwProviderID,
            (ULONG_PTR) dwPermanentDeviceID,
            (ULONG_PTR) pdwFlags,
            (ULONG_PTR) pdwDeviceID,
        },

        {
            hXxxApp,
            Dword,
            Dword,
            Dword,
            lpDword,
            lpDword
        }
    };
    LONG    lResult;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        lResult = DOFUNC (&funcArgs, "SetPhoneInfo");
    }
    else
    {
        funcArgs.Args[0] = (ULONG_PTR) pMmcApp->hLineApp;

        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = DOFUNC (&funcArgs, "SetPhoneInfo");
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
    }

ExitHere:
    return lResult;
}

LONG
WINAPI
MMCShutdown(
    HMMCAPP hMmcApp
    )
{
    LONG    lResult = 0;
    PMMCAPP pMmcApp = IsValidMmcApp (hMmcApp);


    if (!pMmcApp)
    {
        lResult = LINEERR_INVALAPPHANDLE;
    }
    else if (pMmcApp->bLocal)
    {
        pMmcApp->dwKey = 0xfffffffe;

        lResult = lineShutdown (pMmcApp->hLineApp);

        ClientFree (pMmcApp);


        //
        // #196350 - After enabling tapi as a server the MMC does a
        // FreeLibrary on us, thinking that we'll terminate our rpc
        // connection with the tapisrv, so it can shutdown tapisrv
        // and restart it w/ different credentials, etc.  However,
        // the MMC is linked with CSCUI.DLL, who in turn links with
        // a RAS DLL, who in turn links with TAPI32.DLL, therefore
        // we never actually get unloaded.  Since we don't otherwise
        // deal with the service going down at this point, we want
        // to manually call FreeClientResources() to make it seem
        // like we've never been talking to tapisrv.
        //

        // Not needed anymore, now lineShutdown closes the RPC connection
        // FreeClientResources();
    }
    else if (pMmcApp->phCtx)
    {
        pMmcApp->dwKey = 0xfffffffe;

        //  Set the PCONTEXT_TYPE_HANDLE for lineInializeExW to use
        if (!SetTlsPCtxHandle(pMmcApp->phCtx))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
            goto ExitHere;
        }
        lResult = lineShutdown (pMmcApp->hLineApp);
        if (!SetTlsPCtxHandle(NULL) && !lResult)
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
        }
        
        RpcTryExcept
        {
            ClientDetach (&(pMmcApp->phCtx));
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
            // do something?
        }
        RpcEndExcept

        pMmcApp->phCtx = NULL;
        ClientFree (pMmcApp);
    }

ExitHere:
    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\tapireg.c ===
/****************************************************************************
 
  Copyright (c) 1996-1999 Microsoft Corporation
                                                              
  Module Name:  tapireg.c
                                                              
****************************************************************************/

#ifndef UNICODE

// These wrappers are only used when compiling for ANSI.

#include <windows.h>
#include <windowsx.h>

#include <tapi.h>
#include <tspi.h>

#include "utils.h"
#include "client.h"
#include "private.h"

#include "loc_comn.h"

//***************************************************************************
//***************************************************************************
//***************************************************************************
LONG TAPIRegQueryValueExW(
                           HKEY hKey,
                           const CHAR *SectionName,
                           LPDWORD lpdwReserved,
                           LPDWORD lpType,
                           LPBYTE  lpData,
                           LPDWORD lpcbData
                          )
{
    WCHAR *szTempBuffer;
    LONG  lResult;

    lResult = RegQueryValueEx(
                     hKey,
                     SectionName,
                     lpdwReserved,
                     lpType,
                     lpData,
                     lpcbData
                   );

     //
     // Any problems?
     //
     if ( lResult )
     {
         //
         // Yup.  Go away.
         //
         return lResult;
     }

     if (
           (REG_SZ == *lpType)
         &&
           (NULL != lpData)
        )
     {
         if ( NULL == (szTempBuffer = LocalAlloc( LPTR, *lpcbData * sizeof(WCHAR)) ) )
         {
             LOG((TL_ERROR, "Alloc failed - QUERYVALW - 0x%08lx", *lpcbData));
             return ERROR_NOT_ENOUGH_MEMORY;
         }

         MultiByteToWideChar(
                        GetACP(),
                        MB_PRECOMPOSED,
                        lpData,
                        -1,
                        szTempBuffer,
                        *lpcbData
                        );

         wcscpy( (PWSTR) lpData, szTempBuffer );

         LocalFree( szTempBuffer );

//         *lpcbData = ( lstrlenW( (PWSTR)lpData ) + 1 ) * sizeof(WCHAR);
     }

    //
    // Need to adjust the size here because lpData might be NULL, but
    // the size needs to reflect WIDE CHAR size (cause we were using
    // the ANSI version of ReqQuery)
    //
    *lpcbData = (*lpcbData + 1) * sizeof(WCHAR);

    return 0;
}



//***************************************************************************
//***************************************************************************
//***************************************************************************
LONG TAPIRegSetValueExW(
                         HKEY    hKey,
                         const CHAR    *SectionName,
                         DWORD   dwReserved,
                         DWORD   dwType,
                         LPBYTE  lpData,
                         DWORD   cbData
                        )
{
    CHAR *szTempBuffer;
    DWORD dwSize;
    LONG  lResult;


    //
    // Only convert the data if this is a Unicode string
    //
    if ( REG_SZ == dwType )
    {
        dwSize = WideCharToMultiByte(
                  GetACP(),
                  0,
                  (PWSTR)lpData,
                  cbData,
                  NULL,
                  0,
                  NULL,
                  NULL
               );

        if ( NULL == (szTempBuffer = LocalAlloc( LPTR, dwSize )) )
        {
            LOG((TL_ERROR, "Alloc failed - SETVALW - 0x%08lx", dwSize));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dwSize = WideCharToMultiByte(
                  GetACP(),
                  0,
                  (PWSTR)lpData,
                  cbData,
                  szTempBuffer,
                  dwSize,
                  NULL,
                  NULL
               );
    }

    
    lResult = RegSetValueExA(
                  hKey,
                  SectionName,
                  dwReserved,
                  dwType,
                  (REG_SZ == dwType) ?
                        szTempBuffer :
                        lpData,
                  cbData
                 );

    if (REG_SZ == dwType)
    {
        LocalFree( szTempBuffer );
    }

    return lResult;
}


//***************************************************************************
//***************************************************************************
//***************************************************************************
int TAPILoadStringW(
                HINSTANCE hInst,
                UINT      uID,
                PWSTR     pBuffer,
                int       nBufferMax
               )
{
   int nResult;
   PSTR szTempString;

   if ( NULL == ( szTempString = LocalAlloc( LPTR, nBufferMax ) ) )
   {
      LOG((TL_ERROR, "Alloc failed myloadstr - (0x%lx)", nBufferMax ));
      return 0;
   }

   nResult = LoadStringA(
                hInst,
                uID,
                szTempString,
                nBufferMax
                );

   //
   // "... but more importantly: did we get a charge?"
   //
   if ( nResult )
   {
       MultiByteToWideChar(
                     GetACP(),
                     MB_PRECOMPOSED,
                     szTempString,
                     nResult + 1,   //For null...
                     pBuffer,
                     nBufferMax
                     );
   }

   return nResult;
}

//***************************************************************************
//***************************************************************************
//***************************************************************************
HINSTANCE TAPILoadLibraryW(
                           PWSTR     pLibrary
                           )
{
    PSTR pszTempString;
    HINSTANCE hResult;
    DWORD  dwSize;
    
    
    dwSize = WideCharToMultiByte(
        GetACP(),
        0,
        pLibrary,
        -1,
        NULL,
        0,
        NULL,
        NULL
        );
    
    if ( NULL == (pszTempString = LocalAlloc( LPTR, dwSize )) )
    {
        LOG((TL_ERROR, "Alloc failed - LoadLibW - 0x%08lx", dwSize));
        return NULL;
    }
    
    WideCharToMultiByte(
        GetACP(),
        0,
        pLibrary,
        dwSize,
        pszTempString,
        dwSize,
        NULL,
        NULL
        );
    
    
    hResult = LoadLibraryA( pszTempString );
    
    LocalFree( pszTempString );
    
    return hResult;
}



//
// Swiped this from NT - process.c
//
BOOL
WINAPI
TAPIIsBadStringPtrW(
    LPCWSTR lpsz,
    UINT cchMax
    )

/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be read by the calling process.

    The range is the smaller of the number of bytes covered by the
    specified NULL terminated UNICODE string, or the number of bytes
    specified by cchMax.

    If the entire range of memory is accessible, then a value of FALSE
    is returned; otherwise, a value of TRUE is returned.

    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to gaurd access through pointers that it does not control.

Arguments:

    lpsz - Supplies the base address of the memory that is to be checked
        for read access.

    cchMax - Supplies the length in characters to be checked.

Return Value:

    TRUE - Some portion of the specified range of memory is not accessible
        for read access.

    FALSE - All pages within the specified range have been successfully
        read.

--*/

{

    LPCWSTR EndAddress;
    LPCWSTR StartAddress;
    WCHAR c;

    //
    // If the structure has zero length, then do not probe the structure for
    // read accessibility.
    //

    if (cchMax != 0) {

        StartAddress = lpsz;

        //
        // Compute the ending address of the structure and probe for
        // read accessibility.
        //

        EndAddress = (LPCWSTR)((PSZ)StartAddress + (cchMax*2) - 2);
        try {
            c = *(volatile WCHAR *)StartAddress;
            while ( c && StartAddress != EndAddress ) {
                StartAddress++;
                c = *(volatile WCHAR *)StartAddress;
                }
            }
        except(EXCEPTION_EXECUTE_HANDLER) {
            return TRUE;
            }
        }
    return FALSE;
}


#endif  // not UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\cpl\precomp.h ===
#pragma once

#include <windows.h>
#include <cpl.h>
#include <tapi.h>
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\cpl\resource.h ===
// Used by telephon.rc
//
#define IDS_NAME                        1
#define IDS_DESCRIPTION                 2
#define IDI_TELEPHONE                   100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\utils.h ===
#ifndef __CLIENT_UTILS_H__
#define __CLIENT_UTILS_H__

#ifdef __cplusplus
extern "C" {
#endif

#ifdef TRACELOG
	#include <tchar.h>
	#include <stdio.h>
	#include <stdarg.h>
	#include <windows.h>
	#include <winbase.h>
    #include <rtutils.h>
	#include "tapi.h"

	
    #define MAXDEBUGSTRINGLENGTH 1024

    #define TL_ERROR ((DWORD)0x00010000 | TRACE_USE_MASK)
    #define TL_WARN  ((DWORD)0x00020000 | TRACE_USE_MASK)
    #define TL_INFO  ((DWORD)0x00040000 | TRACE_USE_MASK)
    #define TL_TRACE ((DWORD)0x00080000 | TRACE_USE_MASK)
    #define TL_EVENT ((DWORD)0x00100000 | TRACE_USE_MASK)

    BOOL  TRACELogRegister(LPCTSTR szName);
    void  TRACELogDeRegister();
    void  TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR DbgMessage, IN ...);

    extern char *TraceLevel(DWORD dwDbgLevel);
    extern void TAPIFormatMessage(HRESULT hr, LPVOID lpMsgBuf);

    #define TRACELOGREGISTER(arg) TRACELogRegister(arg)
    #define TRACELOGDEREGISTER() TRACELogDeRegister()
	#define LOG(arg) TRACELogPrint arg

	extern char    sg_szTraceName[100];
	extern DWORD   sg_dwTracingToDebugger;
	extern DWORD   sg_dwDebuggerMask;
    extern DWORD   sg_dwTraceID;

    #define DECLARE_TRACELOG_CLASS(x)                                                                   \
        void  TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR lpszFormat, IN ...)                          \
        {																								\
			char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];												\
			va_list arglist;																			\
																										\
			if ( ( sg_dwTracingToDebugger > 0 ) &&														\
				 ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )											\
			{																							\
				SYSTEMTIME SystemTime;																	\
				GetLocalTime(&SystemTime);																\
																										\
				wsprintfA(szTraceBuf,																	\
						  "%s:[%02u:%02u:%02u.%03u,tid=%x:] [%s] (%p) %s::",							\
						  sg_szTraceName,																\
						  SystemTime.wHour,																\
						  SystemTime.wMinute,															\
						  SystemTime.wSecond,															\
						  SystemTime.wMilliseconds,														\
						  GetCurrentThreadId(),															\
						  TraceLevel(dwDbgLevel),														\
						  this,																			\
						  _T(#x));																		\
																										\
				va_list ap;																				\
				va_start(ap, lpszFormat);																\
																										\
				_vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)],											\
					MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf),										\
					lpszFormat,																			\
					ap																					\
					);																					\
																										\
				lstrcatA (szTraceBuf, "\n");															\
																										\
				OutputDebugStringA (szTraceBuf);														\
																										\
				va_end(ap);																				\
			}																							\
																										\
			if (sg_dwTraceID != INVALID_TRACEID)														\
			{																							\
				wsprintfA(szTraceBuf, "[%s] (%p) %s::%s", TraceLevel(dwDbgLevel), this, _T(#x), lpszFormat);	\
																										\
				va_start(arglist, lpszFormat);															\
				TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);							\
				va_end(arglist);																		\
			}																							\
        }                                                                                               \
                                                                                                        \
        void  TRACELogPrint(IN DWORD dwDbgLevel,IN HRESULT hr, IN LPCSTR lpszFormat, IN ...)            \
        {                                                                                               \
			char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];												\
			LPVOID  lpMsgBuf = NULL;																	\
			va_list arglist;																			\
																										\
			TAPIFormatMessage(hr, &lpMsgBuf);															\
																										\
			if ( ( sg_dwTracingToDebugger > 0 ) &&														\
				 ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )											\
			{																							\
				SYSTEMTIME SystemTime;																	\
				GetLocalTime(&SystemTime);																\
																										\
				wsprintfA(szTraceBuf,																	\
						  "%s:[%02u:%02u:%02u.%03u,tid=%x:] [%s] (%p) %s::",							\
						  sg_szTraceName,																\
						  SystemTime.wHour,																\
						  SystemTime.wMinute,															\
						  SystemTime.wSecond,															\
						  SystemTime.wMilliseconds,														\
						  GetCurrentThreadId(),															\
						  TraceLevel(dwDbgLevel),														\
						  this,																			\
						  _T(#x)																		\
						  );																			\
																										\
				va_list ap;																				\
				va_start(ap, lpszFormat);																\
																										\
				_vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)],											\
					MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf),										\
					lpszFormat,																			\
					ap																					\
					);																					\
																										\
				wsprintfA(&szTraceBuf[lstrlenA(szTraceBuf)],											\
						  " Returned[%lx] %s\n",														\
						  hr,																			\
						  lpMsgBuf);																	\
																										\
				OutputDebugStringA (szTraceBuf);														\
																										\
				va_end(ap);																				\
			}																							\
																										\
			if (sg_dwTraceID != INVALID_TRACEID)														\
			{																							\
				wsprintfA(szTraceBuf, "[%s] (%p) %s::%s  Returned[%lx] %s", TraceLevel(dwDbgLevel), this, _T(#x), lpszFormat,hr, lpMsgBuf );	\
																										\
				va_start(arglist, lpszFormat);															\
				TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);							\
				va_end(arglist);																		\
			}																							\
																										\
			if(lpMsgBuf != NULL)																		\
			{																							\
				LocalFree( lpMsgBuf );																	\
			}																							\
        }																								\
                                                                                                        \
        static void  StaticTRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR lpszFormat, IN ...)             \
        {																								\
			char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];												\
			va_list arglist;																			\
																										\
			if ( ( sg_dwTracingToDebugger > 0 ) &&														\
				 ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )											\
			{																							\
				SYSTEMTIME SystemTime;																	\
				GetLocalTime(&SystemTime);																\
																										\
				wsprintfA(szTraceBuf,																	\
						  "%s:[%02u:%02u:%02u.%03u,tid=%x:] [%s] %s::",									\
						  sg_szTraceName,																\
						  SystemTime.wHour,																\
						  SystemTime.wMinute,															\
						  SystemTime.wSecond,															\
						  SystemTime.wMilliseconds,														\
						  GetCurrentThreadId(),															\
						  TraceLevel(dwDbgLevel),														\
						  _T(#x));																		\
																										\
				va_list ap;																				\
				va_start(ap, lpszFormat);																\
																										\
				_vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)],											\
					MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf),										\
					lpszFormat,																			\
					ap																					\
					);																					\
																										\
				lstrcatA (szTraceBuf, "\n");															\
																										\
				OutputDebugStringA (szTraceBuf);														\
																										\
				va_end(ap);																				\
			}																							\
																										\
			if (sg_dwTraceID != INVALID_TRACEID)														\
			{																							\
				wsprintfA(szTraceBuf, "[%s] %s::%s", TraceLevel(dwDbgLevel), _T(#x), lpszFormat);		\
																										\
				va_start(arglist, lpszFormat);															\
				TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);							\
				va_end(arglist);																		\
			}																							\
        }                                                                                               \
                                                                                                        \
        static void StaticTRACELogPrint(IN DWORD dwDbgLevel,IN HRESULT hr, IN LPCSTR lpszFormat, IN ...)      \
        {                                                                                               \
			char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];												\
			LPVOID  lpMsgBuf = NULL;																	\
			va_list arglist;																			\
																										\
			TAPIFormatMessage(hr, &lpMsgBuf);															\
																										\
			if ( ( sg_dwTracingToDebugger > 0 ) &&														\
				 ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )											\
			{																							\
				SYSTEMTIME SystemTime;																	\
				GetLocalTime(&SystemTime);																\
																										\
				wsprintfA(szTraceBuf,																	\
						  "%s:[%02u:%02u:%02u.%03u,tid=%x:] [%s] %s::",									\
						  sg_szTraceName,																\
						  SystemTime.wHour,																\
						  SystemTime.wMinute,															\
						  SystemTime.wSecond,															\
						  SystemTime.wMilliseconds,														\
						  GetCurrentThreadId(),															\
						  TraceLevel(dwDbgLevel),														\
						  _T(#x)																		\
						  );																			\
																										\
				va_list ap;																				\
				va_start(ap, lpszFormat);																\
																										\
				_vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)],											\
					MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf),										\
					lpszFormat,																			\
					ap																					\
					);																					\
																										\
				wsprintfA(&szTraceBuf[lstrlenA(szTraceBuf)],											\
						  " Returned[%lx] %s\n",														\
						  hr,																			\
						  lpMsgBuf);																	\
																										\
				OutputDebugStringA (szTraceBuf);														\
																										\
				va_end(ap);																				\
			}																							\
																										\
			if (sg_dwTraceID != INVALID_TRACEID)														\
			{																							\
				wsprintfA(szTraceBuf, "[%s] %s::%s  Returned[%lx] %s", TraceLevel(dwDbgLevel), _T(#x), lpszFormat,hr, lpMsgBuf );	\
																										\
				va_start(arglist, lpszFormat);															\
				TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);							\
				va_end(arglist);																		\
			}																							\
																										\
			if(lpMsgBuf != NULL)																		\
			{																							\
				LocalFree( lpMsgBuf );																	\
			}																							\
        }

#else // TRACELOG not defined

    #define TRACELOGREGISTER(arg)
    #define TRACELOGDEREGISTER()
    #define LOG(arg)
	#define STATICLOG(arg)
    #define DECLARE_TRACELOG_CLASS(x)

#endif // TRACELOG

#ifdef __cplusplus
}
#endif

#endif //__CLIENT_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\client\utils.cpp ===
#include <stdio.h>
#include <stdarg.h>
#include "utils.h"

#ifdef __cplusplus
extern "C" {
#endif


#ifdef TRACELOG


DWORD   sg_dwTraceID = INVALID_TRACEID;
char    sg_szTraceName[100];   // saves name of dll

DWORD   sg_dwTracingToDebugger = 0;
DWORD   sg_dwTracingToConsole  = 0;
DWORD   sg_dwTracingToFile     = 0;
DWORD   sg_dwDebuggerMask      = 0;


BOOL TRACELogRegister(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szDebuggerTracingEnableValue[] = "EnableDebuggerTracing";
    const char szConsoleTracingEnableValue[] = "EnableConsoleTracing";
    const char szFileTracingEnableValue[] = "EnableFileTracing";
    const char szTracingMaskValue[]   = "ConsoleTracingMask";

    sg_dwTracingToDebugger = 0;
    sg_dwTracingToConsole = 0;
    sg_dwTracingToFile = 0; 

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
        DWORD      dwDataSize = sizeof (DWORD);
        DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szDebuggerTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToDebugger,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szConsoleTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToConsole,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szFileTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToFile,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwDebuggerMask,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

#ifdef UNICODE
    wsprintfA(sg_szTraceName, "%ls", szName);
#else
    wsprintfA(sg_szTraceName, "%s", szName);
#endif

    sg_dwTraceID = TraceRegister(szName);

    return (sg_dwTraceID != INVALID_TRACEID);
}


void TRACELogDeRegister()
{
    sg_dwTracingToDebugger = 0;
    sg_dwTracingToConsole = 0;
    sg_dwTracingToFile = 0; 

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(sg_dwTraceID);
        sg_dwTraceID = INVALID_TRACEID;
    }
}


void TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR lpszFormat, IN ...)
{

    char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];
    va_list arglist;

    if ( ( sg_dwTracingToDebugger > 0 ) &&
         ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )
    {

        // retrieve local time
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        wsprintfA(szTraceBuf,
                  "%s:[%02u:%02u:%02u.%03u,tid=%x:] [%s] ",
                  sg_szTraceName,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  SystemTime.wMilliseconds,
                  GetCurrentThreadId(), 
                  TraceLevel(dwDbgLevel));

        va_list ap;
        va_start(ap, lpszFormat);

        _vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)], 
            MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf), 
            lpszFormat, 
            ap
            );

        lstrcatA (szTraceBuf, "\n");

        OutputDebugStringA (szTraceBuf);

        va_end(ap);
		
    }
    
	if (sg_dwTraceID != INVALID_TRACEID)
    {
		wsprintfA(szTraceBuf, "[%s] %s", TraceLevel(dwDbgLevel), lpszFormat);

		va_start(arglist, lpszFormat);
		TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);
		va_end(arglist);
	}

}

 

char *TraceLevel(DWORD dwDbgLevel)
{
    switch(dwDbgLevel)
    {
        case TL_ERROR: return "ERROR";
        case TL_WARN:  return "WARN ";
        case TL_INFO:  return "INFO ";
        case TL_TRACE: return "TRACE";
        case TL_EVENT: return "EVENT";
        default:       return " ??? ";
    }
}


#endif // TRACELOG

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\cpl\cpl.cpp ===
// The CPL basics
#include "precomp.h"

// Prototypes

LONG OnCPlInit();
LONG OnCPlGetCount();
LONG OnCPlInquire( int i, CPLINFO * pci );
LONG OnCPlDblClk( int i, HWND hwndParent, LPTSTR pszCmdLine );
LONG OnCPlStop( int i, LPARAM lData );
LONG OnCPlExit();

void DisplayDialingRulesPropertyPage(HWND hwndCPl, int iTab);


// Global Variables

HINSTANCE g_hInst;


// DllMain
//
// This is the DLL entry point, called whenever the DLL is loaded.

extern "C" BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved )
{
    // Perform actions based on the reason for calling.
    switch( fdwReason )
    {
    case DLL_PROCESS_ATTACH:
        g_hInst = hinstDLL;
        break;

    case DLL_THREAD_ATTACH:
     // Do thread-specific initialization.
        break;

    case DLL_THREAD_DETACH:
     // Do thread-specific cleanup.
        break;

    case DLL_PROCESS_DETACH:
     // Perform any necessary cleanup.
        break;

    default:
        break;
    }
    return TRUE;  // Successful DLL_PROCESS_ATTACH.
}


// CPlApplet
//
// This is the main entry point for a CPl applet.  This exported function
// is called by the control panel.

LONG APIENTRY CPlApplet(
    HWND    hwndCPl,
    UINT    uMsg,
    LPARAM  lParam1,
    LPARAM  lParam2
)
{
    switch (uMsg )
    {
    case CPL_INIT:
        return OnCPlInit();

    case CPL_GETCOUNT:
        return OnCPlGetCount();

    case CPL_INQUIRE:
        return OnCPlInquire((int)lParam1, (CPLINFO*)lParam2);

    case CPL_DBLCLK:
        lParam2 = 0;
        //fall through

    case CPL_STARTWPARMS:
        return OnCPlDblClk((int)lParam1, hwndCPl, (LPTSTR)lParam2);

    case CPL_STOP:
        return OnCPlStop((int)lParam1, lParam2);

    case CPL_EXIT:
        return OnCPlExit();
    }

    return 0;
}

 
// OnCPlInit
//
// Before any required initialization.
// Return zero to abort the CPl and non-zero on successful initialization.
   
LONG OnCPlInit()
{
    return (0 == GetSystemMetrics (SM_CLEANBOOT))?TRUE:FALSE;
}


// OnCPlGetCount
//
// Returns the number of CPl dialogs implemented by this DLL.

LONG OnCPlGetCount()
{
    return 1;
}


// OnCPlInquire
//
// Fills out a CPLINFO structure with information about the CPl dialog.
// This information includes the name, icon, and description.

LONG OnCPlInquire( int i, CPLINFO * pci )
{
    pci->idIcon = IDI_TELEPHONE;
    pci->idName = IDS_NAME;
    pci->idInfo = IDS_DESCRIPTION;
    pci->lData  = 0;
    return 0;
}


// OnCPlDblClk
//
// This message is sent whenever our CPl is selected.  In response we display
// our UI and handle input.  This is also used when we are started with parameters
// in which case we get passed a command line.

LONG OnCPlDblClk( int i, HWND hwndCPl, LPTSTR pszCmdLine )
{
    int iTab = 0;

    if ( pszCmdLine )
    {
        iTab = *pszCmdLine - TEXT('0');
        if ( (iTab < 0) || (iTab > 2) )
        {
            iTab = 0;
        }
    }

    DisplayDialingRulesPropertyPage(hwndCPl, iTab);

    return TRUE;
}


// OnCPlStop
//
// Any resource allocated on a per-dialog basis in OnCPlInquire should be
// freed in this function.  The lData member of the CPLINFO structure that
// was initialized in OnCPlInit is passed to this function.

LONG OnCPlStop( int i, LPARAM lData )
{
    return 0;
}


// OnCPlExit
//
// This is the final message we recieve.  Any memory that was allocated in
// OnCPlInit should be freed here.  Release any resources we are holding.

LONG OnCPlExit()
{
    return 0;
}

typedef LONG (WINAPI *CONFIGPROC)(HWND, PWSTR, INT, DWORD);

void DisplayDialingRulesPropertyPage(HWND hwndCPl, int iTab)
{
    // Load tapi32 and call InternalConfig of something like that
    HINSTANCE hTapi = LoadLibrary(TEXT("TAPI32.DLL"));
    if ( hTapi )
    {
        CONFIGPROC pfnInternalConfig = (CONFIGPROC)GetProcAddress(hTapi, "internalConfig");
        if ( pfnInternalConfig )
        {
            pfnInternalConfig( hwndCPl, NULL, iTab, TAPI_CURRENT_VERSION );
            return;
        }
    }

    // TODO: Show some sort of error dialog?  Maybe something that says "your
    // tapi32.dll is missing or corrupt, please reinstall."
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\explib\tapilib.c ===
#if DBG
#define InternalDebugOut(_x_) DbgPrtEXPLIB _x_
#else
#define InternalDebugOut(_x_)
#endif

#define STRICT

#include <windows.h>
#include <windowsx.h>

//#include "stdlib.h"
#include "tapi.h"

HINSTANCE ghTapi32 = NULL;
DWORD     gdwDebugLevel = 0;

typedef LONG (WINAPI *TAPIPROC)();

#undef   lineBlindTransfer
#undef   lineConfigDialog
#undef   lineConfigDialogEdit
#undef   lineDial
#undef   lineForward
#undef   lineGatherDigits
#undef   lineGenerateDigits
#undef   lineGetAddressCaps
#undef   lineGetAddressID
#undef   lineGetAddressStatus
#undef   lineGetCallInfo
#undef   lineGetDevCaps
#undef   lineGetDevConfig
#undef   lineGetIcon
#undef   lineGetID
#undef   lineGetLineDevStatus
#undef   lineGetRequest
#undef   lineGetTranslateCaps
#undef   lineHandoff
#undef   lineMakeCall
#undef   lineOpen
#undef   linePark
#undef   linePickup
#undef   linePrepareAddToConference
#undef   lineRedirect
#undef   lineSetDevConfig
#undef   lineSetTollList
#undef   lineSetupConference
#undef   lineSetupTransfer
#undef   lineTranslateAddress
#undef   lineUnpark
#undef   phoneConfigDialog
#undef   phoneGetButtonInfo
#undef   phoneGetDevCaps
#undef   phoneGetIcon
#undef   phoneGetID
#undef   phoneGetStatus
#undef   phoneSetButtonInfo
#undef   tapiGetLocationInfo
#undef   tapiRequestMakeCall
#undef   tapiRequestMediaCall
#undef   lineAddProvider
#undef   lineGetAppPriority
#undef   lineGetCountry
#undef   lineGetProviderList
#undef   lineSetAppPriority
#undef   lineTranslateDialog



//**************************************************************************
//**************************************************************************
//**************************************************************************
#if DBG
VOID
DbgPrtEXPLIB(
    IN DWORD  dwDbgLevel,
    IN PUCHAR lpszFormat,
    IN ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
    static BOOLEAN fBeenThereDoneThat = FALSE;

    if ( !fBeenThereDoneThat )
    {
            HKEY  hKey;


            gdwDebugLevel=0;

            if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony",
                    0,
                    KEY_ALL_ACCESS,
                    &hKey

                    ) == ERROR_SUCCESS)
            {
                DWORD dwDataSize = sizeof(DWORD), dwDataType;

                RegQueryValueEx(
                    hKey,
                    "Tapi32libDebugLevel",
                    0,
                    &dwDataType,
                    (LPBYTE)&gdwDebugLevel,
                    &dwDataSize
                    );

                RegCloseKey (hKey);
            }
    }


    if (dwDbgLevel <= gdwDebugLevel)
    {
        char    buf[1280] = "TAPI32.LIB: ";
        va_list ap;


        va_start(ap, lpszFormat);

        wvsprintf (&buf[12],
                   lpszFormat,
                   ap
                  );

        lstrcat (buf, "\n");

        OutputDebugStringA (buf);

        va_end(ap);
    }
}
#endif

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG PASCAL GetTheFunctionPtr( LPSTR lpszFunction, TAPIPROC *ppfn )
{
   InternalDebugOut((4, "Looking for: [%s]", lpszFunction));

   if ( !ghTapi32 )
   {
      ghTapi32 = LoadLibrary("TAPI32.DLL");
      
      //
      // If this failed, we won't try again
      //
      if ( 0 == ghTapi32 )
      {
         InternalDebugOut((1, "Can't LoadLibrary(""TAPI32.DLL"") !"));
         ghTapi32 = (HINSTANCE)-1;
      }
   }


   if ( ghTapi32 != (HINSTANCE)-1 )
   {
      *ppfn = (TAPIPROC) GetProcAddress( ghTapi32, lpszFunction );
   }
   else
   {
      return LINEERR_OPERATIONUNAVAIL;
   }


   if ( NULL == *ppfn )
   {
      InternalDebugOut((1, "Can't find function: [%s]", lpszFunction));
      return LINEERR_OPERATIONUNAVAIL;
   }

   return 0;
}
//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineAccept(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineAccept", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpsUserUserInfo,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineAddProvider(
    LPCSTR              lpszProviderFilename,
    HWND                hwndOwner,
    LPDWORD             lpdwPermanentProviderID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineAddProvider", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lpszProviderFilename,
                   hwndOwner,
                   lpdwPermanentProviderID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineAddProviderA(
    LPCSTR              lpszProviderFilename,
    HWND                hwndOwner,
    LPDWORD             lpdwPermanentProviderID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineAddProviderA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lpszProviderFilename,
                   hwndOwner,
                   lpdwPermanentProviderID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineAddProviderW(
    LPCWSTR             lpszProviderFilename,
    HWND                hwndOwner,
    LPDWORD             lpdwPermanentProviderID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineAddProviderW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lpszProviderFilename,
                   hwndOwner,
                   lpdwPermanentProviderID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineAddToConference(
    HCALL               hConfCall,
    HCALL               hConsultCall
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineAddToConference", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hConfCall,
                   hConsultCall
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineAgentSpecific(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwAgentExtensionIDIndex,
    LPVOID              lpParams,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineAgentSpecific", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   dwAgentExtensionIDIndex,
                   lpParams,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineAnswer(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineAnswer", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpsUserUserInfo,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineBlindTransfer(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineBlindTransfer", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszDestAddress,
                   dwCountryCode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineBlindTransferA(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineBlindTransferA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszDestAddress,
                   dwCountryCode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineBlindTransferW(
    HCALL               hCall,
    LPCWSTR             lpszDestAddressW,
    DWORD               dwCountryCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineBlindTransferW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszDestAddressW,
                   dwCountryCode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineClose(
    HLINE               hLine
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineClose", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineCompleteCall(
    HCALL               hCall,
    LPDWORD             lpdwCompletionID,
    DWORD               dwCompletionMode,
    DWORD               dwMessageID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineCompleteCall", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpdwCompletionID,
                   dwCompletionMode,
                   dwMessageID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineCompleteTransfer(
    HCALL               hCall,
    HCALL               hConsultCall,
    LPHCALL             lphConfCall,
    DWORD               dwTransferMode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineCompleteTransfer", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   hConsultCall,
                   lphConfCall,
                   dwTransferMode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineConfigDialog(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineConfigDialog", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   hwndOwner,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineConfigDialogA(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineConfigDialogA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   hwndOwner,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineConfigDialogW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineConfigDialogW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   hwndOwner,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineConfigDialogEdit(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineConfigDialogEdit", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   hwndOwner,
                   lpszDeviceClass,
                   lpDeviceConfigIn,
                   dwSize,
                   lpDeviceConfigOut
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineConfigDialogEditA(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineConfigDialogEditA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   hwndOwner,
                   lpszDeviceClass,
                   lpDeviceConfigIn,
                   dwSize,
                   lpDeviceConfigOut
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineConfigDialogEditW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineConfigDialogEditW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   hwndOwner,
                   lpszDeviceClass,
                   lpDeviceConfigIn,
                   dwSize,
                   lpDeviceConfigOut
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineConfigProvider(
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineConfigProvider", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hwndOwner,
                   dwPermanentProviderID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineCreateAgentA(                                               // TAPI v2.2
    HLINE               hLine,
    LPSTR               lpszAgentID,
    LPSTR               lpszAgentPIN,
    LPHAGENT            lphAgent
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineCreateAgentA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpszAgentID,
                   lpszAgentPIN,
                   lphAgent
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineCreateAgentW(                                               // TAPI v2.2
    HLINE               hLine,
    LPWSTR              lpszAgentID,
    LPWSTR              lpszAgentPIN,
    LPHAGENT            lphAgent
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineCreateAgentW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpszAgentID,
                   lpszAgentPIN,
                   lphAgent
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineCreateAgentSessionA(                                        // TAPI v2.2
    HLINE               hLine,
    HAGENT              hAgent,
    LPSTR               lpszAgentPIN,
    DWORD               dwWorkingAddressID,
    LPGUID              lpGroupID,
    LPHAGENTSESSION     lphAgentSession
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineCreateAgentSessionA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   hAgent,
                   lpszAgentPIN,
                   dwWorkingAddressID,
                   lpGroupID,
                   lphAgentSession
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineCreateAgentSessionW(                                               // TAPI v2.2
    HLINE               hLine,
    HAGENT              hAgent,
    LPWSTR              lpszAgentPIN,
    DWORD               dwWorkingAddressID,
    LPGUID              lpGroupID,
    LPHAGENTSESSION     lphAgentSession
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineCreateAgentSessionW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   hAgent,
                   lpszAgentPIN,
                   dwWorkingAddressID,
                   lpGroupID,
                   lphAgentSession
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineDeallocateCall(
    HCALL               hCall
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineDeallocateCall", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineDevSpecific(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    LPVOID              lpParams,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineDevSpecific", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   hCall,
                   lpParams,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineDevSpecificFeature(
    HLINE               hLine,
    DWORD               dwFeature,
    LPVOID              lpParams,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineDevSpecificFeature", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwFeature,
                   lpParams,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineDial(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineDial", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszDestAddress,
                   dwCountryCode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineDialA(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineDialA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszDestAddress,
                   dwCountryCode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineDialW(
    HCALL               hCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineDialW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszDestAddress,
                   dwCountryCode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineDrop(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineDrop", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpsUserUserInfo,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineForward(
    HLINE               hLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineForward", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   bAllAddresses,
                   dwAddressID,
                   lpForwardList,
                   dwNumRingsNoAnswer,
                   lphConsultCall,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineForwardA(
    HLINE               hLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineForwardA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   bAllAddresses,
                   dwAddressID,
                   lpForwardList,
                   dwNumRingsNoAnswer,
                   lphConsultCall,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineForwardW(
    HLINE               hLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineForwardW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   bAllAddresses,
                   dwAddressID,
                   lpForwardList,
                   dwNumRingsNoAnswer,
                   lphConsultCall,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGatherDigits(
    HCALL               hCall,
    DWORD               dwDigitModes,
    LPSTR               lpsDigits,
    DWORD               dwNumDigits,
    LPCSTR              lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGatherDigits", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwDigitModes,
                   lpsDigits,
                   dwNumDigits,
                   lpszTerminationDigits,
                   dwFirstDigitTimeout,
                   dwInterDigitTimeout
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGatherDigitsA(
    HCALL               hCall,
    DWORD               dwDigitModes,
    LPSTR               lpsDigits,
    DWORD               dwNumDigits,
    LPCSTR              lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGatherDigitsA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwDigitModes,
                   lpsDigits,
                   dwNumDigits,
                   lpszTerminationDigits,
                   dwFirstDigitTimeout,
                   dwInterDigitTimeout
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGatherDigitsW(
    HCALL               hCall,
    DWORD               dwDigitModes,
    LPWSTR              lpsDigits,
    DWORD               dwNumDigits,
    LPCWSTR             lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGatherDigitsW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwDigitModes,
                   lpsDigits,
                   dwNumDigits,
                   lpszTerminationDigits,
                   dwFirstDigitTimeout,
                   dwInterDigitTimeout
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGenerateDigits(
    HCALL               hCall,
    DWORD               dwDigitMode,
    LPCSTR              lpszDigits,
    DWORD               dwDuration
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGenerateDigits", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwDigitMode,
                   lpszDigits,
                   dwDuration
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGenerateDigitsA(
    HCALL               hCall,
    DWORD               dwDigitMode,
    LPCSTR              lpszDigits,
    DWORD               dwDuration
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGenerateDigitsA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwDigitMode,
                   lpszDigits,
                   dwDuration
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGenerateDigitsW(
    HCALL               hCall,
    DWORD               dwDigitMode,
    LPCWSTR             lpszDigits,
    DWORD               dwDuration
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGenerateDigitsW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwDigitMode,
                   lpszDigits,
                   dwDuration
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGenerateTone(
    HCALL               hCall,
    DWORD               dwToneMode,
    DWORD               dwDuration,
    DWORD               dwNumTones,
    LPLINEGENERATETONE  const lpTones
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGenerateTone", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwToneMode,
                   dwDuration,
                   dwNumTones,
                   lpTones
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAddressCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAddressCaps", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAddressID,
                   dwAPIVersion,
                   dwExtVersion,
                   lpAddressCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAddressCapsA(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAddressCapsA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAddressID,
                   dwAPIVersion,
                   dwExtVersion,
                   lpAddressCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAddressCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAddressCapsW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAddressID,
                   dwAPIVersion,
                   dwExtVersion,
                   lpAddressCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAddressID(
    HLINE               hLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCSTR              lpsAddress,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAddressID", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpdwAddressID,
                   dwAddressMode,
                   lpsAddress,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAddressIDA(
    HLINE               hLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCSTR              lpsAddress,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAddressIDA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpdwAddressID,
                   dwAddressMode,
                   lpsAddress,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAddressIDW(
    HLINE               hLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCWSTR             lpsAddress,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAddressIDW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpdwAddressID,
                   dwAddressMode,
                   lpsAddress,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAddressStatus(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAddressStatus", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lpAddressStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAddressStatusA(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAddressStatusA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lpAddressStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAddressStatusW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAddressStatusW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lpAddressStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentActivityListA(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentActivityListA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                       hLine,
                       dwAddressID,
                       lpAgentActivityList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentActivityListW(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentActivityListW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                       hLine,
                       dwAddressID,
                       lpAgentActivityList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentCapsA(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAppAPIVersion,
    LPLINEAGENTCAPS     lpAgentCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentCapsA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAddressID,
                   dwAppAPIVersion,
                   lpAgentCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAppAPIVersion,
    LPLINEAGENTCAPS     lpAgentCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentCapsW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAddressID,
                   dwAppAPIVersion,
                   lpAgentCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentGroupListA(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentGroupListA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                       hLine,
                       dwAddressID,
                       lpAgentGroupList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentGroupListW(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentGroupListW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                       hLine,
                       dwAddressID,
                       lpAgentGroupList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentInfo(                                               // TAPI v2.2
    HLINE               hLine,
    HAGENT              hAgent,
    LPLINEAGENTINFO     lpAgentInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentInfo", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                       hLine,
                       hAgent,
                       lpAgentInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentSessionInfo(                                        // TAPI v2.2
    HLINE                   hLine,
    HAGENTSESSION           hAgentSession,
    LPLINEAGENTSESSIONINFO  lpAgentSessionInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentSessionInfo", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                       hLine,
                       hAgentSession,
                       lpAgentSessionInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentSessionList(                                        // TAPI v2.2
    HLINE                   hLine,
    HAGENT                  hAgent,
    LPLINEAGENTSESSIONLIST  lpAgentSessionList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentSessionList", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                       hLine,
                       hAgent,
                       lpAgentSessionList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentStatusA(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEAGENTSTATUS   lpAgentStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentStatusA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lpAgentStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAgentStatusW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEAGENTSTATUS   lpAgentStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAgentStatusW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lpAgentStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAppPriority(
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAppPriority", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lpszAppFilename,
                   dwMediaMode,
                   lpExtensionID,
                   dwRequestMode,
                   lpExtensionName,
                   lpdwPriority
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAppPriorityA(
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAppPriorityA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lpszAppFilename,
                   dwMediaMode,
                   lpExtensionID,
                   dwRequestMode,
                   lpExtensionName,
                   lpdwPriority
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetAppPriorityW(
    LPCWSTR             lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetAppPriorityW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lpszAppFilename,
                   dwMediaMode,
                   lpExtensionID,
                   dwRequestMode,
                   lpExtensionName,
                   lpdwPriority
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetCallInfo(
    HCALL               hCall,
    LPLINECALLINFO      lpCallInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetCallInfo", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpCallInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetCallInfoA(
    HCALL               hCall,
    LPLINECALLINFO      lpCallInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetCallInfoA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpCallInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetCallInfoW(
    HCALL               hCall,
    LPLINECALLINFO      lpCallInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetCallInfoW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpCallInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetCallStatus(
    HCALL               hCall,
    LPLINECALLSTATUS    lpCallStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetCallStatus", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpCallStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetConfRelatedCalls(
    HCALL               hCall,
    LPLINECALLLIST      lpCallList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetConfRelatedCalls", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpCallList
                 );
}
    
//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetCountry(
    DWORD               dwCountryID,
    DWORD               dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetCountry", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwCountryID,
                   dwAPIVersion,
                   lpLineCountryList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetCountryA(
    DWORD               dwCountryID,
    DWORD               dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetCountryA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwCountryID,
                   dwAPIVersion,
                   lpLineCountryList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetCountryW(
    DWORD               dwCountryID,
    DWORD               dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetCountryW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwCountryID,
                   dwAPIVersion,
                   lpLineCountryList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetDevCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetDevCaps", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   dwExtVersion,
                   lpLineDevCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetDevCapsA(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetDevCapsA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   dwExtVersion,
                   lpLineDevCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetDevCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetDevCapsW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   dwExtVersion,
                   lpLineDevCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetDevConfig(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetDevConfig", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpDeviceConfig,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetDevConfigA(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetDevConfigA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpDeviceConfig,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetDevConfigW(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCWSTR             lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetDevConfigW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpDeviceConfig,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetNewCalls(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwSelect,
    LPLINECALLLIST      lpCallList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetNewCalls", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   dwSelect,
                   lpCallList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetGroupListA(                                              // TAPI v2.2
    HLINE                   hLine,
    LPLINEAGENTGROUPLIST    lpGroupList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetGroupListA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpGroupList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetGroupListW(                                              // TAPI v2.2
    HLINE                   hLine,
    LPLINEAGENTGROUPLIST    lpGroupList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetGroupListW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpGroupList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetIcon(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetIcon", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpszDeviceClass,
                   lphIcon
                 );
}
    
//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetIconA(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetIconA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpszDeviceClass,
                   lphIcon
                 );
}
    
//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetIconW(
    DWORD               dwDeviceID,
    LPCWSTR             lpszDeviceClass,
    LPHICON             lphIcon
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetIconW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpszDeviceClass,
                   lphIcon
                 );
}
    
//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetID(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetID", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   hCall,
                   dwSelect,
                   lpDeviceID,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetIDA(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetIDA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   hCall,
                   dwSelect,
                   lpDeviceID,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetIDW(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCWSTR             lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetIDW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   hCall,
                   dwSelect,
                   lpDeviceID,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetLineDevStatus(
    HLINE               hLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetLineDevStatus", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpLineDevStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetLineDevStatusA(
    HLINE               hLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetLineDevStatusA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpLineDevStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetLineDevStatusW(
    HLINE               hLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetLineDevStatusW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpLineDevStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetMessage(
    HLINEAPP        hLineApp,
    LPLINEMESSAGE   lpMessage,
    DWORD           dwTimeout
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetMessage", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   lpMessage,
                   dwTimeout
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetNumRings(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPDWORD             lpdwNumRings
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetNumRings", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lpdwNumRings
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetProviderList(
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetProviderList", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwAPIVersion,
                   lpProviderList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetProviderListA(
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetProviderListA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwAPIVersion,
                   lpProviderList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetProviderListW(
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetProviderListW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwAPIVersion,
                   lpProviderList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetProxyStatus(                                             // TAPI v2.2
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAppAPIVersion,
    LPLINEPROXYREQUESTLIST  lpLineProxyReqestList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetProxyStatus", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAppAPIVersion,
                   lpLineProxyReqestList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetQueueInfo(                                               // TAPI v2.2
    HLINE               hLine,
    DWORD               dwQueueID, 
    LPLINEQUEUEINFO     lpLineQueueInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetQueueInfo", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwQueueID,
                   lpLineQueueInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetQueueListA(                                              // TAPI v2.2
    HLINE               hLine,
    LPGUID              lpGroupID,
    LPLINEQUEUELIST     lpQueueList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetQueueListA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpGroupID,
                   lpQueueList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetQueueListW(                                              // TAPI v2.2
    HLINE               hLine,
    LPGUID              lpGroupID,
    LPLINEQUEUELIST     lpQueueList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetQueueListW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpGroupID,
                   lpQueueList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetRequest(
    HLINEAPP            hLineApp,
    DWORD               dwRequestMode,
    LPVOID              lpRequestBuffer
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetRequest", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwRequestMode,
                   lpRequestBuffer
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetRequestA(
    HLINEAPP            hLineApp,
    DWORD               dwRequestMode,
    LPVOID              lpRequestBuffer
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetRequestA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwRequestMode,
                   lpRequestBuffer
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetRequestW(
    HLINEAPP            hLineApp,
    DWORD               dwRequestMode,
    LPVOID              lpRequestBuffer
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetRequestW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwRequestMode,
                   lpRequestBuffer
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetStatusMessages(
    HLINE               hLine,
    LPDWORD             lpdwLineStates,
    LPDWORD             lpdwAddressStates
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetStatusMessages", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpdwLineStates,
                   lpdwAddressStates
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetTranslateCaps(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetTranslateCaps", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwAPIVersion,
                   lpTranslateCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetTranslateCapsA(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetTranslateCapsA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwAPIVersion,
                   lpTranslateCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineGetTranslateCapsW(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineGetTranslateCapsW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwAPIVersion,
                   lpTranslateCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineHandoff(
    HCALL               hCall,
    LPCSTR              lpszFileName,
    DWORD               dwMediaMode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineHandoff", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszFileName,
                   dwMediaMode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineHandoffA(
    HCALL               hCall,
    LPCSTR              lpszFileName,
    DWORD               dwMediaMode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineHandoffA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszFileName,
                   dwMediaMode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineHandoffW(
    HCALL               hCall,
    LPCWSTR             lpszFileName,
    DWORD               dwMediaMode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineHandoffW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszFileName,
                   dwMediaMode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineHold(
    HCALL               hCall
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineHold", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineInitialize(
    LPHLINEAPP          lphLineApp,
    HINSTANCE           hInstance,
    LINECALLBACK        lpfnCallback,
    LPCSTR              lpszAppName,
    LPDWORD             lpdwNumDevs
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineInitialize", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lphLineApp,
                   hInstance,
                   lpfnCallback,
                   lpszAppName,
                   lpdwNumDevs
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineInitializeExA(
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCSTR                      lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineInitializeExA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lphLineApp,
                   hInstance,
                   lpfnCallback,
                   lpszFriendlyAppName,
                   lpdwNumDevs,
                   lpdwAPIVersion,
                   lpLineInitializeExParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineInitializeExW(
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCWSTR                     lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineInitializeExW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lphLineApp,
                   hInstance,
                   lpfnCallback,
                   lpszFriendlyAppName,
                   lpdwNumDevs,
                   lpdwAPIVersion,
                   lpLineInitializeExParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineMakeCall(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineMakeCall", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lphCall,
                   lpszDestAddress,
                   dwCountryCode,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineMakeCallA(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineMakeCallA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lphCall,
                   lpszDestAddress,
                   dwCountryCode,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineMakeCallW(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineMakeCallW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lphCall,
                   lpszDestAddress,
                   dwCountryCode,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineMonitorDigits(
    HCALL               hCall,
    DWORD               dwDigitModes
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineMonitorDigits", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwDigitModes
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineMonitorMedia(
    HCALL               hCall,
    DWORD               dwMediaModes
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineMonitorMedia", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwMediaModes
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineMonitorTones(
    HCALL               hCall,
    LPLINEMONITORTONE   const lpToneList,
    DWORD               dwNumEntries
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineMonitorTones", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpToneList,
                   dwNumEntries
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineNegotiateAPIVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPLINEEXTENSIONID   lpExtensionID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineNegotiateAPIVersion", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPILowVersion,
                   dwAPIHighVersion,
                   lpdwAPIVersion,
                   lpExtensionID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineNegotiateExtVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtLowVersion,
    DWORD               dwExtHighVersion,
    LPDWORD             lpdwExtVersion
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineNegotiateExtVersion", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   dwExtLowVersion,
                   dwExtHighVersion,
                   lpdwExtVersion
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineOpen(
    HLINEAPP            hLineApp, 
    DWORD               dwDeviceID,
    LPHLINE             lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD_PTR           dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineOpen", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp, 
                   dwDeviceID,
                   lphLine,
                   dwAPIVersion,
                   dwExtVersion,
                   dwCallbackInstance,
                   dwPrivileges,
                   dwMediaModes,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineOpenA(
    HLINEAPP            hLineApp, 
    DWORD               dwDeviceID,
    LPHLINE             lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD_PTR           dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineOpenA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp, 
                   dwDeviceID,
                   lphLine,
                   dwAPIVersion,
                   dwExtVersion,
                   dwCallbackInstance,
                   dwPrivileges,
                   dwMediaModes,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineOpenW(
    HLINEAPP            hLineApp, 
    DWORD               dwDeviceID,
    LPHLINE             lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD_PTR           dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineOpenW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp, 
                   dwDeviceID,
                   lphLine,
                   dwAPIVersion,
                   dwExtVersion,
                   dwCallbackInstance,
                   dwPrivileges,
                   dwMediaModes,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
linePark(
    HCALL               hCall,
    DWORD               dwParkMode,
    LPCSTR              lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "linePark", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwParkMode,
                   lpszDirAddress,
                   lpNonDirAddress
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineParkA(
    HCALL               hCall,
    DWORD               dwParkMode,
    LPCSTR              lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineParkA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwParkMode,
                   lpszDirAddress,
                   lpNonDirAddress
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineParkW(
    HCALL               hCall,
    DWORD               dwParkMode,
    LPCWSTR             lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineParkW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwParkMode,
                   lpszDirAddress,
                   lpNonDirAddress
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
linePickup(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszGroupID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "linePickup", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lphCall,
                   lpszDestAddress,
                   lpszGroupID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
linePickupA(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszGroupID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "linePickupA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lphCall,
                   lpszDestAddress,
                   lpszGroupID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
linePickupW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCWSTR             lpszDestAddress,
    LPCWSTR             lpszGroupID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "linePickupW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lphCall,
                   lpszDestAddress,
                   lpszGroupID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
linePrepareAddToConference(
    HCALL               hConfCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "linePrepareAddToConference", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hConfCall,
                   lphConsultCall,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
linePrepareAddToConferenceA(
    HCALL               hConfCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "linePrepareAddToConferenceA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hConfCall,
                   lphConsultCall,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
linePrepareAddToConferenceW(
    HCALL               hConfCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "linePrepareAddToConferenceW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hConfCall,
                   lphConsultCall,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineProxyMessage(
    HLINE               hLine,
    HCALL               hCall,
    DWORD               dwMsg,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwParam3
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineProxyMessage", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   hCall,
                   dwMsg,
                   dwParam1,
                   dwParam2,
                   dwParam3
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineProxyResponse(
    HLINE               hLine,
    LPLINEPROXYREQUEST  lpProxyRequest,
    DWORD               dwResult
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineProxyResponse", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   lpProxyRequest,
                   dwResult
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineRedirect(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineRedirect", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszDestAddress,
                   dwCountryCode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineRedirectA(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineRedirectA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszDestAddress,
                   dwCountryCode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineRedirectW(
    HCALL               hCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineRedirectW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpszDestAddress,
                   dwCountryCode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineRegisterRequestRecipient(
    HLINEAPP            hLineApp,
    DWORD               dwRegistrationInstance,
    DWORD               dwRequestMode,
    DWORD               bEnable
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineRegisterRequestRecipient", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwRegistrationInstance,
                   dwRequestMode,
                   bEnable
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineReleaseUserUserInfo(
    HCALL               hCall
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineReleaseUserUserInfo", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineRemoveFromConference(
    HCALL               hCall
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineRemoveFromConference", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineRemoveProvider(
    DWORD               dwPermanentProviderID,
    HWND                hwndOwner
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineRemoveProvider", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwPermanentProviderID,
                   hwndOwner
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSecureCall(
    HCALL               hCall
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSecureCall", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSendUserUserInfo(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSendUserUserInfo", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpsUserUserInfo,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAgentActivity(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwActivityID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAgentActivity", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   dwActivityID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAgentGroup(
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAgentGroup", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lpAgentGroupList
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAgentMeasurementPeriod(                                  // TAPI v2.2
    HLINE               hLine,
    HAGENT              hAgent,
    DWORD               dwMeasurementPeriod
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAgentMeasurementPeriod", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   hAgent,
                   dwMeasurementPeriod
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAgentSessionState(                                       // TAPI v2.2
    HLINE               hLine,
    HAGENTSESSION       hAgentSession,
    DWORD               dwSessionState,
    DWORD               dwNextSessionState
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAgentSessionState", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   hAgentSession,
                   dwSessionState,
                   dwNextSessionState
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAgentState(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwAgentState,
    DWORD               dwNextAgentState
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAgentState", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   dwAgentState,
                   dwNextAgentState
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAgentStateEx(                                            // TAPI v2.2
    HLINE               hLine,
    HAGENT              hAgent,
    DWORD               dwSessionState,
    DWORD               dwNextSessionState
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAgentStateEx", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   hAgent,
                   dwSessionState,
                   dwNextSessionState
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAppPriority(
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCSTR              lpszExtensionName,
    DWORD               dwPriority
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAppPriority", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lpszAppFilename,
                   dwMediaMode,
                   lpExtensionID,
                   dwRequestMode,
                   lpszExtensionName,
                   dwPriority
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAppPriorityA(
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCSTR              lpszExtensionName,
    DWORD               dwPriority
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAppPriorityA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lpszAppFilename,
                   dwMediaMode,
                   lpExtensionID,
                   dwRequestMode,
                   lpszExtensionName,
                   dwPriority
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAppPriorityW(
    LPCWSTR             lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCWSTR             lpszExtensionName,
    DWORD               dwPriority
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAppPriorityW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lpszAppFilename,
                   dwMediaMode,
                   lpExtensionID,
                   dwRequestMode,
                   lpszExtensionName,
                   dwPriority
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetAppSpecific(
    HCALL               hCall,
    DWORD               dwAppSpecific
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetAppSpecific", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwAppSpecific
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetCallData(
    HCALL               hCall,
    LPVOID              lpCallData,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetCallData", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpCallData,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetCallParams(
    HCALL               hCall,
    DWORD               dwBearerMode,
    DWORD               dwMinRate,
    DWORD               dwMaxRate,
    LPLINEDIALPARAMS    const lpDialParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetCallParams", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwBearerMode,
                   dwMinRate,
                   dwMaxRate,
                   lpDialParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetCallPrivilege(
    HCALL               hCall,
    DWORD               dwCallPrivilege
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetCallPrivilege", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwCallPrivilege
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetCallQualityOfService(
    HCALL               hCall,
    LPVOID              lpSendingFlowspec,
    DWORD               dwSendingFlowspecSize,
    LPVOID              lpReceivingFlowspec,
    DWORD               dwReceivingFlowspecSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetCallQualityOfService", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lpSendingFlowspec,
                   dwSendingFlowspecSize,
                   lpReceivingFlowspec,
                   dwReceivingFlowspecSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetCallTreatment(
    HCALL               hCall,
    DWORD               dwTreatment
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetCallTreatment", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwTreatment
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetCurrentLocation(
    HLINEAPP            hLineApp,
    DWORD               dwLocation
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetCurrentLocation", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwLocation
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetDevConfig(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetDevConfig", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpDeviceConfig,
                   dwSize,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetDevConfigA(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetDevConfigA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpDeviceConfig,
                   dwSize,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetDevConfigW(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCWSTR             lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetDevConfigW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpDeviceConfig,
                   dwSize,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetLineDevStatus(
    HLINE               hLine,
    DWORD               dwStatusToChange,
    DWORD               fStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetLineDevStatus", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwStatusToChange,
                   fStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetMediaControl(
    HLINE                       hLine,
    DWORD                       dwAddressID,
    HCALL                       hCall,
    DWORD                       dwSelect,
    LPLINEMEDIACONTROLDIGIT     const lpDigitList,
    DWORD                       dwDigitNumEntries,
    LPLINEMEDIACONTROLMEDIA     const lpMediaList,
    DWORD                       dwMediaNumEntries,
    LPLINEMEDIACONTROLTONE      const lpToneList,
    DWORD                       dwToneNumEntries,
    LPLINEMEDIACONTROLCALLSTATE const lpCallStateList, 
    DWORD                       dwCallStateNumEntries
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetMediaControl", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   hCall,
                   dwSelect,
                   lpDigitList,
                   dwDigitNumEntries,
                   lpMediaList,
                   dwMediaNumEntries,
                   lpToneList,
                   dwToneNumEntries,
                   lpCallStateList, 
                   dwCallStateNumEntries
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetMediaMode(
    HCALL               hCall,
    DWORD               dwMediaModes
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetMediaMode", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   dwMediaModes
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetNumRings(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwNumRings
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetNumRings", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   dwNumRings
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetQueueMeasurementPeriod(                                  // TAPI v2.2
    HLINE               hLine,
    DWORD               dwQueueID,
    DWORD               dwMeasurementPeriod
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetQueueMeasurementPeriod", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwQueueID,
                   dwMeasurementPeriod
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetStatusMessages(
    HLINE               hLine,
    DWORD               dwLineStates,
    DWORD               dwAddressStates
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetStatusMessages", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwLineStates,
                   dwAddressStates
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetTerminal(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    DWORD               dwTerminalModes,
    DWORD               dwTerminalID,
    DWORD               bEnable
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetTerminal", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   hCall,
                   dwSelect,
                   dwTerminalModes,
                   dwTerminalID,
                   bEnable
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetTollList(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPCSTR              lpszAddressIn,
    DWORD               dwTollListOption
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetTollList", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   lpszAddressIn,
                   dwTollListOption
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetTollListA(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPCSTR              lpszAddressIn,
    DWORD               dwTollListOption
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetTollListA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   lpszAddressIn,
                   dwTollListOption
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetTollListW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPCWSTR             lpszAddressInW,
    DWORD               dwTollListOption
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetTollListW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   lpszAddressInW,
                   dwTollListOption
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetupConference(
    HCALL               hCall,
    HLINE               hLine,
    LPHCALL             lphConfCall,
    LPHCALL             lphConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetupConference", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   hLine,
                   lphConfCall,
                   lphConsultCall,
                   dwNumParties,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetupConferenceA(
    HCALL               hCall,
    HLINE               hLine,
    LPHCALL             lphConfCall,
    LPHCALL             lphConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetupConferenceA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   hLine,
                   lphConfCall,
                   lphConsultCall,
                   dwNumParties,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetupConferenceW(
    HCALL               hCall,
    HLINE               hLine,
    LPHCALL             lphConfCall,
    LPHCALL             lphConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetupConferenceW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   hLine,
                   lphConfCall,
                   lphConsultCall,
                   dwNumParties,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetupTransfer(
    HCALL               hCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetupTransfer", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lphConsultCall,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetupTransferA(
    HCALL               hCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetupTransferA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lphConsultCall,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSetupTransferW(
    HCALL               hCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSetupTransferW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall,
                   lphConsultCall,
                   lpCallParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineShutdown(
    HLINEAPP            hLineApp
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineShutdown", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineSwapHold(
    HCALL               hActiveCall,
    HCALL               hHeldCall
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineSwapHold", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hActiveCall,
                   hHeldCall
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineTranslateAddress(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCSTR                  lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineTranslateAddress", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   lpszAddressIn,
                   dwCard,
                   dwTranslateOptions,
                   lpTranslateOutput
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineTranslateAddressA(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCSTR                  lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineTranslateAddressA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   lpszAddressIn,
                   dwCard,
                   dwTranslateOptions,
                   lpTranslateOutput
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineTranslateAddressW(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCWSTR                 lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineTranslateAddressW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   lpszAddressIn,
                   dwCard,
                   dwTranslateOptions,
                   lpTranslateOutput
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineTranslateDialog(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    HWND                hwndOwner,
    LPCSTR              lpszAddressIn
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineTranslateDialog", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   hwndOwner,
                   lpszAddressIn
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineTranslateDialogA(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    HWND                hwndOwner,
    LPCSTR              lpszAddressIn
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineTranslateDialogA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   hwndOwner,
                   lpszAddressIn
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineTranslateDialogW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    HWND                hwndOwner,
    LPCWSTR             lpszAddressIn
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineTranslateDialogW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLineApp,
                   dwDeviceID,
                   dwAPIVersion,
                   hwndOwner,
                   lpszAddressIn
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineUncompleteCall(
    HLINE               hLine,
    DWORD               dwCompletionID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineUncompleteCall", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwCompletionID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineUnhold(
    HCALL               hCall
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineUnhold", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hCall
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineUnpark(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineUnpark", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lphCall,
                   lpszDestAddress
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineUnparkA(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineUnparkA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lphCall,
                   lpszDestAddress
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
lineUnparkW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCWSTR             lpszDestAddress
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "lineUnparkW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return LINEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hLine,
                   dwAddressID,
                   lphCall,
                   lpszDestAddress
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneClose(
    HPHONE              hPhone
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneClose", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneConfigDialog(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneConfigDialog", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   hwndOwner,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneConfigDialogA(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneConfigDialogA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   hwndOwner,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneConfigDialogW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneConfigDialogW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   hwndOwner,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneDevSpecific(
    HPHONE              hPhone,
    LPVOID              lpParams,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneDevSpecific", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpParams,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetButtonInfo(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetButtonInfo", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwButtonLampID,
                   lpButtonInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetButtonInfoA(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetButtonInfoA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwButtonLampID,
                   lpButtonInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetButtonInfoW(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetButtonInfoW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwButtonLampID,
                   lpButtonInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetData(
    HPHONE              hPhone,
    DWORD               dwDataID,
    LPVOID              lpData,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetData", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwDataID,
                   lpData,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetDevCaps(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetDevCaps", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhoneApp,
                   dwDeviceID,
                   dwAPIVersion,
                   dwExtVersion,
                   lpPhoneCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetDevCapsA(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetDevCapsA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhoneApp,
                   dwDeviceID,
                   dwAPIVersion,
                   dwExtVersion,
                   lpPhoneCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetDevCapsW(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetDevCapsW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhoneApp,
                   dwDeviceID,
                   dwAPIVersion,
                   dwExtVersion,
                   lpPhoneCaps
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetDisplay(
    HPHONE              hPhone,
    LPVARSTRING         lpDisplay
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetDisplay", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpDisplay
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetGain(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwGain
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetGain", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwHookSwitchDev,
                   lpdwGain
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetHookSwitch(
    HPHONE              hPhone,
    LPDWORD             lpdwHookSwitchDevs
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetHookSwitch", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpdwHookSwitchDevs
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetIcon(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetIcon", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpszDeviceClass,
                   lphIcon
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetIconA(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetIconA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpszDeviceClass,
                   lphIcon
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetIconW(
    DWORD               dwDeviceID,
    LPCWSTR             lpszDeviceClass,
    LPHICON             lphIcon
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetIconW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   dwDeviceID,
                   lpszDeviceClass,
                   lphIcon
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetID(
    HPHONE              hPhone,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetID", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpDeviceID,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetIDA(
    HPHONE              hPhone,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetIDA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpDeviceID,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetIDW(
    HPHONE              hPhone,
    LPVARSTRING         lpDeviceID,
    LPCWSTR             lpszDeviceClass
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetIDW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpDeviceID,
                   lpszDeviceClass
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetLamp(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPDWORD             lpdwLampMode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetLamp", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwButtonLampID,
                   lpdwLampMode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetMessage(
    HPHONEAPP       hPhoneApp,
    LPPHONEMESSAGE  lpMessage,
    DWORD           dwTimeout
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetMessage", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhoneApp,
                   lpMessage,
                   dwTimeout
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetRing(
    HPHONE              hPhone,
    LPDWORD             lpdwRingMode,
    LPDWORD             lpdwVolume
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetRing", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpdwRingMode,
                   lpdwVolume
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetStatus(
    HPHONE              hPhone,
    LPPHONESTATUS       lpPhoneStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetStatus", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpPhoneStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetStatusA(
    HPHONE              hPhone,
    LPPHONESTATUS       lpPhoneStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetStatusA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpPhoneStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetStatusW(
    HPHONE              hPhone,
    LPPHONESTATUS       lpPhoneStatus
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetStatusW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpPhoneStatus
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetStatusMessages(
    HPHONE              hPhone,
    LPDWORD             lpdwPhoneStates,
    LPDWORD             lpdwButtonModes,
    LPDWORD             lpdwButtonStates
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetStatusMessages", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   lpdwPhoneStates,
                   lpdwButtonModes,
                   lpdwButtonStates
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneGetVolume(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwVolume
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneGetVolume", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwHookSwitchDev,
                   lpdwVolume
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneInitialize(
    LPHPHONEAPP         lphPhoneApp,
    HINSTANCE           hInstance,
    PHONECALLBACK       lpfnCallback,
    LPCSTR              lpszAppName,
    LPDWORD             lpdwNumDevs
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneInitialize", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lphPhoneApp,
                   hInstance,
                   lpfnCallback,
                   lpszAppName,
                   lpdwNumDevs
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneInitializeExA(
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCSTR                      lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneInitializeExA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lphPhoneApp,
                   hInstance,
                   lpfnCallback,
                   lpszFriendlyAppName,
                   lpdwNumDevs,
                   lpdwAPIVersion,
                   lpPhoneInitializeExParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneInitializeExW(
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCWSTR                     lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneInitializeExW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   lphPhoneApp,
                   hInstance,
                   lpfnCallback,
                   lpszFriendlyAppName,
                   lpdwNumDevs,
                   lpdwAPIVersion,
                   lpPhoneInitializeExParams
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneNegotiateAPIVersion(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneNegotiateAPIVersion", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhoneApp,
                   dwDeviceID,
                   dwAPILowVersion,
                   dwAPIHighVersion,
                   lpdwAPIVersion,
                   lpExtensionID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneNegotiateExtVersion(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtLowVersion,
    DWORD               dwExtHighVersion,
    LPDWORD             lpdwExtVersion
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneNegotiateExtVersion", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhoneApp,
                   dwDeviceID,
                   dwAPIVersion,
                   dwExtLowVersion,
                   dwExtHighVersion,
                   lpdwExtVersion
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneOpen(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    LPHPHONE            lphPhone,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD_PTR           dwCallbackInstance,
    DWORD               dwPrivilege
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneOpen", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhoneApp,
                   dwDeviceID,
                   lphPhone,
                   dwAPIVersion,
                   dwExtVersion,
                   dwCallbackInstance,
                   dwPrivilege
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetButtonInfo(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetButtonInfo", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwButtonLampID,
                   lpButtonInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetButtonInfoA(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetButtonInfoA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwButtonLampID,
                   lpButtonInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetButtonInfoW(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetButtonInfoW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwButtonLampID,
                   lpButtonInfo
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetData(
    HPHONE              hPhone,
    DWORD               dwDataID,
    LPVOID              const lpData,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetData", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwDataID,
                   lpData,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetDisplay(
    HPHONE              hPhone,
    DWORD               dwRow,
    DWORD               dwColumn,
    LPCSTR              lpsDisplay,
    DWORD               dwSize
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetDisplay", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwRow,
                   dwColumn,
                   lpsDisplay,
                   dwSize
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetGain(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwGain
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetGain", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwHookSwitchDev,
                   dwGain
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetHookSwitch(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDevs,
    DWORD               dwHookSwitchMode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetHookSwitch", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwHookSwitchDevs,
                   dwHookSwitchMode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetLamp(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    DWORD               dwLampMode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetLamp", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwButtonLampID,
                   dwLampMode
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetRing(
    HPHONE              hPhone,
    DWORD               dwRingMode,
    DWORD               dwVolume
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetRing", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwRingMode,
                   dwVolume
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetStatusMessages(
    HPHONE              hPhone,
    DWORD               dwPhoneStates,
    DWORD               dwButtonModes,
    DWORD               dwButtonStates
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetStatusMessages", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwPhoneStates,
                   dwButtonModes,
                   dwButtonStates
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneSetVolume(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwVolume
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneSetVolume", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhone,
                   dwHookSwitchDev,
                   dwVolume
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
phoneShutdown(
    HPHONEAPP           hPhoneApp
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "phoneShutdown", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return PHONEERR_OPERATIONUNAVAIL;
   }

   return (*lpfn)(
                   hPhoneApp
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiGetLocationInfo(
    LPSTR               lpszCountryCode,
    LPSTR               lpszCityCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiGetLocationInfo", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   lpszCountryCode,
                   lpszCityCode
                 );
}
    
//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiGetLocationInfoA(
    LPSTR               lpszCountryCode,
    LPSTR               lpszCityCode
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiGetLocationInfoA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   lpszCountryCode,
                   lpszCityCode
                 );
}
    
//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiGetLocationInfoW(
    LPWSTR               lpszCountryCodeW,
    LPWSTR               lpszCityCodeW
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiGetLocationInfoW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   lpszCountryCodeW,
                   lpszCityCodeW
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiRequestDrop(
    HWND                hwnd,
    WPARAM              wRequestID
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiRequestDrop", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   hwnd,
                   wRequestID
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiRequestMakeCall(
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiRequestMakeCall", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   lpszDestAddress,
                   lpszAppName,
                   lpszCalledParty,
                   lpszComment
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiRequestMakeCallA(
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiRequestMakeCallA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   lpszDestAddress,
                   lpszAppName,
                   lpszCalledParty,
                   lpszComment
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiRequestMakeCallW(
    LPCWSTR             lpszDestAddress,
    LPCWSTR             lpszAppName,
    LPCWSTR             lpszCalledParty,
    LPCWSTR             lpszComment
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiRequestMakeCallW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   lpszDestAddress,
                   lpszAppName,
                   lpszCalledParty,
                   lpszComment
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiRequestMediaCall(
    HWND                hwnd,
    WPARAM              wRequestID,
    LPCSTR              lpszDeviceClass,
    LPCSTR              lpDeviceID,
    DWORD               dwSize,
    DWORD               dwSecure,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiRequestMediaCall", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   hwnd,
                   wRequestID,
                   lpszDeviceClass,
                   lpDeviceID,
                   dwSize,
                   dwSecure,
                   lpszDestAddress,
                   lpszAppName,
                   lpszCalledParty,
                   lpszComment
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiRequestMediaCallA(
    HWND                hwnd,
    WPARAM              wRequestID,
    LPCSTR              lpszDeviceClass,
    LPCSTR              lpDeviceID,
    DWORD               dwSize,
    DWORD               dwSecure,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiRequestMediaCallA", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   hwnd,
                   wRequestID,
                   lpszDeviceClass,
                   lpDeviceID,
                   dwSize,
                   dwSecure,
                   lpszDestAddress,
                   lpszAppName,
                   lpszCalledParty,
                   lpszComment
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
LONG
WINAPI
tapiRequestMediaCallW(
    HWND                hwnd,
    WPARAM              wRequestID,
    LPCWSTR             lpszDeviceClass,
    LPCWSTR             lpDeviceID,
    DWORD               dwSize,
    DWORD               dwSecure,
    LPCWSTR             lpszDestAddress,
    LPCWSTR             lpszAppName,
    LPCWSTR             lpszCalledParty,
    LPCWSTR             lpszComment
    )
{
   static TAPIPROC lpfn = NULL;
   LONG lResult;

   if ( lpfn == NULL )
   {
      //
      // Did we have a problem?
      //
      if ( 0 != (lResult = GetTheFunctionPtr( "tapiRequestMediaCallW", &lpfn )) )
      {
         lpfn = (TAPIPROC)-1;
         return lResult;
      }
   }

   //
   // Have we determined that this is a lost cause?
   //
   if ( (TAPIPROC)-1 == lpfn )
   {
      return TAPIERR_REQUESTFAILED;
   }

   return (*lpfn)(
                   hwnd,
                   wRequestID,
                   lpszDeviceClass,
                   lpDeviceID,
                   dwSize,
                   dwSecure,
                   lpszDestAddress,
                   lpszAppName,
                   lpszCalledParty,
                   lpszComment
                 );
}

//**************************************************************************
//**************************************************************************
//**************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\explib\wave.cpp ===
/*
*) Functions to simplify recording & playback of wave file/data to a line/phone
*) Put the code in TAPI32L.LIB?  Then only apps that need it, get it

    +) tapiMakeNoise(
                      DWORD  Device Type: PHONE/LINE/WAVE, etc?
                      HANDLE Device Handle,
                      DWORD  NoiseType:   BUFFER/FILENAME/HFILE(readfile directly?)/MMIOHANDLE
                      HANDLE hArray - array of type NoiseTypes that are to be played serially
                      DWORD  Flags:
                              fSYNC
                              fSTOP_EXISTING_PLAYING_IF_ANY
                    );

        -) How to handle hardware assist?  IE: Hey, hardware, play prompt #7 - how would an 
                       app know how/when to request that?

        -) What about proprietary wave formats? How to know what proprietary formats the hardware supports?
                Just try it?

        -) What about conversions?  How to know what conversions the hardware can do

        -) How about a notification method?  Such that an app can know when the wave is done.

        -)


*/        
        
        
        
        
#define STRICT

#include "windows.h"
#include "windowsx.h"
#include "mmsystem.h"
#include "tapi.h"


#if DBG

VOID
DbgPrtWave(
    IN DWORD  dwDbgLevel,
    IN PTCHAR lpszFormat,
    IN ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
//    if (dwDbgLevel <= gdwDebugLevel)
    {
        TCHAR    buf[1280];
        va_list ap;


        va_start(ap, lpszFormat);

        wsprintf(buf, TEXT("CallUpW (0x%08lx) - "), GetCurrentThreadId() );

        wvsprintf (&buf[23],
                   lpszFormat,
                   ap
                  );

        lstrcat (buf, TEXT("\n"));

        OutputDebugString (buf);

        va_end(ap);
    }
}

#define WDBGOUT(_x_) DbgPrtWave _x_

#else

#define WDBGOUT(_x_)

#endif


//****************************************************************************
//****************************************************************************
//****************************************************************************
unsigned long WINAPI WaveThread( LPVOID junk );

void CALLBACK WaveOutCallback(
    HWAVE  hWave,    // handle of waveform device
    UINT  uMsg,    // sent message
    DWORD  dwInstance,    // instance data
    DWORD  dwParam1,    // application-defined parameter
    DWORD  dwParam2    // application-defined parameter
   );



enum 
{
    DEVICE_WAVEID,
    DEVICE_WAVEHANDLE,
    DEVICE_HLINE,
    DEVICE_HPHONE,
    DEVICE_HCALL
};
enum
{
    SOURCE_WAVEFILE,
    SOURCE_MSDOSFILE,
    SOURCE_MEM
};
class WaveDevice;
class WaveOperation;

#define OPERATIONSTATUS_DONTPLAYTHIS 0x00000001



#define MAX_NUM_BUFFERS (8)
#define BUFFER_SIZE (8192)
typedef    struct {
               ULONG           uBufferLength;
               WaveOperation * poWaveOperation;
               PBYTE           pBuffer;
           } MISCINFO;



//****************************************************************************
//****************************************************************************
LONG gfInited = 0;
BOOLEAN     gfShutdown = FALSE;
WaveDevice *gpoWaveDeviceList = NULL;
HANDLE      ghFreeBufferEvent = 0;
HANDLE      ghWaveThread = NULL;
MISCINFO   *gDoneBuffersToBeProcessed[MAX_NUM_BUFFERS + 1];
CRITICAL_SECTION gCriticalSection;

//****************************************************************************
//****************************************************************************
//****************************************************************************

class WaveOperation
{
    public:
    
        DWORD   dwSourceType;
        union
        {
            PTSTR  psz;
            
            PBYTE  pb;
            
            HANDLE h;

            LONG   l;
            
        } SourceThing;
        
        class WaveOperation * pNextWaveOperationInList;
        
        class WaveDevice    * poWaveDevice;
        
        HANDLE    hSyncEvent;
        
        DWORD   dwStatus;
        
        DWORD   cFileSize;
        DWORD   cDataRemaining;
        DWORD   cDataDonePlaying;
        BOOLEAN fInited;

        LONG WaveOperation::InitOperation(
                                            class WaveDevice * poWaveDevice,
                                            DWORD dwSoundTypeIn,
                                            LONG  lSourceThing
                                         );
                                         
        virtual LONG     InitSpecific( void ) = 0;
        virtual ULONG    GetData( PBYTE pBuffer, ULONG uBufferSize ) = 0;
        virtual void     FreeSpecific( void ) = 0;
        
        inline  WaveOperation * GetpNext();
        inline  void            SetpNext( WaveOperation * );
        
        inline  HANDLE GetSyncEvent();
        inline  void   SetSyncEvent( HANDLE );
        
        inline void ProcessDoneBuffer( MISCINFO * pMiscInfo );
        inline ULONG BytesNotDonePlaying( void );
};


//****************************************************************************
//****************************************************************************
//****************************************************************************
class WaveDevice
{
    ULONG     uDeviceId;
    DWORD     dwDeviceType;
    HANDLE    hDevice;
    
    HWAVEOUT  hWaveOut;
    CRITICAL_SECTION  CriticalSection;
    
    ULONG uUsageCount;
    
    class WaveDevice     * pNextWaveDeviceInList;

    class WaveOperation  *  CurrentWaveOperation;
    class WaveOperation  *  LastWaveOperation;
    
    

    ULONG     Head;
    ULONG     Tail;

    ULONG     NumFreeBuffers;
    ULONG     cBufferSize;

    PBYTE     FreeQueue[MAX_NUM_BUFFERS];
    WAVEHDR   WaveHeader[MAX_NUM_BUFFERS];
    MISCINFO  MiscInfo[MAX_NUM_BUFFERS];

    DWORD     dwStatusBits;

    
    public:

        inline ULONG GetNumFreeBuffers( void );
        DWORD GetStatus( void );
        void TerminateAllOperations( void );
        LONG KillWaveDevice( BOOLEAN fWaitForThreadTermination );
        LONG CloseWaveDevice();
        LONG InitWaveDevice( ULONG  uDeviceId );
        LONG OpenWaveDevice( WAVEFORMATEX * pWaveFormat );
    
        inline  WaveDevice * GetpNext();
        inline  void         SetpNext( WaveDevice * );
        
        LONG QueueOperation( class WaveOperation * );
        class WaveOperation * NextOperation();

        ULONG PlaySomeData( BOOL fPrimeOnly );

        inline void ReturnToFreeBufferQueue( PBYTE pBuffer );
        inline void IncrementBytesPlayed( ULONG cCount );
        inline ULONG GetWaveDeviceId( void );
        
        inline CRITICAL_SECTION * GetCriticalSection( void );

//        static void CALLBACK WaveOutCallback(
//                       HWAVE  hWave,    // handle of waveform device
//                       UINT   uMsg,     // sent message
//                       DWORD  dwInstance,    // instance data
//                       DWORD  dwParam1,    // application-defined parameter
//                       DWORD  dwParam2    // application-defined parameter
//                      );

        void  IncUsageCount( void );
        void  DecUsageCount( void );
        UINT  GetUsageCount( void );
};


//****************************************************************************
LONG WaveDevice::InitWaveDevice( ULONG  uDevId )
{
    LONG lResult = 0;
    ULONG n;


    WDBGOUT((4, "Entering InitWaveDevice"));


    // 
    // Alloc some buffers
    // 
    Head = 0;
    Tail = 0;
    NumFreeBuffers = 0;

    uUsageCount = 0;
    
    dwStatusBits = 0;

    cBufferSize = BUFFER_SIZE;
    
    uDeviceId = uDevId;

    for ( n = 0; n < MAX_NUM_BUFFERS; n++ )
    {
        FreeQueue[n] = (PBYTE)LocalAlloc(LPTR, cBufferSize);
        
        if ( NULL == FreeQueue[n] )
        {
            WDBGOUT((1, "Mem alloc failed.  Size= 0x%08lx", cBufferSize));
        
            while ( n )
            {
                LocalFree( FreeQueue[n-1] );
                n--;
            }
            
            return( LINEERR_NOMEM );
        }
        
        NumFreeBuffers++;

    }


    InitializeCriticalSection( &CriticalSection );
    
    
    CurrentWaveOperation = NULL;
    LastWaveOperation = NULL;

    
    return( lResult );
}

    
//****************************************************************************
inline ULONG WaveDevice::GetWaveDeviceId( void )
{
    return uDeviceId;
}


//****************************************************************************
inline ULONG WaveDevice::GetNumFreeBuffers( void )
{
    return NumFreeBuffers;
}


//****************************************************************************
LONG WaveDevice::OpenWaveDevice( WAVEFORMATEX * pWaveFormat )
{
    ULONG u;
    LONG lResult;
    
    WDBGOUT((4, "Entering OpenWaveDevice"));
    
    lResult = (LONG)waveOutOpen(
                 &hWaveOut,
                 uDeviceId,
                 pWaveFormat,
                 (DWORD)WaveOutCallback,
                 (DWORD)this,
                 CALLBACK_FUNCTION | WAVE_MAPPED
               );

//{
//    TCHAR buf[500];
//    wsprintf( buf, "woo on %lx ret=0x%lx", uDeviceId, lResult);
//    MessageBox(GetFocus(), buf, buf, MB_OK);
//}      


    
    if ( lResult )
    {
        WDBGOUT((1, "waveOutOpen returned 0x%08lx", lResult ));
        return( LINEERR_NOMEM);  //TODO LATER: Diff ret codes?
    }
    
    for ( u = 0; u < NumFreeBuffers; u++ )
    {
        WaveHeader[u].lpData = (LPSTR)FreeQueue[u];

        WaveHeader[u].dwBufferLength = cBufferSize;

        WaveHeader[u].dwFlags = 0;

        lResult = waveOutPrepareHeader(
                              hWaveOut,
                              &(WaveHeader[u]),
                              sizeof(WAVEHDR)
                            );
        if ( lResult )
        {
            WDBGOUT((1, TEXT("waveOutPrepareHeader returned 0x%08lx"), lResult ));
            return( LINEERR_NOMEM);  //TODO LATER: Diff ret codes?
        }
    
    }

    WDBGOUT((4, TEXT("Leaving OpenWaveDevice result = 0x0")));
    return( 0 );
}
    
    
////****************************************************************************
//LONG WaveDevice::RestartDevice( WAVEFORMATEX * pWaveFormat )
//{
//    ULONG n;
//    
//
//    WDBGOUT((4, "Entering RestartDevice"));
//
//
//    //  Reset wave device
//    WDBGOUT((4, TEXT("Resetting the wave device...")));
//    waveOutReset( hWaveOut );
//
//    //
//    // Wait until all of the outstanding buffers are back.
//    //
//    WDBGOUT((4, TEXT("Waiting for all buffers to be returned...")));
//    while ( NumFreeBuffers < MAX_NUM_BUFFERS )
//    {
//        Sleep(0);
//    }
//
//    WDBGOUT((4, TEXT("Closing the wave device...")));
//    waveOutClose( hWaveOut );
//
//    
//
//    return( 0 );
//}
//
    

//****************************************************************************
LONG WaveDevice::CloseWaveDevice()
{

    WDBGOUT((4, "Entering CloseWaveDevice"));


    //  Reset wave device
    WDBGOUT((4, TEXT("Resetting the wave device...")));
    waveOutReset( hWaveOut );

    //
    // Wait until all of the outstanding buffers are back.
    //
    WDBGOUT((4, TEXT("Waiting for all buffers to be returned...")));
    while ( NumFreeBuffers < MAX_NUM_BUFFERS )
    {
        Sleep(0);
    }

    WDBGOUT((4, TEXT("Closing the wave device...")));
    waveOutClose( hWaveOut );
    
    return( 0 );
}

    
//****************************************************************************
LONG WaveDevice::KillWaveDevice( BOOLEAN fWaitForThreadTermination )
{
    ULONG n;
    WaveDevice * poTempDevice;

    

    WDBGOUT((4, "Entering KillWaveDevice"));


    
    //  Reset wave device
    WDBGOUT((4, TEXT("Resetting the wave device...")));
    waveOutReset( hWaveOut );

    //
    // Wait until all of the outstanding buffers are back.
    //
    WDBGOUT((4, TEXT("Waiting for all buffers to be returned...")));
    while ( NumFreeBuffers < MAX_NUM_BUFFERS )
    {
        Sleep(0);
    }

    WDBGOUT((4, TEXT("Closing the wave device...")));
    waveOutClose( hWaveOut );
    
    //
    // Free the memory for all of the buffers
    //
    for ( n=0; n<MAX_NUM_BUFFERS; n++ )
    {
        LocalFree( FreeQueue[n] );

        FreeQueue[n] = NULL;
    }
    
    
    //
    // Remove the device from the global list
    //
    poTempDevice = gpoWaveDeviceList;
    
    if ( poTempDevice == this )
    {
        gpoWaveDeviceList = GetpNext();
    }
    else
    {
        while (    poTempDevice
                &&
                  ( (*poTempDevice).GetpNext() != this )
              )
        {
            poTempDevice =(*poTempDevice).GetpNext();
        }

        //
        // The next one in the list is it.  Remove the link.
        //
        if ( poTempDevice != NULL )
        {
           //
           // Adjust the list pointers
           //
           (*poTempDevice).SetpNext( GetpNext() );
        }
    }

    DeleteCriticalSection( &CriticalSection );

    delete this;
    


    //
    // Are all of the devices dead and buried?
    //
    if ( NULL == gpoWaveDeviceList )
    {
        gfShutdown = TRUE;
//TODO NOW: fix this        gfInited   = 0;
    
        //
        // Signal the other thread to come down
        //
        SetEvent( ghFreeBufferEvent );
        
        //
        // Wait 'till the thread is dead?
        //
        if ( fWaitForThreadTermination )
        {
            WaitForSingleObject( ghWaveThread, INFINITE );
        }
        
        CloseHandle( ghWaveThread );
        
        //
        // Zero this so we start fresh next time.
        //
//        ghWaveThread = NULL;
    }
    
    
    
    return( 0 );
}


    
//****************************************************************************
inline DWORD WaveDevice::GetStatus( void )
{
    return dwStatusBits;
}

    
//****************************************************************************
inline void WaveDevice::TerminateAllOperations( void )
{
    WaveOperation *poWaveOperation;
    
    WDBGOUT((3, TEXT("Entering TerminateAllOps")));
    
    EnterCriticalSection( &CriticalSection );
    
    poWaveOperation = CurrentWaveOperation;
    
    while ( poWaveOperation )
    {
        WDBGOUT((4, TEXT("Tainting oper: 0x%08lx"), poWaveOperation ));
        
        (*poWaveOperation).dwStatus |= OPERATIONSTATUS_DONTPLAYTHIS;
        
        poWaveOperation = (*poWaveOperation).GetpNext();
    }

    //
    //  Reset wave device to force all the buffers in
    //
    WDBGOUT((4, TEXT("Resetting the wave device...")));
    waveOutReset( hWaveOut );

    LeaveCriticalSection( &CriticalSection );
    
    WDBGOUT((3, TEXT("Leaving TerminateAllOps")));
}

    
//****************************************************************************
inline CRITICAL_SECTION * WaveDevice::GetCriticalSection( void )
{
   return &CriticalSection;
}


//****************************************************************************
inline WaveDevice * WaveDevice::GetpNext()
{
    return( pNextWaveDeviceInList );
    
}


//****************************************************************************
inline void WaveDevice::SetpNext(WaveDevice * pWaveDevice)
{
    pNextWaveDeviceInList = pWaveDevice;
}


//****************************************************************************
inline void  WaveDevice::IncUsageCount( void )
{
    uUsageCount++;
};
                
                      
//****************************************************************************
inline void  WaveDevice::DecUsageCount( void )
{
    uUsageCount--;
};
                
                      
//****************************************************************************
inline UINT  WaveDevice::GetUsageCount( void )
{
    return uUsageCount;
};
                
                      
//****************************************************************************
LONG WaveDevice::QueueOperation( class WaveOperation *poNewWaveOperation )
{

    WDBGOUT((3, TEXT("Entering QueueOperation")));
    
    EnterCriticalSection( &CriticalSection );
    

    (*poNewWaveOperation).SetpNext( NULL );

    //
    // Add operation to list
    //
    if ( LastWaveOperation )
    {
        (*LastWaveOperation).SetpNext( poNewWaveOperation );
    }

    LastWaveOperation = poNewWaveOperation;

    if ( NULL == CurrentWaveOperation )
    {
        CurrentWaveOperation = poNewWaveOperation;
    }
    
    
    LeaveCriticalSection( &CriticalSection );
    
    WDBGOUT((4, TEXT("Created new oper: 0x%08lx"), poNewWaveOperation));
    
    WDBGOUT((3, TEXT("Leaving QueueOperation")));
    return( 0 );
}
    

//****************************************************************************
class WaveOperation * WaveDevice::NextOperation()
{
    //
    // This function will get rid of the operation at the top of this wave
    // device's operation queue, and will update the queue to reflect the next
    // as now the first.
    //


    WDBGOUT((3, TEXT("Entering NextOperation")));


    EnterCriticalSection( &CriticalSection );
    
    if ( CurrentWaveOperation )
    {
        WaveOperation * poWaveOperation;
        WaveOperation * poTempOperation;
        
        poWaveOperation = (*CurrentWaveOperation).GetpNext();
        delete CurrentWaveOperation;
        
        while ( poWaveOperation )
        {
            //
            // If we can play this operation, break outta this loop
            //
            if ( !( (*poWaveOperation).dwStatus & OPERATIONSTATUS_DONTPLAYTHIS) )
            {
WDBGOUT((55, TEXT("How much break?")));
                break;
            }
            
            //
            // We're not supposed to play this operation
            //
            
            if ( (*poWaveOperation).hSyncEvent )
            {
                WDBGOUT((5, TEXT("Caller was waiting.  Signaling...")));
                SetEvent( (*poWaveOperation).hSyncEvent );
            }

            
            poTempOperation = (*poWaveOperation).GetpNext();
            
            delete poWaveOperation;
            
            poWaveOperation = poTempOperation;
            
        }
        
WDBGOUT((55, TEXT("Not too much")));
        CurrentWaveOperation = poWaveOperation;
    }
WDBGOUT((55, TEXT("was it Too much?")));
   
    //
    // The CurrentWaveOperation may have been "NULLED" out by the previous stuff
    //
    if ( NULL == CurrentWaveOperation )
    {
        LastWaveOperation = NULL;
    }

    LeaveCriticalSection( &CriticalSection );

    WDBGOUT((4, TEXT("Leaving NextOperation - returning 0x%08lx"), CurrentWaveOperation));

    return( CurrentWaveOperation );
}    
        
       

//****************************************************************************
inline void WaveDevice::ReturnToFreeBufferQueue( PBYTE pBuffer )
{
    FreeQueue[Tail] = pBuffer;
    
    //
    // If we're at the end of the list, wrap.
    //
    Tail = ( Tail + 1 )  % MAX_NUM_BUFFERS;

    NumFreeBuffers++;
}                             


//****************************************************************************
inline void WaveDevice::IncrementBytesPlayed( ULONG cCount )
{

//    //
//    // If there is an operation on the dying queue, this must be from it
//    //
//    if ( DyingWaveOperation )
//    {
//        //
//        // Is it dead yet?
//        //
//        if ( 0 == DyingWaveOperation->BytesNotDonePlaying() )
//        {
//           WaveOperation * poNextOperation;
//
//           EnterCriticalSection( &CriticalSection );
//
//           //
//           // Yes, it's dead.
//           //
//           poNextOperation = DyingWaveOperation->GetpNext();
//
//           //
//           // Was the caller waiting (ie: was it sync) ?
//           //
//           if ( (*DyingWaveOperation).GetSyncEvent() )
//           {
//               SetEvent( (*DyingWaveOperation).GetSyncEvent() );
//           }
//        
//           delete DyingWaveOperation;
//
//           DyingWaveOperation = poNextOperation;
//
//           LeaveCriticalSection( &CriticalSection );
//        }
//    }
//  
    //TODO LATER: Keep a total count of bytes played out this device?

}

                       
//****************************************************************************
//****************************************************************************
//****************************************************************************



//****************************************************************************
LONG WaveOperation::InitOperation(
                                          class WaveDevice * poWaveDeviceIn,
                                          DWORD dwSourceTypeIn,
                                          LONG  lSourceThing
                                        )
{
    WDBGOUT((4, TEXT("Entering InitOperation")));

    dwSourceType   = dwSourceTypeIn;
    SourceThing.l  = lSourceThing;
    poWaveDevice   = poWaveDeviceIn;
    
    pNextWaveOperationInList = NULL;
    
    (*poWaveDevice).IncUsageCount();

    dwStatus = 0;

    fInited = FALSE;
        
    return(0);
}                                 
                                 
    
//****************************************************************************
inline HANDLE WaveOperation::GetSyncEvent()
{
    return( hSyncEvent );
}


//****************************************************************************
inline void WaveOperation::SetSyncEvent( HANDLE hEvent )
{
    hSyncEvent = hEvent;
    return;
}


//****************************************************************************
inline WaveOperation * WaveOperation::GetpNext()
{
    return( pNextWaveOperationInList );
    
}


//****************************************************************************
inline void WaveOperation::SetpNext(WaveOperation * pWaveOperation)
{
    pNextWaveOperationInList = pWaveOperation;
}


//****************************************************************************
inline void WaveOperation::ProcessDoneBuffer( MISCINFO * pMiscInfo )
{
    ULONG nBytesQueued;
           
    WDBGOUT((3, TEXT("Entering ProcessDoneBuffer")));

    cDataDonePlaying += pMiscInfo->uBufferLength;

    WDBGOUT((11, TEXT("Now - size=0x%08lx  done=0x%08lx"),
                  cFileSize,
                  cDataDonePlaying));


    (*poWaveDevice).IncrementBytesPlayed( pMiscInfo->uBufferLength );
    (*poWaveDevice).ReturnToFreeBufferQueue( pMiscInfo->pBuffer );

    //
    // Has someone decided this wave should stop?
    //
    if ( dwStatus & OPERATIONSTATUS_DONTPLAYTHIS )
    {
        if ( (*poWaveDevice).GetNumFreeBuffers() != MAX_NUM_BUFFERS )
        {
            WDBGOUT((4, TEXT("Bailing from ProcessDoneBuffer - dontplay")));
            return;
        }
        
        cDataDonePlaying = cFileSize;
    }

    //
    // Is this thing already dead?
    //
    if ( cDataDonePlaying >= cFileSize )
    {

        WDBGOUT((4, TEXT("Done playing this:0x%08lx"), this ));


        //
        // Was the caller waiting (ie: was it sync) ?
        //
        if ( hSyncEvent )
        {
            WDBGOUT((5, TEXT("Caller was waiting.  Signaling...")));
            SetEvent( hSyncEvent );
        }

//TODO LATER: PERFORMANCE: If the next format is the same as this one, don't close the device

        (*poWaveDevice).CloseWaveDevice();


        (*poWaveDevice).DecUsageCount();


        EnterCriticalSection( &gCriticalSection );
        
        //
        // Was this the last oper?
        //
        if ( (*poWaveDevice).GetUsageCount() == 0 )
        {
            WDBGOUT((4, TEXT("Last oper out...")));

            (*poWaveDevice).KillWaveDevice(FALSE);
        }
        else
        {
           WaveOperation * pNewOperation;
           
           //
           // Move up the next operation
           //
           while ( TRUE )
           {
               pNewOperation = (*poWaveDevice).NextOperation();
               
               if ( NULL == pNewOperation )
               {
                  if ( (*poWaveDevice).GetUsageCount() == 0 )
                  {
                      WDBGOUT((4, TEXT("No more ops to run...")));

                      (*poWaveDevice).KillWaveDevice(FALSE);
                  }
                  
                  //
                  // All operations done.  Go away.
                  //
                  WDBGOUT((3, TEXT("All operations seem to be done...")));
                  break;
               }
               
               WDBGOUT((3, TEXT("Playing data from new op...")));
               nBytesQueued = (*poWaveDevice).PlaySomeData( FALSE );
               
               if ( nBytesQueued )
               {
                  //
                  // There were some bytes played.  Break the loop...
                  //
                  break;
               }
               
               //
               // Was the caller waiting (ie: was it sync) ?
               //
               if ( pNewOperation->hSyncEvent )
               {
                   WDBGOUT((3, TEXT("No data in new op and caller is waiting...")));
                   SetEvent( pNewOperation->hSyncEvent );
               }

               //
               // Update the counter.  This op is, for all intents and purposes, done.
               //
               (*poWaveDevice).DecUsageCount();
        
               WDBGOUT((3, TEXT("No data in new op.  Looking for next...")));
           }
           
        }

        FreeSpecific();

        delete this;
        
        LeaveCriticalSection( &gCriticalSection );
    }
    else
    {
        WDBGOUT((3, TEXT("Playing data from same op...")));
        (*poWaveDevice).PlaySomeData( FALSE );
    }
    
    WDBGOUT((3, TEXT("Leaving ProcessDoneBuffer")));
}


//****************************************************************************

                       
//****************************************************************************
inline ULONG WaveOperation::BytesNotDonePlaying( void )
{
    return cFileSize - cDataDonePlaying;
}

                       
//****************************************************************************
//****************************************************************************
class BufferWave: public WaveOperation
{
    PBYTE   pData;  // Pointer to the data to play
    PBYTE   pCurrentPointer;
    
    public:
        LONG BufferWave::InitSpecific( void );
        ULONG GetData( PBYTE pBuffer, ULONG uBufferSize );
        void BufferWave::FreeSpecific( void );
};


//****************************************************************************
LONG BufferWave::InitSpecific( void )
{
    pData = SourceThing.pb;
    
    pCurrentPointer = pData;
    
    return(0);
}


//****************************************************************************
ULONG BufferWave::GetData( PBYTE pBuffer, ULONG uBufferSize )
{
    ULONG uBytesToPlay;

    uBytesToPlay = (cDataRemaining > uBufferSize) ?
                        uBufferSize    :
                        cDataRemaining;

    cDataRemaining -= uBytesToPlay;
    
    memcpy( pBuffer, pCurrentPointer, uBytesToPlay );
    
    pCurrentPointer += uBytesToPlay;
    
    return( uBytesToPlay );
}



//****************************************************************************
void BufferWave::FreeSpecific( void )
{
    return;
}


//****************************************************************************
//****************************************************************************
class WaveFile: public WaveOperation
{
    HMMIO hmmio;
    
    public:
        LONG WaveFile::InitSpecific( void );
        ULONG GetData( PBYTE pBuffer, ULONG uBufferSize );
        void WaveFile::FreeSpecific( void );
};


//****************************************************************************
LONG WaveFile::InitSpecific( void )
{
    MMCKINFO    mmckinfoParent;   /* parent chunk information structure */ 
    MMCKINFO    mmckinfoSubchunk; /* subchunk information structure    */ 
    DWORD       dwFmtSize;        /* size of "fmt" chunk               */ 
    WAVEFORMATEX Format;          /* pointer to memory for "fmt" chunk */ 
    LONG         lResult;


    WDBGOUT((4, TEXT("Entering WaveFile::InitSpecific")));


    hmmio = mmioOpen(
                      SourceThing.psz,
                      NULL,
                      MMIO_READ
                    );

    //
    // Did the open go ok?
    //
    if ( NULL == hmmio )
    {
       //
       // Nope.
       //
       WDBGOUT((1, TEXT("Error during mmioOpen of [%s] - err=0x%08lx"),
                   (SourceThing.psz == NULL) ? "" : SourceThing.psz,
                   GetLastError() ));

       return LINEERR_OPERATIONFAILED;
    }


    /* 
     * Locate a "RIFF" chunk with a "WAVE" form type 
     * to make sure the file is a WAVE file. 
     */ 
    mmckinfoParent.fccType = mmioFOURCC('W', 'A', 'V', 'E'); 

	WDBGOUT((11, TEXT("Descend WAVE")));
    if ( mmioDescend(
                      hmmio,
                      (LPMMCKINFO) &mmckinfoParent,
                      NULL, 
                      MMIO_FINDRIFF)
       )
    { 
       WDBGOUT((1, TEXT("This is not a WAVE file - [%s]"),
                   (SourceThing.psz == NULL) ? "" : SourceThing.psz));
       mmioClose( hmmio, 0); 
       return LINEERR_INVALPARAM; 
    } 


    /* 
     * Find the "fmt " chunk (form type "fmt "); it must be 
     * a subchunk of the "RIFF" parent chunk. 
     */ 
    mmckinfoSubchunk.ckid = mmioFOURCC('f', 'm', 't', ' '); 

	WDBGOUT((11, TEXT("Descend FMT")));
    if ( mmioDescend(
                      hmmio,
                      &mmckinfoSubchunk,
                      &mmckinfoParent,
                      MMIO_FINDCHUNK)
       )
    { 
       WDBGOUT((1, TEXT("WAVE file has no \"fmt\" chunk")));
       mmioClose(hmmio, 0); 
       return LINEERR_INVALPARAM; 
    } 


     /* 
      * Get the size of the "fmt " chunk--allocate and lock memory for it. 
      */ 
     dwFmtSize = mmckinfoSubchunk.cksize; 


	WDBGOUT((11, TEXT("read fmt")));
    /* Read the "fmt " chunk. */ 
     mmioRead(
                   hmmio,
                   (HPSTR)&Format,
                   sizeof(Format) );
 //   {
 //      WDBGOUT((1, TEXT("Failed to read format chunk.")));
 //      mmioClose(pMyWaveFile->hmmio, 0); 
 //      return 1; 
 //   }



	WDBGOUT((11, TEXT("Ascend fmt")));
    /* Ascend out of the "fmt " subchunk. */ 
    mmioAscend(hmmio, &mmckinfoSubchunk, 0); 


    
    /* 
    * Find the data subchunk. The current file position 
    * should be at the beginning of the data chunk. 
    */ 
    mmckinfoSubchunk.ckid = mmioFOURCC('d', 'a', 't', 'a'); 

	WDBGOUT((11, TEXT("Descend DATA")));
    if ( mmioDescend(
                      hmmio,
                      &mmckinfoSubchunk,
                      &mmckinfoParent, 
                      MMIO_FINDCHUNK)
       )
    {
       WDBGOUT((1, TEXT("WAVE file has no data chunk.")));
       mmioClose(hmmio, 0); 
       return LINEERR_INVALPARAM; 
    } 
   
    /* Get the size of the data subchunk. */ 
    cFileSize      = mmckinfoSubchunk.cksize; 
    cDataRemaining = mmckinfoSubchunk.cksize; 

    cDataDonePlaying = 0;

    
	WDBGOUT((11, TEXT("OpenWaveDev")));
    lResult = poWaveDevice->OpenWaveDevice( &Format );
    

//    if ( cDataRemaining == 0L)
//    {
//       WDBGOUT((1, TEXT("The data chunk contains no data.")));
//       mmioClose(hmmio, 0); 
//       return 0;  //TODO LATER: Right?  It's not an error...
// It'll just get 0 bytes on the first read...
//    } 

    return( lResult );
}



//****************************************************************************
ULONG WaveFile::GetData( PBYTE pBuffer, ULONG uBufferSize )
{
    ULONG uBytesToPlay;
    ULONG uBytesRead;


    WDBGOUT((11, TEXT("Entering WaveFile::GetData")));


    //
    // Have we done anything yet?
    //
    if ( !fInited )
    {
        if ( InitSpecific() )
        {
            return( 0 );
        }
        fInited = TRUE;
    }
    
   
    uBytesToPlay = (cDataRemaining > uBufferSize) ?
                        uBufferSize    :
                        cDataRemaining;


    if ( 0 == uBytesToPlay )
    {
        return 0;
    }


    /* Read the waveform data subchunk. */ 
    uBytesRead = mmioRead(
                           hmmio,
                           (LPSTR)pBuffer,
                           uBytesToPlay
                         );


    if ( uBytesRead != uBytesToPlay )
    {
        WDBGOUT((1, TEXT("Failed to properly read data chunk.")));
        mmioClose(hmmio, 0); 
        return 0;
    } 

    cDataRemaining -= uBytesToPlay;
    
    return( uBytesToPlay );
}


//****************************************************************************
void WaveFile::FreeSpecific( void )
{
    mmioClose(hmmio, 0); 
    return;
}


//****************************************************************************
//****************************************************************************
class DosFile: public WaveOperation
{
    HANDLE   hFile;
    
    public:
        LONG DosFile::InitSpecific( void );
        ULONG GetData( PBYTE pBuffer, ULONG uBufferSize );
        void DosFile::FreeSpecific( void );
};

//****************************************************************************
LONG DosFile::InitSpecific( void )
{
    BOOL fResult;
//    WIN32_FILE_ATTRIBUTE_DATA FileInfo;
    BY_HANDLE_FILE_INFORMATION FileInfo;
    
    hFile = CreateFile(
                        SourceThing.psz,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                      );

    if ( 0 == hFile )
    {
        WDBGOUT((1, TEXT("Error doing OpenFile( lpszName ) GetLastError=0x%)8lx"),
                       SourceThing.psz, GetLastError() ));
                       
        return( LINEERR_OPERATIONFAILED );
    }

//    fResult = GetFileAttributesEx( SourceThing.psz,
//                                   GetFileExInfoStandard,
//                                   (PVOID) &FileInfo
//                                 );
  
    fResult = GetFileInformationByHandle( hFile, &FileInfo );
    
    if ( fResult )
    {
        //TODO LATER: Handle > 4 gig files

        //
        // Uh, we don't really handle gigabyte files...
        //
        if ( FileInfo.nFileSizeHigh )
        {
            cFileSize      = (DWORD)-1;
            cDataRemaining = (DWORD)-1;
        }
        else
        {
            cFileSize      = FileInfo.nFileSizeLow;
            cDataRemaining = FileInfo.nFileSizeLow;
        }
    }
    else
    {
        cFileSize      = 0;
        cDataRemaining = 0;
    }

    cDataDonePlaying = 0;

    return(0);
}


//****************************************************************************
ULONG DosFile::GetData( PBYTE pBuffer, ULONG uBufferSize )
{
    BOOL fResult;
    UINT uBytesRead = 0;

    fResult = ReadFile( hFile,
                        pBuffer,
                        uBufferSize,
                        (LPDWORD)&uBytesRead,
                        NULL
                      );

    if ( fResult )
    {
        if ( 0 == uBytesRead )
        {
            //
            // We're at the end of the file
            //
            cDataRemaining = 0;
        }
        else
        {
            cDataRemaining -= uBytesRead;
        }
    }

    return( uBytesRead );
}


//****************************************************************************
void DosFile::FreeSpecific( void )
{
    CloseHandle( hFile );
    return;
}




//****************************************************************************
//****************************************************************************
//****************************************************************************
ULONG WaveDevice::PlaySomeData( BOOL fPrimeOnly )
{
    ULONG uBufferedBytes = 0;
    ULONG uTotalQueuedSize = 0;
    PBYTE pBuffer = NULL;
    LONG lResult;
    CRITICAL_SECTION *pCriticalSection;

        
    WDBGOUT((3, TEXT("Entering PlaySomeData")));

    pCriticalSection = &CriticalSection;
    EnterCriticalSection( pCriticalSection );

    if ( NULL != CurrentWaveOperation )
    {
    
        //
        // Is it OK to play this thing?
        //
        if ( !((*CurrentWaveOperation).dwStatus & OPERATIONSTATUS_DONTPLAYTHIS) )
        {
            while ( NumFreeBuffers )
            {
                uBufferedBytes = (*CurrentWaveOperation).GetData( FreeQueue[Head], cBufferSize );
                              
                WDBGOUT((11, "GetData on 0x%08lx gave %ld bytes for buffer #%d",
                          CurrentWaveOperation,
                          uBufferedBytes,
                          Head));

                if ( 0 == uBufferedBytes )
                {
					WDBGOUT((10, TEXT("breakin 'cause 0 bytes...")));
                    break;
                }
                
				WDBGOUT((10, TEXT("past if...")));
                uTotalQueuedSize += uBufferedBytes;
                
                MiscInfo[Head].uBufferLength    = uBufferedBytes;
                MiscInfo[Head].poWaveOperation  = CurrentWaveOperation;
                MiscInfo[Head].pBuffer          = FreeQueue[Head];
                WaveHeader[Head].dwUser         = (DWORD) &MiscInfo[Head];
                WaveHeader[Head].dwBufferLength = uBufferedBytes;
   
                lResult = waveOutWrite( hWaveOut,
                                        &WaveHeader[Head],
                                        sizeof(WAVEHDR)
                                      );
                if ( lResult )
                {
                    //
                    // Something's wrong.  Quit this operation.
                    //
                    uTotalQueuedSize = 0;
                    uBufferedBytes = 0;
                    WDBGOUT((1, TEXT("waveOutWrite returned 0x%08lx"), lResult));
                    break;
                }

                Head = (Head + 1) % MAX_NUM_BUFFERS;

                NumFreeBuffers--;

                //
                // Are we just "priming" the pump?
                //
//                if ( fPrimeOnly )
//                {
//                    WDBGOUT((4, TEXT("Leaving PlaySomeData - primed (size=%08ld)"), uTotalQueuedSize ));
//                    LeaveCriticalSection( pCriticalSection );
//                    return uTotalQueuedSize;
//                }

            }
        }
#if DBG
        else
        {
			WDBGOUT((10, TEXT("I've been asked not to play this operation (0x%08lx)"), CurrentWaveOperation));
        }
        
#endif        
        
		WDBGOUT((10, TEXT("past while numfreebuffers...")));
        

        //
        // We got here because we're out of buffers, or the operation is done
        //
        if ( 0 != uBufferedBytes )
        {
            //
            // Must be here because we ran out of buffers...
            //
            LeaveCriticalSection( pCriticalSection );
            return( uTotalQueuedSize );
        }

        
        //
        // We get here when the current operation is all done
        // (or, at least, all of its remaining data is queued in the
        // wave driver)
        //
    }    
    
    //
    // If we got here, it's because we're out of things to do
    //

    LeaveCriticalSection( pCriticalSection );


    WDBGOUT((4, TEXT("Leaving PlaySomeData - no currop (size=%08ld)"), uTotalQueuedSize ));

    return uTotalQueuedSize;
//    return( 0 );
}


//****************************************************************************
//****************************************************************************
//****************************************************************************
void CALLBACK WaveOutCallback(
    HWAVE  hWave,    // handle of waveform device
    UINT  uMsg,    // sent message
    DWORD  dwInstance,    // instance data
    DWORD  dwParam1,    // application-defined parameter
    DWORD  dwParam2    // application-defined parameter
   )
{
    UINT n;

    switch ( uMsg )
    {
        case WOM_DONE:
        {
            class WaveDevice * poWaveDevice =
                        (class WaveDevice *)dwInstance;

            MISCINFO * pMiscInfo = (MISCINFO *)((LPWAVEHDR)dwParam1)->dwUser;

            
            WDBGOUT((11, TEXT("Got DoneWithBuff msg for 0x%08lx in 0x%08lx"),
                           *(LPDWORD)dwParam1,
                           dwParam1));


//            EnterCriticalSection( &gBufferCriticalSection );

            n = 0;

//TODO NOW: If this buffer won't fit, it'll get lost.  This can easily happen
//            when there are >1 wave devices playing.

            while (
                     ( n < MAX_NUM_BUFFERS )
                   &&
                     ( gDoneBuffersToBeProcessed[n] != NULL )
                  )
            {
               n++;
            }

            gDoneBuffersToBeProcessed[n] = pMiscInfo;

//            LeaveCriticalSection( &gBufferCriticalSection );

            SetEvent( ghFreeBufferEvent );
        }    
        break;

            
        case WOM_OPEN:
            WDBGOUT((11, TEXT("Got Waveout Open")));
            break;

            
        case WOM_CLOSE:
            WDBGOUT((11, TEXT("Got Waveout Close")));
            break;
    }
}    





//****************************************************************************
//****************************************************************************
//****************************************************************************
//LONG tapiMakeNoise(
//                      DWORD  Device Type: PHONE/LINE/WAVE, etc?
//                      HANDLE Device Handle,
//                      DWORD  NoiseType:   BUFFER/FILENAME/HFILE(readfile directly?)/MMIOHANDLE
//                      HANDLE hArray - array of type NoiseTypes that are to be played serially
//                      DWORD  Flags:
//                              fSYNC
//                              fSTOP_EXISTING_PLAYING_IF_ANY
//                    );


// SOME FLAGS FOR THIS FUNC
#define PLAY_SYNC 0x00000001
#define KILL_ALL_NOISE 0x80000000

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

LONG WINAPI tapiPlaySound(
                    DWORD  dwDeviceType,
                    HANDLE hDevice,
                    DWORD  dwSoundType,
                    HANDLE hArray,
                    DWORD  dwFlags
                  )
{
    HANDLE hSyncEvent = NULL;
    class WaveDevice * poWaveDevice;
    class WaveOperation * poWaveOperation;
    LONG fAreWeInited;
    LONG lResult = 0;
    ULONG uNormalizedWaveId = 0;
//    BOOLEAN fNeedToPrimeDevice = FALSE;

    WDBGOUT((3, "Entering tapiPlaySound"));
    WDBGOUT((5, "    dwDeviceType: %ld", dwDeviceType));
    WDBGOUT((5, "    hDevice:      0x%08lx", hDevice));
    WDBGOUT((5, "    dwSoundType:  %ld", dwSoundType));
    WDBGOUT((5, "    hArray:       0x%08lx", hArray));
    WDBGOUT((5, "    dwFlags:      0x%08lx", dwFlags));

    
    fAreWeInited = InterlockedExchange(
                                        &gfInited,
                                        TRUE
                                      );  
    
    if ( 0 == fAreWeInited )
    {
        InitializeCriticalSection( &gCriticalSection );
    }
    

    if ( 0 == ghFreeBufferEvent )
    {
        ghFreeBufferEvent = CreateEvent(
                                        NULL,
                                        FALSE,
                                        FALSE,
                                        NULL
                                      );
            

        if ( NULL == ghFreeBufferEvent )
        {
            WDBGOUT((1, "CreateEvent2 failed: GetLastError = 0x%08lx", GetLastError()));
            return  LINEERR_NOMEM;
        }
    }


    //
    // Normalize to a wave device (and validate dwDeviceType at the same time)
    //
    switch ( dwDeviceType )
    {
        case DEVICE_WAVEID:
        {
            uNormalizedWaveId = (ULONG) hDevice;
        }
        break;


        case DEVICE_WAVEHANDLE:
        {
        }
        break;


        case DEVICE_HLINE:
        case DEVICE_HCALL:
        {
        
           DWORD  VarString[ 8 ] = 
           {
             sizeof(VarString),
             0,
             0,
             STRINGFORMAT_BINARY,
             0,
             0,
             0
           };


           if ( 0 == (lResult = lineGetID(
              (HLINE)hDevice,
              0,
              (HCALL)hDevice,
              (DEVICE_HCALL == dwDeviceType) ?
                    LINECALLSELECT_CALL :
                    LINECALLSELECT_LINE,
              (LPVARSTRING)&VarString,
              TEXT("wave/out")
            ) ) )
           {
              uNormalizedWaveId = (DWORD) ((LPBYTE)VarString)[ ((LPVARSTRING)&VarString)->dwStringOffset ];
           }
           else 
           {
              WDBGOUT((1, "lineGetID failed - 0x%08lx", lResult));
              
              return  LINEERR_INVALPARAM;
           }

        }
        break;


        case DEVICE_HPHONE:
        {
        }
        break;


        default:
        WDBGOUT((1, "Invalid dwDeviceType (0x%08lx) passed in.", dwDeviceType));
        return LINEERR_BADDEVICEID;
    }


    EnterCriticalSection( &gCriticalSection );

    poWaveDevice = gpoWaveDeviceList;

    while ( poWaveDevice )
    {
        if ( (*poWaveDevice).GetWaveDeviceId() == uNormalizedWaveId )
        {
            //
            // We found it!
            //
            break;
        }

        //
        // ...and I still haven't found what I'm lookin' for.
        //
        poWaveDevice = (*poWaveDevice).GetpNext();
    }


    //
    // So, was it not in our list already?
    //
    if ( NULL == poWaveDevice )
    {
       //
       // No, add a new device object to the list
       //

       poWaveDevice = new WaveDevice;

       lResult = (*poWaveDevice).InitWaveDevice( uNormalizedWaveId );

       if ( lResult )
       {
            WDBGOUT((1, TEXT("InitWaveDevice returned 0x%08lx"), lResult));
//TODO: Diff error codes for diff causes...
            LeaveCriticalSection( &gCriticalSection );
            return LINEERR_RESOURCEUNAVAIL;
       }

       (*poWaveDevice).SetpNext( gpoWaveDeviceList );
       
       gpoWaveDeviceList = poWaveDevice;
    }
    


    //
    // If the caller wants to cancel all currently queued and playing
    // sound on this device, do it now
    //
    if ( KILL_ALL_NOISE & dwFlags )
    {
        (*poWaveDevice).TerminateAllOperations();
        WDBGOUT((4, "Caller was asking to terminate the wave device.  Done."));
        
//        LeaveCriticalSection( &gCriticalSection );
//            
//	  	return( 0 );
    }



// t-mperh 6/30 was all commented before - not sure why
//
    //
    // If the user passed in a NULL for hArray, we'll (for now?) assume
    // he wants a no-op (or 'twas a TERMINATE request).
    //
    if ( NULL == hArray )
    {
        WDBGOUT((3, "Leaving tapiPlaySound - NULL thing"));
        LeaveCriticalSection( &gCriticalSection );
        return  0;
    }

//**************************************************************
//NOTE: The above code fixed a problem of passing in NULL names.
// This caused an OPEN to fail and this stuff would get stuck.
// There must still be a bug that will show up when someone calls with
// a bad filename or a file that plays 0 bytes.
//**************************************************************



    switch ( dwSoundType )
    {
        case SOURCE_WAVEFILE:
        {
            poWaveOperation = new WaveFile;
        }
        break;
        
        
        case SOURCE_MSDOSFILE:
        {
            poWaveOperation = new DosFile;
        }
        break;
    
        
        case SOURCE_MEM:
        {
            poWaveOperation = new BufferWave;
        }
        break;
    
        
        default:
        {
            WDBGOUT((1, "Invalid dwSourceType - 0x%08lx", dwSoundType));
            LeaveCriticalSection( &gCriticalSection );
            return LINEERR_INVALPARAM;
        }
    }
   
    
    if ( NULL == ghWaveThread )
    {
        DWORD dwThreadID;

        ghWaveThread = CreateThread(
                                    NULL,
                                    0,
                                    WaveThread,
                                    NULL,
                                    0,
                                    &dwThreadID
                                  );
        if ( 0 != lResult )
        {
            WDBGOUT((1, "Create thread failed! GetLastError()=0x%lx", GetLastError() ));
            LeaveCriticalSection( &gCriticalSection );
            return  LINEERR_NOMEM;
        }

    }


    //
    // Init global operation
    //
    (*poWaveOperation).InitOperation(
                                      poWaveDevice,
                                      dwSoundType,
                                      (LONG)hArray
                                    );  
    
    (*poWaveDevice).QueueOperation( poWaveOperation );
    
    
    if ( dwFlags & PLAY_SYNC )
    {
        hSyncEvent = CreateEvent(
                                  NULL,
                                  TRUE,
                                  FALSE,
                                  NULL
                                );
        
        if ( NULL == hSyncEvent )
        {
            WDBGOUT((1, TEXT("CreateEvent failed: GetLastError = 0x%08lx"), GetLastError()));
            
            delete poWaveOperation;
            LeaveCriticalSection( &gCriticalSection );
            return( LINEERR_NOMEM );
        }
        
        (*poWaveOperation).SetSyncEvent( hSyncEvent );
    }
    
    
    //
    // If all of the buffers are idle, we'll have to prime...
    //
    if ( MAX_NUM_BUFFERS == (*poWaveDevice).GetNumFreeBuffers() )
    {
        WDBGOUT((4, TEXT("Priming")));
        
        if ( 0 == (*poWaveDevice).PlaySomeData( TRUE ) )
        {
            WaveOperation * poWaveOperation;
            
            WDBGOUT((4, TEXT("No data played for this wave!")));
            
            
            poWaveOperation = (*poWaveDevice).NextOperation();
            
            while (poWaveOperation)
            {
               if ( (*poWaveDevice).PlaySomeData(TRUE) )
               {
                  break;
               }
               
               poWaveOperation = (*poWaveDevice).NextOperation();
            }
            
            //
            // If fNeedToPrimeDevice was true, this must be the first (and only,
            // since we're still in the critical section) operation
            // And, since there was no data (or we failed for any reason),
            // we should shut down the wave device here.
            
            // Now leave the critical section so we can wait for the WAVETHREAD
            // to finish and so that thread can do work to clean up
            LeaveCriticalSection( &gCriticalSection );
            (*poWaveDevice).KillWaveDevice(TRUE);
            EnterCriticalSection( &gCriticalSection );
            
            //
            // Fake out the event
            //
            if ( hSyncEvent )
            {
                WDBGOUT((5, TEXT("Faking hSyncEvent...")));
                SetEvent( hSyncEvent );
            }
        }
    }
#if DBG
    else
    {
        WDBGOUT((4, TEXT("Not priming because %ln buffers are out"),
                    (*poWaveDevice).GetNumFreeBuffers() ));
    }    
#endif    

    
    LeaveCriticalSection( &gCriticalSection );
    
    if ( hSyncEvent )
    {
        WDBGOUT((5, TEXT("Waiting for the wave to finish (event=0x%08lx)"),
                      hSyncEvent));
                      
        WaitForSingleObject( hSyncEvent, INFINITE );
        
        //
        // When it gets back, the thing is done playing
        //
        CloseHandle( hSyncEvent );
    }
    
    
    WDBGOUT((4, TEXT("Leaving tapiPlaySound - retcode = 0x0")));
    return( 0 );
}    

    


#ifdef __cplusplus
}            /* End Assume C declarations for C++ */
#endif  /* __cplusplus */


    
//****************************************************************************
//****************************************************************************
//****************************************************************************
unsigned long WINAPI WaveThread( LPVOID junk )
{
    UINT n;

    WDBGOUT((3, "WaveThread starting..."));

    do
    {
        WDBGOUT((3, "WaveThread waiting..."));
        WaitForSingleObject( ghFreeBufferEvent, INFINITE );


        //
        // First, deal with any finished buffers
        //
        n = 0;
//        while ( gDoneBuffersToBeProcessed[n] != NULL )

        EnterCriticalSection( &gCriticalSection );
                
        while ( n < MAX_NUM_BUFFERS )
        {
            if ( gDoneBuffersToBeProcessed[n] != NULL )
            {
                MISCINFO *pMiscInfo = gDoneBuffersToBeProcessed[n];

                pMiscInfo->poWaveOperation->ProcessDoneBuffer( pMiscInfo );
                gDoneBuffersToBeProcessed[n] = NULL;
            }

            n++;
        }

        LeaveCriticalSection( &gCriticalSection );

//        poWaveDevice = gpoWaveDeviceList;
//
//        while ( poWaveDevice )
//        {
//            UINT nBytesQueued = 0;
//
//            while ( nBytesQueued == 0 )
//            {
//                //
//                // Now play some new data
//                //
//                nBytesQueued = (*poWaveDevice).PlaySomeData( FALSE );
//
//                //
//                // And is the entire wave done?
//                //
//                if ( 0 == nBytesQueued )
//                {
//                    WaveOperation * poNewCurrent;
//                
//                    poNewCurrent = (*poWaveDevice).NextOperation();
//                        
//                    if ( NULL == poNewCurrent )
//                    {
//    if ( NULL == gpoWaveDeviceList )
//    {
//        gfShutdown = TRUE;
//        gfInited   = 0;
//    }
//                        break;
//                    }
//                }
//            }
//
//
//            poWaveDevice = (*poWaveDevice).GetpNext();
//        }

    } while ( !gfShutdown );

    WDBGOUT((5, TEXT("Oh, I guess we're done now...")));
    
    CloseHandle( ghFreeBufferEvent );
    ghFreeBufferEvent = 0;

    gfShutdown = FALSE;
    
    
    WDBGOUT((3, TEXT("WaveThread ending...")));

    ghWaveThread = NULL;
       
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\clntprivate.h ===
/****************************************************************************
 
  Copyright (c) 1995-1999 Microsoft Corporation
                                                              
  Module Name:  private.h
         
****************************************************************************/

#pragma once

#include "tapsrv.h"

#ifdef __cplusplus
extern "C"{
#endif

//***************************************************************************
//***************************************************************************
//***************************************************************************
void AllocNewID( HKEY MainKey, LPDWORD lpdw );
void PASCAL WideStringToNotSoWideString( LPBYTE lpBase, LPDWORD lpdwThing );
PWSTR PASCAL MultiToWide( LPCSTR  lpStr );
PWSTR PASCAL NotSoWideStringToWideString( LPCSTR lpStr, DWORD dwLength );



//***************************************************************************
//***************************************************************************
//***************************************************************************
typedef enum
{
    Dword,
    lpDword,
    hXxxApp,
    hXxxApp_NULLOK,
//    lpsz,
    lpszW,
    lpGet_SizeToFollow,
    lpSet_SizeToFollow,
    lpSet_Struct,
    lpGet_Struct,
    Size,
    Hwnd

} ARG_TYPE;


typedef struct _FUNC_ARGS
{
    DWORD               Flags;

    ULONG_PTR           Args[MAX_TAPI_FUNC_ARGS];

    BYTE                ArgTypes[MAX_TAPI_FUNC_ARGS];

} FUNC_ARGS, *PFUNC_ARGS;


typedef struct _UI_REQUEST_THREAD_PARAMS
{
    BOOL                bRequestCompleted;

    PFUNC_ARGS          pFuncArgs;

    LONG                lResult;

} UI_REQUEST_THREAD_PARAMS, *PUI_REQUEST_THREAD_PARAMS;


typedef struct _INIT_DATA
{
    DWORD               dwKey;

    DWORD               dwInitOptions;

    union
    {
        HWND            hwnd;

        HANDLE          hEvent;

        HANDLE          hCompletionPort;
    };

    union
    {
        LINECALLBACK    lpfnCallback;

        DWORD           dwCompletionKey;
    };

    HLINEAPP            hXxxApp;

    BOOL                bPendingAsyncEventMsg;

    DWORD               dwNumTotalEntries;

    DWORD               dwNumUsedEntries;

    PASYNC_EVENT_PARAMS pEventBuffer;

    PASYNC_EVENT_PARAMS pValidEntry;

    PASYNC_EVENT_PARAMS pFreeEntry;

    DWORD               dwNumLines;

    BOOL                bLine;

    DWORD               dwThreadID;

    DWORD               hInitData;

} INIT_DATA, *PINIT_DATA;


//
//  Private Error codes
//

#define TAPIERR_NOSERVICECONTROL    0xF100
#define TAPIERR_INVALRPCCONTEXT     0xF101

#if DBG

#define DBGOUT(arg) DbgPrt arg

VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN LPTSTR DbgMessage,
    IN ...
    );

extern DWORD   gdwDebugLevel;

#define DOFUNC(arg1,arg2) DoFunc(arg1,arg2)

LONG
WINAPI
DoFunc(
    PFUNC_ARGS  pFuncArgs,
    char       *pszFuncName
    );

#else

#define DBGOUT(arg)

#define DOFUNC(arg1,arg2) DoFunc(arg1)

LONG
WINAPI
DoFunc(
    PFUNC_ARGS  pFuncArgs
    );

#endif

BOOL
WINAPI
SetTlsPCtxHandle(
    PCONTEXT_HANDLE_TYPE phCtxHandle
    );

PCONTEXT_HANDLE_TYPE
WINAPI
GetTlsPCtxHandle(
    void
    );

#ifdef __cplusplus
}
#endif


#if DBG

#define DWORD_CAST(v,f,l) (((v)>MAXDWORD)?(DbgPrt(0,L"DWORD_CAST: information will be lost during cast from %p in file %s, line %d",(v),(f),(l)), DebugBreak(),((DWORD)(v))):((DWORD)(v)))

#else
#define DWORD_CAST(v,f,l)   (DWORD)(v)
#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\g723uids.h ===
/*++

Copyright (c) 1997, Microsoft Corporation

Module Name:

    g723uids.h

Abstract:

    Include File for g723.

--*/

//
// GUIDs
//

// G.723.1 Codec Filter Object
// {24532D00-FCD8-11cf-A7D3-00A0C9056683}
DEFINE_GUID(CLSID_IntelG723Codec,
0x24532d00, 0xfcd8, 0x11cf, 0xa7, 0xd3, 0x0, 0xa0, 0xc9, 0x5, 0x66, 0x83);

// G.723.1 Codec Filter Property Page Object
// {24532D01-FCD8-11cf-A7D3-00A0C9056683}
DEFINE_GUID(CLSID_IntelG723CodecPropertyPage,
0x24532d01, 0xfcd8, 0x11cf, 0xa7, 0xd3, 0x0, 0xa0, 0xc9, 0x5, 0x66, 0x83);

// G.723.1 Compressed Speech Format
// {E4D13050-0E80-11d1-B094-00A0C95BED34}
DEFINE_GUID(MEDIASUBTYPE_G723Audio,
0xe4d13050, 0xe80, 0x11d1, 0xb0, 0x94, 0x0, 0xa0, 0xc9, 0x5b, 0xed, 0x34);

// {9D3C85D1-F877-11d0-B083-00A0C95BED34}
DEFINE_GUID(CLSID_IntelG723CodecAbout,
0x9d3c85d1, 0xf877, 0x11d0, 0xb0, 0x83, 0x0, 0xa0, 0xc9, 0x5b, 0xed, 0x34);

// G.723.1 codec license IF
// {899308D0-F7B1-11d0-B082-00A0C95BED34}
DEFINE_GUID(IID_IG723CodecLicense,
0x899308d0, 0xf7b1, 0x11d0, 0xb0, 0x82, 0x0, 0xa0, 0xc9, 0x5b, 0xed, 0x34);

#ifndef INC_G723UIDS
#define INC_G723UIDS

DECLARE_INTERFACE_(IG723CodecLicense, IUnknown)
{
    STDMETHOD(put_LicenseKey)
        ( THIS_
          DWORD magicword0,  // [in] magic word 0
          THIS_
          DWORD magicword1   // [in] magic word 1
        ) PURE;

    STDMETHOD(put_AccessKey)
        ( THIS_
          int accesskey      // [in] access key
        ) PURE;

    STDMETHOD(get_AccessKeyState)
        ( THIS_
          BOOL *flag         // [out] boolean flag
        ) PURE;
};

#define G723KEY_PSword0	0xcd4d8488 // full licence key 0
#define G723KEY_PSword1	0xd4c9b9ae // full licence key 1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\client.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    client.h

Abstract:

    Header file for tapi client module

Author:

    Dan Knudson (DanKn)    01-Apr-1994

Revision History:

--*/


#pragma once

#define TAPI_VERSION1_0           0x00010003
#define TAPI_VERSION1_4           0x00010004
#define TAPI_VERSION2_0           0x00020000
#define TAPI_VERSION2_1           0x00020001
#define TAPI_VERSION2_2           0x00020002
#define TAPI_VERSION3_0           0x00030000
#define TAPI_VERSION3_1           0x00030001
#define TAPI_VERSION_CURRENT      TAPI_VERSION3_1

#ifdef _WIN64
#define TALIGN_MASK                 0xfffffff8
#define TALIGN_COUNT                7
#else
#define TALIGN_MASK                 0xfffffffc
#define TALIGN_COUNT                3
#endif
#define ALIGN(a)                    (((a)+TALIGN_COUNT)&TALIGN_MASK)

#define NUM_ARGS_MASK             0x0000000f

#define LINE_FUNC                 0x00000010
#define PHONE_FUNC                0x00000020
#define TAPI_FUNC                 0x00000000

#define ASYNC                     0x00000040
#define SYNC                      0x00000000

#define INCL_CONTEXT              0x00000080

#define INITDATA_KEY              ((DWORD) 'INIT')
#define TPROXYREQUESTHEADER_KEY   ((DWORD) 'REQH')

#define WM_ASYNCEVENT             (WM_USER+111)

#define DEF_NUM_EVENT_BUFFER_ENTRIES    16

#define WAVE_STRING_ID_BUFFER_SIZE      256

#define TAPI_SUCCESS                    0
#define TAPI_NO_DATA                    ((DWORD)-1)
#define MAX_TAPI_FUNC_ARGS              13

#define REMOVEPROVIDER                  0
#define CONFIGPROVIDER                  1
#define ADDPROVIDER                     2
#define TAPI16BITSUCCESS                -2

#define INITIAL_CLIENT_THREAD_BUF_SIZE  512
#define WM_TAPI16_CALLBACKMSG           (WM_USER+101)

#define IsOnlyOneBitSetInDWORD(dw) (dw && !(((DWORD)dw) & (((DWORD)dw) - 1)))

#define AllCallSelect                \
    (LINECALLSELECT_CALL           | \
    LINECALLSELECT_ADDRESS         | \
    LINECALLSELECT_LINE)

#define AllDigitModes                \
    (LINEDIGITMODE_PULSE           | \
    LINEDIGITMODE_DTMF             | \
    LINEDIGITMODE_DTMFEND)

#define AllForwardModes              \
    (LINEFORWARDMODE_UNCOND        | \
    LINEFORWARDMODE_UNCONDINTERNAL | \
    LINEFORWARDMODE_UNCONDEXTERNAL | \
    LINEFORWARDMODE_UNCONDSPECIFIC | \
    LINEFORWARDMODE_BUSY           | \
    LINEFORWARDMODE_BUSYINTERNAL   | \
    LINEFORWARDMODE_BUSYEXTERNAL   | \
    LINEFORWARDMODE_BUSYSPECIFIC   | \
    LINEFORWARDMODE_NOANSW         | \
    LINEFORWARDMODE_NOANSWINTERNAL | \
    LINEFORWARDMODE_NOANSWEXTERNAL | \
    LINEFORWARDMODE_NOANSWSPECIFIC | \
    LINEFORWARDMODE_BUSYNA         | \
    LINEFORWARDMODE_BUSYNAINTERNAL | \
    LINEFORWARDMODE_BUSYNAEXTERNAL | \
    LINEFORWARDMODE_BUSYNASPECIFIC)

#define AllTerminalModes             \
    (LINETERMMODE_BUTTONS          | \
    LINETERMMODE_LAMPS             | \
    LINETERMMODE_DISPLAY           | \
    LINETERMMODE_RINGER            | \
    LINETERMMODE_HOOKSWITCH        | \
    LINETERMMODE_MEDIATOLINE       | \
    LINETERMMODE_MEDIAFROMLINE     | \
    LINETERMMODE_MEDIABIDIRECT)

#define AllToneModes                 \
    (LINETONEMODE_CUSTOM           | \
    LINETONEMODE_RINGBACK          | \
    LINETONEMODE_BUSY              | \
    LINETONEMODE_BEEP              | \
    LINETONEMODE_BILLING)

#define AllHookSwitchDevs            \
    (PHONEHOOKSWITCHDEV_HANDSET    | \
    PHONEHOOKSWITCHDEV_SPEAKER     | \
    PHONEHOOKSWITCHDEV_HEADSET)

#define AllHookSwitchModes           \
    (PHONEHOOKSWITCHMODE_ONHOOK    | \
    PHONEHOOKSWITCHMODE_MIC        | \
    PHONEHOOKSWITCHMODE_SPEAKER    | \
    PHONEHOOKSWITCHMODE_MICSPEAKER)

#define AllLampModes                 \
    (PHONELAMPMODE_BROKENFLUTTER   | \
    PHONELAMPMODE_FLASH            | \
    PHONELAMPMODE_FLUTTER          | \
    PHONELAMPMODE_OFF              | \
    PHONELAMPMODE_STEADY           | \
    PHONELAMPMODE_WINK             | \
    PHONELAMPMODE_DUMMY)

#define AllMediaModes                \
    (LINEMEDIAMODE_UNKNOWN         | \
    LINEMEDIAMODE_INTERACTIVEVOICE | \
    LINEMEDIAMODE_AUTOMATEDVOICE   | \
    LINEMEDIAMODE_DIGITALDATA      | \
    LINEMEDIAMODE_G3FAX            | \
    LINEMEDIAMODE_G4FAX            | \
    LINEMEDIAMODE_DATAMODEM        | \
    LINEMEDIAMODE_TELETEX          | \
    LINEMEDIAMODE_VIDEOTEX         | \
    LINEMEDIAMODE_TELEX            | \
    LINEMEDIAMODE_MIXED            | \
    LINEMEDIAMODE_TDD              | \
    LINEMEDIAMODE_ADSI             | \
    LINEMEDIAMODE_VOICEVIEW        | \
    LINEMEDIAMODE_VIDEO)


typedef enum
{
    xGetAsyncEvents,
    xGetUIDllName,
    xUIDLLCallback,
    xFreeDialogInstance,

    lAccept,
    lAddToConference,
    lAgentSpecific,
    lAnswer,
    lBlindTransfer,
    lClose,
    lCompleteCall,
    lCompleteTransfer,
//    lConditionalMediaDetection,  //remotesp
    lDeallocateCall,
    lDevSpecific,
    lDevSpecificFeature,
    lDial,
    lDrop,
    lForward,
    lGatherDigits,
    lGenerateDigits,
    lGenerateTone,
    lGetAddressCaps,
    lGetAddressID,
    lGetAddressStatus,
    lGetAgentActivityList,
    lGetAgentCaps,
    lGetAgentGroupList,
    lGetAgentStatus,
    lGetAppPriority,
    lGetCallAddressID,          // remotesp only
    lGetCallInfo,
    lGetCallStatus,
    lGetConfRelatedCalls,
    lGetCountry,
    lGetDevCaps,
    lGetDevConfig,
    lGetIcon,
    lGetID,
    lGetLineDevStatus,
    lGetNewCalls,
    lGetNumAddressIDs,          // remotesp only
    lGetNumRings,
    lGetProviderList,
    lGetRequest,
    lGetStatusMessages,
//In TAPI32.DLL now:    lGetTranslateCaps,
    lHandoff,
    lHold,
    lInitialize,
    lMakeCall,
    lMonitorDigits,
    lMonitorMedia,
    lMonitorTones,
    lNegotiateAPIVersion,
    lNegotiateExtVersion,
    lOpen,
    lPark,
    lPickup,
    lPrepareAddToConference,
    lProxyMessage,
    lProxyResponse,
    lRedirect,
    lRegisterRequestRecipient,
    lReleaseUserUserInfo,
    lRemoveFromConference,
    lSecureCall,
//    lSelectExtVersion,
    lSendUserUserInfo,
    lSetAgentActivity,
    lSetAgentGroup,
    lSetAgentState,
    lSetAppPriority,
    lSetAppSpecific,
    lSetCallData,
    lSetCallParams,
    lSetCallPrivilege,
    lSetCallQualityOfService,
    lSetCallTreatment,
//In TAPI32.DLL now:    lSetCurrentLocation,
    lSetDefaultMediaDetection,  // remotesp only
    lSetDevConfig,
    lSetLineDevStatus,
    lSetMediaControl,
    lSetMediaMode,
    lSetNumRings,
    lSetStatusMessages,
    lSetTerminal,
//In TAPI32.DLL now:    lSetTollList,
    lSetupConference,
    lSetupTransfer,
    lShutdown,
    lSwapHold,
//In TAPI32.DLL now:    lTranslateAddress,
    lUncompleteCall,
    lUnhold,
    lUnpark,

    pClose,
    pDevSpecific,
    pGetButtonInfo,
    pGetData,
    pGetDevCaps,
    pGetDisplay,
    pGetGain,
    pGetHookSwitch,
    pGetID,
    pGetIcon,
    pGetLamp,
    pGetRing,
    pGetStatus,
    pGetStatusMessages,
    pGetVolume,
    pInitialize,
    pOpen,
    pNegotiateAPIVersion,
    pNegotiateExtVersion,
//    pSelectExtVersion,      // remotesp
    pSetButtonInfo,
    pSetData,
    pSetDisplay,
    pSetGain,
    pSetHookSwitch,
    pSetLamp,
    pSetRing,
    pSetStatusMessages,
    pSetVolume,
    pShutdown,

//In TAPI32.DLL now:    tGetLocationInfo,
    tRequestDrop,
    tRequestMakeCall,
    tRequestMediaCall,
//    tMarkLineEvent,
    tReadLocations,
    tWriteLocations,
    tAllocNewID,
    tPerformance,
    lConditionalMediaDetection,  //remotesp
    lSelectExtVersion,
    pSelectExtVersion,      // remotesp
//    lOpenInt,
//    lShutdownInt,

    //
    // Ordinals for tapi 2.1 ended here.  the lOpenInt & lShutdownInt
    // were Win95 local-machine-only hacks which have since been removed
    //

    xNegotiateAPIVersionForAllDevices, // remotesp

    mGetAvailableProviders,
    mGetLineInfo,
    mGetPhoneInfo,
    mGetServerConfig,
    mSetLineInfo,
    mSetPhoneInfo,
    mSetServerConfig,

    //
    // Ordinals for 2.1 update (nt4 sp4) ended here.
    //

    lMSPIdentify,
    lReceiveMSPData,

    lGetCallHubTracking,
    lGetCallIDs,
    lGetHubRelatedCalls,
    lSetCallHubTracking,
    xPrivateFactoryIdentify,
    lDevSpecificEx,
    lCreateAgent,
    lCreateAgentSession,
    lGetAgentInfo,
    lGetAgentSessionInfo,
    lGetAgentSessionList,
    lGetQueueInfo,
    lGetGroupList,
    lGetQueueList,
    lSetAgentMeasurementPeriod,
    lSetAgentSessionState,
    lSetQueueMeasurementPeriod,
    lSetAgentStateEx,
    lGetProxyStatus,
    lCreateMSPInstance,
    lCloseMSPInstance,

    //
    //  Funcs for TAPI 3.1
    //
    tSetEventMasksOrSubMasks,
    tGetEventMasksOrSubMasks,
    tSetPermissibleMasks,
    tGetPermissibleMasks,

    mGetDeviceFlags,

    lGetCountryGroup,

    lGetIDEx,

    pGetIDEx,

    //
    // The following is always the last one in the list
    //

    xLastFunc

} FUNC_TYPE;



typedef struct _CLIENT_THREAD_INFO
{
    LIST_ENTRY  TlsList;

    LPBYTE      pBuf;

    DWORD       dwBufSize;

} CLIENT_THREAD_INFO, *PCLIENT_THREAD_INFO;


typedef struct _TAPI32_MSG
{
    //
    // The following union is used:
    //
    //   1. by requests from client to server to specify a function type
    //   2. by acks from server to client to specify a return value
    //   3. by async msgs from server to client to specify msg type
    //

    union
    {
        DWORD       Req_Func;

        DWORD       Ack_ReturnValue;

        DWORD       Msg_Type;

    } u;


    //
    // The following...
    //

	DWORD       unsused;


    //
    // Function paramters
    //

    DWORD       Params[MAX_TAPI_FUNC_ARGS];


} TAPI32_MSG, *PTAPI32_MSG;


typedef struct _ASYNCEVENTMSG
{
    DWORD                   TotalSize;
    DWORD                   InitContext;
    DWORD                   fnPostProcessProcHandle;
    DWORD                   hDevice;

    DWORD                   Msg;
    DWORD                   OpenContext;

    union {
    
        DWORD           Param1;
    };

    union {
    
        DWORD           Param2;
    };

    union {
    
        DWORD           Param3;
    };

    union {
    
        DWORD           Param4;
    };

} ASYNCEVENTMSG, *PASYNCEVENTMSG;


typedef void (PASCAL *POSTPROCESSPROC)(PASYNCEVENTMSG pMsg);


typedef struct _ASYNC_EVENT_PARAMS
{
    DWORD                   hDevice;
    DWORD                   dwMsg;
    ULONG_PTR               dwCallbackInstance;
    ULONG_PTR               dwParam1;

    ULONG_PTR               dwParam2;
    ULONG_PTR               dwParam3;

} ASYNC_EVENT_PARAMS, *PASYNC_EVENT_PARAMS;


typedef LONG (PASCAL *TUISPIPROC)();


typedef struct _UITHREADDATA
{
    HTAPIDIALOGINSTANCE     htDlgInst;
    HINSTANCE               hUIDll;
    HANDLE                  hThread;
    HANDLE                  hEvent;

    LPVOID                  pParams;
    DWORD                   dwSize;
    TUISPIPROC              pfnTUISPI_providerGenericDialog;
    TUISPIPROC              pfnTUISPI_providerGenericDialogData;

    struct _UITHREADDATA   *pPrev;
    struct _UITHREADDATA   *pNext;

} UITHREADDATA, *PUITHREADDATA;


typedef struct _PROXYREQUESTHEADER
{
    DWORD                   dwKey;

    DWORD                   dwInstance;

} PROXYREQUESTHEADER, *PPROXYREQUESTHEADER;


#if DBG
extern TCHAR    gszDebug[];
#endif
extern const TCHAR    gszCurrentLocation[];
extern const TCHAR    gszNullString[];

#ifdef __cplusplus
extern "C"{
#endif

#if DBG
#define ClientAlloc( __size__ ) ClientAllocReal( __size__, __LINE__, __FILE__ )

LPVOID
WINAPI
ClientAllocReal(
    DWORD dwSize,
    DWORD dwLine,
    PSTR  pszFile
    );

#else
#define ClientAlloc( __size__ ) ClientAllocReal( __size__ )

LPVOID
WINAPI
ClientAllocReal(
    DWORD dwSize
    );

#endif
    
SIZE_T
WINAPI
ClientSize(
    LPVOID  lp
    );

void
WINAPI
ClientFree(
    LPVOID  lp
    );



LONG
WINAPI
MarkLineEvent(
    DWORD           dwApiVersion,
    DWORD           ptLine,
    DWORD           ptLineClientToExclude,
    DWORD           dwMsg,
    DWORD           dwParam1,
    DWORD           dwParam2,
    DWORD           dwParam3
    );

void ListNodePoolsInitialize(void);
void ListNodePoolsUninitialize(void);

extern  BOOL gbDisableGetTranslateCapsHack;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\cplresource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cplresource.rc
//
#define IDS_NAME                        1
#define IDS_DESCRIPTION                 2
#define IDS_LOCATION                    3
#define IDS_CLICKNEW                    4
#define IDS_NEWLOCATION                 5
#define IDS_EDITLOCATION                6
#define IDS_NEWCALLINGCARD              7
#define IDS_EDITCALLINGCARD             8
#define IDS_AREACODE                    9
#define IDS_PREFIXES                    10
#define IDS_RULE                        11
#define IDS_PHONEPADCHAR                12
#define IDS_PHONENUMBERCHAR             13
#define IDS_DIGITSONLY                  14
#define IDS_ALLPHONECHARS               15
#define IDS_DIALX                       16
#define IDS_DIALXPLUSAREACODE           17
#define IDS_DIALAREACODE                18
#define IDS_DIALNUMBERONLY              19
#define IDS_ALLPREFIXES                 20
#define IDS_SELECTEDPREFIXES            21
#define IDS_EDITRULE                    22
#define IDS_SELECTARULE                 23
#define IDS_DIAL_XpAC_FORALL            24
#define IDS_DIAL_X_FORALL               25
#define IDS_DIAL_AC_FORALL              26
#define IDS_DIAL_NUMONLY_FORALL         27
#define IDS_DIAL_XpAC_FORSELECTED       28
#define IDS_DIAL_X_FORSELECTED          29
#define IDS_DIAL_AC_FORSELECTED         30
#define IDS_DIAL_NUMONLY_FORSELECTED    31
#define IDS_DIAL_ONEpAC_ALLOTHER        32
#define IDS_ADDPREFIX                   33
#define IDS_TYPEPREFIX                  34
#define IDS_SPECIFYDIGITS               35
#define IDS_TYPEDIGITS                  36
#define IDS_DIGITLIST                   37
#define IDS_WAITFORXSECONDS             38
#define IDS_DIALACCESSNUMBER            39
#define IDS_DIALACOUNTNUMBER            40
#define IDS_DIALPINNUMBER               41
#define IDS_WAITFORDIALTONE             42
#define IDS_WAITFORQUIET                43
#define IDS_DIAL_CCpACpNUM              44
#define IDS_DIAL_CCpNUM                 45
#define IDS_DIAL_ACpNUM                 46
#define IDS_DIAL_CC                     47
#define IDS_DIAL_AC                     48
#define IDS_DIAL_NUM                    49
#define IDS_DIALING_LD_CALLS            50
#define IDS_DIALING_INT_CALLS           51
#define IDS_DIALING_LOC_CALLS           52
#define IDS_NOCCRULES                   53
#define IDS_NEEDALONGDISTANCECARRIERCODE 54
#define IDS_NEEDALOCATIONNAME           55
#define IDS_NEEDANAREACODE              56
#define IDS_NEEDADISABLESTRING          57
#define IDS_NEEDACOUNTRY                58
#define IDS_ERRORCAPTION                59
#define IDS_NEEDUNIQUENAME              60
#define IDS_INVALIDCARD                 61
#define IDS_NOCARDSELECTED              62
#define IDS_MUSTENTERCARDNAME           63
#define IDS_MUSTENTERCARDNUMBER         64
#define IDS_MUSTENTERPINNUMBER          65
#define IDS_NORULESFORTHISCARD          66
#define IDS_NOLONGDISTANCEACCESSNUMBER  67
#define IDS_NOINTERNATIONALACCESSNUMBER 68
#define IDS_NOLOCALACCESSNUMBER         69
#define IDS_NONE                        70
#define IDS_CONFIRM_DRIVER_REMOVE       71
#define IDS_NOSERVICEPROVIDER           72
#define IDS_NEEDPREFIXLIST              73
#define IDS_DIGITS                      74
#define IDS_ACPREFIXES                  75
#define IDS_MULTIDIGITLIST              76
#define IDS_CONFIRMDELETE               77
#define IDS_DELETELOCTEXT               78
#define IDS_DELETECARDTEXT              79
#define IDS_DELETERULETEXT              80
#define IDS_NEEDDIALNUMBER              81
#define IDS_NEEDUNIQUECARDNAME          82
#define IDS_NOLOCWARNING                83
#define IDS_NOLOCCAPTION                84
#define IDS_MYLOCATION                  85
#define IDS_NO_PROVIDERS                86
#define IDS_PHONENUMBERCHAREXT          87
#define IDS_NEEDANINTERNATIONALCARRIERCODE 88
#define IDS_NEEDACARRIERCODE            89
#define IDS_TAPI_SEC_PROMPT             90
#define IDS_REND_SEC_PROMPT             91
#define IDS_MADCAP_SEC_PROMPT           92
#define IDS_PLUGTERM_SEC_PROMPT         93
#define IDD_MAIN_DIALINGRULES           101
#define IDD_LOC_GENERAL                 102
#define IDD_LOC_AREACODERULES           103
#define IDD_LOC_CALLINGCARD             104
#define IDD_CARD_GENERAL                105
#define IDD_CARD_LONGDISTANCE           106
#define IDD_CARD_INTERNATIONAL          107
#define IDD_CARD_LOCALCALLS             108
#define IDD_NEWAREACODERULE             109
#define IDD_EDITDIALOG                  110
#define IDD_WAITFORDIALOG               111
#define IDD_DESTNUMDIALOG               112
#define IDD_MAIN_ADVANCED               113
#define IDD_ADD_DRIVER                  114
#define IDD_SIMPLELOCATION              115
#define IDI_TELEPHONE                   201
#define IDI_HOUSE                       202
#define IDI_CARD                        203
#define IDB_BUTTONS                     301
#define IDB_SIMPLELOCATION              302
#define IDD_WIZ_DIALINFO                400
#define IDD_TAPI_SECURITY_DIALOG        500
#define IDC_SECURITY_WARNING_ICON       501
#define IDC_SECURITY_WARNING_TEXT       502
#define IDC_DONOT_PROMPT_IN_THE_FUTURE  503
#define IDI_SECURITY                    504
#define ID_YES                          505
#define ID_NO                           506
#define IDS_TYPEPREFIX2                 700
#define IDC_CARDUSAGE1                  1000
#define IDC_CARDUSAGE2                  1001
#define IDC_CARDUSAGE3                  1002
#define IDC_TEXT                        1003
#define IDC_SETDEFAULT                  1004
#define IDC_ADD                         1005
#define IDC_COUNTRY                     1006
#define IDC_DIALNUMBER                  1007
#define IDC_LOCALNUMBER                 1008
#define IDC_WAITFORDIALTONE             1009
#define IDC_LOCALACCESSNUM              1010
#define IDC_LONGDISTANCEACCESSNUM       1011
#define IDC_DIALCHECK                   1012
#define IDC_DISABLESTRING               1013
#define IDC_ALLPREFIXES                 1014
#define IDC_LISTEDPREFIXES              1015
#define IDC_WAITFORVOICE                1016
#define IDC_WAITFOR                     1017
#define IDC_CARDNUMBER                  1018
#define IDC_PIN                         1019
#define IDC_DESTNUMBER                  1020
#define IDC_SPECIFYDIGITS               1021
#define IDC_MOVEUP                      1022
#define IDC_MOVEDOWN                    1023
#define IDC_REMOVE                      1024
#define IDC_ACCESSNUMBER                1025
#define IDC_STEPS                       1026
#define IDC_COUNTRYCODE                 1027
#define IDC_USECALLINGCARD              1028
#define IDC_DIALAREACODE                1029
#define IDC_NEW                         1030
#define IDC_EDIT                        1031
#define IDC_DELETE                      1032
#define IDC_LIST                        1033
#define IDC_AREACODE                    1034
#define IDC_DISABLECALLWAITING          1035
#define IDC_TONE                        1036
#define IDC_PULSE                       1037
#define IDC_LOCATIONNAME                1038
#define IDC_DESCRIPTIONTEXT             1039
#define IDC_SAMPLENUMBER                1041
#define IDC_LONGDISTANCE                1042
#define IDC_INTERNATIONAL               1043
#define IDC_LONGDISTANCENUMBER          1044
#define IDC_INTERNATIONALNUMBER         1045
#define IDC_CALLINGCARDUSAGE            1046
#define IDC_CARDNAME                    1047
#define IDC_WAITFORTIME                 1048
#define IDC_TIMESPIN                    1049
#define IDC_TIME                        1050
#define IDC_LOCAL                       1051
#define IDC_PHONENUMBERTEXT             1052
#define IDC_PHONENUMBERSAMPLE           1053
#define IDC_CALLSFROM                   1054
#define IDC_DRIVER_LIST                 1055
#define IDC_CARDUSAGE                   1056
#define IDC_PREFIXES                    1057
#define IDC_CARRIERCODE                 1058
#define IDC_LONGDISTANCECARRIERCODE     1059
#define IDC_INTERNATIONALCARRIERCODE    1060
#define IDC_STATICLDC                   1061
#define IDC_STATICIC                    1062
#define IDC_STATICCC                    1063
#define IDS_CANNOT_START_TELEPHONCPL    1064
#define IDS_REMOVEPROVIDER              1065


#define IDC_NOHELP                      2000
#define RC_CARD_ID_BASE                 15800

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1057
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\h245if.h ===
/* Copyright (C) Microsoft Corporation 1999, All rights reserved. */

#ifndef __H245FMT_H__
#define __H245FMT_H__

#ifdef __cplusplus
extern "C" {
#endif

/*

	This file defines the structural interface that exists between
	installable H.245-compatible filter components and core TAPI MSP
	components. 

*/


// FORMAT_H245VERSION indicates the version number of H.245 that
// was in effect at the time the module was compiled.  Core MSP 
// maintain backward compatibility with modules compiled using this 
// header file. 
#define FORMAT_H245VERSION	3

/*
	The following data types are defined here to be consistent with 
	the ASN.1 library that is/was used to build TAPI core components.  
	If the ASN core files are also to be included, they must be included 
	before including this file. 
*/

#ifndef __MS_ASN1_H__ // avoid duplicate definitions when msasn1.h is included
#define __MS_ASN1_H__

/* ------ Basic integer types ------ */

typedef unsigned char   ASN1uint8_t;
typedef signed char     ASN1int8_t;

typedef unsigned short  ASN1uint16_t;
typedef signed short    ASN1int16_t;

typedef unsigned long   ASN1uint32_t;
typedef signed long     ASN1int32_t;

typedef ASN1int32_t     ASN1enum_t;     // enumerated type
typedef ASN1uint16_t    ASN1choice_t;   // choice


/* ------ Basic ASN.1 types ------ */

typedef ASN1uint8_t ASN1octet_t;
typedef ASN1uint8_t ASN1bool_t;

typedef struct ASN1objectidentifier_s
{
    struct ASN1objectidentifier_s *next;
    ASN1uint32_t value;
}*ASN1objectidentifier_t;

typedef struct tagASN1octetstring_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}ASN1octetstring_t;

#endif __MS_ASN1_H__

#ifndef _H245ASN_Module_H_  // avoid duplicate definitions when h245asn.h is included
#define _H245ASN_Module_H_
    

/* ------ H.245 audio and video structures ------ */

typedef ASN1uint16_t CustomPictureFormat_pixelAspectInformation_pixelAspectCode_Set;
typedef ASN1uint16_t RTPH263VideoRedundancyEncoding_containedThreads_Seq;
typedef ASN1uint16_t RTPH263VideoRedundancyFrameMapping_frameSequence_Seq;

typedef struct RedundancyEncodingCapability_secondaryEncoding * PRedundancyEncodingCapability_secondaryEncoding;
typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom * PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom;
typedef struct H263Options_customPictureFormat * PH263Options_customPictureFormat;
typedef struct H263Options_customPictureClockFrequency * PH263Options_customPictureClockFrequency;
typedef struct H263Options_modeCombos * PH263Options_modeCombos;
typedef struct EnhancementLayerInfo_bPictureEnhancement * PEnhancementLayerInfo_bPictureEnhancement;
typedef struct EnhancementLayerInfo_spatialEnhancement * PEnhancementLayerInfo_spatialEnhancement;
typedef struct EnhancementLayerInfo_snrEnhancement * PEnhancementLayerInfo_snrEnhancement;
typedef struct H2250Capability_redundancyEncodingCapability * PH2250Capability_redundancyEncodingCapability;
typedef struct EncryptionCapability * PEncryptionCapability;


typedef ASN1uint16_t CapabilityTableEntryNumber;

   
typedef struct NonStandardIdentifier_h221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} NonStandardIdentifier_h221NonStandard;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	NonStandardIdentifier_h221NonStandard h221NonStandard;
    } u;
} NonStandardIdentifier;

typedef struct NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct CustomPictureFormat_pixelAspectInformation_extendedPAR_Set {
    ASN1uint16_t width;
    ASN1uint16_t height;
} CustomPictureFormat_pixelAspectInformation_extendedPAR_Set;

typedef struct CustomPictureFormat_mPI_customPCF_Set {
    ASN1uint16_t clockConversionCode;
    ASN1uint16_t clockDivisor;
    ASN1uint16_t customMPI;
} CustomPictureFormat_mPI_customPCF_Set;

typedef struct VCCapability_availableBitRates_type_rangeOfBitRates {
    ASN1uint16_t lowerBitRate;
    ASN1uint16_t higherBitRate;
} VCCapability_availableBitRates_type_rangeOfBitRates;

typedef struct CustomPictureFormat_mPI_customPCF {
    ASN1uint32_t count;
    CustomPictureFormat_mPI_customPCF_Set value[16];
} CustomPictureFormat_mPI_customPCF;

typedef struct CustomPictureFormat_pixelAspectInformation_extendedPAR {
    ASN1uint32_t count;
    CustomPictureFormat_pixelAspectInformation_extendedPAR_Set value[256];
} CustomPictureFormat_pixelAspectInformation_extendedPAR;

typedef struct CustomPictureFormat_pixelAspectInformation_pixelAspectCode {
    ASN1uint32_t count;
    CustomPictureFormat_pixelAspectInformation_pixelAspectCode_Set value[14];
} CustomPictureFormat_pixelAspectInformation_pixelAspectCode;


typedef struct H263VideoMode_resolution {
    ASN1choice_t choice;
#   define sqcif_chosen 1
#   define H263VideoMode_resolution_qcif_chosen 2
#   define H263VideoMode_resolution_cif_chosen 3
#   define cif4_chosen 4
#   define cif16_chosen 5
} H263VideoMode_resolution;

typedef struct H262VideoMode_profileAndLevel {
    ASN1choice_t choice;
#   define profileAndLevel_SPatML_chosen 1
#   define profileAndLevel_MPatLL_chosen 2
#   define profileAndLevel_MPatML_chosen 3
#   define profileAndLevel_MPatH_14_chosen 4
#   define profileAndLevel_MPatHL_chosen 5
#   define profileAndLevel_SNRatLL_chosen 6
#   define profileAndLevel_SNRatML_chosen 7
#   define profileAndLevel_SpatialatH_14_chosen 8
#   define profileAndLevel_HPatML_chosen 9
#   define profileAndLevel_HPatH_14_chosen 10
#   define profileAndLevel_HPatHL_chosen 11
} H262VideoMode_profileAndLevel;

typedef struct H261VideoMode_resolution {
    ASN1choice_t choice;
#   define H261VideoMode_resolution_qcif_chosen 1
#   define H261VideoMode_resolution_cif_chosen 2
} H261VideoMode_resolution;

typedef struct CustomPictureFormat_pixelAspectInformation {
    ASN1choice_t choice;
    union {
#	define anyPixelAspectRatio_chosen 1
	ASN1bool_t anyPixelAspectRatio;
#	define pixelAspectCode_chosen 2
	CustomPictureFormat_pixelAspectInformation_pixelAspectCode pixelAspectCode;
#	define extendedPAR_chosen 3
	CustomPictureFormat_pixelAspectInformation_extendedPAR extendedPAR;
    } u;
} CustomPictureFormat_pixelAspectInformation;

typedef struct CustomPictureFormat_mPI {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define standardMPI_present 0x80
    ASN1uint16_t standardMPI;
#   define customPCF_present 0x40
    CustomPictureFormat_mPI_customPCF customPCF;
} CustomPictureFormat_mPI;

typedef struct RefPictureSelection_videoBackChannelSend {
    ASN1choice_t choice;
#   define RefPictureSelection_videoBackChannelSend_none_chosen 1
#   define ackMessageOnly_chosen 2
#   define nackMessageOnly_chosen 3
#   define ackOrNackMessageOnly_chosen 4
#   define ackAndNackMessage_chosen 5
} RefPictureSelection_videoBackChannelSend;

typedef struct RefPictureSelection_additionalPictureMemory {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define sqcifAdditionalPictureMemory_present 0x80
    ASN1uint16_t sqcifAdditionalPictureMemory;
#   define qcifAdditionalPictureMemory_present 0x40
    ASN1uint16_t qcifAdditionalPictureMemory;
#   define cifAdditionalPictureMemory_present 0x20
    ASN1uint16_t cifAdditionalPictureMemory;
#   define cif4AdditionalPictureMemory_present 0x10
    ASN1uint16_t cif4AdditionalPictureMemory;
#   define cif16AdditionalPictureMemory_present 0x8
    ASN1uint16_t cif16AdditionalPictureMemory;
#   define bigCpfAdditionalPictureMemory_present 0x4
    ASN1uint16_t bigCpfAdditionalPictureMemory;
} RefPictureSelection_additionalPictureMemory;

typedef struct RTPH263VideoRedundancyFrameMapping_frameSequence {
    ASN1uint32_t count;
    RTPH263VideoRedundancyFrameMapping_frameSequence_Seq value[256];
} RTPH263VideoRedundancyFrameMapping_frameSequence;

typedef struct RTPH263VideoRedundancyEncoding_containedThreads {
    ASN1uint32_t count;
    RTPH263VideoRedundancyEncoding_containedThreads_Seq value[256];
} RTPH263VideoRedundancyEncoding_containedThreads;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping {
    ASN1choice_t choice;
    union {
#	define roundrobin_chosen 1
#	define custom_chosen 2
	PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom custom;
    } u;
} RTPH263VideoRedundancyEncoding_frameToThreadMapping;

typedef struct RedundancyEncodingCapability_secondaryEncoding {
    PRedundancyEncodingCapability_secondaryEncoding next;
    CapabilityTableEntryNumber value;
} RedundancyEncodingCapability_secondaryEncoding_Element;


typedef struct RTPH263VideoRedundancyEncoding {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t numberOfThreads;
    ASN1uint16_t framesBetweenSyncPoints;
    RTPH263VideoRedundancyEncoding_frameToThreadMapping frameToThreadMapping;
#   define containedThreads_present 0x80
    RTPH263VideoRedundancyEncoding_containedThreads containedThreads;
} RTPH263VideoRedundancyEncoding;

typedef struct RTPH263VideoRedundancyFrameMapping {
    ASN1uint16_t threadNumber;
    RTPH263VideoRedundancyFrameMapping_frameSequence frameSequence;
} RTPH263VideoRedundancyFrameMapping;

typedef struct H261VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H261VideoCapability_qcifMPI_present 0x80
    ASN1uint16_t qcifMPI;
#   define H261VideoCapability_cifMPI_present 0x40
    ASN1uint16_t cifMPI;
    ASN1bool_t temporalSpatialTradeOffCapability;
    ASN1uint16_t maxBitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoCapability;

typedef struct H262VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t profileAndLevel_SPatML;
    ASN1bool_t profileAndLevel_MPatLL;
    ASN1bool_t profileAndLevel_MPatML;
    ASN1bool_t profileAndLevel_MPatH_14;
    ASN1bool_t profileAndLevel_MPatHL;
    ASN1bool_t profileAndLevel_SNRatLL;
    ASN1bool_t profileAndLevel_SNRatML;
    ASN1bool_t profileAndLevel_SpatialatH_14;
    ASN1bool_t profileAndLevel_HPatML;
    ASN1bool_t profileAndLevel_HPatH_14;
    ASN1bool_t profileAndLevel_HPatHL;
#   define H262VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoCapability_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoCapability;


typedef struct EnhancementLayerInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t baseBitRateConstrained;
#   define snrEnhancement_present 0x80
    PEnhancementLayerInfo_snrEnhancement snrEnhancement;
#   define spatialEnhancement_present 0x40
    PEnhancementLayerInfo_spatialEnhancement spatialEnhancement;
#   define bPictureEnhancement_present 0x20
    PEnhancementLayerInfo_bPictureEnhancement bPictureEnhancement;
} EnhancementLayerInfo;

typedef struct TransparencyParameters {
    ASN1uint16_t presentationOrder;
    ASN1int32_t offset_x;
    ASN1int32_t offset_y;
    ASN1uint16_t scale_x;
    ASN1uint16_t scale_y;
} TransparencyParameters;

typedef struct RefPictureSelection {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define additionalPictureMemory_present 0x80
    RefPictureSelection_additionalPictureMemory additionalPictureMemory;
    ASN1bool_t videoMux;
    RefPictureSelection_videoBackChannelSend videoBackChannelSend;
} RefPictureSelection;

typedef struct CustomPictureClockFrequency {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t clockConversionCode;
    ASN1uint16_t clockDivisor;
#   define CustomPictureClockFrequency_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define CustomPictureClockFrequency_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define CustomPictureClockFrequency_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define CustomPictureClockFrequency_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define CustomPictureClockFrequency_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
} CustomPictureClockFrequency;


typedef struct CustomPictureFormat {
    ASN1uint16_t maxCustomPictureWidth;
    ASN1uint16_t maxCustomPictureHeight;
    ASN1uint16_t minCustomPictureWidth;
    ASN1uint16_t minCustomPictureHeight;
    CustomPictureFormat_mPI mPI;
    CustomPictureFormat_pixelAspectInformation pixelAspectInformation;
} CustomPictureFormat;

typedef struct H263ModeComboFlags {
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t advancedIntraCodingMode;
    ASN1bool_t deblockingFilterMode;
    ASN1bool_t unlimitedMotionVectors;
    ASN1bool_t slicesInOrder_NonRect;
    ASN1bool_t slicesInOrder_Rect;
    ASN1bool_t slicesNoOrder_NonRect;
    ASN1bool_t slicesNoOrder_Rect;
    ASN1bool_t improvedPBFramesMode;
    ASN1bool_t referencePicSelect;
    ASN1bool_t dynamicPictureResizingByFour;
    ASN1bool_t dynamicPictureResizingSixteenthPel;
    ASN1bool_t dynamicWarpingHalfPel;
    ASN1bool_t dynamicWarpingSixteenthPel;
    ASN1bool_t reducedResolutionUpdate;
    ASN1bool_t independentSegmentDecoding;
    ASN1bool_t alternateInterVLCMode;
    ASN1bool_t modifiedQuantizationMode;
} H263ModeComboFlags;

typedef struct IS11172VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoCapability_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoCapability;

typedef struct H261VideoMode {
    H261VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoMode;

typedef struct H262VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H262VideoMode_profileAndLevel profileAndLevel;
#   define H262VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoMode_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoMode;

typedef struct IS11172VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoMode_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoMode;


typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom {
    PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom next;
    RTPH263VideoRedundancyFrameMapping value;
} RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_Element;

typedef struct H263VideoModeCombos_h263VideoCoupledModes {
    ASN1uint32_t count;
    H263ModeComboFlags value[16];
} H263VideoModeCombos_h263VideoCoupledModes;

typedef struct H263Options_customPictureFormat {
    PH263Options_customPictureFormat next;
    CustomPictureFormat value;
} H263Options_customPictureFormat_Element;

typedef struct H263Options_customPictureClockFrequency {
    PH263Options_customPictureClockFrequency next;
    CustomPictureClockFrequency value;
} H263Options_customPictureClockFrequency_Element;

typedef struct H263VideoModeCombos {
    H263ModeComboFlags h263VideoUncoupledModes;
    H263VideoModeCombos_h263VideoCoupledModes h263VideoCoupledModes;
} H263VideoModeCombos;

typedef struct H263Options_modeCombos {
    PH263Options_modeCombos next;
    H263VideoModeCombos value;
} H263Options_modeCombos_Element;

typedef struct H263Options {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t advancedIntraCodingMode;
    ASN1bool_t deblockingFilterMode;
    ASN1bool_t improvedPBFramesMode;
    ASN1bool_t unlimitedMotionVectors;
    ASN1bool_t fullPictureFreeze;
    ASN1bool_t partialPictureFreezeAndRelease;
    ASN1bool_t resizingPartPicFreezeAndRelease;
    ASN1bool_t fullPictureSnapshot;
    ASN1bool_t partialPictureSnapshot;
    ASN1bool_t videoSegmentTagging;
    ASN1bool_t progressiveRefinement;
    ASN1bool_t dynamicPictureResizingByFour;
    ASN1bool_t dynamicPictureResizingSixteenthPel;
    ASN1bool_t dynamicWarpingHalfPel;
    ASN1bool_t dynamicWarpingSixteenthPel;
    ASN1bool_t independentSegmentDecoding;
    ASN1bool_t slicesInOrder_NonRect;
    ASN1bool_t slicesInOrder_Rect;
    ASN1bool_t slicesNoOrder_NonRect;
    ASN1bool_t slicesNoOrder_Rect;
    ASN1bool_t alternateInterVLCMode;
    ASN1bool_t modifiedQuantizationMode;
    ASN1bool_t reducedResolutionUpdate;
#   define transparencyParameters_present 0x80
    TransparencyParameters transparencyParameters;
    ASN1bool_t separateVideoBackChannel;
#   define refPictureSelection_present 0x40
    RefPictureSelection refPictureSelection;
#   define customPictureClockFrequency_present 0x20
    PH263Options_customPictureClockFrequency customPictureClockFrequency;
#   define customPictureFormat_present 0x10
    PH263Options_customPictureFormat customPictureFormat;
#   define modeCombos_present 0x8
    PH263Options_modeCombos modeCombos;
} H263Options;


typedef struct H263VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H263VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
#   define H263VideoMode_errorCompensation_present 0x80
    ASN1bool_t errorCompensation;
#   define H263VideoMode_enhancementLayerInfo_present 0x40
    EnhancementLayerInfo enhancementLayerInfo;
#   define H263VideoMode_h263Options_present 0x20
    H263Options h263Options;
} H263VideoMode;


typedef struct H263VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H263VideoCapability_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define H263VideoCapability_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define H263VideoCapability_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define H263VideoCapability_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define H263VideoCapability_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define hrd_B_present 0x4
    ASN1uint32_t hrd_B;
#   define bppMaxKb_present 0x2
    ASN1uint16_t bppMaxKb;
#   define H263VideoCapability_slowSqcifMPI_present 0x8000
    ASN1uint16_t slowSqcifMPI;
#   define H263VideoCapability_slowQcifMPI_present 0x4000
    ASN1uint16_t slowQcifMPI;
#   define H263VideoCapability_slowCifMPI_present 0x2000
    ASN1uint16_t slowCifMPI;
#   define H263VideoCapability_slowCif4MPI_present 0x1000
    ASN1uint16_t slowCif4MPI;
#   define H263VideoCapability_slowCif16MPI_present 0x800
    ASN1uint16_t slowCif16MPI;
#   define H263VideoCapability_errorCompensation_present 0x400
    ASN1bool_t errorCompensation;
#   define H263VideoCapability_enhancementLayerInfo_present 0x200
    EnhancementLayerInfo enhancementLayerInfo;
#   define H263VideoCapability_h263Options_present 0x100
    H263Options h263Options;
} H263VideoCapability;


typedef struct EnhancementOptions {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define EnhancementOptions_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define EnhancementOptions_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define EnhancementOptions_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define EnhancementOptions_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define EnhancementOptions_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define EnhancementOptions_slowSqcifMPI_present 0x4
    ASN1uint16_t slowSqcifMPI;
#   define EnhancementOptions_slowQcifMPI_present 0x2
    ASN1uint16_t slowQcifMPI;
#   define EnhancementOptions_slowCifMPI_present 0x1
    ASN1uint16_t slowCifMPI;
#   define EnhancementOptions_slowCif4MPI_present 0x8000
    ASN1uint16_t slowCif4MPI;
#   define EnhancementOptions_slowCif16MPI_present 0x4000
    ASN1uint16_t slowCif16MPI;
    ASN1bool_t errorCompensation;
#   define EnhancementOptions_h263Options_present 0x2000
    H263Options h263Options;
} EnhancementOptions;


typedef struct BEnhancementParameters {
    EnhancementOptions enhancementOptions;
    ASN1uint16_t numberOfBPictures;
} BEnhancementParameters;

typedef struct EnhancementLayerInfo_bPictureEnhancement {
    PEnhancementLayerInfo_bPictureEnhancement next;
    BEnhancementParameters value;
} EnhancementLayerInfo_bPictureEnhancement_Element;

typedef struct VideoMode {
    ASN1choice_t choice;
    union {
#	define VideoMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoMode_chosen 2
	H261VideoMode h261VideoMode;
#	define h262VideoMode_chosen 3
	H262VideoMode h262VideoMode;
#	define h263VideoMode_chosen 4
	H263VideoMode h263VideoMode;
#	define is11172VideoMode_chosen 5
	IS11172VideoMode is11172VideoMode;
    } u;
} VideoMode;

typedef struct VideoCapability {
    ASN1choice_t choice;
    union {
#	define VideoCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoCapability_chosen 2
	H261VideoCapability h261VideoCapability;
#	define h262VideoCapability_chosen 3
	H262VideoCapability h262VideoCapability;
#	define h263VideoCapability_chosen 4
	H263VideoCapability h263VideoCapability;
#	define is11172VideoCapability_chosen 5
	IS11172VideoCapability is11172VideoCapability;
    } u;
} VideoCapability;

/******************************************************************************
Audio Format/Capability definitions and structures
*******************************************************************************
*/
typedef struct G7231AnnexCCapability_g723AnnexCAudioMode {
    ASN1uint16_t highRateMode0;
    ASN1uint16_t highRateMode1;
    ASN1uint16_t lowRateMode0;
    ASN1uint16_t lowRateMode1;
    ASN1uint16_t sidMode0;
    ASN1uint16_t sidMode1;
} G7231AnnexCCapability_g723AnnexCAudioMode;

typedef struct G7231AnnexCCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
#   define g723AnnexCAudioMode_present 0x80
    G7231AnnexCCapability_g723AnnexCAudioMode g723AnnexCAudioMode;
} G7231AnnexCCapability;

typedef struct IS11172AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1uint16_t bitRate;
} IS11172AudioCapability;


typedef struct IS13818AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling16k;
    ASN1bool_t audioSampling22k05;
    ASN1bool_t audioSampling24k;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1bool_t threeChannels2_1;
    ASN1bool_t threeChannels3_0;
    ASN1bool_t fourChannels2_0_2_0;
    ASN1bool_t fourChannels2_2;
    ASN1bool_t fourChannels3_1;
    ASN1bool_t fiveChannels3_0_2_0;
    ASN1bool_t fiveChannels3_2;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioCapability;

typedef struct GSMAudioCapability {
    ASN1uint16_t audioUnitSize;
    ASN1bool_t comfortNoise;
    ASN1bool_t scrambled;
} GSMAudioCapability;

typedef struct AudioMode_g7231 {
    ASN1choice_t choice;
#   define noSilenceSuppressionLowRate_chosen 1
#   define noSilenceSuppressionHighRate_chosen 2
#   define silenceSuppressionLowRate_chosen 3
#   define silenceSuppressionHighRate_chosen 4
} AudioMode_g7231;

typedef struct AudioCapability_g7231 {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
} AudioCapability_g7231;

typedef struct G7231AnnexCMode_g723AnnexCAudioMode {
    ASN1uint16_t highRateMode0;
    ASN1uint16_t highRateMode1;
    ASN1uint16_t lowRateMode0;
    ASN1uint16_t lowRateMode1;
    ASN1uint16_t sidMode0;
    ASN1uint16_t sidMode1;
} G7231AnnexCMode_g723AnnexCAudioMode;

typedef struct G7231AnnexCMode {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
    G7231AnnexCMode_g723AnnexCAudioMode g723AnnexCAudioMode;
} G7231AnnexCMode;

typedef struct IS13818AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS13818AudioMode_multichannelType_singleChannel_chosen 1
#   define IS13818AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS13818AudioMode_multichannelType_twoChannelDual_chosen 3
#   define threeChannels2_1_chosen 4
#   define threeChannels3_0_chosen 5
#   define fourChannels2_0_2_0_chosen 6
#   define fourChannels2_2_chosen 7
#   define fourChannels3_1_chosen 8
#   define fiveChannels3_0_2_0_chosen 9
#   define fiveChannels3_2_chosen 10
} IS13818AudioMode_multichannelType;

typedef struct IS13818AudioMode_audioSampling {
    ASN1choice_t choice;
#   define audioSampling16k_chosen 1
#   define audioSampling22k05_chosen 2
#   define audioSampling24k_chosen 3
#   define IS13818AudioMode_audioSampling_audioSampling32k_chosen 4
#   define IS13818AudioMode_audioSampling_audioSampling44k1_chosen 5
#   define IS13818AudioMode_audioSampling_audioSampling48k_chosen 6
} IS13818AudioMode_audioSampling;

typedef struct IS13818AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS13818AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS13818AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS13818AudioMode_audioLayer_audioLayer3_chosen 3
} IS13818AudioMode_audioLayer;

typedef struct IS11172AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS11172AudioMode_multichannelType_singleChannel_chosen 1
#   define IS11172AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS11172AudioMode_multichannelType_twoChannelDual_chosen 3
} IS11172AudioMode_multichannelType;

typedef struct IS11172AudioMode_audioSampling {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioSampling_audioSampling32k_chosen 1
#   define IS11172AudioMode_audioSampling_audioSampling44k1_chosen 2
#   define IS11172AudioMode_audioSampling_audioSampling48k_chosen 3
} IS11172AudioMode_audioSampling;

typedef struct IS11172AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS11172AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS11172AudioMode_audioLayer_audioLayer3_chosen 3
} IS11172AudioMode_audioLayer;


typedef struct IS11172AudioMode {
    IS11172AudioMode_audioLayer audioLayer;
    IS11172AudioMode_audioSampling audioSampling;
    IS11172AudioMode_multichannelType multichannelType;
    ASN1uint16_t bitRate;
} IS11172AudioMode;

typedef struct IS13818AudioMode {
    IS13818AudioMode_audioLayer audioLayer;
    IS13818AudioMode_audioSampling audioSampling;
    IS13818AudioMode_multichannelType multichannelType;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioMode;


typedef struct AudioCapability {
    ASN1choice_t choice;
    union {
#	define AudioCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioCapability_g711Alaw64k_chosen 2
	ASN1uint16_t g711Alaw64k;
#	define AudioCapability_g711Alaw56k_chosen 3
	ASN1uint16_t g711Alaw56k;
#	define AudioCapability_g711Ulaw64k_chosen 4
	ASN1uint16_t g711Ulaw64k;
#	define AudioCapability_g711Ulaw56k_chosen 5
	ASN1uint16_t g711Ulaw56k;
#	define AudioCapability_g722_64k_chosen 6
	ASN1uint16_t g722_64k;
#	define AudioCapability_g722_56k_chosen 7
	ASN1uint16_t g722_56k;
#	define AudioCapability_g722_48k_chosen 8
	ASN1uint16_t g722_48k;
#	define AudioCapability_g7231_chosen 9
	AudioCapability_g7231 g7231;
#	define AudioCapability_g728_chosen 10
	ASN1uint16_t g728;
#	define AudioCapability_g729_chosen 11
	ASN1uint16_t g729;
#	define AudioCapability_g729AnnexA_chosen 12
	ASN1uint16_t g729AnnexA;
#	define is11172AudioCapability_chosen 13
	IS11172AudioCapability is11172AudioCapability;
#	define is13818AudioCapability_chosen 14
	IS13818AudioCapability is13818AudioCapability;
#	define AudioCapability_g729wAnnexB_chosen 15
	ASN1uint16_t g729wAnnexB;
#	define AudioCapability_g729AnnexAwAnnexB_chosen 16
	ASN1uint16_t g729AnnexAwAnnexB;
#	define g7231AnnexCCapability_chosen 17
	G7231AnnexCCapability g7231AnnexCCapability;
#	define AudioCapability_gsmFullRate_chosen 18
	GSMAudioCapability gsmFullRate;
#	define AudioCapability_gsmHalfRate_chosen 19
	GSMAudioCapability gsmHalfRate;
#	define AudioCapability_gsmEnhancedFullRate_chosen 20
	GSMAudioCapability gsmEnhancedFullRate;
    } u;
} AudioCapability;


typedef struct AudioMode {
    ASN1choice_t choice;
    union {
#	define AudioMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioMode_g711Alaw64k_chosen 2
#	define AudioMode_g711Alaw56k_chosen 3
#	define AudioMode_g711Ulaw64k_chosen 4
#	define AudioMode_g711Ulaw56k_chosen 5
#	define AudioMode_g722_64k_chosen 6
#	define AudioMode_g722_56k_chosen 7
#	define AudioMode_g722_48k_chosen 8
#	define AudioMode_g728_chosen 9
#	define AudioMode_g729_chosen 10
#	define AudioMode_g729AnnexA_chosen 11
#	define AudioMode_g7231_chosen 12
	AudioMode_g7231 g7231;
#	define is11172AudioMode_chosen 13
	IS11172AudioMode is11172AudioMode;
#	define is13818AudioMode_chosen 14
	IS13818AudioMode is13818AudioMode;
#	define AudioMode_g729wAnnexB_chosen 15
	ASN1uint16_t g729wAnnexB;
#	define AudioMode_g729AnnexAwAnnexB_chosen 16
	ASN1uint16_t g729AnnexAwAnnexB;
#	define g7231AnnexCMode_chosen 17
	G7231AnnexCMode g7231AnnexCMode;
#	define AudioMode_gsmFullRate_chosen 18
	GSMAudioCapability gsmFullRate;
#	define AudioMode_gsmHalfRate_chosen 19
	GSMAudioCapability gsmHalfRate;
#	define AudioMode_gsmEnhancedFullRate_chosen 20
	GSMAudioCapability gsmEnhancedFullRate;
    } u;
} AudioMode;


typedef struct T84Profile_t84Restricted {
    ASN1bool_t qcif;
    ASN1bool_t cif;
    ASN1bool_t ccir601Seq;
    ASN1bool_t ccir601Prog;
    ASN1bool_t hdtvSeq;
    ASN1bool_t hdtvProg;
    ASN1bool_t g3FacsMH200x100;
    ASN1bool_t g3FacsMH200x200;
    ASN1bool_t g4FacsMMR200x100;
    ASN1bool_t g4FacsMMR200x200;
    ASN1bool_t jbig200x200Seq;
    ASN1bool_t jbig200x200Prog;
    ASN1bool_t jbig300x300Seq;
    ASN1bool_t jbig300x300Prog;
    ASN1bool_t digPhotoLow;
    ASN1bool_t digPhotoMedSeq;
    ASN1bool_t digPhotoMedProg;
    ASN1bool_t digPhotoHighSeq;
    ASN1bool_t digPhotoHighProg;
} T84Profile_t84Restricted;

typedef struct V42bis {
    ASN1uint32_t numberOfCodewords;
    ASN1uint16_t maximumStringLength;
} V42bis;

typedef struct T84Profile {
    ASN1choice_t choice;
    union {
#	define t84Unrestricted_chosen 1
#	define t84Restricted_chosen 2
	T84Profile_t84Restricted t84Restricted;
    } u;
} T84Profile;

typedef struct CompressionType {
    ASN1choice_t choice;
    union {
#	define v42bis_chosen 1
	V42bis v42bis;
    } u;
} CompressionType;

typedef struct DataProtocolCapability_v76wCompression {
    ASN1choice_t choice;
    union {
#	define transmitCompression_chosen 1
	CompressionType transmitCompression;
#	define receiveCompression_chosen 2
	CompressionType receiveCompression;
#	define transmitAndReceiveCompression_chosen 3
	CompressionType transmitAndReceiveCompression;
    } u;
} DataProtocolCapability_v76wCompression;

typedef struct DataProtocolCapability {
    ASN1choice_t choice;
    union {
#	define DataProtocolCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define v14buffered_chosen 2
#	define v42lapm_chosen 3
#	define hdlcFrameTunnelling_chosen 4
#	define h310SeparateVCStack_chosen 5
#	define h310SingleVCStack_chosen 6
#	define transparent_chosen 7
#	define segmentationAndReassembly_chosen 8
#	define hdlcFrameTunnelingwSAR_chosen 9
#	define v120_chosen 10
#	define separateLANStack_chosen 11
#	define v76wCompression_chosen 12
	DataProtocolCapability_v76wCompression v76wCompression;
    } u;
} DataProtocolCapability;


typedef struct DataMode_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataMode_application_nlpid;

typedef struct DataMode_application {
    ASN1choice_t choice;
    union {
#	define DataMode_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataMode_application_t120_chosen 2
	DataProtocolCapability t120;
#	define DataMode_application_dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataMode_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataMode_application_t84_chosen 5
	DataProtocolCapability t84;
#	define DataMode_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataMode_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataMode_application_nlpid_chosen 8
	DataMode_application_nlpid nlpid;
#	define DataMode_application_dsvdControl_chosen 9
#	define DataMode_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
#	define DataMode_application_t30fax_chosen 11
	DataProtocolCapability t30fax;
#	define DataMode_application_t140_chosen 12
	DataProtocolCapability t140;
    } u;
} DataMode_application;

typedef struct DataMode {
    DataMode_application application;
    ASN1uint32_t bitRate;
} DataMode;

typedef struct EncryptionMode {
    ASN1choice_t choice;
    union {
#	define EncryptionMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h233Encryption_chosen 2
    } u;
} EncryptionMode;

typedef struct AuthenticationCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define AuthenticationCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
} AuthenticationCapability;

typedef struct IntegrityCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define IntegrityCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
} IntegrityCapability;

typedef struct EncryptionAuthenticationAndIntegrity {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define encryptionCapability_present 0x80
    PEncryptionCapability encryptionCapability;
#   define authenticationCapability_present 0x40
    AuthenticationCapability authenticationCapability;
#   define integrityCapability_present 0x20
    IntegrityCapability integrityCapability;
} EncryptionAuthenticationAndIntegrity;

typedef struct H235Mode_mediaMode {
    ASN1choice_t choice;
    union {
#	define H235Mode_mediaMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H235Mode_mediaMode_videoMode_chosen 2
	VideoMode videoMode;
#	define H235Mode_mediaMode_audioMode_chosen 3
	AudioMode audioMode;
#	define H235Mode_mediaMode_dataMode_chosen 4
	DataMode dataMode;
    } u;
} H235Mode_mediaMode;



typedef struct H235Mode {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    H235Mode_mediaMode mediaMode;
} H235Mode;

typedef struct ModeElement_type {
    ASN1choice_t choice;
    union {
#	define ModeElement_type_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define ModeElement_type_videoMode_chosen 2
	VideoMode videoMode;
#	define ModeElement_type_audioMode_chosen 3
	AudioMode audioMode;
#	define ModeElement_type_dataMode_chosen 4
	DataMode dataMode;
#	define encryptionMode_chosen 5
	EncryptionMode encryptionMode;
#	define h235Mode_chosen 6
	H235Mode h235Mode;
    } u;
} ModeElement_type;

#endif // _H245ASN_Module_H_ 

typedef VideoCapability H245VideoCapability; 
typedef AudioCapability H245AudioCapability; 
typedef ModeElement_type H245_MODE_ELEMENT; 

typedef struct 
{
	DWORD dwApplicationCapID;
	ASN1choice_t choiceSetupProcedure;
	BOOL fRestrictAudio;
	BOOL fRestrictVideo;
	DataProtocolCapability T120ProtocolCap;
	//NonStandardParameter *pNonStandardParameter;
}H245T120Capability;

typedef enum 
{
    H245MediaType_Audio,    
    H245MediaType_Video,
    H245MediaType_T120
}H245MediaCapabilityType;

// media capability structure 
typedef struct tag_H245MediaCapability
{
    H245MediaCapabilityType  media_type;
    union 
    {
        H245AudioCapability audio_cap; 
        H245VideoCapability video_cap;
        H245T120Capability T120_cap;
    }capability;
    
}H245MediaCapability;

typedef struct tag_FormatResourceBounds
{
    DWORD dwBitsPerSecond;
    DWORD dwCPUUtilization;
} FormatResourceBounds;

#ifdef __cplusplus

/*****************************************************************************
 *  @doc INTERNAL H245VIDCSTRUCTENUM
 *
 *  @struct H245VideoCapabilityMap | The <t H245VideoCapabilityMap> structure
 *    is used to specify the relationship between supported formats and
 *    estimated maximum system resources for the supported format.
 *
 *  @field H245MediaCapability | h245MediaCapability | Specifies the H.245
 *    video/audio format, including all parameters and options. This structure
 *    is H.245 version specific: its definition depends on the version of
 *    H.245 used by the TAPI MSP filters. For video, this structure may indicate
 *    format parameters for more than one standard video size at a time if
 *    the resource requirements are similar for all sizes.
 *
 *  @field GUID | filterGuid | Specifies a GUID value that uniquely
 *    identifies the TAPI MSP filter.
 *
 *  @field DWORD | dwUniqueID | Specifies a DWORD value that uniquely
 *    identifies the capability of the TAPI MSP filter.
 *
 *  @field UINT | uNumEntries | This indicates the number of elements
 *    referenced by <t pResourceBoundArray>.
 *
 *  @field FormatResourceBounds* | pResourceBoundArray | Specifies an array
 *    of <t FormatResourceBounds> structures that indicate the approximate
 *    resource bounds of each entry.
 ***************************************************************************/
typedef struct tag_H245MediaCapabilityMap
{
    H245MediaCapability h245MediaCapability;
    GUID filterGuid;
    DWORD dwUniqueID;
    UINT uNumEntries;
    FormatResourceBounds *pResourceBoundArray;
} H245MediaCapabilityMap;

/*****************************************************************************
 *  @doc INTERNAL H245VIDCSTRUCTENUM
 *
 *  @struct H245MediaCapabilityTable | The <t H245MediaCapabilityTable> structure
 *    is used to specify the set of formats that are supported by the TAPI MSP
 *    filters.
 *
 *  @field UINT | uMappedCapabilities | Specifies  the  number of
 *    <t H245VideoCapabilityMap> structures in <t pCapabilityArray>.
 *
 *  @field H245MediaCapabilityMap* | pCapabilityArray | Specifies a pointer
 *    to an array of <t H245MediaCapabilityMap> structures.
 ***************************************************************************/
typedef struct tag_H245MediaCapabilityTable
{
    UINT uMappedCapabilities;
    H245MediaCapabilityMap *pCapabilityArray;
} H245MediaCapabilityTable;

/*****************************************************************************
 *  @doc INTERNAL CONST
 *
 *  @const int | TAPI_H245_VERSION_ID | Specifies  the  H.245 platform
 *    version 3.
 ***************************************************************************/
#define TAPI_H245_VERSION_ID 3

// H.245 video capability interface (pin interface)
interface DECLSPEC_UUID("ec35770f-b64d-405d-a5f2-4514164ba87a") IH245Capability : public IUnknown
{
	public:
	virtual STDMETHODIMP GetH245VersionID(OUT DWORD *pdwVersionID) PURE;
	virtual STDMETHODIMP GetFormatTable(OUT H245MediaCapabilityTable *pTable) PURE;
	virtual STDMETHODIMP ReleaseFormatTable(IN H245MediaCapabilityTable *pTable) PURE;
	virtual STDMETHODIMP IntersectFormats(
        IN DWORD dwUniqueID, 
        IN const H245MediaCapability *pLocalCapability, 
        IN const H245MediaCapability *pRemoteCapability, 
        OUT H245MediaCapability **ppIntersectedCapability,
        OUT  DWORD *pdwPayloadType
        ) PURE;

	virtual STDMETHODIMP Refine(IN OUT H245MediaCapability *pLocalCapability, IN DWORD dwUniqueID, IN DWORD dwResourceBoundIndex) PURE;
	virtual STDMETHODIMP GetLocalFormat(IN DWORD dwUniqueID, IN const H245MediaCapability *pIntersectedCapability, OUT AM_MEDIA_TYPE **ppAMMediaType) PURE;
	virtual STDMETHODIMP ReleaseNegotiatedCapability(IN H245MediaCapability *pIntersectedCapability) PURE;
	virtual STDMETHODIMP FindIDByRange(IN const AM_MEDIA_TYPE *pAMMediaType, OUT DWORD *pdwUniqueID) PURE;
};

// IH245EncoderCommand interface (pin interface)
interface DECLSPEC_UUID("b4263e5b-f216-4b58-9968-ba9ab7808ab3") IH245EncoderCommand : public IUnknown
{
	public:
	virtual STDMETHODIMP videoFastUpdatePicture() PURE;
	virtual STDMETHODIMP videoFastUpdateGOB(IN DWORD dwFirstGOB, IN DWORD dwNumberOfGOBs) PURE;
	virtual STDMETHODIMP videoFastUpdateMB(IN DWORD dwFirstGOB, IN DWORD dwFirstMB, IN DWORD dwNumberOfMBs) PURE;
	virtual STDMETHODIMP videoSendSyncEveryGOB(IN BOOL fEnable) PURE;
	virtual STDMETHODIMP videoNotDecodedMBs(IN DWORD dwFirstMB, IN DWORD dwNumberOfMBs, IN DWORD dwTemporalReference) PURE;
};

// IH245DecoderCommand interface (pin interface)
interface DECLSPEC_UUID("a542d119-6abd-48a5-92db-dac1dfe6995c") IH245DecoderCommand : public IUnknown
{
	public:
	virtual STDMETHODIMP videoFreezePicture() PURE;
};

#ifdef USE_PROGRESSIVE_REFINEMENT
// Progressive refinement interface (pin interface)
interface DECLSPEC_UUID("46a02824-6d1f-49d9-9e62-e1694f28ab1a") IProgressiveRefinement : public IUnknown
{
	public:
	virtual STDMETHODIMP doOneProgression() PURE;
	virtual STDMETHODIMP doContinuousProgressions() PURE;
	virtual STDMETHODIMP doOneIndependentProgression() PURE;
	virtual STDMETHODIMP doContinuousIndependentProgressions() PURE;
	virtual STDMETHODIMP progressiveRefinementAbortOne() PURE;
	virtual STDMETHODIMP progressiveRefinementAbortContinuous() PURE;
};
#endif

#if !defined(STREAM_INTERFACES_DEFINED)

#define MAX_DESCRIPTION_LEN 256

typedef enum tagStreamConfigCapsType
{
	AudioStreamConfigCaps,
	VideoStreamConfigCaps
} StreamConfigCapsType;

typedef struct _TAPI_AUDIO_STREAM_CONFIG_CAPS
{
	WCHAR Description[MAX_DESCRIPTION_LEN];
	ULONG MinimumChannels;
	ULONG MaximumChannels;
	ULONG ChannelsGranularity;
	ULONG MinimumBitsPerSample;
	ULONG MaximumBitsPerSample;
	ULONG BitsPerSampleGranularity;
	ULONG MinimumSampleFrequency;
	ULONG MaximumSampleFrequency;
	ULONG SampleFrequencyGranularity;
    ULONG MinimumAvgBytesPerSec;
    ULONG MaximumAvgBytesPerSec;
    ULONG AvgBytesPerSecGranularity;
} TAPI_AUDIO_STREAM_CONFIG_CAPS, *PTAPI_AUDIO_STREAM_CONFIG_CAPS;

typedef struct _TAPI_VIDEO_STREAM_CONFIG_CAPS
{
	WCHAR Description[MAX_DESCRIPTION_LEN];
	ULONG VideoStandard;
	SIZE InputSize;
	SIZE MinCroppingSize;
	SIZE MaxCroppingSize;
	int CropGranularityX;
	int CropGranularityY;
	int CropAlignX;
	int CropAlignY;
	SIZE MinOutputSize;
	SIZE MaxOutputSize;
	int OutputGranularityX;
	int OutputGranularityY;
	int StretchTapsX;
	int StretchTapsY;
	int ShrinkTapsX;
	int ShrinkTapsY;
	LONGLONG MinFrameInterval;
	LONGLONG MaxFrameInterval;
	LONG MinBitsPerSecond;
	LONG MaxBitsPerSecond;
} TAPI_VIDEO_STREAM_CONFIG_CAPS, *PTAPI_VIDEO_STREAM_CONFIG_CAPS;

typedef struct tagTAPI_STREAM_CONFIG_CAPS
{
	StreamConfigCapsType CapsType;
	union
	{
		TAPI_VIDEO_STREAM_CONFIG_CAPS VideoCap;
		TAPI_AUDIO_STREAM_CONFIG_CAPS AudioCap;
	};
} TAPI_STREAM_CONFIG_CAPS, *PTAPI_STREAM_CONFIG_CAPS;

#endif


// used in SetFormat when the payload type is unknown.
const DWORD UNKNOWN_PAYLOAD = (DWORD)(-1);

// IStreamConfig interface (pin interface)
interface DECLSPEC_UUID("c5888472-8f4f-475b-8f5b-93b6c8e7567f") IStreamConfig : public IUnknown
{
// TODO, we need to introduce a new interface to handle all the RTP payload type
// related issues. The payload type info shouldn't be in this interface.

	public:
	virtual STDMETHODIMP SetFormat(IN DWORD dwRTPPayLoadType, IN AM_MEDIA_TYPE *pMediaType) PURE;
	virtual STDMETHODIMP GetFormat(OUT DWORD *pdwRTPPayLoadType, OUT AM_MEDIA_TYPE **ppMediaType) PURE;
	virtual STDMETHODIMP GetNumberOfCapabilities(OUT DWORD *pdwCount) PURE;
	virtual STDMETHODIMP GetStreamCaps(IN DWORD dwIndex, OUT AM_MEDIA_TYPE **ppMediaType, OUT TAPI_STREAM_CONFIG_CAPS *pTSCC, OUT DWORD *pdwRTPPayLoadType) PURE;
};

#endif // __cplusplus

#ifdef __cplusplus
}
#endif

#endif	// __H245FMT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\clientr.h ===
//
// (c) 1995 Microsoft Corporation.  Portions Copyright Intel/Microsoft 1992-93.  All Rights Reserved."
//
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by TELEPHON.RC
//
#define IDS_DC_GL_DRIVER_SETUP          1
#define IDS_DT_GL_DRIVER_LIST           2
#define IDCL_CR_HELP                    3
#define IDS_DC_GL_LOCATION              4
#define ID_CURRENT                      4
#define IDS_DT_GL_LOC_LIST              5
#define IDS_DC_GL_CALL_CARD             6
#define ID_NEW                          6
#define IDS_DT_GL_CARD_LIST             7
#define IDS_TITLE                       8
#define IDS_STATUS_LINE                 9
#define IDHELP                          9
#define IDS_HELP_FILE                   10
#define IDS_CLOSE                       11
#define IDS_CUSTOMIZE                   12
#define IDS_ADD_LOCATION                13
#define IDS_EDIT_LOCATION               14
#define IDS_WRN_REMOVE_CARD             15
#define IDS_ERR_APPLICATION             16
#define IDS_ERR_MEMORY                  17
#define IDS_ERR_ALREADY_IN_LIST         18
#define IDS_ERR_READ_PRIV_INI           19
#define IDS_ERR_WRITE_INI               20
#define IDS_ERR_INVALID_INI             21
#define IDS_ERR_WRITE_WIN_INI           22
#define IDS_WRN_INVALID_STR             23
#define IDS_WRN_INVALID_EX_NUM_STR      24
#define IDS_WRN_INVALID_NUM             25
#define IDS_ERR_INVALID_TAPIADDR        26
#define IDS_WRN_INI_READ_ONLY           27
#define IDS_DT_DS_NO_DRIVER             28
#define IDS_ERR_NO_DRIVER               29
#define IDS_ERR_BAD_DRIVER              30
#define IDS_NONE                        31
#define IDS_ADD_CALLING_CARD            32
#define IDS_EDIT_CALLING_CARD           33

#define IDS_CARD_REMOVE                 34
#define REMOVE_CARD       IDS_CARD_REMOVE
#define IDS_LOCATION_REMOVE             35
#define REMOVE_LOCATION   IDS_LOCATION_REMOVE

#define IDS_DRIVER_REMOVE               36
#define IDS_ERR_INVALID_INI_LOCATIONS   37
#define IDS_ERR_INVALID_INI_CARDS       38
#define IDD_BROWSE_TEMPLATE             38
#define IDS_ERR_INVALID_INI_DRIVERS     39

#ifndef CHICAGO
#define IDS_ERR_INVALID_INI_COUNTRIES   40
#endif

#define IDS_WRN_AREA_CODE_REQUIRED      41
#define IDS_WRN_INVALID_NUM_STR         42
#define IDS_WRN_INVALID_LOCATION_CARD   43
#define IDS_WRN_DRIVER_IN_USE           44
#define IDS_ERR_DRIVER_FAILED           45
#define IDS_ERR_MULTIPLE_INST           46

#define IDS_DIAL_ASST                   47
#define IDS_ERR_UPDATE_LOCATION          48
#define IDS_ERR_UPDATE_CARD              49
#define IDS_WRN_LOCATION_NAME_REQUIRED  50
#define IDS_WRN_CANNOT_CHANGE_DEF_LOC   51
#define IDS_WRN_LOCATION_NAME_REQUIRED  50

#define IDS_PROVIDERERROR_NOT_AN_SP     52
#define IDS_PROVIDERERROR_TOO_OLD       53
#define IDS_PROVIDERERROR_FAILED_INIT   54
#define IDS_WRN_CARD_NAME_REQUIRED       55
#define IDS_WRN_QUITING_WIZ            56

#define IDS_WRN_CANT_REMOVE_LAST_CARD   57

#define IDS_WRN_CARD_NUMBER_REQUIRED    58
#define IDS_MSG_SIMPLEMSG_MDMINSTALLED  59
#define IDS_NOCALLINGCARD               60
#define IDS_DL_DUP_NAME                 61
#define IDS_DL_NULL_NAME                62
#define IDS_DL_DUP_NAME_CAPTION         63
#define IDS_DL_NULL_NAME_CAPTION        64

#define IDD_TOLL_LIST                   104
#define IDD_CREDIT_CARD                 105
#define IDD_DIALING_RULES               106
#define IDI_TELEPHONY                   108
#define IDD_COPY_DIAL_RULES             109
#define IDD_ADD_DRIVER                  111
#define IDD_DEFINE_LOCATION             112
#define IDD_DEFINE_LOCATION_SIMPLE      113
#define IDD_DRIVER_SETUP                116
#define IDD_INSTALL_DRIVER              117
#define IDB_BITMAP1                     120
#define IDD_DEBUG_OUT                   121
#define ID_LIST                         303
#define LB_UNLISTED                     306

#define IDS_WRN_TITLE_WARNING           350
#define IDS_WRN_TITLE_NAMEINUSE         351
#define IDS_WRN_TITLE_INVALCHAR         352
#define IDS_WRN_TITLE_SURE              353
#define IDS_WRN_TITLE_REQUIRED          354
#define IDS_WRN_RULESNEEDED             355

#define IDCC_TM_CURR_LOCATION           1000
#define IDD_INSERT_DISK                 1000
#define IDD_BROWSE                      1001
#define IDD_UNLISTED_DRIVERS            1002
#define IDD_UPDATE                      1003
#define IDD_RESTART                     1004
#define IDD_EXISTS                      1005
#define IDCB_TM_MULT_LOCATIONS          1007
#define IDCB_TM_DRIVER_SETUP            1008
#define IDCB_TM_HELP                    1009
#define IDCB_GL_REMOVE                  1011
#define IDCB_TL_REMOVE                  1012
#define IDCB_TL_ADD                     1013
#define IDCB_TL_HELP                    1014
#define IDCK_TL_USE_AREA_CODE           1015
#define IDCT_GL_LIST_TEXT               1017
#define IDCB_CC_CUSTOMIZE               1018
#define IDCB_CC_HELP                    1019
#define IDCE_CC_CARD_NAME               1020
#define IDCE_CC_CARD_NUM                1021
#define IDCB_DR_COPY_FROM               1022
#define IDCE_CC_PASSWORD_CARD_NUM       1022
#define IDCB_DR_HELP                    1023
#define IDCE_DR_LOCAL_NUM               1024
#define IDCE_DR_LONG_NUM                1025
#define IDCE_DR_INTERNATIONAL_NUM       1026
#define IDCL_CR_RULE_LIST               1031
#define IDCB_AD_ADD                     1032
#define IDCB_AD_BROWSE                  1033
#define IDCH_AD_HELP                    1034
#define IDCE_DL_NAME                    1035
#define IDCE_DL_OUTSIDEACCESS           1036
#define IDCE_DL_LONGDISTANCEACCESS      1037
#define IDCE_DL_AREACODE                1038
#define psh15                           0x040e
#define IDCC_DL_COUNTRY                 1039
#define IDCC_DL_CALLING_CARD            1040
#define chx1                            0x0410
#define IDCB_DL_TOLL_LIST               1041
#define IDCL_AD_DRIVER_LIST             1042
#define IDCB_DL_CALLCARD_SETUP          1052
#define IDCB_DL_HELP                    1053
#define IDCC_TL_TOLL_LIST               1055
#define IDCB_DS_EDIT                    1056
#define IDCL_DS_LIST                    1057
#define IDCB_DS_ADD                     1058
#define IDCB_DS_REMOVE                  1059
#define IDCB_DS_HELP                    1060
#define IDCK_DR_HIDE_CARD               1061
#define IDCS_TM_LOCAL_CALLS             1062
#define IDCS_TM_LONG_DIST_CALLS         1063
#define IDCS_TM_AREA_CODE               1064
#define IDCS_TM_COUNTRY_CODE            1065
#define IDCS_TM_CALLING_CARD            1066
#define IDCB_INSTALL_BROWSE             1067
#define IDC_BUTTON2                     1068
#define IDCB_ID_HELP                    1068
#define IDCE_PATHNAME                   1069
#define IDT_DEBUG                       1070
#define IDCB_TM_CALLCARD_SETUP          1081
#define IDCB_GL_EDIT                    1083
#define stc1                            0x0440
#define stc2                            0x0441
#define IDCB_GL_ADD                     1109
#define IDCB_GL_HELP                    1112
#define lst1                            0x0460
#define IDCL_GL_LIST                    1121
#define lst2                            0x0461
#define cmb1                            0x0470
#define cmb2                            0x0471
#define edt1                            0x0480
#define ctlLast                         0x04ff
#define IDS_NAME                        2001
#define IDS_NAME2                       2002
#define IDS_NOINF                       2003
#define IDS_NOINF2                      2004
#define IDS_OUTOFDISK                   2005
#define IDS_NOINF3                      2006
#define IDS_NAME3                       2007
#define IDS_RESTARTTEXT                 2015
#define IDS_UPDATED                     2031
#define IDS_UNLISTED                    2034
#define IDS_UNABLE_TOINSTALL            2049
#define IDS_FILEINUSEADD                2053
#define IDS_FILEINUSEREM                2055
#define IDS_FILEINUSEREM2               2056
#define IDS_DRIVER_EXISTS               2058
#define IDS_DIAL_ASST_NOT_SET                2059
#define IDS_WRN_DIAL_ASST_NOT_SET        2060
#define ID_STATUS2                      4002
#define IDS_FILENOTINDIR                0x2001
#define IDS_DISKMSG                     0x2002
#define IDS_FILEMSG                     0x2003
#define IDS_DISKFILEMSG                 0x2004
#define IDH_DLG_ADD_UNKNOWN             8803
#define IDD_PATH                        0x3002
#define IDD_TEXT                        0x3003
#define IDD_ICON                        0x3004
#define IDS_NEWLOCATION                 0x3005
#define IDC_STATIC                      -1

#define IDCC_DL_NAME                5000
#define IDCB_DL_NEW_LOCATION                 5001
#define IDCK_DL_IN_LOCAL                     5002
#define IDCB_DL_REMOVE_LOCATION          5003
#define IDCB_DL_CHANGE_CARD              5004
#define IDCK_DL_CALLINGCARD              5005
#define IDCK_DL_CALLWAITING             5006
#define IDCK_DL_PULSE_DIAL               5007
#define IDCC_DL_CALLWAITING             5008
#define IDCE_DL_CALLINGCARD              5009
#define IDCS_DL_NAME                     5010
#define IDCS_DL_AREACODE                 5011
#define IDCS_DL_COUNTRY                  5012
#define IDCS_DL_OUTSIDE                  5013
#define IDCS_DL_OUTSIDEACCESS            5014
#define IDCS_DL_LONGDISTANCEACCESS       5015

#define IDCS_DL_SILENTTEXT               5016
#define IDCS_DL_CREATED_LOCATION         5017


#define IDCC_DR_CARD_NAME               6000
#define IDCE_DR_CARD_NUM                6001
#define IDCK_DR_IN_LOCAL                     6002
#define IDCB_DR_NEW_CARD                     6003
#define IDCB_DR_REMOVE_CARD              6004
#define IDCB_DR_ADVANCED                     6005
#define IDCS_DR_CARD_NAME                   6006
#define IDCS_DR_CARD_NUM                    6007
#define IDCS_DR_LOCAL_NUM                   6008
#define IDCS_DR_LONG_NUM                    6009
#define IDCS_DR_INTERNATIONAL_NUM           6010
#define IDCB_DR_DUMMY                                                6011



#define IDCR_PULSE                          6050
#define IDCR_TONE                           6051
#define IDCS_PULSE                          6052
#define IDCS_TONE                           6053
#define IDCR_CC_DIALZERO                    6054
#define IDCR_CC_DIALACCESSNUM               6055

#define IDD_NEW_LOCATION                    7000
#define IDCE_NL_NEW_LOCATION                7001
#define IDCS_NL_NEW_LOCATION                7002

#define IDD_NEW_CARD                        8000
#define IDCE_NC_NEW_CARD                    8001
#define IDCS_NC_NEW_CARD                    8002
#define IDCS_CR_RULE_LIST                   8003

#define IDCS_DIAL_NUMBER_TEXT               9000
#define IDCS_DL_DIAL_NUMBER                 9001
#define IDCS_DR_DIAL_NUMBER                 9002
#define IDCS_LOC_BMP                        9100
#define IDCL_LOC_BMP                        9101
#define IDCL_LOC_SIMPLE_BMP                 9102

#define IDD_CALLING_CARD_CHANGE             9150

/* ALERT! Do NOT change this value. It is used by the RNA guys
 * to identify the Dialing info dialog for their Modems Wizard.
 */
#define IDD_WIZ_DIALINFO                                        400


// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        122
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1071
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif


#define RC_CARD_ID_BASE         15800
#define RC_COUNTRY_ID_BASE      16000

#define DIALINGPROPERTIES_NAME 4446




//#if WINNT

// id's for TAPI Dial Helper (5100-5199)

// (copied from HELP.H)

#define IDH_TAPI_ACCESS_LINE            5100
#define IDH_TAPI_AREA_CODE              5101
#define IDH_TAPI_CALLCARD_ADD           5102
//#define IDH_TAPI_CALLCARD_ADV           5103
#define IDH_TAPI_CALLCARD_NUMBER        5104
#define IDH_TAPI_CALLCARD_REMOVE        5105
#define IDH_TAPI_CALLCARD_RULES         5106
#define IDH_TAPI_CALLCARDS              5107
#define IDH_TAPI_COPY_FROM_BUTTON       5108
#define IDH_TAPI_COPYFROM               5109
#define IDH_TAPI_COUNTRY                5110
#define IDH_TAPI_CREATE_CARD            5111
#define IDH_TAPI_CREATE_LOCATION        5112
#define IDH_TAPI_LOCATION_CALL_WAIT     5113
#define IDH_TAPI_LOCATION_CARD          5114
#define IDH_TAPI_LOCATION_CARD_CHANGE   5115
#define IDH_TAPI_LOCATION_NEW           5116
#define IDH_TAPI_LOCATION_PHONE         5117
#define IDH_TAPI_LOCATION_PULSE         5118
#define IDH_TAPI_LOCATION_REMOVE        5119
#define IDH_TAPI_LOCATIONS              5120
#define IDH_TAPI_LONG_DISTANCE          5121

// NOTE: Telephony Drivers dlg/propsheet uses help IDs 5122-5128
#define IDH_TAPI_NEW_PREFIX             5129
#define IDH_TAPI_DIGITSTODIAL           5130
#define IDH_TAPI_CC_LDPHONENUMBER       5131
#define IDH_TAPI_CC_IPHONENUMBER        5132
#define IDH_TAPI_CC_LDSTEPSBUTTON       5133
#define IDH_TAPI_CC_ISTEPSBUTTON        5134
#define IDH_TAPI_DIALINGRULES           5135
#define IDH_TAPI_CARDNAME               5136
#define IDH_TAPI_USE_CALLINGCARD        5137
#define IDH_TAPI_NEW_TOLLPREFIX         5138
#define IDH_TAPI_REMOVE_TOLLPREFIX      5139
#define IDH_TAPI_NEW_10DIGITAC          5140
#define IDH_TAPI_REMOVE_10DIGITAC       5141
#define IDH_TAPI_NEW_ACFIELD            5142
#define IDH_TAPI_CCSTEP_DIAL            5143
#define IDH_TAPI_CCSTEP_WAIT            5144
#define IDH_TAPI_10DIGITDIALING         5145

//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\line.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    line.h

Abstract:

    Header file for tapi server line functions

Author:

    Dan Knudson (DanKn)    01-Apr-1995

Revision History:

--*/


#define MAXLEN_NAME    96
#define MAXLEN_RULE    128



#define ANY_RT_HCALL        1
#define ANY_RT_HLINE        2
#define DEVICE_ID           3


#if DBG

#define LINEPROLOG(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14) \
        LineProlog(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14)

#define LINEEPILOGSYNC(a1,a2,a3,a4,a5) LineEpilogSync(a1,a2,a3,a4,a5)

#define LINEEPILOGASYNC(a1,a2,a3,a4,a5,a6,a7) \
        LineEpilogAsync(a1,a2,a3,a4,a5,a6,a7)

#else

#define LINEPROLOG(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14) \
        LineProlog(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13)

#define LINEEPILOGSYNC(a1,a2,a3,a4,a5) LineEpilogSync(a1,a2,a3,a4)

#define LINEEPILOGASYNC(a1,a2,a3,a4,a5,a6,a7) \
        LineEpilogAsync(a1,a2,a3,a4,a5,a6)

#endif


#define AllAddressTypes                   \
    (LINEADDRESSTYPE_PHONENUMBER        | \
    LINEADDRESSTYPE_SDP                 | \
    LINEADDRESSTYPE_EMAILNAME           | \
    LINEADDRESSTYPE_DOMAINNAME          | \
    LINEADDRESSTYPE_IPADDRESS)

#define AllAddressStates1_0               \
    (LINEADDRESSSTATE_OTHER             | \
    LINEADDRESSSTATE_DEVSPECIFIC        | \
    LINEADDRESSSTATE_INUSEZERO          | \
    LINEADDRESSSTATE_INUSEONE           | \
    LINEADDRESSSTATE_INUSEMANY          | \
    LINEADDRESSSTATE_NUMCALLS           | \
    LINEADDRESSSTATE_FORWARD            | \
    LINEADDRESSSTATE_TERMINALS)

#define AllAddressStates1_4               \
    (AllAddressStates1_0                | \
    LINEADDRESSSTATE_CAPSCHANGE)

//#define AllAddressStates2_0               \
//    (AllAddressStates1_4                | \
//    LINEADDRESSSTATE_AGENT              | \
//    LINEADDRESSSTATE_AGENTSTATE         | \
//    LINEADDRESSSTATE_AGENTACTIVITY)

#define AllAgentStates                    \
    (LINEAGENTSTATE_LOGGEDOFF           | \
    LINEAGENTSTATE_NOTREADY             | \
    LINEAGENTSTATE_READY                | \
    LINEAGENTSTATE_BUSYACD              | \
    LINEAGENTSTATE_BUSYINCOMING         | \
    LINEAGENTSTATE_BUSYOUTBOUND         | \
    LINEAGENTSTATE_BUSYOTHER            | \
    LINEAGENTSTATE_WORKINGAFTERCALL     | \
    LINEAGENTSTATE_UNKNOWN              | \
    LINEAGENTSTATE_UNAVAIL              | \
    0xffff0000)

#define AllAgentStatus                    \
    (LINEAGENTSTATUS_GROUP              | \
    LINEAGENTSTATUS_STATE               | \
    LINEAGENTSTATUS_NEXTSTATE           | \
    LINEAGENTSTATUS_ACTIVITY            | \
    LINEAGENTSTATUS_ACTIVITYLIST        | \
    LINEAGENTSTATUS_GROUPLIST           | \
    LINEAGENTSTATUS_CAPSCHANGE          | \
    LINEAGENTSTATUS_VALIDSTATES         | \
    LINEAGENTSTATUS_VALIDNEXTSTATES)

#define AllAgentSessionStates             \
    (LINEAGENTSESSIONSTATE_NOTREADY     | \
    LINEAGENTSESSIONSTATE_READY         | \
    LINEAGENTSESSIONSTATE_BUSYONCALL    | \
    LINEAGENTSESSIONSTATE_BUSYWRAPUP    | \
    LINEAGENTSESSIONSTATE_ENDED         | \
    LINEAGENTSESSIONSTATE_RELEASED)

#define AllAgentSessionStatus             \
    (LINEAGENTSESSIONSTATUS_NEWSESSION  | \
    LINEAGENTSESSIONSTATUS_STATE        | \
    LINEAGENTSESSIONSTATUS_UPDATEINFO)

#define AllAgentStatusEx                  \
    (LINEAGENTSTATUSEX_NEWAGENT         | \
    LINEAGENTSTATUSEX_STATE             | \
    LINEAGENTSTATUSEX_UPDATEINFO)
                                        
#define AllAgentStatesEx                  \
    (LINEAGENTSTATEEX_NOTREADY          | \
    LINEAGENTSTATEEX_READY              | \
    LINEAGENTSTATEEX_BUSYACD            | \
    LINEAGENTSTATEEX_BUSYINCOMING       | \
    LINEAGENTSTATEEX_BUSYOUTGOING       | \
    LINEAGENTSTATEEX_UNKNOWN            | \
    LINEAGENTSTATEEX_RELEASED)    


#define AllBearerModes1_0                 \
    (LINEBEARERMODE_VOICE               | \
    LINEBEARERMODE_SPEECH               | \
    LINEBEARERMODE_MULTIUSE             | \
    LINEBEARERMODE_DATA                 | \
    LINEBEARERMODE_ALTSPEECHDATA        | \
    LINEBEARERMODE_NONCALLSIGNALING)

#define AllBearerModes1_4                 \
    (AllBearerModes1_0                  | \
    LINEBEARERMODE_PASSTHROUGH)

#define AllBearerModes2_0                 \
    (AllBearerModes1_4                  | \
    LINEBEARERMODE_RESTRICTEDDATA)

#define AllCallComplModes                 \
    (LINECALLCOMPLMODE_CAMPON           | \
    LINECALLCOMPLMODE_CALLBACK          | \
    LINECALLCOMPLMODE_INTRUDE           | \
    LINECALLCOMPLMODE_MESSAGE)

#define AllCallParamFlags1_0              \
    (LINECALLPARAMFLAGS_SECURE          | \
    LINECALLPARAMFLAGS_IDLE             | \
    LINECALLPARAMFLAGS_BLOCKID          | \
    LINECALLPARAMFLAGS_ORIGOFFHOOK      | \
    LINECALLPARAMFLAGS_DESTOFFHOOK)

#define AllCallParamFlags2_0              \
    (LINECALLPARAMFLAGS_SECURE          | \
    LINECALLPARAMFLAGS_IDLE             | \
    LINECALLPARAMFLAGS_BLOCKID          | \
    LINECALLPARAMFLAGS_ORIGOFFHOOK      | \
    LINECALLPARAMFLAGS_DESTOFFHOOK      | \
    LINECALLPARAMFLAGS_NOHOLDCONFERENCE | \
    LINECALLPARAMFLAGS_PREDICTIVEDIAL   | \
    LINECALLPARAMFLAGS_ONESTEPTRANSFER)

#define AllCallSelects                    \
    (LINECALLSELECT_LINE                | \
    LINECALLSELECT_ADDRESS              | \
    LINECALLSELECT_CALL)

#define AllForwardModes1_0                \
    (LINEFORWARDMODE_UNCOND             | \
    LINEFORWARDMODE_UNCONDINTERNAL      | \
    LINEFORWARDMODE_UNCONDEXTERNAL      | \
    LINEFORWARDMODE_UNCONDSPECIFIC      | \
    LINEFORWARDMODE_BUSY                | \
    LINEFORWARDMODE_BUSYINTERNAL        | \
    LINEFORWARDMODE_BUSYEXTERNAL        | \
    LINEFORWARDMODE_BUSYSPECIFIC        | \
    LINEFORWARDMODE_NOANSW              | \
    LINEFORWARDMODE_NOANSWINTERNAL      | \
    LINEFORWARDMODE_NOANSWEXTERNAL      | \
    LINEFORWARDMODE_NOANSWSPECIFIC      | \
    LINEFORWARDMODE_BUSYNA              | \
    LINEFORWARDMODE_BUSYNAINTERNAL      | \
    LINEFORWARDMODE_BUSYNAEXTERNAL      | \
    LINEFORWARDMODE_BUSYNASPECIFIC)

#define AllForwardModes1_4                \
    (AllForwardModes1_0                 | \
    LINEFORWARDMODE_UNKNOWN             | \
    LINEFORWARDMODE_UNAVAIL)

#define AllGroupStatus                    \
    (LINEGROUPSTATUS_NEWGROUP           | \
    LINEGROUPSTATUS_GROUPREMOVED)      


#define AllLineStates1_0                  \
    (LINEDEVSTATE_OTHER                 | \
    LINEDEVSTATE_RINGING                | \
    LINEDEVSTATE_CONNECTED              | \
    LINEDEVSTATE_DISCONNECTED           | \
    LINEDEVSTATE_MSGWAITON              | \
    LINEDEVSTATE_MSGWAITOFF             | \
    LINEDEVSTATE_INSERVICE              | \
    LINEDEVSTATE_OUTOFSERVICE           | \
    LINEDEVSTATE_MAINTENANCE            | \
    LINEDEVSTATE_OPEN                   | \
    LINEDEVSTATE_CLOSE                  | \
    LINEDEVSTATE_NUMCALLS               | \
    LINEDEVSTATE_NUMCOMPLETIONS         | \
    LINEDEVSTATE_TERMINALS              | \
    LINEDEVSTATE_ROAMMODE               | \
    LINEDEVSTATE_BATTERY                | \
    LINEDEVSTATE_SIGNAL                 | \
    LINEDEVSTATE_DEVSPECIFIC            | \
    LINEDEVSTATE_REINIT                 | \
    LINEDEVSTATE_LOCK)

#define AllLineStates1_4                  \
    (AllLineStates1_0                   | \
    LINEDEVSTATE_CAPSCHANGE             | \
    LINEDEVSTATE_CONFIGCHANGE           | \
    LINEDEVSTATE_TRANSLATECHANGE        | \
    LINEDEVSTATE_COMPLCANCEL            | \
    LINEDEVSTATE_REMOVED)

#define AllMediaModes1_0                  \
    (LINEMEDIAMODE_UNKNOWN              | \
    LINEMEDIAMODE_INTERACTIVEVOICE      | \
    LINEMEDIAMODE_AUTOMATEDVOICE        | \
    LINEMEDIAMODE_DIGITALDATA           | \
    LINEMEDIAMODE_G3FAX                 | \
    LINEMEDIAMODE_G4FAX                 | \
    LINEMEDIAMODE_DATAMODEM             | \
    LINEMEDIAMODE_TELETEX               | \
    LINEMEDIAMODE_VIDEOTEX              | \
    LINEMEDIAMODE_TELEX                 | \
    LINEMEDIAMODE_MIXED                 | \
    LINEMEDIAMODE_TDD                   | \
    LINEMEDIAMODE_ADSI)

#define AllMediaModes1_4                  \
    (AllMediaModes1_0                   | \
    LINEMEDIAMODE_VOICEVIEW)

#define AllMediaModes2_1                  \
    (AllMediaModes1_4                   | \
    LINEMEDIAMODE_VIDEO)

#define AllProxyStatus                    \
    (LINEPROXYSTATUS_OPEN               | \
    LINEPROXYSTATUS_CLOSE)

#define AllRequiredACDProxyRequests3_0                    \
     ((1<<LINEPROXYREQUEST_GETAGENTCAPS)                | \
     (1<<LINEPROXYREQUEST_CREATEAGENT)                  | \
     (1<<LINEPROXYREQUEST_SETAGENTMEASUREMENTPERIOD)    | \
     (1<<LINEPROXYREQUEST_GETAGENTINFO)                 | \
     (1<<LINEPROXYREQUEST_CREATEAGENTSESSION)           | \
     (1<<LINEPROXYREQUEST_GETAGENTSESSIONLIST)          | \
     (1<<LINEPROXYREQUEST_SETAGENTSESSIONSTATE)         | \
     (1<<LINEPROXYREQUEST_GETAGENTSESSIONINFO)          | \
     (1<<LINEPROXYREQUEST_GETQUEUELIST)                 | \
     (1<<LINEPROXYREQUEST_SETQUEUEMEASUREMENTPERIOD)    | \
     (1<<LINEPROXYREQUEST_GETQUEUEINFO)                 | \
     (1<<LINEPROXYREQUEST_GETGROUPLIST)                 | \
     (1<<LINEPROXYREQUEST_SETAGENTSTATEEX))          

#define AllQueueStatus                    \
    (LINEQUEUESTATUS_UPDATEINFO         | \
    LINEQUEUESTATUS_NEWQUEUE            | \
    LINEQUEUESTATUS_QUEUEREMOVED)

#define AllTerminalModes                  \
    (LINETERMMODE_BUTTONS               | \
    LINETERMMODE_LAMPS                  | \
    LINETERMMODE_DISPLAY                | \
    LINETERMMODE_RINGER                 | \
    LINETERMMODE_HOOKSWITCH             | \
    LINETERMMODE_MEDIATOLINE            | \
    LINETERMMODE_MEDIAFROMLINE          | \
    LINETERMMODE_MEDIABIDIRECT)


LONG
PASCAL
LineProlog(
    PTCLIENT    ptClient,
    DWORD       dwArgType,
    DWORD       dwArg,
    LPVOID      phdXxx,
    DWORD       dwPrivilege,
    HANDLE     *phMutex,
    BOOL       *pbCloseMutex,
    DWORD       dwTSPIFuncIndex,
    TSPIPROC   *ppfnTSPI_lineXxx,
    PASYNCREQUESTINFO  *ppAsyncRequestInfo,
    DWORD       dwRemoteRequestID,
    DWORD      *pObjectToDereference,
    LPVOID     *pContext
#if DBG
    ,char      *pszFuncName
#endif
    );

void
PASCAL
LineEpilogSync(
    LONG   *plResult,
    HANDLE  hMutex,
    BOOL    bCloseMutex,
    DWORD   ObjectToDereference
#if DBG
    ,char *pszFuncName
#endif
    );



PTLINEAPP
PASCAL
IsValidLineApp(
    HLINEAPP    hLineApp,
    PTCLIENT    ptClient
    );



typedef struct _LINEACCEPT_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwUserUserInfoOffset;       // valid offset or
    };

    union
    {
        IN  DWORD       dwSize;
    };

} LINEACCEPT_PARAMS, *PLINEACCEPT_PARAMS;


typedef struct _LINEADDTOCONFERENCE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hConfCall;
    };

    union
    {
        IN  HCALL       hConsultCall;
    };


} LINEADDTOCONFERENCE_PARAMS, *PLINEADDTOCONFERENCE_PARAMS;


typedef struct _LINEAGENTSPECIFIC_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    // IN  DWORD       hfnPostProcessProc;
    IN  DWORD          hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwAgentExtensionIDIndex;
    };

    // IN  ULONG_PTR       lpParams;                   // pointer to client buffer
    IN  DWORD           hpParams;

    union
    {
        IN  DWORD       dwParamsOffset;             // valid offset or
    };

    union
    {
        IN  DWORD       dwParamsSize;
    };

} LINEAGENTSPECIFIC_PARAMS, *PLINEAGENTSPECIFIC_PARAMS;


typedef struct _LINEANSWER_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwUserUserInfoOffset;       // valid offset or
    };

    union
    {
        IN  DWORD       dwUserUserInfoSize;
    };

} LINEANSWER_PARAMS, *PLINEANSWER_PARAMS;


typedef struct _LINEBLINDTRANSFER_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwDestAddressOffset;        // always valid offset
    };

    union
    {
        IN  DWORD       dwCountryCode;
    };

} LINEBLINDTRANSFER_PARAMS, *PLINEBLINDTRANSFER_PARAMS;


typedef struct _LINECLOSE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD			    dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    OUT DWORD           dwCallbackInstance;

} LINECLOSE_PARAMS, *PLINECLOSE_PARAMS;


typedef struct _LINECLOSEMSPINSTANCE_PARAMS
{
    union
    {
        OUT LONG            lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE           hLine;
    };
    
} LINECLOSEMSPINSTANCE_PARAMS, *PLINECLOSEMSPINSTANCE_PARAMS;


typedef struct _LINECOMPLETECALL_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD           hfnPostProcessProc;

    union
    {
        IN  HCALL       hCall;
    };

    IN  DWORD           hpdwCompletionID;

    union
    {
        IN  DWORD       dwCompletionMode;
    };

    union
    {
        IN  DWORD       dwMessageID;
    };

} LINECOMPLETECALL_PARAMS, *PLINECOMPLETECALL_PARAMS;


typedef struct _LINECOMPLETETRANSFER_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD           hfnPostProcessProc;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  HCALL       hConsultCall;
    };

    IN  DWORD           hpConfCallHandle;                // pointer to client buffer

    union
    {
        IN  DWORD       dwTransferMode;
    };

} LINECOMPLETETRANSFER_PARAMS, *PLINECOMPLETETRANSFER_PARAMS;


typedef struct _LINECONDITIONALMEDIADETECTION_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwMediaModes;
    };

    union
    {
        IN  DWORD       dwCallParamsOffset;
    };

    union
    {
        IN  DWORD       dwAsciiCallParamsCodePage;
    };

} LINECONDITIONALMEDIADETECTION_PARAMS, *PLINECONDITIONALMEDIADETECTION_PARAMS;


typedef struct _LINECONFIGPROVIDER_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD dwwndOwner;
    };

    union
    {
        IN  DWORD       dwPermanentProviderID;
    };

} LINECONFIGPROVIDER_PARAMS, *PLINECONFIGPROVIDER_PARAMS;


typedef struct _LINECREATEAGENT_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    // IN  DWORD       hfnPostProcessProc;
    IN  DWORD           hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAgentIDOffset;            // valid offset or
    };
                                                    //   TAPI_NO_DATA
    union
    {
        IN  DWORD       dwAgentPINOffset;           // valid offset or
                                                    //   TAPI_NO_DATA
    };

    // IN  ULONG_PTR       lphAgent;                   // pointer to client buffer
    IN  DWORD           hpAgent;                   // pointer to client buffer

} LINECREATEAGENT_PARAMS, * PLINECREATEAGENT_PARAMS;


typedef struct _LINECREATEAGENTSESSION_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    // IN  DWORD       hfnPostProcessProc;
    IN  DWORD          hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  HAGENT      hAgent;
    };

    union
    {
        IN  DWORD       dwAgentPINOffset;           // valid offset or
                                                    //   TAPI_NO_DATA
    };

    union
    {
        IN  DWORD       dwWorkingAddressID;
    };

    union
    {
        IN  DWORD       dwGroupIDOffset;
    };

    union
    {
        IN  DWORD       dwGroupIDSize;
    };

    IN  DWORD           hpAgentSessionHandle;            // pointer to client buffer

} LINECREATEAGENTSESSION_PARAMS, *PLINECREATEAGENTSESSION_PARAMS;

typedef struct _LINECREATEMSPINSTANCE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };
    
} LINECREATEMSPINSTANCE_PARAMS, *PLINECREATEMSPINSTANCE_PARAMS;

typedef struct _LINEDEALLOCATECALL_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

} LINEDEALLOCATECALL_PARAMS, *PLINEDEALLOCATECALL_PARAMS;


typedef struct _LINEDEVSPECIFIC_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    // IN  DWORD       hfnPostProcessProc;
    IN  DWORD           hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    IN  DWORD          hpParams;                   // pointer to client buffer

    union
    {
        IN  DWORD       dwParamsOffset;             // valid offset or
    };

    union
    {
        IN  DWORD       dwParamsSize;
    };

} LINEDEVSPECIFIC_PARAMS, *PLINEDEVSPECIFIC_PARAMS;


typedef struct _LINEDEVSPECIFICEX_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    // IN  DWORD       hfnPostProcessProc;
    IN  DWORD          hfnPostProcessProc;

    union
    {
        IN  DWORD       dwProviderID;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  HCALLHUB    hCallHub;
    };

    union
    {
        IN  DWORD       dwSelect;
    };

    IN  DWORD           hpParams;                   // pointer to client buffer

    union
    {
        IN  DWORD       dwParamsOffset;             // valid offset or
                                                    //    TAPI_NO_DATA
    };

    union
    {
        IN  DWORD       dwParamsSize;
    };

} LINEDEVSPECIFICEX_PARAMS, *PLINEDEVSPECIFICEX_PARAMS;


typedef struct _LINEDEVSPECIFICFEATURE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    // IN  DWORD       hfnPostProcessProc;
    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  DWORD       hLine;
    };

    union
    {
        IN  DWORD       dwFeature;
    };

    IN  DWORD           hpParams;                   // pointer to client buffer

    union
    {
        IN  DWORD       dwParamsOffset;             // valid offset or
                                                    //   TAPI_NO_DATA
    };

    union
    {
        IN  DWORD       dwParamsSize;
    };

} LINEDEVSPECIFICFEATURE_PARAMS, *PLINEDEVSPECIFICFEATURE_PARAMS;


typedef struct _LINEDIAL_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwDestAddressOffset;        // always valid offset
    };

    union
    {
        IN  DWORD       dwCountryCode;
    };

} LINEDIAL_PARAMS, *PLINEDIAL_PARAMS;


typedef struct _LINEDROP_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwUserUserInfoOffset;       // valid offset or
    };

    union
    {
        IN  DWORD       dwSize;
    };

} LINEDROP_PARAMS, *PLINEDROP_PARAMS;


typedef struct _LINEFORWARD_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  DWORD       hLine;
    };

    union
    {
        IN  DWORD       bAllAddresses;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwForwardListOffset;        // always valid offset
    };

    union
    {
        IN  DWORD       dwNumRingsNoAnswer;
    };

    IN  DWORD           hpConsultCall;             // pointer to client buffer

    union
    {
        IN  DWORD       dwCallParamsOffset;         // valid offset or
                                                    //   TAPI_NO_DATA
    };

    union
    {
        IN  DWORD       dwAsciiCallParamsCodePage;
    };

} LINEFORWARD_PARAMS, *PLINEFORWARD_PARAMS;


typedef struct _LINEGATHERDIGITS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HCALL       hCall;
    };

#if NEWTAPI32
    union
    {
        IN  DWORD       dwEndToEndID;
    };
#endif

    union
    {
        IN  DWORD       dwDigitModes;
    };

    // IN  ULONG_PTR       lpsDigits;                  // pointer to client buffer
    IN  DWORD           hpsDigits;                  // pointer to client buffer

    union
    {
        IN  DWORD       dwNumDigits;
    };

    union
    {
        IN  DWORD       dwTerminationDigitsOffset;  // valid offset or
                                                    //   TAPI_NO_DATA
    };

    union
    {
        IN  DWORD       dwFirstDigitTimeout;
    };

    union
    {
        IN  DWORD       dwInterDigitTimeout;
    };

} LINEGATHERDIGITS_PARAMS, *PLINEGATHERDIGITS_PARAMS;


typedef struct _LINEGENERATEDIGITS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       hCall;
    };

    union
    {
        IN  DWORD       dwDigitMode;
    };

    union
    {
        IN  DWORD       dwDigitsOffset;             // always valid offset
    };

    union
    {
        IN  DWORD       dwDuration;
    };

    union
    {
        IN  DWORD       dwEndToEndID;               // Used for remotesp only
    };

} LINEGENERATEDIGITS_PARAMS, *PLINEGENERATEDIGITS_PARAMS;


typedef struct _LINEGENERATETONE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwToneMode;
    };

    union
    {
        IN  DWORD       dwDuration;
    };

    union
    {
        IN  DWORD       dwNumTones;
    };

    union
    {
        IN  DWORD       dwTonesOffset;              // valid offset or

    };

    IN  DWORD           _Unused_;                   // placeholdr for following
                                                    //   Size arg on clnt side

    union
    {
        IN  DWORD       dwEndToEndID;               // Used for remotesp only
    };

} LINEGENERATETONE_PARAMS, *PLINEGENERATETONE_PARAMS;


typedef struct _LINEGETADDRESSCAPS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwExtVersion;
    };

    union
    {
        IN  DWORD       dwAddressCapsTotalSize;     // size of client buffer
        OUT DWORD       dwAddressCapsOffset;        // valid offset on success
    };

} LINEGETADDRESSCAPS_PARAMS, *PLINEGETADDRESSCAPS_PARAMS;


typedef struct _LINEGETADDRESSID_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        OUT DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwAddressMode;
    };

    union
    {
        IN  DWORD       dwAddressOffset;            // always valid offset
    };

    union
    {
        IN  DWORD       dwSize;
    };

} LINEGETADDRESSID_PARAMS, *PLINEGETADDRESSID_PARAMS;


typedef struct _LINEGETADDRESSSTATUS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        OUT DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwAddressStatusTotalSize;   // size of client buffer
        OUT DWORD       dwAddressStatusOffset;      // valid offset on success
    };

} LINEGETADDRESSSTATUS_PARAMS, *PLINEGETADDRESSSTATUS_PARAMS;


typedef struct _LINEGETAGENTACTIVITYLIST_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    // IN  ULONG_PTR       lpAgentActivityList;        // pointer to client buffer
    IN  DWORD           hpAgentActivityList;        // pointer to client buffer

    union
    {
        IN  DWORD       dwActivityListTotalSize;
    };

} LINEGETAGENTACTIVITYLIST_PARAMS, *PLINEGETAGENTACTIVITYLIST_PARAMS;


typedef struct _LINEGETAGENTCAPS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwAppAPIVersion;
    };

    // IN  ULONG_PTR       lpAgentCaps;                // pointer to client buffer
    IN  DWORD           hpAgentCaps;                // pointer to client buffer

    union
    {
        IN  DWORD       dwAgentCapsTotalSize;

    };

} LINEGETAGENTCAPS_PARAMS, *PLINEGETAGENTCAPS_PARAMS;


typedef struct _LINEGETAGENTGROUPLIST_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    // IN  ULONG_PTR       lpAgentGroupList;           // pointer to client buffer
    IN  DWORD           hpAgentGroupList;           // pointer to client buffer

    union
    {
        IN  DWORD       dwAgentGroupListTotalSize;
    };

} LINEGETAGENTGROUPLIST_PARAMS, *PLINEGETAGENTGROUPLIST_PARAMS;


typedef struct _LINEGETAGENTINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  HAGENT      hAgent;
    };

    // IN  ULONG_PTR       lpAgentInfo;                // pointer to client buffer
    IN  DWORD           hpAgentInfo;                // pointer to client buffer

    union
    {
        IN  DWORD       dwAgentInfoTotalSize;
    };

} LINEGETAGENTINFO_PARAMS, *PLINEGETAGENTINFO_PARAMS;


typedef struct _LINEGETAGENTSESSIONINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;
    
    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  HAGENTSESSION   hAgentSession;
    };

    // IN  ULONG_PTR       lpAgentSessionInfo;         // pointer to client buffer
    IN  DWORD               hpAgentSessionInfo;         // pointer to client buffer

    union
    {
        IN  DWORD       dwAgentSessionInfoTotalSize;
    };

} LINEGETAGENTSESSIONINFO_PARAMS, *PLINEGETAGENTSESSIONINFO_PARAMS;


typedef struct _LINEGETAGENTSESSIONLIST_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  HAGENT      hAgent;
    };

    // IN  ULONG_PTR       lpSessionList;              // pointer to client buffer
    IN  DWORD          hpSessionList;              // pointer to client buffer

    union
    {
        IN  DWORD       dwSessionListTotalSize;
    };

} LINEGETAGENTSESSIONLIST_PARAMS, *PLINEGETAGENTSESSIONLIST_PARAMS;


typedef struct _LINEGETAGENTSTATUS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    // IN  ULONG_PTR       lpAgentStatus;              // pointer to client buffer
    IN  DWORD           hpAgentStatus;              // pointer to client buffer

    union
    {
        IN  DWORD       dwAgentStatusTotalSize;
    };

} LINEGETAGENTSTATUS_PARAMS, *PLINEGETAGENTSTATUS_PARAMS;


typedef struct _LINEGETAPPPRIORITY_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwAppNameOffset;            // always valid offset
    };

    union
    {
        IN  DWORD       dwMediaMode;
    };

    union
    {
        IN  DWORD       dwExtensionIDOffset;        // valid offset or

    };

    //IN  ULONG_PTR       _Unused_;                   // padding for Size type on
    IN  DWORD           _Unused_;                   // padding for Size type on
                                                    //   client side
    union
    {
        IN  DWORD       dwRequestMode;
    };

    union
    {
        IN  DWORD       dwExtensionNameTotalSize;   // size of client buf or
                                                    //   TAPI_NO_DATA
        OUT DWORD       dwExtensionNameOffset;      // valid offset or
                                                    //   TAPI_NO_DATA on succes
    };

    union
    {
        OUT DWORD       dwPriority;
    };

} LINEGETAPPPRIORITY_PARAMS, *PLINEGETAPPPRIORITY_PARAMS;


typedef struct _LINEGETCALLADDRESSID_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        OUT DWORD       dwAddressID;
    };

} LINEGETCALLADDRESSID_PARAMS, *PLINEGETCALLADDRESSID_PARAMS;


typedef struct _LINEGETCALLHUBTRACKING_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwTrackingInfoTotalSize;    // size of client buffer
        OUT DWORD       dwTrackingInfoOffset;       // valid offset on success
    };

} LINEGETCALLHUBTRACKING_PARAMS, *PLINEGETCALLHUBTRACKING_PARAMS;


typedef struct _LINEGETCALLIDS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        OUT DWORD       dwAddressID;
    };

    union
    {
        OUT DWORD       dwCallID;
    };

    union
    {
        OUT DWORD       dwRelatedCallID;
    };

} LINEGETCALLIDS_PARAMS, *PLINEGETCALLIDS_PARAMS;


typedef struct _LINEGETCALLINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwCallInfoTotalSize;        // size of client buffer
        OUT DWORD       dwCallInfoOffset;           // valid offset on success
    };

} LINEGETCALLINFO_PARAMS, *PLINEGETCALLINFO_PARAMS;


typedef struct _LINEGETCALLSTATUS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwCallStatusTotalSize;      // size of client buffer
        OUT DWORD       dwCallStatusOffset;         // valid offset on success
    };

} LINEGETCALLSTATUS_PARAMS, *PLINEGETCALLSTATUS_PARAMS;


typedef struct _LINEGETCONFRELATEDCALLS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwCallListTotalSize;        // size of client buffer
        OUT DWORD       dwCallListOffset;           // valid offset on success
    };

} LINEGETCONFRELATEDCALLS_PARAMS, *PLINEGETCONFRELATEDCALLS_PARAMS;


typedef struct _LINEGETCOUNTRY_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwCountryID;
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwDestCountryID;
    };

    union
    {
        IN  DWORD       dwCountryListTotalSize;     // size of client buffer
        OUT DWORD       dwCountryListOffset;        // valid offset on success
    };

} LINEGETCOUNTRY_PARAMS, *PLINEGETCOUNTRY_PARAMS;


typedef struct _LINEGETCOUNTRYGROUP_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN DWORD       dwCountryIdOffset;
    };

    union
    {
        IN OUT DWORD    dwCountryIdSize;
    };

    union
    {
        OUT DWORD       dwCountryGroupOffset;
    };

    union
    {
        IN OUT DWORD    dwCountryGroupSize;
    };

} LINEGETCOUNTRYGROUP_PARAMS, *PLINEGETCOUNTRYGROUP_PARAMS;

typedef struct _LINEGETDEVCAPS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwExtVersion;
    };

    union
    {
        IN  DWORD       dwDevCapsTotalSize;         // size of client buffer
        OUT DWORD       dwDevCapsOffset;            // valid offset on success
    };

} LINEGETDEVCAPS_PARAMS, *PLINEGETDEVCAPS_PARAMS;


typedef struct _LINEGETDEVCONFIG_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwDeviceConfigTotalSize;    // size of client buffer
        OUT DWORD       dwDeviceConfigOffset;       // valid offset on success
    };

    union
    {
        IN  DWORD       dwDeviceClassOffset;        // always valid offset
    };

} LINEGETDEVCONFIG_PARAMS, *PLINEGETDEVCONFIG_PARAMS;


typedef struct _LINEGETGROUPLIST_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    // IN  ULONG_PTR       lpGroupList;                // pointer to client buffer
    IN  DWORD           hpGroupList;                   // pointer to client buffer

    union
    {
        IN  DWORD       dwGroupListTotalSize;
    };

} LINEGETGROUPLIST_PARAMS, *PLINEGETGROUPLIST_PARAMS;


typedef struct _LINEGETHUBRELATEDCALLS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALLHUB    hCallHub;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwCallListTotalSize;        // size of client buffer
        OUT DWORD       dwCallListOffset;           // valid offset on success
    };

} LINEGETHUBRELATEDCALLS_PARAMS, *PLINEGETHUBRELATEDCALLS_PARAMS;


typedef struct _LINEGETICON_PARAMS
{
    OUT LONG        lResult;

    DWORD			dwUnused;

    IN  DWORD       dwDeviceID;

    IN  DWORD       dwDeviceClassOffset;        // valid offset or

    OUT HICON       hIcon;

} LINEGETICON_PARAMS, *PLINEGETICON_PARAMS;


typedef struct _LINEGETID_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       hCall;
    };

    union
    {
        IN  DWORD       dwSelect;
    };

    union
    {
        IN  DWORD       dwDeviceIDTotalSize;        // size of client buffer
        OUT DWORD       dwDeviceIDOffset;           // valid offset on success
    };

    union
    {
        IN  DWORD       dwDeviceClassOffset;        // always valid offset
    };

} LINEGETID_PARAMS, *PLINEGETID_PARAMS;


typedef struct _LINEGETLINEDEVSTATUS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwLineDevStatusTotalSize;   // size of client buffer
        OUT DWORD       dwLineDevStatusOffset;      // valid offset on success
    };

    union
    {
        OUT DWORD       dwAPIVersion;
    };

} LINEGETLINEDEVSTATUS_PARAMS, *PLINEGETLINEDEVSTATUS_PARAMS;


typedef struct _LINEGETPROXYSTATUS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAppAPIVersion;
    };

    union
    {
        IN  DWORD       dwProxyStatusTotalSize;     // size of client buffer
        OUT DWORD       dwProxyStatusOffset;        // valid offset on success
    };

    union
    {
        OUT DWORD       dwAPIVersion;
    };

} LINEGETPROXYSTATUS_PARAMS, *PLINEGETPROXYSTATUS_PARAMS;


typedef struct _LINEGETNEWCALLS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwSelect;
    };

    union
    {
        IN  DWORD       dwCallListTotalSize;        // size of client buffer
        OUT DWORD       dwCallListOffset;           // valid offset on success
    };

} LINEGETNEWCALLS_PARAMS, *PLINEGETNEWCALLS_PARAMS;


typedef struct _LINEGETNUMADDRESSIDS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        OUT DWORD       dwNumAddresses;
    };

} LINEGETNUMADDRESSIDS_PARAMS, *PLINEGETNUMADDRESSIDS_PARAMS;


typedef struct _LINEGETNUMRINGS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        OUT DWORD       dwNumRings;
    };

} LINEGETNUMRINGS_PARAMS, *PLINEGETNUMRINGS_PARAMS;


typedef struct _LINEGETPROVIDERLIST_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwProviderListTotalSize;    // size of client buf
        OUT DWORD       dwProviderListOffset;       // valid offset on success
    };

} LINEGETPROVIDERLIST_PARAMS, *PLINEGETPROVIDERLIST_PARAMS;


typedef struct _LINEGETQUEUEINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwQueueID;
    };

    // IN  ULONG_PTR       lpQueueInfo;                // pointer to client buffer
    IN  DWORD           phQueueInfo;                // pointer to client buffer

    union
    {
        IN  DWORD       dwQueueInfoTotalSize;
    };

} LINEGETQUEUEINFO_PARAMS, *PLINEGETQUEUEINFO_PARAMS;


typedef struct _LINEGETQUEUELIST_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwGroupIDOffset;
    };

    union
    {
        IN  DWORD       dwGroupIDSize;
    };

    //IN  ULONG_PTR       lpQueueList;                // pointer to client buffer
    IN  DWORD           hpQueueList;                // pointer to client buffer

    union
    {
        IN  DWORD       dwQueueListTotalSize;
    };

} LINEGETQUEUELIST_PARAMS, *PLINEGETQUEUELIST_PARAMS;


typedef struct _LINEGETREQUEST_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwRequestMode;
    };

    union
    {
        OUT DWORD       dwRequestBufferOffset;      // valid offset on success
    };

    union
    {
        IN OUT DWORD    dwSize;
    };

} LINEGETREQUEST_PARAMS, *PLINEGETREQUEST_PARAMS;


typedef struct _LINEGETSTATUSMESSAGES_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        OUT DWORD       dwLineStates;
    };

    union
    {
        OUT DWORD       dwAddressStates;
    };

} LINEGETSTATUSMESSAGES_PARAMS, *PLINEGETSTATUSMESSAGES_PARAMS;


typedef struct _LINEHANDOFF_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwFileNameOffset;           // valid offset or
    };

    union
    {
        IN  DWORD       dwMediaMode;
    };

} LINEHANDOFF_PARAMS, *PLINEHANDOFF_PARAMS;


typedef struct _LINEHOLD_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

} LINEHOLD_PARAMS, *PLINEHOLD_PARAMS;


typedef struct _LINEINITIALIZE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        OUT HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       hInstance;
    };

    union
    {
        IN  DWORD       InitContext;
    };

    union
    {
        IN  DWORD       dwFriendlyNameOffset;       // always valid offset
    };

    union
    {
        OUT DWORD       dwNumDevs;
    };

    union
    {
        IN  DWORD       dwModuleNameOffset;         // always valid offset
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

} LINEINITIALIZE_PARAMS, *PLINEINITIALIZE_PARAMS;


typedef struct _LINEMAKECALL_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD           hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    IN  DWORD           hpCall;

    union
    {
        IN  DWORD       dwDestAddressOffset;        // valid offset or
    };

    union
    {
        IN  DWORD       dwCountryCode;
    };

    union
    {
        IN  DWORD       dwCallParamsOffset;         // valid offset or
    };

    union
    {
        IN  DWORD       dwAsciiCallParamsCodePage;
    };

} LINEMAKECALL_PARAMS, *PLINEMAKECALL_PARAMS;


typedef struct _LINEMONITORDIGITS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwDigitModes;
    };

} LINEMONITORDIGITS_PARAMS, *PLINEMONITORDIGITS_PARAMS;


typedef struct _LINEMONITORMEDIA_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwMediaModes;
    };

} LINEMONITORMEDIA_PARAMS, *PLINEMONITORMEDIA_PARAMS;


typedef struct _LINEMONITORTONES_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwTonesOffset;              // valid offset or
    };

    union
    {
        IN  DWORD       dwNumEntries;               // really dwNumEntries *
    };

    union
    {
        IN  DWORD       dwToneListID;               // Used for remotesp only
    };

} LINEMONITORTONES_PARAMS, *PLINEMONITORTONES_PARAMS;


typedef struct _LINENEGOTIATEAPIVERSION_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAPILowVersion;
    };

    union
    {
        IN  DWORD       dwAPIHighVersion;
    };

    union
    {
        OUT DWORD       dwAPIVersion;
    };

    union
    {
        OUT DWORD       dwExtensionIDOffset;        // valid offset on success
    };

    union
    {
        IN OUT DWORD    dwSize;
    };

} LINENEGOTIATEAPIVERSION_PARAMS, *PLINENEGOTIATEAPIVERSION_PARAMS;


typedef struct _NEGOTIATEAPIVERSIONFORALLDEVICES_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwNumLineDevices;
    };

    union
    {
        IN  DWORD       dwNumPhoneDevices;
    };

    union
    {
        IN  DWORD       dwAPIHighVersion;
    };

    union
    {
        OUT DWORD       dwLineAPIVersionListOffset; // valid offset on success
    };

    union
    {
        IN OUT DWORD    dwLineAPIVersionListSize;
    };

    union
    {
        OUT DWORD       dwLineExtensionIDListOffset;// valid offset on success
    };

    union
    {
        IN OUT DWORD    dwLineExtensionIDListSize;
    };

    union
    {
        OUT DWORD       dwPhoneAPIVersionListOffset;// valid offset on success
    };

    union
    {
        IN OUT DWORD    dwPhoneAPIVersionListSize;
    };

    union
    {
        OUT DWORD       dwPhoneExtensionIDListOffset;// valid offset on success
    };

    union
    {
        IN OUT DWORD    dwPhoneExtensionIDListSize;
    };

} NEGOTIATEAPIVERSIONFORALLDEVICES_PARAMS,
    *PNEGOTIATEAPIVERSIONFORALLDEVICES_PARAMS;


typedef struct _LINENEGOTIATEEXTVERSION_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwExtLowVersion;
    };

    union
    {
        IN  DWORD       dwExtHighVersion;
    };

    union
    {
        OUT DWORD       dwExtVersion;
    };

} LINENEGOTIATEEXTVERSION_PARAMS, *PLINENEGOTIATEEXTVERSION_PARAMS;


typedef struct _LINEOPEN_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        OUT DWORD       hLine;
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwExtVersion;
    };

    IN  DWORD       OpenContext;

    union
    {
        IN  DWORD       dwPrivileges;
    };

    union
    {
        IN  DWORD       dwMediaModes;
    };

    union
    {
        IN  DWORD       dwCallParamsOffset;         // valid offset or
    };

    union
    {
        IN  DWORD       dwAsciiCallParamsCodePage;
    };

    union
    {
        IN  DWORD       dwCallParamsReturnTotalSize;// size of client buffer
        OUT DWORD       dwCallParamsReturnOffset;   // valid offset on success
    };

    //
    // The following is a "remote line handle".  When the client is
    // remotesp.tsp running on a remote machine, this will be some
    // non-NULL value, and tapisrv should use this handle in status/etc
    // indications to the client rather than the std hLine. If the
    // client is not remote.tsp then this value will be NULL.
    //

    union
    {
        IN  HLINE       hRemoteLine;
    };

} LINEOPEN_PARAMS, *PLINEOPEN_PARAMS;


typedef struct _LINEPARK_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwParkMode;
    };

    union
    {
        IN  DWORD       dwDirAddressOffset;         // valid offset or
    };
                                                    //   TAPI_NO_DATA
    // IN  ULONG_PTR       lpNonDirAddress;            // pointer to client buffer
    IN  DWORD           hpNonDirAddress;            // pointer to client buffer

    union
    {
        IN  DWORD       dwNonDirAddressTotalSize;   // size of client buffer
                                                    // for sync func would be
                                                    //   dwXxxOffset
    };

} LINEPARK_PARAMS, *PLINEPARK_PARAMS;


typedef struct _LINEPICKUP_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    // IN  ULONG_PTR       lphCall;                    // pointer to client buffer
    IN  DWORD           hpCall;                    // pointer to client buffer

    union
    {
        IN  DWORD       dwDestAddressOffset;        // valid offset or
    };

    union
    {
        IN  DWORD       dwGroupIDOffset;            // always valid offset
    };

} LINEPICKUP_PARAMS, *PLINEPICKUP_PARAMS;


typedef struct _LINEPREPAREADDTOCONFERENCE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HCALL       hConfCall;
    };

    // IN  ULONG_PTR       lphConsultCall;             // pointer to client buffer
    IN  DWORD          hpConsultCall;             // pointer to client buffer

    union
    {
        IN  DWORD       dwCallParamsOffset;         // valid offset or
    };

    union
    {
        IN  DWORD       dwAsciiCallParamsCodePage;
    };

} LINEPREPAREADDTOCONFERENCE_PARAMS, *PLINEPREPAREADDTOCONFERENCE_PARAMS;


typedef struct _LINEPROXYMESSAGE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwMsg;
    };

    union
    {
        IN  DWORD       dwParam1;
    };

    union
    {
        IN  DWORD       dwParam2;
    };

    union
    {
        IN  DWORD       dwParam3;
    };

} LINEPROXYMESSAGE_PARAMS, *PLINEPROXYMESSAGE_PARAMS;


typedef struct _LINEPROXYRESPONSE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwInstance;
    };

    union
    {
        IN  DWORD       dwProxyResponseOffset;      // valid offset or
    };

    union
    {
        IN  DWORD       dwResult;
    };

} LINEPROXYRESPONSE_PARAMS, *PLINEPROXYRESPONSE_PARAMS;


typedef struct _LINEREDIRECT_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwDestAddressOffset;        // always valid offset
    };

    union
    {
        IN  DWORD       dwCountryCode;
    };

} LINEREDIRECT_PARAMS, *PLINEREDIRECT_PARAMS;


typedef struct _LINEREGISTERREQUESTRECIPIENT_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwRegistrationInstance;
    };

    union
    {
        IN  DWORD       dwRequestMode;
    };

    union
    {
        IN  DWORD       bEnable;
    };

} LINEREGISTERREQUESTRECIPIENT_PARAMS, *PLINEREGISTERREQUESTRECIPIENT_PARAMS;


typedef struct _LINERELEASEUSERUSERINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

} LINERELEASEUSERUSERINFO_PARAMS, *PLINERELEASEUSERUSERINFO_PARAMS;


typedef struct _LINEREMOVEFROMCONFERENCE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

} LINEREMOVEFROMCONFERENCE_PARAMS, *PLINEREMOVEFROMCONFERENCE_PARAMS;


typedef struct _LINESECURECALL_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

} LINESECURECALL_PARAMS, *PLINESECURECALL_PARAMS;


typedef struct _LINESELECTEXTVERSION_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwExtVersion;
    };

} LINESELECTEXTVERSION_PARAMS, *PLINESELECTEXTVERSION_PARAMS;


typedef struct _LINESENDUSERUSERINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwUserUserInfoOffset;       // valid offset or
    };

    union
    {
        IN  DWORD       dwSize;
    };

} LINESENDUSERUSERINFO_PARAMS, *PLINESENDUSERUSERINFO_PARAMS;


typedef struct _LINESETAGENTACTIVITY_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwActivityID;
    };

} LINESETAGENTACTIVITY_PARAMS, *PLINESETAGENTACTIVITY_PARAMS;


typedef struct _LINESETAGENTGROUP_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwAgentGroupListOffset;
    };

} LINESETAGENTGROUP_PARAMS, *PLINESETAGENTGROUP_PARAMS;


typedef struct _LINESETAGENTMEASUREMENTPERIOD_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  HAGENT      hAgent;
    };

    union
    {
        IN  DWORD       dwMeasurementPeriod;
    };

} LINESETAGENTMEASUREMENTPERIOD_PARAMS, *PLINESETAGENTMEASUREMENTPERIOD_PARAMS;


typedef struct _LINESETAGENTSESSIONSTATE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  HAGENTSESSION   hAgentSession;
    };

    union
    {
        IN  DWORD       dwAgentState;
    };

    union
    {
        IN  DWORD       dwNextAgentState;
    };

} LINESETAGENTSESSIONSTATE_PARAMS, *PLINESETAGENTSESSIONSTATE_PARAMS;


typedef struct _LINESETAGENTSTATE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwAgentState;
    };

    union
    {
        IN  DWORD       dwNextAgentState;
    };

} LINESETAGENTSTATE_PARAMS, *PLINESETAGENTSTATE_PARAMS;


typedef struct _LINESETAGENTSTATEEX_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  HAGENT      hAgent;
    };

    union
    {
        IN  DWORD       dwAgentState;
    };

    union
    {
        IN  DWORD       dwNextAgentState;
    };

} LINESETAGENTSTATEEX_PARAMS, *PLINESETAGENTSTATEEX_PARAMS;


typedef struct _LINESETAPPPRIORITY_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwAppNameOffset;            // always valid offset
    };

    union
    {
        IN  DWORD       dwMediaMode;
    };

    union
    {
        IN  DWORD       dwExtensionIDOffset;        // valid offset or

    };

    // IN  ULONG_PTR       _Unused_;                   // padding for Size type on
    IN  DWORD           _Unused_;                   // padding for Size type on
                                                    //   client side
    union
    {
        IN  DWORD       dwRequestMode;
    };

    union
    {
        IN  DWORD       dwExtensionNameOffset;      // valid offset or
    };

    union
    {
        IN  DWORD       dwPriority;
    };

} LINESETAPPPRIORITY_PARAMS, *PLINESETAPPPRIORITY_PARAMS;


typedef struct _LINESETAPPSPECIFIC_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwAppSpecific;
    };

} LINESETAPPSPECIFIC_PARAMS, *PLINESETAPPSPECIFIC_PARAMS;


typedef struct _LINESETCALLDATA_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwCallDataOffset;           // valid offset or
    };

    union
    {
        IN  DWORD       dwCallDataSize;
    };

} LINESETCALLDATA_PARAMS, *PLINESETCALLDATA_PARAMS;


typedef struct _LINESETCALLHUBTRACKING_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwTrackingInfoOffset;       // always valid offset
    };

} LINESETCALLHUBTRACKING_PARAMS, *PLINESETCALLHUBTRACKING_PARAMS;


typedef struct _LINESETCALLPARAMS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwBearerMode;
    };

    union
    {
        IN  DWORD       dwMinRate;
    };

    union
    {
        IN  DWORD       dwMaxRate;
    };

    union
    {
        IN  DWORD       dwDialParamsOffset;         // valid offset or
    };

    // IN  ULONG_PTR       _Unused_;                   // placeholdr for following
    IN  DWORD           _Unused_;                   // placeholdr for following
                                                    //   Size arg on clnt side
} LINESETCALLPARAMS_PARAMS, *PLINESETCALLPARAMS_PARAMS;


typedef struct _LINESETCALLPRIVILEGE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwPrivilege;
    };

} LINESETCALLPRIVILEGE_PARAMS, *PLINESETCALLPRIVILEGE_PARAMS;


typedef struct _LINESETCALLQUALITYOFSERVICE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwSendingFlowspecOffset;    // always valid offset
    };

    union
    {
        IN  DWORD       dwSendingFlowspecSize;
    };

    union
    {
        IN  DWORD       dwReceivingFlowspecOffset;  // always valid offset
    };

    union
    {
        IN  DWORD       dwReceivingFlowspecSize;
    };

} LINESETCALLQUALITYOFSERVICE_PARAMS, *PLINESETCALLQUALITYOFSERVICE_PARAMS;


typedef struct _LINESETCALLTREATMENT_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwTreatment;
    };

} LINESETCALLTREATMENT_PARAMS, *PLINESETCALLTREATMENT_PARAMS;


typedef struct _LINESETDEFAULTMEDIADETECTION_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwMediaModes;
    };

} LINESETDEFAULTMEDIADETECTION_PARAMS, *PLINESETDEFAULTMEDIADETECTION_PARAMS;


typedef struct _LINESETDEVCONFIG_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwDeviceConfigOffset;       // always valid offset
    };

    union
    {
        IN  DWORD       dwSize;
    };

    union
    {
        IN  DWORD       dwDeviceClassOffset;        // always valid offset
    };

} LINESETDEVCONFIG_PARAMS, *PLINESETDEVCONFIG_PARAMS;


typedef struct _LINESETLINEDEVSTATUS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwStatusToChange;
    };

    union
    {
        IN  DWORD       fStatus;
    };

} LINESETLINEDEVSTATUS_PARAMS, *PLINESETLINEDEVSTATUS_PARAMS;


typedef struct _LINESETMEDIACONTROL_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwSelect;
    };

    union
    {
        IN  DWORD       dwDigitListOffset;          // valid offset or
    };

    union
    {
        IN  DWORD       dwDigitListNumEntries;      // actually dwNumEntries *
    };

    union
    {
        IN  DWORD       dwMediaListOffset;          // valid offset or
    };

    union
    {
        IN  DWORD       dwMediaListNumEntries;      // actually dwNumEntries *
    };

    union
    {
        IN  DWORD       dwToneListOffset;           // valid offset or
    };

    union
    {
        IN  DWORD       dwToneListNumEntries;       // actually dwNumEntries *
    };

    union
    {
        IN  DWORD       dwCallStateListOffset;      // valid offset or
    };

    union
    {
        IN  DWORD       dwCallStateListNumEntries;  // actually dwNumEntries *
    };

} LINESETMEDIACONTROL_PARAMS, *PLINESETMEDIACONTROL_PARAMS;


typedef struct _LINESETMEDIAMODE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwMediaModes;
    };

} LINESETMEDIAMODE_PARAMS, *PLINESETMEDIAMODE_PARAMS;


typedef struct _LINESETNUMRINGS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  DWORD       dwNumRings;
    };

} LINESETNUMRINGS_PARAMS, *PLINESETNUMRINGS_PARAMS;


typedef struct _LINESETQUEUEMEASUREMENTPERIOD_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwQueueID;
    };

    union
    {
        IN  DWORD       dwMeasurementPeriod;
    };

} LINESETQUEUEMEASUREMENTPERIOD_PARAMS, *PLINESETQUEUEMEASUREMENTPERIOD_PARAMS;


typedef struct _LINESETSTATUSMESSAGES_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwLineStates;
    };

    union
    {
        IN  DWORD       dwAddressStates;
    };

} LINESETSTATUSMESSAGES_PARAMS, *PLINESETSTATUSMESSAGES_PARAMS;


typedef struct _LINESETTERMINAL_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  DWORD       dwSelect;
    };

    union
    {
        IN  DWORD       dwTerminalModes;
    };

    union
    {
        IN  DWORD       dwTerminalID;
    };

    union
    {
        IN  DWORD       bEnable;
    };

} LINESETTERMINAL_PARAMS, *PLINESETTERMINAL_PARAMS;


typedef struct _LINESETUPCONFERENCE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HCALL       hCall;
    };

    union
    {
        IN  HLINE       hLine;
    };

    // IN  ULONG_PTR       lphConfCall;                // pointer to client buffer
    IN  DWORD           hpConfCall;                // pointer to client buffer

    // IN  ULONG_PTR       lphConsultCall;             // pointer to client buffer
    IN  DWORD           hpConsultCall;             // pointer to client buffer

    union
    {
        IN  DWORD       dwNumParties;
    };

    union
    {
        IN  DWORD       dwCallParamsOffset;         // valid offset or
    };

    union
    {
        IN  DWORD       dwAsciiCallParamsCodePage;
    };

} LINESETUPCONFERENCE_PARAMS, *PLINESETUPCONFERENCE_PARAMS;


typedef struct _LINESETUPTRANSFER_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HCALL       hCall;
    };

    // IN  ULONG_PTR       lphConsultCall;             // pointer to client buffer
    IN  DWORD           hpConsultCall;             // pointer to client buffer

    union
    {
        IN  DWORD       dwCallParamsOffset;         // valid offset or
    };

    union
    {
        IN  DWORD       dwAsciiCallParamsCodePage;
    };

} LINESETUPTRANSFER_PARAMS, *PLINESETUPTRANSFER_PARAMS;


typedef struct _LINESHUTDOWN_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    hLineApp;
    };

} LINESHUTDOWN_PARAMS, *PLINESHUTDOWN_PARAMS;


typedef struct _LINESWAPHOLD_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hActiveCall;
    };

    union
    {
        IN  HCALL       hHeldCall;
    };

} LINESWAPHOLD_PARAMS, *PLINESWAPHOLD_PARAMS;


typedef struct _LINEUNCOMPLETECALL_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwCompletionID;
    };

} LINEUNCOMPLETECALL_PARAMS, *PLINEUNCOMPLETECALL_PARAMS;


typedef struct _LINEUNHOLD_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HCALL       hCall;
    };

} LINEUNHOLD_PARAMS, *PLINEUNHOLD_PARAMS;


typedef struct _LINEUNPARK_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD       hfnPostProcessProc;

    union
    {
        IN  HLINE       hLine;
    };

    union
    {
        IN  DWORD       dwAddressID;
    };

    IN  DWORD           hpCall;                    // pointer to client buffer

    union
    {
        IN  DWORD       dwDestAddressOffset;        // always valid offset
    };

} LINEUNPARK_PARAMS, *PLINEUNPARK_PARAMS;


typedef struct _LINEMSPIDENTIFY_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;
    
    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        OUT DWORD       dwCLSIDOffset;
    };

    union
    {
        IN OUT DWORD    dwCLSIDSize;
    };

} LINEMSPIDENTIFY_PARAMS, *PLINEMSPIDENTIFY_PARAMS;


typedef struct _LINERECEIVEMSPDATA_PARAMS
{
    union
    {
        OUT LONG            lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINE           hLine;
    };

    union
    {
        IN  HCALL           hCall;
    };

    union
    {
        IN  DWORD           dwBufferOffset;
    };

    union
    {
        IN  DWORD           dwBufferSize;
    };

} LINERECEIVEMSPDATA_PARAMS, *PLINERECEIVEMSPDATA_PARAMS;


typedef struct _R_LOCATIONS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  HLINEAPP    dwhLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwParmsToCheckFlags;
    };

    union
    {
        IN  DWORD       dwLocationsTotalSize;       // size of client buffer
        OUT DWORD       dwLocationsOffset;          // valid offset on success
    };

} R_LOCATIONS_PARAMS, *PR_LOCATIONS_PARAMS;


typedef struct _W_LOCATIONS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       nNumLocations;
    };

    union
    {
        IN  DWORD       dwChangedFlags;
    };

    union
    {
        IN  DWORD       dwCurrentLocationID;
    };

    union
    {
        IN  DWORD       dwLocationListOffset;
    };

} W_LOCATIONS_PARAMS, *PW_LOCATIONS_PARAMS;


typedef struct _ALLOCNEWID_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       hKeyToUse;
        OUT DWORD       dwNewID;
    };

} ALLOCNEWID_PARAMS, *P_ALLOCNEWID_PARAMS;


typedef struct _PERFORMANCE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwCookie;
    };

    union
    {
        IN  DWORD       dwPerformanceTotalSize;     // size of client buffer
        OUT DWORD       dwLocationsOffset;          // valid offset on success
    };

} PERFORMANCE_PARAMS, *PPERFORMANCE_PARAMS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\msrtp.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    msrtp.h
 *
 *  Abstract:
 *
 *    RTP definitions used by applications
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/11/19 created
 *
 **********************************************************************/

#ifndef _msrtp_h_
#define _msrtp_h_

#include <evcode.h>

/**********************************************************************
 * Flags passed in IRtpSession::Init()
 **********************************************************************/
/* Helper enumeration (do not use): Init flags
 *
 * WARNING The order here is important, it matches some flags in
 * RtpAddr_t so a mapping by shifting is possible */
enum {
    RTPINITFG_FIRST, /* Internal only, do not use */

    RTPINITFG_AUTO,  /* Internal only, do not use */
    
    /* Used to enable QOS, i.e. create QOS enabled sockets */
    RTPINITFG_QOS,

    /* Used to make the SSRC persistent */
    RTPINITFG_PERSISTSSRC,

    /* Used to make the sockets persistent */
    RTPINITFG_PERSISTSOCKETS,

    /* Media class 1 to 7 */
    RTPINITFG_CLASS0,
    RTPINITFG_CLASS1,
    RTPINITFG_CLASS2,

    RTPINITFG_DUMMY8,

    RTPINITFG_MATCHRADDR, /* Discard packets not comming from the
                           * remote address */
    RTPINITFG_RADDRRESETDEMUX,/* Reset the demux (unmap all outputs)
                               * when a new remote address is set */

    RTPINITFG_LAST /* Internal only, do not use */
};

/* Helper enumeration (do not use): RTP media class */
enum {
    RTPCLASS_FIRST, /* Internal only, do not use */

    /* Audio traffic */
    RTPCLASS_AUDIO,

    /* Video traffic */
    RTPCLASS_VIDEO,
    
    RTPCLASS_LAST  /* Internal only, do not use */
};

/*
 * Flags used in IRtpSession::Init()
 */
#define RTPINIT_ENABLE_QOS      (1 << RTPINITFG_QOS)
#define RTPINIT_PERSIST_SSRC    (1 << RTPINITFG_PERSISTSSRC)
#define RTPINIT_PERSIST_SOCKETS (1 << RTPINITFG_PERSISTSOCKETS)
#define RTPINIT_CLASS_AUDIO     (RTPCLASS_AUDIO << RTPINITFG_CLASS0)
#define RTPINIT_CLASS_VIDEO     (RTPCLASS_VIDEO << RTPINITFG_CLASS0)
#define RTPINIT_CLASS_DEFAULT   (RTPCLASS_FIRST << RTPINITFG_CLASS0)
#define RTPINIT_MATCHRADDR      (1 << RTPINITFG_MATCHRADDR)
#define RTPINIT_RADDRRESETDEMUX (1 << RTPINITFG_RADDRRESETDEMUX)


/* Mask to validate valid flags in IRtpSession::Init() */
#define RTPINIT_MASK         ( (1 << RTPINITFG_AUTO)   | \
                               (1 << RTPINITFG_QOS)    | \
                               (1 << RTPINITFG_PERSISTSSRC)   | \
                               (1 << RTPINITFG_PERSISTSOCKETS)| \
                               (1 << RTPINITFG_CLASS0) | \
                               (1 << RTPINITFG_CLASS1) | \
                               (1 << RTPINITFG_CLASS2) | \
                               (1 << RTPINITFG_MATCHRADDR)      | \
                               (1 << RTPINITFG_RADDRRESETDEMUX) | \
                               0 \
                             )


/**********************************************************************
 * Multicast modes
 **********************************************************************/
enum {
    RTPMCAST_LOOPBACKMODE_FIRST, /* Internal only, do not use */
    
    /* Disable loopback in Winsock (WS2 will filter ALL packets coming
     * from any socket in the same machine, collision detection is
     * enabled) */
    RTPMCAST_LOOPBACKMODE_NONE,

    /* Enable loopback in RTP (Winsock will enable loopback and RTP
     * will filter packets with a source address equal to the local
     * address, and with the same SSRC, note that in this mode
     * collision detection is enabled but is not possible among
     * applications runing on the same machine) */
    RTPMCAST_LOOPBACKMODE_PARTIAL,
    
    /* Let everything loopback (multicast loopback is enabled in
     * Winsock, no filtering is done in RTP, and collision detection
     * is disabled) */
    RTPMCAST_LOOPBACKMODE_FULL,

    RTPMCAST_LOOPBACKMODE_LAST /* Internal only, do not use */
};

#define DEFAULT_MCAST_LOOPBACK  RTPMCAST_LOOPBACKMODE_NONE

/**********************************************************************
 * TTL defaults
 **********************************************************************/
#define DEFAULT_UCAST_TTL       127
#define DEFAULT_MCAST_TTL       4

#define RTPTTL_RTP               0x1
#define RTPTTL_RTCP              0x2
#define RTPTTL_RTPRTCP           (RTPTTL_RTP | RTPTTL_RTCP)

/**********************************************************************
 *
 * Events base
 *
 **********************************************************************/

/* Helper enumeration (do not use) */
enum {
    /* RTP */
    RTPEVENTKIND_RTP,

    /* Participants */
    RTPEVENTKIND_PINFO,

    /* QOS */
    RTPEVENTKIND_QOS,

    /* SDES info */
    RTPEVENTKIND_SDES,

    RTPEVENTKIND_LAST
};

#define RTPEVNTRANGE   100
#define RTPQOS_ADJUST    3

/* EC_USER defined in evcode.h (0x8000+32=32800) */
#define RTPEVENTBASE         (EC_USER+32)

/* Event base for RTP events */
#define RTPRTP_EVENTBASE     (RTPEVENTBASE + RTPEVNTRANGE*RTPEVENTKIND_RTP)

/* Event base for participant events */
#define RTPPARINFO_EVENTBASE (RTPEVENTBASE + RTPEVNTRANGE*RTPEVENTKIND_PINFO)

/* Event base for QOS */
#define RTPQOS_EVENTBASE     (RTPEVENTBASE + RTPEVNTRANGE*RTPEVENTKIND_QOS + \
                              RTPQOS_ADJUST)

/* Event base for SDES information */
#define RTPSDES_EVENTBASE    (RTPEVENTBASE + RTPEVNTRANGE*RTPEVENTKIND_SDES)

/**********************************************************************
 * Kind of mask (used as the dwKind parameter in ModifySessionMask)
 **********************************************************************/
/* This enum is used to select the mask on which the ModifySessionMask
 * function will modify or query zero, one, or more bits.
 *
 * E.g. ModifySessionMask(RTPMASK_SDESRECV_EVENTS,
 *                        RTPSDES_MASK_PHONE,
 *                        0,
 *                        NULL);
 *
 * This will disable firing an event to the RTP source filter when a
 * PHONE SDES item is received, the modified mask will not be returned
 * as the pointer passed is NULL
 * */
enum {
    RTPMASK_FIRST,   /* Internal only, do not use */

    /* Select the RTP features mask */
    RTPMASK_FEATURES_MASK,

    /* Select the RTP events mask of events fired to a receiver,
     * e.g. an RTP source filter */
    RTPMASK_RECV_EVENTS,

    /* Select the RTP events mask of events fired to a sender, e.g. an
     * RTP render filter */
    RTPMASK_SEND_EVENTS,

    /* Select the events mask for participants events to be fired to a
     * receiver, e.g. an RTP source filter */
    RTPMASK_PINFOR_EVENTS,

    /* Select the events mask for participants events to be fired to a
     * sender, e.g. an RTP render filter */
    RTPMASK_PINFOS_EVENTS,

    /* Select the events mask of QOS events to be fired to a receiver,
     * e.g. an RTP source filter */
    RTPMASK_QOSRECV_EVENTS,

    /* Select the events mask of QOS events to be fired to a sender,
     * e.g. an RTP render filter */
    RTPMASK_QOSSEND_EVENTS,

    /* Select what SDES items (the items must also be enabled to be
     * accepted - RTPMASK_SDES_REMMASK), when received, will fire
     * events to a receiver, e.g. an RTP source filter */
    RTPMASK_SDESRECV_EVENTS,
    
    /* Select what SDES items (the items must also be enabled to be
     * accepted - RTPMASK_SDES_REMMASK), when received, will fire
     * events to a sender, e.g. an RTP render filter */
    RTPMASK_SDESSEND_EVENTS,
    
    /* Select the SDES items to send (provided they have a default or a
     * value has been set) in RTCP reports */
    RTPMASK_SDES_LOCMASK,

    /* Select the SDES items to accept and store when they are
     * received from the remote participants in their RTCP reports,
     * regardless if they are senders or receivers or both */
    RTPMASK_SDES_REMMASK,
    
    RTPMASK_LAST    /* Internal only, do not use */
};

/**********************************************************************
 * Features in RTP (masks)
 * Will use with RTPMASK_FEATURES_MASK
 **********************************************************************/

/* Helper enumeration (do not use) for masks */
enum {
    RTPFEAT_FIRST,  /* Internal only, do not use */

    /* Generate timestamps locally (RTP render only) */
    RTPFEAT_GENTIMESTAMP,

    /* Receive in same buffer RTP header and payload, don't change the
     * RTP header except the SSRC (RTP render only) */
    RTPFEAT_PASSHEADER,

    /* Enable sending RTCP SR probe packets to do bandwidth estimation
     * (queueing latency) */
    RTPFEAT_BANDESTIMATION,
    
    RTPFEAT_LAST    /* Internal only, do not use */
};

/*
 * Masks used to enable/disable the above features (used with
 * RTPMASK_FEATURES_MASK)
 */
#define RTPFEAT_MASK_GENTIMESTAMP   (1 << RTPFEAT_GENTIMESTAMP)
#define RTPFEAT_MASK_PASSHEADER     (1 << RTPFEAT_PASSHEADER)
#define RTPFEAT_MASK_BANDESTIMATION (1 << RTPFEAT_BANDESTIMATION)

/**********************************************************************
 * RTP information (events, masks)
 * Will use with RTPMASK_RECV_EVENTS or RTPMASK_SEND_EVENTS
 **********************************************************************/

/* Helper enumeration (do not use) for events and masks */
enum {
    RTPRTP_FIRST,   /* Internal only, do not use */
    
    /* RTCP RR received */
    RTPRTP_RR_RECEIVED,
    
    /* RTCP SR received */
    RTPRTP_SR_RECEIVED,

    /* Local SSRC is in collision */
    RTPRTP_LOCAL_COLLISION,

    /* Winsock reception error */
    RTPRTP_WS_RECV_ERROR,

    /* Winsock send error */
    RTPRTP_WS_SEND_ERROR,

    /* Network failure */
    RTPRTP_WS_NET_FAILURE,

    /* Loss rate reported in RTCP RR (loss rate observed in the
     * incoming stream that we report to the sender) */
    RTPRTP_RECV_LOSSRATE,
    
    /* Loss rate received in RTCP RR (loss rate seen by our peer (and
     * reported to us) in our outgoing data stream) */
    RTPRTP_SEND_LOSSRATE,

    /* Bandwidth estimation reported back to the sender */
    RTPRTP_BANDESTIMATION,

    /* Decryption failed */
    RTPRTP_CRYPT_RECV_ERROR,
    
    /* Encryption failed */
    RTPRTP_CRYPT_SEND_ERROR,
    
    RTPRTP_LAST    /* Internal only, do not use */
};

/*
 * Events generated
 */
/* P1:Sender's SSRC, P2:0 */
#define RTPRTP_EVENT_RR_RECEIVED     (RTPRTP_EVENTBASE + RTPRTP_RR_RECEIVED)

/* P1:Sender's SSRC, P2:0 */
#define RTPRTP_EVENT_SR_RECEIVED     (RTPRTP_EVENTBASE + RTPRTP_SR_RECEIVED)

/* P1:Local SSRC, P2:Old local SSRC */
#define RTPRTP_EVENT_LOCAL_COLLISION (RTPRTP_EVENTBASE + RTPRTP_LOCAL_COLLISION)

/* P1:0=RTP|1=RTCP, P2:WS2 Error */
#define RTPRTP_EVENT_WS_RECV_ERROR   (RTPRTP_EVENTBASE + RTPRTP_WS_RECV_ERROR)

/* P1:0=RTP|1=RTCP, P2:WS2 Error */
#define RTPRTP_EVENT_WS_SEND_ERROR   (RTPRTP_EVENTBASE + RTPRTP_WS_SEND_ERROR)

/* P1:0=RTP|1=RTCP, P2:WS2 Error */
#define RTPRTP_EVENT_WS_NET_FAILURE  (RTPRTP_EVENTBASE + RTPRTP_WS_NET_FAILURE)

/* P1:Sender's SSRC, P2:Loss rate being reported (See NOTE below) */
#define RTPRTP_EVENT_RECV_LOSSRATE   (RTPRTP_EVENTBASE + RTPRTP_RECV_LOSSRATE)

/* P1:Reporter's SSRC, P2:Loss rate received in report (See NOTE below) */
#define RTPRTP_EVENT_SEND_LOSSRATE   (RTPRTP_EVENTBASE + RTPRTP_SEND_LOSSRATE)

/* NOTE Loss rate passed as (int)(dLossRate * LOSS_RATE_PRECISSION),
 * e.g. if you receive a loss rate = L, then the real percentage in a
 * 0 - 100 scale would be obtained as L / LOSS_RATE_PRECISSION */
#define LOSS_RATE_PRECISSION           1000

/* P1:Reporter's SSRC, P2:Bandwidth estimation in bps (if the
 * estimation is done but the value is undefined, will report the
 * value RTP_BANDWIDTH_UNDEFINED. If the estimation is not done at all
 * will report the value RTP_BANDWIDTH_NOTESTIMATED. If the estimation
 * is getting its initial average will report RTP_BANDWIDTH_NOTREADY)
 * */
#define RTPRTP_EVENT_BANDESTIMATION  (RTPRTP_EVENTBASE + RTPRTP_BANDESTIMATION)

#define RTP_BANDWIDTH_UNDEFINED        ((DWORD)-1)
#define RTP_BANDWIDTH_NOTESTIMATED     ((DWORD)-2)
#define RTP_BANDWIDTH_BANDESTNOTREADY  ((DWORD)-3)

/* P1:0=RTP|1=RTCP, P2:Error */
#define RTPRTP_EVENT_CRYPT_RECV_ERROR \
                                   (RTPRTP_EVENTBASE + RTPRTP_CRYPT_RECV_ERROR)

/* P1:0=RTP|1=RTCP, P2:Error */
#define RTPRTP_EVENT_CRYPT_SEND_ERROR \
                                   (RTPRTP_EVENTBASE + RTPRTP_CRYPT_SEND_ERROR)


/*
 * Masks used to enable/disable the above events (used with
 * RTPMASK_RECV_EVENTS or RTPMASK_SEND_EVENTS)
 */
#define RTPRTP_MASK_RR_RECEIVED        (1 << RTPRTP_RR_RECEIVED)
#define RTPRTP_MASK_SR_RECEIVED        (1 << RTPRTP_SR_RECEIVED)
#define RTPRTP_MASK_LOCAL_COLLISION    (1 << RTPRTP_LOCAL_COLLISION)
#define RTPRTP_MASK_WS_RECV_ERROR      (1 << RTPRTP_WS_RECV_ERROR)
#define RTPRTP_MASK_WS_SEND_ERROR      (1 << RTPRTP_WS_SEND_ERROR)
#define RTPRTP_MASK_WS_NET_FAILURE     (1 << RTPRTP_WS_NET_FAILURE)
#define RTPRTP_MASK_RECV_LOSSRATE      (1 << RTPRTP_RECV_LOSSRATE)
#define RTPRTP_MASK_SEND_LOSSRATE      (1 << RTPRTP_SEND_LOSSRATE)
#define RTPRTP_MASK_BANDESTIMATIONSEND (1 << RTPRTP_BANDESTIMATION)
#define RTPRTP_MASK_CRYPT_RECV_ERROR   (1 << RTPRTP_CRYPT_RECV_ERROR)
#define RTPRTP_MASK_CRYPT_SEND_ERROR   (1 << RTPRTP_CRYPT_SEND_ERROR)
/* RTP prefix
 *
 * A prefix is used to pass extra information from the source RTP
 * filter down stream to the other filters in DShow. There may be as
 * many RTP prefixes as needed, each one begins with a
 * RtpPrefixCommon_t followed by a structure specific to that prefix.
 * A filter not recognizing any prefix will not bother scanning them.
 * A filter expecting a prefix should skip those that it doesn't
 * undestand. Currently there is only 1 prefix used to pass the offset
 * to the payload type and avoid next filters having to compute the
 * variable size RTP header (RTPPREFIXID_HDRSIZE)
 * */
typedef struct _RtpPrefixCommon_t {
    /* Common RtpPrefix */
    WORD             wPrefixID;  /* Prefix ID */
    WORD             wPrefixLen; /* This header length in bytes */
} RtpPrefixCommon_t;

#define RTPPREFIXID_HDRSIZE         1

/*
 * Prefix header for RTP header offset (RTPPREFIXID_HDRSIZE)
 *
 * The lHdrSize field is the number of bytes from the beginnig of the
 * RTP header to the first byte of payload */
typedef struct _RtpPrefixHdr_t {
    /* Common RtpPrefix */
    WORD             wPrefixID;  /* Prefix ID */
    WORD             wPrefixLen; /* This header length in bytes
                                  * (i.e. sizeof(RtpPrefixHdr_t) */
    /* Specific prefix HDRSIZE */
    long             lHdrSize;
} RtpPrefixHdr_t;

/**********************************************************************
 * Participants information (state, events, masks)
 *
 * NOTE: In general, participants generate an event when having state
 * transitions, e.g. event RTPPARINFO_EVENT_TALKING is generated when
 * participant receives RTP packets and goes to the TALKING state.
 * Each event can be enabled or disabled using the mask provided for
 * each of them.
 * Will use with RTPMASK_PINFOR_EVENTS or RTPMASK_PINFOS_EVENTS
 **********************************************************************/

/* Helper enumeration (do not use) for events/states and masks */
enum {
    RTPPARINFO_FIRST,  /* Internal only, do not use */

    /* User was just created (RTP or RTCP packet received) */
    RTPPARINFO_CREATED,

    /* In the conference but not sending data, i.e. sending RTCP
     * packets */
    RTPPARINFO_SILENT,
    
    /* Receiving data from this participant (RTP packets) */
    RTPPARINFO_TALKING,
    
    /* Was just sending data a while ago */
    RTPPARINFO_WAS_TALKING,
    
    /* No RTP/RTCP packets have been received for some time */
    RTPPARINFO_STALL,
    
    /* Left the conference (i.e. sent a RTCP BYE packet) */
    RTPPARINFO_BYE,
    
    /* Participant context has been deleted */
    RTPPARINFO_DEL,

    /* Participant was assigned an output (i.e. mapped) */
    RTPPARINFO_MAPPED,
    
    /* Participant has released its output (i.e. unmapped) */
    RTPPARINFO_UNMAPPED,

    /* Participant has generated network quality metrics update */
    RTPPARINFO_NETWORKCONDITION,
    
    RTPPARINFO_LAST  /* Internal only, do not use */
};

/*
 * Events generated
 */
/*
 * All the events pass the same parameters (except otherwise noted):
 * P1:Remote participant's SSRC, P2:0
 */
#define RTPPARINFO_EVENT_CREATED  (RTPPARINFO_EVENTBASE + RTPPARINFO_CREATED)
#define RTPPARINFO_EVENT_SILENT   (RTPPARINFO_EVENTBASE + RTPPARINFO_SILENT)
#define RTPPARINFO_EVENT_TALKING  (RTPPARINFO_EVENTBASE + RTPPARINFO_TALKING)
#define RTPPARINFO_EVENT_WAS_TALKING (RTPPARINFO_EVENTBASE + RTPPARINFO_WAS_TALKING)
#define RTPPARINFO_EVENT_STALL    (RTPPARINFO_EVENTBASE + RTPPARINFO_STALL)
#define RTPPARINFO_EVENT_BYE      (RTPPARINFO_EVENTBASE + RTPPARINFO_BYE)
#define RTPPARINFO_EVENT_DEL      (RTPPARINFO_EVENTBASE + RTPPARINFO_DEL)

/* P1:Remote participant's SSRC, P2:IPin pointer */
#define RTPPARINFO_EVENT_MAPPED   (RTPPARINFO_EVENTBASE + RTPPARINFO_MAPPED)

/* P1:Remote participant's SSRC, P2:IPin pointer */
#define RTPPARINFO_EVENT_UNMAPPED (RTPPARINFO_EVENTBASE + RTPPARINFO_UNMAPPED)

/*
  NOTE: This event is different from all the others in the sense that
  two actions are needed in order to be generated, first, the network
  metrics computation needs to be enabled (SetNetMetricsState) in one
  or more participants (SSRCs), and second this event needs to be
  enabled
  
  P1:Remote participant's SSRC, P2:Network condition encoded as follows:
      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   loss rate   |    jitter     |      RTT      | network metric|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   network metric - encoded as a 0 - 100 quality, where 0 is very bad,
   and 100 is very good.

   RTT - Encoded as 10's of milliseconds.

   jitter - Encoded as milliseconds.
   
   loss rate - encoded as a 1/256 units */
#define RTPPARINFO_EVENT_NETWORKCONDITION \
                           (RTPPARINFO_EVENTBASE + RTPPARINFO_NETWORKCONDITION)

/* Use these macros to extract each metric encoded in P2 with event
 * RTPPARINFO_EVENT_NETWORKCONDITION.
 *
 * network metric is returned as a DWORD 0 - 100 value, RTT is
 * returned as a double in secods, jitter is returned as double in
 * seconds, and loss rate is returned as a double in percentage [0 -
 * 100] */
#define RTPNET_GET_dwGLOBALMETRIC(_p2) ((DWORD) ((_p2) & 0xff))
#define RTPNET_GET_dRTT(_p2)           ((double) (((_p2) >> 8) & 0xff) / 100)
#define RTPNET_GET_dJITTER(_p2)        ((double) (((_p2) >> 16) & 0xff) / 1000)
#define RTPNET_GET_dLOSSRATE(_p2)      ((double) (((_p2)>>24)&0xff)*100.0/256)

/*
 * Masks used to enable/disable the above events (used with
 * RTPMASK_PINFOR_EVENTS or RTPMASK_PINFOS_EVENTS)
 */
#define RTPPARINFO_MASK_CREATED      (1 << RTPPARINFO_CREATED)
#define RTPPARINFO_MASK_SILENT       (1 << RTPPARINFO_SILENT)
#define RTPPARINFO_MASK_TALKING      (1 << RTPPARINFO_TALKING)
#define RTPPARINFO_MASK_WAS_TALKING  (1 << RTPPARINFO_WAS_TALKING)
#define RTPPARINFO_MASK_STALL        (1 << RTPPARINFO_STALL)
#define RTPPARINFO_MASK_BYE          (1 << RTPPARINFO_BYE)
#define RTPPARINFO_MASK_DEL          (1 << RTPPARINFO_DEL)
#define RTPPARINFO_MASK_MAPPED       (1 << RTPPARINFO_MAPPED)
#define RTPPARINFO_MASK_UNMAPPED     (1 << RTPPARINFO_UNMAPPED)
#define RTPPARINFO_MASK_NETWORKCONDITION (1 << RTPPARINFO_NETWORKCONDITION)

/* Helper enumeration (do not use) for the modifiable items in
 * participants */
enum {
    RTPPARITEM_FIRST,  /* Internal only, do not use */

    RTPPARITEM_STATE,  /* qury: e.g TALKING, SILENT, etc. */
    RTPPARITEM_MUTE,   /* set/query: muted or not muted */
    RTPPARITEM_NETEVENT, /* enable/disable/query: genarting events
                          * when network conditions change */
    
    RTPPARITEM_LAST   /* Internal only, do not use */
};

/* Indexes for the items in RtpNetInfo.dItems, used for RTT, Jitter
 * and loss rate
 *
 * WARNING
 *
 * The following enumeration and the min/max bounds
 * (e.g. NETQ_RTT_MAX) defined in struct.h and rtcpdec.c and used by
 * RtpComputNetworkMetrics() must be kept in sync */
enum {
    NETQ_RTT_IDX,         /* Average RTT in seconds */
    NETQ_JITTER_IDX,      /* Average Jitters in seconds */
    NETQ_LOSSRATE_IDX,    /* Average Loss rate is a percentage */
    
    NETQ_LAST_IDX         /* Internal (do not use) */
};

typedef struct _RtpNetInfo_t {
    /* Network quality */
    double           dAvg[NETQ_LAST_IDX];     /* Keep averages */
    double           dHowGood[NETQ_LAST_IDX]; /* Keep a 0-100 metric */
    
    /* Compound network metric as seen by this user, uses the above
     * parameters to come up with a network quality metric between 0
     * and 100, 0 is too bad, and 100 is the best */
    DWORD            dwNetMetrics;  /* 0 - 100 scale */
    union {
        double           dMetricAge;/* Elapsed time since last update (secs) */
        double           dLastUpdate;/* Last time metrics were updated */
    };
} RtpNetInfo_t;

/**********************************************************************
 * QOS (events, masks)
 *
 * NOTE Each QOS event can be enabled or disabled, using the mask
 * provided for each of them.
 * Will use with RTPMASK_QOSSEND_EVENTS or RTPMASK_QOSSEND_EVENTS
 **********************************************************************/

/* Helper enumeration (do not use) for events and masks */
enum {
    RTPQOS_FIRST,   /* Internal only, do not use */
    
    /* no QoS support is available */
    RTPQOS_NOQOS,
    
    /* at least one Reserve has arrived */
    RTPQOS_RECEIVERS,

    /* at least one Path has arrived */
    RTPQOS_SENDERS,

    /* there are no senders */
    RTPQOS_NO_SENDERS,

    /* there are no receivers */
    RTPQOS_NO_RECEIVERS,

    /* Reserve has been confirmed */
    RTPQOS_REQUEST_CONFIRMED,

    /* error due to lack of resources */
    RTPQOS_ADMISSION_FAILURE,
    
    /* rejected for administrative reasons - bad credentials */
    RTPQOS_POLICY_FAILURE,
    
    /* unknown or conflicting style */
    RTPQOS_BAD_STYLE,
    
    /* problem with some part of the filterspec or providerspecific
     * buffer in general */
    RTPQOS_BAD_OBJECT,
    
    /* problem with some part of the flowspec */
    RTPQOS_TRAFFIC_CTRL_ERROR,
    
    /* general error */
    RTPQOS_GENERIC_ERROR,
    
    /* invalid service type in flowspec */
    RTPQOS_ESERVICETYPE,

    /* invalid flowspec */
    RTPQOS_EFLOWSPEC,

    /* invalid provider specific buffer */
    RTPQOS_EPROVSPECBUF,

    /* invalid filter style */
    RTPQOS_EFILTERSTYLE,

    /* invalid filter type */
    RTPQOS_EFILTERTYPE,

    /* incorrect number of filters */
    RTPQOS_EFILTERCOUNT,

    /* invalid object length */
    RTPQOS_EOBJLENGTH,

    /* incorrect number of flows */
    RTPQOS_EFLOWCOUNT,

    /* unknown object in provider specific buffer */
    RTPQOS_EUNKOWNPSOBJ,

    /* invalid policy object in provider specific buffer */
    RTPQOS_EPOLICYOBJ,

    /* invalid flow descriptor in the list */
    RTPQOS_EFLOWDESC,

    /* inconsistent flow spec in provider specific buffer */
    RTPQOS_EPSFLOWSPEC,

    /* invalid filter spec in provider specific buffer */
    RTPQOS_EPSFILTERSPEC,

    /* invalid shape discard mode object in provider specific buffer */
    RTPQOS_ESDMODEOBJ,

    /* invalid shaping rate object in provider specific buffer */
    RTPQOS_ESHAPERATEOBJ,

    /* reserved policy element in provider specific buffer */
    RTPQOS_RESERVED_PETYPE,

    /* sender is not allowed to send */
    RTPQOS_NOT_ALLOWEDTOSEND,
    
    /* sender is allowed to send */
    RTPQOS_ALLOWEDTOSEND,

    RTPQOS_LAST    /* Internal only, do not use */
};

/*
 * Events generated
 */
/* All the events pass the same parameters:
 * P1:0, P2:0
 */
#define RTPQOS_EVENT_NOQOS           (RTPQOS_EVENTBASE + RTPQOS_NOQOS)
#define RTPQOS_EVENT_RECEIVERS       (RTPQOS_EVENTBASE + RTPQOS_RECEIVERS)
#define RTPQOS_EVENT_SENDERS         (RTPQOS_EVENTBASE + RTPQOS_SENDERS)
#define RTPQOS_EVENT_NO_SENDERS      (RTPQOS_EVENTBASE + RTPQOS_NO_SENDERS)
#define RTPQOS_EVENT_NO_RECEIVERS    (RTPQOS_EVENTBASE + RTPQOS_NO_RECEIVERS)
#define RTPQOS_EVENT_REQUEST_CONFIRMED (RTPQOS_EVENTBASE + RTPQOS_REQUEST_CONFIRMED)
#define RTPQOS_EVENT_ADMISSION_FAILURE (RTPQOS_EVENTBASE + RTPQOS_ADMISSION_FAILURE)
#define RTPQOS_EVENT_POLICY_FAILURE  (RTPQOS_EVENTBASE + RTPQOS_POLICY_FAILURE)
#define RTPQOS_EVENT_BAD_STYLE       (RTPQOS_EVENTBASE + RTPQOS_BAD_STYLE)
#define RTPQOS_EVENT_BAD_OBJECT      (RTPQOS_EVENTBASE + RTPQOS_BAD_OBJECT)
#define RTPQOS_EVENT_TRAFFIC_CTRL_ERROR (RTPQOS_EVENTBASE + RTPQOS_TRAFFIC_CTRL_ERROR)
#define RTPQOS_EVENT_GENERIC_ERROR   (RTPQOS_EVENTBASE + RTPQOS_GENERIC_ERROR)
#define RTPQOS_EVENT_ESERVICETYPE    (RTPQOS_EVENTBASE + RTPQOS_ESERVICETYPE)
#define RTPQOS_EVENT_EFLOWSPEC       (RTPQOS_EVENTBASE + RTPQOS_EFLOWSPEC)
#define RTPQOS_EVENT_EPROVSPECBUF    (RTPQOS_EVENTBASE + RTPQOS_EPROVSPECBUF)
#define RTPQOS_EVENT_EFILTERSTYLE    (RTPQOS_EVENTBASE + RTPQOS_EFILTERSTYLE)
#define RTPQOS_EVENT_EFILTERTYPE     (RTPQOS_EVENTBASE + RTPQOS_EFILTERTYPE)
#define RTPQOS_EVENT_EFILTERCOUNT    (RTPQOS_EVENTBASE + RTPQOS_EFILTERCOUNT)
#define RTPQOS_EVENT_EOBJLENGTH      (RTPQOS_EVENTBASE + RTPQOS_EOBJLENGTH)
#define RTPQOS_EVENT_EFLOWCOUNT      (RTPQOS_EVENTBASE + RTPQOS_EFLOWCOUNT)
#define RTPQOS_EVENT_EUNKOWNPSOBJ    (RTPQOS_EVENTBASE + RTPQOS_EUNKOWNPSOBJ)
#define RTPQOS_EVENT_EPOLICYOBJ      (RTPQOS_EVENTBASE + RTPQOS_EPOLICYOBJ)
#define RTPQOS_EVENT_EFLOWDESC       (RTPQOS_EVENTBASE + RTPQOS_EFLOWDESC)
#define RTPQOS_EVENT_EPSFLOWSPEC     (RTPQOS_EVENTBASE + RTPQOS_EPSFLOWSPEC)
#define RTPQOS_EVENT_EPSFILTERSPEC   (RTPQOS_EVENTBASE + RTPQOS_EPSFILTERSPEC)
#define RTPQOS_EVENT_ESDMODEOBJ      (RTPQOS_EVENTBASE + RTPQOS_ESDMODEOBJ)
#define RTPQOS_EVENT_ESHAPERATEOBJ   (RTPQOS_EVENTBASE + RTPQOS_ESHAPERATEOBJ)
#define RTPQOS_EVENT_RESERVED_PETYPE (RTPQOS_EVENTBASE + RTPQOS_RESERVED_PETYPE)
#define RTPQOS_EVENT_NOT_ALLOWEDTOSEND (RTPQOS_EVENTBASE + RTPQOS_NOT_ALLOWEDTOSEND)
#define RTPQOS_EVENT_ALLOWEDTOSEND   (RTPQOS_EVENTBASE + RTPQOS_ALLOWEDTOSEND)

/*
 * Masks used to enable/disable the above events (used with
 * RTPMASK_QOSRECV_EVENTS or RTPMASK_QOSSEND_EVENTS)
 */
#define RTPQOS_MASK_NOQOS              (1 << RTPQOS_NOQOS)
#define RTPQOS_MASK_RECEIVERS          (1 << RTPQOS_RECEIVERS)
#define RTPQOS_MASK_SENDERS            (1 << RTPQOS_SENDERS)
#define RTPQOS_MASK_NO_SENDERS         (1 << RTPQOS_NO_SENDERS)
#define RTPQOS_MASK_NO_RECEIVERS       (1 << RTPQOS_NO_RECEIVERS)
#define RTPQOS_MASK_REQUEST_CONFIRMED  (1 << RTPQOS_REQUEST_CONFIRMED)
#define RTPQOS_MASK_ADMISSION_FAILURE  (1 << RTPQOS_ADMISSION_FAILURE)
#define RTPQOS_MASK_POLICY_FAILURE     (1 << RTPQOS_POLICY_FAILURE)
#define RTPQOS_MASK_BAD_STYLE          (1 << RTPQOS_BAD_STYLE)
#define RTPQOS_MASK_BAD_OBJECT         (1 << RTPQOS_BAD_OBJECT)
#define RTPQOS_MASK_TRAFFIC_CTRL_ERROR (1 << RTPQOS_TRAFFIC_CTRL_ERROR)
#define RTPQOS_MASK_GENERIC_ERROR      (1 << RTPQOS_GENERIC_ERROR)
#define RTPQOS_MASK_ESERVICETYPE       (1 << RTPQOS_ESERVICETYPE)
#define RTPQOS_MASK_EFLOWSPEC          (1 << RTPQOS_EFLOWSPEC)
#define RTPQOS_MASK_EPROVSPECBUF       (1 << RTPQOS_EPROVSPECBUF)
#define RTPQOS_MASK_EFILTERSTYLE       (1 << RTPQOS_EFILTERSTYLE)
#define RTPQOS_MASK_EFILTERTYPE        (1 << RTPQOS_EFILTERTYPE)
#define RTPQOS_MASK_EFILTERCOUNT       (1 << RTPQOS_EFILTERCOUNT)
#define RTPQOS_MASK_EOBJLENGTH         (1 << RTPQOS_EOBJLENGTH)
#define RTPQOS_MASK_EFLOWCOUNT         (1 << RTPQOS_EFLOWCOUNT)
#define RTPQOS_MASK_EUNKOWNPSOBJ       (1 << RTPQOS_EUNKOWNPSOBJ)
#define RTPQOS_MASK_EPOLICYOBJ         (1 << RTPQOS_EPOLICYOBJ)
#define RTPQOS_MASK_EFLOWDESC          (1 << RTPQOS_EFLOWDESC)
#define RTPQOS_MASK_EPSFLOWSPEC        (1 << RTPQOS_EPSFLOWSPEC)
#define RTPQOS_MASK_EPSFILTERSPEC      (1 << RTPQOS_EPSFILTERSPEC)
#define RTPQOS_MASK_ESDMODEOBJ         (1 << RTPQOS_ESDMODEOBJ)
#define RTPQOS_MASK_ESHAPERATEOBJ      (1 << RTPQOS_ESHAPERATEOBJ)
#define RTPQOS_MASK_RESERVED_PETYPE    (1 << RTPQOS_RESERVED_PETYPE)
#define RTPQOS_MASK_NOT_ALLOWEDTOSEND  (1 << RTPQOS_NOT_ALLOWEDTOSEND)
#define RTPQOS_MASK_ALLOWEDTOSEND      (1 << RTPQOS_ALLOWEDTOSEND)

/* QOS template names */
#define RTPQOSNAME_G711                L"G711"
#define RTPQOSNAME_G723_1              L"G723.1"
#define RTPQOSNAME_GSM6_10             L"GSM6.10"
#define RTPQOSNAME_DVI4_8              L"DVI4_8"
#define RTPQOSNAME_DVI4_16             L"DVI4_16"
#define RTPQOSNAME_SIREN               L"SIREN"
#define RTPQOSNAME_G722_1              L"G722.1"
#define RTPQOSNAME_MSAUDIO             L"MSAUDIO"
#define RTPQOSNAME_H263QCIF            L"H263QCIF"
#define RTPQOSNAME_H263CIF             L"H263CIF"
#define RTPQOSNAME_H261QCIF            L"H261QCIF"
#define RTPQOSNAME_H261CIF             L"H261CIF"

/* RTP reservation styles */
enum {
    /* Use default style, i.e. FF for unicast, WF for multicast */
    RTPQOS_STYLE_DEFAULT,

    /* Wildcard-Filter (default in multicast) */
    RTPQOS_STYLE_WF,

    /* Fixed-Filter (default in unicast) */
    RTPQOS_STYLE_FF,

    /* Shared-Explicit (for multicast, typically for video) */
    RTPQOS_STYLE_SE,

    RTPQOS_STYLE_LAST
};

/* Used to derive a flow spec. This information is obtained from the
 * codecs and passed to RTP to generate a QOS flow spec that closelly
 * describes the codecs generating/receiving traffic */
typedef struct _RtpQosSpec_t {
    DWORD            dwAvgRate;       /* bits/s */
    DWORD            dwPeakRate;      /* bits/s */
    DWORD            dwMinPacketSize; /* bytes */
    DWORD            dwMaxPacketSize; /* bytes */
    DWORD            dwMaxBurst;      /* number of packets */
    DWORD            dwResvStyle;     /* maps to FF, WF, or SE */
} RtpQosSpec_t;

/* Helper enumeration (do not use) */
enum {
    RTPQOS_QOSLIST_FIRST,  /* Internal only, do not use */

    /* Enable Add/Delete */
    RTPQOS_QOSLIST_ENABLE,

    /* If Enabled, select Add */
    RTPQOS_QOSLIST_ADD,

    /* Flush */
    RTPQOS_QOSLIST_FLUSH,
    
    RTPQOS_QOSLIST_LAST    /* Internal only, do not use */
};

/* Values for parameter dwOperation in ModifyQosList().
 * They can be OR'ed */
#define RTPQOS_ADD_SSRC ((1<<RTPQOS_QOSLIST_ENABLE) | (1<<RTPQOS_QOSLIST_ADD))
#define RTPQOS_DEL_SSRC (1 << RTPQOS_QOSLIST_ENABLE)
#define RTPQOS_FLUSH    (1 << RTPQOS_QOSLIST_FLUSH)

/* Allowed to send mode */
/* Passed as parameters dwQosSendMode in SetQosByName or
 * SetQosParameters functions */
enum {
    RTPQOSSENDMODE_FIRST,   /* Internal only, do not use */

    /* Don't ask for permission to send */
    RTPQOSSENDMODE_UNRESTRICTED,

    /* Ask permission to send, if denied, keep sending at a reduced
     * rate */
    RTPQOSSENDMODE_REDUCED_RATE,

    /* Ask permission to send, if denied, DON'T SEND at all */
    RTPQOSSENDMODE_DONT_SEND,
    
    /* Ask permission to send, send at normal rate no matter what, the
     * application is supposed to stop passing data to RTP or to pass
     * the very minimum (this is the mode that should be used) */
    RTPQOSSENDMODE_ASK_BUT_SEND,
    
    RTPQOSSENDMODE_LAST     /* Internal only, do not use */
};

/* Maximum number of UNICODE chars to set in the QOS policy locator
 * and app ID */
#define MAX_QOS_APPID   128
#define MAX_QOS_APPGUID 128
#define MAX_QOS_POLICY  128

/**********************************************************************
 * SDES local/remote information (events, masks)
 * Will use with RTPMASK_SDESRECV_EVENTS or RTPMASK_SDESSEND_EVENTS or
 * RTPMASK_SDES_LOCMASK or RTPMASK_SDES_REMMASK
 **********************************************************************/

/* Helper enumeration (do not use) for events and masks */
enum {
    RTPSDES_FIRST,  /* Internal only, do not use */

    /* RTCP SDES CNAME Canonical name */
    RTPSDES_CNAME,

    /* RTCP SDES NAME User name*/
    RTPSDES_NAME,

    /* RTCP SDES EMAIL User's e-mail */
    RTPSDES_EMAIL,

    /* RTCP SDES PHONE User's phone number */
    RTPSDES_PHONE,

    /* RTCP SDES LOC User's location */
    RTPSDES_LOC,

    /* RTCP SDES TOOL Tools (application) used */
    RTPSDES_TOOL,

    /* RTCP SDES NOTE Note about the user/site */
    RTPSDES_NOTE,

    /* RTCP SDES PRIV Private information */
    RTPSDES_PRIV,

    /* RTCP SDES ANY Any of the above */
    RTPSDES_ANY,

    RTPSDES_LAST    /* Internal only, do not use */
};

#define RTPSDES_END RTPSDES_FIRST

/*
 * Events generated when the specific SDES field is received for the
 * first time (used with RTPMASK_SDES_EVENTS)
 */
/* All the events pass the same parameters:
 * P1:Remote participant's SSRC, P2:The event index (as in the above
 * enumeration.
 * Note that the event index goes from RTPSDES_CNAME to RTPSDES_PRIV
 */
#define RTPSDES_EVENT_CNAME        (RTPSDES_EVENTBASE + RTPSDES_CNAME)
#define RTPSDES_EVENT_NAME         (RTPSDES_EVENTBASE + RTPSDES_NAME)
#define RTPSDES_EVENT_EMAIL        (RTPSDES_EVENTBASE + RTPSDES_EMAIL)
#define RTPSDES_EVENT_PHONE        (RTPSDES_EVENTBASE + RTPSDES_PHONE)
#define RTPSDES_EVENT_LOC          (RTPSDES_EVENTBASE + RTPSDES_LOC)
#define RTPSDES_EVENT_TOOL         (RTPSDES_EVENTBASE + RTPSDES_TOOL)
#define RTPSDES_EVENT_NOTE         (RTPSDES_EVENTBASE + RTPSDES_NOTE)
#define RTPSDES_EVENT_PRIV         (RTPSDES_EVENTBASE + RTPSDES_PRIV)
#define RTPSDES_EVENT_ANY          (RTPSDES_EVENTBASE + RTPSDES_ANY)

/*
 * Masks used to enable/disable the above events (used with
 * RTPMASK_SDESRECV_EVENTS and RTPMASK_SDESSEND_EVENTS)
 */
#define RTPSDES_MASK_CNAME         (1 << RTPSDES_CNAME)
#define RTPSDES_MASK_NAME          (1 << RTPSDES_NAME)
#define RTPSDES_MASK_EMAIL         (1 << RTPSDES_EMAIL)
#define RTPSDES_MASK_PHONE         (1 << RTPSDES_PHONE)
#define RTPSDES_MASK_LOC           (1 << RTPSDES_LOC)
#define RTPSDES_MASK_TOOL          (1 << RTPSDES_TOOL)
#define RTPSDES_MASK_NOTE          (1 << RTPSDES_NOTE)
#define RTPSDES_MASK_PRIV          (1 << RTPSDES_PRIV)
#define RTPSDES_MASK_ANY           (1 << RTPSDES_ANY)

/*
 * Masks used to enable/disable sending each SDES field (used with
 * RTPMASK_SDES_LOCMASK)
 */
#define RTPSDES_LOCMASK_CNAME      (1 << RTPSDES_CNAME)
#define RTPSDES_LOCMASK_NAME       (1 << RTPSDES_NAME)
#define RTPSDES_LOCMASK_EMAIL      (1 << RTPSDES_EMAIL)
#define RTPSDES_LOCMASK_PHONE      (1 << RTPSDES_PHONE)
#define RTPSDES_LOCMASK_LOC        (1 << RTPSDES_LOC)
#define RTPSDES_LOCMASK_TOOL       (1 << RTPSDES_TOOL)
#define RTPSDES_LOCMASK_NOTE       (1 << RTPSDES_NOTE)
#define RTPSDES_LOCMASK_PRIV       (1 << RTPSDES_PRIV)

/*
 * Masks used to enable/disable keeping each SDES field from the
 * remote participants (used with RTPMASK_SDES_REMMASK)
 */
#define RTPSDES_REMMASK_CNAME      (1 << RTPSDES_CNAME)
#define RTPSDES_REMMASK_NAME       (1 << RTPSDES_NAME)
#define RTPSDES_REMMASK_EMAIL      (1 << RTPSDES_EMAIL)
#define RTPSDES_REMMASK_PHONE      (1 << RTPSDES_PHONE)
#define RTPSDES_REMMASK_LOC        (1 << RTPSDES_LOC)
#define RTPSDES_REMMASK_TOOL       (1 << RTPSDES_TOOL)
#define RTPSDES_REMMASK_NOTE       (1 << RTPSDES_NOTE)
#define RTPSDES_REMMASK_PRIV       (1 << RTPSDES_PRIV)

/**********************************************************************
 * RTP encryption
 **********************************************************************/

/* RTP encryption modes */
enum {
    RTPCRYPTMODE_FIRST,  /* Internal only, do not use */

    /* Encrypt/Decrypt RTP payload only */
    RTPCRYPTMODE_PAYLOAD,

    /* Encrypt/Decrypt RTP packets only */
    RTPCRYPTMODE_RTP,

    /* Encrypt/Decrypt RTP and RTCP packets */
    RTPCRYPTMODE_ALL,

    RTPCRYPTMODE_LAST    /* Internal only, do not use */
};

/* Helper enumeration (do not use) for mode flags */
enum {
    RTPCRYPTFG_FIRST = 16, /* Internal only, do not use */

    /* Use the same key for RECV, SEND, and RTCP */
    RTPCRYPTFG_SAMEKEY,
    
    RTPCRYPTFG_LAST,       /* Internal only, do not use */
};    

/*
 * Flags to modify mode
 */
#define RTPCRYPT_SAMEKEY           (1 << RTPCRYPTFG_SAMEKEY)

/* Max pass phrase in bytes (after it is converted from UNICODE to
 * UTF-8), the resulting data is stored in an array this size big */
#define RTPCRYPT_PASSPHRASEBUFFSIZE 256

/*
 * The following hashing and data encryption algorithms work on
 * Windows2000 out of the box, other algorithms may work with other
 * providers
 * */

/*
 * Hashing algorithms to use in SetEncryptionKey, default hash
 * algorithm is RTPCRYPT_HASH_MD5 */
#define  RTPCRYPT_HASH_MD2                   L"MD2"
#define  RTPCRYPT_HASH_MD4                   L"MD4"
#define  RTPCRYPT_HASH_MD5                   L"MD5"
#define  RTPCRYPT_HASH_SHA                   L"SHA"
#define  RTPCRYPT_HASH_SHA1                  L"SHA1"

/*
 * Encryption algorithms to use in SetEncryptionKey, default data
 * encryption algorithm is RTPCRYPT_DATA_DES */
#define  RTPCRYPT_DATA_DES                   L"DES"
#define  RTPCRYPT_DATA_3DES                  L"3DES"
#define  RTPCRYPT_DATA_RC2                   L"RC2"
#define  RTPCRYPT_DATA_RC4                   L"RC4"

/* NOTE
 *
 * The stack will be able to recognize the following algorithms, if
 * supported:
 *
 * L"MD2"
 * L"MD4"
 * L"MD5"
 * L"SHA"
 * L"SHA1"
 * L"MAC"
 * L"RSA_SIGN"
 * L"DSS_SIGN"
 * L"RSA_KEYX"
 * L"DES"
 * L"3DES_112"
 * L"3DES"
 * L"DESX"
 * L"RC2"
 * L"RC4"
 * L"SEAL"
 * L"DH_SF"
 * L"DH_EPHEM"
 * L"AGREEDKEY_ANY"
 * L"KEA_KEYX"
 * L"HUGHES_MD5"
 * L"SKIPJACK"
 * L"TEK"
 * L"CYLINK_MEK"
 * L"SSL3_SHAMD5"
 * L"SSL3_MASTER"
 * L"SCHANNEL_MASTER_HASH"
 * L"SCHANNEL_MAC_KEY"
 * L"SCHANNEL_ENC_KEY"
 * L"PCT1_MASTER"
 * L"SSL2_MASTER"
 * L"TLS1_MASTER"
 * L"RC5"
 * L"HMAC"
 * L"TLS1PRF"
 * */

/**********************************************************************
 * RTP Demux
 **********************************************************************/
/* Demux modes */
enum {
    RTPDMXMODE_FIRST,   /* Internal only, do not use */

    /* Manual mapping */
    RTPDMXMODE_MANUAL,

    /* Automatically map and unmap */
    RTPDMXMODE_AUTO,

    /* Automatically map, manual unmap */
    RTPDMXMODE_AUTO_MANUAL,
    
    RTPDMXMODE_LAST     /* Internal only, do not use */
};

/* State used in SetMappingState */
#define RTPDMX_PINMAPPED   TRUE
#define RTPDMX_PINUNMAPPED FALSE

/* Maximum number of payload type mappings */
#define MAX_MEDIATYPE_MAPPINGS  10

/**********************************************************************
 * DTMF (RFC2833)
 **********************************************************************/
/* Events sent */
enum {
    RTPDTMF_FIRST = 0,  /* Internal only, do not use */
    
    RTPDTMF_0 = 0,      /*  0 */
    RTPDTMF_1,          /*  1 */
    RTPDTMF_2,          /*  2 */
    RTPDTMF_3,          /*  3 */
    RTPDTMF_4,          /*  4 */
    RTPDTMF_5,          /*  5 */
    RTPDTMF_6,          /*  6 */
    RTPDTMF_7,          /*  7 */
    RTPDTMF_8,          /*  8 */
    RTPDTMF_9,          /*  9 */
    RTPDTMF_STAR,       /* 10 */
    RTPDTMF_POUND,      /* 11 */
    RTPDTMF_A,          /* 12 */
    RTPDTMF_B,          /* 13 */
    RTPDTMF_C,          /* 14 */
    RTPDTMF_D,          /* 15 */
    RTPDTMF_FLASH,      /* 16 */

    RTPDTMF_LAST        /* Internal only, do not use */
};
    
    

#endif /* _msrtp_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\phone.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1995  Microsoft Corporation

Module Name:

    phone.h

Abstract:

    Header file for

Author:

    Dan Knudson (DanKn)    dd-Mmm-1995

Revision History:

--*/


#define ANY_RT_HPHONE       1
#define ANY_RT_HPHONE_CLOSE 2
#define ANY_RT_HPHONEAPP    3
#define DEVICE_ID           4
#define DEVICE_ID_OPEN      5


#define AllPhoneStates1_0          \
    (PHONESTATE_OTHER            | \
    PHONESTATE_CONNECTED         | \
    PHONESTATE_DISCONNECTED      | \
    PHONESTATE_OWNER             | \
    PHONESTATE_MONITORS          | \
    PHONESTATE_DISPLAY           | \
    PHONESTATE_LAMP              | \
    PHONESTATE_RINGMODE          | \
    PHONESTATE_RINGVOLUME        | \
    PHONESTATE_HANDSETHOOKSWITCH | \
    PHONESTATE_HANDSETVOLUME     | \
    PHONESTATE_HANDSETGAIN       | \
    PHONESTATE_SPEAKERHOOKSWITCH | \
    PHONESTATE_SPEAKERVOLUME     | \
    PHONESTATE_SPEAKERGAIN       | \
    PHONESTATE_HEADSETHOOKSWITCH | \
    PHONESTATE_HEADSETVOLUME     | \
    PHONESTATE_HEADSETGAIN       | \
    PHONESTATE_SUSPEND           | \
    PHONESTATE_RESUME            | \
    PHONESTATE_DEVSPECIFIC       | \
    PHONESTATE_REINIT)

#define AllPhoneStates1_4          \
    (PHONESTATE_OTHER            | \
    PHONESTATE_CONNECTED         | \
    PHONESTATE_DISCONNECTED      | \
    PHONESTATE_OWNER             | \
    PHONESTATE_MONITORS          | \
    PHONESTATE_DISPLAY           | \
    PHONESTATE_LAMP              | \
    PHONESTATE_RINGMODE          | \
    PHONESTATE_RINGVOLUME        | \
    PHONESTATE_HANDSETHOOKSWITCH | \
    PHONESTATE_HANDSETVOLUME     | \
    PHONESTATE_HANDSETGAIN       | \
    PHONESTATE_SPEAKERHOOKSWITCH | \
    PHONESTATE_SPEAKERVOLUME     | \
    PHONESTATE_SPEAKERGAIN       | \
    PHONESTATE_HEADSETHOOKSWITCH | \
    PHONESTATE_HEADSETVOLUME     | \
    PHONESTATE_HEADSETGAIN       | \
    PHONESTATE_SUSPEND           | \
    PHONESTATE_RESUME            | \
    PHONESTATE_DEVSPECIFIC       | \
    PHONESTATE_REINIT            | \
    PHONESTATE_CAPSCHANGE        | \
    PHONESTATE_REMOVED)

#define AllButtonModes             \
    (PHONEBUTTONMODE_DUMMY       | \
    PHONEBUTTONMODE_CALL         | \
    PHONEBUTTONMODE_FEATURE      | \
    PHONEBUTTONMODE_KEYPAD       | \
    PHONEBUTTONMODE_LOCAL        | \
    PHONEBUTTONMODE_DISPLAY)

#define AllButtonStates1_0         \
    (PHONEBUTTONSTATE_UP         | \
    PHONEBUTTONSTATE_DOWN)

#define AllButtonStates1_4         \
    (PHONEBUTTONSTATE_UP         | \
    PHONEBUTTONSTATE_DOWN        | \
    PHONEBUTTONSTATE_UNKNOWN     | \
    PHONEBUTTONSTATE_UNAVAIL)

#if DBG

#define PHONEPROLOG(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12) \
        PhoneProlog(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12)

#define PHONEEPILOGSYNC(a1,a2,a3,a4) PhoneEpilogSync(a1,a2,a3,a4)

#define PHONEEPILOGASYNC(a1,a2,a3,a4,a5,a6) PhoneEpilogAsync(a1,a2,a3,a4,a5,a6)

#else

#define PHONEPROLOG(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12) \
        PhoneProlog(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)

#define PHONEEPILOGSYNC(a1,a2,a3,a4) PhoneEpilogSync(a1,a2,a3)

#define PHONEEPILOGASYNC(a1,a2,a3,a4,a5,a6) PhoneEpilogAsync(a1,a2,a3,a4,a5)

#endif


typedef struct _PPHONECLOSE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    OUT DWORD           dwCallbackInstance;

} PHONECLOSE_PARAMS, *PPHONECLOSE_PARAMS;


typedef struct _PHONECONFIGDIALOG_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  HWND        hwndOwner;
    };

    union
    {
        IN  DWORD       dwDeviceClassOffset;        // valid offset or
                                                    //   TAPI_NO_DATA
    };

} PHONECONFIGDIALOG_PARAMS, *PPHONECONFIGDIALOG_PARAMS;


typedef struct _PHONEDEVSPECIFIC_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    IN  DWORD           hfnPostProcessProc;

    union
    {
        IN  HPHONE      hPhone;
    };

    // IN  ULONG_PTR       lpParams;                   // pointer to client buffer
    IN  DWORD           hpParams;                   // pointer to client buffer

    union
    {
        IN  DWORD       dwParamsOffset;
    };

    union
    {
        IN  DWORD       dwParamsSize;
    };

} PHONEDEVSPECIFIC_PARAMS, *PPHONEDEVSPECIFIC_PARAMS;


typedef struct _PHONEGETBUTTONINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwButtonLampID;
    };

    union
    {
        IN  DWORD       dwButtonInfoTotalSize;      // size of client buffer
        OUT DWORD       dwButtonInfoOffset;         // valid offset on success
    };

} PHONEGETBUTTONINFO_PARAMS, *PPHONEGETBUTTONINFO_PARAMS;


typedef struct _PHONEGETDATA_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };


    union
    {
        IN  DWORD       dwDataID;
    };

    union
    {
        OUT DWORD       dwDataOffset;
    };

    union
    {
        IN  DWORD       dwSize;
    };

} PHONEGETDATA_PARAMS, *PPHONEGETDATA_PARAMS;


typedef struct _PHONEGETDEVCAPS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONEAPP   hPhoneApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwExtVersion;
    };

    union
    {
        IN  DWORD       dwPhoneCapsTotalSize;       // size of client buffer
        OUT DWORD       dwPhoneCapsOffset;          // valid offset on success
    };

} PHONEGETDEVCAPS_PARAMS, *PPHONEGETDEVCAPS_PARAMS;


typedef struct _PHONEGETDISPLAY_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwDisplayTotalSize;         // size of client buffer
        OUT DWORD       dwDisplayOffset;            // valid offset on success
    };

} PHONEGETDISPLAY_PARAMS, *PPHONEGETDISPLAY_PARAMS;


typedef struct _PHONEGETGAIN_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwHookSwitchDev;
    };

    union
    {
        OUT DWORD       dwGain;
    };

} PHONEGETGAIN_PARAMS, *PPHONEGETGAIN_PARAMS;


typedef struct _PHONEGETHOOKSWITCH_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        OUT DWORD       dwHookSwitchDevs;
    };

} PHONEGETHOOKSWITCH_PARAMS, *PPHONEGETHOOKSWITCH_PARAMS;


typedef struct _PHONEGETICON_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwDeviceClassOffset;        // valid offset or
                                                    //   TAPI_NO_DATA
    };

    union
    {
        OUT HICON       hIcon;
    };

} PHONEGETICON_PARAMS, *PPHONEGETICON_PARAMS;


typedef struct _PHONEGETID_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwDeviceIDTotalSize;        // size of client buffer
        OUT DWORD       dwDeviceIDOffset;           // valid offset on success
    };

    union
    {
        IN  DWORD       dwDeviceClassOffset;        // always valid offset
    };

} PHONEGETID_PARAMS, *PPHONEGETID_PARAMS;


typedef struct _PHONEGETLAMP_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwButtonLampID;
    };

    union
    {
        OUT DWORD       dwLampMode;
    };

} PHONEGETLAMP_PARAMS, *PPHONEGETLAMP_PARAMS;


typedef struct _PHONEGETRING_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        OUT DWORD       dwRingMode;
    };

    union
    {
        OUT DWORD       dwVolume;
    };

} PHONEGETRING_PARAMS, *PPHONEGETRING_PARAMS;


typedef struct _PHONEGETSTATUS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE       hPhone;
    };

    union
    {
        IN  DWORD       dwPhoneStatusTotalSize;     // size of client buffer
        OUT DWORD       dwPhoneStatusOffset;        // valid offset on success
    };

} PHONEGETSTATUS_PARAMS, *PPHONEGETSTATUS_PARAMS;


typedef struct _PHONEGETSTATUSMESSAGES_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        OUT DWORD       dwPhoneStates;
    };

    union
    {
        OUT DWORD       dwButtonModes;
    };

    union
    {
        OUT DWORD       dwButtonStates;
    };

} PHONEGETSTATUSMESSAGES_PARAMS, *PPHONEGETSTATUSMESSAGES_PARAMS;


typedef struct _PHONEGETVOLUME_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwHookSwitchDev;
    };

    union
    {
        OUT DWORD       dwVolume;
    };

} PHONEGETVOLUME_PARAMS, *PPHONEGETVOLUME_PARAMS;


typedef struct _PHONEINITIALIZE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        OUT HPHONEAPP   hPhoneApp;
    };

    union
    {
        IN  DWORD       hInstance;
    };

    union
    {
        IN  DWORD       InitContext;
    };

    union
    {
        IN  DWORD       dwFriendlyNameOffset;       // always valid offset
    };

    union
    {
        OUT DWORD       dwNumDevs;
    };

    union
    {
        IN  DWORD       dwModuleNameOffset;         // always valid offset
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

} PHONEINITIALIZE_PARAMS, *PPHONEINITIALIZE_PARAMS;


typedef struct _PHONENEGOTIATEAPIVERSION_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONEAPP   hPhoneApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAPILowVersion;
    };

    union
    {
        IN  DWORD       dwAPIHighVersion;
    };

    union
    {
        OUT DWORD       dwAPIVersion;
    };

    union
    {
        OUT DWORD       dwExtensionIDOffset;        // valid offset if success
    };

    union
    {
        IN OUT DWORD    dwSize;
    };

} PHONENEGOTIATEAPIVERSION_PARAMS, *PPHONENEGOTIATEAPIVERSION_PARAMS;


typedef struct _PHONENEGOTIATEEXTVERSION_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONEAPP   hPhoneApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwExtLowVersion;
    };

    union
    {
        IN  DWORD       dwExtHighVersion;
    };

    union
    {
        OUT DWORD       dwExtVersion;
    };

} PHONENEGOTIATEEXTVERSION_PARAMS, *PPHONENEGOTIATEEXTVERSION_PARAMS;


typedef struct _PHONEOPEN_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONEAPP   hPhoneApp;
    };

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        OUT HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwAPIVersion;
    };

    union
    {
        IN  DWORD       dwExtVersion;
    };

    DWORD               OpenContext;

    union
    {
        IN  DWORD       dwPrivilege;
    };

    //
    // The following is a "remote phone handle".  When the client is
    // remotesp.tsp running on a remote machine, this will be some
    // non-NULL value, and tapisrv should use this handle in status/etc
    // indications to the client rather than the std hPhone. If the
    // client is not remote.tsp thne this value will be NULL.
    //

    union
    {
        IN  HPHONE      hRemotePhone;
    };

} PHONEOPEN_PARAMS, *PPHONEOPEN_PARAMS;


typedef struct _PHONESELECTEXTVERSION_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwExtVersion;
    };

} PHONESELECTEXTVERSION_PARAMS, *PPHONESELECTEXTVERSION_PARAMS;


typedef struct _PHONESETBUTTONINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwButtonLampID;
    };

    union
    {
        IN  DWORD       dwButtonInfoOffset;         // always valid offset
    };

} PHONESETBUTTONINFO_PARAMS, *PPHONESETBUTTONINFO_PARAMS;


typedef struct _PHONESETDATA_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwDataID;
    };

    union
    {
        IN  DWORD       dwDataOffset;               // always valid offset
    };

    union
    {
        IN  DWORD       dwSize;
    };

} PHONESETDATA_PARAMS, *PPHONESETDATA_PARAMS;


typedef struct _PHONESETDISPLAY_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwRow;
    };

    union
    {
        IN  DWORD       dwColumn;
    };

    union
    {
        IN  DWORD       dwDisplayOffset;            // always valid offset
    };

    union
    {
        IN  DWORD       dwSize;
    };

} PHONESETDISPLAY_PARAMS, *PPHONESETDISPLAY_PARAMS;


typedef struct _PHONESETGAIN_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwHookSwitchDev;
    };

    union
    {
        IN  DWORD       dwGain;
    };

} PHONESETGAIN_PARAMS, *PPHONESETGAIN_PARAMS;


typedef struct _PHONESETHOOKSWITCH_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwHookSwitchDevs;
    };

    union
    {
        IN  DWORD       dwHookSwitchMode;
    };

} PHONESETHOOKSWITCH_PARAMS, *PPHONESETHOOKSWITCH_PARAMS;


typedef struct _PHONESETLAMP_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwButtonLampID;
    };

    union
    {
        IN  DWORD       dwLampMode;
    };

} PHONESETLAMP_PARAMS, *PPHONESETLAMP_PARAMS;


typedef struct _PHONESETRING_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwRingMode;
    };

    union
    {
        IN  DWORD       dwVolume;
    };

} PHONESETRING_PARAMS, *PPHONESETRING_PARAMS;


typedef struct _PHONESETSTATUSMESSAGES_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwPhoneStates;
    };

    union
    {
        IN  DWORD       dwButtonModes;
    };

    union
    {
        IN  DWORD       dwButtonStates;
    };

} PHONESETSTATUSMESSAGES_PARAMS, *PPHONESETSTATUSMESSAGES_PARAMS;


typedef struct _PHONESETVOLUME_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwRemoteRequestID;
    };

    union
    {
        IN  HPHONE      hPhone;
    };

    union
    {
        IN  DWORD       dwHookSwitchDev;
    };

    union
    {
        IN  DWORD       dwVolume;
    };

} PHONESETVOLUME_PARAMS, *PPHONESETVOLUME_PARAMS;


typedef struct _PHONESHUTDOWN_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HPHONEAPP   hPhoneApp;
    };

} PHONESHUTDOWN_PARAMS, *PPHONESHUTDOWN_PARAMS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\loc_comn.h ===
/****************************************************************************
 
  Copyright (c) 1995-1999 Microsoft Corporation
                                                              
  Module Name:  loc_comn.h
                                                              
****************************************************************************/

#ifndef __LOC_COMN_H_
#define __LOC_COMN_H_

#ifndef UNICODE

// For ANSI we need wrappers that will call the A version of the given function
// and then convert the return result to Unicode

LONG TAPIRegQueryValueExW(
                           HKEY hKey,
                           const TCHAR *SectionName,
                           LPDWORD lpdwReserved,
                           LPDWORD lpType,
                           LPBYTE  lpData,
                           LPDWORD lpcbData
                          );

LONG TAPIRegSetValueExW(
                         HKEY    hKey,
                         const TCHAR    *SectionName,
                         DWORD   dwReserved,
                         DWORD   dwType,
                         LPBYTE  lpData,
                         DWORD   cbData
                        );

int TAPILoadStringW(
                HINSTANCE hInst,
                UINT      uID,
                PWSTR     pBuffer,
                int       nBufferMax
               );

HINSTANCE TAPILoadLibraryW(
                PWSTR     pszLibraryW
               );

BOOL WINAPI TAPIIsBadStringPtrW( LPCWSTR lpsz, UINT cchMax );


#else // UNICODE is defined

// For Unicode we already get the correct return type so don't call the wrappers.

#define TAPIRegQueryValueExW    RegQueryValueExW
#define TAPIRegSetValueExW      RegSetValueExW
#define TAPILoadStringW         LoadStringW
#define TAPILoadLibraryW        LoadLibraryW
#define TAPIIsBadStringPtrW     IsBadStringPtrW

#endif  // !UNICODE


//***************************************************************************
#define LOCATION_USETONEDIALING        0x00000001
#define LOCATION_USECALLINGCARD        0x00000002
#define LOCATION_HASCALLWAITING        0x00000004
#define LOCATION_ALWAYSINCLUDEAREACODE 0x00000008


//***************************************************************************
//***************************************************************************
//***************************************************************************
#define CHANGEDFLAGS_CURLOCATIONCHANGED      0x00000001
#define CHANGEDFLAGS_REALCHANGE              0x00000002
#define CHANGEDFLAGS_TOLLLIST                0x00000004


//***************************************************************************
//***************************************************************************
//***************************************************************************
//
// These bits decide which params TAPISRV will check on READLOCATION and
// WRITELOCATION operations
//
#define CHECKPARMS_DWHLINEAPP       0x00000001
#define CHECKPARMS_DWDEVICEID       0x00000002
#define CHECKPARMS_DWAPIVERSION     0x00000004
#define GET_CURRENTLOCATION         0x00000008
#define GET_NUMLOCATIONS            0x00000010
#define CHECKPARMS_ONLY             0x00000020

//***************************************************************************
//***************************************************************************
//***************************************************************************
#define DWTOTALSIZE  0
#define DWNEEDEDSIZE 1
#define DWUSEDSIZE   2


//***************************************************************************
#define RULE_APPLIESTOALLPREFIXES   0x00000001
#define RULE_DIALAREACODE           0x00000002
#define RULE_DIALNUMBER             0x00000004



//***************************************************************************
//
// Structures used to pass location & area code rule info Client <--> TAPISRV
//
typedef struct 
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    
    DWORD       dwCurrentLocationID;
    DWORD       dwNumLocationsAvailable;

    DWORD       dwNumLocationsInList;
    DWORD       dwLocationListSize;
    DWORD       dwLocationListOffset;
    
} LOCATIONLIST,  *PLOCATIONLIST;

typedef struct
{
    DWORD       dwUsedSize;
    DWORD       dwPermanentLocationID;
    DWORD       dwCountryCode;
    DWORD       dwCountryID;
    DWORD       dwPreferredCardID;
    DWORD       dwOptions;

    DWORD       dwLocationNameSize;
    DWORD       dwLocationNameOffset;           // offset is relative to LOCATION struct
    
    DWORD       dwAreaCodeSize;
    DWORD       dwAreaCodeOffset;               // offset is relative to LOCATION struct

    DWORD       dwLongDistanceCarrierCodeSize;
    DWORD       dwLongDistanceCarrierCodeOffset; // offset is relative to LOCATION struct

    DWORD       dwInternationalCarrierCodeSize;
    DWORD       dwInternationalCarrierCodeOffset; // offset is relative to LOCATION struct

    DWORD       dwLocalAccessCodeSize;
    DWORD       dwLocalAccessCodeOffset;        // offset is relative to LOCATION struct
    
    DWORD       dwLongDistanceAccessCodeSize;
    DWORD       dwLongDistanceAccessCodeOffset; // offset is relative to LOCATION struct

    DWORD       dwCancelCallWaitingSize;
    DWORD       dwCancelCallWaitingOffset;      // offset is relative to LOCATION struct

    DWORD       dwNumAreaCodeRules;
    DWORD       dwAreaCodeRulesListSize;
    DWORD       dwAreaCodeRulesListOffset;      // offset is relative to LOCATION struct
    

} LOCATION, * PLOCATION;

typedef struct                       
{                                                
    DWORD       dwOptions;                       
                                                 
    DWORD       dwAreaCodeSize;                  
    DWORD       dwAreaCodeOffset;               // offset is relative to enclosing LOCATION struct     
                                                 
    DWORD       dwNumberToDialSize;           
    DWORD       dwNumberToDialOffset;           // offset is relative to enclosing LOCATION struct
                                                 
    DWORD       dwPrefixesListSize;             
    DWORD       dwPrefixesListOffset;           // offset is relative to enclosing LOCATION struct           
                                                 
                                                 
} AREACODERULE, * PAREACODERULE;   


#endif // __LOC_COMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\tapiaud.h ===
/*++

    Copyright (c) 1997 Microsoft Corporation

Module Name:

    tapiaud.h

Abstract:

    This module contains the definition of interfaces to the audio related
    filters.

Author:

    Mu Han (muhan) May-15-1999

--*/

#ifndef __tapiaud_h__
#define __tapiaud_h__

#include <mmreg.h>
#include <dsound.h>
#include "tapiqc.h"


// CLSIDs for the audio filters

struct DECLSPEC_UUID("581d09e5-0b45-11d3-a565-00c04f8ef6e3") TAPIAudioCapture;
struct DECLSPEC_UUID("8d5c6cb6-0b44-4a5a-b785-44c366d4e677") TAPIAudioEncoder;
struct DECLSPEC_UUID("65439c20-604f-49ca-aa82-dc01a10af171") TAPIAudioDecoder;
struct DECLSPEC_UUID("ad4e63da-c3ef-408f-8153-0fc7d5c29f72") TAPIAudioMixer;
struct DECLSPEC_UUID("44a3b142-cf81-42ea-b4d1-f43dd6f64ece") TAPIAudioRender;

struct DECLSPEC_UUID("3878e189-cfb5-4e75-bd92-3686ee6e6634") TAPIAudioPluginDecoder;

struct DECLSPEC_UUID("613ebf9e-c765-446f-bf96-7728ce579282") TAPIAudioDuplexController;

// It is really bad that we had to do this here.
struct DECLSPEC_UUID("b0210783-89cd-11d0-af08-00a0c925cd16") IDirectSoundNotify;
struct DECLSPEC_UUID("279AFA83-4981-11CE-A521-0020AF0BE560") IDirectSound;
struct DECLSPEC_UUID("C50A7E93-F395-4834-9EF6-7FA99DE50966") IDirectSound8;
struct DECLSPEC_UUID("b0210781-89cd-11d0-af08-00a0c925cd16") IDirectSoundCapture;
struct DECLSPEC_UUID("b0210782-89cd-11d0-af08-00a0c925cd16") IDirectSoundCaptureBuffer;
struct DECLSPEC_UUID("279AFA85-4981-11CE-A521-0020AF0BE560") IDirectSoundBuffer;


// the data structure to describe a audio device.
typedef interface tagAudioDeviceInfo
{
    UINT    WaveID;
    GUID    DSoundGUID;
	WCHAR   szDeviceDescription[MAX_PATH];

} AudioDeviceInfo, *PAudioDeviceInfo;


// device enumeration functions exposed by the tapi audio capture dll.
typedef HRESULT (WINAPI *PFNAudioGetDeviceInfo)(
    OUT DWORD * pdwNumDevices,
    OUT AudioDeviceInfo ** ppDeviceInfo
    );

typedef HRESULT (WINAPI *PFNAudioReleaseDeviceInfo)(
    IN AudioDeviceInfo * ppDeviceInfo
    );


// This interface is supported by the duplex controller. It only supports 
// dsound now.
typedef enum EFFECTS
{
    EFFECTS_AEC = 0,
    EFFECTS_AGC,
    EFFECTS_NS,
    EFFECTS_LAST

} EFFECTS;

interface DECLSPEC_UUID("864551a0-a822-48d7-a193-ddaa1c43d242") DECLSPEC_NOVTABLE 
IAudioDuplexController : public IUnknown
{
    STDMETHOD (SetCaptureBufferInfo) (
        IN  GUID *          pDSoundCaptureGUID,
        IN  DSCBUFFERDESC * pDescription
        ) PURE;

    STDMETHOD (SetRenderBufferInfo) (
        IN  GUID *          pDSoundRenderGUID,
        IN  DSBUFFERDESC *  pDescription,
        IN  HWND            hWindow,
        IN  DWORD           dwCooperateLevel
        ) PURE;

    STDMETHOD (EnableEffects) (
        IN  DWORD           dwNumberEffects,
        IN  EFFECTS *       pEffects,
        IN  BOOL *          pfEnable
        );

    STDMETHOD (GetCaptureDevice) (
        LPLPDIRECTSOUNDCAPTURE        ppDSoundCapture,
        LPLPDIRECTSOUNDCAPTUREBUFFER  ppCaptureBuffer
        ) PURE;

    STDMETHOD (GetRenderDevice) (
        LPLPDIRECTSOUND        ppDirectSound,
        LPLPDIRECTSOUNDBUFFER  ppRenderBuffer
        ) PURE;

    STDMETHOD (ReleaseCaptureDevice) () PURE;

    STDMETHOD (ReleaseRenderDevice) () PURE;

    STDMETHOD (GetEffect) (
        IN EFFECTS Effect,
        OUT BOOL *pfEnabled
        );
};


// the device configuration interface on teh tapi audio capture filter.
interface DECLSPEC_UUID("3a12e2c1-1265-11d3-a56d-00c04f8ef6e3") DECLSPEC_NOVTABLE 
IAudioDeviceConfig : public IUnknown
{
    STDMETHOD (SetDeviceID) (
        IN  REFGUID pDSoundGUID,
        IN  UINT    uiWaveID
        ) PURE;

    STDMETHOD (SetDuplexController) (
        IN  IAudioDuplexController * pIAudioDuplexController
        ) PURE;
};

#if !defined(STREAM_INTERFACES_DEFINED)

typedef enum tagAudioDeviceProperty
{
    AudioDevice_DuplexMode,
    AudioDevice_AutomaticGainControl,
    AudioDevice_AcousticEchoCancellation

} AudioDeviceProperty;

#endif

// IAudioDeviceControl interface.
interface DECLSPEC_UUID("3a12e2c2-1265-11d3-a56d-00c04f8ef6e3") DECLSPEC_NOVTABLE 
IAudioDeviceControl : public IUnknown
{
    STDMETHOD (GetRange) (
        IN AudioDeviceProperty Property, 
        OUT long *plMin, 
        OUT long *plMax, 
        OUT long *plSteppingDelta, 
        OUT long *plDefault, 
        OUT TAPIControlFlags *plFlags
        ) PURE;

    STDMETHOD (Get) (
        IN AudioDeviceProperty Property, 
        OUT long *plValue, 
        OUT TAPIControlFlags *plFlags
        ) PURE;

    STDMETHOD (Set) (
        IN AudioDeviceProperty Property, 
        IN long lValue, 
        IN TAPIControlFlags lFlags
        ) PURE;
};

// IAudioAutoPlay interface
interface DECLSPEC_UUID("c5e7c28f-1446-4ebe-b7fc-72f599a72663")  DECLSPEC_NOVTABLE
IAudioAutoPlay : public IUnknown
{
    STDMETHOD (StartAutoPlay) (IN BOOL fRun) PURE;

    STDMETHOD (StopAutoPlay) () PURE;
};

// IAudioEffectControl interface
interface DECLSPEC_UUID("8eb9f108-3447-4fee-a705-6c6cf35c660c")  DECLSPEC_NOVTABLE
IAudioEffectControl : public IUnknown
{
    // if enabled and AEC, use DSound AGC
    STDMETHOD (SetDsoundAGC) (IN BOOL fEnable) PURE;

    // if enabled and no AEC, revert gain to previous volume
    STDMETHOD (SetGainIncRevert) (IN BOOL fEnable) PURE;

    STDMETHOD (SetFixedMixLevel) (IN DOUBLE dLevel) PURE;
};

// IBasicAudioEx interface
interface DECLSPEC_UUID("9c31055a-24bd-4ac1-be2b-ebe7ce89890c")  DECLSPEC_NOVTABLE
IBasicAudioEx : public IUnknown
{
    STDMETHOD (SetMute) (IN BOOL fMute) PURE;
    STDMETHOD (GetMute) (OUT LPBOOL pfMute) PURE;
};

// IAudioDTMFControl interface
interface DECLSPEC_UUID("dd1f3c26-5524-4d77-9fb2-7df5d62ffd87")  DECLSPEC_NOVTABLE
IAudioDTMFControl : public IUnknown
{
    STDMETHOD (SendDTMFEvent) (
        IN DWORD dwEvent
        ) PURE;
};

// IAudioStatistics
interface DECLSPEC_UUID("20fc7641-f3b2-4384-96ad-bf3d986e8751")  DECLSPEC_NOVTABLE
IAudioStatistics : public IUnknown
{
    STDMETHOD (GetAudioLevel) (OUT LPLONG plAudioLevel) PURE;
    STDMETHOD (GetAudioLevelRange) (
        OUT LPLONG plMin,
        OUT LPLONG plMax
        ) PURE;
};

// ISilenceControl interface
interface DECLSPEC_UUID("8804b7e4-2ef4-489f-a31b-740ac4278304")  DECLSPEC_NOVTABLE
ISilenceControl : public IUnknown
{
    STDMETHOD (SetSilenceDetection) (IN BOOL fEnable) PURE;
    STDMETHOD (GetSilenceDetection) (OUT LPBOOL pfEnable) PURE;

    STDMETHOD (SetSilenceCompression) (IN BOOL fEnable) PURE;
    STDMETHOD (GetSilenceCompression) (OUT LPBOOL pfEnable) PURE;

    STDMETHOD (GetAudioLevel) (
        OUT LPLONG plAudioLevel
        ) PURE;

    STDMETHOD (GetAudioLevelRange) (
        OUT LPLONG plMin, 
        OUT LPLONG plMax, 
        OUT LPLONG plSteppingDelta
        ) PURE;

    STDMETHOD (SetSilenceLevel) (
        IN LONG lSilenceLevel,
        IN TAPIControlFlags lFlags
        ) PURE;

    STDMETHOD (GetSilenceLevel) (
        OUT LPLONG plSilenceLevel,
        OUT TAPIControlFlags * pFlags
        ) PURE;

    STDMETHOD (GetSilenceLevelRange) (
        OUT LPLONG plMin, 
        OUT LPLONG plMax, 
        OUT LPLONG plSteppingDelta, 
        OUT LPLONG plDefault,
        OUT TAPIControlFlags * pFlags
        ) PURE;
};

#define VAD_EVENTBASE (100000)

// events for voice activity detection.
typedef enum VAD_EVENT
{
    VAD_TALKING,
    VAD_SILENCE

} VAD_EVENT;

#ifndef WAVEFORMATEX_RTPG711
typedef struct {
	// Generic WAVEFORMATEX fields
	WAVEFORMATEX WaveFormatEx;

	// network specific field
	WORD wPacketDuration;

	// Reserved
	DWORD dwReserved[2];
} WAVEFORMATEX_RTPG711, *PWAVEFORMATEX_RTPG711;
#endif

#ifndef WAVEFORMATEX_RTPG723_1
typedef struct {
	// Generic WAVEFORMATEX fields
	WAVEFORMATEX WaveFormatEx;

	// network specific field
	WORD wPacketDuration;

	// Variable bitrate specific field
	WORD wSamplesPerBlock;

	// G.723.1 specific fields
	WORD fSilenceDetection:1;
	WORD fSilenceCompression:1;
	WORD fLowDataRate:1;
	WORD fReserved:13;

	// Reserved
	DWORD dwReserved[2];
} WAVEFORMATEX_RTPG723_1, *PWAVEFORMATEX_RTPG723_1;
#endif

#ifndef WAVEFORMATEX_RTPDVI4
typedef struct {
	// Generic WAVEFORMATEX fields
	WAVEFORMATEX WaveFormatEx;

	// network specific field
	WORD wPacketDuration;

} WAVEFORMATEX_RTPDVI4, *PWAVEFORMATEX_RTPDVI4;
#endif

#ifndef WAVEFORMATEX_RTPSIREN

/* WAVE form wFormatTag IDs (mmreg.h defines most of the tags) */
#define WAVE_FORMAT_SIREN 0x3001

typedef struct {
	// Generic WAVEFORMATEX fields
	WAVEFORMATEX WaveFormatEx;

	// network specific field
	WORD wPacketDuration;

} WAVEFORMATEX_RTPSIREN, *PWAVEFORMATEX_RTPSIREN;
#endif

#ifndef WAVEFORMATEX_RTPG722_1

#define WAVE_FORMAT_G722_1 0x3002

typedef struct {
	// Generic WAVEFORMATEX fields
	WAVEFORMATEX WaveFormatEx;

	// network specific field
	WORD wPacketDuration;

} WAVEFORMATEX_RTPG722_1, *PWAVEFORMATEX_RTPG722_1;
#endif


#ifndef WAVEFORMATEX_RTPMSAUDIO
typedef struct {
	// Generic WAVEFORMATEX fields
	WAVEFORMATEX WaveFormatEx;

	// network specific field
	WORD wPacketDuration;

} WAVEFORMATEX_RTPMSAUDIO, *PWAVEFORMATEX_RTPMSAUDIO;
#endif

#ifndef WAVEFORMATEX_RTPGSM
typedef struct {
	// Generic WAVEFORMATEX fields
	WAVEFORMATEX WaveFormatEx;

	// network specific field
	WORD wPacketDuration;

    BOOL fMbone;

} WAVEFORMATEX_RTPGSM, *PWAVEFORMATEX_RTPGSM;
#endif


// IEncoderSampleRateControl, a private interface for the test team.
interface DECLSPEC_UUID("483f56a9-513f-4f8b-b0e5-bc6a7ba3f8b9")  DECLSPEC_NOVTABLE
IEncoderSampleRateControl : public IUnknown
{
    STDMETHOD (GetSampleRate) (OUT DWORD *pdwSampleRate) PURE;
    STDMETHOD (SetSampleRate) (IN DWORD dwSampleRate) PURE;
};


#endif //__tapiaud_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\server.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    server.h

Abstract:

    Header file for tapi server & client

Author:

    Dan Knudson (DanKn)    01-Apr-1995

Revision History:

--*/


#include "rmotsp.h"
#include "tapiclnt.h"
#include "tlnklist.h"
#include "tapievt.h"

#ifdef __cplusplus
extern "C" {
#endif

#define INVAL_KEY                   ((DWORD) 'LVNI')
#define TCALL_KEY                   ((DWORD) 'LLAC')
#define TINCOMPLETECALL_KEY         ((DWORD) 'LACI')
#define TZOMBIECALL_KEY             ((DWORD) 'LACZ')
#define TCALLCLIENT_KEY             ((DWORD) 'ILCC')
#define TCALLHUBCLIENT_KEY          ((DWORD) 'CBUH')
#define TINCOMPLETECALLCLIENT_KEY   ((DWORD) 'LCCI')
#define TLINE_KEY                   ((DWORD) 'ENIL')
#define TINCOMPLETELINE_KEY         ((DWORD) 'NILI')
#define TLINECLIENT_KEY             ((DWORD) 'ILCL')
#define TPHONE_KEY                  ((DWORD) 'NOHP')
#define TINCOMPLETEPHONE_KEY        ((DWORD) 'OHPI')
#define TPHONECLIENT_KEY            ((DWORD) 'ILCP')
#define TLINEAPP_KEY                ((DWORD) 'PPAL')
#define TPHONEAPP_KEY               ((DWORD) 'PPAP')
#define TCLIENT_KEY                 ((DWORD) 'TNLC')
#define TCLIENTCLEANUP_KEY          ((DWORD) 'CNLC')
#define TZOMBIECLIENT_KEY           ((DWORD) 'ZNLC')
#define TPROVIDER_KEY               ((DWORD) 'VORP')
#define TASYNC_KEY                  ((DWORD) 'CYSA')
#define TDLGINST_KEY                ((DWORD) 'GOLD')
#define TCONFLIST_KEY               ((DWORD) 'FNOC')
#define RSP_MSG                     ((DWORD)'RXYQ')
#define RSP_CALLPARAMS              0xFEDC

#ifdef _WIN64
#define TALIGN_MASK                 0xfffffff8
#define TALIGN_COUNT                7
#else
#define TALIGN_MASK                 0xfffffffc
#define TALIGN_COUNT                3
#endif
#define ALIGN(a)                    (((a)+TALIGN_COUNT)&TALIGN_MASK)
#define ALIGNED(a)                  (0 == ((a)&TALIGN_COUNT))

#define INITIAL_EVENT_BUFFER_SIZE   1024

#define DEF_NUM_LOOKUP_ENTRIES      16
#define DEF_NUM_CONF_LIST_ENTRIES   4
#define DEF_NUM_PTR_LIST_ENTRIES    8

#define LINEPROXYREQUEST_LASTVALUE  LINEPROXYREQUEST_SETAGENTSTATEEX

#define BOGUS_REQUEST_ID            0x7fffffff

#define DCF_SPIRETURNED             0x00000001
#define DCF_DRVCALLVALID            0x00000002
#define DCF_CREATEDINITIALMONITORS  0x00000004
#define DCF_INCOMINGCALL            0x00010000

#define SYNC_REQUESTS_ALL           0
#define SYNC_REQUESTS_PER_WIDGET    1
#define SYNC_REQUESTS_NONE          2

#define SP_NONE                     0xffffffff

#define DGCLIENT_TIMEOUT            1000        // milliseconds
#define DGCLIENTDISCONNECT_TIMEOUT  (5*60*1000) // milliseconds

#define SP_LINEACCEPT                       0
#define SP_LINEADDTOCONFERENCE              1
#define SP_LINEAGENTSPECIFIC                2
#define SP_LINEANSWER                       3
#define SP_LINEBLINDTRANSFER                4
#define SP_LINECLOSE                        5
#define SP_LINECLOSECALL                    6
#define SP_LINECOMPLETECALL                 7
#define SP_LINECOMPLETETRANSFER             8
#define SP_LINECONDITIONALMEDIADETECTION    9
#define SP_LINEDEVSPECIFIC                  10
#define SP_LINEDEVSPECIFICFEATURE           11
#define SP_LINEDIAL                         12
#define SP_LINEDROP                         13
#define SP_LINEFORWARD                      14
#define SP_LINEGATHERDIGITS                 15
#define SP_LINEGENERATEDIGITS               16
#define SP_LINEGENERATETONE                 17
#define SP_LINEGETADDRESSCAPS               18
#define SP_LINEGETADDRESSID                 19
#define SP_LINEGETADDRESSSTATUS             20
#define SP_LINEGETAGENTACTIVITYLIST         21
#define SP_LINEGETAGENTCAPS                 22
#define SP_LINEGETAGENTGROUPLIST            23
#define SP_LINEGETAGENTSTATUS               24
#define SP_LINEGETCALLADDRESSID             25
#define SP_LINEGETCALLINFO                  26
#define SP_LINEGETCALLSTATUS                27
#define SP_LINEGETDEVCAPS                   28
#define SP_LINEGETDEVCONFIG                 29
#define SP_LINEGETEXTENSIONID               30
#define SP_LINEGETICON                      31
#define SP_LINEGETID                        32
#define SP_LINEGETLINEDEVSTATUS             33
#define SP_LINEGETNUMADDRESSIDS             34
#define SP_LINEHOLD                         35
#define SP_LINEMAKECALL                     36
#define SP_LINEMONITORDIGITS                37
#define SP_LINEMONITORMEDIA                 38
#define SP_LINEMONITORTONES                 39
#define SP_LINENEGOTIATEEXTVERSION          40
#define SP_LINENEGOTIATETSPIVERSION         41
#define SP_LINEOPEN                         42
#define SP_LINEPARK                         43
#define SP_LINEPICKUP                       44
#define SP_LINEPREPAREADDTOCONFERENCE       45
#define SP_LINEREDIRECT                     46
#define SP_LINERELEASEUSERUSERINFO          47
#define SP_LINEREMOVEFROMCONFERENCE         48
#define SP_LINESECURECALL                   49
#define SP_LINESELECTEXTVERSION             50
#define SP_LINESENDUSERUSERINFO             51
#define SP_LINESETAGENTACTIVITY             52
#define SP_LINESETAGENTGROUP                53
#define SP_LINESETAGENTSTATE                54
#define SP_LINESETAPPSPECIFIC               55
#define SP_LINESETCALLDATA                  56
#define SP_LINESETCALLPARAMS                57
#define SP_LINESETCALLQUALITYOFSERVICE      58
#define SP_LINESETCALLTREATMENT             59
#define SP_LINESETCURRENTLOCATION           60
#define SP_LINESETDEFAULTMEDIADETECTION     61
#define SP_LINESETDEVCONFIG                 62
#define SP_LINESETLINEDEVSTATUS             63
#define SP_LINESETMEDIACONTROL              64
#define SP_LINESETMEDIAMODE                 65
#define SP_LINESETSTATUSMESSAGES            66
#define SP_LINESETTERMINAL                  67
#define SP_LINESETUPCONFERENCE              68
#define SP_LINESETUPTRANSFER                69
#define SP_LINESWAPHOLD                     70
#define SP_LINEUNCOMPLETECALL               71
#define SP_LINEUNHOLD                       72
#define SP_LINEUNPARK                       73
#define SP_PHONECLOSE                       74
#define SP_PHONEDEVSPECIFIC                 75
#define SP_PHONEGETBUTTONINFO               76
#define SP_PHONEGETDATA                     77
#define SP_PHONEGETDEVCAPS                  78
#define SP_PHONEGETDISPLAY                  79
#define SP_PHONEGETEXTENSIONID              80
#define SP_PHONEGETGAIN                     81
#define SP_PHONEGETHOOKSWITCH               82
#define SP_PHONEGETICON                     83
#define SP_PHONEGETID                       84
#define SP_PHONEGETLAMP                     85
#define SP_PHONEGETRING                     86
#define SP_PHONEGETSTATUS                   87
#define SP_PHONEGETVOLUME                   88
#define SP_PHONENEGOTIATEEXTVERSION         89
#define SP_PHONENEGOTIATETSPIVERSION        90
#define SP_PHONEOPEN                        91
#define SP_PHONESELECTEXTVERSION            92
#define SP_PHONESETBUTTONINFO               93
#define SP_PHONESETDATA                     94
#define SP_PHONESETDISPLAY                  95
#define SP_PHONESETGAIN                     96
#define SP_PHONESETHOOKSWITCH               97
#define SP_PHONESETLAMP                     98
#define SP_PHONESETRING                     99
#define SP_PHONESETSTATUSMESSAGES           100
#define SP_PHONESETVOLUME                   101
#define SP_PROVIDERCREATELINEDEVICE         102
#define SP_PROVIDERCREATEPHONEDEVICE        103
#define SP_PROVIDERENUMDEVICES              104
#define SP_PROVIDERFREEDIALOGINSTANCE       105
#define SP_PROVIDERGENERICDIALOGDATA        106
#define SP_PROVIDERINIT                     107
#define SP_PROVIDERSHUTDOWN                 108
#define SP_PROVIDERUIIDENTIFY               109
#define SP_LINEMSPIDENTIFY                  110
#define SP_LINERECEIVEMSPDATA               111
#define SP_PROVIDERCHECKFORNEWUSER          112
#define SP_LINEGETCALLIDS                   113
#define SP_LINEGETCALLHUBTRACKING           114
#define SP_LINESETCALLHUBTRACKING           115
#define SP_PROVIDERPRIVATEFACTORYIDENTIFY   116
#define SP_LINEDEVSPECIFICEX                117
#define SP_LINECREATEAGENT                  118
#define SP_LINECREATEAGENTSESSION           119
#define SP_LINEGETAGENTINFO                 120
#define SP_LINEGETAGENTSESSIONINFO          121
#define SP_LINEGETAGENTSESSIONLIST          122
#define SP_LINEGETQUEUEINFO                 123
#define SP_LINEGETGROUPLIST                 124
#define SP_LINEGETQUEUELIST                 125
#define SP_LINESETAGENTMEASUREMENTPERIOD    126
#define SP_LINESETAGENTSESSIONSTATE         127
#define SP_LINESETQUEUEMEASUREMENTPERIOD    128
#define SP_LINESETAGENTSTATEEX              129
#define SP_LINEGETPROXYSTATUS               130
#define SP_LINECREATEMSPINSTANCE            131
#define SP_LINECLOSEMSPINSTANCE             132
#define SP_LASTPROCNUMBER                   (SP_LINECLOSEMSPINSTANCE + 1)


// TAPICLIENT api

#define TC_LOAD                             0
#define TC_FREE                             1
#define TC_CLIENTINITIALIZE                 2
#define TC_CLIENTSHUTDOWN                   3
#define TC_GETDEVICEACCESS                  4
#define TC_LINEADDTOCONFERENCE              5
#define TC_LINEBLINDTRANSFER                6
#define TC_LINECONFIGDIALOG                 7
#define TC_LINEDIAL                         8
#define TC_LINEFORWARD                      9
#define TC_LINEGENERATEDIGITS               10
#define TC_LINEMAKECALL                     11
#define TC_LINEOPEN                         12
#define TC_LINEREDIRECT                     13
#define TC_LINESETCALLDATA                  14
#define TC_LINESETCALLPARAMS                15
#define TC_LINESETCALLPRIVILEGE             16
#define TC_LINESETCALLTREATMENT             17
#define TC_LINESETCURRENTLOCATION           18
#define TC_LINESETDEVCONFIG                 19
#define TC_LINESETLINEDEVSTATUS             20
#define TC_LINESETMEDIACONTROL              21
#define TC_LINESETMEDIAMODE                 22
#define TC_LINESETTERMINAL                  23
#define TC_LINESETTOLLLIST                  24
#define TC_PHONECONFIGDIALOG                25
#define TC_PHONEOPEN                        26
#define TC_LASTPROCNUMBER                   TC_PHONEOPEN+1


#define myexcept except(EXCEPTION_EXECUTE_HANDLER)

#define CN_CLIENT ((ULONG_PTR) -1)
#define DG_CLIENT ((ULONG_PTR) -2)
#define MMC_CLIENT ((ULONG_PTR) -3)

#define IS_REMOTE_CLIENT(ptClient) \
            (((((ULONG_PTR) ptClient->hProcess) & DG_CLIENT) == DG_CLIENT) || \
            (ptClient->hProcess == (HANDLE) MMC_CLIENT))

#define IS_REMOTE_CN_CLIENT(ptClient) \
            (ptClient->hProcess == (HANDLE) CN_CLIENT)

#define IS_REMOTE_DG_CLIENT(ptClient) \
            (ptClient->hProcess == (HANDLE) DG_CLIENT)

#define IS_REMOTE_MMC_CLIENT(ptClient) \
            (ptClient->hProcess == (HANDLE) MMC_CLIENT)

#define SET_FLAG(dw,fl)     (dw) |= (fl)
#define RESET_FLAG(dw,fl)   (dw) &= ~(fl)
#define IS_FLAG_SET(dw,fl)  ((dw) & (fl))

typedef LONG (PASCAL *TSPIPROC)();
typedef LONG (PASCAL *CLIENTPROC)();

typedef struct _TPOINTERLIST
{
    DWORD                   dwNumUsedEntries;

    LPVOID                  aEntries[DEF_NUM_PTR_LIST_ENTRIES];

} TPOINTERLIST, *PTPOINTERLIST;


typedef struct _THASHTABLEENTRY
{
    DWORD                       dwCallHubID;
    LONG                        lCookie;
    LIST_ENTRY                  CallHubList;
    struct _TCALLHUBCLIENT     *ptCallHubClients;
    struct _THASHTABLEENTRY    *pNext;

} THASHTABLEENTRY, *PTHASHTABLEENTRY;


typedef struct _TPROVIDER
{
    DWORD                   dwKey;
    HANDLE                  hMutex;
    HINSTANCE               hDll;
    DWORD                   dwTSPIOptions;

    DWORD                   dwSPIVersion;
    DWORD                   dwPermanentProviderID;
    struct _TPROVIDER      *pPrev;
    struct _TPROVIDER      *pNext;

    DWORD                   dwNumHashTableEntries;
    DWORD                   dwNumDynamicHashTableEntries;
    PTHASHTABLEENTRY        pHashTable;
    LONG                    lHashTableReaderCount;

    HANDLE                  hHashTableReaderEvent;

    CRITICAL_SECTION        HashTableCritSec;

    TSPIPROC                apfn[SP_LASTPROCNUMBER];

    DWORD                   dwNameHash;
    TCHAR                   szFileName[1];

} TPROVIDER, *PTPROVIDER;


typedef struct _TCALLHUBCLIENT
{
    DWORD                   dwKey;
    struct _TCLIENT *       ptClient;
    PTPROVIDER              ptProvider;
    DWORD                   dwCallHubID;

    HCALLHUB                hCallHub;
    struct _TLINEAPP       *ptLineApp;
    struct _TCALLHUBCLIENT *pNext;

} TCALLHUBCLIENT, *PTCALLHUBCLIENT;


typedef struct _TCALLCLIENT
{
    DWORD                   dwKey;
    struct _TCLIENT        *ptClient;
    struct _TLINECLIENT    *ptLineClient;
    struct _TCALL          *ptCall;

    DWORD                   dwPrivilege;
    DWORD                   dwMonitorDigitModes;
    DWORD                   dwMonitorMediaModes;

    //
    // The following field is used to determine whether we need to
    // set or zero the LINE_CALLSTATE\dwParam3 parameter to indicate
    // a privilege change to the app
    //

    BYTE                    bIndicatePrivilege;
    BYTE                    bMonitoringTones;
    BYTE                    bUnused1;
    BYTE                    bUnused2;

    struct _TCALLCLIENT    *pPrevSametCall;
    struct _TCALLCLIENT    *pNextSametCall;
    struct _TCALLCLIENT    *pPrevSametLineClient;
    struct _TCALLCLIENT    *pNextSametLineClient;

    struct _TCALLHUBCLIENT *ptCallHubClient;
    DWORD                   hCall;
    DWORD                   adwEventSubMasks[EM_NUM_MASKS];

} TCALLCLIENT, *PTCALLCLIENT;


typedef struct _TCALL
{
    DWORD                   dwKey;
    PTCALLCLIENT            ptCallClients;
    struct _TLINE          *ptLine;
    PTPROVIDER              ptProvider;

    DWORD                   dwDrvCallFlags;
    BOOL                    bCreatedInitialMonitors;
    HDRVCALL                hdCall;
    HCALL                   hCall;

    DWORD                   dwAddressID;
    DWORD                   dwCallState;
    DWORD                   dwCallStateMode;
    DWORD                   dwNumOwners;

    DWORD                   dwNumMonitors;
    BOOL                    bAlertApps;
    DWORD                   dwAppNameSize;
    LPVOID                  pszAppName;

    DWORD                   dwDisplayableAddressSize;
    LPVOID                  pszDisplayableAddress;
    DWORD                   dwCalledPartySize;
    LPVOID                  pszCalledParty;

    DWORD                   dwCommentSize;
    LPVOID                  pszComment;
    struct _TCONFERENCELIST * pConfList;
    struct _TCALL          *pPrev;

    struct _TCALL          *pNext;
    DWORD                   dwCallID;
    DWORD                   dwRelatedCallID;

    LIST_ENTRY              CallHubList;

    #define DEF_NUM_FAST_CALLCLIENTS 2

    LONG                    lUsedFastCallClients;
    LONG                    lActiveFastCallClients;

    TCALLCLIENT             aFastCallClients[DEF_NUM_FAST_CALLCLIENTS];

} TCALL, *PTCALL;


typedef struct _TCONFERENCELIST
{
    DWORD                   dwKey;
    DWORD                   dwNumTotalEntries;
    DWORD                   dwNumUsedEntries;
    struct _TCONFERENCELIST *pNext;

    PTCALL                  aptCalls[1];

} TCONFERENCELIST, *PTCONFERENCELIST;


typedef struct _TLINE
{
    DWORD                   dwKey;
    HANDLE                  hMutex;
    struct _TLINECLIENT *   ptLineClients;
    LPVOID                  apProxys[LINEPROXYREQUEST_LASTVALUE+1];

    PTPROVIDER              ptProvider;
    HDRVLINE                hdLine;
    HLINE                   hLine;
    DWORD                   dwDeviceID;

    DWORD                   dwSPIVersion;
    DWORD                   dwExtVersion;
    DWORD                   dwExtVersionCount;
    DWORD                   dwNumAddresses;

    DWORD                   dwOpenMediaModes;
    DWORD                   dwNumOpens;
    DWORD                   dwUnionLineStates;
    DWORD                   dwUnionAddressStates;

    PTCALL                  ptCalls;
    DWORD                   dwNumCallHubTrackers;
    DWORD                   dwNumCallHubTrackersSPLevel;
    DWORD                   dwBusy;

} TLINE, *PTLINE;


typedef struct _TLINECLIENT
{
    DWORD                   dwKey;
    struct _TCLIENT *       ptClient;
    struct _TLINEAPP *      ptLineApp;
    DWORD                   hLine;

    PTLINE                  ptLine;
    DWORD                   dwAddressID;
    PTCALLCLIENT            ptCallClients;
    DWORD                   hRemoteLine;

    DWORD                   dwAPIVersion;
    DWORD                   dwPrivileges;
    DWORD                   dwMediaModes;
    DWORD                   OpenContext;    // was : DWORD dwCallbackInstance;
    DWORD                   dwLineStates;

    DWORD                   dwAddressStates;
    LPDWORD                 aNumRings;
    DWORD                   dwExtVersion;

    struct _TLINECLIENT    *pPrevSametLine;
    struct _TLINECLIENT    *pNextSametLine;
    struct _TLINECLIENT    *pPrevSametLineApp;
    struct _TLINECLIENT    *pNextSametLineApp;

    LPVOID                  pPendingProxyRequests;
    DWORD                   dwCurrentTracking;
    HDRVMSPLINE             hdMSPLine;
    LPTSTR                  szProxyClsid;

    DWORD                   adwEventSubMasks[EM_NUM_MASKS];

} TLINECLIENT, *PTLINECLIENT;


typedef struct _TPHONE
{
    DWORD                   dwKey;
    HANDLE                  hMutex;
    struct _TPHONECLIENT *  ptPhoneClients;
    PTPROVIDER              ptProvider;

    HDRVPHONE               hdPhone;
    HPHONE                  hPhone;
    DWORD                   dwDeviceID;
    DWORD                   dwSPIVersion;

    DWORD                   dwExtVersion;
    DWORD                   dwExtVersionCount;
    DWORD                   dwNumOwners;
    DWORD                   dwNumMonitors;

    DWORD                   dwUnionPhoneStates;
    DWORD                   dwUnionButtonModes;
    DWORD                   dwUnionButtonStates;
    DWORD                   dwBusy;

} TPHONE, *PTPHONE;


typedef struct _TPHONECLIENT
{
    DWORD                   dwKey;
    struct _TCLIENT *       ptClient;
    struct _TPHONEAPP *     ptPhoneApp;
    PTPHONE                 ptPhone;

    DWORD                   hRemotePhone;
    DWORD                   dwAPIVersion;
    DWORD                   dwExtVersion;
    DWORD                   dwPrivilege;

    DWORD                   OpenContext;    // was : DWORD dwCallbackInstance;
    DWORD                   dwPhoneStates;
    DWORD                   dwButtonModes;
    DWORD                   dwButtonStates;

    struct _TPHONECLIENT   *pPrevSametPhone;
    struct _TPHONECLIENT   *pNextSametPhone;
    struct _TPHONECLIENT   *pPrevSametPhoneApp;
    struct _TPHONECLIENT   *pNextSametPhoneApp;

    DWORD                   hPhone;
    DWORD                   adwEventSubMasks[EM_NUM_MASKS];

} TPHONECLIENT, *PTPHONECLIENT;


typedef struct _TLINEAPP
{
    DWORD                   dwKey;
    struct _TCLIENT *       ptClient;
    PTLINECLIENT            ptLineClients;
    DWORD                   hLineApp; 

    DWORD                   InitContext;    // was: LINECALLBACK lpfnCallback;
    struct _TLINEAPP       *pPrev;
    struct _TLINEAPP       *pNext;
    DWORD                   dwAPIVersion;

    DWORD                   bReqMediaCallRecipient;
    LPVOID                  pRequestRecipient;
    DWORD                   dwFriendlyNameSize;
    WCHAR                  *pszFriendlyName;

    DWORD                   adwEventSubMasks[EM_NUM_MASKS];

    DWORD                   dwModuleNameSize;
    WCHAR                  *pszModuleName;

} TLINEAPP, *PTLINEAPP;


typedef struct _TPHONEAPP
{
    DWORD                   dwKey;
    DWORD                   hPhoneApp;
    struct _TCLIENT *       ptClient;
    DWORD                   InitContext;    // was: PHONECALLBACK lpfnCallback;

    PTPHONECLIENT           ptPhoneClients;
    struct _TPHONEAPP      *pPrev;
    struct _TPHONEAPP      *pNext;
    WCHAR                  *pszFriendlyName;

    WCHAR                  *pszModuleName;
    DWORD                   dwAPIVersion;
    DWORD                   dwFriendlyNameSize;
    DWORD                   dwModuleNameSize;

    DWORD                   adwEventSubMasks[EM_NUM_MASKS];

} TPHONEAPP, *PTPHONEAPP;


typedef struct _TAPIDIALOGINSTANCE
{
    DWORD                   dwKey;
    struct _TCLIENT *       ptClient;
    DWORD                   dwPermanentProviderID;
    HINSTANCE               hTsp;

    TSPIPROC                pfnTSPI_providerGenericDialogData;
    PTPROVIDER              ptProvider;
    HDRVDIALOGINSTANCE      hdDlgInst;
    WCHAR                  *pszProviderFilename;

    DWORD                   bRemoveProvider;
    struct _TAPIDIALOGINSTANCE *pPrev;
    struct _TAPIDIALOGINSTANCE *pNext;

    HTAPIDIALOGINSTANCE     htDlgInst;

} TAPIDIALOGINSTANCE, *PTAPIDIALOGINSTANCE;


// management DLL client info
typedef struct _TMANAGEDLLINFO
{
    HINSTANCE               hDll;
    DWORD                   dwID;
    CLIENTPROC              aProcs[TC_LASTPROCNUMBER];
    LPWSTR                  pszName;
    DWORD                   dwAPIVersion;
    struct _TMANAGEDLLINFO  *pNext;

} TMANAGEDLLINFO, *PTMANAGEDLLINFO;


typedef struct _TCLIENTHANDLE
{
    HMANAGEMENTCLIENT       hClient;
    DWORD                   dwID;
    BOOL                    fValid;
    struct _TCLIENTHANDLE   *pNext;

} TCLIENTHANDLE, *PTCLIENTHANDLE;


typedef struct _TCLIENT
{
    DWORD                   dwKey;
    HANDLE                  hProcess;
    DWORD                   dwUserNameSize;
    WCHAR                  *pszUserName;

    DWORD                   dwComputerNameSize;
    WCHAR                  *pszComputerName;
    WCHAR                  *pszDomainName;
    PCONTEXT_HANDLE_TYPE2   phContext;

    PTCLIENTHANDLE          pClientHandles;
    HMANAGEMENTCLIENT       hMapper;
    LPTAPIPERMANENTID       pLineMap;
    LPDWORD                 pLineDevices;

    DWORD                   dwLineDevices;
    LPTAPIPERMANENTID       pPhoneMap;
    LPDWORD                 pPhoneDevices;
    DWORD                   dwPhoneDevices;

    union
    {
    HANDLE                  hValidEventBufferDataEvent;
    HANDLE                  hMailslot;
    };
    DWORD                   dwEventBufferTotalSize;
    DWORD                   dwEventBufferUsedSize;
    LPBYTE                  pEventBuffer;

    LPBYTE                  pDataIn;
    LPBYTE                  pDataOut;
    PTLINEAPP               ptLineApps;
    PTPHONEAPP              ptPhoneApps;

    PTAPIDIALOGINSTANCE     pProviderXxxDlgInsts;
    PTAPIDIALOGINSTANCE     pGenericDlgInsts;
    struct _TCLIENT        *pPrev;
    struct _TCLIENT        *pNext;

    DWORD                   dwFlags;
    LIST_ENTRY              MsgPendingListEntry;
    union
    {
    DWORD                   dwDgRetryTimeoutTickCount;
    DWORD                   dwCnBusy;
    };

    DWORD                   dwDgEventsRetrievedTickCount;

    DWORD                   htClient;

    DWORD                   adwEventSubMasks[EM_NUM_MASKS];
} TCLIENT, *PTCLIENT;
#define PTCLIENT_FLAG_ADMINISTRATOR     1
#define PTCLIENT_FLAG_SKIPFIRSTMESSAGE  2
#define PTCLIENT_FLAG_LOCKEDMMCWRITE    4


typedef struct _TREQUESTRECIPIENT
{
    PTLINEAPP               ptLineApp;
    DWORD                   dwRegistrationInstance;
    struct _TREQUESTRECIPIENT  *pPrev;
    struct _TREQUESTRECIPIENT  *pNext;

} TREQUESTRECIPIENT, *PTREQUESTRECIPIENT;

typedef void (*SRVPOSTPROCESSPROC)(LPVOID, LPVOID, LPVOID);


//WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
//DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY!
//DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY!
//DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY!
//
// The SPEVENT struct below must have the dwKey/dwType and ListEntry
// fields in the same relative place in the structure as ASYNCREQUESTINFO!
// Code in SERVER.C assumes this is an OK thing to do.
//
typedef struct _ASYNCREQUESTINFO
{
    DWORD                   dwKey;
    LIST_ENTRY              ListEntry;
    
    ULONG_PTR               htXxx;

    PTCLIENT                ptClient;
    LONG                    lResult;
    SRVPOSTPROCESSPROC      pfnPostProcess;
    DWORD                   dwLineFlags;

    DWORD                   InitContext;
    DWORD                   OpenContext;
    DWORD                   hfnClientPostProcessProc;
    DWORD                   dwLocalRequestID;

    DWORD                   dwRemoteRequestID;
    ULONG_PTR               dwParam1;
    ULONG_PTR               dwParam2;
    ULONG_PTR               dwParam3;
    ULONG_PTR               dwParam4;

    ULONG_PTR               dwParam5;

} ASYNCREQUESTINFO, *PASYNCREQUESTINFO;

enum {
        SP_LINE_EVENT = 1,
        SP_COMPLETION_EVENT,
        SP_PHONE_EVENT
     };


//DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY!
//DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY!
//
// (see above)
//
//DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY!
//DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY! DEPENDENCY!
typedef struct _SPEVENT
{
    DWORD                   dwType;
    LIST_ENTRY              ListEntry;

    union
    {
    HTAPILINE               htLine;
    HTAPIPHONE              htPhone;
    DWORD                   dwRequestID;
    };
    union
    {
    HTAPICALL               htCall;
    LONG                    lResult;
    };

    DWORD                   dwMsg;
    ULONG_PTR               dwParam1;
    ULONG_PTR               dwParam2;
    ULONG_PTR               dwParam3;

} SPEVENT, *PSPEVENT;


typedef struct _SPEVENTHANDLERTHREADINFO
{
    LIST_ENTRY              ListHead;
    HANDLE                  hEvent;
    CRITICAL_SECTION        CritSec;

} SPEVENTHANDLERTHREADINFO, *PSPEVENTHANDLERTHREADINFO;

//
// The following XXXTUPLE types give us a quick easy way to retrieve
// the ptProvider and ptXxx associated with the widget (the widget ID
// is used as an index into a global array)
//

typedef struct _TLINELOOKUPENTRY
{
    DWORD                   dwSPIVersion;
    PTLINE                  ptLine;
    HANDLE                  hMutex;
    PTPROVIDER              ptProvider;

    DWORD                   bRemoved;
    DWORD                   bRemote;

} TLINELOOKUPENTRY, *PTLINELOOKUPENTRY;


typedef struct _TLINELOOKUPTABLE
{
    DWORD                   dwNumTotalEntries;
    DWORD                   dwNumUsedEntries;
    struct _TLINELOOKUPTABLE   *pNext;
    TLINELOOKUPENTRY        aEntries[1];

} TLINELOOKUPTABLE, *PTLINELOOKUPTABLE;


typedef struct _TPHONELOOKUPENTRY
{
    DWORD                   dwSPIVersion;
    PTPHONE                 ptPhone;
    HANDLE                  hMutex;
    PTPROVIDER              ptProvider;

    DWORD                   bRemoved;

} TPHONELOOKUPENTRY, *PTPHONELOOKUPENTRY;


typedef struct _TPHONELOOKUPTABLE
{
    DWORD                   dwNumTotalEntries;
    DWORD                   dwNumUsedEntries;
    struct _TPHONELOOKUPTABLE  *pNext;
    TPHONELOOKUPENTRY       aEntries[1];

} TPHONELOOKUPTABLE, *PTPHONELOOKUPTABLE;


typedef struct _TREQUESTMAKECALL
{
    LINEREQMAKECALLW        LineReqMakeCall;
    struct _TREQUESTMAKECALL   *pNext;

} TREQUESTMAKECALL, *PTREQUESTMAKECALL;


typedef struct _TMANAGEDLLLISTHEADER
{
    LONG                    lCount;
    PTMANAGEDLLINFO         pFirst;

} TMANAGEDLLLISTHEADER, *PTMANAGEDLLLISTHEADER;


typedef struct _PERMANENTIDELEMENT
{
    DWORD       dwPermanentID;
    DWORD       dwDeviceID;

} PERMANENTIDELEMENT, *PPERMANENTIDELEMENT;


typedef struct _PERMANENTIDARRAYHEADER
{
    LONG                    lCookie;
    DWORD                   dwPermanentProviderID;
    PPERMANENTIDELEMENT     pLineElements;
    DWORD                   dwNumLines;
    DWORD                   dwCurrentLines;
    PPERMANENTIDELEMENT     pPhoneElements;
    DWORD                   dwNumPhones;
    DWORD                   dwCurrentPhones;
    struct _PERMANENTIDARRAYHEADER *pNext;

} PERMANENTIDARRAYHEADER, *PPERMANENTIDARRAYHEADER;


typedef struct _PRILISTSTRUCT
{
    DWORD   dwMediaModes;
    LPWSTR  pszPriList;

} PRILISTSTRUCT, *PPRILISTSTRUCT;


#ifdef __TAPI_DEBUG_CS__

#define DEBUG_CS_FILENAME_LEN       16

typedef struct _DEBUG_CS_CODEPATH
{
    char    szSourceFile[ DEBUG_CS_FILENAME_LEN ];
    DWORD   dwSourceLine;
    DWORD   dwThreadId;

} DEBUG_CS_CODEPATH;

typedef struct _DEBUG_CS_CRITICAL_SECTION
{
    CRITICAL_SECTION    CriticalSection;
    DEBUG_CS_CODEPATH   LastEnter;
    DEBUG_CS_CODEPATH   LastLeave;

} DEBUG_CS_CRITICAL_SECTION, *PDEBUG_CS_CRITICAL_SECTION;

#define TapiInitializeCriticalSection(a)                    \
    ZeroMemory((a), sizeof(DEBUG_CS_CRITICAL_SECTION));     \
    InitializeCriticalSection(&((a)->CriticalSection));         

#define TapiInitializeCriticalSectionAndSpinCount(a, b)     \
    (ZeroMemory((a), sizeof(DEBUG_CS_CRITICAL_SECTION)),    \
    InitializeCriticalSectionAndSpinCount(&((a)->CriticalSection), b))         

#define TapiMyInitializeCriticalSection(a, b)               \
    (ZeroMemory((a), sizeof(DEBUG_CS_CRITICAL_SECTION)),    \
    MyInitializeCriticalSection(&((a)->CriticalSection), b))

#define TapiDeleteCriticalSection(a)                        \
    DeleteCriticalSection(&((a)->CriticalSection));

#define TapiEnterCriticalSection(a)                         \
    EnterCriticalSection(&((a)->CriticalSection));          \
    (a)->LastEnter.dwSourceLine = __LINE__;                 \
    (a)->LastEnter.dwThreadId = GetCurrentThreadId( );      \
    strcpy(                                                 \
        (a)->LastEnter.szSourceFile,                        \
        (strlen(__FILE__) < DEBUG_CS_FILENAME_LEN)?         \
        (__FILE__) : (__FILE__ + (strlen(__FILE__) + 1 - DEBUG_CS_FILENAME_LEN) ));

#define TapiLeaveCriticalSection(a)                         \
    (a)->LastLeave.dwSourceLine = __LINE__;                 \
    (a)->LastLeave.dwThreadId = GetCurrentThreadId( );      \
    strcpy(                                                 \
        (a)->LastLeave.szSourceFile,                        \
        (strlen(__FILE__) < DEBUG_CS_FILENAME_LEN)?         \
        (__FILE__) : (__FILE__ + (strlen(__FILE__) + 1 - DEBUG_CS_FILENAME_LEN) )); \
    LeaveCriticalSection(&((a)->CriticalSection));

#else // #ifdef __TAPI_DEBUG_CS__

#define TapiInitializeCriticalSection(a)                    \
    InitializeCriticalSection(a);         

#define TapiInitializeCriticalSectionAndSpinCount(a, b)     \
    InitializeCriticalSectionAndSpinCount(a, b)         

#define TapiMyInitializeCriticalSection(a, b)               \
    MyInitializeCriticalSection(a, b)

#define TapiDeleteCriticalSection(a)                        \
    DeleteCriticalSection(a);

#define TapiEnterCriticalSection(a)                         \
    EnterCriticalSection(a);

#define TapiLeaveCriticalSection(a)                         \
    LeaveCriticalSection(a);

#endif // #ifdef __TAPI_DEBUG_CS__

typedef struct _TAPIGLOBALS
{
    HINSTANCE               hinstDll;
    HICON                   hLineIcon;
    HICON                   hPhoneIcon;
    HANDLE                  hProcess;

#define TAPIGLOBALS_REINIT      (0x00000001)
#define TAPIGLOBALS_SERVER      (0x00000002)
#define TAPIGLOBALS_PAUSED      (0x00000004)

    DWORD                   dwFlags;
    PTCLIENT                ptClients;
    PTPROVIDER              ptProviders;
    DWORD                   dwNumLineInits;

    DWORD                   dwNumLines;
    PTLINELOOKUPTABLE       pLineLookup;
    DWORD                   dwNumPhoneInits;
    DWORD                   dwNumPhones;

    PTPHONELOOKUPTABLE      pPhoneLookup;
    PTREQUESTRECIPIENT      pRequestRecipients;
    PTREQUESTRECIPIENT      pHighestPriorityRequestRecipient;
    PTREQUESTMAKECALL       pRequestMakeCallList;

    PTREQUESTMAKECALL       pRequestMakeCallListEnd;
    PRILISTSTRUCT *         pPriLists;
    DWORD                   dwUsedPriorityLists;
    DWORD                   dwTotalPriorityLists;

    WCHAR                  *pszReqMakeCallPriList;
    WCHAR                  *pszReqMediaCallPriList;
    DWORD                   dwComputerNameSize;
    WCHAR                  *pszComputerName;

    SERVICE_STATUS_HANDLE   sshStatusHandle;
#if TELE_SERVER
    PTMANAGEDLLINFO         pMapperDll;
    PTMANAGEDLLLISTHEADER   pManageDllList;
    PPERMANENTIDARRAYHEADER pIDArrays;
#endif

    ULONG64                 ulPermMasks;

#ifdef __TAPI_DEBUG_CS__
    DEBUG_CS_CRITICAL_SECTION CritSec;
#else
    CRITICAL_SECTION        CritSec;
#endif

    CRITICAL_SECTION        RemoteSPCritSec;

} TAPIGLOBALS, *PTAPIGLOBALS;

typedef struct _GETEVENTS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwTotalBufferSize;
    };

    union
    {
        OUT DWORD       dwNeededBufferSize;
    };

    union
    {
        OUT DWORD       dwUsedBufferSize;
    };

} GETEVENTS_PARAMS, *PGETEVENTS_PARAMS;


typedef struct _GETUIDLLNAME_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;

    union
    {
        IN  DWORD       dwObjectID;
    };

    union
    {
        IN  DWORD       dwObjectType;
    };

    union
    {
        OUT DWORD       dwUIDllNameOffset;
    };

    union
    {
        IN OUT DWORD    dwUIDllNameSize;
    };


    //
    // The following fields used only for providerConfig, -Install, & -Remove
    //

    union
    {
        IN  DWORD       dwProviderFilenameOffset;
    };

    union
    {
        IN  DWORD       bRemoveProvider;
    };

    OUT HTAPIDIALOGINSTANCE htDlgInst;

} GETUIDLLNAME_PARAMS, *PGETUIDLLNAME_PARAMS;


typedef struct _UIDLLCALLBACK_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    IN  DWORD           ObjectID;

    union
    {
        IN  DWORD       dwObjectType;
    };

    union
    {
        IN  DWORD       dwParamsInOffset;
    };

    union
    {
        IN  DWORD       dwParamsInSize;
    };

    union
    {
        OUT DWORD       dwParamsOutOffset;
    };

    union
    {
        IN OUT DWORD    dwParamsOutSize;
    };

} UIDLLCALLBACK_PARAMS, *PUIDLLCALLBACK_PARAMS;


typedef struct _FREEDIALOGINSTANCE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD				dwUnused;


    union
    {
        IN  HTAPIDIALOGINSTANCE htDlgInst;
    };

    union
    {
        IN  LONG        lUIDllResult;
    };

} FREEDIALOGINSTANCE_PARAMS, *PFREEDIALOGINSTANCE_PARAMS;


typedef struct _PROXYREQUESTWRAPPER
{
    ASYNCEVENTMSG           AsyncEventMsg;

    LINEPROXYREQUEST        ProxyRequest;

} PROXYREQUESTWRAPPER, *PPROXYREQUESTWRAPPER;


typedef struct _PRIVATEFACTORYIDENTIFY_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwDeviceID;
    };

    union
    {
        OUT DWORD       dwCLSIDOffset;
    };

    union
    {
        IN OUT DWORD    dwCLSIDSize;
    };

} PRIVATEFACTORYIDENTIFY_PARAMS, *PPRIVATEFACTORYIDENTIFY_PARAMS;




#if DBG

    #define DBGOUT(arg) DbgPrt arg

    VOID
    DbgPrt(
        IN DWORD  dwDbgLevel,
        IN PUCHAR DbgMessage,
        IN ...
        );

	#define ASSERT(exp) if(!(exp)) { DbgPrt(0, "ASSERT : File : %s; Line : %d\n", __FILE__, __LINE__) ;}

typedef struct _MYMEMINFO
{
    //
    // The dwDummy field at the top of this struct is there because on
    // x86 the heap mgr seems to trash this field when you free the
    // block (uses it as a list entry pointer or some such).  We'd like
    // to see the line/file info preserved in hopes of getting more
    // clues when debugging.
    //

    DWORD               dwDummy;
    DWORD               dwLine;
    PSTR                pszFile;

} MYMEMINFO, *PMYMEMINFO;

#else

    #define DBGOUT(arg)
    #define ASSERT(exp)

#endif



#if DBG

#define ServerAlloc( __size__ ) ServerAllocReal( __size__, __LINE__, __FILE__ )

LPVOID
WINAPI
ServerAllocReal(
    DWORD dwSize,
    DWORD dwLine,
    PSTR  pszFile
    );

#else

#define ServerAlloc( __size__ ) ServerAllocReal( __size__ )

LPVOID
WINAPI
ServerAllocReal(
    DWORD dwSize
    );

#endif

VOID
WINAPI
ServerFree(
    LPVOID  lp
    );

#if DBG

#define MyCreateMutex() MyRealCreateMutex(__FILE__, __LINE__)
HANDLE
MyRealCreateMutex(PSTR pFile, DWORD dwLine);

#else

#define MyCreateMutex() MyRealCreateMutex()
HANDLE
MyRealCreateMutex(
    void
    );

#endif

void
MyCloseMutex(
    HANDLE hMutex
    );

BOOL
PASCAL
MyDuplicateHandle(
    HANDLE      hSource,
    LPHANDLE    phTarget
    );

VOID
CALLBACK
CompletionProc(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    LONG                lResult
    );

BOOL
WaitForMutex(
    HANDLE      hMutex,
    HANDLE     *phMutex,
    BOOL       *pbCloseMutex,
    LPVOID      pWidget,
    DWORD       dwKey,
    DWORD       dwTimeout
    );

void
MyReleaseMutex(
    HANDLE  hMutex,
    BOOL    bCloseMutex
    );

LONG
PASCAL
DestroytLineApp(
    HLINEAPP    hLineApp
    );

LONG
DestroytPhoneApp(
    HPHONEAPP   hPhoneApp
    );

LONG
ServerInit(
    BOOL fReinit
    );

LONG
ServerShutdown(
    void
    );

void
WriteEventBuffer(
    PTCLIENT        ptClient,
    PASYNCEVENTMSG  pMsg
    );

BOOL
PASCAL
QueueSPEvent(
    PSPEVENT    pSPEvent
    );

VOID
QueueStaleObject(
    LPVOID  pObjectToQueue
    );

#if DBG

#define SP_FUNC_SYNC  0
#define SP_FUNC_ASYNC 1

LONG
WINAPI
CallSP1(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1
    );

LONG
WINAPI
CallSP2(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2
    );

LONG
WINAPI
CallSP3(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3
    );

LONG
WINAPI
CallSP4(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4
    );

LONG
WINAPI
CallSP5(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4,
    ULONG_PTR   Arg5
    );

LONG
WINAPI
CallSP6(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4,
    ULONG_PTR   Arg5,
    ULONG_PTR   Arg6
    );

LONG
WINAPI
CallSP7(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4,
    ULONG_PTR   Arg5,
    ULONG_PTR   Arg6,
    ULONG_PTR   Arg7
    );

LONG
WINAPI
CallSP8(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4,
    ULONG_PTR   Arg5,
    ULONG_PTR   Arg6,
    ULONG_PTR   Arg7,
    ULONG_PTR   Arg8
    );

LONG
WINAPI
CallSP9(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4,
    ULONG_PTR   Arg5,
    ULONG_PTR   Arg6,
    ULONG_PTR   Arg7,
    ULONG_PTR   Arg8,
    ULONG_PTR   Arg9
    );

LONG
WINAPI
CallSP12(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4,
    ULONG_PTR   Arg5,
    ULONG_PTR   Arg6,
    ULONG_PTR   Arg7,
    ULONG_PTR   Arg8,
    ULONG_PTR   Arg9,
    ULONG_PTR   Arg10,
    ULONG_PTR   Arg11,
    ULONG_PTR   Arg12
    );


#else

#define CallSP1(pfn,nm,fl,a1)                   ((*pfn)(a1))
#define CallSP2(pfn,nm,fl,a1,a2)                ((*pfn)(a1,a2))
#define CallSP3(pfn,nm,fl,a1,a2,a3)             ((*pfn)(a1,a2,a3))
#define CallSP4(pfn,nm,fl,a1,a2,a3,a4)          ((*pfn)(a1,a2,a3,a4))
#define CallSP5(pfn,nm,fl,a1,a2,a3,a4,a5)       ((*pfn)(a1,a2,a3,a4,a5))
#define CallSP6(pfn,nm,fl,a1,a2,a3,a4,a5,a6)    ((*pfn)(a1,a2,a3,a4,a5,a6))
#define CallSP7(pfn,nm,fl,a1,a2,a3,a4,a5,a6,a7) ((*pfn)(a1,a2,a3,a4,a5,a6,a7))
#define CallSP8(pfn,nm,fl,a1,a2,a3,a4,a5,a6,a7,a8) \
                ((*pfn)(a1,a2,a3,a4,a5,a6,a7,a8))
#define CallSP9(pfn,nm,fl,a1,a2,a3,a4,a5,a6,a7,a8,a9) \
                ((*pfn)(a1,a2,a3,a4,a5,a6,a7,a8,a9))
#define CallSP12(pfn,nm,fl,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12) \
                ((*pfn)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12))

#endif


#if DBG

BOOL
IsBadSizeOffset(
    DWORD dwTotalSize,
    DWORD dwFixedSize,
    DWORD dwXxxSize,
    DWORD dwXxxOffset,
    DWORD dwAlignMask,
    char *pszCallingFunc,
    char *pszFieldName
    );

#define ISBADSIZEOFFSET(a1,a2,a3,a4,a5,a6,a7) IsBadSizeOffset(a1,a2,a3,a4,a5,a6,a7)

#else

BOOL
IsBadSizeOffset(
    DWORD dwTotalSize,
    DWORD dwFixedSize,
    DWORD dwXxxSize,
    DWORD dwXxxOffset,
    DWORD dwAlignMask
    );

#define ISBADSIZEOFFSET(a1,a2,a3,a4,a5,a6,a7) IsBadSizeOffset(a1,a2,a3,a4,a5)

#endif

BOOL
IsBadStringParam(
    DWORD   dwParamsBufferSize,
    LPBYTE  pDataBuf,
    DWORD   dwStringOffset
    );

#define MAP_HANDLE_TO_SP_EVENT_QUEUE_ID(h) (h % gdwNumSPEventHandlerThreads)

#if DBG

#define DWORD_CAST(v,f,l) (((v)>MAXDWORD)?(DbgPrt(0,"DWORD_CAST: information will be lost during cast from %p in file %s, line %d",(v),(f),(l)), DebugBreak(),((DWORD)(v))):((DWORD)(v)))

#else
#define DWORD_CAST(v,f,l)   (DWORD)(v)
#endif //DBG

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\tapimmc.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    tapimmc.h

Abstract:

    Definitions & prototypes for TAPI MMC support APIs

Author:

    Dan Knudson (DanKn)    10-Dec-1997

Revision History:


Notes:

--*/


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#define HMMCAPP   HANDLE
#define LPHMMCAPP LPHANDLE


#define TAPISERVERCONFIGFLAGS_ISSERVER              0x00000001
#define TAPISERVERCONFIGFLAGS_ENABLESERVER          0x00000002
#define TAPISERVERCONFIGFLAGS_SETACCOUNT            0x00000004
#define TAPISERVERCONFIGFLAGS_SETTAPIADMINISTRATORS 0x00000008
#define TAPISERVERCONFIGFLAGS_NOSERVICECONTROL      0x00000010
#define TAPISERVERCONFIGFLAGS_LOCKMMCWRITE          0x00000020
#define TAPISERVERCONFIGFLAGS_UNLOCKMMCWRITE        0x00000040

#define AVAILABLEPROVIDER_INSTALLABLE               0x00000001
#define AVAILABLEPROVIDER_CONFIGURABLE              0x00000002
#define AVAILABLEPROVIDER_REMOVABLE                 0x00000004


typedef struct _DEVICEINFO
{
    DWORD       dwPermanentDeviceID;

    DWORD       dwProviderID;

    DWORD       dwDeviceNameSize;

    DWORD       dwDeviceNameOffset;

    DWORD       dwAddressesSize;        // Valid for line devices only

    DWORD       dwAddressesOffset;      // Valid for line devices only

    DWORD       dwDomainUserNamesSize;

    DWORD       dwDomainUserNamesOffset;

    DWORD       dwFriendlyUserNamesSize;

    DWORD       dwFriendlyUserNamesOffset;

} DEVICEINFO, *LPDEVICEINFO;


typedef struct _DEVICEINFOLIST
{
    DWORD       dwTotalSize;

    DWORD       dwNeededSize;

    DWORD       dwUsedSize;

    DWORD       dwNumDeviceInfoEntries;

    DWORD       dwDeviceInfoSize;

    DWORD       dwDeviceInfoOffset;

} DEVICEINFOLIST, *LPDEVICEINFOLIST;


typedef struct _TAPISERVERCONFIG
{
    DWORD       dwTotalSize;

    DWORD       dwNeededSize;

    DWORD       dwUsedSize;

    DWORD       dwFlags;

    DWORD       dwDomainNameSize;

    DWORD       dwDomainNameOffset;

    DWORD       dwUserNameSize;

    DWORD       dwUserNameOffset;

    DWORD       dwPasswordSize;

    DWORD       dwPasswordOffset;

    DWORD       dwAdministratorsSize;

    DWORD       dwAdministratorsOffset;

} TAPISERVERCONFIG, *LPTAPISERVERCONFIG;


typedef struct _AVAILABLEPROVIDERENTRY
{
    DWORD       dwFileNameSize;

    DWORD       dwFileNameOffset;

    DWORD       dwFriendlyNameSize;

    DWORD       dwFriendlyNameOffset;

    DWORD       dwOptions;

} AVAILABLEPROVIDERENTRY, *LPAVAILABLEPROVIDERENTRY;


typedef struct _AVAILABLEPROVIDERLIST
{
    DWORD       dwTotalSize;

    DWORD       dwNeededSize;

    DWORD       dwUsedSize;

    DWORD       dwNumProviderListEntries;

    DWORD       dwProviderListSize;

    DWORD       dwProviderListOffset;

} AVAILABLEPROVIDERLIST, *LPAVAILABLEPROVIDERLIST;


LONG
WINAPI
MMCAddProvider(
    HMMCAPP             hMmcApp,
    HWND                hwndOwner,
    LPCWSTR             lpszProviderFilename,
    LPDWORD             lpdwProviderID
    );

LONG
WINAPI
MMCConfigProvider(
    HMMCAPP             hMmcApp,
    HWND                hwndOwner,
    DWORD               dwProviderID
    );

LONG
WINAPI
MMCGetAvailableProviders(
    HMMCAPP                 hMmcApp,
    LPAVAILABLEPROVIDERLIST lpProviderList
    );

LONG
WINAPI
MMCGetLineInfo(
    HMMCAPP             hMmcApp,
    LPDEVICEINFOLIST    lpDeviceInfoList
    );

LONG
WINAPI
MMCGetLineStatus(
    HMMCAPP             hMmcApp,
    HWND                hwndOwner,
    DWORD               dwStatusLevel,
    DWORD               dwProviderID,
    DWORD               dwPermanentLineID,
    LPVARSTRING         lpStatusBuffer
    );

LONG
WINAPI
MMCGetPhoneInfo(
    HMMCAPP             hMmcApp,
    LPDEVICEINFOLIST    lpDeviceInfoList
    );

LONG
WINAPI
MMCGetPhoneStatus(
    HMMCAPP             hMmcApp,
    HWND                hwndOwner,
    DWORD               dwStatusLevel,
    DWORD               dwProviderID,
    DWORD               dwPermanentPhoneID,
    LPVARSTRING         lpStatusBuffer
    );

LONG
WINAPI
MMCGetProviderList(
    HMMCAPP             hMmcApp,
    LPLINEPROVIDERLIST  lpProviderList
    );

LONG
WINAPI
MMCGetServerConfig(
    HMMCAPP             hMmcApp,
    LPTAPISERVERCONFIG  lpConfig
    );

LONG
WINAPI
MMCInitialize(
    LPCWSTR             lpszComputerName,
    LPHMMCAPP           lphMmcApp,
    LPDWORD             lpdwAPIVersion,
    HANDLE              hReinitializeEvent
    );

LONG
WINAPI
MMCRemoveProvider(
    HMMCAPP             hMmcApp,
    HWND                hwndOwner,
    DWORD               dwProviderID
    );

LONG
WINAPI
MMCSetLineInfo(
    HMMCAPP             hMmcApp,
    LPDEVICEINFOLIST    lpDeviceInfoList
    );

LONG
WINAPI
MMCSetPhoneInfo(
    HMMCAPP             hMmcApp,
    LPDEVICEINFOLIST    lpDeviceInfoList
    );

LONG
WINAPI
MMCSetServerConfig(
    HMMCAPP             hMmcApp,
    LPTAPISERVERCONFIG  lpConfig
    );

LONG
WINAPI
MMCGetDeviceFlags(
    HMMCAPP             hMmcApp,
    BOOL                bLine,
    DWORD               dwProviderID,
    DWORD               dwPermanentDeviceID,
    DWORD               * pdwFlags,
    DWORD               * pdwDeviceID
    );

LONG
WINAPI
MMCShutdown(
    HMMCAPP             hMmcApp
    );

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\tapievt.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    tapievt.h

Abstract:

    Header file for tapi server event filtering

Author:

    Xiaohai Zhang (xzhang)    15-Oct-1999

Revision History:

--*/

#ifndef __TAPIEVT_H__
#define __TAPIEVT_H__

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
//  Event filtering private APIs
//

LONG 
WINAPI 
tapiSetEventFilterMasks (
    DWORD           dwObjType,
    LONG_PTR        lObjectID,
    ULONG64         ulEventMasks
);

LONG 
WINAPI 
tapiSetEventFilterSubMasks (
    DWORD           dwObjType,
    LONG_PTR        lObjectID,
    ULONG64         ulEventMask,
    DWORD			dwEventSubMasks
);

LONG
WINAPI
tapiGetEventFilterMasks (
    DWORD           dwObjType,
    LONG_PTR        lObjectID,
    ULONG64 *       pulEventMasks
);

LONG
WINAPI
tapiGetEventFilterSubMasks (
    DWORD           dwObjType,
    LONG_PTR        lObjectID,
    ULONG64         ulEventMask,
    DWORD *			pdwEventSubMasks
);

LONG
WINAPI
tapiSetPermissibleMasks (
    ULONG64              ulPermMasks
);

LONG
WINAPI
tapiGetPermissibleMasks (
    ULONG64              * pulPermMasks
);

//
//  Object type constants 
//
//      object type defines the scope of the event filtering
//  i.e. EM_LINE_CALLINFO applied on TAPIOBJ_HCALL enable/disables the 
//  LINE_CALLINFO message for the particular hCall object, while 
//  EM_LINE_CALLINFO applied on TAPIOBJ_NULL enable/disables LINE_CALLINFO 
//  message for all existing and future call objects.
//

#define TAPIOBJ_NULL			0	// lObjectID is ignored, apply globally
#define TAPIOBJ_HLINEAPP		1	// lObjectID is of type HLINEAPP
#define TAPIOBJ_HLINE			2	// lObjectID is of type HLINE
#define TAPIOBJ_HCALL			3	// lObjectID is of type HCALL
#define TAPIOBJ_HPHONEAPP		4	// lObjectID is of type HPHONEAPP
#define TAPIOBJ_HPHONE			5	// lObjectID is of type HPHONE

//
//	Tapi server event filter masks
//
//      Event filter mask should be used with their submasks if exists,
//  Many of the event filter masks have their corresponding sub masks
//  defined in tapi.h. i.e. EM_LINE_CALLSTATE owns all the submasks of
//  LINECALLSTATE_constants
//

#define EM_LINE_ADDRESSSTATE        0x00000001	
#define EM_LINE_LINEDEVSTATE        0x00000002
#define EM_LINE_CALLINFO            0x00000004
#define EM_LINE_CALLSTATE           0x00000008
#define EM_LINE_APPNEWCALL          0x00000010
#define EM_LINE_CREATE              0x00000020
#define EM_LINE_REMOVE              0x00000040
#define EM_LINE_CLOSE               0x00000080
#define EM_LINE_PROXYREQUEST        0x00000100
#define EM_LINE_DEVSPECIFIC         0x00000200
#define EM_LINE_DEVSPECIFICFEATURE  0x00000400
#define EM_LINE_AGENTSTATUS         0x00000800
#define EM_LINE_AGENTSTATUSEX       0x00001000
#define EM_LINE_AGENTSPECIFIC       0x00002000
#define EM_LINE_AGENTSESSIONSTATUS  0x00004000
#define EM_LINE_QUEUESTATUS         0x00008000
#define EM_LINE_GROUPSTATUS         0x00010000
#define EM_LINE_PROXYSTATUS         0x00020000
#define EM_LINE_APPNEWCALLHUB       0x00040000
#define EM_LINE_CALLHUBCLOSE        0x00080000
#define EM_LINE_DEVSPECIFICEX       0x00100000
#define EM_LINE_QOSINFO             0x00200000
// LINE_GATHERDIGITS is controlled by lineGatherDigits
// LINE_GENERATE is controlled by lineGenerateDigits
// LINE_MONITORDIGITS is controlled by lineMonitorDigits
// LINE_MONITORMEDIA is controlled by lineMonitorMedia
// LINE_MONITORTONE is controlled by lineMonitorTone
// LINE_REQUEST is controlled by lineRegisterRequestRecipient
// LINE_REPLY can not be disabled.

#define EM_PHONE_CREATE             0x01000000
#define EM_PHONE_REMOVE             0x02000000
#define EM_PHONE_CLOSE              0x04000000
#define EM_PHONE_STATE              0x08000000
#define EM_PHONE_DEVSPECIFIC        0x10000000
#define EM_PHONE_BUTTONMODE         0x20000000
#define EM_PHONE_BUTTONSTATE        0x40000000
// PHONE_REPLY can not be disabled

#define EM_ALL						0x7fffffff
#define EM_NUM_MASKS                31

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif      // tapievt.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\tapiqc.h ===
#ifndef __tapiqc_h__
#define __tapiqc_h__

#if !defined(STREAM_INTERFACES_DEFINED)

/*****************************************************************************
 *  @doc INTERNAL CTAPISTRUCTENUM
 *
 *  @enum TAPIControlFlags | The <t TAPIControlFlags> enum is used to qualify
 *    if a control property can be set manually and/or automatically.
 *
 *  @emem TAPIControl_Flags_None | Specifies that a control property does not
 *    have any control flag. This is typical of read-only properties.
 *
 *  @emem TAPIControl_Flags_Manual | Specifies that a control property can be
 *    modified manually.
 *
 *  @emem TAPIControl_Flags_Auto | Specifies that a control property can be
 *    modified automatically.
 ****************************************************************************/
typedef enum tagTAPIControlFlags
{
	TAPIControl_Flags_None		= 0,
	TAPIControl_Flags_Auto		= 0x1,
	TAPIControl_Flags_Manual	= 0x2
}	TAPIControlFlags;
#endif

#ifdef USE_NETWORK_STATISTICS
/*****************************************************************************
 *  @doc INTERNAL CNETSTATSSTRUCTENUM
 *
 *  @struct CHANNELERRORS_S | The <t CHANNELERRORS_S> structure is used
 *    to set and retrieve the value of channel errors.
 *
 *  @field DWORD | dwRandomBitErrorRate | Specifies the random bit error rate
 *    of the channel in multiples of 10-6.
 *
 *  @field DWORD | dwBurstErrorDuration | Specifies the duration for short
 *    burst errors in ms.
 *
 *  @field DWORD | dwBurstErrorMaxFrequency | Specifies the maximum
 *    frequency for short burst errors in Hz.
 ***************************************************************************/
typedef struct {
	DWORD dwRandomBitErrorRate;
	DWORD dwBurstErrorDuration;
	DWORD dwBurstErrorMaxFrequency;
} CHANNELERRORS_S;

/*****************************************************************************
 *  @doc INTERNAL CNETSTATSSTRUCTENUM
 *
 *  @struct KSCHANNELERRORS_LIST_S | The <t KSCHANNELERRORS_LIST_S> structure is used
 *    to set and retrieve the value of channel errors.
 *
 *  @field KSPROPERTY_DESCRIPTION | PropertyDescription | Specifies access
 *    flags (KSPROPERTY_TYPE_GET and KSPROPERTY_TYPE_SET), the inclusive
 *    size of the entire values information, the property value type
 *    information, and the number of members lists that would typically
 *    follow the structure.
 *
 *  @field KSPROPERTY_MEMBERSHEADER | MembersHeader | Used to provide
 *    information on a property member header.
 *
 *  @field KSPROPERTY_STEPPING_LONG | SteppingRandomBitErrorRate | Used to
 *    specify stepping values for random bit error rate.
 *
 *  @field LONG | DefaultRandomBitErrorRate | Used to specify default
 *    values for random bit error rate.
 *
 *  @field KSPROPERTY_STEPPING_LONG | SteppingBurstErrorDuration | Used to
 *    specify stepping values for short burst errors.
 *
 *  @field LONG | DefaultBurstErrorDuration | Used to specify default values
 *    for short burst errors.
 *
 *  @field KSPROPERTY_STEPPING_LONG | SteppingBurstErrorMaxFrequency | Used
 *    to specify stepping values for the maximum frequency for short burst errors.
 *
 *  @field LONG | DefaultBurstErrorMaxFrequency | Used to specify default
 *    values for the maximum frequency for short burst errors.
 ***************************************************************************/
typedef struct {
	KSPROPERTY_DESCRIPTION   PropertyDescription;
	KSPROPERTY_MEMBERSHEADER MembersHeader;
	union {
		KSPROPERTY_STEPPING_LONG SteppingRandomBitErrorRate;
		LONG DefaultRandomBitErrorRate;
	};
	union {
		KSPROPERTY_STEPPING_LONG SteppingBurstErrorDuration;
		LONG DefaultBurstErrorDuration;
	};
	union {
		KSPROPERTY_STEPPING_LONG SteppingBurstErrorMaxFrequency;
		LONG DefaultBurstErrorMaxFrequency;
	};
} KSCHANNELERRORS_LIST_S;

// Network statistics interface
interface DECLSPEC_UUID("e4b248f9-fbb0-4056-a0e6-316b8580b957") INetworkStats : public IUnknown
{
	public:
	virtual STDMETHODIMP SetChannelErrors(IN CHANNELERRORS_S *pChannelErrors, IN DWORD dwLayerId) PURE;
	virtual STDMETHODIMP GetChannelErrors(OUT CHANNELERRORS_S *pChannelErrors, IN WORD dwLayerId) PURE;
	virtual STDMETHODIMP GetChannelErrorsRange(OUT CHANNELERRORS_S *pMin, OUT CHANNELERRORS_S *pMax, OUT CHANNELERRORS_S *pSteppingDelta, OUT CHANNELERRORS_S *pDefault, IN DWORD dwLayerId) PURE;
	virtual STDMETHODIMP SetPacketLossRate(IN DWORD dwPacketLossRate, IN DWORD dwLayerId) PURE;
	virtual STDMETHODIMP GetPacketLossRate(OUT LPDWORD pdwPacketLossRate, IN DWORD dwLayerId) PURE;
	virtual STDMETHODIMP GetPacketLossRateRange(OUT LPDWORD pdwMin, OUT LPDWORD pdwMax, OUT LPDWORD pdwSteppingDelta, OUT LPDWORD pdwDefault, IN DWORD dwLayerId) PURE;
};

// Our filter's default values
// @todo For accelerators, don't use those values
#endif

/*****************************************************************************
 *  @doc INTERNAL CFPSCSTRUCTENUM
 *
 *  @enum FrameRateControlProperty | The <t FrameRateControlProperty> enum is used
 *    to identify specific frame rate control settings.
 *
 *  @emem FrameRateControl_Maximum | Specifies the maximum frame rate not
 *    to be exceeded.
 *
 *  @emem FrameRateControl_Current | Specifies the current frame rate.
 ****************************************************************************/
typedef enum tagFrameRateControlProperty
{
	FrameRateControl_Maximum,
	FrameRateControl_Current	// Read-Only
}	FrameRateControlProperty;

// Frame rate control interface (pin interface)
interface DECLSPEC_UUID("c2bb17e3-ee63-4d54-821b-1c8cb5287087") IFrameRateControl : public IUnknown
{
	public:
	virtual STDMETHODIMP GetRange(IN FrameRateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags) PURE;
	virtual STDMETHODIMP Set(IN FrameRateControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags) PURE;
	virtual STDMETHODIMP Get(IN FrameRateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags) PURE;
};

#ifdef USE_CPU_CONTROL
/*****************************************************************************
 *  @doc INTERNAL CCPUCSTRUCTENUM
 *
 *  @enum CPUControlProperty | The <t CPUControlProperty> enum is used
 *    to identify specific CPU control settings.
 *
 *  @emem CPUControl_MaxCPULoad | Specifies the maximum CPU load not to be
 *    exceeded.
 *
 *  @emem CPUControl_CurrentCPULoad | Specifies the current CPU load.
 *
 *  @emem CPUControl_MaxProcessingTime | Specifies the maximum processing
 *    time not to be exceeded.
 *
 *  @emem CPUControl_CurrentProcessingTime | Specifies the current processing
 *    time.
 ****************************************************************************/
typedef enum tagCPUControlProperty
{
	CPUControl_MaxCPULoad,
	CPUControl_CurrentCPULoad,			// Read-Only
	CPUControl_MaxProcessingTime,
	CPUControl_CurrentProcessingTime	// Read-Only
}	CPUControlProperty;

// CPU control interface (pin interface)
interface DECLSPEC_UUID("3808c526-de63-48da-a0c6-7792dcbbff82") ICPUControl : public IUnknown
{
	public:
	virtual STDMETHODIMP GetRange(IN CPUControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags) PURE;
	virtual STDMETHODIMP Set(IN CPUControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags) PURE;
	virtual STDMETHODIMP Get(IN CPUControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags) PURE;
};
#endif

/*****************************************************************************
 *  @doc INTERNAL CBPSCSTRUCTENUM
 *
 *  @enum BitrateControlProperty | The <t BitrateControlProperty> enum is used
 *    to identify specific bitrate control settings.
 *
 *  @emem BitrateControl_Maximum | Specifies the maximum bitrate not to be
 *    exceeded.
 *
 *  @emem BitrateControl_Current | Specifies the current bitrate.
 ****************************************************************************/
typedef enum tagBitrateControlProperty
{
	BitrateControl_Maximum,
	BitrateControl_Current	// Read-Only
}	BitrateControlProperty;

// Bitrate control interface (pin interface)
interface DECLSPEC_UUID("46a1a0d7-261e-4839-80e7-8a6333466cc7") IBitrateControl : public IUnknown
{
	public:
	virtual STDMETHODIMP GetRange(IN BitrateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags, IN DWORD dwLayerId) PURE;
	virtual STDMETHODIMP Set(IN BitrateControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags, IN DWORD dwLayerId) PURE;
	virtual STDMETHODIMP Get(IN BitrateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags, IN DWORD dwLayerId) PURE;
};

#endif // __tapiqc_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\tapirtp.h ===
#ifndef __tapirtp_h__
#define __tapirtp_h__

#include <objbase.h>
#include "msrtp.h"

/*
 * WARNING
 *
 * All the NETWORK/HOST sensitive parameters (e.g. port numbers, IP
 * addresses, SSRCs) are expected/returned in NETWORK order
 * */

/*
 * NOTE
 *
 * Most constants are defined in file msrtp.h,
 * e.g. RTPMCAST_LOOPBACKMODE_NONE, RTPSDES_CNAME, etc. msrtp.h (in
 * the same directory as this file) has all the options and a short
 * explanation
 * */

/* {5467edec-0cca-11d3-96e0-00104bc7b3a8} */
DEFINE_GUID(CLSID_MSRTPSourceFilter,
0x5467edec, 0x0cca, 0x11d3, 0x96, 0xe0, 0x00, 0x10, 0x4b, 0xc7, 0xb3, 0xa8);

struct DECLSPEC_UUID("5467edec-0cca-11d3-96e0-00104bc7b3a8") MSRTPSourceFilter;

/* {323cdf3c-0cca-11d3-96e0-00104bc7b3a8} */
DEFINE_GUID(CLSID_MSRTPRenderFilter,
0x323cdf3c, 0x0cca, 0x11d3, 0x96, 0xe0, 0x00, 0x10, 0x4b, 0xc7, 0xb3, 0xa8);

struct DECLSPEC_UUID("323cdf3c-0cca-11d3-96e0-00104bc7b3a8") MSRTPRenderFilter;


/**********************************************************************
 *  IRtpSession (Exposed by RTP Source and Render filters)
 **********************************************************************/
struct DECLSPEC_UUID("f07f3070-0cca-11d3-96e0-00104bc7b3a8") DECLSPEC_NOVTABLE 
IRtpSession : public IUnknown
{
    /* Compact form */
    
    STDMETHOD(Control)(
            DWORD            dwControl,
            DWORD_PTR        dwPar1,
            DWORD_PTR        dwPar2
        ) PURE;

    STDMETHOD(GetLastError)(
            DWORD           *pdwError
        ) PURE;

    /* Separate methods */

    /***************************
     * Initialization
     ***************************/

    /* Init is the first method to call after an RTP source or render
     * filter is created, using a cookie allows the same RTP session
     * to be shared by a source and a render. The first call will have
     * the coockie initialized to NULL, the next call will use the
     * returned cookie to lookup the same RTP session. dwFlags can be
     * RTPINIT_QOS to create QOS enabled sockets, you can find out the
     * complete list of flags that can be used in file msrtp.h */
    STDMETHOD(Init)(
            HANDLE          *phCookie,
            DWORD            dwFlags
        ) PURE;

    /* Deinit is a method used to take the filter back to a state on
     * which a new Init() can and must be done if the filter is to be
     * started again, also note that just after Init(), a filter needs
     * to be configured, that holds also when you use Deinit() taking
     * the filter to its initial state */
    STDMETHOD(Deinit)(
            void
        ) PURE;

    /***************************
     * IP adress and ports
     ***************************/
    
    /* Get the local and remote ports */
    STDMETHOD(GetPorts)(
            WORD            *pwRtpLocalPort,
            WORD            *pwRtpRemotePort,
            WORD            *pwRtcpLocalPort,
            WORD            *pwRtcpRemotePort
        ) PURE;

    /* Set the local and remote ports */
    STDMETHOD(SetPorts)(
            WORD             wRtpLocalPort,
            WORD             wRtpRemotePort,
            WORD             wRtcpLocalPort,
            WORD             wRtcpRemotePort
        ) PURE;

    /* Set the local and remote IP address */
    STDMETHOD(SetAddress)(
            DWORD            dwLocalAddr,
            DWORD            dwRemoteAddr
        ) PURE;

    /* Obtain the local and remote IP addresses */
    STDMETHOD(GetAddress)(
            DWORD           *pdwLocalAddr,
            DWORD           *pdwRemoteAddr
        ) PURE;

    /* The dwFlags parameter is used to determine if the scope is set
     * for RTP (0x1), RTCP (0x2), or both (0x3) */
    STDMETHOD(SetScope)(
            DWORD            dwTTL,
            DWORD            dwFlags
        ) PURE;

    /* Set the multicast loopback mode
     * (e.g. RTPMCAST_LOOPBACKMODE_NONE,
     * RTPMCAST_LOOPBACKMODE_PARTIAL, etc) */
    STDMETHOD(SetMcastLoopback)(
            int              iMcastLoopbackMode,
            DWORD            dwFlags /* Not used, pass 0 */
        ) PURE;

    /***************************
     * Miscelaneous
     ***************************/

    /* Modify the mask specified by dwKind (e.g. RTPMASK_RECV_EVENTS,
     * RTPMASK_SDES_LOCMASK).
     *
     * dwMask is the mask of bits to be set or reset depending on
     * dwValue (reset if 0, set otherwise).
     *
     * pdwModifiedMask will return the resulting mask if the pointer
     * is not NULL. You can just query the current mask value by
     * passing dwMask=0 */
    STDMETHOD(ModifySessionMask)(
            DWORD            dwKind,
            DWORD            dwMask,
            DWORD            dwValue,
            DWORD           *pdwModifiedMask
        ) PURE;

    /* Set the bandwidth limits. A value of -1 will make the parameter
     * to be left unchanged.
     *
     * All the parameters are in bits/sec */
    STDMETHOD(SetBandwidth)(
            DWORD            dwInboundBw,
            DWORD            dwOutboundBw,
            DWORD            dwReceiversRtcpBw,
            DWORD            dwSendersRtcpBw
        ) PURE;

    /***************************
     * Participants
     ***************************/
    
    /* pdwSSRC points to an array of DWORDs where to copy the SSRCs,
     * pdwNumber contains the maximum entries to copy, and returns the
     * actual number of SSRCs copied. If pdwSSRC is NULL, pdwNumber
     * will return the current number of SSRCs (i.e. the current
     * number of participants) */
    STDMETHOD(EnumParticipants)(
            DWORD           *pdwSSRC,
            DWORD           *pdwNumber
        ) PURE;

    /* Get the participant state. dwSSRC specifies the
     * participant. pdwState will return the current participant's
     * state (e.g. RTPPARINFO_TALKING, RTPPARINFO_SILENT). */
    STDMETHOD(GetParticipantState)(
            DWORD            dwSSRC,
            DWORD           *pdwState
        ) PURE;

    /* Get the participant's mute state. dwSSRC specifies the
     * participant. pbMuted will return the participant's mute state
     * */
    STDMETHOD(GetMuteState)(
            DWORD            dwSSRC,
            BOOL            *pbMuted
        ) PURE;

    /* Set the participant's mute state. dwSSRC specifies the
     * participant. bMuted specifies the new state. Note that mute is
     * used to refer to the permission or not to pass packets received
     * up to the application, and it applies equally to audio or video
     * */
    STDMETHOD(SetMuteState)(
            DWORD            dwSSRC,
            BOOL             bMuted
        ) PURE;

    /* Query the network metrics computation state for the specific SSRC */
    STDMETHOD(GetNetMetricsState)(
            DWORD            dwSSRC,
            BOOL            *pbState
        ) PURE;
    
    /* Enable or disable the computation of networks metrics, this is
     * mandatory in order of the corresponding event to be fired if
     * enabled. This is done for the specific SSRC or the first one
     * found if SSRC=-1, if SSRC=0, then the network metrics
     * computation will be performed for any and all the SSRCs */
    STDMETHOD(SetNetMetricsState)(
            DWORD            dwSSRC,
            BOOL             bState
        ) PURE;
    
    /* Retrieves network information, if the network metric
     * computation is enabled for the specific SSRC, all the fields in
     * the structure will be meaningful, if not, only the average
     * values will contain valid data */
    STDMETHOD(GetNetworkInfo)(
            DWORD            dwSSRC,
            RtpNetInfo_t    *pRtpNetInfo
        ) PURE;

    /***************************
     * SDES 
     ***************************/
    
    /* Set the local SDES information for item dwSdesItem (e.g
     * RTPSDES_CNAME, RTPSDES_EMAIL), psSdesData contains the UNICODE
     * NULL terminated string to be assigned to the item */
    STDMETHOD(SetSdesInfo)(
            DWORD            dwSdesItem,
            WCHAR           *psSdesData
        ) PURE;

    /* Get a local SDES item if dwSSRC=0, otherwise gets the SDES item
     * from the participant whose SSRC was specified.
     *
     * dwSdesItem is the item to get (e.g. RTPSDES_CNAME,
     * RTPSDES_EMAIL), psSdesData is the memory place where the item's
     * value will be copied, pdwSdesDataLen contains the initial size
     * in UNICODE chars, and returns the actual UNICODE chars copied
     * (including the NULL terminating char, if any), dwSSRC specify
     * which participant to retrieve the information from. If the SDES
     * item is not available, dwSdesDataLen is set to 0 and the call
     * doesn't fail */
    STDMETHOD(GetSdesInfo)(
            DWORD            dwSdesItem,
            WCHAR           *psSdesData,
            DWORD           *pdwSdesDataLen,
            DWORD            dwSSRC
        ) PURE;

    /***************************
     * QOS
     ***************************/

    /* Select a QOS template (flowspec) by passing its name in
     * psQosName, dwResvStyle specifies the RSVP style (e.g
     * RTPQOS_STYLE_WF, RTPQOS_STYLE_FF), dwMaxParticipants specifies
     * the max number of participants (1 for unicast, N for
     * multicast), this number is used to scale up the
     * flowspec. dwQosSendMode specifies the send mode (has to do with
     * allowed/not allowed to send) (e.g. RTPQOSSENDMODE_UNRESTRICTED,
     * RTPQOSSENDMODE_RESTRICTED1). dwFrameSize is the frame size (in
     * ms), used to derive several flowspec parameters, if this value
     * is not available, 0 can be set
     * */
    STDMETHOD(SetQosByName)(
            WCHAR           *psQosName,
            DWORD            dwResvStyle,
            DWORD            dwMaxParticipants,
            DWORD            dwQosSendMode,
            DWORD            dwFrameSize
        ) PURE;

    /* Not yet implemented, will have same functionality as
     * SetQosByName, except that instead of passing a name to use a
     * predefined flowspec, the caller will pass enough information in
     * the RtpQosSpec structure to obtain the customized flowspec to
     * use */
    STDMETHOD(SetQosParameters)(
            RtpQosSpec_t    *pRtpQosSpec,
            DWORD            dwMaxParticipants,
            DWORD            dwQosSendMode
        ) PURE;


    /* If AppName is specified, replaces the default AppName, as well
     * as the APP field in the policy used, with the new UNICODE
     * string, if not, sets the binary image name as the default. If
     * psAppGUID is specified, it will be prepended to the default
     * policy locator as "GUID=string_passed,". If psPolicyLocator is
     * specified, append a comma and this whole string to the default
     * policy locator, if not, just sets the default
     * */
    STDMETHOD(SetQosAppId)(
            WCHAR           *psAppName,
            WCHAR           *psAppGUID,
            WCHAR           *psPolicyLocator
        ) PURE;

    /* Adds/removes a single SSRC to/from the shared explicit list of
     * participants who receive reservation (i.e. it is used when the
     * ResvStyle=RTPQOS_STYLE_SE). */
    STDMETHOD(SetQosState)(
            DWORD            dwSSRC,
            BOOL             bEnable
        ) PURE;

    /* Adds/removes a number of SSRCs to/from the shared explicit list
     * of participants who receive reservation (i.e. it is used when
     * the ResvStyle=RTPQOS_STYLE_SE). dwNumber is the number of SSRCs
     * to add/remove, and returns the actual number of SSRCs
     * added/removed */
    STDMETHOD(ModifyQosList)(
            DWORD           *pdwSSRC,
            DWORD           *pdwNumber,
            DWORD            dwOperation
        ) PURE;

    /***************************
     * Cryptography
     ***************************/

    /* iMode defines what is going to be encrypted/decrypted,
     * e.g. RTPCRYPTMODE_PAYLOAD to encrypt/decrypt only RTP
     * payload. dwFlag can be RTPCRYPT_SAMEKEY to indicate that (if
     * applicable) the key used for RTCP is the same used for RTP */
    STDMETHOD(SetEncryptionMode)(
            int              iMode,
            DWORD            dwFlags
        ) PURE;

    /* Specifies the information needed to derive an
     * encryption/decryption key. PassPhrase is the (random) text used
     * to generate a key. HashAlg specifies the algorithm to use to
     * hash the pass phrase and generate a key. DataAlg is the
     * algorithm used to encrypt/decrypt the data. Default hash
     * algorithm is RTPCRYPT_MD5, default data algorithm is
     * RTPCRYPT_DES. If encryption is to be used, the PassPhrase is a
     * mandatory parameter to set. bRtcp specifies if the parameters
     * are for RTCP or RTP, if the SAMEKEY flag was used when setting
     * the mode, this parameter is ignored */
    STDMETHOD(SetEncryptionKey)(
            WCHAR           *psPassPhrase,
            WCHAR           *psHashAlg,
            WCHAR           *psDataAlg,
            BOOL             bRtcp
        ) PURE;
};

/**********************************************************************
 *  IRtpMediaControl (Exposed by RTP Source and Render filters)
 **********************************************************************/
struct DECLSPEC_UUID("825db25c-cbbd-4212-b10f-2e1b2ff024e7") DECLSPEC_NOVTABLE 
IRtpMediaControl : public IUnknown
{
    /* Establishes the mapping between a payload type, its sampling
     * frequency and its DShow media type (e.g. for H.261
     * {31,90000,MEDIASUBTYPE_RTP_Payload_H261} ) */
    STDMETHOD(SetFormatMapping)(
	        IN DWORD dwRTPPayLoadType, 
            IN DWORD dwFrequency,
            IN AM_MEDIA_TYPE *pMediaType
        ) PURE;

    /* Empties the format mapping table */
    STDMETHOD(FlushFormatMappings)(
            void
        ) PURE;
};

/**********************************************************************
 *  IRtpDemux (Exposed only by RTP Source filter)
 **********************************************************************/
struct DECLSPEC_UUID("1308f00a-fc1a-4d08-af3c-10a62ae70bde") DECLSPEC_NOVTABLE
IRtpDemux : public IUnknown
{
    /* Add a single pin, may return its position */
    STDMETHOD(AddPin)(
            IN  int          iOutMode,
            OUT int         *piPos
        ) PURE;

    /* Set the number of pins, can only be >= than current number of
     * pins */
    STDMETHOD(SetPinCount)(
            IN  int          iCount,
            IN  int          iOutMode
        ) PURE;

    /* Set the pin mode (e.g. RTPDMXMODE_AUTO or RTPDMXMODE_MANUAL),
     * if iPos >= 0 use it, otherwise use pIPin */
    STDMETHOD(SetPinMode)(
            IN  int          iPos,
            IN  IPin        *pIPin,
            IN  int          iOutMode
        ) PURE;

    /* Map/unmap pin i to/from user with SSRC, if iPos >= 0 use it,
     * otherwise use pIPin, when unmapping, only the pin or the SSRC
     * is required */
    STDMETHOD(SetMappingState)(
            IN  int          iPos,
            IN  IPin        *pIPin,
            IN  DWORD        dwSSRC,
            IN  BOOL         bMapped
        ) PURE;

    /* Find the Pin assigned (if any) to the SSRC, return either
     * position or pin or both */
    STDMETHOD(FindPin)(
            IN  DWORD        dwSSRC,
            OUT int         *piPos,
            OUT IPin       **ppIPin
        ) PURE;

    /* Find the SSRC mapped to the Pin, if iPos >= 0 use it, otherwise
     * use pIPin */
    STDMETHOD(FindSSRC)(
            IN  int          iPos,
            IN  IPin        *pIPin,
            OUT DWORD       *pdwSSRC
        ) PURE;
};

/**********************************************************************
 *  IRtpDtmf (Exposed only by RTP Render filter)
 **********************************************************************/
struct DECLSPEC_UUID("554438d8-a4bd-428a-aabd-1cff350eece6") DECLSPEC_NOVTABLE 
IRtpDtmf : public IUnknown
{
    /***************************
     * DTMF (RFC2833)
     ***************************/

    /* Configures DTMF parameters */
    STDMETHOD(SetDtmfParameters)(
            DWORD            dwPT_Dtmf  /* Payload type for DTMF events */
        ) PURE;
    
    /* Directs an RTP render filter to send a packet formatted
     * according to rfc2833 containing the specified event, specified
     * volume level, duration in milliseconds, and the END flag,
     * following the rules in section 3.6 for events sent in multiple
     * packets. Parameter dwId changes from one digit to the next one.
     *
     * NOTE the duration is given in milliseconds, then it is
     * converted to RTP timestamp units which are represented using 16
     * bits, the maximum value is hence dependent on the sampling
     * frequency, but for 8KHz the valid values would be 0 to 8191 ms
     * */
    STDMETHOD(SendDtmfEvent)(
            DWORD            dwId,
                                          /* As per RFC2833 */
            DWORD            dwEvent,     /* 0 - 16 */
            DWORD            dwVolume,    /* 0 - 63 */
            DWORD            dwDuration,  /* See note above */
            BOOL             bEnd         /* 0 - 1 */
        ) PURE;
};

/**********************************************************************
 *  IRtpRedundancy (Exposed by RTP Source and Render filters)
 **********************************************************************/
struct DECLSPEC_UUID("f3a9dcfe-1513-46ce-a1cb-0fcabe70ff44") DECLSPEC_NOVTABLE
IRtpRedundancy : public IUnknown
{
    /***************************
     * RTP redundancy (RFC2918)
     ***************************/

    /* Configures redundancy. For a receiver only parameter dwPT_Red
     * is used (the other are ignored) and may be set to -1 to ignore
     * it if it was already set or to assign the default. For a
     * sender, parameters dwPT_Red, dwInitialRedDistance, and
     * dwMaxRedDistance can be set to -1 to ignore the parameter if it
     * was already set or to assign the default value */
    STDMETHOD(SetRedParameters)(
            DWORD            dwPT_Red, /* Payload type for redundant packets */
            DWORD            dwInitialRedDistance,/* Initial red distance */
            DWORD            dwMaxRedDistance /* default used when passing -1*/
        ) PURE;
};

#endif // __tapirtp_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\tapiperf.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects
  
  

Copyright (c) 1992 Microsoft Corporation

Module Name:

      datatapi.h

Abstract:

    Header file for the TAPI Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various driver API calls is placed into the structures shown
    here.

--*/

#ifndef _TAPIPERF_H_
#define _TAPIPERF_H_

#include <winperf.h>
//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundaries. Alpha support may 
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define TAPI_NUM_PERF_OBJECT_TYPES 1


//
//  TAPI Resource object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
  

#define LINES_OFFSET                                                 sizeof(DWORD)
#define PHONES_OFFSET                   LINES_OFFSET               + sizeof(DWORD)
#define LINESINUSE_OFFSET               PHONES_OFFSET              + sizeof(DWORD)
#define PHONESINUSE_OFFSET              LINESINUSE_OFFSET          + sizeof(DWORD)
#define TOTALOUTGOINGCALLS_OFFSET       PHONESINUSE_OFFSET         + sizeof(DWORD)
#define TOTALINCOMINGCALLS_OFFSET       TOTALOUTGOINGCALLS_OFFSET  + sizeof(DWORD)
#define CLIENTAPPS_OFFSET               TOTALINCOMINGCALLS_OFFSET  + sizeof(DWORD)
#define ACTIVEOUTGOINGCALLS_OFFSET      CLIENTAPPS_OFFSET          + sizeof(DWORD)
#define ACTIVEINCOMINGCALLS_OFFSET      ACTIVEOUTGOINGCALLS_OFFSET + sizeof(DWORD)
//#define SIZE_OF_TAPI_PERFORMANCE_DATA   32
#define SIZE_OF_TAPI_PERFORMANCE_DATA   40


//
//  This is the counter structure presently returned by TAPI.
//

typedef struct _TAPI_DATA_DEFINITION 
{
    PERF_OBJECT_TYPE            TapiObjectType;
    PERF_COUNTER_DEFINITION     Lines;
    PERF_COUNTER_DEFINITION     Phones;
    PERF_COUNTER_DEFINITION     LinesInUse;
    PERF_COUNTER_DEFINITION     PhonesInUse;
    PERF_COUNTER_DEFINITION     TotalOutgoingCalls;
    PERF_COUNTER_DEFINITION     TotalIncomingCalls;
    PERF_COUNTER_DEFINITION     ClientApps;
    PERF_COUNTER_DEFINITION     CurrentOutgoingCalls;
    PERF_COUNTER_DEFINITION     CurrentIncomingCalls;
} TAPI_DATA_DEFINITION;

typedef struct tagPERFBLOCK
{
    DWORD           dwSize;
    DWORD           dwLines;
    DWORD           dwPhones;
    DWORD           dwLinesInUse;
    DWORD           dwPhonesInUse;
    DWORD           dwTotalOutgoingCalls;
    DWORD           dwTotalIncomingCalls;
    DWORD           dwClientApps;
    DWORD           dwCurrentOutgoingCalls;
    DWORD           dwCurrentIncomingCalls;
} PERFBLOCK, *PPERFBLOCK;

#pragma pack ()

    

/////////////////////////////////////////////////////////////////
// PERFUTIL header stuff below

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif
//
  
  
//  Utility macro.  This is used to reserve a DWORD multiple of bytes for Unicode strings 
//  embedded in the definitional data, viz., object instance names.
  
  
//
  
  
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))
  
  

//    (assumes dword is 4 bytes long and pointer is a dword in size)
  
  
#define ALIGN_ON_DWORD(x) ((VOID *)( ((DWORD) x & 0x00000003) ? ( ((DWORD) x & 0xFFFFFFFC) + 4 ) : ( (DWORD) x ) ))
  
  

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];      
  
  
extern WCHAR  NULL_STRING[];
  
  

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

//
  
  
// The definition of the only routine of perfutil.c, It builds part of a performance data 
// instance (PERF_INSTANCE_DEFINITION) as described in winperf.h
  
  
//

HANDLE MonOpenEventLog ();
VOID MonCloseEventLog ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;


//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

#define HEAP_PROBE()    { \
    DWORD   dwHeapStatus[5]; \
    NTSTATUS CallStatus; \
    dwHeapStatus[4] = __LINE__; }
//    if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
//        REPORT_INFORMATION_DATA (TAPI_HEAP_STATUS, LOG_DEBUG,    \
//            &dwHeapStatus, sizeof(dwHeapStatus));  \
//    } else {  \
//        REPORT_ERROR_DATA (TAPI_HEAP_STATUS_ERROR, LOG_DEBUG, \
//            &CallStatus, sizeof (DWORD)); \
//    } \
//}

#else

#define HEAP_PROBE()    ;
  
  

  
  
#endif


#endif //_DATATAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\tapivid.h ===
#ifndef __tapivid_h__
#define __tapivid_h__

#include "h245if.h"
#include "tapiqc.h"

/****************************************************************************
 *  @doc INTERNAL TAPIVID
 *
 *  @module TAPIVid.h | Header file for the new TAPI internal interfaces and
 *    devine enumeration enums and struct, and our filter GUID.
 *
 *  @comm Two interface declaration changes are due to a multiple inheritance
 *    problem: <i IAMCameraControl> and <i IAMVideoProcAmp> interface methods
 *    have identical prototypes. Our Video Capture filter implements both
 *    interfaces.
 ***************************************************************************/

DEFINE_GUID(CLSID_TAPIVideoCapture,
0x70616376L, 0x5245, 0x4945, 0x52, 0x52, 0x45, 0x46, 0x4C, 0x49, 0x48, 0x50);

struct DECLSPEC_UUID("47a39f38-7f0f-4ce0-b788-d76b39fd6a4f") TAPIVideoCapture;
struct DECLSPEC_UUID("145cb377-e7bb-4adf-bd42-a42304717ede") TAPIVideoDecoder;

const WCHAR* const PNAME_PREVIEW = L"Preview";
const WCHAR* const PNAME_CAPTURE = L"Capture";
const WCHAR* const PNAME_RTPPD = L"RtpPd";

/*****************************************************************************
 *  @doc INTERNAL CDEVENUMSTRUCTENUM
 *
 *  @enum DeviceType | The <t DeviceType> enum is used to identify VfW and WDM
 *    device types.
 *
 *  @emem DeviceType_VfW | Specifies a VfW device.
 *
 *  @emem DeviceType_WDM | Specifies a WDM device.
 *
 *  @emem DeviceType_DShow | Specifies unknown DirectShow device (e.g.,
 *    DV camera)
 ****************************************************************************/
typedef enum tagDeviceType
{
        DeviceType_VfW,
        DeviceType_WDM,
        DeviceType_DShow
} DeviceType;

/*****************************************************************************
 *  @doc INTERNAL CDEVENUMSTRUCTENUM
 *
 *  @enum CaptureMode | The <t CaptureMode> enum is used to identify frame
 *    grabbing or streaming mode.
 *
 *  @emem CaptureMode_FrameGrabbing | Specifies frame grabbing mode.
 *
 *  @emem CaptureMode_Streaming | Specifies streaming mode.
 ****************************************************************************/
typedef enum tagCaptureMode
{
        CaptureMode_FrameGrabbing,
        CaptureMode_Streaming
} CaptureMode;

/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 4 | MAX_CAPTURE_DEVICES | Maximum number of capture devices.
 *
 * @const MAX_PATH | MAX_CAPDEV_DESCRIPTION | Maximum length of capture
 *   device description string.
 *
 * @const 80 | MAX_CAPDEV_VERSION | Maximum length of capture device version
 *   string.
 ****************************************************************************/
#define MAX_CAPTURE_DEVICES             10
#define MAX_CAPDEV_DESCRIPTION  MAX_PATH
#define MAX_CAPDEV_VERSION              80

/*****************************************************************************
 *  @doc INTERNAL CDEVENUMSTRUCTENUM
 *
 *  @struct VIDEOCAPTUREDEVICEINFO | The <t VIDEOCAPTUREDEVICEINFO> structure is used to store capture
 *    device information.
 *
 *  @field char | szDeviceDescription[] | Specifies the description string of
 *    the capture device.
 *
 *  @field char | szDeviceVersion[] | Specifies the version string of
 *    the capture device.
 *
 *  @field BOOL | fHasOverlay | Specifies the overlay support of the capture
 *    device.
 *
 *  @field BOOL | fInUse | Set to TRUE when a device is being used by an
 *    instance of the capture filter.
 *
 *  @field DeviceType | nDeviceType | Specifies the type (VfW or WDM) of the
 *    capture device.
 *
 *  @field CaptureMode | nCaptureMode | Specifies the capture mode (frame grabbing
 *    or streaming) of the capture device.
 *
 *  @field DWORD | dwVfWIndex | Specifies the VfW index of the capture device.
 ***************************************************************************/
typedef struct tagDEVICEINFO
{
        char            szDeviceDescription[MAX_CAPDEV_DESCRIPTION];
        char            szDeviceVersion[MAX_CAPDEV_VERSION];
        char            szDevicePath[MAX_PATH];
        BOOL            fHasOverlay;
        BOOL            fInUse;
        DeviceType      nDeviceType;
        CaptureMode     nCaptureMode;
        DWORD           dwVfWIndex;
} VIDEOCAPTUREDEVICEINFO, *PDEVICEINFO;

typedef HRESULT (WINAPI *PFNGetCapDeviceInfo)(
    IN DWORD dwDeviceIndex,
    OUT PDEVICEINFO pDeviceInfo
    );

typedef HRESULT (WINAPI *PFNGetNumCapDevices)(
    OUT PDWORD pdwNumDevices
    );

// Video capture device selection/control interface (filter interface)
interface DECLSPEC_UUID("bda95399-48da-4309-af1b-9b8f65f4f9be") IVideoDeviceControl : public IUnknown
{
        public:
        virtual STDMETHODIMP GetNumDevices(OUT PDWORD pdwNumDevices) PURE;
        virtual STDMETHODIMP GetDeviceInfo(IN DWORD dwDeviceIndex, OUT VIDEOCAPTUREDEVICEINFO *pDeviceInfo) PURE;
        virtual STDMETHODIMP GetCurrentDevice(OUT DWORD *pdwDeviceIndex) PURE;
        virtual STDMETHODIMP SetCurrentDevice(IN DWORD dwDeviceIndex) PURE;
};

/*****************************************************************************
 *  @doc INTERNAL CPROCAMPSTRUCTENUM
 *
 *  @enum VideoProcAmpProperty | The <t VideoProcAmpProperty> enum is used to
 *    identify specific video quality settings.
 *
 *  @emem VideoProcAmp_Brightness | Specifies the brightness setting in IRE
 *    units * 100. The range for Value is -10000 to 10000; the default value
 *    is 750 (7.5 IRE).
 *
 *  @emem VideoProcAmp_Contrast | Specifies the contrast or luma gain setting
 *    in gain factor * 100. The Value range is from zero to 10000, and the
 *    default is 100 (1x). Note that a particular video encoder filter may
 *    only implement a subset of this range.
 *
 *  @emem VideoProcAmp_Hue | Specifies the hue setting in degrees * 100. Value
 *    range is from -18000 to 18000 ( -180 to +180 degrees), and the default
 *    is zero. Note that a particular video encoder filter may only implement
 *    a subset of this range.
 *
 *  @emem VideoProcAmp_Saturation | Specifies the saturation or chroma gain
 *    setting in gain * 100. Value ranges from zero to 10000, and the default
 *    is 100 (1x). Note that a particular video encoder filter may only
 *    implement a subset of this range.
 *
 *  @emem VideoProcAmp_Sharpness | Specifies the sharpness setting in
 *    arbitrary units. Value ranges from zero to 100, and the default is 50.
 *    Note that a particular video encoder filter may only implement a subset
 *    of this range.
 *
 *  @emem VideoProcAmp_Gamma | Specifies the gamma setting in gamma * 100.
 *    Value ranges from 1 to 500, and the default is 100 (gamma = 1). Note
 *    that a particular video encoder filter may only implement a subset of
 *    this range.
 *
 *  @emem VideoProcAmp_ColorEnable | Specifies the color enable setting as a
 *    Boolean value. Value ranges from zero to 1, and the default is 1.
 *
 *  @emem VideoProcAmp_WhiteBalance | Specifies the white balance setting
 *    expressed as a color temperature in degrees Kelvin. The range and
 *    default values for this setting are video encoder filter dependent.
 *
 *  @emem VideoProcAmp_BacklightCompensation | Specifies the backlight
 *    compensation setting which is a Boolean. Zero indicates backlight
 *    compensation is disabled, and 1 indicates backlight compensation is
 *    enabled.
 ****************************************************************************/

// IAMVideoProcAmp interface (filter interface)
interface DECLSPEC_UUID("C6E13360-30AC-11d0-A18C-00A0C9118956") IVideoProcAmp : public IUnknown
{
        public:
        virtual STDMETHODIMP GetRange(IN VideoProcAmpProperty Property, OUT long *pMin, OUT long *pMax, OUT long *pSteppingDelta, OUT long *pDefault, OUT TAPIControlFlags *pCapsFlags) PURE;
        virtual STDMETHODIMP Set(IN VideoProcAmpProperty Property, IN long lValue, IN TAPIControlFlags Flags) PURE;
        virtual STDMETHODIMP Get(IN VideoProcAmpProperty Property, OUT long *lValue, OUT TAPIControlFlags *Flags) PURE;
};

/*****************************************************************************
 *  @doc INTERNAL CCAMERACSTRUCTENUM
 *
 *  @enum TAPICameraControlProperty | The <t TAPICameraControlProperty> enum
 *     is used to identify specific camera control settings.
 *
 *  @emem TAPICameraControl_Pan | Specifies the camera pan setting in degrees.
 *    Values range from -180 to +180, and the default is zero. Positive values
 *    are clockwise from the origin (the camera rotates clockwise when viewed
 *    from above), and negative values are counterclockwise from the origin.
 *    Note that a particular video capture filter may only implement a subset
 *    of this range.
 *
 *  @emem TAPICameraControl_Tilt | Specifies the camera tilt setting in degrees.
 *    Values range from -180 to +180, and the default is zero. Positive values
 *    point the imaging plane up, and negative values point the imaging plane
 *    down. Note that a particular video capture filter may only implement a
 *    subset of this range.
 *
 *  @emem TAPICameraControl_Roll | Specifies the roll setting in degrees. Values
 *    range from -180 to +180, and the default is zero. Positive values cause
 *    a clockwise rotation of the camera along the image viewing axis, and
 *    negative values cause a counterclockwise rotation of the camera. Note
 *    that a particular video capture filter may only implement a subset of
 *    this range.
 *
 *  @emem TAPICameraControl_Zoom | Specifies the zoom setting in millimeter units.
 *    Values range from 10 to 600, and the default is video capture filter
 *    specific.
 *
 *  @emem TAPICameraControl_Exposure | Specifies the exposure setting in seconds
 *    using the following formula. For values less than zero, the exposure
 *    time is 1/2n seconds. For positive values and zero, the exposure time is
 *    2n seconds. Note that a particular video capture filter may only
 *    implement a subset of this range.
 *
 *  @emem TAPICameraControl_Iris | Specifies the iris setting expressed as the
 *    fstop * 10.
 *
 *  @emem TAPICameraControl_Focus | Specifies the camera focus setting as the
 *    distance to the optimally focused target in millimeters. The range and
 *    default values are video encoder filter specific. Note that a
 *    particular video capture filter may only implement a subset of this
 *    range.
 *
 *  @emem TAPICameraControl_FlipVertical | Specifies that the picture is
 *    flipped vertically.
 *
 *  @emem TAPICameraControl_FlipHorizontal | Specifies that the picture is
 *    flipped horizontally.
 *
 *  @comm Our software-only implementation provides zoom, pan, tilt, vertical
 *    flip and horizontal flip capabilities.
 ****************************************************************************/

typedef enum tagTAPICameraControlProperty
{
        TAPICameraControl_Pan                           = CameraControl_Pan,
        TAPICameraControl_Tilt                          = CameraControl_Tilt,
        TAPICameraControl_Roll                          = CameraControl_Roll,
        TAPICameraControl_Zoom                          = CameraControl_Zoom,
        TAPICameraControl_Exposure                      = CameraControl_Exposure,
        TAPICameraControl_Iris                          = CameraControl_Iris,
        TAPICameraControl_Focus                         = CameraControl_Focus,
        TAPICameraControl_FlipVertical          = 0x100,
        TAPICameraControl_FlipHorizontal        = 0x200
}       TAPICameraControlProperty;

// ICameraControl interface (filter interface)
interface DECLSPEC_UUID("4cda4f2d-969e-4223-801e-68267395fce4") ICameraControl : public IUnknown
{
        public:
        virtual STDMETHODIMP GetRange(IN TAPICameraControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags) PURE;
        virtual STDMETHODIMP Set(IN TAPICameraControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags) PURE;
        virtual STDMETHODIMP Get(IN TAPICameraControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags) PURE;
};

// IVideoControl interface (pin interface)
interface DECLSPEC_UUID("12345678-30AC-11d0-A18C-00A0C9118956") IVideoControl : public IUnknown
{
        public:
        virtual STDMETHODIMP GetCaps(OUT long *pCapsFlags) PURE;
        virtual STDMETHODIMP SetMode(IN long Mode) PURE;
        virtual STDMETHODIMP GetMode(OUT long *Mode) PURE;
        virtual STDMETHODIMP GetCurrentActualFrameRate(OUT LONGLONG *ActualFrameRate) PURE;
        virtual STDMETHODIMP GetMaxAvailableFrameRate(IN long iIndex, IN SIZE Dimensions, OUT LONGLONG *MaxAvailableFrameRate) PURE;
        virtual STDMETHODIMP GetFrameRateList(IN long iIndex, IN SIZE Dimensions, IN long *ListSize, OUT LONGLONG **FrameRates) PURE;
};

// RTP packetization descriptor control interface (pin interface)
interface DECLSPEC_UUID("f454d51d-dfa4-4f88-ad4a-e64940eba1c0") IRTPPDControl : public IUnknown
{
        public:
        virtual STDMETHODIMP SetMaxRTPPacketSize(IN DWORD dwMaxRTPPacketSize, IN DWORD dwLayerId) PURE;
        virtual STDMETHODIMP GetMaxRTPPacketSize(OUT LPDWORD pdwMaxRTPPacketSize, IN DWORD dwLayerId) PURE;
        virtual STDMETHODIMP GetMaxRTPPacketSizeRange(OUT LPDWORD pdwMin, OUT LPDWORD pdwMax, OUT LPDWORD pdwSteppingDelta, OUT LPDWORD pdwDefault, IN DWORD dwLayerId) PURE;
};

// Interface used to pass down an addrefed pointer to the IH245EncoderCommand interface (pin interface)
interface DECLSPEC_UUID("dcbd33c7-dc65-48f1-8e83-22fdc954a8e7") IOutgoingInterface : public IUnknown
{
        public:
        virtual STDMETHODIMP Set(IN IH245EncoderCommand *pIH245EncoderCommand) PURE;
};

typedef enum tagRTPPayloadHeaderMode
{
        RTPPayloadHeaderMode_Draft = 0,         // 0 = draft payload header (as for older compatibility, like Netmeeting)
        RTPPayloadHeaderMode_RFC2190 = 1        // 1 = standard payload header (as in RFC 2190)
}       RTPPayloadHeaderMode;

// Interface used to switch the above mode in filters (TAPIVCap and TAPIVDec)
interface DECLSPEC_UUID("d884c4e3-41d9-42a6-85c0-7d00658b4a26") IRTPPayloadHeaderMode : public IUnknown
{
        public:
        virtual STDMETHODIMP SetMode(IN RTPPayloadHeaderMode rtpphmMode) PURE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\tapihndl.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1998  Microsoft Corporation

Module Name:

    handle.h

Abstract:

    Public definitions for handle table library

Author:

    Dan Knudson (DanKn)    15-Sep-1998

Revision History:

--*/


typedef VOID (CALLBACK * FREECONTEXTCALLBACK)(LPVOID, LPVOID);


typedef struct _MYCONTEXT
{
    LPVOID              C;

    LPVOID              C2;

} MYCONTEXT, *PMYCONTEXT;


typedef struct _HANDLETABLEENTRY
{
    // NOTE: ListEntry must be 1st field in structure so that we don't
    //       have to use CONTAINING_RECORD macro

    union
    {
        LIST_ENTRY      ListEntry;
        MYCONTEXT       Context;
    };

    DWORD	            Handle;

    union
    {
        DWORD           ReferenceCount;
        DWORD           Instance;
    };

} HANDLETABLEENTRY, *PHANDLETABLEENTRY;


typedef struct _HANDLETABLEHEADER
{
    HANDLE              Heap;
    PHANDLETABLEENTRY   Table;
    DWORD               NumEntries;
    DWORD               HandleBase;

    LIST_ENTRY          FreeList;

    FREECONTEXTCALLBACK FreeContextCallback;

    CRITICAL_SECTION    Lock;

} HANDLETABLEHEADER, *PHANDLETABLEHEADER;


HANDLE
CreateHandleTable(
    HANDLE              Heap,
    FREECONTEXTCALLBACK FreeContextCallback,
    DWORD               MinHandleValue,
    DWORD               MaxHandleValue
    );

VOID
DeleteHandleTable(
    HANDLE      HandleTable
    );

DWORD
NewObject(
    HANDLE      HandleTable,
    LPVOID      Context,
    LPVOID      Context2
    );

DWORD
NewObjectEx(
    HANDLE      HandleTable,
    LPVOID      Context,
    LPVOID      Context2,
    DWORD       ModBase,
    DWORD       Remainder
    );

LPVOID
ReferenceObject(
    HANDLE      HandleTable,
    DWORD       Handle,
    DWORD       Key
    );

LPVOID
ReferenceObjectEx(
    HANDLE      HandleTable,
    DWORD       Handle,
    DWORD       Key,
    LPVOID      *Context2
    );

VOID
DereferenceObject(
    HANDLE      HandleTable,
    DWORD       Handle,
    DWORD       DereferenceCount
    );

void
ReleaseAllHandles(
    HANDLE      HandleTable,
    PVOID       Context2
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpdmx\globals.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : RTPDemux.cpp
// Purpose  : RTP Demux filter implementation.
// Contents : 
//*M*/

#ifndef _GLOBALS_H_
#define _GLOBALS_H_

EXTERN_C const CLSID CLSID_IntelRTPDemux;
EXTERN_C const CLSID CLSID_IntelRTPDemuxPropertyPage;

extern const AMOVIESETUP_MEDIATYPE    g_sudInputPinTypes[2];
extern const AMOVIESETUP_MEDIATYPE    g_sudOutputPinTypes[5];
extern const AMOVIESETUP_PIN          g_psudPins[];
extern const AMOVIESETUP_FILTER       g_RTPDemuxFilter;

#endif _GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpdmx\globals.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : Globals.cpp
// Purpose  : RTP Demux filter globals.
// Contents : 
//*M*/

#include <streams.h>

#ifndef _GLOBALS_CPP_
#define _GLOBALS_CPP_

#if !defined(AMRTPDMX_IN_DXMRTP)
#include <initguid.h> // Force the AMRTPUID to turn into real GUID definitions.
#endif
#include <AMRTPUID.h>

#include "globals.h"

// Setup data

const 
AMOVIESETUP_MEDIATYPE g_sudInputPinTypes[2] =
{
    {
        &MEDIATYPE_RTP_Multiple_Stream, // Major CLSID
        &MEDIASUBTYPE_RTP_Payload_Mixed // Minor type
    },
    {
        &MEDIATYPE_RTP_Single_Stream,   // Major CLSID
        &MEDIASUBTYPE_RTP_Payload_Mixed // Minor type
    }
};


const 
AMOVIESETUP_MEDIATYPE g_sudOutputPinTypes[5] =
{
    {
        &MEDIATYPE_RTP_Single_Stream,  
        &MEDIASUBTYPE_RTP_Payload_G711U
    },
    {
        &MEDIATYPE_RTP_Single_Stream,  
        &MEDIASUBTYPE_RTP_Payload_G711A
    },
    {
        &MEDIATYPE_RTP_Single_Stream,  
        &MEDIASUBTYPE_RTP_Payload_G723
    },
    {
        &MEDIATYPE_RTP_Single_Stream,  
        &MEDIASUBTYPE_RTP_Payload_H261
    },
    {
        &MEDIATYPE_RTP_Single_Stream,  
        &MEDIASUBTYPE_RTP_Payload_H263
    }
};


const 
AMOVIESETUP_PIN g_psudPins[] =
{
    { L"Input",             // Pin's string name
      FALSE,                // Is it rendered
      FALSE,                // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Output",            // Connects to pin
      2,                    // Number of types
      g_sudInputPinTypes }, // Pin information
    { L"Output",            // Pin's string name
      FALSE,                // Is it rendered
      TRUE,                 // Is it an output
      TRUE,                 // Allowed none
      TRUE,                 // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Input",             // Connects to pin
      5,                    // Number of types
      g_sudOutputPinTypes } // Pin information
};

const 
AMOVIESETUP_FILTER g_RTPDemuxFilter =
{
    &CLSID_IntelRTPDemux,        // CLSID of filter
    L"Intel RTP Demux Filter",    // Filter's name
    MERIT_DO_NOT_USE,       // Filter merit
    2,                      // Number of pins
    g_psudPins              // Pin information
};


#endif _GLOBALS_CPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\tlnklist.h ===
//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpdmx\regres.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  This file supplied under the terms of the licence agreement and may
*  not be reproduced with out express written consent.
*
*
*******************************************************************************/

#include <streams.h>
#include <malloc.h>
#include "regres.h"

//  Association between the ASCII name and the handle of the registry key.
const REGISTRY_ROOT g_RegistryRoots[] = {
    "HKEY_CLASSES_ROOT", HKEY_CLASSES_ROOT,
    "HKEY_CURRENT_USER", HKEY_CURRENT_USER,
    "HKEY_LOCAL_MACHINE", HKEY_LOCAL_MACHINE,
    "HKEY_USERS", HKEY_USERS,
    "HKEY_CURRENT_CONFIG", HKEY_CURRENT_CONFIG,
    "HKEY_DYN_DATA", HKEY_DYN_DATA
};

#define MAXKEYNAME              256         // Max length of a key name string
#define MAXVALUENAME_LENGTH     MAXKEYNAME  // Max length of a value name string
#define MAXDATA_LENGTH          16L*1024L   // Max length of a value data item

class CRegResHelper
{
    BYTE m_ValueDataBuffer[MAXDATA_LENGTH];
    LPSTR m_pszBuffer;
    DWORD m_dwCP;
public:
    CRegResHelper::CRegResHelper(LPSTR pszBuffer) 
        : m_pszBuffer(pszBuffer)
        , m_dwCP(0)
    {}
    VOID ImportReg(VOID);

private:
    DWORD CreateRegistryKey(LPHKEY lphKey, LPSTR lpFullKeyName, BOOL fCreate);
    VOID ParseHeader(LPHKEY lphKey);
    VOID ParseValuename(HKEY hKey);
    VOID ParseDefaultValue(HKEY hKey);
    BOOL ParseString(LPSTR lpString, LPDWORD cbStringData);
    BOOL ParseHexSequence(LPBYTE lpHexData, LPDWORD lpcbHexData);
    BOOL ParseHexDword(LPDWORD lpDword);
    BOOL ParseHexByte(LPBYTE lpByte);
    BOOL ParseHexDigit(LPBYTE lpDigit);
    BOOL ParseEndOfLine(VOID);
    VOID SkipWhitespace(VOID);
    VOID SkipPastEndOfLine(VOID);
    BOOL GetChar(PCHAR lpChar);
    VOID UngetChar(VOID);
    BOOL MatchChar(CHAR CharToMatch);
    BOOL IsWhitespace(CHAR Char);
    BOOL IsNewLine(CHAR Char);
};

const CHAR g_szHexPrefix[] = "hex";
const CHAR g_szDwordPrefix[] = "dword:";

HRESULT RegisterResource(LPSTR pszResID)
{
    HRESULT     hr;
    HRSRC       hrscReg;
    HGLOBAL     hReg;
    DWORD       dwSize;
    LPSTR       szRegA;
    LPTSTR      szReg;
    LPTSTR      szType = TEXT("REGISTRY");
    
    hrscReg = FindResource(g_hInst, pszResID, szType);
    if (NULL == hrscReg)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Failed to FindResource on ID:%s TYPE:%s"), pszResID, szType));
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    hReg = LoadResource(g_hInst, hrscReg);
    if (NULL == hReg)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Failed to LoadResource")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    dwSize = SizeofResource(g_hInst, hrscReg);
    szRegA = (LPSTR)hReg;
    if (szRegA[dwSize] != NULL)
    {
        szRegA = (LPSTR)_alloca(dwSize+1);
        if (szRegA) {
            memcpy(szRegA, (void*)hReg, dwSize+1);
            szRegA[dwSize] = NULL;
        } else {
            hr = E_OUTOFMEMORY;
            return(hr);
        }
    }

    CRegResHelper rrh(szRegA);
    rrh.ImportReg();

    return S_OK;
}


/*******************************************************************************
*
*  CreateRegistryKey
*
*  DESCRIPTION:
*     Parses the pFullKeyName string and creates a handle to the registry key.
*
*  PARAMETERS:
*     lphKey, location to store handle to registry key.
*     lpFullKeyName, string of form "HKEY_LOCAL_MACHINE\Subkey1\Subkey2".
*     fCreate, TRUE if key should be created, else FALSE for open only.
*     (returns), ERROR_SUCCESS, no errors occurred, phKey is valid,
*                ERROR_CANTOPEN, registry access error of some form,
*                ERROR_BADKEY, incorrectly formed pFullKeyName.
*
*******************************************************************************/

DWORD
CRegResHelper::CreateRegistryKey(
    LPHKEY lphKey,
    LPSTR lpFullKeyName,
    BOOL fCreate
    )
{

    LPSTR lpSubKeyName;
    CHAR PrevChar;
    HKEY hRootKey;
    UINT Counter;
    DWORD Result;

    if ((lpSubKeyName = (LPSTR) strchr(lpFullKeyName, '\\')) != NULL) {

        PrevChar = *lpSubKeyName;
        *lpSubKeyName++ = '\0';

    }

    _strupr(lpFullKeyName);

    hRootKey = NULL;

    for (Counter = 0; Counter < NUMBER_REGISTRY_ROOTS; Counter++) {

        if (strcmp(g_RegistryRoots[Counter].lpKeyName, lpFullKeyName) == 0) {

            hRootKey = g_RegistryRoots[Counter].hKey;
            break;

        }

    }

    if (hRootKey) {

        Result = ERROR_CANTOPEN;

        if (fCreate) {

            if (RegCreateKey(hRootKey, lpSubKeyName, lphKey) == ERROR_SUCCESS)
                Result = ERROR_SUCCESS;

        }

        else {

            if (RegOpenKey(hRootKey, lpSubKeyName, lphKey) == ERROR_SUCCESS)
                Result = ERROR_SUCCESS;

        }

    }

    else
        Result = ERROR_BADKEY;

    if (lpSubKeyName != NULL) {

        lpSubKeyName--;
        *lpSubKeyName = PrevChar;

    }

    return Result;

}

/*******************************************************************************
*
*  ImportRegResource
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID 
CRegResHelper::ImportReg(
    VOID
    )
{

    HKEY hLocalMachineKey;
    HKEY hUsersKey;
    HKEY hKey;
    CHAR Char;

    //
    //  Keep open handles for the predefined roots to prevent the registry
    //  library from flushing after every single RegOpenKey/RegCloseKey
    //  operation.
    //

    RegOpenKey(HKEY_LOCAL_MACHINE, NULL, &hLocalMachineKey);
    RegOpenKey(HKEY_USERS, NULL, &hUsersKey);

#ifdef DEBUG
    if (hLocalMachineKey == NULL)
        DbgLog((LOG_TRACE, 1, "Unable to open HKEY_LOCAL_MACHINE"));
    if (hUsersKey == NULL)
        DbgLog((LOG_TRACE, 1, "Unable to open HKEY_USERS"));
#endif

    hKey = NULL;

    while (TRUE) {

        SkipWhitespace();

        //
        //  Check for the end of file condition.
        //

        if (!GetChar(&Char))
            break;

        switch (Char) {

            case '[':
                //
                //  If a registry key is currently open, we must close it first.
                //  If ParseHeader happens to fail (for example, no closing
                //  bracket), then hKey will be NULL and any values that we
                //  parse must be ignored.
                //

                if (hKey != NULL) {

                    RegCloseKey(hKey);
                    hKey = NULL;

                }

                ParseHeader(&hKey);

                break;

            case '"':
                //
                //  As noted above, if we don't have an open registry key, then
                //  just skip the line.
                //

                if (hKey != NULL)
                    ParseValuename(hKey);

                else
                    SkipPastEndOfLine();

                break;

            case '@':
                //
                //
                //

                if (hKey != NULL)
                    ParseDefaultValue(hKey);

                else
                    SkipPastEndOfLine();

                break;

            case ';':
                //
                //  This line is a comment so just dump the rest of it.
                //

                SkipPastEndOfLine();

                break;

            default:
                if (IsNewLine(Char))
                    break;

                SkipPastEndOfLine();

                break;

        }

    }

    if (hKey != NULL)
        RegCloseKey(hKey);

    if (hUsersKey != NULL)
        RegCloseKey(hUsersKey);

    if (hLocalMachineKey != NULL)
        RegCloseKey(hLocalMachineKey);

}

/*******************************************************************************
*
*  ParseHeader
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/
#define SIZE_FULL_KEYNAME (MAXKEYNAME + 40)

VOID 
CRegResHelper::ParseHeader(
    LPHKEY lphKey
    )
{
    CHAR FullKeyName[SIZE_FULL_KEYNAME];
    int CurrentIndex;
    int LastRightBracketIndex;
    CHAR Char;

    CurrentIndex = 0;
    LastRightBracketIndex = -1;

    while (GetChar(&Char)) {

        if (IsNewLine(Char))
            break;

        if (Char == ']')
            LastRightBracketIndex = CurrentIndex;

        FullKeyName[CurrentIndex++] = Char;

        if (CurrentIndex == SIZE_FULL_KEYNAME) {

            do {

                if (Char == ']')
                    LastRightBracketIndex = -1;

                if (IsNewLine(Char))
                    break;

            }   while (GetChar(&Char));

            break;

        }

    }

    if (LastRightBracketIndex != -1) {

        FullKeyName[LastRightBracketIndex] = '\0';

        switch (CreateRegistryKey(lphKey, FullKeyName, TRUE)) {

            case ERROR_CANTOPEN:
#if 0
                g_FileErrorStringID = IDS_IMPFILEERRREGOPEN;
#endif
                break;

        }

    }

}

/*******************************************************************************
*
*  ParseValuename
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
CRegResHelper::ParseValuename(
    HKEY hKey
    )
{

    DWORD Type;
    CHAR ValueName[MAXVALUENAME_LENGTH];
    DWORD cbData;
    LPCSTR lpPrefix;

    cbData = sizeof(ValueName);

    if (!ParseString(ValueName, &cbData))
        goto ParseError;

    SkipWhitespace();

    if (!MatchChar('='))
        goto ParseError;

    SkipWhitespace();

    //
    //  REG_SZ.
    //
    //  "ValueName" = "string of text"
    //

    if (MatchChar('"')) {

        //  BUGBUG:  Line continuations for strings?

        cbData = MAXDATA_LENGTH;

        if (!ParseString((CHAR*)m_ValueDataBuffer, &cbData) || !ParseEndOfLine())
            goto ParseError;

        Type = REG_SZ;

    }

    //
    //  REG_DWORD.
    //
    //  "ValueName" = dword: 12345678
    //

    else if (MatchChar(g_szDwordPrefix[0])) {

        lpPrefix = &g_szDwordPrefix[1];

        while (*lpPrefix != '\0')
            if (!MatchChar(*lpPrefix++))
                goto ParseError;

        SkipWhitespace();

        if (!ParseHexDword((LPDWORD) m_ValueDataBuffer) || !ParseEndOfLine())
            goto ParseError;

        Type = REG_DWORD;
        cbData = sizeof(DWORD);

    }

    //
    //  REG_BINARY and other.
    //
    //  "ValueName" = hex: 00 , 11 , 22
    //  "ValueName" = hex(12345678): 00, 11, 22
    //

    else {

        lpPrefix = g_szHexPrefix;

        while (*lpPrefix != '\0')
            if (!MatchChar(*lpPrefix++))
                goto ParseError;

        //
        //  Check if this is a type of registry data that we don't directly
        //  support.  If so, then it's just a dump of hex data of the specified
        //  type.
        //

        if (MatchChar('(')) {

            if (!ParseHexDword(&Type) || !MatchChar(')'))
                goto ParseError;

        }

        else
            Type = REG_BINARY;

        if (!MatchChar(':') || !ParseHexSequence(m_ValueDataBuffer, &cbData) ||
            !ParseEndOfLine())
            goto ParseError;

    }

    RegSetValueEx(hKey, ValueName, 0, Type, m_ValueDataBuffer, cbData);
	// BUGBUG should we check the return value?  ERROR_SUCCESS

#if 0
        g_FileErrorStringID = IDS_IMPFILEERRREGSET;
#endif

    return;

ParseError:
    SkipPastEndOfLine();

}

/*******************************************************************************
*
*  ParseDefaultValue
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
CRegResHelper::ParseDefaultValue(
    HKEY hKey
    )
{

    BOOL fSuccess;
    DWORD cbData;

    fSuccess = FALSE;

    SkipWhitespace();

    if (MatchChar('=')) {

        SkipWhitespace();

        if (MatchChar('"')) {

            //  BUGBUG:  Line continuations for strings?

            cbData = MAXDATA_LENGTH;

            if (ParseString((CHAR*)m_ValueDataBuffer, &cbData) && ParseEndOfLine()) {

                fSuccess = TRUE;

            }

        }

    }

    if (!fSuccess)
        SkipPastEndOfLine();

}

/*******************************************************************************
*
*  ParseString
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
CRegResHelper::ParseString(
    LPSTR lpString,
    LPDWORD lpcbStringData
    )
{

    CHAR Char;
    DWORD cbMaxStringData;
    DWORD cbStringData;

    cbMaxStringData = *lpcbStringData;
    cbStringData = 1;                   //  Account for the null terminator

    while (GetChar(&Char)) {

        if (cbStringData >= cbMaxStringData)
            return FALSE;

        switch (Char) {

            case '\\':
                if (!GetChar(&Char))
                    return FALSE;

                switch (Char) {

                    case '\\':
                        *lpString++ = '\\';
                        break;

                    case '"':
                        *lpString++ = '"';
                        break;

                    default:
                        DbgLog((LOG_TRACE, 0, "ParseString:  Invalid escape sequence"));
                        return FALSE;

                }
                break;

            case '"':
                *lpString = '\0';
                *lpcbStringData = cbStringData;
                return TRUE;

            default:
                if (IsNewLine(Char))
                    return FALSE;

                *lpString++ = Char;
                break;
        }

        cbStringData++;

    }

    return FALSE;

}

/*******************************************************************************
*
*  ParseHexSequence
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
CRegResHelper::ParseHexSequence(
    LPBYTE lpHexData,
    LPDWORD lpcbHexData
    )
{

    DWORD cbHexData;

    cbHexData = 0;

    do {

        if (cbHexData >= MAXDATA_LENGTH)
            return FALSE;

        SkipWhitespace();

        if (MatchChar('\\') && !ParseEndOfLine())
            return FALSE;

        SkipWhitespace();

        if (!ParseHexByte(lpHexData++))
            break;

        cbHexData++;

        SkipWhitespace();

    }   while (MatchChar(','));

    *lpcbHexData = cbHexData;

    return TRUE;

}

/*******************************************************************************
*
*  ParseHexDword
*
*  DESCRIPTION:
*     Parses a one dword hexadecimal string from the registry file stream and
*     converts it to a binary number.  A maximum of eight hex digits will be
*     parsed from the stream.
*
*  PARAMETERS:
*     lpByte, location to store binary number.
*     (returns), TRUE if a hexadecimal dword was parsed, else FALSE.
*
*******************************************************************************/

BOOL
CRegResHelper::ParseHexDword(
    LPDWORD lpDword
    )
{

    UINT CountDigits;
    DWORD Dword;
    BYTE Byte;

    Dword = 0;
    CountDigits = 0;

    while (TRUE) {

        if (!ParseHexDigit(&Byte))
            break;

        Dword = (Dword << 4) + (DWORD) Byte;

        if (++CountDigits == 8)
            break;

    }

    *lpDword = Dword;

    return CountDigits != 0;

}

/*******************************************************************************
*
*  ParseHexByte
*
*  DESCRIPTION:
*     Parses a one byte hexadecimal string from the registry file stream and
*     converts it to a binary number.
*
*  PARAMETERS:
*     lpByte, location to store binary number.
*     (returns), TRUE if a hexadecimal byte was parsed, else FALSE.
*
*******************************************************************************/

BOOL
CRegResHelper::ParseHexByte(
    LPBYTE lpByte
    )
{

    BYTE SecondDigit;

    if (ParseHexDigit(lpByte)) {

        if (ParseHexDigit(&SecondDigit))
            *lpByte = (BYTE) ((*lpByte << 4) | SecondDigit);

        return TRUE;

    }

    else
        return FALSE;

}

/*******************************************************************************
*
*  ParseHexDigit
*
*  DESCRIPTION:
*     Parses a hexadecimal character from the registry file stream and converts
*     it to a binary number.
*
*  PARAMETERS:
*     lpDigit, location to store binary number.
*     (returns), TRUE if a hexadecimal digit was parsed, else FALSE.
*
*******************************************************************************/

BOOL
CRegResHelper::ParseHexDigit(
    LPBYTE lpDigit
    )
{

    CHAR Char;
    BYTE Digit;

    if (GetChar(&Char)) {

        if (Char >= '0' && Char <= '9')
            Digit = (BYTE) (Char - '0');

        else if (Char >= 'a' && Char <= 'f')
            Digit = (BYTE) (Char - 'a' + 10);

        else if (Char >= 'A' && Char <= 'F')
            Digit = (BYTE) (Char - 'A' + 10);

        else {

            UngetChar();

            return FALSE;

        }

        *lpDigit = Digit;

        return TRUE;

    }

    return FALSE;

}

/*******************************************************************************
*
*  ParseEndOfLine
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
CRegResHelper::ParseEndOfLine(
    VOID
    )
{

    CHAR Char;
    BOOL fComment;
    BOOL fFoundOneEndOfLine;

    fComment = FALSE;
    fFoundOneEndOfLine = FALSE;

    while (GetChar(&Char)) {

        if (IsWhitespace(Char))
            continue;

        if (IsNewLine(Char)) {

            fComment = FALSE;
            fFoundOneEndOfLine = TRUE;

        }

        //
        //  Like .INIs and .INFs, comments begin with a semicolon character.
        //

        else if (Char == ';')
            fComment = TRUE;

        else if (!fComment) {

            UngetChar();

            break;

        }

    }

    return fFoundOneEndOfLine;

}

/*******************************************************************************
*
*  SkipWhitespace
*
*  DESCRIPTION:
*     Advances the registry file pointer to the first character past any
*     detected whitespace.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
CRegResHelper::SkipWhitespace(
    VOID
    )
{

    CHAR Char;

    while (GetChar(&Char)) {

        if (!IsWhitespace(Char)) {

            UngetChar();
            break;

        }

    }

}

/*******************************************************************************
*
*  SkipPastEndOfLine
*
*  DESCRIPTION:
*     Advances the registry file pointer to the first character past the first
*     detected new line character.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

VOID
CRegResHelper::SkipPastEndOfLine(
    VOID
    )
{

    CHAR Char;

    while (GetChar(&Char)) {

        if (IsNewLine(Char))
            break;

    }

    while (GetChar(&Char)) {

        if (!IsNewLine(Char)) {

            UngetChar();
            break;

        }

    }

}

/*******************************************************************************
*
*  GetChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/
BOOL
CRegResHelper::GetChar(
    PCHAR lpChar
    )
{
    m_dwCP++;
    if (m_pszBuffer[m_dwCP] == NULL)
        return FALSE;

    *lpChar = m_pszBuffer[m_dwCP];
    return TRUE;
}

/*******************************************************************************
*
*  UngetChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/
VOID
CRegResHelper::UngetChar(
    VOID
    )
{
    m_dwCP--;
}

/*******************************************************************************
*
*  MatchChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/
BOOL
CRegResHelper::MatchChar(
    CHAR CharToMatch
    )
{

    BOOL fMatch;
    CHAR NextChar;

    fMatch = FALSE;

    if (GetChar(&NextChar)) {
        if (CharToMatch == NextChar)
            fMatch = TRUE;
        else
            UngetChar();
    }

    return fMatch;

}

/*******************************************************************************
*
*  IsWhitespace
*
*  DESCRIPTION:
*     Checks if the given character is whitespace.
*
*  PARAMETERS:
*     Char, character to check.
*     (returns), TRUE if character is whitespace, else FALSE.
*
*******************************************************************************/
BOOL
CRegResHelper::IsWhitespace(
    CHAR Char
    )
{

    return Char == ' ' || Char == '\t';

}

/*******************************************************************************
*
*  IsNewLine
*
*  DESCRIPTION:
*     Checks if the given character is a new line character.
*
*  PARAMETERS:
*     Char, character to check.
*     (returns), TRUE if character is a new line, else FALSE.
*
*******************************************************************************/
BOOL
CRegResHelper::IsNewLine(
    CHAR Char
    )
{

    return Char == '\n' || Char == '\r';

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\inc\tregupr2.h ===
/****************************************************************************
 
  Copyright (c) 1998-1999 Microsoft Corporation
                                                              
  Module Name:  tregupr2.h
                                                              
       Author:  radus - 12/03/98

****************************************************************************/

// tregupr2.h - functions for converting the registry format to 
//	the new one (post NT5b2)		


#ifdef __cplusplus
extern "C" {
#endif


// should be incremented any time there's a registry structure change 
#define TAPI_CARD_LIST_VERSION      2
#define TAPI_LOCATION_LIST_VERSION  2


DWORD ConvertLocations(void);
DWORD ConvertUserLocations(HKEY hUser);
DWORD ConvertCallingCards(HKEY hUser);

DWORD RegDeleteKeyRecursive (HKEY hParentKey, LPCTSTR pszKeyName);


BOOL  IsLocationListInOldFormat(HKEY hLocations); // for both user & machine
BOOL  IsCardListInOldFormat(HKEY hCards);

DWORD TapiCryptInitialize(void);
void  TapiCryptUninitialize(void);

DWORD TapiEncrypt(PWSTR, DWORD, PWSTR, DWORD *);
DWORD TapiDecrypt(PWSTR, DWORD, PWSTR, DWORD *);

BOOL  TapiIsSafeToDisplaySensitiveData(void);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpdmx\regres.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  This file supplied under the terms of the licence agreement and may
*  not be reproduced with out express written consent.
*
*
*******************************************************************************/

#ifndef _INC_REGRES
#define _INC_REGRES

#ifndef LPHKEY
#define LPHKEY                          HKEY FAR*
#endif

typedef struct _REGISTRY_ROOT {
    LPSTR lpKeyName;
    HKEY hKey;
}   REGISTRY_ROOT;

#define INDEX_HKEY_CLASSES_ROOT         0
#define INDEX_HKEY_CURRENT_USER         1
#define INDEX_HKEY_LOCAL_MACHINE        2
#define INDEX_HKEY_USERS                3
#define INDEX_HKEY_CURRENT_CONFIG       5
#define INDEX_HKEY_DYN_DATA             6

#define NUMBER_REGISTRY_ROOTS           6

//  BUGBUG:  This is supposed to be enough for one keyname plus one predefined
//  handle name.
#define SIZE_SELECTED_PATH              (MAXKEYNAME + 40)

HRESULT RegisterResource(LPSTR pszResID);

#endif // _INC_REGRES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpdmx\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rtpdmx.rc
//
#define IDSBASE_AMRTPDMX                3100

#define IDS_RTPDEMUX_TITLE              3101
#define IDS_RTPDEMUX_NEWPINS_OUTOFMEM   3102
#define IDS_RTPDEMUX_NEWPINS_OTHER      3103
#define IDS_RTPDEMUX_NEWPINS_ERRTITLE   3104
#define IDS_RTPDEMUX_NEWPT_CONNECTED    3105
#define IDS_RTPDEMUX_NEWPT_OTHER        3106
#define IDS_RTPDEMUX_NEWPT_NEWPT_ERRTITLE 3107
#define IDS_RTPDEMUX_NEWPT_ERRTITLE     3107
#define IDS_RTPDEMUX_NEWPINS_NOTSTOPPED 3108
// IDD_RTPDEMUXPROP was 107 
#define IDD_RTPDEMUXPROP                3109
#define IDC_SSRCLIST                    1000
#define IDC_PINLIST                     1001
#define IDC_SUBTYPELIST                 1002
#define IDC_MAP                         1003
#define IDC_UNMAP                       1004
#define IDC_MODEAUTO                    1006
#define IDC_MODEMANUAL                  1007
#define IDC_TIMEOUT                     1008
#define IDC_PINCOUNT                    1010
#define IDC_PT                          1011
#define IDC_PTVALUE                     1018
#define IDC_CONNECTED                   1019
#define IDR_PayloadData                 1020
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1020
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpdmx\rtpconst.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : RTPConst.h
// Purpose  : Defines RTP constants used in building the RTP Demux filter.
// Contents : 
//*M*/

#ifndef _RTPCONST_H_
#define _RTPCONST_H_

#define PT_PCMU         0
#define PT_1016         1
#define PT_G721         2
#define PT_GSM          3
#define PT_DVI48        5
#define PT_DVI416       6
#define PT_LPC          7
#define PT_PCMA         8
#define PT_G722         9
#define PT_L16Stereo   10
#define PT_L16Mono     11
#define PT_MPA         14
#define PT_G728        15
#define PT_CelB        25
#define PT_JPEG        26
#define PT_NV          28
#define PT_H261        31
#define PT_MPV         32
#define PT_MP2T        33

#endif _RTPCONST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpdmx\rtpdinpp.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : RTPDmx.h
// Purpose  : Define the class that implements the RTP Demux filter.
// Contents : 
//*M*/

#ifndef _RTPDINPP_H_
#define _RTPDINPP

#include "am_dmx.h"

class CRTPDemux;
class CRTPDemuxOutputPin;
class CSSRCEnumPin;


/*C*
//  Name    : CRTPDemuxInputPin
//  Purpose : Implements the input pin of the RTP Demux filter.
//  Context : Handles most issues associated with delivery of 
//            a media sample (RTP Packet) by the upstream filter.
*C*/
class 
CRTPDemuxInputPin 
: public CBaseInputPin
{
private:
    // Helper functions.
    HRESULT TryNewSSRC(
        IMediaSample                        *pSample,
        DWORD                               *pdwBuffer, 
        int                                 iSampleLength,
		SSRCRecord_t                        *pSSRCRecord
		);
    HRESULT OldSSRC(
        IMediaSample                        *pSample,  
        SSRCRecordMapIterator_t             iSSRCMapRecord, 
        DWORD                               *pdwPacket, 
        int                                 iPacketLength);
    void ExpirePins(void);

    friend class    CRTPDemuxOutputPin;
    CRTPDemux       *m_pFilter;                  // Main filter object

    void Lock() {if (m_pFilter) m_pFilter->DmxLock();}

    void Unlock() {if (m_pFilter) m_pFilter->DmxUnlock();}
    
public:

	// ZCS 7-14-97 fixing circular refcount troubles
	STDMETHODIMP_(ULONG) NonDelegatingAddRef();
	STDMETHODIMP_(ULONG) NonDelegatingRelease();

    // Constructor and destructor
    CRTPDemuxInputPin(TCHAR *pObjName,
                 CRTPDemux *pTee,
                 HRESULT *phr,
                 LPCWSTR pPinName);

    ~CRTPDemuxInputPin();

    // Used to check the input pin connection
    HRESULT GetMediaType(
        int         iPosition, 
        CMediaType  *pmt);
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT BreakConnect();

    STDMETHODIMP ReceiveCanBlock(void);
    STDMETHODIMP GetAllocator(
        IMemAllocator           **pIMemAllocator);
    STDMETHODIMP GetAllocatorRequirements(
        ALLOCATOR_PROPERTIES    *pProperties);
    STDMETHODIMP NotifyAllocator(
        IMemAllocator           *pAllocator, 
        BOOL                    bReadOnly);

    // Pass through calls downstream
    STDMETHODIMP EndOfStream();
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    // Handles the next block of data from the stream
    STDMETHODIMP Receive(IMediaSample *pSample);

    HRESULT PassNotify(Quality q);

	HRESULT RTPDemuxNotifyEvent(RTPDEMUX_EVENT_t Event,
								DWORD_PTR dwSSRC,
								DWORD dwPT);
};


#endif _RTPDINPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpdmx\rtpdinpp.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : RTPDemux.cpp
// Purpose  : Used as part of the RTP Demux filter.
// Contents : Implementation of the CRTPDemuxInputPin class.
//*M*/

#include <streams.h>

#ifndef _RTPDINPP_CPP_
#define _RTPDINPP_CPP_

#pragma warning( disable : 4786 )
#pragma warning( disable : 4146 )
#pragma warning( disable : 4018 )
#include <algo.h>
#include <map.h>
#include <multimap.h>
#include <function.h>

#include <amrtpuid.h>

#include "amrtpdmx.h"
#include "rtpdtype.h"
#include "globals.h"

#include "rtpdmx.h"
#include "rtpdinpp.h"
#include "rtpdoutp.h"

#include "rtpdprop.h"
#include "ssrcenum.h"

#define LOG_DEVELOP 1

#define B2M(b) (1 << (b))

// ZCS 7-14-97 fixing circular refcount troubles
ULONG __stdcall CRTPDemuxInputPin::NonDelegatingAddRef()
{
    // internal debug-only refcount maintained by base class
    // ASSERT(++m_cRef > 0);
    return m_pFilter->AddRef();
}

ULONG __stdcall CRTPDemuxInputPin::NonDelegatingRelease()
{
    // internal debug-only refcount maintained by base class
    // ASSERT(--m_cRef >= 0);
    return m_pFilter->Release();
}

/*F*
//  Name    : CRTPDemuxInputPin::CRTPDemuxInputPin()
//  Purpose : Constructor. Initialize some member variables and base classes.
//  Context : Constructed as a member class of the CRTPDemux class
//            during its construction.
//  Returns : Nothing.
//  Params  :
//      pName       Name assigned to the object for debugging purposes.
//      pFilter     The RTP Demux filter this pin is connected to.
//      phr         A place to return an error code if we have a problem.
//      pPinName    Name of this pin for use in controlling via the FGM.
//  Notes   : None.
*F*/
CRTPDemuxInputPin::CRTPDemuxInputPin(
    TCHAR *pName,
    CRTPDemux *pFilter,
    HRESULT *phr,
    LPCWSTR pPinName) 
: CBaseInputPin(pName, pFilter, pFilter, phr, pPinName),
  m_pFilter(pFilter)
{
    ASSERT(pFilter);
    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxInputPin::CRTPDemuxInputPin: Constructed at 0x%08x"), this));
} /* CRTPDemuxInputPin::CRTPDemuxInputPin() */


/*F*
//  Name    : CRTPDemuxInputPin::~CRTPDemuxInputPin()
//  Purpose : Destructor
//  Context : Called when we are being deleted.
//            As if you didn't know that.
//  Returns : Nothing.
//  Params  : None.
//  Notes   : None.
*F*/
CRTPDemuxInputPin::~CRTPDemuxInputPin()
{
    ASSERT(m_pFilter->m_pAllocator == NULL);
    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxInputPin::~CRTPDemuxInputPin: Destructor for 0x%08x called"), this));
} /* CRTPDemuxInputPin::~CRTPDemuxInputPin() */


/*F*
//  Name    : CRTPDemuxInputPin::CheckMediaType()
//  Purpose : Check that the media type we are being connected for
//            is what we expect.
//  Context : Called during connection negotiation.
//  Returns :
//      S_OK    The indicated media type matches the one we expect.
//      S_FALSE An unacceptable media type was suggested.
//  Params  : 
//      pmt     A media type that we are expected to compare to our own.
//  Notes   : None.
*F*/
HRESULT 
CRTPDemuxInputPin::CheckMediaType(const CMediaType *pmt)
{
    if ((*pmt->Type() == MEDIATYPE_RTP_Multiple_Stream) && 
        (*(pmt->Subtype()) == MEDIASUBTYPE_RTP_Payload_Mixed)) {
        DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxInputPin::CheckMediaType(): Accepted media type")));
        return S_OK;
    } else {
        DbgLog((LOG_ERROR, 3, TEXT("CRTPDemuxInputPin::CheckMediaType(): Failed to accept media type")));
        return S_FALSE;
    } /* if */
} /* CRTPDemuxInputPin::CheckMediaType() */


/*F*
//  Name    : CRTPDemuxInputPin::GetMediaType()
//  Purpose : Return what media types this pin supports.
//  Context : Called by the filter graph manager to figure out what
//            the heck we can handle.
//  Returns :
//      S_OK    Returned a media type.
//      VFW_S_NO_MORE_ITEMS We only support 1 media type, so any
//                          iPosition value greater than 0 results in this error.
//  Params  : 
//      iPosition   Index of the media type number that we want. Only 0 is valid.
//      pmt         CMediaType to return our media type in.
//  Notes   : None.
*F*/
HRESULT 
CRTPDemuxInputPin::GetMediaType(
    int iPosition,
    CMediaType *pmt)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRTPDemuxInputPin::GetMediaType(): Called for position %d"),
            iPosition));

    ASSERT(iPosition < 3);
    if (iPosition > 1) {
        return VFW_S_NO_MORE_ITEMS;
    } /* if */

    pmt->SetType(&MEDIATYPE_RTP_Multiple_Stream);
    pmt->SetSubtype(g_sudInputPinTypes[iPosition].clsMinorType);

    return S_OK;
} /* CRTPDemuxInputPin::CheckMediaType() */


/*F*
//  Name    : CRTPDemuxInputPin::SetMediaType()
//  Purpose : Set the media type that this pin
//            is to use.
//  Context : Called at the tail end of the connection process.
//  Returns :
//      NOERROR If the media type was accepted.
//      Otherwise can return whatever error code the base class accepts.
//  Params  : 
//      pmt     The media type that we are to use.
//  Notes   : None.
*F*/
HRESULT 
CRTPDemuxInputPin::SetMediaType(
    const CMediaType    *pmt)
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    // Make sure that the base class likes it
    hr = CBaseInputPin::SetMediaType(pmt);
    if (FAILED(hr))
        return hr;

    ASSERT(m_Connected != static_cast<IPin *>(NULL));
    return NOERROR;

} /* CRTPDemuxInputPin::SetMediaType() */


/*F*
//  Name    : CRTPDemuxInputPin::BreakConnect()
//  Purpose : Tell us that our upgraph pin connection is broken.
//            We can release resources as a result.
//  Context : Called when pin connection is broken.
//  Returns :
//      NOERROR Successfully broke connection.
//  Params  : None.
//  Notes   : We should probably empty our SSRC list when this happens! FIX
*F*/
HRESULT 
CRTPDemuxInputPin::BreakConnect()
{
    // Release any allocator that we are holding
    if (m_pFilter->m_pAllocator) {
        m_pFilter->m_pAllocator->Release();
        m_pFilter->m_pAllocator = NULL;
    } /* if */

    return NOERROR;
} /* CRTPDemuxInputPin::BreakConnect() */


/*F*
//  Name    : CRTPDemuxInputPin::GetAllocator()
//  Purpose : Try to find an allocator to use for a graph.
//            The RTP Demux filter doesn't have its own
//            allocator, so it tries to take one from downgraph.
//  Context : Called by the upstream filter during connection negotiation.
//  Returns :
//      NOERROR             Successfully found a memory allocator to suggest.
//      VFW_E_NO_ALLOCATOR  Unable to find an allocator (e.g., no downgraph
//                          filters available which give one.)
//  Params  : 
//      ppAllocator Pointer to place allocator in.
//  Notes   : None.
*F*/
STDMETHODIMP 
CRTPDemuxInputPin::GetAllocator(
    IMemAllocator   **ppAllocator)
{
    CheckPointer(ppAllocator,E_POINTER);
    ValidateReadWritePtr(ppAllocator,sizeof(IMemAllocator *));
    CAutoLock cObjectLock(m_pLock);

    DbgLog((LOG_TRACE, 2, TEXT("CRTPDemuxInputPin::GetAllocator() called.")));

    IPinRecordMapIterator_t iPinRecord = m_pFilter->m_mIPinRecords.begin();
    HRESULT hErr = NOERROR;
    while (iPinRecord != m_pFilter->m_mIPinRecords.end()) {
        if ((*iPinRecord).second.pPin->IsConnected() == TRUE) {
            DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxInputPin::GetAllocator: Asking downstream pin 0x%08x for allocator."),
                    (*iPinRecord).second.pPin->m_pInputPin));
            hErr = (*iPinRecord).second.pPin->m_pInputPin->GetAllocator(ppAllocator);
            if (SUCCEEDED(hErr)) {
                DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxInputPin::GetAllocator: Allocator 0x%08x found from this pin."), 
                        *ppAllocator));
                return hErr;
            } else {
                DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxInputPin::GetAllocator: No allocator available from this pin.")));
            } /* if */
        } /* if */
        iPinRecord++; // Next pin please.
    } /* while */

    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxInputPin::GetAllocator: No allocators available, returning VFW_E_NO_ALLOCATOR.")));
    return VFW_E_NO_ALLOCATOR;
} /* CRTPDemuxInputPin::GetAllocator() */


/*F*
//  Name    : CRTPDemuxInputPin::GetAllocatorRequirements()
//  Purpose : Called by the upstream filter to figure out what
//            allocator properties we want.
//  Context : Called during connecting to the upstream filter
//            and whenever a reconnect occurs because a downstream
//            filter was connected.
//  Returns :
//      E_NOTIMPL   No downstream filters are connected.
//  Params  : 
//      pProperties An output parameter used to indicate what properties
//                  we (our downstream filters) want.
//  Notes   : None.
*F*/
STDMETHODIMP 
CRTPDemuxInputPin::GetAllocatorRequirements(
    ALLOCATOR_PROPERTIES *pProperties)
{
    DbgLog((LOG_TRACE, 2, TEXT("CRTPDemuxInputPin::GetAllocatorRequirements() called.")));

    // HUGEMEMORY set to 0 to avoid that extra that will never be used
    pProperties->cBuffers = 0; // This value will be cumulative with what the
    // downgraph filters want, because we will always want to be able to look
    // at one media sample even if the rest are held downgraph.

    pProperties->cbBuffer = 12; // This value will be the max of what all the
    // downgraph filters want.
    pProperties->cbAlign = 4; // This will also be the max.
    pProperties->cbPrefix = 0;// As will this.
    // Note that it only makes sense to make the count cumulative.

    HRESULT hErr;
    ALLOCATOR_PROPERTIES sDowngraphProperties;
    IPinRecordMapIterator_t iIPinRecord = m_pFilter->m_mIPinRecords.begin();
    while(iIPinRecord != m_pFilter->m_mIPinRecords.end()) {
        if ((*iIPinRecord).second.pPin->IsConnected() == TRUE) {
            // This pin is bound. Query the downstream filter for his requirements.
            DbgLog((LOG_TRACE, 4, TEXT("CRTPDemuxInputPin::GetAllocatorRequirements(): Querying downgraph input pin 0x%08x for allocator requirements"),
                    (*iIPinRecord).second.pPin->m_pInputPin));
            hErr = (*iIPinRecord).second.pPin->m_pInputPin->GetAllocatorRequirements(&sDowngraphProperties);
            if (FAILED(hErr)) {
                DbgLog((LOG_ERROR, 3, TEXT("CRTPDemuxInputPin::GetAllocatorRequirements(): Error 0x%08x querying downgraph input pin 0x%08x for allocator requirements!"),
                        hErr, (*iIPinRecord).second.pPin->m_pInputPin));
                // Don't error out, because the downgraph filter might just not care.
            } else {
                DbgLog((LOG_TRACE, 4, TEXT("CRTPDemuxInputPin::GetAllocatorRequirements(): downgraph pin 0x%08x requsts: cBuffers=%d, cbBuffer=%d, cbPrefix=%d, cbAlign=%d"),
                        (*iIPinRecord).second.pPin->m_pInputPin, 
                        sDowngraphProperties.cBuffers, 
                        sDowngraphProperties.cbBuffer, 
                        sDowngraphProperties.cbPrefix, 
                        sDowngraphProperties.cbAlign));
                // HUGEMEMORY
                pProperties->cBuffers += sDowngraphProperties.cBuffers;
                pProperties->cbBuffer  = max(sDowngraphProperties.cbBuffer, pProperties->cbBuffer);
                pProperties->cbAlign   = max(sDowngraphProperties.cbAlign,  pProperties->cbAlign);
                pProperties->cbPrefix  = max(sDowngraphProperties.cbPrefix, pProperties->cbPrefix);
            } /* if */
        } /* if */
        iIPinRecord++;
    } /* while */

    pProperties->cBuffers = max(pProperties->cBuffers, 9);
    
    DbgLog((LOG_TRACE, 4, TEXT("CRTPDemuxInputPin::GetAllocatorRequirements(): final values: cBuffers=%d, cbBuffer=%d, cbPrefix=%d, cbAlign=%d"),
            pProperties->cBuffers, pProperties->cbBuffer, pProperties->cbPrefix, pProperties->cbAlign));
    return NOERROR;
} /* CRTPDemuxInputPin::GetAllocatorRequirements() */


/*F*
//  Name    : CRTPDemuxInputPin::NotifyAllocator()
//  Purpose : Tell us what allocator will be used by this graph.
//  Context : Called by the upstream filter once it has made its
//            decision as to what allocator to use.
//  Returns :
//      NOERROR Accepted new allocator.
//      Any error code returned by downgraph filters if they don't
//              accept the new allocator.
//  Params  : 
//      pAllocator  The new allocator to be used.
//      bReadOnly   Whether this is a read-only allocator or not.
//  Notes   : None.
*F*/
STDMETHODIMP
CRTPDemuxInputPin::NotifyAllocator(
    IMemAllocator   *pAllocator, 
    BOOL            bReadOnly)
{
    CheckPointer(pAllocator,E_POINTER);
    ValidateReadPtr(pAllocator,sizeof(IMemAllocator));

    CAutoLock lock_it(m_pLock);

    // First make sure all the downgraph pins like this allocator.
    HRESULT hErr = NOERROR;
    IPinRecordMapIterator_t iIPinRecord = m_pFilter->m_mIPinRecords.begin();
    while(iIPinRecord != m_pFilter->m_mIPinRecords.end()) {
        if ((*iIPinRecord).second.pPin->IsConnected() == TRUE) {
            // This pin is bound. Notify the downstream filter.
            DbgLog((LOG_TRACE, 4, TEXT("CRTPDemuxInputPin::NotifyAllocator(): Notifying output pin 0x%08x of new allocator"),
                    (*iIPinRecord).second.pPin));
            hErr = (*iIPinRecord).second.pPin->NotifyAllocator(pAllocator, bReadOnly);
            if (FAILED(hErr)) {
                DbgLog((LOG_ERROR, 3, TEXT("CRTPDemuxInputPin::NotifyAllocator(): Error 0x%08x notifying output pin 0x%08x of new allocator!"),
                        hErr, (*iIPinRecord).second.pPin));
                m_pFilter->m_pAllocator = static_cast<IMemAllocator *>(NULL);
                m_pFilter->m_pAllocator->Release();
                return hErr;
            } /* if */
        } /* if */
        iIPinRecord++;
    } /* while */

    // Now store the allocator locally.
    // It's possible that the old and the new are the same thing.
    // AddRef before release ensures that we don't unload the thing!
    pAllocator->AddRef();

    // Free the old allocator if any
    if (m_pFilter->m_pAllocator)
        m_pFilter->m_pAllocator->Release();

    m_pFilter->m_pAllocator = pAllocator;

    return NOERROR;
} /* CRTPDemuxInputPin::NotifyAllocator() */


/*F*
//  Name    : CRTPDemuxInputPin::EndOfStream()
//  Purpose : 
//  Context : 
//  Returns :
//  Params  : 
//  Notes   : None.
*F*/
HRESULT 
CRTPDemuxInputPin::EndOfStream()
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    // Walk through the output pins list, sending the message downstream
    IPinRecordMapIterator_t iPinRecordMapIterator = m_pFilter->m_mIPinRecords.begin();

    while (iPinRecordMapIterator != m_pFilter->m_mIPinRecords.end()) {
        hr = (*iPinRecordMapIterator).second.pPin->DeliverEndOfStream();
        if (FAILED(hr)) {
            return hr;
        } /* if */

        iPinRecordMapIterator++;
    } /* while */

    return(NOERROR);
} /* CRTPDemuxInputPin::EndOfStream() */


/*F*
//  Name    : CRTPDemuxInputPin::BeginFlush()
//  Purpose : 
//  Context : 
//  Returns :
//  Params  : 
//  Notes   : None.
*F*/
HRESULT 
CRTPDemuxInputPin::BeginFlush()
{
    CAutoLock lock_it(m_pFilter);
    HRESULT hr = NOERROR;

    // Walk through the output pins list, sending the message downstream
    IPinRecordMapIterator_t iPinMapIterator = m_pFilter->m_mIPinRecords.begin();

    while (iPinMapIterator != m_pFilter->m_mIPinRecords.end()) {
        hr = (*iPinMapIterator).second.pPin->DeliverBeginFlush();
        if (FAILED(hr)) {
            return hr;
        } /* if */
    } /* while */

    return CBaseInputPin::BeginFlush();
} /* CRTPDemuxInputPin::BeginFlush() */


/*F*
//  Name    : CRTPDemuxInputPin::EndFlush()
//  Purpose : 
//  Context : 
//  Returns :
//  Params  : 
//  Notes   : None.
*F*/
HRESULT 
CRTPDemuxInputPin::EndFlush()
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    // Walk through the output pin list, sending the message downstream
    IPinRecordMapIterator_t iPinMapIterator = m_pFilter->m_mIPinRecords.begin();

    while (iPinMapIterator != m_pFilter->m_mIPinRecords.end()) {
        hr = (*iPinMapIterator).second.pPin->DeliverEndFlush();
        if (FAILED(hr)) {
            return hr;
        } /* if */
    } /* while */

    return CBaseInputPin::EndFlush();
} /* CRTPDemuxInputPin::EndFlush() */


/*F*
//  Name    : CRTPDemuxInputPin::Receive()
//  Purpose : Get an RTP packet and "do the right thing" with it.
//            This means either deliver it to the right output pin,
//            map it to an output pin (and then deliver it), or
//            drop it on the floor.
//  Context : Called by the upgraph OutputPin::Deliver() routine.
//  Returns :
//      VFW_E_SAMPLE_REJECTED   If the sample is too short to be a 
//                              valid RTP packet.
//      Otherwise it returns S_OK if the packet is successfully processed
//          (e.g., delivered or dropped) or an error code from
//          the base class Receive(), from the samples's GetPointer(),
//          or from OldSSRC()/TryNewSSRC().
//  Params  : 
//      pSample The media sample we are to try to deliver.
//  Notes   : None.
*F*/
HRESULT 
CRTPDemuxInputPin::Receive(
    IMediaSample *pSample)
{
    static dwExpirePinTime = 0;
    const PINEXPIREINTERVAL = 2000;

    Lock();
    
    HRESULT hr = CBaseInputPin::Receive(pSample);
    if (S_OK != hr) {
        DbgLog((LOG_ERROR, 3, TEXT("CRTPDemuxInputPin::Receive(): Error 0x%08x calling base class!"),
                hr));
        Unlock();
        return hr;
    }

    DbgLog((LOG_TRACE, 5, TEXT("CRTPDemuxInputPin::Receive(): Called for IMediaSample 0x%08x"),
            pSample));

    int iSampleLength = pSample->GetActualDataLength();
    if (iSampleLength < 12) {
        DbgLog((LOG_ERROR, 3, TEXT("CRTPDemuxInputPin::Receive(): Sample length (%d < 12) too short!"),
                iSampleLength));
        // This should never happen, as UDP should preserve packet length. 
        Unlock();
        return VFW_E_SAMPLE_REJECTED;
    } /* if */

    DWORD *pdwBuffer;
    hr = pSample->GetPointer(reinterpret_cast<BYTE **>(&pdwBuffer));
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 3, TEXT("CRTPDemuxInputPin::Receive(): Error 0x%08x getting sample pointer!"),
                hr));
        Unlock();
        return hr;
    } /* if */
    SSRCRecordMapIterator_t iSSRCMapRecord = m_pFilter->m_mSSRCRecords.find(SSRC_VALUE(pdwBuffer));
    if (iSSRCMapRecord == m_pFilter->m_mSSRCRecords.end()) {
        DbgLog((LOG_TRACE, LOG_DEVELOP /*3*/,
                TEXT("CRTPDemuxInputPin::Receive(): "
                     "New SSRC 0x%08x detected, PT value 0x%02x"),
                SSRC_VALUE(pdwBuffer), PT_VALUE(pdwBuffer)));
        // Add a record for this SSRC to our SSRC record map.
        SSRCRecord_t sNewRecord;
        sNewRecord.bPT = PT_VALUE(pdwBuffer);
        sNewRecord.m_dwFlag = 0;
        sNewRecord.pPin = static_cast<CRTPDemuxOutputPin *>(NULL);
        pair<const DWORD, SSRCRecord_t> pNewSSRCRecordMapping(SSRC_VALUE(pdwBuffer), sNewRecord);
        m_pFilter->m_mSSRCRecords.insert(pNewSSRCRecordMapping);
        ASSERT(m_pFilter->m_mSSRCRecords.find(SSRC_VALUE(pdwBuffer)) != m_pFilter->m_mSSRCRecords.end()); // Sanity check.
            
        // rajeevb - If this new SSRC doesn't have a pin, don't remove the SSRC record.
        // This ensures that any detected ssrcs will have a record and can be enumerated for
        // manual mapping if required.
        hr = TryNewSSRC(pSample, pdwBuffer, iSampleLength,
                        (SSRCRecord_t *)NULL);
        Unlock();
        return(hr);
    } else if ( (*iSSRCMapRecord).second.pPin == NULL ) {
        // rajeevb - this check has been introduced here to avoid having to delete the ssrc record
        // for an unmaped ssrc each time
        // the ssrc is not mapped to any pin
        DbgLog((LOG_TRACE, 4,
                TEXT("CRTPDemuxInputPin::Receive(): "
                     "Unmapped SSRC 0x%08x detected"),
                SSRC_VALUE(pdwBuffer)));

        // if the payload type has changed since last time, change it
        if ( (PT_VALUE(pdwBuffer) != (*iSSRCMapRecord).second.bPT) &&
             (PT_VALUE(pdwBuffer) != PAYLOAD_SR) ){
            // The PT of the packet didn't match that of the record, and
            // the packet wasn't a sender report. This means the PT value
            // of record for the packet has changed. Update the record
            DbgLog((LOG_TRACE, LOG_DEVELOP /*4*/,
                    TEXT("CRTPDemuxInputPin::Receive(): "
                         "Unmapped SSRC 0x%08x PT changed 0x%08x -> 0x%08x"),
                    SSRC_VALUE(pdwBuffer),
                    (*iSSRCMapRecord).second.bPT,
                    PT_VALUE(pdwBuffer)
                    ));
                    
            (*iSSRCMapRecord).second.bPT = PT_VALUE(pdwBuffer);
            (*iSSRCMapRecord).second.m_dwFlag = 0;
        }
        hr = TryNewSSRC(pSample, pdwBuffer, iSampleLength,
                        &((*iSSRCMapRecord).second));
        Unlock();
        return(hr);
    } else {
        DbgLog((LOG_TRACE, 6,
                TEXT("CRTPDemuxInputPin::Receive(): "
                     "Old SSRC 0x%08x detected"),
                SSRC_VALUE(pdwBuffer)));

        hr = OldSSRC(pSample, iSSRCMapRecord, pdwBuffer, iSampleLength);

        // Check to see if other pins have expired.
        const DWORD dwCurrentTime = timeGetTime();
        if (dwCurrentTime - dwExpirePinTime > PINEXPIREINTERVAL)
        {
            ExpirePins();
            dwExpirePinTime = dwCurrentTime;
        }

        Unlock();
        return hr;
    } /* if */
} /* CRTPDemuxInputPin::Receive() */


/*F*
//  Name    : CRTPDemuxInputPin::ReceiveCanBlock()
//  Purpose : Indicates whether this filter can block. Since this filter is
//            just a demultiplexer, it can't, but our downstream filters might.
//  Context : Called by upstream filters if they are concerned that we might block.
//  Returns :
//      S_FALSE Neither this filter nor any downstream filters block.
//      S_OK    A downstream filter has indicated that it can block.
//  Params  : None.
//  Notes   : None.
*F*/
STDMETHODIMP 
CRTPDemuxInputPin::ReceiveCanBlock(void)
{
    CAutoLock lock_it(m_pFilter);
    HRESULT hr = NOERROR;

    // Walk through the output pins list, sending the message downstream
    IPinRecordMapIterator_t iPinMapIterator = m_pFilter->m_mIPinRecords.begin();

    while (iPinMapIterator != m_pFilter->m_mIPinRecords.end()) {
        if ((*iPinMapIterator).second.pPin->IsConnected() == TRUE) {
            DbgLog((LOG_TRACE, 4, TEXT("CRTPDemuxInputPin::ReceiveCanBlock(): Checking if connected downstream input pin 0x%08x can block"),
                    (*iPinMapIterator).second.pPin->m_pInputPin));
            if ((*iPinMapIterator).second.pPin->m_pInputPin->ReceiveCanBlock() == S_OK) {
                DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxInputPin::Receive(): Downstream input pin 0x%08x can block. Returning S_OK"),
                        (*iPinMapIterator).second.pPin->m_pInputPin));
                return S_OK;
            } /* if */
        } /* if */
        iPinMapIterator++; // Next pin please.
    } /* while */

    // If we receive this point, none of out connected filters can block,
    // and we don't block, so return S_FALSE.
    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxInputPin::ReceiveCanBlock(): No connected downstream pins block. Returning S_FALSE")));
    return S_FALSE;
} /* CRTPDemuxInputPin::ReceiveCanBlock() */


/*F*
//  Name    : CRTPDemuxInputPin::TryNewSSRC()
//  Purpose : Searches the PT map for available pins that
//            match the PT of the given packet.
//  Context : Called by Receive() for a new SSRC.
//  Returns :
//      NOERROR Successfully found a free pin in our map of
//              PTs to automatic mapping pins and mapped the
//              new SSRC to it.
//      S_FALSE No available pins to map this SSRC to.
//  Params  : 
//      pSample         Pointer to an IMediaSample containing an
//                      RTP packet with a new SSRC in it.
//      pdwBuffer       Pointer to the buffer in the sample.
//      iSampleLength   Length of the buffer in the sample.
//  Notes   : Searches the map of PTs to to pins. If nothing is found,
//            returns S_FALSE immediately. Otherwise maps the new
//            SSRC to the pin that was found, then calls OldSSRC
//            in order to arrange delivery of the packet.
*F*/
HRESULT 
CRTPDemuxInputPin::TryNewSSRC(
    IMediaSample    *pSample,
    DWORD           *pdwBuffer, 
    int             iSampleLength,
    SSRCRecord_t    *pSSRCRecord)
{
    ExpirePins();

    DWORD ptnum;
    
    IPinRecordMapIterator_t iIPinRecord =
        m_pFilter->FindMatchingFreePin(PT_VALUE(pdwBuffer), TRUE, &ptnum);
    if (iIPinRecord == m_pFilter->m_mIPinRecords.end()) {
        DbgLog((LOG_TRACE, 6,
                TEXT("CRTPDemuxInputPin::CheckAutomap(): "
                     "SSRC 0x%08X with payload 0x%08x returned "
                     "unrendered (no automapping pins to match)"),
                SSRC_VALUE(pdwBuffer), PT_VALUE(pdwBuffer)));
        
        RTPDEMUX_EVENT_t event;
        DWORD dwNotify = TRUE;
        event = ptnum? RTPDEMUX_NO_PINS_AVAILABLE : RTPDEMUX_NO_PAYLOAD_TYPE;
        
        if (pSSRCRecord && (pSSRCRecord->m_dwFlag & B2M(event)))
            dwNotify = FALSE;

        if (dwNotify) {
            RTPDemuxNotifyEvent(event,                 // Event
                                SSRC_VALUE(pdwBuffer), // SSRC
                                PT_VALUE(pdwBuffer));  // PT
            // Prevent to notify more than once
            if (pSSRCRecord)
                pSSRCRecord->m_dwFlag |= B2M(event);
        }
        
        return S_FALSE;
    } /* if */

    // If we reach this point, we found an available pin to map this SSRC to.
    HRESULT hr = m_pFilter->MapPin((*iIPinRecord).second.pPin, SSRC_VALUE(pdwBuffer));
    ASSERT(hr == NOERROR);

    SSRCRecordMapIterator_t iSSRCMapRecord = m_pFilter->m_mSSRCRecords.find(SSRC_VALUE(pdwBuffer));
    ASSERT(iSSRCMapRecord != m_pFilter->m_mSSRCRecords.end()); // Better be in map!
    RTPDemuxNotifyEvent(RTPDEMUX_PIN_MAPPED,   // Event
#if 1
                        (DWORD_PTR)            // pass current Pin 
                        (static_cast<IPin *>((*iIPinRecord).second.pPin)),
#else
                        (DWORD_PTR)            // pass connected Pin
                        ((*iIPinRecord).second.pPin->GetConnected()),
#endif
                        PT_VALUE(pdwBuffer));  // PT

    RTPDemuxNotifyEvent(RTPDEMUX_SSRC_MAPPED,  // Event
                        SSRC_VALUE(pdwBuffer), // SSRC
                        PT_VALUE(pdwBuffer));  // PT
    // Just use the same routine to handle delivery.
    return OldSSRC(pSample, iSSRCMapRecord, pdwBuffer, iSampleLength);
} /* CRTPDemuxInputPin::TryNewSSRC() */


/*F*
//  Name    : CRTPDemuxInputPin::ExpirePins()
//  Purpose : Checks the set of currently mapped pins to see if
//            any of them is mapped to an SSRC which has been silent
//            for too long. If this is the case, the pin is unmapped
//            from the SSRC.
//  Context : Called in CheckAutoMap() when a new SSRC is detected, just
//            before the map of PTs to automapping pins is searched for
//            an unoccupied pin to map the new SSRC to.
//  Returns : Nothing.
//  Params  : None.
//  Notes   : By only expiring ping when we have a new SSRC, we defer
//            this task until the last possible moment (just before
//            searching for a pin for the new SSRC.)  We also avoid
//            needing to use a callback thread or anything like that.
*F*/
void
CRTPDemuxInputPin::ExpirePins(void)
{
    const DWORD dwCurrentTime = timeGetTime();
    for(IPinRecordMapIterator_t iCurrentIPinRecord = m_pFilter->m_mIPinRecords.begin();
        iCurrentIPinRecord != m_pFilter->m_mIPinRecords.end();
        iCurrentIPinRecord++) {
        if ((*iCurrentIPinRecord).second.pPin->IsAutoMapping() &&
            ((*iCurrentIPinRecord).second.pPin->GetSSRC() != static_cast<DWORD>(NULL))) {
            // Only automapping pins which are currently mapped can expire.
            DbgLog((LOG_TRACE, 6,
                    TEXT("CRTPDemuxInputPin::ExpirePin(): "
                         "Checking pin 0x%08x at time 0x%08x "
                         "for expired SSRC"),
                    (*iCurrentIPinRecord).first, dwCurrentTime));
            if (dwCurrentTime > 
                ((*iCurrentIPinRecord).second.pPin->GetLastPacketDeliveryTime() +
                 (*iCurrentIPinRecord).second.pPin->GetTimeoutDelay())) {
                // The SSRC this pin is mapped to has been silent for too
                // long and needs to be unmapped now.
                DWORD dwMappedSSRC =
                    (*iCurrentIPinRecord).second.pPin->GetSSRC();

                DbgLog((LOG_TRACE, 3,
                        TEXT("CRTPDemuxInputPin::ExpirePin(): "
                             "Pin 0x%08x unmapped from SSRC 0x%08x "
                             "because of expiration"),
                        (*iCurrentIPinRecord).first, dwMappedSSRC));

                RTPDemuxNotifyEvent(RTPDEMUX_PIN_UNMAPPED,  // Event
#if 1
                                    (DWORD_PTR)        // pass current Pin 
                                    (static_cast<IPin *>
                                     ((*iCurrentIPinRecord).second.pPin)),
#else
                                    (DWORD_PTR)       // pass connected Pin
                                    ((*iCurrentIPinRecord).second.pPin->
                                     GetConnected()),
#endif
                                    (*iCurrentIPinRecord).second.pPin->
                                    GetPTValue());          // PT

                RTPDemuxNotifyEvent(RTPDEMUX_SSRC_UNMAPPED, // Event
                                    dwMappedSSRC,           // SSRC
                                    (*iCurrentIPinRecord).second.pPin->
                                    GetPTValue());          // PT

                
                SSRCRecordMapIterator_t iSSRCMapRecord =
                    m_pFilter->m_mSSRCRecords.find(
                            (*iCurrentIPinRecord).second.pPin->GetSSRC()
                        );
                
                // Allow again RTPDEMUX_NO_PINS_AVAILABLE and
                // RTPDEMUX_NO_PAYLOAD_TYPE notifications
                if (iSSRCMapRecord != m_pFilter->m_mSSRCRecords.end()) {
                    // found
                    (*iSSRCMapRecord).second.m_dwFlag &=
                        ~(B2M(RTPDEMUX_NO_PINS_AVAILABLE) |
                          B2M(RTPDEMUX_NO_PAYLOAD_TYPE));
                }
                
                DbgLog((LOG_TRACE, 3,
                        TEXT("                                "
                             "Last packet at 0x%08x, timeout 0x%08x, "
                             "current time 0x%08x"),
                        (*iCurrentIPinRecord).second.pPin->
                        GetLastPacketDeliveryTime(),
                        (*iCurrentIPinRecord).second.pPin->GetTimeoutDelay(),
                        dwCurrentTime));
                DWORD dwTemp;
                HRESULT hr = (*iCurrentIPinRecord).second.pPin->
                    m_pFilter->UnmapPin((*iCurrentIPinRecord).first, &dwTemp);
                ASSERT(dwMappedSSRC == dwTemp);

                ASSERT(hr == NOERROR);
            } /* if */
        } /* if */
    } /* for */

    return;
} /* CRTPDemuxInputPin::ExpirePins() */


/*F*
//  Name    : CRTPDemuxInputPin::OldSSRC()
//  Purpose : Handle a packet from a SSRC that we have seen before.
//            Basically, decide to either drop the packet or
//            deliver it to some output pin.
//  Context : Called by Receive() when it has determined that
//            a packet is from a SSRC that we have seen before.
//            Called by TryNewSSRC() when it finds an empty pin
//            and maps a new SSRC to it.
//  Returns :
//      NOERROR     This is almost always returned, because to
//                  return anything else causes a graph to stop.
//                  This function returns NOERROR when it drops
//                  a packet (e.g. unmapped SSRC).
//      Otherwise this function returns whatever the result
//                  is of delivering the packet, or calling TryNewSSRC().
//  Params  :
//      pSample         The media sample containing the packet.
//      iSSRCMapRecord  The record of this SSRC in our SSRC map.
//      pdwBuffer       Pointer to the buffer contained by this
//                      media sample. Passed in as a convenience,
//                      since it is already determined outside.
//      iPacketLength   Actual packet length. Passed for same reasons
//                      as pdwBuffer.
//  Notes   : It may be faster to just called GetPointer() and
//            GetActualDataLength() than push/pop these parameters
//            off the stack, but I don't think so.
*F*/
HRESULT
CRTPDemuxInputPin::OldSSRC(
    IMediaSample            *pSample,
    SSRCRecordMapIterator_t iSSRCMapRecord,
    DWORD                   *pdwPacket, 
    int                     iPacketLength)
{
    // rajeevb - at this point the ssrc record must be mapped to a pin
    ASSERT((*iSSRCMapRecord).second.pPin != (CRTPDemuxOutputPin *) NULL);

    if (PT_VALUE(pdwPacket) != (*iSSRCMapRecord).second.bPT) {
        if (PT_VALUE(pdwPacket) != PAYLOAD_SR) {
            // The PT of the packet didn't match that of the record, and
            // the packet wasn't a sender report. This means the PT value
            // of record for the packet has changed. Update the record
            // and automap the SSRC if necessary.
            if ((*iSSRCMapRecord).second.pPin != static_cast<CRTPDemuxOutputPin *>(NULL)) {
                DbgLog((LOG_TRACE, 1, TEXT("CRTPDemuxInputPin::OldSSRC(): SSRC 0x%08x unmapped from pin 0x%08x because of changed PT (0x%02x->0x%02x)"),
                        SSRC_VALUE(pdwPacket), (*iSSRCMapRecord).second.pPin, (*iSSRCMapRecord).second.pPin->GetPTValue(), PT_VALUE(pdwPacket)));

                (*iSSRCMapRecord).second.m_dwFlag = 0;
                // rajeevb - previously UnmapSSRC which currently removes the SSRC record. TryNewSSRC expects
                // the SSRC record to exist
                DWORD   dwTempSSRC;
                HRESULT hr = m_pFilter->ClearSSRCForPin((*iSSRCMapRecord).second.pPin, dwTempSSRC);
                ASSERT(hr == NOERROR); // This better unmap, as we had recorded it as mapped.
                // FIX - signal unmapping here.
                // Treat a changed PT SSRC as a new SSRC.
                // rajeevb - if TryNewSSRC fails, don't remove the ssrc record
                return TryNewSSRC(pSample, pdwPacket, iPacketLength,
                                  &(*iSSRCMapRecord).second);
            } /* if */
        } else {
            // Packet PT value doesn't match because it is a SR. Fall through to below to forward it.
        } /* if */
    } /* if */

    // If we reach this point, the PT value of the packet matches
    // the PT value we expect for it, or it is a sender report.
    if (PT_VALUE(pdwPacket) == PAYLOAD_SR) {
        DbgLog((LOG_TRACE, 5, TEXT("CRTPDemuxInputPin::OldSSRC(): Delivering SR to output pin 0x%08x"),
                (*iSSRCMapRecord).second.pPin));
    } else {
        DbgLog((LOG_TRACE, 5, TEXT("CRTPDemuxInputPin::OldSSRC(): Delivering payload 0x%02x packet to output pin 0x%08x"),
                PT_VALUE(pdwPacket), (*iSSRCMapRecord).second.pPin));
        ASSERT(PT_VALUE(pdwPacket) == static_cast<BYTE>((*iSSRCMapRecord).second.bPT));
        ASSERT(PT_VALUE(pdwPacket) == static_cast<BYTE>((*iSSRCMapRecord).second.pPin->GetPTValue()));
    } /* if */

    /* This function is always called with the lock held, unlock
       during deliver, then lock again, the caller will unlock */
    Unlock();
    HRESULT hr = (*iSSRCMapRecord).second.pPin->Deliver(pSample);
    Lock();

    return(hr);
} /* CRTPDemuxInputPin::OldSSRC() */


/*F*
//  Name    : CRTPDemuxInputPin::PassNotify()
//  Purpose : Deliver a quality notification upgraph
//            and to a quality sink, if one is specified.
//  Context : Called by CRTPDemuxOutputPin::Notify().
//  Returns : 
//      VFW_E_NOT_FOUND     No upstream pin to pass notify to.
//      Otherwise this returns whatever the upstream pin returns to Notify().
//  Params  :
//      q   Quality indication to pass.
//  Notes   : 
//      The RTP Demux filter really doesn't have anything it can do
//      to increase performance, as it is purely data driven and
//      doesn't do any sort of transformations.
//      Maybe it should stop delivering data to pins which are 
//      automapping, concentrating on those pins which are
//      manually mapped (and therefore implicitly of greater importance.)
//      Something to consider later. FIX.
*F*/
HRESULT
CRTPDemuxInputPin::PassNotify(Quality q)
{
    // We pass the message on, which means that we find the quality sink
    // for our input pin and send it there

    HRESULT hr;
    if (m_pQSink!=NULL) {
        DbgLog((LOG_TRACE, 6, TEXT("CRTPDemuxInputPin::PassNotify: Delivering quality notification to quality sink.")));
        hr = m_pQSink->Notify(m_pFilter, q);
        DbgLog((LOG_TRACE, 7, TEXT("CRTPDemuxInputPin::PassNotify: Quality sink returned 0x%08x."), hr));
        return hr;
    } else {
        // no sink set, so pass it upstream
        IQualityControl * pIQC;

        hr = VFW_E_NOT_FOUND;                   // default
        if (m_Connected) {
            m_Connected->QueryInterface(IID_IQualityControl, (void**)&pIQC);
            if (pIQC!=NULL) {
                DbgLog((LOG_TRACE, 6, TEXT("CRTPDemuxInputPin::PassNotify: Delivering quality notification to upgraph input pin.")));
                hr = pIQC->Notify(m_pFilter, q);
                DbgLog((LOG_TRACE, 7, TEXT("CRTPDemuxInputPin::PassNotify: Upgraph input pin returned 0x%08x."), hr));
                pIQC->Release();
            } else {
                DbgLog((LOG_TRACE, 6, TEXT("CRTPDemuxInputPin::PassNotify: Upgraph input pin doesn't support IQualityControl. Returning 0x%08x."), hr));
            } /* if */
        } /* if */
        return hr;
    } /* if */
} /* CRTPDemuxInputPin:: PassNotify() */


#if defined(DEBUG)
static char *sEventString[] = {"SSRC_MAPPED",
                               "SSRC_UNMAPPED",
                               "PIN_MAPPED",
                               "PIN_UNMAPPED",
                               "NO_PINS_AVAILABLE",
                               "NO_PAYLOAD_TYPE"};
#endif

HRESULT
CRTPDemuxInputPin::RTPDemuxNotifyEvent(RTPDEMUX_EVENT_t Event,
                                       DWORD_PTR dwSSRC,
                                       DWORD dwPT)
{
#if defined(DEBUG)
    long ID = -1;
    if (m_pFilter)
        ID = m_pFilter->GetDemuxID_();
    
    DbgLog((
            LOG_TRACE, 
            LOG_DEVELOP, 
            TEXT("CRTPDemuxInputPin::RTPDemuxNotifyEvent: "
                 "%s, DemuxID:%d, SSRC:0x%X"),
            sEventString[Event], ID, dwSSRC
            
        ));
#endif

    if (m_pFilter) {

        HRESULT hr;
        hr = m_pFilter->NotifyEvent(RTPDMX_EVENTBASE + Event,
                                    (DWORD)dwSSRC,
                                    dwPT); //m_pFilter->GetDemuxID_());
        if ( SUCCEEDED(hr) ) {
            DbgLog((
                    LOG_TRACE, 
                    LOG_DEVELOP, 
                    TEXT("CRTPDemuxInputPin::RTPDemuxNotifyEvent: "
                         "Succeeded !!!")
                ));
        } else {
            DbgLog((
                    LOG_TRACE, 
                    LOG_DEVELOP, 
                    TEXT("CRTPDemuxInputPin::RTPDemuxNotifyEvent: "
                         "failed 0x%X"),
                    hr
                ));
        }
        return(hr);
    }
    
    return(S_OK);
}

#endif _RTPDINPP_CPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpdmx\rtpdmx.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : RTPDmx.h
// Purpose  : Define the class that implements the Intel RTP Demux filter.
// Contents : 
//*M*/

#ifndef _RTPDMX_H_
#define _RTPDMX_H_

class CRTPDemux;
class CRTPDemuxOutputPin;
class CSSRCEnumPin;


/*C*
//  Name    : CRTPDemux
//  Purpose : Implements the RTP Demux filter class.
//  Context : Handles most interaction with the application
//            (e.g., implements IIntelRTPDemuxFilter).
*C*/
class 
CRTPDemux
: public CBaseFilter,
  public CPersistStream,
  public CCritSec, 
  public IRTPDemuxFilter,
  public ISpecifyPropertyPages
{
public:

    CRTPDemux(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr);
    ~CRTPDemux();

    CBasePin *GetPin(int n);
    int GetPinCount();

    // Persistent pin id support
    STDMETHODIMP FindPin(LPCWSTR pwszPinId, IPin **ppPin);

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    STDMETHODIMP GetPages(CAUUID *pcauuid);

    // Send EndOfStream if no input connection
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP Pause();
    STDMETHODIMP Stop();
    STDMETHODIMP StartStreaming();

    // IUnknown functions.
    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID                          riid, 
        void                            **ppv);
    DECLARE_IUNKNOWN

    // IPersistStream interfaces
    HRESULT _stdcall GetClassID(
        CLSID                           *pCLSID);
    HRESULT ReadFromStream(
        IStream                         *pStream);
    HRESULT WriteToStream(
        IStream                         *pStream);
    DWORD GetSoftwareVersion(void);
    int SizeMax(void);

    // IIntelRTPDemuxFilter functions.
    STDMETHODIMP EnumSSRCs(
        IEnumSSRCs                      **ppEnumSSRCs);
    STDMETHODIMP GetPinInfo(
        IPin                            *pIPin,
        DWORD                           *pdwSSRC,
        BYTE                            *pbPT,
        BOOL                            *pbAutoMapping,
        DWORD                           *pdwTimeout);
    STDMETHODIMP SetPinCount(
        DWORD                           dwPinCount);
    STDMETHODIMP SetPinMode(
        IPin                            *pIPin,
        BOOL                            bAutomatic);
    STDMETHODIMP SetPinSourceTimeout(
        IPin                            *pIPin,
        DWORD                           dwMilliseconds);
    STDMETHODIMP SetPinTypeInfo(
        IPin                            *pIPin,
        BYTE                            bPT,
        GUID                            gMinorType);
    STDMETHODIMP GetSSRCInfo(
        DWORD                           dwSSRC,
        BYTE                            *pbPT,
        IPin                            **ppIPin);
    STDMETHODIMP MapSSRCToPin(
        DWORD                           dwSSRC,
        IPin                            *pIPin);
    STDMETHODIMP UnmapPin(
        IPin                            *pIPin,
        DWORD                           *pdwSSRC);
    STDMETHODIMP UnmapSSRC(
        DWORD                           dwSSRC,
        IPin                            **ppIPin);
    STDMETHODIMP GetDemuxID(
        DWORD                           *pdwID);
private:
    // Let the pins access our internal state
    friend class CRTPDemuxInputPin;
    friend class CRTPDemuxOutputPin;
    // Let the enumerator look inside as well.
    friend class CSSRCEnum;

    // Declare an input pin.
    CRTPDemuxInputPin   *m_pInput;              // ZCS 7-7-97 changed to a pointer
    IMemAllocator       *m_pAllocator;          // Allocator from our input pin

    SSRCRecordMap_t     m_mSSRCRecords;
    IPinRecordMap_t     m_mIPinRecords;
    int                 m_iNextOutputPinNumber;

	long                m_lDemuxID;

	inline long GetDemuxID_() { return(m_lDemuxID); }
	
    // Helper functions
    // Allocate the indicated number of new pins.
    HRESULT AllocatePins(DWORD          dwPinsToAllocate);

    // Find a pin in our pin record list that matches the
    // indicated PT and is not currently mapped.
    IPinRecordMapIterator_t FindMatchingFreePin(
        BYTE    bPT,
        BOOL    bMustBeAutoMapping,
		DWORD  *pdwPTNum); // Number of pins with that PT (not accurate)

    // Look in the registry to determine the subtype associated with a particular PT.
    GUID FindSubtypeFromPT(BYTE bPT);

    int GetNumFreePins(void);
	
	// clears the ssrc value (to 0) on the pin record
	STDMETHODIMP ClearSSRCForPin(
		IPin							*pIPin,
		DWORD							&dwSSRC);

    // Try to remove the indicated number of unconnected pins.
    HRESULT RemovePins(DWORD            dwPinsToRemove);
    // Verify the PT/minor type combo and set it for the pin.
    HRESULT SetupPinTypeInfo(
        CRTPDemuxOutputPin  *pIPin,
        BYTE                bPT,
        GUID                gMinorType);
    // Map the indicated pin to the indicated SSRC.
    HRESULT MapPin(
        CRTPDemuxOutputPin   *pPin,
        DWORD                dwSSRC);
protected:
    // Acquire the lock
    void DmxLock() { m_pLock->Lock(); }

    // Release the lock
    void DmxUnlock() { m_pLock->Unlock(); }
};

#endif _RTPDMX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpdmx\rtpdmx.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : RTPDemux.cpp
// Purpose  : RTP Demux filter implementation.
// Contents : 
//*M*/

#include <streams.h>

#ifndef _RTPDEMUX_CPP_
#define _RTPDEMUX_CPP_

#pragma warning( disable : 4786 )
#pragma warning( disable : 4146 )
#pragma warning( disable : 4018 )
#include <algo.h>
#include <map.h>
#include <multimap.h>
#include <function.h>

#include <amrtpuid.h>
#include "amrtpdmx.h"
#include "rtpdtype.h"
#include "globals.h"

#include "rtpdmx.h"
#include "rtpdinpp.h"
#include "rtpdoutp.h"

#include "rtpdprop.h"
#include "ssrcenum.h"

#include "resource.h"
#include "regres.h"

#include "template.h"

#if !defined(AMRTPDMX_IN_DXMRTP)

CFactoryTemplate g_Templates [2] = {
	CFT_AMRTPDMX_ALL_FILTERS
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

#endif

static long g_lDemuxID = 0;
static UINT CBasePropertyPages = 1;
static const CLSID *pPropertyPageClsids[] =
{
    &CLSID_IntelRTPDemuxPropertyPage,
};


// Using this pointer in constructor
#pragma warning(disable:4355)

/*F*
//  Name    : CRTPDemux::CreateInstance()
//  Purpose : Create an instance of the RTPDemux object.
//  Context : Standard COM method used by CoCreateInstance.
//  Returns :
//      NULL    Not enough memory to allocate filter and output pin.
//      Otherwise a CUnknown * for this filter is returned.
//  Params  :
//      pUnk    Unknown to the parent object of this filter if aggregated.
//      phr     HRESULT return parameter to put result in.
//  Notes   : 
*F*/
CUnknown * WINAPI 
CRTPDemux::CreateInstance(
    LPUNKNOWN   pUnk, 
    HRESULT     *phr)
{
    CRTPDemux *pNewFilter = new CRTPDemux(NAME("Intel RTP Demux Filter"), pUnk, phr);
    if (pNewFilter != static_cast<CRTPDemux *>(NULL)) {
        *phr = pNewFilter->AllocatePins(1); // Allocate initial output pin
        if (FAILED(*phr)) {
            delete pNewFilter;
            return NULL;
        } /* if */
    } /* if */

    return pNewFilter;
} /* CRTPDemux::CreateInstance() */


/*F*
//  Name    : CRTPDemux::CRTPDemux()
//  Purpose : Constructor. Do nothing.
//  Context : Called as a result of a new CRTPDemux being contrstructed
//            in CRTPDemux::CreateInstance().
//  Returns : Nothing
//  Params  :
//      pName   Name to assign to the root CUnknown for this object.
//      pUnk    Unknown to the parent object of this filter if aggregated.
//      phr     HRESULT return parameter to put result in.
//  Notes   : None.
*F*/
CRTPDemux::CRTPDemux(
    TCHAR       *pName, 
    LPUNKNOWN   pUnk, 
    HRESULT *phr) 
: m_pAllocator(NULL),
  m_iNextOutputPinNumber(0),
  
  CPersistStream(pUnk, phr),
  CBaseFilter(NAME("Intel RTP Demux filter"), pUnk, this, CLSID_IntelRTPDemux)
{
    DbgLog((LOG_TRACE, 2, TEXT("CRTPDemux::CRTPDemux: Constructed at 0x%08x"), this));

	ASSERT(phr);
	
	m_lDemuxID = InterlockedIncrement(&g_lDemuxID) - 1;
	
	// ZCS 7-7-97: changed m_Input to m_pInput (a pointer to a pin rather than just a pin)
	m_pInput = new CRTPDemuxInputPin(NAME("Input Pin"), this, phr, L"Input");

	if (!m_pInput) {
		*phr = E_OUTOFMEMORY;
		return;
	}
	// we don't addref it -- it uses the same reference count as we do, so if we addref it
	// we are addreffing ourselves and preventing our destructor from ever getting called.
    
	*phr = NOERROR;
} /* CRTPDemux::CRTPDemux() */


/*F*
//  Name    : CRTPDemux::~CRTPDemux()
//  Purpose : Destructor. Tear down any pins we have and exit.
//  Context : Called as a result of the reference count going to zero 
//            in CUnknown::Release().
//  Returns : Nothing
//  Params  : None.
//  Notes   : None.
*F*/
CRTPDemux::~CRTPDemux()
{
	// we know that all external references to the filter, input pin, and output pins have been
	// released, and we never hold any references to them ourselves.

    DbgLog((LOG_TRACE, 2, TEXT("CRTPDemux::~CRTPDemux: Destructor for 0x%08x called"), this));
    // Release (ZCS: actually, delete) all the output pins we hold.
    SetPinCount(0);

	// ZCS 7-7-97 -- get rid of the input pin.
	delete m_pInput;

    // Sanity checks
    ASSERT(m_mIPinRecords.size() == 0);
} /* CRTPDemux::~CRTPDemux() */


/*F*
//  Name    : CRTPDemux::NonDelegatingQueryInterface()
//  Purpose : Called to QI this object for its interfaces.
//  Context : 
//  Returns : Standard QI result codes.
//  Params  : Standard QI params.
//  Notes   : None.
*F*/
STDMETHODIMP 
CRTPDemux::NonDelegatingQueryInterface(
    REFIID  riid, 
    void    **ppv)
{
    CheckPointer(ppv,E_POINTER);
    if (riid == IID_IRTPDemuxFilter) {
        DbgLog((LOG_TRACE, 5, TEXT("CRTPDemux::NonDelegatingQueryInterface: called for IID_IRTPDemuxFilter")));
        return GetInterface(static_cast<IRTPDemuxFilter *>(this), ppv);
    } else if (riid == IID_ISpecifyPropertyPages) {
        DbgLog((LOG_TRACE, 5, TEXT("CRTPDemux::NonDelegatingQueryInterface: called for IID_ISpecifyPropertyPages")));
        return GetInterface(static_cast<ISpecifyPropertyPages *>(this), ppv);
    } else if (riid == IID_IPersistStream) {
        DbgLog((LOG_TRACE, 5, TEXT("CRTPDemux::NonDelegatingQueryInterface: called for IID_IPersistStream")));
        return GetInterface(static_cast<IPersistStream *>(this), ppv);
    } else if (riid == IID_IEnumSSRCs) {
        DbgLog((LOG_TRACE, 5, TEXT("CRTPDemux::NonDelegatingQueryInterface: called for IID_ISSRCEnum")));
        CSSRCEnum *pNewEnumerator = new CSSRCEnum(static_cast<CRTPDemux *>(this), m_mSSRCRecords.begin());
        if (pNewEnumerator == static_cast<CSSRCEnum *>(NULL)) {
            DbgLog((LOG_ERROR, 3, TEXT("CRTPDemux::NonDelegatingQueryInterface: Failed to allocate new SSRC enumerator!")));
            return E_OUTOFMEMORY;
        } /* if */
        return GetInterface(static_cast<IEnumSSRCs *>(pNewEnumerator), ppv);
    } /* if */

    DbgLog((LOG_TRACE, 8, TEXT("CRTPDemux::NonDelegatingQueryInterface: called for an unknown IID!")));
    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
} /* CRTPDemux::NonDelegatingQueryInterface() */


/*F*
//  Name    : CRTPDemux::StartStreaming()
//  Purpose : Used to remove all SSRC records when we start streaming.
//            This is necessary because we might be connected to a different
//            session.
//  Context : Called by base classes whenever "play" is hit.
//  Returns : NOERROR
//  Params  : 
//  Notes   : Does nothing when an output pin disconnects.
*F*/
STDMETHODIMP 
CRTPDemux::StartStreaming(void)
{
    // Breaking of the input pin direction signals us to unmap
    // all of our pins.
    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemux::StartStreaming unmapping all SSRCs from pins")));
    IPinRecordMapIterator_t iIPins = m_mIPinRecords.begin();
    while (iIPins != m_mIPinRecords.end()) {
        DbgLog((LOG_TRACE, 5, TEXT("CRTPDemux::StartStreaming unmapping pin 0x%08x"), 
                (*iIPins).first));

		// rajeevb - just clear the ssrc on the pin, removing the ssrc record is taken
		// care of enblock (see below - using erase)
		DWORD	dwTempSSRC;
        CRTPDemux::ClearSSRCForPin((*iIPins).first, dwTempSSRC);
    } /* while */
    // We also need to toss all of our SSRC records.
    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemux::StartStreaming removing all SSRC records")));
    m_mSSRCRecords.erase(m_mSSRCRecords.begin(), m_mSSRCRecords.end());

    return NOERROR;
} /* CRTPDemux::BreakConnect() */


/*F*
//  Name    : CRTPDemux::GetPinCount()
//  Purpose : Determine how many pins we have. 
//  Context : Used by base classes.
//  Returns : Number of pins we currently have.
//  Params  : None.
//  Notes   : None.
*F*/
int 
CRTPDemux::GetPinCount()
{
    CAutoLock l(m_pLock);

    return (1 + m_mIPinRecords.size());
} /* CRTPDemux::GetPinCount() */


/*F*
//  Name    : CRTPDemux::EnumSSRCs()
//  Purpose : Get an enumerator for the list of SSRCs that are
//            currently being tracked by this filter.
//  Context : Called by the app when it is interested in SSRC info.
//  Returns :
//      E_OUTOFMEMORY       Insufficient memory to allocate enumerator.
//      Also returns error codes returned by CEnumSSRCs::QI.
//  Params  : ppEnumSSRCs   Return parameter used to return IEnumSSRCs interface pointer.
//  Notes   : None.
*F*/
STDMETHODIMP
CRTPDemux::EnumSSRCs(
    IEnumSSRCs  **ppEnumSSRCs)
{
    DbgLog((LOG_TRACE, 2, TEXT("CRTPDemux::EnumSSRCs called")));
    
    CAutoLock l(m_pLock);
    
    CSSRCEnum *pNewEnum = new CSSRCEnum(this, m_mSSRCRecords.begin());
    if (pNewEnum == NULL) {
        DbgLog((LOG_ERROR, 2, TEXT("CRTPDemux::EnumSSRCs: Unable to allocate enumerator due to out of memory error!")));
        return E_OUTOFMEMORY;
    } /* if */

    return pNewEnum->QueryInterface(IID_IEnumSSRCs,
                                    (PVOID *) ppEnumSSRCs);
} /* CRTPDemux::EnumSSRCs() */


/*F*
//  Name    : CRTPDemux::FindMatchingFreePin()
//  Purpose : Helper function used to find a free pin which can
//            accept the indicated PT value.
//  Context : Called by MapSSRCToPin() to find a pin that matches
//            the PT of the indicated SSRC.
//  Returns : An interator to our IPin record map. This iterator
//            will either be the end() iterator (if no match was found)
//            or the iterator of a matching entry in the map.
//  Params  : 
//      bPT                 Payload value to search for.
//      bMustBeAutomapping  Signals if we are looking for an automapping
//                          pin or not. If FALSE, we return the first
//                          available pin which matches the PT. If TRUE,
//                          we return the first available pin which matches
//                          the PT and is an automapping pin.
//  Notes   : While this is an O(n) function on the number of output
//            pins, I don't believe it is terribly inefficient. This is
//            because this function will only be called at most once
//            for each new sender and the number of output pins should
//            always be relatively small. Furthermore, appearance of new 
//            senders is typically fairly infrequent.  If this turns out 
//            to be a bottleneck, we may wish to replace this with a map
//            of PTs to lists of pins which accept the indicated PTs.
*F*/
IPinRecordMapIterator_t
CRTPDemux::FindMatchingFreePin(
    BYTE bPT,
    BOOL bMustBeAutomapping,
	DWORD *pdwPTNum)
{
	*pdwPTNum = 0;

    DbgLog((LOG_TRACE, 3,
			TEXT("CRTPDemux::FindMatchingFreePin called with PT %d, "
				 "bMustBeAutoMapping = %s"), 
            bPT, bMustBeAutomapping ? "TRUE" : "FALSE"));
    if (bPT == PAYLOAD_INVALID) {
        return m_mIPinRecords.end();
    } /* if */

    IPinRecordMapIterator_t iIPinRecord = m_mIPinRecords.begin();
    while (iIPinRecord != m_mIPinRecords.end()) {
        if (((*iIPinRecord).second.bPT == bPT)) {
			(*pdwPTNum)++;
			if ( (*iIPinRecord).second.pPin->IsConnected() &&
                 ((*iIPinRecord).second.pPin->GetSSRC() == 0) ) {
				if(bMustBeAutomapping == TRUE) {
					if ((*iIPinRecord).second.pPin->IsAutoMapping() == FALSE) {
						DbgLog((LOG_TRACE, 3,
								TEXT("CRTPDemux::FindMatchingFreePin: "
									 "Pin 0x%08x matches PT %d, and "
									 "is not currently mapped but it "
									 "is not automapping. Skipping."),
								(*iIPinRecord).first, bPT));
					} else {
						DbgLog((LOG_TRACE, 3,
								TEXT("CRTPDemux::FindMatchingFreePin: "
									 "Pin 0x%08x matches PT %d, "
									 "is automapping, and is not "
									 "currently mapped"),
								(*iIPinRecord).first, bPT));
						return iIPinRecord;
					}
				} else {
					DbgLog((LOG_TRACE, 3,
							TEXT("CRTPDemux::FindMatchingFreePin: "
								 "Pin 0x%08x matches PT %d and "
								 "is not currently mapped"),
							(*iIPinRecord).first, bPT));
					return iIPinRecord;
				} /* if */
			} /* if */
        } /* if */
        iIPinRecord++;
    } /* while */

    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemux::FindMatchingFreePin: No matching output pins found")));
    return m_mIPinRecords.end();
} /* CRTPDemux::FindMatchingFreePin() */


/*F*
//  Name    : CRTPDemux::GetPinToSSRCMapping()
//  Purpose : 
//  Context : Called by the app when it is interested in SSRC info.
//  Returns :
//      E_INVALIDARG    The specified pin is not an output pin of this filter.
//      E_POINTER       Invalid pIPin or pdwSSRC pointer.
//  Params  : 
//      pIPin           IPin interface points to indicate which pin we 
//                      are indicated in.
//      pdwSSRC         Return value to place the SSRC value associated with
//                      the indicated pin into.
//  Notes   : None.
*F*/
STDMETHODIMP
CRTPDemux::GetPinInfo(
    IPin    *pIPin,
    DWORD   *pdwSSRC,
    BYTE    *pbPT,
    BOOL    *pbAutoMapping,
    DWORD   *pdwTimeout)
{
    DbgLog((LOG_TRACE, 2, TEXT("CRTPDemux::GetPinInfo called for IPin 0x%08x"), pIPin));

    CAutoLock l(m_pLock);
    
    if (pIPin == NULL) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRTPDemux::GetPinInfo: Invalid NULL pIPin parameter passed in!")));
        return E_POINTER;
    } /* if */

    if (IsBadWritePtr(pdwSSRC, sizeof(DWORD))) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRTPDemux::GetPinInfo: Invalid pdwSSRC argument passed in!")));
        return E_POINTER;
    } /* if */

    if (IsBadWritePtr(pbPT, sizeof(BOOL))) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRTPDemux::GetPinInfo: Invalid pbPT argument passed in!")));
        return E_POINTER;
    } /* if */

    if (IsBadWritePtr(pbAutoMapping, sizeof(BOOL))) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRTPDemux::GetPinInfo: Invalid pbAutoMapping argument passed in!")));
        return E_POINTER;
    } /* if */

    if (IsBadWritePtr(pdwTimeout, sizeof(DWORD))) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRTPDemux::GetPinInfo: Invalid pdwTimeout argument passed in!")));
        return E_POINTER;
    } /* if */

    IPinRecordMapIterator_t iIPinMap = m_mIPinRecords.find(pIPin);
    if (iIPinMap == m_mIPinRecords.end()) {
        // No such pin!
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRTPDemux::GetPinInfo: IPin * 0x%08x is invalid!"), pIPin));
        return E_POINTER;
    } /* if */

    *pdwSSRC = ((*iIPinMap).second.pPin)->m_dwSSRC;
    if (*pdwSSRC != 0) {
        // Looks like this pin is mapped to a particular SSRC.
        DbgLog((LOG_TRACE, 3, 
                TEXT("CRTPDemux::GetPinInfo: IPin 0x%08x maps to SSRC 0x%08x"),
                pIPin, *pdwSSRC));
        // Sanity checking  - Make sure our various maps 
        // are tracking each other properly.
        // First, make sure this SSRC appears in our map of SSRC records.
        ASSERT(m_mSSRCRecords.find(*pdwSSRC) != m_mSSRCRecords.end());
        // Second, make sure the pin that is mapped to this SSRC matches
        // the SSRC that the pin we found claimed.
        ASSERT((*m_mSSRCRecords.find(*pdwSSRC)).second.pPin == (*iIPinMap).second.pPin);
    } else {
        // Can't do any validation here because this pin isn't mapped to any SSRC.
        DbgLog((LOG_TRACE, 3, 
                TEXT("CRTPDemux::GetPinInfo: IPin 0x%08x not mapped to any SSRC"),
                pIPin));
    } /* if */

    *pbPT = ((*iIPinMap).second.pPin)->m_bPT;
    *pbAutoMapping = ((*iIPinMap).second.pPin)->IsAutoMapping();
    *pdwTimeout = ((*iIPinMap).second.pPin)->IsAutoMapping() ? ((*iIPinMap).second.pPin)->m_dwTimeoutDelay : 0L;

    return NOERROR;
} /* CRTPDemux::GetPinInfo() */


/*F*
//  Name    : CRTPDemux::GetSSRCInfo()
//  Purpose : 
//  Context : Called by the app when it is interested in SSRC info.
//  Returns :
//      E_INVALIDARG    The specified pin is not an output pin of this filter.
//      E_POINTER       Invalid pIPin or pdwSSRC pointer.
//  Params  : 
//      pIPin           IPin interface points to indicate which pin we 
//                      are indicated in.
//      pdwSSRC         Return value to place the SSRC value associated with
//                      the indicated pin into.
//  Notes   : None.
*F*/
STDMETHODIMP
CRTPDemux::GetSSRCInfo(
    DWORD   dwSSRC,
    BYTE    *pbPT,
    IPin    **ppIPin)
{
    DbgLog((LOG_TRACE, 2, TEXT("CRTPDemux::GetSSRCInfo called for SSRC 0x%08x"), dwSSRC));

    // Validate parameters
    if (IsBadWritePtr(pbPT, sizeof(BYTE))) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRTPDemux::GetSSRCInfo: Invalid pbPT pointer passed in!")));
        return E_POINTER;
    } /* if */
    if (IsBadWritePtr(ppIPin, sizeof(IPin *))) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRTPDemux::GetSSRCInfo: Invalid pIPin pointer passed in!")));
        return E_POINTER;
    } /* if */

    CAutoLock l(m_pLock);
    
    // Have we seen this SSRC?
    SSRCRecordMapIterator_t iSSRCRecord = m_mSSRCRecords.find(dwSSRC);
    if (iSSRCRecord == m_mSSRCRecords.end()) {
        // We have no record of it.
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRTPDemux::GetSSRCInfo: No record of SSRC 0x%08x!"), dwSSRC));
        return E_INVALIDARG;
    } /* if */

    *pbPT = (*iSSRCRecord).second.bPT;
    *ppIPin = static_cast<IPin *>((*iSSRCRecord).second.pPin);
    if (*ppIPin) {
        // AddRef it since we are returning an interface pointer.
        (*ppIPin)->AddRef();
        // Sanity checking to verify that our data structures are in sync.
        ASSERT((*iSSRCRecord).second.pPin->GetPTValue() == *pbPT);     // PT matches what the pin claims.
        ASSERT((*iSSRCRecord).second.pPin->m_dwSSRC == dwSSRC); // SSRC matches what the pin claims.
        ASSERT(m_mIPinRecords.find(static_cast<IPin *>((*iSSRCRecord).second.pPin)) != m_mIPinRecords.end());
    } /* if */
    DbgLog((LOG_TRACE, 3, 
        TEXT("CRTPDemux::GetSSRCInfo: SSRC 0x%08x maps to PT 0x%02x, IPin 0x%08x!"), 
             dwSSRC, *pbPT, *ppIPin));

    return NOERROR;
} /* CRTPDemux::GetSSRCInfo() */


/*F*
//  Name    : CRTPDemux::MapSSRCToPin()
//  Purpose : Map a particular SSRC to a pin that may or may not
//            be specified.
//  Context : Part of the IIntelRTPDemuxFilter interface. Always
//            called by the app.
//  Returns :
//      E_POINTER               The specified pin is not an output pin of this filter,
//                              or pIPin or pdwSSRC is invalid.
//      E_INVALIDARG            There is no record of the indicated SSRC.
//      VFW_E_INVALIDSUBTYPE    No IPin was specified and no free automapping
//                              pins which match the PT value of the SSRC are
//                              available to map to.
//  Params  : 
//      dwSSRC          The SSRC that the app wants to have mapped.
//      pIPin           IPin interface that indicates the particular pin
//                      that the app wants this SSRC mapped to. If NULL,
//                      the filter will map the SSRC to the first pin whose
//                      media type matches that of the SSRC.
//  Notes   : None.
*F*/
STDMETHODIMP
CRTPDemux::MapSSRCToPin(
    DWORD   dwSSRC,
    IPin    *pIPin)
{
    DbgLog((LOG_TRACE, 2, TEXT("CRTPDemux::MapSSRCToPin called for SSRC 0x%08x, pin 0x%08x"), 
            dwSSRC, pIPin));

    CAutoLock l(m_pLock);
    
    SetDirty(TRUE);

    DWORD dwTempSSRC;
    if (dwSSRC == 0) {
        // The app wants us to unmap this pin.
        return UnmapPin(pIPin, &dwTempSSRC);
    } /* if */

    // Find the record for this SSRC.
    SSRCRecordMapIterator_t iSSRCRecord = m_mSSRCRecords.find(dwSSRC);
    if (iSSRCRecord == m_mSSRCRecords.end()) {
        DbgLog((LOG_ERROR, 2, TEXT("CRTPDemux::MapSSRCToPin: Unable to find requested SSRC!")));
        return E_INVALIDARG;
    } /* if */
    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemux::MapSSRCToPin: SSRC 0x%08x found, PT is 0x%02x."),
            dwSSRC, (*iSSRCRecord).second.bPT));

    // If another pin is already mapped to this SSRC, unmap it.
    if ((*iSSRCRecord).second.pPin != static_cast<CRTPDemuxOutputPin *>(NULL)) {
        DbgLog((LOG_TRACE, 3, 
                TEXT("CRTPDemux::MapSSRCToPin: Pin 0x%08x already mapped to SSRC 0x%08x. Unmapping old SSRC."),
                (*iSSRCRecord).second.pPin, (*iSSRCRecord).second.pPin->m_dwSSRC));
        ASSERT((*iSSRCRecord).second.pPin->m_dwSSRC == dwSSRC); // Sanity check.
        ASSERT((*iSSRCRecord).second.pPin->GetPTValue() == (*iSSRCRecord).second.bPT); // Sanity check.

		// rajeevb - just clear the ssrc on the pin, should not remove the ssrc record
        HRESULT hr = ClearSSRCForPin(static_cast<IPin *>((*iSSRCRecord).second.pPin), dwTempSSRC);
        ASSERT(hr == NOERROR);
        // rajeevb - set the pin mapped to the ssrc record to null
        (*iSSRCRecord).second.pPin = NULL;
    } /* if */

    IPinRecordMapIterator_t iIPinToMap;
    if (pIPin == NULL) {
		DWORD ptnum;
        // The app wants us to automatically select a suitable pin.
        iIPinToMap = FindMatchingFreePin((*iSSRCRecord).second.bPT, FALSE,
										 &ptnum);
        if (iIPinToMap == m_mIPinRecords.end()) {
            // No pins are suitable for this media type.

			// rajeevb - remove the ssrc record
			m_mSSRCRecords.erase(iSSRCRecord);
            DbgLog((LOG_ERROR, 2, TEXT("CRTPDemux::MapSSRCToPin: No available pins match indicated media type!")));
            return VFW_E_INVALIDSUBTYPE;
        } /* if */
        ASSERT((*iIPinToMap).second.pPin != static_cast<CRTPDemuxOutputPin *>(NULL));
        ASSERT((*iIPinToMap).second.pPin->IsAutoMapping() == TRUE);
        ASSERT((*iIPinToMap).second.pPin->GetSSRC() == 0); // Sanity check to make sure pin isn't already mapped.
        ASSERT((*iIPinToMap).second.pPin->GetPTValue() == (*iSSRCRecord).second.bPT); // Make sure PT matches.
    } else {
        // The app wants this SSRC mapped to this pin. First find the class from the interface.
        iIPinToMap = m_mIPinRecords.find(pIPin);
        if (iIPinToMap == m_mIPinRecords.end()) {
 			// rajeevb - remove the ssrc record
			m_mSSRCRecords.erase(iSSRCRecord);
           DbgLog((LOG_ERROR, 2, TEXT("CRTPDemux::MapSSRCToPin: Indicated pin is not an output pin of this filter!")));
            return E_POINTER;
        } /* if */
        // Next verify that the PT value is OK.
        if ((*iSSRCRecord).second.bPT != (*iIPinToMap).second.pPin->GetPTValue()) {
			// rajeevb - remove the ssrc record
			m_mSSRCRecords.erase(iSSRCRecord);
            DbgLog((LOG_ERROR, 2, TEXT("CRTPDemux::MapSSRCToPin: Indicated pin expects PT 0x%02x, rather than PT 0x%02x!"),
                    (*iIPinToMap).second.pPin->GetPTValue(),
                    (*iSSRCRecord).second.bPT));
            return VFW_E_INVALIDSUBTYPE;
        } /* if */
    } /* if */

    // We have the output pin & the SSRC. Perform the mapping.
    return MapPin((*iIPinToMap).second.pPin, dwSSRC);
} /* CRTPDemux::MapSSRCToPin() */


/*F*
//  Name    : CRTPDemux::GetSoftwareVersion
//  Purpose : Return the version of the persistence file we
//            write for this filter.
//  Context : WriteToStream() uses this value to determine if
//            we are reading a persistence file we understand or not.
//  Returns : The format version (currently 1) for the persistence file
//            used by this filter.
//  Params  : None.
//  Notes   : None.
*F*/
DWORD 
CRTPDemux::GetSoftwareVersion(void)
{
    return 1;
} /* CRTPDemux::GetSoftwareVersion() */


/*F*
//  Name    : CRTPDemux::GetClassID
//  Purpose : Return the CLSID for this filter.
//  Context : Used by the persistence code to store a unique
//            identifier (the filter CLSID) for persistence
//            streams for this filter. 
//  Returns : 
//      NOERROR     CLSID placed in pCLSID.
//  Params  : 
//      pCLSID      CLSID for this filter is returned here.
//  Notes   : None.
*F*/
HRESULT
CRTPDemux::GetClassID(CLSID *pCLSID)
{
    *pCLSID = CLSID_IntelRTPDemux;
    return NOERROR;
} /* CRTPDemux::GetClassID() */


struct bIsPinPairUnBound_t : unary_function<pair<IPin *, IPinRecord_t>, bool> {
    bool operator()(pair< IPin * const , IPinRecord_t> iPinRecord) const {
        return (iPinRecord.second.pPin->IsConnected() == FALSE);
    } /* operator() */
} bIsPinPairUnBound;


/*F*
//  Name    : CRTPDemux::GetNumFreePins
//  Purpose : Return the number of free (unconnected) output pins.
//  Context : Used in CRTPDemuxOutputPin::CompleteConnect()
//            to make sure that there is always at least one
//            free output pin.
//  Returns : An integer indicating how many free output pins there are.
//  Params  : 
//  Notes   : None.
*F*/
int
CRTPDemux::GetNumFreePins()
{
    int iNumFreePins = 0;
    IPinRecordMapIterator_t iCurrentOutputPin = m_mIPinRecords.begin();

    while (iCurrentOutputPin != m_mIPinRecords.end()) {
        if ((*iCurrentOutputPin).second.pPin->IsConnected() == FALSE) {
            iNumFreePins++;
        } /* if */
        iCurrentOutputPin++;
    } /* while */

    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemux::GetNumFreePins: Returning %d free pins"),
            iNumFreePins));

    return iNumFreePins;
} /* CRTPDemux::GetNumFreePins() */


    // IPersistStream interfaces

	/*F*
//  Name    : ReadEntry
//  Purpose : A macro that implements the stuff we do to read
//            a property of this filter from its persistent stream.
//  Context : Used in ReadFromStream() to improve readability.
//  Returns : Will only return if an error is detected.
//  Params  : 
//      Entry       Pointer to a buffer containing the value to read.
//      InSize      Integer indicating the length of the buffer
//      OutSize     Integer to store the written length.
//      Description Char string used to describe the entry.
//  Notes   : 
*F*/
#define ReadEntry(Entry, InSize, OutSize, Description) \
  { DbgLog((LOG_TRACE, 4, TEXT("CRTPDemux::ReadFromStream: Reading %s"), Description)); \
    hErr = pStream->Read(Entry, InSize, &OutSize); \
    if (FAILED(hErr)) { \
        DbgLog((LOG_ERROR, 2, TEXT("CRTPDemux::ReadFromStream: Error 0x%08x reading %s"), hErr, Description)); \
        return hErr; \
    } else if (OutSize != InSize) { \
        DbgLog((LOG_ERROR, 2,  \
                TEXT("CRTPDemux::ReadFromStream: Too few (%d/%d) bytes read for %s"), \
                OutSize, InSize, Description)); \
        return E_INVALIDARG; \
    } /* if */ }


/*F*
//  Name    : CRTPDemux::ReadFromStream()
//  Purpose : Read in from the persistence stream all the values 
//            necessary to configure this filter for use. 
//  Context : Called shortly after being created and loaded into
//            a filter graph.
//  Returns :
//      NOERROR                     Successfully loaded values and configured filter.
//      VFW_E_INVALID_FILE_FORMAT   Some entry in the persistence file was bogus
//                                  and it caused us to error out.
//  Params  : 
//      pStream Pointer to an IStream which has been moved to
//              the beginning of our stored persistence data.
//  Notes   : None.
*F*/
HRESULT
CRTPDemux::ReadFromStream(
    IStream *pStream)
{
    if (mPS_dwFileVersion > CURRENT_PERSISTENCE_FILE_VERSION) {
        DbgLog((LOG_ERROR, 2, TEXT("CRTPDemux::ReadFromStream: File format version %d is newer than expected version %d!"),
                mPS_dwFileVersion, CURRENT_PERSISTENCE_FILE_VERSION));
        return VFW_E_INVALID_FILE_VERSION;
    } /* if */

    HRESULT hErr;
    ULONG uBytesWritten = 0;

    int iPinCount;
    ReadEntry(&iPinCount, sizeof(int), uBytesWritten, "output pin count");
    hErr = CRTPDemux::SetPinCount(iPinCount);
    if (FAILED(hErr)) {
        DbgLog((LOG_ERROR, 2, TEXT("CRTPDemux::ReadFromStream: Error 0x%08x calling SetPinCount(%d)!"),
                hErr, iPinCount));
        return VFW_E_INVALID_FILE_FORMAT;
    } /* if */

    // Now read all the output pins
    BOOL bAutoMapping;
    DWORD dwTimeout;
    BYTE bPT;
    GUID mtsSubtype;
    IPinRecordMapIterator_t iCurrentPin = m_mIPinRecords.begin();
    for(int iPinCounter = 0; iPinCounter < iPinCount; iPinCounter++) {
        ASSERT(iCurrentPin != m_mIPinRecords.end());
        DbgLog((LOG_TRACE, 4, 
                TEXT("CRTPDemux::ReadFromStream: Reading information for output pin %d at 0x%08x"),
                iPinCounter, (*iCurrentPin).first));

        ReadEntry(&bAutoMapping, sizeof(BOOL), uBytesWritten, "output pin mode");
        hErr = CRTPDemux::SetPinMode((*iCurrentPin).first, bAutoMapping);
        if (FAILED(hErr)) {
            DbgLog((LOG_ERROR, 2, TEXT("CRTPDemux::ReadFromStream: Error 0x%08x calling SetPinMode(0x%08x, %s)!"),
                    hErr, (*iCurrentPin).first, bAutoMapping? "TRUE" : "FALSE"));
            return VFW_E_INVALID_FILE_FORMAT;
        } /* if */

        ReadEntry(&dwTimeout, sizeof(DWORD), uBytesWritten, "output pin timeout");
        if (bAutoMapping == TRUE) {
            // Source timeouts only apply to automapping pins.
            hErr = CRTPDemux::SetPinSourceTimeout((*iCurrentPin).first, dwTimeout);
            if (FAILED(hErr)) {
                DbgLog((LOG_ERROR, 2, TEXT("CRTPDemux::ReadFromStream: Error 0x%08x calling SetPinSourceTimeout(0x%08x, %d)!"),
                        hErr, (*iCurrentPin).first, dwTimeout));
                return VFW_E_INVALID_FILE_FORMAT;
            } /* if */
        } /* if */

        ReadEntry(&bPT, sizeof(BYTE), uBytesWritten, "output pin PT value");
        ReadEntry(&mtsSubtype, sizeof(GUID), uBytesWritten, "output pin subtype");

        hErr = CRTPDemux::SetPinTypeInfo((*iCurrentPin).first, bPT, mtsSubtype);
        if (FAILED(hErr)) {
            DbgLog((LOG_ERROR, 2, TEXT("CRTPDemux::ReadFromStream: Error 0x%08x calling SetPinTypeInfo(0x%08x, %d, (GUID))!"),
                    hErr, (*iCurrentPin).first, bPT));
            return VFW_E_INVALID_FILE_FORMAT;
        } /* if */

        iCurrentPin++;
    } /* for */

    return NOERROR;
} /* CRTPDemux::ReadFromStream() */


/*F*
//  Name    : WriteEntry
//  Purpose : A macro that implements the stuff we do to write
//            a property of this filter to its persistent stream.
//  Context : Used in WriteToStream() to improve readability.
//  Returns : Will only return if an error is detected.
//  Params  : 
//      Entry       Pointer to a buffer containing the value to write.
//      InSize      Integer indicating the length of the buffer
//      OutSize     Integer to store the written length.
//      Description Char string used to describe the entry.
//  Notes   : 
*F*/
#define WriteEntry(Entry, InSize, OutSize, Description) \
  { DbgLog((LOG_TRACE, 4, TEXT("CRTPDemux::WriteToStream: Writing %s"), Description)); \
    hErr = pStream->Write(Entry, InSize, &OutSize); \
    if (FAILED(hErr)) { \
        DbgLog((LOG_ERROR, 2, TEXT("CRTPDemux::WriteToStream: Error 0x%08x writing %s"), hErr, Description)); \
        return hErr; \
    } else if (OutSize != InSize) { \
        DbgLog((LOG_ERROR, 2,  \
                TEXT("CRTPDemux::WriteToStream: Too few (%d/%d) bytes written for %s"), \
                uBytesWritten, sizeof(int), Description)); \
        return E_INVALIDARG; \
    } /* if */ }


/*F*
//  Name    : CRTPDemux::WriteToStream()
//  Purpose : 
//  Context : 
//  Returns :
//  Params  : 
//  Notes   : 
*F*/

HRESULT
CRTPDemux::WriteToStream(
    IStream *pStream)
{
    DbgLog((LOG_TRACE, 2, 
            TEXT("CRTPDemux::WriteToStream: Saving filter configuration")));

    HRESULT hErr;
    ULONG uBytesWritten = 0;
    int iPinCount = CRTPDemux::GetPinCount() - 1;

    // Store the output pin count
    WriteEntry(&iPinCount, sizeof(int), uBytesWritten, "output pin count");

    // Now write all the output pins
    IPinRecordMapIterator_t iCurrentPin = m_mIPinRecords.begin();
    for(int iPinCounter = 0; iPinCounter < iPinCount; iPinCounter++) {
        ASSERT(iCurrentPin != m_mIPinRecords.end());
        DbgLog((LOG_TRACE, 4, 
                TEXT("CRTPDemux::WriteToStream: Writing information for output pin %d at 0x%08x"),
                iPinCounter, (*iCurrentPin).first));
        WriteEntry(&(*iCurrentPin).second.bAutoMapping, sizeof(BOOL), uBytesWritten, "output pin mode");
        WriteEntry(&(*iCurrentPin).second.dwTimeout, sizeof(DWORD), uBytesWritten, "output pin timeout");
        WriteEntry(&(*iCurrentPin).second.bPT, sizeof(BYTE), uBytesWritten, "output pin PT value");
        WriteEntry(&(*iCurrentPin).second.mtsSubtype, sizeof(GUID), uBytesWritten, "output pin subtype");
        iCurrentPin++;
    } /* for */

    return NOERROR;
} /* CRTPDemux::WriteToStream() */


/*F*
//  Name    : CRTPDemux::SizeMax()
//  Purpose : 
//  Context : 
//  Returns :
//  Params  : 
//  Notes   : 
*F*/
int
CRTPDemux::SizeMax(void)
{
    int iSize = sizeof(int) + 
                ((CRTPDemux::GetPinCount() - 1) * (sizeof(BOOL) + sizeof(DWORD) + sizeof(BYTE) + sizeof(GUID)));
    DbgLog((LOG_TRACE, 2, 
            TEXT("CRTPDemux::SizeMax: Returning calculated size %d"), iSize));
    return iSize;
} /* CRTPDemux::SizeMax() */


/*F*
//  Name    : CRTPDemux::MapPin()
//  Purpose : Helper function used to map a particular pin to a particular SSRC.
//  Context : Used in MapSSRCToPin once it has determined the right pin/SSRC combination.
//  Returns :
//  Params  : 
//      pCRTPPin    Pointer to a CRTPDemuxOutputPin to be mapped.
//      dwSSRC      SSRC to map to the pin in question.
//  Notes   : This function is called with a valid pin and SSRC. The pin may
//            appear in our list of PTs to unmapped pins, so we have to remove
//            it from there. The SSRC should appear in our SSRC records. The
//            pin might also be previously mapped, which means we need to unmap it.
*F*/
HRESULT
CRTPDemux::MapPin(
    CRTPDemuxOutputPin  *pCRTPPin,
    DWORD               dwSSRC)
{
    CAutoLock l(m_pLock);

    ASSERT(pCRTPPin);
    ASSERT(dwSSRC);
    ASSERT(m_mIPinRecords.find(static_cast<IPin *>(pCRTPPin)) != m_mIPinRecords.end());
    SSRCRecordMapIterator_t iSSRCRecord = m_mSSRCRecords.find(dwSSRC);
    ASSERT(iSSRCRecord != m_mSSRCRecords.end());
    BYTE bPT = (*iSSRCRecord).second.bPT;
    ASSERT(bPT == pCRTPPin->GetPTValue()); // PT match sanity check
    ASSERT((*iSSRCRecord).second.pPin == NULL); // SSRC not previously mapped sanity check

    // rajeevb - If pin is previously mapped to a difference SSRC, unmap it.
    // rajeevb - previously compared with static_cast<DWORD>(NULL) !!!
    if (pCRTPPin->m_dwSSRC != 0) {
        // rajeevb - check if the ssrc the pin is currently mapped to is same as dwSSRC
        if ( pCRTPPin->m_dwSSRC == dwSSRC ) {
            (*iSSRCRecord).second.pPin = pCRTPPin; // Mark the SSRC record as being delivered on this pin.
            return NOERROR;
		}
        DbgLog((LOG_TRACE, 2, TEXT("CRTPDemux::MapPin: Pin 0x%08x previously mapped to SSRC 0x%08x. Unmapping"), 
                pCRTPPin, pCRTPPin->GetSSRC()));
        HRESULT hr = UnmapSSRC(pCRTPPin->m_dwSSRC, (IPin **)NULL);
        ASSERT(hr == NOERROR);
    } /* if */

    // By this point we have an unmapped pin that isn't in the automapping list.
    pCRTPPin->SetSSRC(dwSSRC);    // Mark the pin as delivering this SSRC
    (*iSSRCRecord).second.pPin = pCRTPPin; // Mark the SSRC record as being delivered on this pin.
    DbgLog((LOG_TRACE, 2, TEXT("CRTPDemux::MapPin: Pin 0x%08x mapped to PT 0x%02x for SSRC 0x%08x."), 
            pCRTPPin, pCRTPPin->GetPTValue(), pCRTPPin->GetSSRC()));
    return NOERROR;
} /* CRTPDemux::MapPin() */


/*F*
//  Name    : CRTPDemux::SetPinCount()
//  Purpose : Set how many output pins to expose.
//  Context : Used by the app to allocate more pins
//            or remove currently allocated pins.
//            Used in the destructor to release pins.
//  Returns :
//      E_INVALIDARG        The indicated pin count is less than the
//                          number of currently connected output pins.
//                          Pins may only be removed when they are not connected.
//      VFW_E_NOT_STOPPED   The filter is still paused/running. Pins may only
//                          be removed when the filter is stopped.
//      NOERROR             Successfully changed the output pin count to the
//                          desired value.
//  Params  : dwPinCount    Desired number of pins.
//  Notes   : None.
*F*/
STDMETHODIMP
CRTPDemux::SetPinCount(
    DWORD  dwPinCount)
{
    CAutoLock l(m_pLock);

    DbgLog((LOG_TRACE, 2, TEXT("CRTPDemux::SetPinCount(%d) called"), dwPinCount));
    SetDirty(TRUE);

    if (m_State != State_Stopped) {
        DbgLog((LOG_ERROR, 3, TEXT("CRTPDemux::SetPinCount(%d) called while %s (must be stopped)!"), 
                dwPinCount, 
                (m_State == State_Paused) ? "paused" : "running"));
        return VFW_E_NOT_STOPPED;
    } /* if */

    // OK, we have verified that a valid number of pins has been input. 
    if (m_mIPinRecords.size() < dwPinCount) {
        // Need to allocate more pins.
        return AllocatePins(dwPinCount - m_mIPinRecords.size());
    } else {
        // Free up extra pins
        return RemovePins(m_mIPinRecords.size() - dwPinCount);
    } /* if */
} /* CRTPDemux::SetPinCount() */



/*F*
//  Name    : CRTPDemux::SetPinMode()
//  Purpose : Indicates whether a given pin should automatically
//            map to new SSRCs when not already mapped or not.
//  Context : Part of the IIntelRTPDemuxFilter interface.
//  Returns :
//      E_POINTER   The indicated IPin is not an output pin of this filter.
//      S_FALSE     The indicated pin was already set to the mode in question.
//  Params  : 
//      pIPin       The IPin* corresponding to an output pin of this
//                  filter to set for automatic mapping (or not, if
//                  bAutomatic is FALSE.)
//      bAutomatic  True indicates that the indicated pin should be
//                  automatically mapping. False indicates that it should not.
//  Notes   : None.
*F*/
STDMETHODIMP
CRTPDemux::SetPinMode(
    IPin    *pIPin,
    BOOL    bAutomatic)
{
    DbgLog((LOG_TRACE, 2, TEXT("CRTPDemux::SetPinMode called for pin 0x%08x, automatic = %s"), 
            pIPin, (bAutomatic ? "TRUE" : "FALSE")));

    CAutoLock l(m_pLock);
    
    SetDirty(TRUE);

    // Find the CRTPPin for this IPin. Puke if no such pin.
    IPinRecordMapIterator_t iIPinRecord;
    iIPinRecord = m_mIPinRecords.find(pIPin);
    if (iIPinRecord == m_mIPinRecords.end()) {
        DbgLog((LOG_ERROR, 2, TEXT("CRTPDemux::SetPinMode called for invalid pIPin!")));
        return E_POINTER;
    } /* if */

    // See if the pin is already in the requested mode.
    if ((*iIPinRecord).second.pPin->IsAutoMapping() == bAutomatic) {
        DbgLog((LOG_TRACE, 2, TEXT("CRTPDemux::SetPinMode: Pin 0x%08x already %s automapping!"), 
                pIPin, (bAutomatic ? "is" : "is not")));
        return S_FALSE;
    } /* if */

    // Switch the pin to the requested mode.
    (*iIPinRecord).second.pPin->SetAutoMapping(bAutomatic);
    (*iIPinRecord).second.bAutoMapping = bAutomatic;

    // That's all there is to it.
    return NOERROR;
} /* CRTPDemux::SetPinMode() */


/*F*
//  Name    : CRTPDemux::SetPinSourceTimeout()
//  Purpose : Indicate how many milliseconds a particular pin
//            should wait before automatically unmapping from
//            its current SRC.
//  Context : Part of the IIntelRTPDemuxFilter interface.
//  Returns :
//      E_INVALIDARG    Too small a timeout value specified.
//      E_POINTER       Invalid pIPin parameter,
//      E_UNEXPECTED    Called for a non-automapping pin.
//      NOERROR         Successfully set timeout value.
//  Params  : 
//      pIPin           The particular pin to set a timeout for. Must be
//                      an output pin of this filter in automatic mapping mode.
//      dwMillseconds   The number of milliseconds allowed to elapse before
//                      a mapped SSRC may be unmapped from this pin. Must be
//                      at least 100ms.
//  Notes   : None.
*F*/
STDMETHODIMP
CRTPDemux::SetPinSourceTimeout(
    IPin    *pIPin,
    DWORD   dwMilliseconds)
{
    DbgLog((LOG_TRACE, 5, TEXT("CRTPDemux::SetPinSourceTimeout called pIPin 0x%08x, timeout %d"), 
            pIPin, dwMilliseconds));

    CAutoLock l(m_pLock);
    
    SetDirty(TRUE);

    if (dwMilliseconds < 100) {
        DbgLog((LOG_ERROR, 2, TEXT("CRTPDemux::SetPinSourceTimeout called for invalid dwMilliseconds!")));
        return E_INVALIDARG;
    } /* if */

    IPinRecordMapIterator_t iIPinRecord = m_mIPinRecords.find(pIPin);
    if (iIPinRecord == m_mIPinRecords.end()) {
        DbgLog((LOG_ERROR, 2, TEXT("CRTPDemux::SetPinSourceTimeout called for invalid pIPin!")));
        return E_POINTER;
    } /* if */

    if ((*iIPinRecord).second.pPin->IsAutoMapping() == FALSE) {
        DbgLog((LOG_ERROR, 2, TEXT("CRTPDemux::SetPinSourceTimeout called for non-automapping pIPin!")));
        return E_UNEXPECTED;
    } /* if */

    (*iIPinRecord).second.pPin->SetTimeoutDelay(dwMilliseconds);
    (*iIPinRecord).second.dwTimeout = dwMilliseconds;
    return NOERROR;
} /* CRTPDemux::SetPinSourceTimeout() */

  
/*F*
//  Name    : CRTPDemux::SetPinTypeInfo()
//  Purpose : Used to setup the payload type a particular pin accepts and
//            the corresponding media subtype it exposes.
//  Context : Called by the application when manually configuring the RTP
//            demux filter. Also called automatically when the filter is
//            instantiated without previously setup pins, in an attempt
//            to render whatever we receive.
//  Returns :
//      E_POINTER           The pIPin parameter is not a valid output pin for this filter.
//      VFW_E_ALREADY_CONNECTED The pin in question is already connected, so we cannot
//                          change the payload type/media type.
//      NOERROR             Successfully set the payload type and minor type for the
//                          pin in question.
//  Params  : 
//      pIPin   IPin * of an output pin of this filter to set the type info for.
//      bPT     Payload type value to accept for this pin. Any RTP packets with
//              a different payload type will be rejected. Note that an exception
//              is made for RTCP Sender Reports, which are always passed on.
//      gMinorType  The minor type of the pin to expose. If NULL, the pin will
//              attempt to automatically choose the correct minor type to expose
//              based on the indicated PT value.
//  Notes   : Uses the SetupPinTypeInfo() helper function to do the work
//            of verifying the PT/minor type combo and actually setting the
//            pin. Thus, this function only checks parameters.
*F*/
STDMETHODIMP
CRTPDemux::SetPinTypeInfo(
    IPin    *pIPin,
    BYTE    bPT,
    GUID    gMinorType)
{
    DbgLog((LOG_TRACE, 2, TEXT("CRTPDemux::SetPinTypeInfo called, pIPin = 0x%08x, pt = 0x%02x"),
            pIPin, bPT));

    CAutoLock l(m_pLock);

    SetDirty(TRUE);

    IPinRecordMapIterator_t iIPinRecord = m_mIPinRecords.find(pIPin);
    if (iIPinRecord == m_mIPinRecords.end()) {
        DbgLog((LOG_ERROR, 3, TEXT("CRTPDemux::SetPinTypeInfo: Invalid pIPin parameter!")));
        return E_POINTER;
    } /* if */

    // This conditional is worth explaining. First, check if a pin
    // is connected. If not, then go ahead and change the PT/Subtype info.
    // If it is connected, this means that the subtype should be
    // invariant. So we better make sure that the specified subtype 
    // matches the one already specified for this pin. The only case where
    // this should happen is when the PT value is being changed by
    // the subtype isn't (typically this is used with dynamic PTs.)
    if (((*iIPinRecord).second.pPin->IsConnected() == TRUE) && 
        (gMinorType != (*iIPinRecord).second.pPin->m_mt.subtype)) {
        DbgLog((LOG_ERROR, 3, TEXT("CRTPDemux::SetPinTypeInfo: Pin already bound, cannot change media type type!")));
        return VFW_E_ALREADY_CONNECTED;
    } /* if */

    HRESULT hErr = SetupPinTypeInfo((*iIPinRecord).second.pPin, bPT, gMinorType);
    if (SUCCEEDED(hErr)) {
        (*iIPinRecord).second.bPT = (*iIPinRecord).second.pPin->GetPTValue();
        (*iIPinRecord).second.mtsSubtype = gMinorType;
        (*iIPinRecord).second.dwTimeout = (*iIPinRecord).second.pPin->GetTimeoutDelay();
        (*iIPinRecord).second.bAutoMapping = (*iIPinRecord).second.pPin->IsAutoMapping();
    } /* if */

    return hErr;
} /* CRTPDemux::SetPinTypeInfo() */


/*F*
//  Name    : CRTPDemux::SetupPinTypeInfo()
//  Purpose : 
//  Context : Called as a helper function to SetPinTypeInfo.
//  Returns :
//      NOERROR             Successfully set the payload type and minor type for the
//                          pin in question.
//      VFW_E_NOT_ACCEPTED  The subtype was invalid and/or the PT was bogus.
//  Params  : 
//      pIPin   IPin * of an output pin of this filter to set the type info for.
//      bPT     Payload type value to accept for this pin. Any RTP packets with
//              a different payload type will be rejected. Note that an exception
//              is made for RTCP Sender Reports, which are always passed on.
//      gMinorType  The minor type of the pin to expose. If NULL, the pin will
//              attempt to automatically choose the correct minor type to expose
//              based on the indicated PT value.
//  Notes   : Called as a helper function, so no locking is necessary.
//            Assumes the pCRTPPin is a valid pointer.
*F*/
HRESULT
CRTPDemux::SetupPinTypeInfo(
    CRTPDemuxOutputPin      *pCRTPPin,
    BYTE                    bPT,
    GUID                    gMinorType)
{
    ASSERT(pCRTPPin);
    CMediaType cTempMT;

    CAutoLock l(m_pLock);
    
    cTempMT.SetType(&MEDIATYPE_RTP_Single_Stream);

    if ((bPT != PAYLOAD_INVALID) && (gMinorType == MEDIASUBTYPE_NULL)) {
        // PT was set but subtype isn't. Find subtype from registry.
        gMinorType = FindSubtypeFromPT(bPT);
    } /* if */

    if ((bPT != PAYLOAD_INVALID) && (gMinorType != MEDIASUBTYPE_NULL)) {
        // Either the PT was set and a matching subtype was found in
        // the registry, or both the PT and the minor type were set,
        // so everything is fine. Set the media type on the pin.
        cTempMT.SetSubtype(&gMinorType);
        pCRTPPin->SetMediaType(&cTempMT);
        // Now set the PT value for the pin. Need to toggle the
        // pin mode back and forth if it was automapping to ensure
        // that the map of PT values gets updated.
        BOOL bWasAutoMapping = pCRTPPin->IsAutoMapping();
        if (bWasAutoMapping == TRUE) {
            SetPinMode(static_cast<IPin *>(pCRTPPin), FALSE);
        } /* if */
        pCRTPPin->SetPTValue(bPT);
        if (bWasAutoMapping  == TRUE) {
            SetPinMode(static_cast<IPin *>(pCRTPPin), TRUE);
        } /* if */
        return NOERROR;
    } /* if */

    DbgLog((LOG_ERROR, 3, 
            TEXT("CRTPDemux::SetupPinTypeInfo: No subtype set and PT value is unknown.")));
    return VFW_E_TYPE_NOT_ACCEPTED;
} /* CRTPDemux::SetupPinTypeInfo() */

  
/*F*
//  Name    : CRTPDemux::AllocatePins()
//  Purpose : Allocate a bunch of currently unused pins.
//  Context : Called by SetPinCount() as a helper function. 
//  Returns : 
//      E_OUTOFMEMORY   Not enough memory to allocate all of the
//                      requested pins, so none were allocated.
//      NOERROR         Successfully allocated all the requested pins.
//      Also returns error codes from the constructor of CRTPDemuxOutputPins.
//  Params  : 
//      dwPinsToAllocate    The number of pins we should allocate
//                          above and beyond any currently allocated pins.
//  Notes   : This is a private helper function for SetPinCount(),
//            so no need to acquire any locks as they were already
//            acquired there.
//            This function used to be implemented recursively -- this caused
//            problems when allocating large numbers of pins. Rewritten by
//            t-zoltas to work iteratively and watch out-of-memory conditions
//            more carefully.
*F*/
HRESULT
CRTPDemux::AllocatePins(
    DWORD dwPinsToAllocate)
{
	// If running within the VC5 debugger the following can help to turn off weird exceptions that
	// the debugger makes happen instead of letting new return NULL:
	// _set_new_handler(0);

	// First of all, if there is nothing to do, then do nothing.
    if (dwPinsToAllocate == 0)
	{
        return NOERROR;
    } /* if */

	// We can only allocate pins one at a time, but we need to be able to deallocate
	// ALL the pins if any one allocation fails. Furthermore, we don't want to modify
	// anything until we're sure they were all allocated successfully.

	// Create an array of pointers to new pins. This replaces the stack in the previous
	// implementation, which is good because we can check if we have enough space for it.
	typedef CRTPDemuxOutputPin * OutPinPointer;

	OutPinPointer *ppNewPinsArray = new OutPinPointer[dwPinsToAllocate];

	if (ppNewPinsArray == NULL)
	{
		DbgLog((LOG_ERROR, 2,
				TEXT("CRTPDemux::AllocatePins: Error attempting to create new pins"),
				E_OUTOFMEMORY));
		return E_OUTOFMEMORY;
	} /* if */

	// now allocate each pin...
	
	HRESULT hr;

	// m_iNextOutputPinNumber is the zero-based index in the output
	//    pins list of the next pin to be allocated.
	// m_mIPinRecords.size() returns the number of pins in the output
	//     pin list.
	// These had better be equal!

	if (m_iNextOutputPinNumber != m_mIPinRecords.size())
		return E_UNEXPECTED;

	// ZCS 7-18-97
	DWORD dwFirstNewPinNumber = m_iNextOutputPinNumber;

	for (int i = 0; i < dwPinsToAllocate; i++)
	{
		WCHAR szbuf[20];             // Temporary scratch buffer
	    wsprintfW(szbuf, L"Output%d", m_iNextOutputPinNumber);

		hr = NOERROR;

		ppNewPinsArray[i] = new CRTPDemuxOutputPin(NAME("RTPDemux Output"), this,
		  										   &hr, szbuf, m_iNextOutputPinNumber);

		m_iNextOutputPinNumber++;

		// if the allocation failed, clean up
		if ((ppNewPinsArray[i] == NULL) || (FAILED(hr)))
		{
			DbgLog((LOG_ERROR, 2, 
                    TEXT("CRTPDemux::AllocatePins: Error 0x%08x attempting to create a new pin"), 
                    ppNewPinsArray[i] ? hr : E_OUTOFMEMORY));
			// deallocate all the pins allocated so far
			for (int j = 0; j <= i; j++)
				delete ppNewPinsArray[i];
			// ...and don't forget the array of pointers itself!
			delete []ppNewPinsArray;
			return hr;
		} /* if */

		// ZCS 7-7-97: we no longer AddRef our own references to the output pins
		// because this is just our own reference count and addreffing it would
		// prevent our destructor from being called to release the references.
		// ppNewPinsArray[i]->AddRef();
	} /* for */

	// Now we've got an array of new pins -- add them to m_mIPinRecords.
	for (i = 0; i < dwPinsToAllocate; i++)
	{
	    IPin *pTempIPin = static_cast<IPin *>(ppNewPinsArray[i]);
	    ASSERT(m_mIPinRecords.find(pTempIPin) == m_mIPinRecords.end());

		IPinRecord_t pTempRecord;
		pTempRecord.pPin = ppNewPinsArray[i];
		pTempRecord.bPT = ppNewPinsArray[i]->GetPTValue();
		pTempRecord.mtsSubtype = MEDIASUBTYPE_NULL;
		pTempRecord.dwTimeout = ppNewPinsArray[i]->GetTimeoutDelay();
		pTempRecord.bAutoMapping = ppNewPinsArray[i]->IsAutoMapping();
		 // ZCS 7-18-97 -- keep track of which pin this is for GetPin()'s use
		pTempRecord.dwPinNumber = dwFirstNewPinNumber + i;

		// this insertion is only place that might eat memory, but we trust the STL
		m_mIPinRecords[pTempIPin] = pTempRecord;

		hr = SetPinMode(pTempIPin, TRUE);    // All pins are created as automapping.
		ASSERT(SUCCEEDED(hr));

		// ZCS: If someone's in the process of enumerating our pins, let them know that
		// our pin information has changed and the enumeration should be restarted.
		IncrementPinVersion();
	} /* for */

	delete []ppNewPinsArray;
    return NOERROR;
} /* CRTPDemux::AllocatePins() */


/*F*
//  Name    : CRTPDemux::RemovePins()
//  Purpose : Remove the indicated number of disconnected pins from our list of pins,
//            releasing them so they self-destruct in the process.
//  Context : Used by SetPinCount() as a helper function.
//  Returns : 
//      E_INVALIDARG    Too many pins indicated (eg, more than the
//                      count of currently disconnected pins.)
//      NOERROR         Successfully released the indicated number of pins.
//  Params  : 
//      dwPinsToRemove  The number of pins we need to remove.
//  Notes   : This is a private helper function for SetPinCount(),
//            so no need to acquire any locks as they were already
//            acquired there.
*F*/
HRESULT
CRTPDemux::RemovePins(
    DWORD dwPinsToRemove)
{
    int iUnconnectedPins = 0;
    count_if(m_mIPinRecords.begin(), m_mIPinRecords.end(),
             bIsPinPairUnBound, 
             iUnconnectedPins);

    if (iUnconnectedPins < dwPinsToRemove) return E_INVALIDARG;

    // Remember how many pins we started with.
    int iStartingSize = m_mIPinRecords.size();
    int iPinsRemoved = 0;
    IPinRecordMapIterator_t iIPinToRemove;

	// ZCS: remember which pins we removed so that we can fill in holes
	DWORD *removed = new DWORD[dwPinsToRemove];
	if (removed == NULL) return E_OUTOFMEMORY;

	while ((iUnconnectedPins > 0) && (iPinsRemoved < dwPinsToRemove)) {
        iIPinToRemove = find_if(m_mIPinRecords.begin(), 
                                m_mIPinRecords.end(), 
//                                bIsPinPairBound);
                                bIsPinPairUnBound);


        // ZCS: remember which ones we removed
		removed[iPinsRemoved] = (*iIPinToRemove).second.dwPinNumber;
		
		ASSERT(iIPinToRemove != m_mIPinRecords.end());
        UnmapPin((*iIPinToRemove).first, NULL);
        SetPinMode((*iIPinToRemove).first, FALSE);
        // ZCS 7-7-97 we no longer call release on our output pins
		// because that would just decrement our reference count -- instead we
		// just delete the output pin.
		// OLD: (*iIPinToRemove).first->Release();
		// in debug build we must also trick the extra debug-only refcount:
		// ASSERT((((CRTPDemuxOutputPin *)((*iIPinToRemove).first))->m_cRef = 0) == 0);
		delete dynamic_cast<CRTPDemuxOutputPin *>((*iIPinToRemove).first);
        m_mIPinRecords.erase(iIPinToRemove);
        iUnconnectedPins--;
        iPinsRemoved++;

		// ZCS: If someone's in the process of enumerating our pins, let them know that
		// our pin information has changed and the enumeration should be restarted.
		IncrementPinVersion();
	} /* while */

	// ZCS:
	// We've just plucked out the desired number of unconnected pins. This has
	// left us with a sequence with "holes". For example, we could
	// start with the sequence: *0, 1, *3, 2 and end up with the
	// sequence *0, 1, *3 or the sequence *0, *3, 2, or the sequence *0, *3,
	// any one of which will make GetPins() go crazy. We need to adjust the pin
	// numbers to get back to sanity. Furtunately we remembered the pin numbers
	// we removed: [1, 2] in the last case, so we can adjust.

	HRESULT hr = S_OK, hr2 = S_OK;

	for (int i = 0; i < dwPinsToRemove; i++)
	{
		IPinRecordMapIterator_t iIPinRecord;
        for (iIPinRecord = m_mIPinRecords.begin(); iIPinRecord != m_mIPinRecords.end(); iIPinRecord++)
			if ((*iIPinRecord).second.dwPinNumber > removed[i])
			{
				(*iIPinRecord).second.dwPinNumber--;
				
				// Also change the pin's name....
				WCHAR szbuf[20];             // Temporary scratch buffer
			    wsprintfW(szbuf, L"Output%d", (*iIPinRecord).second.dwPinNumber);

				// This returns an HRESULT and can fail if we run out of memory when allocating
				// the 20 bytes or so required to copy in the string. :) The names are not
				// too essential though so we should just keep on chugging and report the error
				// on returning (after having cleaned up nicely below).
				// The hr / hr2 business assures that if it fails one time and subsequently
				// succeeds, we remember that one of the calls failed and return the error.

				hr2 = (*iIPinRecord).second.pPin->Rename(szbuf); 
				if (hr == S_OK) hr = hr2;
			}

		// but the deleted pins have to be decremented too!
		for (int j = i + 1; j < dwPinsToRemove; j++)
			if (removed[j] > removed[i])
				removed[j]--;
	}

	delete []removed;

	// Make sure we removed the indicated number of pins.
    ASSERT(iStartingSize - dwPinsToRemove == m_mIPinRecords.size());

	// ZCS fix 7-11-97
    m_iNextOutputPinNumber -= dwPinsToRemove;
	
	return hr;
} /* CRTPDemux::RemovePins() */

/*F*
//  Name    : CRTPDemux::ClearSSRCForPin()
//  Purpose : Clear the SSRC for the indicated pin.
//  Context : Called by UnmapPin to clear the pin's current SSRC.
//            Called by MapSSRCToPin() when mapping a pin to a new SSRC when
//				it had previously been mapped to another SSRC.
//			  Called by UnmapSSRC() when it has the SSRC record already
//  Returns : 
//      E_POINTER   No such pin exists, or the passed-in pdwSSRC parameter
//                  is an invalid pointer.
//      S_FALSE     The pin in question was not previously mapped to any SSRC.
//  Params  : 
//  Notes   : rajeevb - added to separate the clearing of ssrc from unmapping the pin which
//				also removes the corresponding ssrc record
*F*/
STDMETHODIMP
CRTPDemux::ClearSSRCForPin(
    IPin    *pIPin,
    DWORD   &dwSSRC)
{
    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemux::ClearSSRCForPin: Called for pin 0x%08x"), 
            pIPin));

    IPinRecordMapIterator_t iIPinRecord = m_mIPinRecords.find(pIPin);
    if (iIPinRecord == m_mIPinRecords.end()) {
        DbgLog((LOG_ERROR, 3, TEXT("CRTPDemux::ClearSSRCForPin: No such pin!")));
        return E_POINTER;
    } /* if */

    if ((*iIPinRecord).second.pPin->m_dwSSRC == 0) {
        DbgLog((LOG_TRACE, 3, TEXT("CRTPDemux::ClearSSRCForPin: Pin 0x%08x not currently mapped.")));
        return S_FALSE;
    } /* if */

	dwSSRC = (*iIPinRecord).second.pPin->GetSSRC();

    (*iIPinRecord).second.pPin->m_dwSSRC = 0;// Mark the pin as no longer being mapped to an SSRC.

    return NOERROR;
} /* CRTPDemux::ClearSSRCForPin() */


/*F*
//  Name    : CRTPDemux::UnmapPin()
//  Purpose : Unmap the indicated pin from the SSRC currently being delivered to it.
//  Context : Called by the app to force a pin to be unmapped from its current SSRC.
//            Called by MapSSRCToPin() when mapping a pin to a new SSRC when
//            it had previously been mapped to another SSRC.
//  Returns : 
//      E_POINTER   No such pin exists, or the passed-in pdwSSRC parameter
//                  is an invalid pointer.
//      S_FALSE     The pin in question was not previously mapped to any SSRC.
//  Params  : 
//  Notes   : 
*F*/
STDMETHODIMP
CRTPDemux::UnmapPin(
    IPin    *pIPin,
    DWORD   *pdwSSRC)
{
    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemux::UnmapPin: Called for pin 0x%08x"), 
            pIPin));

    CAutoLock l(m_pLock);
    
   if ((pdwSSRC != static_cast<DWORD *>(NULL)) && 
        (IsBadWritePtr(pdwSSRC, sizeof(DWORD)))) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRTPDemux::UnmapPin: Invalid pdwSSRC argument passed in!")));
        return E_POINTER;
    } /* if */

	// rajeevb - this only clears the ssrc entry on the pin
	DWORD	dwSSRC;
    HRESULT hr = ClearSSRCForPin(pIPin, dwSSRC);
	if ( NOERROR != hr ) {
		return hr;
	}

	// remove the corresponding ssrc record
	if ( 1 != m_mSSRCRecords.erase(dwSSRC) )
	{
		DbgLog((LOG_TRACE, 3, 
				TEXT("CRTPDemux::UnmapPin: SSRC 0x%08x from SSRC records failed"), dwSSRC));
		return S_FALSE;
	}

	// if the caller wants the ssrc value, set the parameter to the value
    if (pdwSSRC != static_cast<DWORD *>(NULL)) {
        *pdwSSRC = dwSSRC;
    } /* if */

    return NOERROR;
} /* CRTPDemux::UnmapPin() */


/*F*
//  Name    : CRTPDemux::UnmapSSRC()
//  Purpose : Unmap the indicated SSRC from whatever pin it is currently associated with.
//  Context : Called by the app to force a SSRC to be unmapped from its current pin.
//            Part of the IIntelRTPDemuxFilter interface.
//  Returns : 
//      E_INVALIDARG    There is no record of the SSRC in question.
//      E_POINTER       Invalid (unwritable) ppIPin parameter.
//      S_FALSE         The indicated SSRC is not currently mapped to any pin.
//      NOERROR         Successfully unmapped SSRC in question.
//  Params  : 
//      dwSSRC  The SSRC to be unmapped.
//      ppIPin  Returns the pin the SSRC was unmapped from.
//              The app may pass in NULL if not interested.
//  Notes   : Uses ClearSSRCForPin() to do the dirty work.
//            The app has to make sure to release the ppIPin 
//            if it isn't passed in as NULL.
*F*/
STDMETHODIMP
CRTPDemux::UnmapSSRC(
    DWORD   dwSSRC,
    IPin    **ppIPin)
{
    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemux::UnmapSSRC() called for SSRC 0x%08x"), dwSSRC));

    CAutoLock l(m_pLock);
    
    if ((ppIPin != static_cast<IPin **>(NULL)) && 
        (IsBadWritePtr(ppIPin, sizeof(IPin *)))) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRTPDemux::UnmapSSRC: Invalid ppIPin pointer passed in!")));
        return E_POINTER;
    } /* if */

    SSRCRecordMapIterator_t iSSRCRecord = m_mSSRCRecords.find(dwSSRC);
    if (iSSRCRecord == m_mSSRCRecords.end()) {
        DbgLog((LOG_ERROR, 3, 
                TEXT("CRTPDemux::UnmapSSRC(): No record of SSRC 0x%08x!"), dwSSRC));
        return E_INVALIDARG;
    } /* if */

    if ((*iSSRCRecord).second.pPin == NULL) {
        DbgLog((LOG_ERROR, 3, 
                TEXT("CRTPDemux::UnmapSSRC(): SSRC 0x%08x is not mapped to any pin!"), dwSSRC));
        return S_FALSE;
    } /* if */

    IPin *pIPin;
    HRESULT hErr = (*iSSRCRecord).second.pPin->QueryInterface(IID_IPin,
                                                              reinterpret_cast<PVOID *>(&pIPin));
    ASSERT(SUCCEEDED(hErr)); // Out output pin should always support this interface.

    DWORD dwTempSSRC = 0;
    hErr = CRTPDemux::ClearSSRCForPin(pIPin, dwTempSSRC);
    ASSERT(SUCCEEDED(hErr)); // This should always succeed as we already know this pin is mapped.
    ASSERT(dwTempSSRC == dwSSRC); // Sanity check.
	// remove the ssrc record (erase by iterator returns void - so nothing to check)
	m_mSSRCRecords.erase(iSSRCRecord);

    if (ppIPin != static_cast<IPin **>(NULL)) {
        *ppIPin = pIPin;
    } else {
        // Since the app doesn't want the IPin, release it here.
        pIPin->Release();
    } /* if */

    return NOERROR;
} /* CRTPDemux::UnmapSSRC() */


/*F*
//  Name    : CRTPDemux::GetPages()
//  Purpose : Return the CLSID of the property page we support.
//  Context : Called when the FGM wants to show our property page.
//  Returns : 
//      E_OUTOFMEMORY   Unable to allocate structure to return property pages in.
//      NOERROR         Successfully returned property pages.
//  Params  :
//      pcauuid Pointer to a structure used to return property pages.
//  Notes   : None.
*F*/
HRESULT 
CRTPDemux::GetPages(
    CAUUID *pcauuid) 
{
    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemux::GetPages called")));

    pcauuid->cElems = 1;
    pcauuid->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pcauuid->pElems == NULL) {
        return E_OUTOFMEMORY;
    } /* if */

    *(pcauuid->pElems) = *pPropertyPageClsids[ 0 ];
    return NOERROR;
} /* CRTPDemux::GetPages() */


/*F*
//  Name    : CRTPDemux::GetPin()
//  Purpose : Return the Nth pin of this filter, where the
//            zeroth is the input pin.
//  Context : Called by FindPin() to find a pin by number.
//            Called by IEnumPins when traversing our pin list.
//  Returns : 
//      NULL            We have less than N pins.
//      A CBasePin *    If we found the pin in question.
//  Params  :
//      n     The pin we are interested in.
//  Notes   : None.
*F*/
CBasePin *
CRTPDemux::GetPin(
    int n)
{
    CAutoLock l(m_pLock);

    DbgLog((LOG_TRACE, 6, TEXT("CRTPDemux::GetPin(%d) called"), n));
    
    // Pin zero is the one and only input pin
    if (n == 0)
        return m_pInput;

    // we want the output pin at position(n - 1) (zero based)
    n--;
    
    // Validate the position being asked for
    if (n >= m_mIPinRecords.size()) {
        DbgLog((LOG_ERROR, 5, TEXT("CRTPDemux::GetPin(%d) called - only have %d output pins!"), 
                n+1, m_mIPinRecords.size()));
        return NULL;
    } /* if */

	// ZCS: this used to just take the nth pin in the map -- changed it to
	// actually look at pin numbers

    IPinRecordMapIterator_t iIPinRecord = m_mIPinRecords.begin();
    while (iIPinRecord != m_mIPinRecords.end())
	{
		if (((*iIPinRecord).second).dwPinNumber == n)
			break;
        
		iIPinRecord++;
    } /* if */

    ASSERT(iIPinRecord != m_mIPinRecords.end());
    return static_cast<CBasePin *>((*iIPinRecord).second.pPin);
} /* CRTPDemux::GetPin() */


/*F*
//  Name    : CRTPDemux::FindPin()
//  Purpose : Return the named pin in the given IPin **.
//  Context : Called for persistent stream support.
//  Returns : 
//      VFW_E_NOT_FOUND No such pin exists.
//      NOERROR         Pin found & returned in ppPin.
//  Params  :
//      pwszPinId   Name of the desired pin.
//      ppPin       Return parameter used to place in in.
//  Notes   : None.
*F*/
STDMETHODIMP 
CRTPDemux::FindPin(
    LPCWSTR pwszPinId, 
    IPin    **ppPin)
{
    CAutoLock l(m_pLock);

    DbgLog((LOG_TRACE, 5, TEXT("CRTPDemux::FindPin(%s) called"), pwszPinId));

    *ppPin = GetPin(WstrToInt(pwszPinId));
    if (*ppPin==NULL) {
        DbgLog((LOG_ERROR, 5, TEXT("CRTPDemux::FindPin(%s): No such pin!"), pwszPinId));
        return VFW_E_NOT_FOUND;
    }

	// addref becayse we are returning a reference to the pin
    (*ppPin)->AddRef();
    return NOERROR;
}  /* CRTPDemux::FindPin() */


/*F*
//  Name    : CRTPDemux::FindSubtypeFromPT()
//  Purpose : Given a particular PT, see if it is a well know RTP
//            payload that we have a subtype for in the registry.
//  Context : Helper function called by SetupPinTypeInfo().
//  Returns : 
//      MEDIASUBTYPE_NULL   No matching subtypes in the registry for this PT.
//      Otherwise returns a subtype that indicated PT is equivalent of.
//  Params  :
//      bPT     Well know payload value to get a subtype for.
//  Notes   : None.
*F*/
GUID 
CRTPDemux::FindSubtypeFromPT(
    BYTE bPT)
{
    long    lRes;
    HKEY    hKey;
    DWORD   dwTypekeys, dwTypeNameLen, dwIndex, dwBufLen, dwData;
    // open the registry key for rtp payload info.
    lRes = RegOpenKeyEx (HKEY_LOCAL_MACHINE, szRegAMRTPKey, 0, KEY_READ, &hKey);
    lRes = RegQueryInfoKey(hKey, NULL, NULL, NULL, &dwTypekeys, &dwTypeNameLen,
                           NULL, NULL, NULL, NULL, NULL, NULL);

    TCHAR   tchTypeBuf[128];
    HKEY    hTypeKey;
    BYTE    lpValBuf[128];
    DWORD   dwValLen;
    wchar_t wcCLSID[40];
    GUID    gSubtype;
    // Enumerate over the registered payload types searching for
    // one with a matching PT value.
    for (dwIndex = 0; dwIndex < dwTypekeys; dwIndex++) {
        dwBufLen = dwTypeNameLen;
        // Get the next key
        lRes = RegEnumKeyEx(hKey, dwIndex, tchTypeBuf, &dwBufLen, NULL, NULL, NULL, NULL);
        // Gotta open the GUID first because it is the key for each PT.
        lRes = RegOpenKeyEx (hKey, tchTypeBuf, 0, KEY_READ, &hTypeKey);
        dwValLen = 128;
        lRes = RegQueryValueEx(hTypeKey, "PayloadType", NULL, &dwData, lpValBuf, &dwValLen);
        if (bPT == *(reinterpret_cast<DWORD *>(&lpValBuf[0]))) {
            // Found a match.
            // Convert the CLSID to WChars.
            mbstowcs(wcCLSID, tchTypeBuf, 40);
            // Convert the WChars to a GUID structure.
            CLSIDFromString(wcCLSID, &gSubtype);
            // Close out our keys.
            RegCloseKey(hTypeKey);
            RegCloseKey(hKey);
            // Return the GUID.
            return gSubtype;
        } /* if */

        RegCloseKey(hTypeKey);
    } /* for */

    RegCloseKey(hKey);
    return MEDIASUBTYPE_NULL;
} /* CRTPDemux::FindSubtypeFromPT() */



/*F*
//  Name    : CRTPDemux::Stop()
//  Purpose : Signal a stop. Overridden to handle no input pin connection.
//  Context : Called when the graph is stop.
//  Returns : Result of stop() from CBaseFilter superclass.
//  Params  : None.
//  Notes   : None.
*F*/
STDMETHODIMP 
CRTPDemux::Stop()
{
    CAutoLock l(m_pLock);

    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemux::Stop() called")));
    CBaseFilter::Stop();
    m_State = State_Stopped;
    return NOERROR;
} /* CRTPDemux::Stop() */


/*F*
//  Name    : CRTPDemux::Pause()
//  Purpose : Signal a pause. Overridden to handle no input pin connection.
//  Context : Called when the graph is paused.
//  Returns : Result of Pause() from CBaseFilter superclass.
//  Params  : None.
//  Notes   : None.
*F*/
STDMETHODIMP 
CRTPDemux::Pause()
{
    CAutoLock l(m_pLock);

    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemux::Pause() called")));
    HRESULT hr = CBaseFilter::Pause();
    if (m_pInput->IsConnected() == FALSE) {
        m_pInput->EndOfStream();
    } /* if */

    DbgLog((LOG_TRACE, 4, TEXT("CRTPDemux::Pause: BaseFilter method returning 0x%08x"), hr));

    return hr;
} /* CRTPDemux::Pause() */


/*F*
//  Name    : CRTPDemux::Run()
//  Purpose : Signal a run. Overridden to handle no input pin connection.
//  Context : Called when the graph is ran.
//  Returns : Result of Run() from CBaseFilter superclass.
//  Params  : None.
//  Notes   : None.
*F*/
STDMETHODIMP 
CRTPDemux::Run(
    REFERENCE_TIME tStart)
{
    CAutoLock l(m_pLock);

    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemux::Run(%d) called"), tStart));
    HRESULT hr = CBaseFilter::Run(tStart);
    if (m_pInput->IsConnected() == FALSE) {
        m_pInput->EndOfStream();
    } /* if */

    DbgLog((LOG_TRACE, 4, TEXT("CRTPDemux::Run: BaseFilter method returning 0x%08x"), hr));

    return hr;
} /* CRTPDemux::Run() */


#if !defined(AMRTPDMX_IN_DXMRTP)
//
// DllRegisterServer
//
STDAPI DllRegisterServer()
{
    HRESULT hr = RegisterResource(MAKEINTRESOURCE(IDR_PayloadData));
    if (FAILED(hr)) return hr;

    // Finally call the activemovie registry helpers
    return AMovieDllRegisterServer2( TRUE );
}


//
// DllUnregisterServer
//
STDAPI
DllUnregisterServer()
{
    //BUGBUG : Payload Data not removed
    return AMovieDllRegisterServer2( FALSE );
}
#else
void RtpDemuxRegisterResources()
{
	RegisterResource(MAKEINTRESOURCE(IDR_PayloadData));
}
#endif

STDMETHODIMP 
CRTPDemux::GetDemuxID(DWORD *pdwID)
{
	CheckPointer(pdwID, E_POINTER);

	*pdwID = (DWORD)m_lDemuxID;
	return(NOERROR);
}

#endif _RTPDEMUX_CPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpdmx\rtpdoutp.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : RTPDmx.h
// Purpose  : Define the class that implements the RTP Demux filter.
// Contents : 
//*M*/

#ifndef _RTPDOUTP_H_
#define _RTPDOUTP_H_

class CRTPDemux;
class CRTPDemuxOutputPin;
class CSSRCEnumPin;


/*C*
//  Name    : CRTPDemuxOutputPin
//  Purpose : Implements the output pins of the RTP Demux filter.
//  Context : Handles most issues associated with keeping track
//            of the state (PT, pin mode, etc.) of the RTP Demux filter.
*C*/
class 
CRTPDemuxOutputPin 
: public CBaseOutputPin
{
    friend class CRTPDemuxInputPin;
    friend class CRTPDemux;
    friend struct ExpirePin;

    CRTPDemux       *m_pFilter;     // Main filter object pointer
    CPosPassThru    *m_pPosition;     // Pass seek calls upstream
    LONG            m_cOurRef;                // We maintain reference counting

    DWORD           m_dwSSRC;
    BYTE            m_bPT;
    BOOL            m_bAutoMapping;
    DWORD           m_dwLastPacketDelivered;
    DWORD           m_dwTimeoutDelay;

public:

    // Constructor and destructor

    CRTPDemuxOutputPin(
        TCHAR       *pObjName,
        CRTPDemux   *pFilter,
        HRESULT     *phr,
        LPCWSTR     pPinName,
        INT         PinNumber);

    ~CRTPDemuxOutputPin();

    BOOL IsAutoMapping(void) { return m_bAutoMapping; }
    void SetAutoMapping(BOOL bAutoMapping) { m_bAutoMapping = bAutoMapping; }

    BYTE GetPTValue(void) { return m_bPT; }
    void SetPTValue(BYTE bPT) { m_bPT = bPT; } 

    DWORD GetSSRC(void) { return m_dwSSRC; }
    void SetSSRC(DWORD dwSSRC) { m_dwSSRC = dwSSRC; }

    DWORD GetLastPacketDeliveryTime(void) { return m_dwLastPacketDelivered; }
    DWORD GetTimeoutDelay(void) { return m_dwTimeoutDelay; }
    void SetTimeoutDelay(DWORD dwMilliseconds) { m_dwTimeoutDelay = dwMilliseconds; }

    // Override since the life time of pins and filters are not the same
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    // Override to enumerate media types
//    STDMETHODIMP EnumMediaTypes(IEnumMediaTypes **ppEnum);

    // Check that we can support an output type
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    // Memory allocator stuff.
    HRESULT CompleteConnect(
        IPin                    *pIPin);
    HRESULT DecideAllocator(
        IMemInputPin            *pPin, 
        IMemAllocator           **ppAlloc);
    HRESULT DecideBufferSize(
        IMemAllocator           *pMemAllocator,
        ALLOCATOR_PROPERTIES    *pPropInputRequest);
    HRESULT NotifyAllocator(
        IMemAllocator           *pMemAllocator, 
        BOOL                    bReadOnly);

    // Persistent pin id
    STDMETHODIMP QueryId(LPWSTR * Id);

    // Used to record time a packet was delivered.
    HRESULT Deliver(IMediaSample *pSample);

    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

	// ZCS 7-21-97: allow the filter to change our name
	HRESULT Rename(WCHAR *szName);
};


#endif _RTPDOUTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpdmx\rtpdoutp.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : RTPDemux.cpp
// Purpose  : RTP Demux filter implementation.
// Contents : 
//*M*/

#include <streams.h>

#ifndef _RTPDOUTP_CPP_
#define _RTPDOUTP_CPP_

#pragma warning( disable : 4786 )
#pragma warning( disable : 4146 )
#pragma warning( disable : 4018 )
#include <algo.h>
#include <map.h>
#include <multimap.h>
#include <function.h>

#include <AMRTPUID.h>

#include "amRTPDmx.h"
#include "RTPDType.h"
#include "Globals.h"

#include "RTPDmx.h"
#include "RTPDInpP.h"
#include "RTPDOutP.h"

#include "RTPDProp.h"
#include "SSRCEnum.h"

/*F*
//  Name    : CRTPDemuxOutputPin::Notify()
//  Purpose : Pass on quality notifications to the upstream filter.
//            Don't act on them directly, because we can't do anything
//            about it in this filter.
//  Context : Called by the downstream filter when it is being
//            starved/flooded.
//  Returns : 
//      S_FALSE         No upstream filter is connected to us, and we
//                      couldn't do anything about the quality problem.
//      Otherwise returns whatever the upstream filter returns.
//  Params  : 
//      pSender The filter sending the notification.
//      q       The quality info (flood/starvation + degree).
//  Notes   : It seems like it would be very unlikely, if not
//            impossible, to get a notify message when not connected
//            to an upstream filter, but check for it anyway.
*F*/
STDMETHODIMP
CRTPDemuxOutputPin::Notify(
    IBaseFilter *pSender, 
    Quality     q)
{
    CheckPointer(pSender, E_POINTER);
    ValidateReadPtr(pSender, sizeof(IBaseFilter));

    CAutoLock lck(m_pFilter->m_pLock);
    if (m_pFilter->m_pInput->IsConnected() == TRUE) {
        // Find the quality sink for our input pin and send it there
        DbgLog((LOG_TRACE, 4, TEXT("CRTPDemuxOutputPin::Notify() called - passing upstream")));
        return m_pFilter->m_pInput->PassNotify(q);
    } else {
        // No upstream filter.
        DbgLog((LOG_TRACE, 4, TEXT("CRTPDemuxOutputPin::Notify() called but no upstream filter. Retunring S_FALSE.")));
        return S_FALSE;
    } /* if */
} /* CRTPDemuxOutputPin::Notify() */


/*F*
//  Name    : CRTPDemuxOutputPin::QueryId()
//  Purpose : Persistent pin ID support.
//  Context : 
//  Returns : 
//      NOERROR         Found requested pin
//      E_OUTOFMEMORY   Unable to allocator memory to return name of pin.
//      VFW_E_NOT_FOUND Unable to find this pin to return its id.
//  Params  : None.
//  Notes   : None.
*F*/
STDMETHODIMP 
CRTPDemuxOutputPin::QueryId(LPWSTR *Id)
{
    DbgLog((LOG_TRACE, 5, TEXT("CRTPDemuxOutputPin::QueryId() called")));
    
    CheckPointer(Id,E_POINTER);
    IPinRecordMapIterator_t iIPinRecord = m_pFilter->m_mIPinRecords.begin();
	// ZCS 7-18-97: we no longer count, instead we look in .second
	// (ie we no longer trust the map order as it depends on heap subtleties)
    // int nPin = 1;   // The first output pin is number 1


    while(iIPinRecord != m_pFilter->m_mIPinRecords.end()) {
        if ((*iIPinRecord).second.pPin == this) {
            *Id =(LPWSTR)CoTaskMemAlloc(8);
            if (*Id==NULL) {
                DbgLog((LOG_ERROR, 3, TEXT("CRTPDemuxOutputPin::QueryId(): Unable to allocate memory to return pin ID!")));
                return E_OUTOFMEMORY;
            } /* if */
			// ZCS: + 1 because this we count our output pins starting at 1
            IntToWstr((*iIPinRecord).second.dwPinNumber + 1, *Id);
            return NOERROR;
        } /* if */
		// ZCS 7-18-97
        // nPin++;
        iIPinRecord++;
    } /* while */

    DbgLog((LOG_ERROR, 4, TEXT("CRTPDemuxOutputPin::QueryId(): Unable to find requested pin!")));
    return VFW_E_NOT_FOUND;
} /* CRTPDemuxOutputPin::QueryId() */


/*F*
//  Name    : CRTPDemuxOutputPin::CRTPDemuxOutputPin()
//  Purpose : Construct an RTP Demux output pin.
//  Context : Called during construction time.
//  Returns : Nothing.
//  Params  : 
//      pName       Name to pass to base CUnknown class.
//      pFilter     Pointer to the RTP Demux filter that owns us.
//      phr         Return value to place error codes in.
//      pPinName    Name for this pin.
//      PinNumber   Which pin we are.
//  Notes   :
//      We default our automapping flag to false, because the
//      RTP Demux filter explicitly adds us to its automap after creating us.
*F*/
CRTPDemuxOutputPin::CRTPDemuxOutputPin(
    TCHAR       *pName,
    CRTPDemux   *pFilter,
    HRESULT     *phr,
    LPCWSTR     pPinName,
    int         PinNumber) 
: CBaseOutputPin(pName, pFilter, pFilter, phr, pPinName) ,
  m_pPosition(NULL),
  m_pFilter(pFilter),
  m_cOurRef(0),
  m_dwSSRC(0), 
  m_bPT(PAYLOAD_INVALID),
  m_bAutoMapping(FALSE),
  m_dwLastPacketDelivered(0), m_dwTimeoutDelay(2000)
{
    ASSERT(pFilter);
    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxOutputPin::CRTPDemuxOutputPin: Constructed at 0x%08x"), this));
}

//
// CRTPDemuxOutputPin destructor
//
CRTPDemuxOutputPin::~CRTPDemuxOutputPin()
{
    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxOutputPin::~CRTPDemuxOutputPin: Destructor for 0x%08x called"), this));
}


//
// NonDelegatingAddRef
//
// We need override this method so that we can do proper reference counting
// on our output pin. The base class CBasePin does not do any reference
// counting on the pin in RETAIL.
//
// Please refer to the comments for the NonDelegatingRelease method for more
// info on why we need to do this.
//
STDMETHODIMP_(ULONG) CRTPDemuxOutputPin::NonDelegatingAddRef()
{
    CAutoLock lock_it(m_pLock);

    // Update the debug only variable maintained by the base class
	// (ASSERT compiles to nothing in a fre build)
	// ASSERT(++m_cRef > 0);

   	// ZCS: we use the filter's refcount.
	return m_pFilter->AddRef();
} // NonDelegatingAddRef

//STDMETHODIMP_(ULONG) CRTPDemuxOutputPin::AddRef()
//{
//    CAutoLock lock_it(m_pLock);
//	return m_pFilter->AddRef();
//} // AddRef

//
// NonDelegatingRelease
//
// CRTPDemuxOutputPin overrides this class so that we can take the pin out of our
// output pins list and delete it when its reference count drops to 1 and there
// is atleast two free pins.
//
// Note that CreateNextOutputPin holds a reference count on the pin so that
// when the count drops to 1, we know that no one else has the pin.
//
// Moreover, the pin that we are about to delete must be a free pin(or else
// the reference would not have dropped to 1, and we must have atleast one
// other free pin(as the filter always wants to have one more free pin)
//
// Also, since CBasePin::NonDelegatingAddRef passes the call to the owning
// filter, we will have to call Release on the owning filter as well.
//
// Also, note that we maintain our own reference count m_cOurRef as the m_cRef
// variable maintained by CBasePin is debug only.
//
STDMETHODIMP_(ULONG) CRTPDemuxOutputPin::NonDelegatingRelease()
{
	CAutoLock lock_it(m_pLock);

    // Update the debug only variable in CBasePin
	// (ASSERT compiles to nothing in a fre build)
	// ASSERT(--m_cRef >= 0);

	// ZCS: we just use the filter's refcount.
	// notwithstanding the comment block above, I did this to get around all
	// sorts of problems with AV's that depend on the order things are released,
	// and circular reference counts that prevent everything from getting released.
	return m_pFilter->Release();
} // NonDelegatingRelease

//STDMETHODIMP_(ULONG) CRTPDemuxOutputPin::Release()
//{
//	CAutoLock lock_it(m_pLock);
//	return m_pFilter->Release();
//} // Release

/*F*
//  Name    : CRTPDemuxOutputPin::DecideBufferSize()
//  Purpose : Present to override the base class, which is pure.
//  Context : Called as part of memory allocator negotiation.
//  Returns :
//      NOERROR We never do anything.
//  Params  : 
//      pMemAllocator       The suggested memory allocator.
//      pPropInputRequest   The properties we want for a memory allocator.
//  Notes   : 
*F*/
HRESULT 
CRTPDemuxOutputPin::DecideBufferSize(
    IMemAllocator           *pMemAllocator,
    ALLOCATOR_PROPERTIES    *pPropInputRequest)
{
    // We don't care, as we don't touch the data.
    return NOERROR;
} /* CRTPDemuxOutputPin::DecideBufferSize() */


/*F*
//  Name    : CRTPDemuxOutputPin::Deliver()
//  Purpose : Deliver a buffer downgraph.
//  Context : Called by the input pin when it has a sample
//            ready to deliver in OldSSRC().
//  Returns : Whatever the base pine class returns for Deliver().
//  Params  : 
//      pSample The media sample to deliver downgraph.
//  Notes   : Debugging output added to be able to tell when
//            we are stuck downgraph.
*F*/
HRESULT 
CRTPDemuxOutputPin::Deliver(
    IMediaSample *pSample)
{
    m_dwLastPacketDelivered = timeGetTime();
    HRESULT hErr = NOERROR;

    DbgLog((LOG_TRACE, 6, TEXT("CRTPDemuxOutputPin::Deliver: About to deliver downgraph at time %d."), m_dwLastPacketDelivered));
    if (m_pInputPin == NULL) {
        DbgLog((LOG_TRACE, 7, TEXT("CRTPDemuxOutputPin::Deliver: Not connected, returning NOERROR")));
    } else {
        HRESULT hErr = m_pInputPin->Receive(pSample);
        DbgLog((LOG_TRACE, 7, TEXT("CRTPDemuxOutputPin::Deliver: Downgraph pin retuned 0x%08x from deliver at time %d."), hErr, timeGetTime()));
    } /* if */

    return hErr;
} /* CRTPDemuxOutputPin::Deliver() */


/*F*
//  Name    : CRTPDemuxOutputPin::CompleteConnect()
//  Purpose : Verify that everything is OK with the input pin.
//  Context : Called upon completion of connection with a downstream filter.
//  Returns : If connected upgraph, the return code from reconnecting
//            the upgraph connection. Otherwise returns NOERROR.
//  Params  : 
//      pIPin   The IPin that this output pin is connecting to (e.g., the
//              input pin of the downstream filter.
//  Notes   : Reconnecting the upgraph pin should trigger 
//            memory allocator renegotiation, which is what we want
//            to happen, because adding a new RPH to the graph means
//            one more place that media samples might be held on to.
*F*/
HRESULT
CRTPDemuxOutputPin::CompleteConnect(
    IPin *pIPin)
{
    ASSERT(pIPin);
    DbgLog((LOG_TRACE, 2, TEXT("CRTPDemuxOutputPin::CompleteConnect: Called for output pin 0x%08x"),
            pIPin));

    HRESULT hErr = NOERROR;
    if (m_pFilter->m_pInput->IsConnected()) {
        DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxOutputPin::CompleteConnect: Input pin is connected. Reconnecting to force allocator renegotiation.")));
        hErr = m_pFilter->m_pGraph->Reconnect(static_cast<IPin *>(m_pFilter->m_pInput));
    } /* if */

    if (SUCCEEDED(hErr)) {
        int n = m_pFilter->GetNumFreePins();
        if (n > 0) {
            DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxOutputPin::CompleteConnect: At least one free pin. Returning success.")));
            return hErr;
        } /* if */

        DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxOutputPin::CompleteConnect: No free output pins available. Spawning new pin.")));
        // No unconnected pins left so spawn a new one
        hErr = m_pFilter->AllocatePins(1);
    } /* if */

    return hErr;
} /* CRTPDemuxOutputPin::CompleteConnect() */


/*F*
//  Name    : CRTPDemuxOutputPin::DecideAllocator()
//  Purpose : 
//  Context : 
//  Returns : 
//  Params  : 
//  Notes   :
*F*/
HRESULT 
CRTPDemuxOutputPin::DecideAllocator(
    IMemInputPin    *pPin, 
    IMemAllocator   **ppAlloc)
{
    ASSERT(m_pFilter->m_pAllocator != static_cast<IMemAllocator *>(NULL));
    *ppAlloc = NULL;

    // Tell the pin about our allocator, set by the input pin.
    HRESULT hr = NOERROR;
    hr = pPin->NotifyAllocator(m_pFilter->m_pAllocator,TRUE);
    if (FAILED(hr))
        return hr;

    // Return the allocator
    *ppAlloc = m_pFilter->m_pAllocator;
    m_pFilter->m_pAllocator->AddRef();
    return NOERROR;

} /* CRTPDemuxOutputPin::DecideAllocator() */



/*F*
//  Name    : CRTPDemuxOutputPin::NotifyAllocator()
//  Purpose : Tell this output pin what allocator to use.
//            Tell the pin we are connected to (if any)
//            to use the same allocator.
//  Context : Called by CRTPDemuxInputPin::NotifyAllocator().
//  Returns : 
//  Params  : 
//      pAllocator  The new allocator to be used.
//      bReadOnly   Whether this is a read-only allocator or not.
//  Notes   :
*F*/
HRESULT
CRTPDemuxOutputPin::NotifyAllocator(
    IMemAllocator * pAllocator,
    BOOL bReadOnly)
{
    CheckPointer(pAllocator,E_POINTER);
    ValidateReadPtr(pAllocator,sizeof(IMemAllocator));

    HRESULT hErr = m_pInputPin->NotifyAllocator(pAllocator, bReadOnly);
    if (FAILED(hErr)) {
        DbgLog((LOG_ERROR, 2, TEXT("CRTPDemuxOutputPin::NotifyAllocator: Error 0x%08x calling NotifyAllocator on downgraph input pin 0x%08x!"), 
                hErr, m_Connected));
        return hErr;
    } /* if */

    // It's possible that the old and the new are the same thing.
    // AddRef before release ensures that we don't unload the thing!
    pAllocator->AddRef();

    if( m_pAllocator != NULL )
        m_pAllocator->Release();

    m_pAllocator = pAllocator;

    return NOERROR;
} /* CRTPDemuxOutputPin::NotifyAllocator() */


/*F*
//  Name    : CRTPDemuxOutputPin::CheckMediaType()
//  Purpose : See if this pin likes a proposed media type.
//  Context : Called during connection time. 
//  Returns : 
//      S_FALSE We don't like the proposed media type.
//      S_OK    The proposed media type looks good.
//  Params  : 
//      pProposedMT The media type being proposed to us.
//  Notes   : None.
*F*/
HRESULT 
CRTPDemuxOutputPin::CheckMediaType(
    const CMediaType    *pProposedMT)
{
    CAutoLock lock_it(m_pLock);

    HRESULT hr = NOERROR;

    // The major type has to be RTP_Single_Stream for output pins.
    if (*pProposedMT->Type() != MEDIATYPE_RTP_Single_Stream) {
        DbgLog((LOG_ERROR, 3, 
                TEXT("CRTPDemuxOutputPin::CheckMediaType(): Failed to accept major media type")));
        return S_FALSE;
    } /* if */

    // See if the subtype matches.
    if (*(pProposedMT->Subtype()) == *(m_mt.Subtype())) {
        DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxInputPin::CheckMediaType(): Accepted media type")));
        return S_OK;
    } /* if */

    // No subtype match.
    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxOutputPin::CheckMediaType: Unable to match subtype value. Not accepting media type.")));
    return S_FALSE;
} /* CRTPDemuxOutputPin::CheckMediaType() */


/*F*
//  Name    : CRTPDemuxOutputPin::GetMediaType()
//  Purpose : See what media types this pin proposes for connection.
//  Context : Called at connection time.
//  Returns : 
//      S_OK    Returned a media type this pin likes.
//      VFW_S_NO_MORE_ITEMS No more media types supported.
//  Params  : 
//      iPosition   The caller wants the ith media type in our array.
//      pMediaType  Pointer to where to place the media type we support.
//  Notes   : None.
*F*/
HRESULT 
CRTPDemuxOutputPin::GetMediaType(
    int         iPosition, 
    CMediaType  *pMediaType)
{
    DbgLog((LOG_TRACE, 4, TEXT("CRTPDemuxOutputPin::GetMediaType(): Called for position %d"),
            iPosition));

    ASSERT(iPosition < 2);
    if (iPosition == 0) {
        // Major type is always the same.
        pMediaType->SetType(&MEDIATYPE_RTP_Single_Stream);
        // Minor type is whatever was set by the app.
        pMediaType->SetSubtype(&m_mt.subtype);
        return S_OK;
    } /* if */

    ASSERT(iPosition > 0);
    return VFW_S_NO_MORE_ITEMS;
} /* CRTPDemuxOutputPin::GetMediaType() */


//
// EnumMediaTypes
//
//STDMETHODIMP CRTPDemuxOutputPin::EnumMediaTypes(IEnumMediaTypes **ppEnum)
//{
//    CAutoLock lock_it(m_pLock);
//    ASSERT(ppEnum);

    // FIX - return the media type of this pin here.
//    return E_NOTIMPL;

//} // EnumMediaTypes


//
// SetMediaType
//
HRESULT 
CRTPDemuxOutputPin::SetMediaType(
    const CMediaType    *pmt)
{
    CAutoLock lock_it(m_pLock);

    // Nothing to do here.
    // FIX - sure about that?
    m_mt = *pmt;

    m_TypeVersion++;
    return NOERROR;
} /* CRTPDemuxOutputPin::SetMediaType() */

// ZCS 7-21-97: this lets us rename pins so that the graph editor will display
// its sockets correctly after other pins have been removed.
//
// Note: I would rather use TCHAR than WCHAR, but ActiveMovie uses WCHAR...

HRESULT CRTPDemuxOutputPin::Rename(WCHAR *szName)
{
	// check that we've got a valid string
	if ((szName == NULL) || IsBadReadPtr(szName, sizeof(szName))) return E_POINTER;

    // get rid of the old name
	if (m_pName) delete []m_pName;

	// make space for the new name
	DWORD dwNameLen = lstrlenW(szName) + 1;
	m_pName = new WCHAR[dwNameLen];
	if (!m_pName) return E_OUTOFMEMORY;
	
	// copy it in
    CopyMemory(m_pName, szName, dwNameLen * sizeof(WCHAR));

	// all done
	return S_OK;
}

#endif _RTPDOUTP_CPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpdmx\rtpdprop.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : RTPDProp.cpp
// Purpose  : RTP Demux filter property page implementation.
// Contents : 
//*M*/

#include <streams.h>

#ifndef _RTPDPROP_CPP_
#define _RTPDPROP_CPP_

#include <strmif.h>

#pragma warning( disable : 4786 )
#pragma warning( disable : 4146 )
#pragma warning( disable : 4018 )
#include <algo.h>
#include <map.h>
#include <multimap.h>
#include <function.h>

#include <commctrl.h>


#include "resource.h"

#include "amrtpdmx.h"
#include "rtpdtype.h"

#include "rtpdmx.h"
#include "rtpdinpp.h"
#include "rtpdoutp.h"

#include "rtpdprop.h"
#include "amrtpuid.h"

EXTERN_C const CLSID CLSID_IntelRTPDemuxPropertyPage;

CUnknown * WINAPI 
CRTPDemuxPropertyPage::CreateInstance( 
    LPUNKNOWN punk, 
    HRESULT *phr )
{
    CRTPDemuxPropertyPage *pNewObject
        = new CRTPDemuxPropertyPage( punk, phr);

    if( pNewObject == NULL )
        *phr = E_OUTOFMEMORY;

    return pNewObject;
} /* CRTPDemuxPropertyPage::CreateInstance() */


CRTPDemuxPropertyPage::CRTPDemuxPropertyPage( 
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBasePropertyPage(NAME("RTP Demux Filter Property Page"),pUnk,
        IDD_RTPDEMUXPROP, IDS_RTPDEMUX_TITLE)
    , m_pIRTPDemux (NULL)
    , m_bIsInitialized(FALSE)
    , m_dwPinCount(0)

{
    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxPropertyPage::CRTPDemuxPropertyPage: Constructed at 0x%08x"), this));
} /* CRTPDemuxPropertyPage::CRTPDemuxPropertyPage() */


void 
CRTPDemuxPropertyPage::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }
} /* CRTPDemuxPropertyPage::SetDirty() */


INT_PTR 
CRTPDemuxPropertyPage::OnReceiveMessage(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg) {
//    case WM_INITDIALOG:
//        return OnInitDialog();
//        break;

    case WM_COMMAND:
        if (m_bIsInitialized) {
            if (OnCommand( (int) LOWORD( wParam ), (int) HIWORD( wParam ), lParam ) == TRUE) {
                return (LRESULT) 1 ;
            } /* if */
        } else {
            return CRTPDemuxPropertyPage::OnInitDialog();
        } /* if */
        break;
    } /* switch */

    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
} /* CRTPDemuxPropertyPage::OnReceiveMessage() */


/*F*
//  Name    : CRTPDemuxPropertyPage::OnConnect()
//  Purpose : Used to setup data structures that are necessary
//            for the life of the property page.
//  Context : Called when the property page springs to life. 
//  Returns : HRESULT indicating success or failure.
//  Params  :
//      pUnknown    IUnknown pointer to the filter object we are
//                  a property page for. Used to acquire other 
//                  interfaces on the filter.
//  Notes   : None.
*F*/
HRESULT 
CRTPDemuxPropertyPage::OnConnect(
    IUnknown    *pUnknown)
{
    ASSERT(m_pIRTPDemux == NULL);
    ASSERT(m_mPinList.size() == 0);
    ASSERT(m_mSSRCInfo.size() == 0);
    DbgLog((LOG_TRACE, 2, TEXT("CRTPDemuxPropertyPage::OnConnect: Called with IUnknown 0x%08x"), pUnknown));

	HRESULT hr = pUnknown->QueryInterface(IID_IRTPDemuxFilter,
					  (void **) &m_pIRTPDemux);
	if(FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, TEXT("CRTPDemuxPropertyPage::OnConnect: Error 0x%08x getting IRTPDemuxFilter interface!"), hr));
	    return hr;
    } /* if */
	ASSERT( m_pIRTPDemux != NULL );
    m_bIsInitialized = FALSE;
    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxPropertyPage::OnConnect: Got IRTPDemuxFilter interface at 0x%08x"), m_pIRTPDemux));

    hr = LoadSSRCs();
    if (FAILED(hr)) {
        m_pIRTPDemux->Release();
        return hr;
    } /* if */

    hr = LoadPins();
    if (FAILED(hr)) {
        m_pIRTPDemux->Release();
        return hr;
    } /* if */

    return S_OK;
} /* CRTPDemuxPropertyPage::OnConnect() */


/*F*
//  Name    : CRTPDemuxPropertyPage::LoadSubtypes()
//  Purpose : Read the registry for what subtypes are currently
//            setup to use for our output pin media type. 
//            Display the subtypes in a listbox window and store a
//            record of each in a hidden data structure in the
//            item of the listbox it appears as.
//  Context : Called by OnActivate() as a helper function.
//  Returns : HRESULT indicating success or failure.
//  Params  : None.
//  Notes   : None.
*F*/
HRESULT
CRTPDemuxPropertyPage::LoadSubtypes(void)
{
	DbgLog((LOG_TRACE, 4, TEXT("CRTPDemuxPropertyPage::LoadSubtypes: Entered")));

    HWND hCurrentListbox;
    hCurrentListbox = GetDlgItem(m_hwnd, IDC_SUBTYPELIST);

    long    lRes;
    HKEY    hKey;
    DWORD   dwTypekeys, dwTypeNameLen, dwIndex, dwBufLen, dwData;
    // open the key
    lRes = RegOpenKeyEx (HKEY_LOCAL_MACHINE, szRegAMRTPKey, 0, KEY_READ, &hKey);
    if (lRes != ERROR_SUCCESS) {
    	DbgLog((LOG_ERROR, 3, 
                TEXT("CRTPDemuxPropertyPage::LoadSubtypes: Error 0x%08x calling RegOpenKeyEx!"), lRes));
        return E_FAIL;
    } /* if */

    lRes = RegQueryInfoKey(hKey, NULL, NULL, NULL, &dwTypekeys, &dwTypeNameLen,
                           NULL, NULL, NULL, NULL, NULL, NULL);
    if (lRes != ERROR_SUCCESS) {
    	DbgLog((LOG_ERROR, 3, 
                TEXT("CRTPDemuxPropertyPage::LoadSubtypes: Error 0x%08x calling RegQueryInfoKey!"), lRes));
        return E_FAIL;
    } /* if */

    TCHAR   tchTypeBuf[128];
    HKEY    hTypeKey;
    BYTE    lpValBuf[128];
    DWORD   dwValLen;
    wchar_t wcCLSID[40];
    int iCurrentItem;
    GUID    gSubtype;
    IPinRecord_t *pTempRecord;
    // Retrieve Registry values for the Media Types
    for (dwIndex = 0; dwIndex < dwTypekeys; dwIndex++) {
        dwBufLen = 128; // dwTypeNameLen;
        lRes = RegEnumKeyEx(hKey, dwIndex, tchTypeBuf, &dwBufLen, NULL, NULL, NULL, NULL);
	if (lRes == ERROR_SUCCESS) {
            lRes = RegOpenKeyEx (hKey, tchTypeBuf, 0, KEY_READ, &hTypeKey);
            if (lRes == ERROR_SUCCESS) {
                pTempRecord = new IPinRecord_t;
                mbstowcs(wcCLSID, tchTypeBuf, 40);
                CLSIDFromString(wcCLSID, &gSubtype);
                pTempRecord->mtsSubtype = gSubtype;

                dwValLen = 128;
                lRes = RegQueryValueEx(hTypeKey, "PayloadType", NULL, &dwData, lpValBuf, &dwValLen);
	        if (lRes == ERROR_SUCCESS) {
                    pTempRecord->bPT = (BYTE)*(reinterpret_cast<DWORD *>(&lpValBuf[0]));

                    dwValLen = 128;
                    lRes = RegQueryValueEx(hTypeKey, "Abbreviated Description", NULL, &dwData, lpValBuf, &dwValLen);
                    iCurrentItem = ListBox_AddString(hCurrentListbox, lpValBuf);
                    ListBox_SetItemData(hCurrentListbox, iCurrentItem, pTempRecord);
        	} /* if */
	    } /* if */
	} /* if */
        RegCloseKey(hTypeKey);
    } /* for */

    // Add a null entry.
    iCurrentItem = ListBox_AddString(hCurrentListbox, "(NULL)");
    pTempRecord = new IPinRecord_t;
    pTempRecord->mtsSubtype = MEDIASUBTYPE_NULL;
    pTempRecord->bPT = PAYLOAD_INVALID;
    ListBox_SetItemData(hCurrentListbox, iCurrentItem, pTempRecord);

    RegCloseKey(hKey);

    return NOERROR;
} /* CRTPDemuxPropertyPage::LoadSubtypes() */


/*F*
//  Name    : CRTPDemuxPropertyPage::LoadSSRCs()
//  Purpose : Interrogate the RTPDemux filter as to what SSRCs it has seen.
//            Store the SSRCs in a data structure used to display & track them.
//  Context : Called by OnConnect() as a helper function.
//  Returns : HRESULT indicating success or failure.
//  Params  : None.
//  Notes   : None.
*F*/
HRESULT
CRTPDemuxPropertyPage::LoadSSRCs(void)
{
    HRESULT hr;
    IEnumSSRCs *pISSRCEnum;

    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxPropertyPage::LoadSSRCs: Loading SSRCs for filter 0x%08x."), 
            m_pIRTPDemux));
    hr = m_pIRTPDemux->QueryInterface(IID_IEnumSSRCs,
                                      reinterpret_cast<PVOID *>(&pISSRCEnum));
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, TEXT("CRTPDemuxPropertyPage::LoadSSRCs: Error 0x%08x getting SSRC Enumerator!"), hr));
        return hr;
    } /* if */

    BOOL bFinished = FALSE;
    ULONG uSSRCsFetched = 1;
    DWORD dwCurrentSSRC;
    while (bFinished == FALSE) {
        hr = pISSRCEnum->Reset();
        ASSERT(SUCCEEDED(hr));
        while ((hr != VFW_E_ENUM_OUT_OF_SYNC) && (uSSRCsFetched > 0)) {
            hr = pISSRCEnum->Next(1, &dwCurrentSSRC, &uSSRCsFetched);
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR, 3, TEXT("CRTPDemuxPropertyPage::LoadSSRCs: SSRC Enumerator out of sync. Restarting load!")));
                ASSERT(hr == VFW_E_ENUM_OUT_OF_SYNC);
            } else if (uSSRCsFetched == 0) {
                DbgLog((LOG_TRACE, 4, TEXT("CRTPDemuxPropertyPage::LoadSSRCs: Finished loading SSRCs.")));
                bFinished = TRUE; // Exit these loops.
            } else {
                DbgLog((LOG_TRACE, 5, TEXT("CRTPDemuxPropertyPage::LoadSSRCs: Detected SSRC 0x%08x."), dwCurrentSSRC));
                SSRCRecord_t sSSRCRecord;
                IPin *pIOutputPin;
                hr = m_pIRTPDemux->GetSSRCInfo(dwCurrentSSRC, &sSSRCRecord.bPT, &pIOutputPin);
                ASSERT(hr == NOERROR); // This SSRC better be good or the enumerator is buggy.
                sSSRCRecord.pPin = static_cast<CRTPDemuxOutputPin *>(NULL);
                m_mSSRCInfo[dwCurrentSSRC] = sSSRCRecord;
            } /* if */
        } /* while */
        if (hr == VFW_E_ENUM_OUT_OF_SYNC) {
            // Erase all the SSRC records and start gathering them again.
            m_mSSRCInfo.erase(m_mSSRCInfo.begin(), m_mSSRCInfo.end());
        } /* if */
    } /* while */

    ASSERT(SUCCEEDED(hr));
    pISSRCEnum->Release();
    DbgLog((LOG_TRACE, 4, TEXT("CRTPDemuxPropertyPage::LoadSSRCs: Successfully loaded SSRCs for filter 0x%08x."), 
            m_pIRTPDemux));
    return NOERROR;
} /* CRTPDemuxPropertyPage::LoadSSRCs() */


HRESULT
CRTPDemuxPropertyPage::LoadPins(void)
{
    DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxPropertyPage::LoadPins: Loading pins for filter 0x%08x."), 
            m_pIRTPDemux));

    // Get an IFilter interface for this filter.
    HRESULT hr;
    IBaseFilter *pIFilter;
    hr = m_pIRTPDemux->QueryInterface(IID_IBaseFilter, 
                                      reinterpret_cast<PVOID *>(&pIFilter));
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, TEXT("CRTPDemuxPropertyPage::LoadPins: Error 0x%08x querying for IFilter interface!"), 
                hr));
        return hr;
    } /* if */

    // Get a pin enumerator for this filter.
    IEnumPins *pIEnumPins;
    hr = pIFilter->EnumPins(&pIEnumPins);
    pIFilter->Release(); // Don't need the IFilter any more after this point.
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, TEXT("CRTPDemuxPropertyPage::LoadPins: Error 0x%08x getting pin enumerator interface!"), 
                hr));
        return hr;
    } /* if */

    BOOL bFinished = FALSE;
    ULONG uPinsFetched = 1;
    IPin *pICurrentPin;
    while (bFinished == FALSE) {
        hr = pIEnumPins->Reset();
        ASSERT(SUCCEEDED(hr));
        hr = pIEnumPins->Skip(1);
        ASSERT(SUCCEEDED(hr));
        while ((hr != VFW_E_ENUM_OUT_OF_SYNC) && (uPinsFetched > 0)) {
            hr = pIEnumPins->Next(1, &pICurrentPin, &uPinsFetched);
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR, 3, TEXT("CRTPDemuxPropertyPage::LoadPins: Pin enumerator out of sync. Restarting load!")));
                ASSERT(hr == VFW_E_ENUM_OUT_OF_SYNC);
            } else if (uPinsFetched == 0) {
                DbgLog((LOG_TRACE, 4, TEXT("CRTPDemuxPropertyPage::LoadPins: Finished loading pins.")));
                bFinished = TRUE; // Exit these loops.
            } else {
                DbgLog((LOG_TRACE, 5, TEXT("CRTPDemuxPropertyPage::LoadPins: Detected pin 0x%08x."), 
                        pICurrentPin));
                pICurrentPin->Release();
                IPinRecord_t sTempRecord;
                DWORD dwTempSSRC;
                HRESULT hErr = m_pIRTPDemux->GetPinInfo(pICurrentPin, 
                                                        &dwTempSSRC, &sTempRecord.bPT,
                                                        &sTempRecord.bAutoMapping,
                                                        &sTempRecord.dwTimeout);
                if (FAILED(hErr)) {
                    DbgLog((LOG_ERROR, 3, TEXT("CRTPDemuxPropertyPage::LoadPins: Error 0x%08x loading pin 0x%08x. Aborting apply!"),
                            hErr, pICurrentPin));
                    pIEnumPins->Release();
                    return hr;
                } /* if */
                // These two fields aren't filled in by GetPinInfo().
                sTempRecord.pPin = static_cast<CRTPDemuxOutputPin *>(NULL);
                LoadPinSubtype(pICurrentPin, &sTempRecord.mtsSubtype);
                
                m_mPinList[pICurrentPin] = sTempRecord;
            } /* if */
        } /* while */
        if (hr == VFW_E_ENUM_OUT_OF_SYNC) {
            // Erase all the SSRC records and start gathering them again.
            m_mPinList.erase(m_mPinList.begin(), m_mPinList.end());
        } /* if */
    } /* while */

    ASSERT(SUCCEEDED(hr));
    pIEnumPins->Release();
    DbgLog((LOG_TRACE, 4, TEXT("CRTPDemuxPropertyPage::LoadPins: Successfully loaded pins for filter 0x%08x."), 
            m_pIRTPDemux));
    return NOERROR;
} /* CRTPDemuxPropertyPage::LoadPins() */


/*F*
//  Name    : CRTPDemuxPropertyPage::LoadPinSubtype()
//  Purpose : Load the subtype that this pin exposes.
//  Context : Called as part of LoadPins().
//  Returns : Nothing.
//  Params  :
//      pICurrentPin    Pointer to the pin to get the media type for.
//      gSubtype        Pointer to where to write the GUID for the subtype.
//  Notes   : None.
*F*/
void
CRTPDemuxPropertyPage::LoadPinSubtype(
    IPin    *pICurrentPin, 
    GUID    *gSubtype)
{
    HRESULT hr;
    IEnumMediaTypes *pIMTEnum;
    hr = pICurrentPin->EnumMediaTypes(&pIMTEnum);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRTPDemuxPropertyPage::LoadPinSubtype: Error 0x%08x loading MT enumerator for pin 0x%08x!"), 
                hr, pICurrentPin));
        *gSubtype = MEDIASUBTYPE_NULL;
        return;
    } /* if */

    AM_MEDIA_TYPE *sAMT;
    ULONG uFetched;
    hr = pIMTEnum->Next(1, &sAMT, &uFetched);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, 
                TEXT("CRTPDemuxPropertyPage::LoadPinSubtype: Error 0x%08x loading first media type for pin 0x%08x!"), 
                hr, pICurrentPin));
        *gSubtype = MEDIASUBTYPE_NULL;
        pIMTEnum->Release();
        return;
    } /* if */

    pIMTEnum->Release();
    *gSubtype = sAMT->subtype;
    return;
} /* CRTPDemuxPropertyPage::LoadPinSubtype() */


HRESULT 
CRTPDemuxPropertyPage::OnDisconnect(void)
{
    m_mPinList.erase(m_mPinList.begin(), m_mPinList.end());
    m_mSSRCInfo.erase(m_mSSRCInfo.begin(), m_mSSRCInfo.end());

    if (m_pIRTPDemux == NULL)
    {
        return E_UNEXPECTED;
    }

    // Release the filter.
	m_pIRTPDemux->Release();
	m_pIRTPDemux = NULL;

    return S_OK;
} /* CRTPDemuxPropertyPage::OnDisconnect() */

//////////////////////////////////////////////////////////////
// moved out of OnActivate by ZCS 7-14-97 to allow it to also
// be called separately for the map and unmap buttons

void
CRTPDemuxPropertyPage::RedisplaySSRCList(void)
{
    TCHAR tchTempString[11]; 
    HWND hCurrentListbox;
    int iCurrentItem;

    // Add all the SSRCs to our list.
    SSRCRecordMapIterator_t iSSRCMap = m_mSSRCInfo.begin();
    hCurrentListbox = GetDlgItem(m_hwnd, IDC_SSRCLIST);
    ASSERT(hCurrentListbox != NULL);
    while (iSSRCMap != m_mSSRCInfo.end()) {
        wsprintf(tchTempString, "0x%08x", (*iSSRCMap).first);
        iCurrentItem = ListBox_AddString(hCurrentListbox, tchTempString); 
        ListBox_SetItemData(hCurrentListbox, iCurrentItem, (*iSSRCMap).first);
        iSSRCMap++;
    } /* while */
}

HRESULT 
CRTPDemuxPropertyPage::OnActivate(void)
{
    HRESULT hr;
    if (m_bIsInitialized == FALSE) {
        // Only load the subtypes once.
        hr = LoadSubtypes();
        if (FAILED(hr)) {
            // Don't release, because the base class that calls us
            // doesn't care what we return. Thus, it will we will
            // end up releasing the filter interface later when the
            // property page goes away.
//            m_pIRTPDemux->Release();
            return hr;
        } /* if */
    } /* if */

    // Remember this so we only do certain OnActive() duties once.
    m_bIsInitialized = TRUE;

    TCHAR tchTempString[11]; 
    HWND hCurrentListbox;
    LRESULT lMessageResult;
    int iCurrentItem;

	// see above -- this updates the SSRC list in the UI
	RedisplaySSRCList();

    // Add all the IPins to our list.
    IPinRecordMapIterator_t iPinList = m_mPinList.begin();
    hCurrentListbox = GetDlgItem(m_hwnd, IDC_PINLIST);
    ASSERT(hCurrentListbox != NULL);
    while (iPinList != m_mPinList.end()) {
        LPWSTR pPinName;
        HRESULT hErr = (*iPinList).first->QueryId(&pPinName);
        ASSERT(SUCCEEDED(hErr)); // QueryId should always succeed on a valid pin.
        int iPinDisplayNumber = _wtoi(pPinName);
        CoTaskMemFree(pPinName);
        iPinDisplayNumber--; 

        // If this pin is connected, put an asterisk before its name.
        IPin *pConnectedPin = static_cast<IPin *>(NULL);
        hErr = (*iPinList).first->ConnectedTo(&pConnectedPin);
        if (SUCCEEDED(hErr)) {
            if (pConnectedPin != static_cast<IPin *>(NULL)) {
                // If connected, check the box.
                wsprintf(tchTempString, "*Output%d", iPinDisplayNumber);
                pConnectedPin->Release();
            } else {
                wsprintf(tchTempString, "Output%d", iPinDisplayNumber);
            } /* if */
        } else {
            // If the ConnectedTo() fails, assume the pin is not connected.
            wsprintf(tchTempString, "Output%d", iPinDisplayNumber);
        } /* if */

        // Display names for output pins are zero based, while
        // the actual pin ID is zero based starting on the input pin. So we munge
        // the number a little and prepent "Output" so it looks the same as in the
        // graph editor.
        iCurrentItem = ListBox_AddString(hCurrentListbox, tchTempString);
        ListBox_SetItemData(hCurrentListbox, iCurrentItem, (*iPinList).first);
        iPinList++;
    } /* if */

    m_dwPinCount = m_mPinList.size();
    SetDlgItemInt(m_Dlg, IDC_PINCOUNT, m_dwPinCount, FALSE);
	
	// ZCS 7-14-97: If we are playing, gray out the pincount box.
	FILTER_STATE fsState;
	hr = ((CRTPDemux *) m_pIRTPDemux)->GetState(0, &fsState);
	if (FAILED(hr)) return hr;

	if (fsState == State_Stopped)
		EnableWindow(GetDlgItem(m_hwnd, IDC_PINCOUNT), TRUE);
	else
		EnableWindow(GetDlgItem(m_hwnd, IDC_PINCOUNT), FALSE);

    // Highlight the first pin. Don't highlight a SSRC, because
    // that would imply that the SSRC and pin are mapped to each other.
    ListBox_SetCurSel(GetDlgItem(m_hwnd, IDC_PINLIST), 0);
    // Sending this message will cause all the pin info to
    // be properly displayed, including highlighting a mapped SSRC
    // if necessary.
    lMessageResult = SendMessage(m_hwnd, WM_COMMAND, MAKEWPARAM(IDC_PINLIST, LBN_SELCHANGE), 
                                 reinterpret_cast<LPARAM>(GetDlgItem(m_hwnd, IDC_PINLIST)));
    SetFocus(GetDlgItem(m_hwnd, IDC_PINLIST));

    return NOERROR;
} /* CRTPDemuxPropertyPage::OnActivate() */


BOOL 
CRTPDemuxPropertyPage::OnInitDialog(void)
{
//    InitCommonControls();

//    m_pIBaseVideoMixer->IsUsingClock  ( &bUsingClock  );    // Are we using a clock?
//    m_pIBaseVideoMixer->GetClockPeriod( &iClockPeriod );    // what is its period?
//    m_pIBaseVideoMixer->GetLeadPin    ( &iLeadPin     );    // if not, which pin leads?
/*
    CheckRadioButton( m_Dlg
                      , IDC_USE_LEAD_PIN
                      , IDC_USE_CLOCK
                      , bUsingClock? IDC_USE_CLOCK : IDC_USE_LEAD_PIN
                    );

    // disable clock period edit control if using lead pin,
    // disable lead pin number edit control if using clock
    EnableWindow( GetDlgItem( m_Dlg, IDC_LEAD_PIN          ), !bUsingClock );
    EnableWindow( GetDlgItem( m_Dlg, IDC_CLOCK_PERIOD      ),  bUsingClock );
    EnableWindow( GetDlgItem( m_Dlg, IDC_CLOCK_PERIOD_TEXT ),  bUsingClock );

    // set the text
    SetDlgItemInt( m_Dlg, IDC_CLOCK_PERIOD, (UINT) iClockPeriod, TRUE );
    SetDlgItemInt( m_Dlg, IDC_LEAD_PIN,     (UINT) iLeadPin    , TRUE );
*/
    return (LRESULT) 1;
} /* CRTPDemuxPropertyPage::OnInitDialog() */


BOOL 
CRTPDemuxPropertyPage::OnCommand( 
    int     iButton,     // lo word
    int     iNotify,     // hi word
    LPARAM  lParam)      // lparam
{
    HWND hCurrentListbox;

    IPin *pIPin;
    int iItem;
    IPinRecord_t *pIPinRecord;
    BOOL bPayloadChosen = FALSE;
    BYTE bPayloadValue;
    GUID gPayloadSubtype;
    BOOL bModeChosen = FALSE;
    BOOL bModeValue;
    BOOL bTimeoutChosen = FALSE;
    DWORD dwTimeoutValue;
    BOOL bPinCountChosen = FALSE;
    DWORD dwPinCountValue;
    BOOL bPTValueChosen = FALSE;
    DWORD dwPTValue;
    DWORD dwSSRC;
    SSRCRecordMapIterator_t iSSRCMap;
    HWND hMapButton;
    HRESULT hErr;
    switch( iButton ){
    case IDC_SSRCLIST:
        hMapButton = GetDlgItem(m_hwnd, IDC_MAP);
        switch(iNotify) {
        case LBN_SELCHANGE:
            hCurrentListbox = GetDlgItem(m_hwnd, IDC_SSRCLIST);
            ASSERT(hCurrentListbox != NULL);
            iItem = ListBox_GetCurSel(reinterpret_cast<HWND>(lParam)); 
            dwSSRC = (DWORD)ListBox_GetItemData(hCurrentListbox, iItem);
            iSSRCMap = m_mSSRCInfo.find(dwSSRC);
            ASSERT(iSSRCMap != m_mSSRCInfo.end());
            SetDlgItemInt(m_Dlg, IDC_PT, (*iSSRCMap).second.bPT, FALSE);
            Button_Enable(hMapButton, TRUE);
            break;
        default:
            break;
        } /* switch */
        break;
    case IDC_PINLIST:
        switch(iNotify) {
        case LBN_SELCHANGE:
            hCurrentListbox = GetDlgItem(m_Dlg, IDC_PINLIST);
            iItem = ListBox_GetCurSel(reinterpret_cast<HWND>(lParam)); 
            pIPin = reinterpret_cast<IPin *>(ListBox_GetItemData(hCurrentListbox, iItem));
            ShowPinInfo(pIPin);
            return (LRESULT) 1;
            break;
        default:
            break;
        } /* switch */
        break;
    case IDC_SUBTYPELIST:
        switch(iNotify) {
        case LBN_SELCHANGE:
            hCurrentListbox = GetDlgItem(m_Dlg, IDC_SUBTYPELIST);
            iItem = ListBox_GetCurSel(reinterpret_cast<HWND>(lParam)); 
            pIPinRecord = reinterpret_cast<IPinRecord_t *>(ListBox_GetItemData(hCurrentListbox, iItem));
            if (pIPinRecord->bPT == PAYLOAD_INVALID) {
                SetDlgItemText(m_Dlg, IDC_PTVALUE, "??");
            } else {
                SetDlgItemInt(m_Dlg, IDC_PTVALUE, pIPinRecord->bPT, FALSE);
            } /* if */
            bPayloadValue = pIPinRecord->bPT;
            gPayloadSubtype = pIPinRecord->mtsSubtype;
            bPayloadChosen = TRUE;
            break;
        default:
            break;
        } /* switch */
        break;
    case IDC_MODEMANUAL:
        bModeValue = FALSE;
        bModeChosen = TRUE;
        break;
    case IDC_MODEAUTO:
        bModeValue = TRUE;
        bModeChosen = TRUE;
        break;
    case IDC_TIMEOUT:
        BOOL bTimeoutScanned;
        dwTimeoutValue = GetDlgItemInt(m_Dlg, IDC_TIMEOUT, &bTimeoutScanned, FALSE); // FALSE => unsigned
        ASSERT(bTimeoutScanned == TRUE); // FIX - too restrictive?
        bTimeoutChosen = TRUE;
        break;
    case IDC_PINCOUNT:
        BOOL bCountScanned;
        dwPinCountValue = GetDlgItemInt(m_Dlg, IDC_PINCOUNT, &bCountScanned, FALSE); // FALSE => unsigned
        if (bCountScanned == TRUE) {
            bPinCountChosen = TRUE;
        } else {
            bPinCountChosen = FALSE;
        } /* if */
        break;
    case IDC_PTVALUE:
        BOOL bPTScanned;
        dwPTValue = GetDlgItemInt(m_Dlg, IDC_PTVALUE, &bPTScanned, FALSE); // FALSE => unsigned
        if (bPTScanned == TRUE) {
            bPTValueChosen = TRUE;
        } else {
            bPTValueChosen = FALSE;
        } /* if */
        break;
    case IDC_MAP:
        hCurrentListbox = GetDlgItem(m_Dlg, IDC_SSRCLIST);
        iItem = ListBox_GetCurSel(hCurrentListbox);
        dwSSRC = (DWORD)ListBox_GetItemData(hCurrentListbox, iItem);
        hCurrentListbox = GetDlgItem(m_Dlg, IDC_PINLIST);
        iItem = ListBox_GetCurSel(hCurrentListbox);
        pIPin = reinterpret_cast<IPin *>(ListBox_GetItemData(hCurrentListbox, iItem));
        hErr = m_pIRTPDemux->MapSSRCToPin(dwSSRC, pIPin);
		// ZCS bugfix 7-14-97:
        // we no longer call OnApplyChanges() here because we don't want to update
		// everything... just the SSRC list. The following does it quite nicely:
		ListBox_ResetContent(GetDlgItem(m_hwnd, IDC_SSRCLIST));
	    RedisplaySSRCList();
        return 1;
        break;
    case IDC_UNMAP:
		// ZCS bugfix 7-14-97: This button was not implemented.
        hCurrentListbox = GetDlgItem(m_Dlg, IDC_PINLIST);
        iItem = ListBox_GetCurSel(hCurrentListbox);
        pIPin = reinterpret_cast<IPin *>(ListBox_GetItemData(hCurrentListbox, iItem));
        hErr = m_pIRTPDemux->UnmapPin(pIPin, &dwSSRC);
        // we don't call OnApplyChanges() here because we don't want to update
		// everything... just the SSRC list. The following does it quite nicely:
		ListBox_ResetContent(GetDlgItem(m_hwnd, IDC_SSRCLIST));
	    RedisplaySSRCList();
        return 1;
        break;
    default:
        break;
    } /* switch */

    if (bPayloadChosen == TRUE) {
        SetDirty();
        hCurrentListbox = GetDlgItem(m_Dlg, IDC_PINLIST);
        int iItem = ListBox_GetCurSel(hCurrentListbox); 
        pIPin = reinterpret_cast<IPin *>(ListBox_GetItemData(hCurrentListbox, iItem));
        IPinRecordMapIterator_t iPinRecord = m_mPinList.find(pIPin);
        ASSERT(iPinRecord != m_mPinList.end());
        DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxPropertyPage::OnCommand: Detected user selecting payload 0x%02x for pin 0x%08x. Recording in pin change record map"),
                bPayloadValue, pIPin));
        (*iPinRecord).second.bPT = bPayloadValue;
        (*iPinRecord).second.mtsSubtype = gPayloadSubtype;
    } else if (bModeChosen == TRUE) {
        SetDirty();
        hCurrentListbox = GetDlgItem(m_Dlg, IDC_PINLIST);
        int iItem = ListBox_GetCurSel(hCurrentListbox); 
        pIPin = reinterpret_cast<IPin *>(ListBox_GetItemData(hCurrentListbox, iItem));
        IPinRecordMapIterator_t iPinRecord = m_mPinList.find(pIPin);
        ASSERT(iPinRecord != m_mPinList.end());
        DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxPropertyPage::OnCommand: Detected user changing automapping mode to %s for pin 0x%08x. Recording in pin change record map"),
                bModeValue == TRUE ? "TRUE" : "FALSE", pIPin));
        (*iPinRecord).second.bAutoMapping = bModeValue;
    } else if (bTimeoutChosen == TRUE) {
        SetDirty();
        hCurrentListbox = GetDlgItem(m_Dlg, IDC_PINLIST);
        int iItem = ListBox_GetCurSel(hCurrentListbox); 
        pIPin = reinterpret_cast<IPin *>(ListBox_GetItemData(hCurrentListbox, iItem));
        IPinRecordMapIterator_t iPinRecord = m_mPinList.find(pIPin);
        ASSERT(iPinRecord != m_mPinList.end());
        DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxPropertyPage::OnCommand: Detected user changing time to %d for pin 0x%08x. Recording in pin change record map"),
                dwTimeoutValue, pIPin));
        (*iPinRecord).second.dwTimeout = dwTimeoutValue;
    } else if (bPinCountChosen == TRUE) {
        SetDirty();
        m_dwPinCount = dwPinCountValue;
    } else if (bPTValueChosen == TRUE) {
        SetDirty();
        hCurrentListbox = GetDlgItem(m_Dlg, IDC_PINLIST);
        int iItem = ListBox_GetCurSel(hCurrentListbox); 
        pIPin = reinterpret_cast<IPin *>(ListBox_GetItemData(hCurrentListbox, iItem));
        IPinRecordMapIterator_t iPinRecord = m_mPinList.find(pIPin);
        ASSERT(iPinRecord != m_mPinList.end());
        DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxPropertyPage::OnCommand: Detected user changing PT value to %d for pin 0x%08x. Recording in pin change record map"),
                dwPTValue, pIPin));
        (*iPinRecord).second.bPT = (BYTE)dwPTValue;
    } /* if */

    return (LRESULT) 1;
} /* CRTPDemuxPropertyPage::OnCommand() */


/*F*
//  Name    : CRTPDemuxPropertyPage::ShowPinInfo()
//  Purpose : Display correct property page info for a particular pin.
//  Context : Called as a helper function by OnCommand().
//  Returns : Nothing.
//  Params  : 
//      pIPin   IPin pointer for the pin we are showind the info for.
//  Notes   : None.
*F*/
void
CRTPDemuxPropertyPage::ShowPinInfo(
    IPin *pIPin)
{
    ASSERT(m_pIRTPDemux);
    // Find the pin record.
    IPinRecordMapIterator_t iPinRecord = m_mPinList.find(pIPin);
    ASSERT(iPinRecord != m_mPinList.end());

    // Next, show the mode of this pin.
    if ((*iPinRecord).second.bAutoMapping == TRUE) {
        CheckRadioButton(m_hwnd, IDC_MODEAUTO, IDC_MODEMANUAL, IDC_MODEAUTO);
    } else {
        CheckRadioButton(m_hwnd, IDC_MODEAUTO, IDC_MODEMANUAL, IDC_MODEMANUAL);
    } /* if */

    // Show the media subtype and PT value for this pin.
    ShowPinSubtype(iPinRecord);

    // Show the SSRC for this pin.
    ShowSSRCInfo(iPinRecord);

    // Finally, show the timeout value.
    SetDlgItemInt(m_Dlg, IDC_TIMEOUT, (*iPinRecord).second.dwTimeout, FALSE);
} /* CRTPDemuxPropertyPage::ShowPinInfo() */


/*F*
//  Name    : CRTPDemuxPropertyPage::ShowPinSubtype()
//  Purpose : Display the correct subtype and PT value info
//            for a pin that is selected.
//  Context : Called as part of ShowPinInfo().
//  Returns : Nothing.
//  Params  : 
//      pIPin   IPin pointer for the pin we are showind the info for.
//  Notes   : None.
*F*/
void
CRTPDemuxPropertyPage::ShowPinSubtype(
    IPinRecordMapIterator_t iPinRecord)
{
    HWND hCurrentListbox;
    // Get the subtype list.
    hCurrentListbox = GetDlgItem(m_hwnd, IDC_SUBTYPELIST);
    // See how many subtypes we know about.
    int iRegistryTypes = ListBox_GetCount(hCurrentListbox);
    IPinRecord_t *pTempRecord;
    // Compare the subtypes against the type that this pin exposes.
    // If there is one that matches, select that entry in the subtype listbox.
    for (int iEntry = 0; iEntry < iRegistryTypes; iEntry++) {
        pTempRecord = reinterpret_cast<IPinRecord_t *>(ListBox_GetItemData(hCurrentListbox, iEntry));
        if (pTempRecord->mtsSubtype == (*iPinRecord).second.mtsSubtype) {
            ListBox_SetCurSel(hCurrentListbox, iEntry);
        } /* if */
    } /* for */

    // Finally, if the subtype and PT are both unknown, 
    // create a new entry in the listbox here. The exception
    // is if the PT is invalid. This means that the pin
    // has not had its PT set, so we should choose the NULL entry.
    if ((*iPinRecord).second.bPT == PAYLOAD_INVALID) {
        SetDlgItemText(m_Dlg, IDC_PTVALUE, "??");
    } else {
        SetDlgItemInt(m_Dlg, IDC_PTVALUE, (*iPinRecord).second.bPT, FALSE);
    } /* if */
} /* CRTPDemuxPropertyPage::ShowPinSubtype() */


/*F*
//  Name    : CRTPDemuxPropertyPage::ShowSSRCInfo()
//  Purpose : 
//  Context : 
//  Returns : Nothing.
//  Params  : 
//  Notes   : None.
*F*/
void
CRTPDemuxPropertyPage::ShowSSRCInfo(
    IPinRecordMapIterator_t iPinRecord)
{
    HWND hCurrentListbox;
    // Get the subtype list.
    hCurrentListbox = GetDlgItem(m_hwnd, IDC_SSRCLIST);
    // See how many SSRCs we know about.
    int iSSRCCount = ListBox_GetCount(hCurrentListbox);
    DWORD dwTempSSRC;
    DWORD dwPinSSRC;
    BYTE bTempPT;       // These three are just to satisfy GetPinInfo().
    BOOL bAutomapping;  // These three are just to satisfy GetPinInfo().
    DWORD dwTimeout;    // These three are just to satisfy GetPinInfo().
    HRESULT hErr = m_pIRTPDemux->GetPinInfo((*iPinRecord).first, 
                                            &dwPinSSRC, &bTempPT, &bAutomapping, &dwTimeout);
    ASSERT(SUCCEEDED(hErr)); // Should always be a valid pin!

    // Turn off any current selection, so that if nothing is
    // mapped to this pin then no SSRC will be selected.
    ListBox_SetCurSel(hCurrentListbox, -1);

    // Find the map/unmap buttons and turn off the unmap button
    // since we are switching pins.
    HWND hUnmapButton = GetDlgItem(m_hwnd, IDC_UNMAP);
    HWND hMapButton = GetDlgItem(m_hwnd, IDC_MAP);
    Button_Enable(hUnmapButton, FALSE);

    // Compare the subtypes against the type that this pin exposes.
    // If there is one that matches, select that entry in the subtype listbox.
    for (int iEntry = 0; iEntry < iSSRCCount; iEntry++) {
        dwTempSSRC = (DWORD)ListBox_GetItemData(hCurrentListbox, iEntry);
        if (dwPinSSRC == dwTempSSRC) {
            ListBox_SetCurSel(hCurrentListbox, iEntry);
            Button_Enable(hUnmapButton, TRUE); // Allow the matched SSRC to be unmapped.
            Button_Enable(hMapButton, FALSE);
        } /* if */
    } /* for */
} /* CRTPDemuxPropertyPage::ShowSSRCInfo() */


HRESULT 
CRTPDemuxPropertyPage::OnApplyChanges(void)
{
    ASSERT(m_pIRTPDemux != NULL);

    IPin    *pIPin;
    BYTE    bPayload;
    GUID    gSubtype;
    DWORD   dwTimeout;
    BOOL    bAutoMapping;
    HRESULT hErr;
	int     iDelta = 0; // ZCS -- number of pins to skip if the user DECREASED the pin count

    if (m_dwPinCount != m_mPinList.size()) {
        DbgLog((LOG_TRACE, 3, TEXT("CRTPDemuxPropertyPage::OnApplyChanges: Pin count changed from %d to %d. Applying change"),
                m_mPinList.size(), m_dwPinCount));

        // ZCS -- remember how much it changed if it went down.
		if (m_dwPinCount < m_mPinList.size())
			iDelta = m_mPinList.size() - m_dwPinCount;
				
		hErr = m_pIRTPDemux->SetPinCount(m_dwPinCount);
        if (FAILED(hErr)) {
            DbgLog((LOG_ERROR, 3, TEXT("CRTPDemuxPropertyPage::OnApplyChanges: Error 0x%08x changing pin count. Aborting apply!"),
                    hErr));

			// ZCS: Make a message box to report the error.

			// first load in the strings from the string table resource
			TCHAR szText[256], szCaption[256];

			switch(hErr)
			{
			case E_OUTOFMEMORY:
				LoadString(g_hInst, IDS_RTPDEMUX_NEWPINS_OUTOFMEM, szText, 255);
				break;

			case VFW_E_NOT_STOPPED:
				LoadString(g_hInst, IDS_RTPDEMUX_NEWPINS_NOTSTOPPED, szText, 255);
				break;

			default:
				LoadString(g_hInst, IDS_RTPDEMUX_NEWPINS_OTHER, szText, 255);
				break;
			}

			LoadString(g_hInst, IDS_RTPDEMUX_NEWPINS_ERRTITLE, szCaption, 255);

			// now display it
			MessageBox(m_hwnd, szText, szCaption, MB_OK);
			// ...we don't care what they clicked

			// change the number of pins back to what it was
			// the old text is a valid 32-bit decimal number and is therefore limited to ten digits
			// we are safe and use an 80 digit limit :)
			TCHAR szOldNumber[80];
			wsprintf(szOldNumber, "%d", m_mPinList.size());
			
			m_dwPinCount = m_mPinList.size();
			SetWindowText(GetDlgItem(m_hwnd, IDC_PINCOUNT), szOldNumber);

			return hErr;
        } /* if */
	} /* if */


    // Check each of the pins for changes.
	// ZCS: note that many of these pins may be gone if we reduced the number of
	// pins just now... we use iDelta to account for this

	// int i = 0;
    for (IPinRecordMapIterator_t iPinRecord = m_mPinList.begin();
                                 (iPinRecord != m_mPinList.end()) /* && (i < m_dwPinCount) */ ;
                                 iPinRecord++ /* , i++ */ ) {

		// skip pins that no longer exist (ZCS)
		//if (iDelta > 0) {
		//	iDelta--;
		//	continue;
		//} /* if */

									 
		ASSERT(iPinRecord != m_mPinList.end());
        pIPin = (*iPinRecord).first;
        ASSERT(pIPin != static_cast<IPin *>(NULL));

        IPinRecord_t sTempRecord;
        DWORD dwTempSSRC;
        hErr = m_pIRTPDemux->GetPinInfo(pIPin, 
                                                &dwTempSSRC, &sTempRecord.bPT,
                                                &sTempRecord.bAutoMapping,
                                                &sTempRecord.dwTimeout);
        if (FAILED(hErr)) {
           // DbgLog((LOG_ERROR, 3, 
           //         TEXT("CRTPDemuxPropertyPage::OnApplyChanges: Error 0x%08x getting pin information. Aborting apply!"),
           //         hErr));
           // return hErr;

			continue;
		} /* if */

        LoadPinSubtype(pIPin, &(sTempRecord.mtsSubtype));

        // Change the payload if the user changed it.
        bPayload = (*iPinRecord).second.bPT;
        gSubtype = (*iPinRecord).second.mtsSubtype;
        if ((bPayload != sTempRecord.bPT) || (gSubtype != sTempRecord.mtsSubtype)) {
            DbgLog((LOG_TRACE, 4, TEXT("CRTPDemuxPropertyPage::OnApplyChanges: Payload changed from 0x%02x to 0x%02x (or subtype mismatch) for pin 0x%08x. Applying change."),
                    sTempRecord.bPT, bPayload, pIPin));
            hErr = m_pIRTPDemux->SetPinTypeInfo(pIPin, bPayload, gSubtype);
            if (FAILED(hErr)) {
                DbgLog((LOG_ERROR, 3, TEXT("CRTPDemuxPropertyPage::OnApplyChanges: Error 0x%08x changing PT. Aborting apply!"),
                        hErr));

				// ZCS: Before we bail, make a message box to report the error.

				// first load in the strings from the string table resource
				TCHAR szTextFormat[256], szCaption[256];
				LoadString(g_hInst, (hErr == VFW_E_ALREADY_CONNECTED) ? IDS_RTPDEMUX_NEWPT_CONNECTED :
																        IDS_RTPDEMUX_NEWPT_OTHER, szTextFormat, 255);
				LoadString(g_hInst, IDS_RTPDEMUX_NEWPT_ERRTITLE, szCaption, 255);

				// get the number of the output pin in question
		        LPWSTR pPinName;
		        HRESULT hErr = (*iPinRecord).first->QueryId(&pPinName);
		        ASSERT(SUCCEEDED(hErr)); // QueryId should always succeed on a valid pin.
			    int iPinDisplayNumber = _wtoi(pPinName);
		        CoTaskMemFree(pPinName);
		        iPinDisplayNumber--;  // it counts from 0 including the input pin, so adjust it

				// Construct the message text from the format (stored in the registry) and the pin number.
				TCHAR szText[512]; // this allows for up to 256 digits in the number, which is ridiculously safe
				wsprintf(szText, szTextFormat, iPinDisplayNumber);

				// now display it
				MessageBox(m_hwnd, szText, szCaption, MB_OK);
				// ...we don't care what they clicked

				// ZCS: Since we couldn't update the payload type, put it back to what it was
				(*iPinRecord).second.bPT        = sTempRecord.bPT;
				(*iPinRecord).second.mtsSubtype = sTempRecord.mtsSubtype;

				// ...and show it on the screen (but only if this is the currently selected pin)
				HWND hCurrentListbox = GetDlgItem(m_hwnd, IDC_PINLIST);
				int  iItem           = ListBox_GetCurSel(hCurrentListbox); 
				if (reinterpret_cast<IPin *>(ListBox_GetItemData(hCurrentListbox, iItem)) == pIPin)
					ShowPinInfo(pIPin);

				return hErr;
            } /* if */
        } /* if */

        // Only set the timeout if this is an automapping pin,
        // because timeouts don't apply to non-automapping pins.
        if (sTempRecord.bAutoMapping == TRUE) {
            // Change the timeout for the pin if the user changed it.
            dwTimeout = (*iPinRecord).second.dwTimeout;
            if (dwTimeout != sTempRecord.dwTimeout) {
                DbgLog((LOG_TRACE, 4, TEXT("CRTPDemuxPropertyPage::OnApplyChanges: Timeout changed from %d to %d for pin 0x%08x. Applying change."),
                        sTempRecord.dwTimeout, dwTimeout, pIPin));
                hErr = m_pIRTPDemux->SetPinSourceTimeout(pIPin, dwTimeout);
                if (FAILED(hErr)) {
                    DbgLog((LOG_ERROR, 3, TEXT("CRTPDemuxPropertyPage::OnApplyChanges: Error 0x%08x changing PT. Aborting apply!"),
                            hErr));
                    return hErr;
                } /* if */
            } /* if */
        } /* if */

        // Change the automapping mode for the pin if the user changed it.
        bAutoMapping = (*iPinRecord).second.bAutoMapping;
        if (bAutoMapping != sTempRecord.bAutoMapping) {
            DbgLog((LOG_TRACE, 4, TEXT("CRTPDemuxPropertyPage::OnApplyChanges: Automapping changed from %s for pin 0x%08x. Applying change."),
                    bAutoMapping ? "FALSE to TRUE" : "TRUE to FALSE", pIPin));
            hErr = m_pIRTPDemux->SetPinMode(pIPin, bAutoMapping);
            if (FAILED(hErr)) {
                DbgLog((LOG_ERROR, 3, TEXT("CRTPDemuxPropertyPage::OnApplyChanges: Error 0x%08x changing automapping state to %s!"),
                        hErr, bAutoMapping ? "TRUE" : "FALSE"));
                return hErr;
            } /* if */
        } /* if */
    } /* for */

    // This whole process is necessary to force the property
    // page to update itself upon the apply button being hit.
    
	IUnknown *pFilterUnknown;
    hErr = m_pIRTPDemux->QueryInterface(IID_IRTPDemuxFilter, 
                                      reinterpret_cast<PVOID *>(&pFilterUnknown));
    ASSERT(SUCCEEDED(hErr));
    hErr = OnDisconnect();
    ListBox_ResetContent(GetDlgItem(m_hwnd, IDC_SSRCLIST));
    ListBox_ResetContent(GetDlgItem(m_hwnd, IDC_PINLIST));
    ASSERT(SUCCEEDED(hErr));
    hErr = OnConnect(pFilterUnknown);
    m_bIsInitialized = TRUE;
    ASSERT(SUCCEEDED(hErr));
	hErr = OnActivate();
    ASSERT(SUCCEEDED(hErr));
    pFilterUnknown->Release();

    return(NOERROR);
} /* CRTPDemuxPropertyPage::OnApplyChanges() */



#endif _RTPDPROP_CPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpdmx\rtpdprop.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : RTPDProp.h
// Purpose  : Define the class that implements the Intel RTP Demux 
//            filter property page.
// Contents : 
//      class CRTPDemuxPropertyPage
//*M*/

#ifndef _RTPDPROP_H_
#define _RTPDPROP_H_

class 
CRTPDemuxPropertyPage 
: public CBasePropertyPage
{

public:
    static CUnknown * WINAPI CreateInstance( LPUNKNOWN punk, HRESULT *phr );

protected:
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate () ;
    HRESULT OnApplyChanges();

    CRTPDemuxPropertyPage( LPUNKNOWN punk, HRESULT *phr);

    BOOL OnInitDialog( void );
    BOOL OnCommand( int iButton, int iNotify, LPARAM lParam );

    void SetDirty();

private:
    HRESULT LoadPins(void);
    void LoadPinSubtype(IPin *pPin, GUID *gSubtype);
    HRESULT LoadSSRCs(void);
    HRESULT LoadSubtypes(void);

    void ShowPinInfo(IPin *pIPin);
    void ShowPinSubtype(IPinRecordMapIterator_t iPinRecord);
    void ShowSSRCInfo(IPinRecordMapIterator_t iPinRecord);

	void RedisplaySSRCList(void); // ZCS 7-14-97

    IRTPDemuxFilter *m_pIRTPDemux;
    BOOL m_bIsInitialized;  // Will be false while we set init values in Dlg

    SSRCRecordMap_t     m_mSSRCInfo;
    IPinRecordMap_t     m_mPinList;
    DWORD               m_dwPinCount;
};

#endif _RTPDPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\amrtpnet.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    amrtpnet.cpp

Abstract:

    Registration routines for ActiveMovie RTP Network Filters.

Environment:

    User Mode - Win32

Revision History:

    06-Nov-1996 DonRyan
        Created.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include "globals.h"

#if !defined(AMRTPNET_IN_DXMRTP)

// I had always the compilation message:
// "error C1020: unexpected #endif"
// if I move the above include inside the #if !defined block.

#include <initguid.h>
#define INITGUID
#include <amrtpuid.h>
#include <amrtpnet.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern "C" BOOL WINAPI DllMain(HINSTANCE, ULONG, LPVOID);
extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE, ULONG, LPVOID);

BOOL WINAPI
DllMain(
    HINSTANCE hInstance, 
    ULONG     ulReason, 
    LPVOID    pv
    )

/*++

Routine Description:

    Wrapper around ActiveMovie DLL entry point.

Arguments:

    Same as DllEntryPoint.   

Return Values:

    Returns TRUE if successful.

--*/

{
    return DllEntryPoint(hInstance, ulReason, pv);
}


HRESULT
DllRegisterServer(
    )

/*++

Routine Description:

    Instructs an in-process server to create its registry entries for all 
    classes supported in this server module. 

Arguments:

    None.

Return Values:

    S_OK - The registry entries were created successfully.

    E_UNEXPECTED - An unknown error occurred.

    E_OUTOFMEMORY - There is not enough memory to complete the registration.

    SELFREG_E_TYPELIB - The server was unable to complete the registration 
    of all the type libraries used by its classes.

    SELFREG_E_CLASS - The server was unable to complete the registration of 
    all the object classes.

--*/

{
    // forward to amovie framework
    return AMovieDllRegisterServer2( TRUE );
}


HRESULT
DllUnregisterServer(
    )

/*++

Routine Description:

    Instructs an in-process server to remove only registry entries created 
    through DllRegisterServer.

Arguments:

    None.

Return Values:

    S_OK - The registry entries were created successfully.

    S_FALSE - Unregistration of this server's known entries was successful, 
    but other entries still exist for this server's classes.

    E_UNEXPECTED - An unknown error occurred.

    E_OUTOFMEMORY - There is not enough memory to complete the unregistration.

    SELFREG_E_TYPELIB - The server was unable to remove the entries of all the 
    type libraries used by its classes.

    SELFREG_E_CLASS - The server was unable to remove the entries of all the 
    object classes.

--*/

{
    // forward to amovie framework
    return AMovieDllRegisterServer2( FALSE );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpdmx\ssrcenum.cpp ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : SSRCEnum.cpp
// Purpose  : Define the class that implements the RTP Demux filter.
// Contents : 
//*M*/

#include <streams.h>

#ifndef _SSRCENUM_CPP_
#define _SSRCENUM_CPP_

#pragma warning( disable : 4786 )
#pragma warning( disable : 4146 )
#pragma warning( disable : 4018 )

#include <vector.h>
#include <map.h>
#include <multimap.h>

//#pragma warning( default : 4786 )
//#pragma warning( default : 4146 )
//#pragma warning( default : 4018 )

#include "RTPDType.h"
#include "amrtpdmx.h"

#include "RTPDmx.h"
#include "RTPDInpP.h"
#include "RTPDOutP.h"

#include "SSRCEnum.h"

/*F*
//  Name    : CSSRCEnum::CSSRCEnum()
//  Purpose : Constructor. Just output a debugging message.
//  Context : 
//  Returns : Nothing.
//  Params  : None.
//  Notes   : None.
*F*/
CSSRCEnum::CSSRCEnum(
    CRTPDemux               *pFilter,
    SSRCRecordMapIterator_t iCurrentSSRCEntry)
: m_pFilter(pFilter),
  m_iCurrentSSRC(iCurrentSSRCEntry),
  CUnknown(NAME("RTP SSRC Enumerator"), NULL)
{
    ASSERT(m_pFilter);
    static_cast<IRTPDemuxFilter *>(m_pFilter)->AddRef();

    m_iVersion = m_pFilter->GetPinVersion();
    DbgLog((LOG_TRACE, 2, TEXT("CRTPDemux::CRTPDemux: Constructed at 0x%08x for filter 0x%08x (v.%d)"), 
            this, m_pFilter, m_iVersion));
} /* CRTPDemux::CSSRCEnum() */


/*F*
//  Name    : CSSRCEnum::~CSSRCEnum()
//  Purpose : Destructor. Just output a debugging message.
//  Context : 
//  Returns : Nothing.
//  Params  : None.
//  Notes   : None.
*F*/
CSSRCEnum::~CSSRCEnum(void)
{
    DbgLog((LOG_TRACE, 2, TEXT("CSSRCEnum::~CSSRCEnum: Instance at 0x%08x destroyed"), this));
    static_cast<IRTPDemuxFilter *>(m_pFilter)->Release();
} /* CSSRCEnum::~CSSRCEnum() */



/*F*
//  Name    : CSSRCEnum::NonDelegatingQueryInterface()
//  Purpose : Override to expose our custom interface.
//  Context : None.
//  Returns :
//      E_POINTER       Invalid pointer argument passed in for ppv
//      E_NOINTERFACE   We don't support the requested interface.
//      NOERROR         Successfully retrieved interface pointer.
//  Params  : None.
//  Notes   : None.
*F*/
STDMETHODIMP
CSSRCEnum::NonDelegatingQueryInterface(
    REFIID  riid,
    void    **ppv)
{
    CheckPointer(ppv, E_POINTER);

    if (riid == IID_IEnumSSRCs) {
        return GetInterface(static_cast<IEnumSSRCs *>(this), ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    } /* if */
} /* CSSRCEnum::NonDelegatingQueryInterface() */


/*F*
//  Name    : CSSRCEnum::Next()
//  Purpose : Get some more SSRCs from this enumerator
//  Context : 
//  Returns :
//      E_POINTER   Invalid pointer argument passed in for pcFetched.
//  Params  : None.
//  Notes   : None.
*F*/
STDMETHODIMP
CSSRCEnum::Next(
    ULONG       cSSRCs,
    DWORD       *pdwSSRCs,
    ULONG       *pcFetched)
{
    DbgLog((LOG_TRACE, 5, TEXT("CSSRCEnum::Next: Called for %d SSRCs"), cSSRCs));
    if (IsBadWritePtr(pdwSSRCs, cSSRCs * sizeof(DWORD))) {
        DbgLog((LOG_ERROR, 3, TEXT("CSSRCEnum::Next: Invalid array pointer argument passed in!")));
        return E_POINTER;
    } /* if */

	// ZCS fix 6-17-97: As per generic IEnumXXXX spec:
	// If cSSRCs != 1, then pcFetched == NULL is an error.
	// If cSSRCs == 1 and pcFetched == NULL, then we must not touch pcFetched

	if (cSSRCs == 1) {
		if ((pcFetched != NULL) && IsBadWritePtr(pcFetched, sizeof(ULONG))) {
	        DbgLog((LOG_ERROR, 3, TEXT("CSSRCEnum::Next: Invalid fetch count pointer argument passed in!")));
	        return E_POINTER;
		}
	}
	else if (IsBadWritePtr(pcFetched, sizeof(ULONG))) {
        DbgLog((LOG_ERROR, 3, TEXT("CSSRCEnum::Next: Invalid fetch count pointer argument passed in!")));
        return E_POINTER;
	}

	// From here on pcFetched might be NULL, so we must check it at each use.

    CAutoLock l(m_pFilter);

    if (AreWeOutOfSync() == TRUE) {
        *pdwSSRCs = NULL;
		if (pcFetched) *pcFetched = 0;
        DbgLog((LOG_ERROR, 3, 
                TEXT("CSSRCEnum::Next: Out of sync with filter (%d internal version vs. %d filter version, aborting!"), 
                m_iVersion, m_pFilter->GetPinVersion()));
        return VFW_E_ENUM_OUT_OF_SYNC;
    } /* if */

    for (int iCurrentSSRC = 0; iCurrentSSRC < cSSRCs; iCurrentSSRC++) {
        if (m_iCurrentSSRC == m_pFilter->m_mSSRCRecords.end()) {
            // Reached the end of the list.
            if (pcFetched) *pcFetched = iCurrentSSRC;
            return NOERROR;
        } /* if */
        pdwSSRCs[iCurrentSSRC] = (*m_iCurrentSSRC).first;
        m_iCurrentSSRC++;
    } /* for */

	// ZCS fix: if we are successful we must still say how many we got!
	if (pcFetched) *pcFetched = cSSRCs;
    return NOERROR;
} /* CSSRCEnum::Next() */

    
/*F*
//  Name    : CSSRCEnum::Skip()
//  Purpose : Skip forward over a bunch of SSRCs.
//  Context : 
//  Returns : 
//      E_INVALIDARG            cSSRCs passed in as < 1. Should always
//                              be a positive value to make sense.
//      VFW_E_ENUM_OUT_OF_SYNC  Enumerator out of sync with parent filter.
//                              App should call Reset() then try again.
//      S_FALSE                 Not enough SSRCs in list to skip. Skipped
//                              as many as possible.
//      NOERROR                 Successfully skipped indicated number of SSRCs.
//  Params  :
//      cSSRCs  Number of SSRCs to skip forward over.
//  Notes   : None.
*F*/
STDMETHODIMP
CSSRCEnum::Skip(
    ULONG       cSSRCs)
{
    DbgLog((LOG_TRACE, 5, TEXT("CSSRCEnum::Skip: Called for %d SSRCs"), cSSRCs));
    if (cSSRCs < 1) {
        DbgLog((LOG_ERROR, 3, TEXT("CSSRCEnum::Skip: Invalid skip count %d passed in!"), cSSRCs));
        return E_INVALIDARG;
    } /* if */

    CAutoLock l(m_pFilter);

    if (AreWeOutOfSync() == TRUE) {
        DbgLog((LOG_ERROR, 3, 
                TEXT("CSSRCEnum::Skip: Out of sync with filter (%d internal version vs. %d filter version, aborting!"), 
                m_iVersion, m_pFilter->GetPinVersion()));
        return VFW_E_ENUM_OUT_OF_SYNC;
    } /* if */

    int iSSRCsSkipped = 0;
    while ((iSSRCsSkipped < cSSRCs) &&
           (m_iCurrentSSRC != m_pFilter->m_mSSRCRecords.end())) {
        m_iCurrentSSRC++;
        iSSRCsSkipped++;
    } /* while */

    if (cSSRCs > 0) {
        // Skip back to where we where.
        DbgLog((LOG_ERROR, 5, TEXT("CSSRCEnum::Skip: Only %d SSRCs left, unable to perform skip!"), iSSRCsSkipped));
        for (int iSSRCsToUnskip = 0; iSSRCsToUnskip < iSSRCsSkipped; iSSRCsToUnskip--) {
            m_iCurrentSSRC--;
        } /* for */
        return S_FALSE;
    } else {
        return NOERROR;
    } /* if */
} /* CSSRCEnum::Skip() */


/*F*
//  Name    : CSSRCEnum::Reset()
//  Purpose : Destructor. Just output a debugging message.
//  Context : 
//  Returns :
//      NOERROR Successfully reset our enumerator.
//  Params  : None.
//  Notes   : None.
*F*/
STDMETHODIMP
CSSRCEnum::Reset(void)
{
    DbgLog((LOG_TRACE, 4, TEXT("CSSRCEnum::Reset: Called for CSSRCEnum 0x%08x"), this));

    CAutoLock l(m_pFilter);

    // No need to check if out of sync because we resync below.

    m_iCurrentSSRC = m_pFilter->m_mSSRCRecords.begin();
    // We reset our version to match the current version of our filter.
    m_iVersion = m_pFilter->GetPinVersion();

    return NOERROR;
} /* CSSRCEnum::Reset() */

  
/*F*
//  Name    : CSSRCEnum::Clone()
//  Purpose : Destructor. Just output a debugging message.
//  Context : 
//  Returns :
//      E_OUTOFMEMORY   No memory to allocate new enumerator.
//      E_POINTER       Invalid ppEnum parameter passed in. 
//  Params  :
//  Notes   : None.
*F*/
STDMETHODIMP
CSSRCEnum::Clone(
    IEnumSSRCs  **ppEnum)
{
    DbgLog((LOG_TRACE, 5, TEXT("CSSRCEnum::Clone: Called for instance 0x%08x"), this));
    if (IsBadWritePtr(ppEnum, sizeof(IEnumSSRCs *))) {
        DbgLog((LOG_ERROR, 3, TEXT("CSSRCEnum::Clone: Invalid ppEnum parameter 0x%08x passed in"), 
                ppEnum));
        return E_POINTER;
    } /* if */

    CAutoLock l(m_pFilter);
    if (AreWeOutOfSync() == TRUE) {
        DbgLog((LOG_ERROR, 3, 
                TEXT("CSSRCEnum::Clone: Out of sync with filter (%d internal version vs. %d filter version, aborting!"), 
                m_iVersion, m_pFilter->GetPinVersion()));
        return VFW_E_ENUM_OUT_OF_SYNC;
    } /* if */

    CSSRCEnum *pNewEnum = new CSSRCEnum(m_pFilter, m_iCurrentSSRC);
    if (pNewEnum == NULL) {
        DbgLog((LOG_ERROR, 3, 
                TEXT("CSSRCEnum::Clone: Out of memory error allocating new enumerator!")));
        return E_OUTOFMEMORY;
    } /* if */

    // AddRef it since we are returning an interface to it.
    pNewEnum->AddRef();
    *ppEnum = static_cast<IEnumSSRCs *>(pNewEnum);
    return NOERROR;
} /* CSSRCEnum::Clone() */

#endif _SSRCENUM_CPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\classes.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    classes.h

Abstract:

    Class definitions for ActiveMovie RTP Network Filters.

Environment:

    User Mode - Win32

Revision History:

    06-Nov-1996 DonRyan
        Created.

--*/
 
#ifndef _INC_CLASSES
#define _INC_CLASSES

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Forward Declarations                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

class CRtpInputPin;
class CRtpOutputPin;
class CRTPAllocator;
class CRtpRenderFilter;
class CRtpSourceFilter;
class CRtpRenderFilterProperties;
class CRtpSourceFilterProperties;
class CRtpSession;
class CSocketManager;
class CShSocket;
class CRtpQOSReserve;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// RTP Render Filter Class                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

class CRtpRenderFilter : public ISpecifyPropertyPages,
                         public CPersistStream,
                         public CBaseFilter,
                         public IAMFilterMiscFlags
{
    friend class CRtpInputPin;

    INT             m_iPins;         // number of pins
    CRtpInputPin ** m_paStreams;     // pointer to input pin array
    CCritSec        m_cStateLock;    // serializes access to filter state

public:

    DECLARE_IUNKNOWN

    // constructor 
    CRtpRenderFilter(LPUNKNOWN pUnk, HRESULT * phr);

    // destructor
    ~CRtpRenderFilter();

    // instance creation routine for active movie class factory
    static CUnknown * CreateInstance(LPUNKNOWN punk, HRESULT * phr);

    // expose state lock to other objects
    CCritSec * pStateLock(void) { return &m_cStateLock; }

    // add input pin from filter
    HRESULT AddPin(CRtpInputPin * pPin);

    // remove input pin from filter
    HRESULT RemovePin(CRtpInputPin * pPin);

    //-----------------------------------------------------------------------//
    // CBaseFilter overrided methods                                         //
    //-----------------------------------------------------------------------//

    // get pin count
    int GetPinCount();

    // get pin from index
    CBasePin * GetPin(int n);

    // setup helper function
    LPAMOVIESETUP_FILTER GetSetupData();

    //-----------------------------------------------------------------------//
    // IBaseFilter implemented methods                                       //
    //-----------------------------------------------------------------------//

    // get vendor specific description string
    STDMETHODIMP QueryVendorInfo(LPWSTR * pVendorInfo);

    //-----------------------------------------------------------------------//
    // IPersistStream implemented methods                                    //
    //-----------------------------------------------------------------------//

    // get filter class id
    STDMETHODIMP GetClassID(CLSID *pClsid);

    // write filter info into stream
    HRESULT WriteToStream(IStream *pStream);

    // read filter info from stream
    HRESULT ReadFromStream(IStream *pStream);

    // get version of info stream
    DWORD GetSoftwareVersion() { return 0; }

    // max size
    int SizeMax();

    //-----------------------------------------------------------------------//
    // IAMFilterMiscFlags implemented methods                                //
    //-----------------------------------------------------------------------//
    STDMETHODIMP_(ULONG) GetMiscFlags(void);
    
    //-----------------------------------------------------------------------//
    // ISpecifyPropertyPages implemented methods                             //
    //-----------------------------------------------------------------------//

    // return our property pages
    STDMETHODIMP GetPages(CAUUID * pPages);

    //-----------------------------------------------------------------------//
    // INonDelegatingUnknown implemented methods                             //
    //-----------------------------------------------------------------------//

    // obtain pointers to active movie and private interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// RTP Input Pin Class                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define FLAG_INPUT_PIN_PRIORITYSET 1

class CRtpInputPin : public CRenderedInputPin
{
    CRtpRenderFilter * const m_pFilter;          // pointer to sink filter
    CRtpSession *            m_pRtpSession;      // pointer to rtp session
    DWORD                    m_dwFlag;
                                         
public:
    // constructor
    CRtpInputPin(
        CRtpRenderFilter * pFilter,
        LPUNKNOWN          pUnk, 
        HRESULT *          phr
        );

    // destructor
    ~CRtpInputPin();

    //-----------------------------------------------------------------------//
    // CRenderedInputPin overrided methods                                   //
    //-----------------------------------------------------------------------//

    // activate
    HRESULT Active();

    //-----------------------------------------------------------------------//
    // CBaseInputPin overrided methods                                       //
    //-----------------------------------------------------------------------//

    // deactivate
    HRESULT Inactive();

    //-----------------------------------------------------------------------//
    // CBasePin overrided methods                                            //
    //-----------------------------------------------------------------------//

    // validate proposed pin type and format
    HRESULT CheckMediaType(const CMediaType *);

    //-----------------------------------------------------------------------//
    // IMemInputPin implemented methods                                      //
    //-----------------------------------------------------------------------//

    // send input stream over network
    STDMETHODIMP Receive(IMediaSample *pSample);

    //-----------------------------------------------------------------------//
    // INonDelegatingUnknown implemented methods                             //
    //-----------------------------------------------------------------------//

    // obtain pointers to active movie and private interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);


    // ZCS added 6-22-97 to facilitate persiststream implementation
    HRESULT GetSession(CRtpSession **ppCRtpSession)
        { *ppCRtpSession = m_pRtpSession; return NOERROR; }
};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// RTP Source Filter Class                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

class CRtpSourceFilter : public ISpecifyPropertyPages,
                         public CPersistStream,
                         public CSource
{
    friend class CRtpOutputPin;

public:
    DECLARE_IUNKNOWN;

    // constructor 
    CRtpSourceFilter(LPUNKNOWN pUnk, HRESULT * phr);

    // destructor
    ~CRtpSourceFilter();

    // instance creation routine for active movie class factory
    static CUnknown * CreateInstance(LPUNKNOWN pUnk, HRESULT * phr);

    // ZCS 6-20-97 as per amovie guys: overloaded from the
    // CBaseMediaFilter class to ensure that we don't hang on stop
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

    //-----------------------------------------------------------------------//
    // CBaseFilter overrided methods                                         //
    //-----------------------------------------------------------------------//

    // setup helper function
    LPAMOVIESETUP_FILTER GetSetupData();

    // pause filter
    STDMETHODIMP Pause();

    //-----------------------------------------------------------------------//
    // IBaseFilter implemented methods                                       //
    //-----------------------------------------------------------------------//

    // get vendor specific description string
    STDMETHODIMP QueryVendorInfo(LPWSTR * pVendorInfo);

    //-----------------------------------------------------------------------//
    // IPersistStream implemented methods                                    //
    //-----------------------------------------------------------------------//

    // get filter class id
    STDMETHODIMP GetClassID(CLSID *pClsid);

    // write filter info into stream
    HRESULT WriteToStream(IStream *pStream);

    // read filter info from stream
    HRESULT ReadFromStream(IStream *pStream);

    // get version of info stream
    DWORD GetSoftwareVersion() { return 0; }

    // Backdoor State Query
    FILTER_STATE GetState() { return m_State; }

    // max size
    int SizeMax();

    //-----------------------------------------------------------------------//
    // ISpecifyPropertyPages implemented methods                             //
    //-----------------------------------------------------------------------//

    // return our property pages
    STDMETHODIMP GetPages(CAUUID * pPages);

    //-----------------------------------------------------------------------//
    // INonDelegatingUnknown implemented methods                             //
    //-----------------------------------------------------------------------//

    // obtain pointers to active movie and private interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// RTP Output Pin Class                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

class CRtpOutputPin : public CSharedSourceStream
{                                               
    CRtpSourceFilter * const  m_pFilter;        // pointer to source filter
    CRtpSession *             m_pRtpSession;    // pointer to rtp session

    DWORD                     m_NumSamples;     // number of current samples
    DWORD                     m_MaxSamples;     // maximum number of samples

    CCritSec                  m_cStateLock;     // worker thread lock
    BOOL                      m_fIsAsyncIoOk;   // worker thread status  
    //DWORD                     m_ThreadPriority; // worker thread priority

    CRTPAllocator *           m_pRtpAlloc;      // special allocator

    HRESULT ProcessCmd(DWORD &Request);
public:

    // constructor
    CRtpOutputPin(
        CRtpSourceFilter * pFilter,
        LPUNKNOWN           pUnk, 
        HRESULT *           phr
        );

    // destructor
    ~CRtpOutputPin();

    // read alertable status 
    BOOL IsAsyncIoEnabled(void) { 
            CAutoLock LockThis(&m_cStateLock); 
            return m_fIsAsyncIoOk; 
            }

    // write alertable status 
    HRESULT EnableAsyncIo(BOOL fIsAsyncIoOk) { 
            CAutoLock LockThis(&m_cStateLock); 
            m_fIsAsyncIoOk = fIsAsyncIoOk; 
            return S_OK;
            }

    //-----------------------------------------------------------------------//
    // CSourceStream overrided methods                                       //
    //-----------------------------------------------------------------------//

    // fill the stream output buffer
    HRESULT FillBuffer(IMediaSample *pSample);

    // verify we can handle this format
    HRESULT CheckMediaType(const CMediaType *pmt);

    // return media type supported
    HRESULT GetMediaType(CMediaType *pmt);

    // activate
    HRESULT Active();

    // deactivate
    HRESULT Inactive();

    // Give samples to WinSock
    HRESULT ProcessFreeSamples();

#if defined(_0_)
    // main processing loop
    HRESULT DoBufferProcessingLoop();
#endif    
    // thread procedure
    DWORD ThreadProc();

    //-----------------------------------------------------------------------//
    // CBaseOutputPin overrided methods                                      //
    //-----------------------------------------------------------------------//

    // ask for buffers of the appropriate size 
    HRESULT DecideBufferSize(
                IMemAllocator *        pAlloc,
                ALLOCATOR_PROPERTIES * pProperties
                );
    HRESULT DecideAllocator(
                IMemInputPin        *pPin,
                IMemAllocator      **ppAlloc
                );

    //-----------------------------------------------------------------------//
    // CBasePin overrided methods                                            //
    //-----------------------------------------------------------------------//

    // tell worker thread to run
    HRESULT Run(REFERENCE_TIME tStart);

    // receive notifications of quality problems
    STDMETHODIMP Notify(IBaseFilter * pSelf, Quality q);

    //------------------------------------------------------------
    // Helper to CSharedSourceStream
    //------------------------------------------------------------
    HRESULT ProcessIO(SAMPLE_LIST_ENTRY *pSLE);
    
    HRESULT ProcessCmd(Command Request);

    inline CRtpSession *GetRtpSession() { return m_pRtpSession; }

    inline void SetNumSamples(DWORD NumSamples)
    {m_NumSamples = NumSamples; }

    //-----------------------------------------------------------------------//
    // INonDelegatingUnknown implemented methods                             //
    //-----------------------------------------------------------------------//

    // obtain pointers to active movie and private interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);


    // ZCS added 6-22-97 to facilitate persiststream implementation
    HRESULT GetSession(CRtpSession **ppCRtpSession)
        { *ppCRtpSession = m_pRtpSession; return NOERROR; }

    HRESULT GetClassPriority(long *plClass, long *plPriority);
};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// RTP Render Filter Properties                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

class CRtpRenderFilterProperties : public CBasePropertyPage 
{
    IRTPStream *        m_pRtpStream;  
    struct sockaddr_in  m_RtpAddr;
    DWORD               m_RtpScope;

    struct sockaddr_in  m_RtcpAddr;
    DWORD               m_RtcpScope;

    DWORD               m_QOSstate;
    DWORD               m_MulticastLoopBack;

public:

    // constrcutor
    CRtpRenderFilterProperties(LPUNKNOWN pUnk, HRESULT *phr);

    // destructor
    ~CRtpRenderFilterProperties();

    // instance creation routine for active movie class factory
    static CUnknown * CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    //-----------------------------------------------------------------------//
    // CBasePropertyPage overrided methods                                   //
    //-----------------------------------------------------------------------//

    // initialize property page
    HRESULT OnConnect(IUnknown *pUnknown);

    // cleanup page
    HRESULT OnDisconnect();

    // activate page
    HRESULT OnActivate();

    // deactive page
    HRESULT OnDeactivate();
    
    // apply user changes
    HRESULT OnApplyChanges();

    // receive messages 
    INT_PTR OnReceiveMessage(
            HWND   hwnd,
            UINT   uMsg,
            WPARAM wParam,
            LPARAM lParam
            );

private:

    // initialize controls
    HRESULT InitControls();
};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// RTP Session Class                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define DEFAULT_TTL 4 // default packet's Time To Live (or scope)

#define NUMBER_SDES_ITEMS (RTCP_SDES_LAST - RTCP_SDES_END)

#define MAX_QOS_NAME 32

#define fg_set(flag, b) (flag |=  (1 << (b)))
#define fg_rst(flag, b) (flag &= ~(1 << (b)))
#define fg_tst(flag, b) (flag &   (1 << (b)))
#define fg_par(b)       (1 << (b))

// Some bits for CRtpSession::m_dwFlags
enum {
    /* b0  ************************************************************/
    FG_ISJOINED,            /* Session is already joined */
    FG_ISSENDER,            /* This sesion is a sender */
    
    FG_MULTICASTLOOPBACK,   /* EXPOSED: Enable multicast loop-back */
    
    FG_ENABLEREPORTS,       /* RTCP reports are enabled */

    /* b4  ************************************************************/
    FG_SENDSTATE,           /* Permission to send is granted */
    FG_SENDIFALLOWED,       /* EXPOSED: Ask for permission before sending */
    FG_SENDIFALLOWED2,      /* flag used while running */
    FG_DUMMY7,

    /* b8  ************************************************************/
    FG_RECEIVERSSTATE,      /* RECEIVERS message received */
    FG_SENDIFRECEIVERS,     /* EXPOSED: Only send if there are RECEIVERS */
    FG_SENDIFRECEIVERS2,    /* flag used while running */
    FG_DUMMY11,

    /* b12 ************************************************************/
    FG_QOSSTATE,            /* EXPOSED: QOS is enabled */
    FG_FAILIFNOQOS,         /* EXPOSED: Fails if QOS was not available */

    FG_SHAREDSTYLE,         /* EXPOSED: QOS Shared Explicit
                             * reservation style (mcast) */
    FG_DUMMY15,

    /* b16 ************************************************************/
    FG_SHAREDSOCKETS,       /* EXPOSED: Allows sockets to be shared
                             * (receiver/sender) */
    FG_SENDPATHMSG,         /* do Reserve for sender at exponentially
                             * increasing intervals until RECEIVERS
                             * notification */
    FG_EVENT_READY,         /* Ready to pass events */
    FG_DUMMY19,

    /* b20 ************************************************************/
    FG_ALLOWEDTOSEND_WILLFAIL,        /* Force Allowed to send to fail/succed*/
    FG_ENABLE_ALLOWEDTOSEND_WILLFAIL ,/* Enable above bit */
    FG_AUTO_SHAREDEXPLICIT,           /* Enable auto shared explicit */
    FG_DUMMY23,

    /* b24 ************************************************************/
    FG_FORCE_MQOSSTYLE,     /* force to use a specific QoS style in mcast */
    FG_MQOSSTYLE,           /* 0: Wildcard, 1:Shared explicit */
    FG_FORCE_UQOSSTYLE,     /* force to use a specific QoS style in ucast */
    FG_UQOSSTYLE,           /* not defined */
    
    /* b28 ************************************************************/
    FG_ISMULTICAST,         /* Address is multicast */
    FG_QOSNOTIFY_STARTED,   /* QOS notifications have been started */
    FG_REG_QOSTEMPLATE,     /* got QOS template from registry */

    
    FG_LAST
};

// The reserve interval time is use by a sender when using
// QOS and when it is not allowed to send.
// In order to speed up the return of a RECEIVERS notification,
// the sender sends multiple PATH messages at exponentially
// increasing intervals.
// Time in ms
#define INITIAL_RESERVE_INTERVAL_TIME (2*1000)
#define MAX_RESERVE_INTERVAL_TIME     (20*1000)

class CRtpSession : public CUnknown,
                    public IRTPStream,
                    public IRTCPStream,
                    public IRTPParticipant
{
    CCritSec       m_cStateLock;        // serializes access to session state

#define flags_set(b) fg_set(m_dwFlags, b)
#define flags_rst(b) fg_rst(m_dwFlags, b)
#define flags_tst(b) fg_tst(m_dwFlags, b)
#define flags_par(b) fg_par(b)

    DWORD          m_dwFlags;           // set of flags
    //BOOL           m_fIsJoined;         // boolean specifying session state
    //BOOL           m_fIsSender;         // boolean specifying session status
    //BOOL           m_fEnableReports;    // controls rtcp report generation

    CSampleQueue * m_pSampleQueue;      // queue of outstanding samples

    SOCKADDR_IN    m_RtpAddr;           // addr used for rtp stream
    DWORD          m_RtpScope;          // multicast scope for senders
    CShSocket     *m_pRtpSocket;        // socket used for rtp stream
    CShSocket     *m_pRtpSocket2;       // socket used for rtp stream

    SOCKADDR_IN    m_RtcpAddr;          // addr used for rtp stream
    DWORD          m_RtcpScope;         // multicast scope for senders
    CShSocket     *m_pRtcpSocket;       // socket used for rtp stream
    CShSocket     *m_pRtcpSocket2;      // socket used for rtp stream

    RTP_SESSION   *m_pRTPSession;       // RTPSession (ptr to session)
    RTP_SESSION   *m_pRTPSession2;      // RTPSession (ptr to session)

    SOCKET         m_pSocket[3];

    // These 2 ports are kept in NETWORK order,
    // i.e. they can be directly compared/copied with/to
    // the port in sockadr_in structures (kept in NETWORK order)
    WORD           m_wRtpLocalPort;      // remote port is in m_RtpAddr
    WORD           m_wRtcpLocalPort;     // remote port is in m_RtcpAddr
    // In unicast, remote and local ports can be different,
    // in multicast, they are (MUST) be the same
    
    SDES_DATA      m_SdesData[NUMBER_SDES_ITEMS]; // user information

    //DWORD          m_QOSstate;          // QOS enabled/disabled
    char           m_QOSname[MAX_QOS_NAME]; // QOS template name
    DWORD          m_dwMaxFilters;      // Maximum number for SE reservations
    DWORD          m_dwMaxBandwidth;    // Maximum target bandwidth

    SOCKADDR_IN    m_LocalIPAddress;    // Our IP address
    
    CBaseFilter   *m_pCBaseFilter;      // To have access to NotifyEvent
    DWORD          m_dwRTCPEventMask;   // RTP/RTCP event mask
    DWORD          m_dwQOSEventMask;    // QOS event mask (original setting)
    DWORD          m_dwQOSEventMask2;   // QOS event mask (run time)
    DWORD          m_dwSdesMask;        // RTCP SDES mask
    
    long           m_lSessionID;        // ID
    
    DWORD          m_dwDataClock;       // Data's Sampling rate
    long           m_lSessionClass;     // e.g. audio, data, ...
    long           m_lSessionPriority;  // e.g. time critical or not

    long           m_lCredits;          // Used when not allowed to send
    DWORD          m_dwLastSent;        // Last sent when not allowed to send

public:
    
    DECLARE_IUNKNOWN

    // constructor
    CRtpSession(LPUNKNOWN pUnk, HRESULT * phr, BOOL fSender,
                CBaseFilter *pCBaseFilter);

    // destructor
    ~CRtpSession();

    // join session
    HRESULT Join();

    // leave session
    HRESULT Leave();

    // sends out specified sample
    HRESULT SendTo(IMediaSample * pSample);

    // receive packet into given sample
    HRESULT RecvFrom(IMediaSample * pSample);

#if defined(_0_)
    // retreive samples from completion queue
    HRESULT RecvNext(IMediaSample ** ppSample);
#endif
    // expose state lock to other objects
    CCritSec * pStateLock(void) { return &m_cStateLock; }

    // expose joined state to other objects 
    inline BOOL IsJoined(void) { return(flags_tst(FG_ISJOINED) != 0); }

    // expose sender state to other objects 
    inline BOOL IsSender(void) { return(flags_tst(FG_ISSENDER) != 0); }

    // Set/Reset one bit in m_dwFlags
    inline void ModifyFlags(DWORD bit, DWORD value)
    { if (value) flags_set(bit);else flags_rst(bit); }

    // Test a flag in m_dwFlags
    inline BOOL TestFlags(DWORD bit) { return(flags_tst(bit)); }

    // test the QOS event mask (refers to the QOS notifications)
    inline DWORD IsQOSEventEnabled(DWORD dwEvent)
    { return(m_dwQOSEventMask2 & (1 << dwEvent)); }

    // Set credits, used when not allowed to send.
    inline long SetCredits(long lCredits, DWORD dwLastSent)
        { m_dwLastSent = dwLastSent; return(m_lCredits = lCredits); }
    
    // expose RTP session pointer
    inline PRTP_SESSION GetpRTPSession() { return(m_pRTPSession); }

    // expose shared sockets
    inline CShSocket *GetpCShRtpSocket() { return(m_pRtpSocket); }
    inline CShSocket *GetpCShRtcpSocket() { return(m_pRtcpSocket); }
    
    // set shared objects
    void SetSharedObjectsCtx( void             *pvContext,
                              LIST_ENTRY       *pSharedList,
                              CRITICAL_SECTION *pSharedLock)
    {
        if (m_pSampleQueue)
            m_pSampleQueue->SetSharedObjectsCtx(pvContext,
                                                pSharedList,
                                                pSharedLock);       
    }

private:
    //-----------------------------------------------------------------------//
    // RTP/RTCP stream independent methods                                   //
    //-----------------------------------------------------------------------//

    // modify the address for the rtp/rtcp stream
    HRESULT SetAddress_(WORD  wLocalPort,
                        WORD  wRemotePort,
                        DWORD dwRemoteAddr,
                        DWORD doRTP);

    // retrieve multicast scope of rtp stream
    HRESULT GetMulticastScope_(LPDWORD pdwMulticastScope,
                               PDWORD pScope);

    // modify multicast scope of rtp/rtcp stream
    HRESULT SetMulticastScope_(DWORD dwMulticastScope,
                               DWORD doRTP);

public:
    //-----------------------------------------------------------------------//
    // IRTPStream methods                                                    //
    //-----------------------------------------------------------------------//

    // retrieve the address for the rtp stream
    STDMETHODIMP GetAddress(LPWORD  pwRtpLocalPort,
                            LPWORD  pwRtpRemotePort,
                            LPDWORD pdwRtpRemoteAddr);

    // modify the address for the rtp/rtcp stream
    STDMETHODIMP SetAddress(WORD  wRtpLocalPort,
                            WORD  wRtpRemotePort,
                            DWORD dwRtpRemoteAddr);

    // retrieve multicast scope of rtp stream
    STDMETHODIMP GetMulticastScope(LPDWORD pdwMulticastScope);

    // modify multicast scope of rtp/rtcp stream
    STDMETHODIMP SetMulticastScope(DWORD dwMulticastScope);

    // set the QOS template name requested.
    // NOTE that the actual setting will be done until
    // we call Join(). It is not possible to do it
    // before because there is no socket created yet.
    // So success returned by this function does not mean
    // that the QOS request to WS2 will succed.
    // The parameter fFailIfNoQOS if different of 0,
    // indicates that joining the session must fail if
    // there is not possible for any reason to set QOS
    STDMETHODIMP SetQOSByName(char *psQOSname, DWORD fFailIfNoQOS);

    // query QOS state (enabled/disabled)
    STDMETHODIMP GetQOSstate(DWORD *pdwQOSstate);

    // set QOS state (enabled/disabled)
    STDMETHODIMP SetQOSstate(DWORD dwQOSstate);

    // query Multicast Loopback state (enabled/disabled)
    STDMETHODIMP GetMulticastLoopBack(DWORD *pdwMulticastLoopBack);

    // set Multicast Loopback state (enabled/disabled)
    STDMETHODIMP SetMulticastLoopBack(DWORD dwMulticastLoopBack);

    // Gets a per RTP/RTCP identifier that is associated to each object
    STDMETHODIMP GetSessionID(DWORD *pdwID);

    // Retrieves the data clock used with RTP data
    STDMETHODIMP GetDataClock(DWORD *pdwDataClock);

    // Sets the data clock to be used with RTP data
    STDMETHODIMP SetDataClock(DWORD dwDataClock);

    // Select the local IP address (multihomed hosts) to use
    // when sending/receiving
    STDMETHODIMP SelectLocalIPAddress(DWORD dwLocalAddr);

    // Select the local IP address (multihomed hosts) to use
    // when sending/receiving. If DestAddr is specified,
    // retrives the local IP address to use (the interface)
    // based on that destination address.
    STDMETHODIMP SelectLocalIPAddressToDest(LPBYTE pLocSAddr,
                                            DWORD  dwLocSAddrLen,
                                            LPBYTE pDestSAddr,
                                            DWORD  dwDestSAddrLen);

    // Enable sharing the sockets between a sender and a receiver,
    // an efect of doing so is that the RTP/RTCP sessions are also
    // shared, then the sender and the receiver are seen as
    // a single participant.
    // If sockets are not shared, a sender and a receiver are seen
    // as independent participants, each sending RTCP reports.
    // Th default is to share sockets.
    STDMETHODIMP SelectSharedSockets(DWORD dwfSharedSockets);
    
    // Get the session's class and priority
    STDMETHODIMP GetSessionClassPriority(long *plSessionClass,
                                         long *plSessionPriority);

    // Set the session's class and priority
    STDMETHODIMP SetSessionClassPriority(long lSessionClass,
                                         long lSessionPriority);

    // Get the session's QoS event mask
    STDMETHODIMP GetQOSEventMask(DWORD *pdwQOSEventMask);

    // Modify (enable/disable items) the QoS event mask
    STDMETHODIMP ModifyQOSEventMask(DWORD dwSelectItems, DWORD dwEnableItems);
    
    // Enable/Disable checking for permission to send (default is to check)
    STDMETHODIMP SetQOSSendIfAllowed(DWORD dwEnable);

    // Enable/Disable waiting until receivers before start sending
    // (default is to send even if we have not received
    // the RECEIVERS notification)
    STDMETHODIMP SetQOSSendIfReceivers(DWORD dwEnable);
#if 0
    // Get the security state enabled!=0, or disabled=0
    STDMETHODIMP GetSecurityState(DWORD *pdwSecurityState);

    // Set the security state enabled!=0, or disabled=0
    STDMETHODIMP SetSecurityState(DWORD dwSecurityState);

    // Get the shared key. Parameter piSecurityKeyLen receives the length
    // of the buffer in bytes as input and returns the size of the key
    // in bytes as output
    STDMETHODIMP GetSecurityKey(LPBYTE *pbSecurityKey,
                                int *piSecurityKeyLen);

    // Set the shared key. Parameter iSecurityKeyLen specifies the
    // size of the key in bytes
    STDMETHODIMP SetSecurityKey(LPBYTE *pbSecurityKey,
                                int iSecurityKeyLen);

    // Retrieves the type of encryption to be used with
    // RTP and RTCP packets
    STDMETHODIMP GetSecurityType(DWORD *pdwRTPSecurityType,
                                 DWORD *pdwRTCPSecurityType);

    // Selects the type of encryption to be used with
    // RTP and RTCP packets.
    // RTP:  0=no change, 1=payload type only, 2=whole packet
    // RTCP: 0=no change, 1=non encryption, 2=whole packet, 3=only SDES packets
    STDMETHODIMP SetSecurityType(DWORD dwRTPSecurityType,
                                 DWORD dwRTCPSecurityType);
#endif
    //-----------------------------------------------------------------------//
    // IRTCPPStream methods                                                  //
    //-----------------------------------------------------------------------//

    // retrieve the address for the rtcp stream
    STDMETHODIMP GetRTCPAddress(LPWORD  pwRtcpLocalPort,
                                LPWORD  pwRtcpRemotePort,
                                LPDWORD pdwRtcpRemoteAddr);

    // modify the address for the rtcp stream
    STDMETHODIMP SetRTCPAddress(WORD  wRtcpLocalPort,
                                WORD  wRtcpRemotePort,
                                DWORD dwRtcpRemoteAddr);

    // retrieve multicast scope of rtcp stream
    STDMETHODIMP GetRTCPMulticastScope(LPDWORD pdwMulticastScope);

    // modify multicast scope of rtcp stream
    STDMETHODIMP SetRTCPMulticastScope(DWORD dwMulticastScope);

    // Get the session's RTCP event mask
    STDMETHODIMP GetRTCPEventMask(DWORD *pdwRTCPEventMask);

    // Modify (enable/disable items) the RTCP event mask
    STDMETHODIMP ModifyRTCPEventMask(DWORD dwSelectItems, DWORD dwEnableItems);
    
    // Get a specific local SDES item
    STDMETHODIMP GetLocalSDESItem(DWORD   dwSDESItem,
                                  LPBYTE  psSDESData,
                                  LPDWORD pdwSDESLen);
    
    // Set a specific local SDES item
    STDMETHODIMP SetLocalSDESItem(DWORD   dwSDESItem,
                                  LPBYTE  psSDESData,
                                  DWORD   dwSDESLen);

    // Get the RTCP SDES mask
    STDMETHODIMP GetRTCPSDESMask(DWORD *pdwSdesMask);

    // Modify (enable/disable items) the RTCP SDES mask
    STDMETHODIMP ModifyRTCPSDESMask(DWORD dwSelectItems, DWORD dwEnableItems);

    //-----------------------------------------------------------------------//
    // IRTPParticipant methods                                               //
    //-----------------------------------------------------------------------//

    // retrieve the SSRC of each participant
    STDMETHODIMP EnumParticipants(LPDWORD pdwSSRC, LPDWORD pdwNum);

    // retrieve an specific SDES item from an specific SSRC (participant)
    STDMETHODIMP GetParticipantSDESItem(
            DWORD   dwSSRC,     // specific SSRC
            DWORD   dwSDESItem, // specific item (CNAME, NAME, etc.)
            LPBYTE  psSDESData, // data holder for item retrieved
            LPDWORD pdwSDESLen  // [IN]size of data holder [OUT] size of item
        );

    // retrieves all the SDES information for an specific SSRC (participant)
    STDMETHODIMP GetParticipantSDESAll(
            DWORD      dwSSRC,  // specific SSRC
            PSDES_DATA pSdes,   // Array of SDES_DATA structures
            DWORD      dwNum    // Number of SDES_DATA items
        );

    // retrieves the IP address/port for an specific SSRC (participant)
    STDMETHODIMP GetParticipantAddress(
            DWORD  dwSSRC,      // specific SSRC
            LPBYTE pbAddr,      // address holder
            int    *piAddrLen   // address lenght
        );

    // get the current maximum number of QOS enabled participants as well
    // as the maximum target bandwidth.
    // Fail with E_POINTER only if both pointers are NULL
    STDMETHODIMP GetMaxQOSEnabledParticipants(DWORD *pdwNumParticipants,
                                              DWORD *pdwMaxBandwidth);

    // The first parametr pass the maximum number of QOS enabled
    // participants (this parameter is used by receivers), flush the
    // QOS filter list for receivers.  The second parameter specifies
    // the target bandwidth and allows to scale some of the parameters
    // in the flowspec so the reservation matches the available
    // bandwidth. The third parameter defines the reservation style to
    // use (0=Wilcard, other=Shared Explicit)the second parameter
    STDMETHODIMP SetMaxQOSEnabledParticipants(DWORD dwMaxParticipants,
                                              DWORD dwMaxBandwidth,
                                              DWORD fSharedStyle);

    // retrieves the QOS state (QOS enabled/disabled) for
    // an specific SSRC (participant)
    STDMETHODIMP GetParticipantQOSstate(
            DWORD dwSSRC,       // specific SSRC
            DWORD *pdwQOSstate  // the participant's QOS current state
        );

    // sets the QOS state (QOS enabled/disabled) for
    // an specific SSRC (participant)
    STDMETHODIMP SetParticipantQOSstate(
            DWORD dwSSRC,       // specific SSRC
            DWORD dwQOSstate    // sets the participant's QOS state
        );

    // Retrieves the current list of SSRCs that are sharing the
    // SE reservation
    STDMETHODIMP GetQOSList(
            DWORD *pdwSSRCList, // array to place the SSRCs from the list
            DWORD *pdwNumSSRC   // number of SSRCs that can be hold, returned
        );
    
    // Modify the QOS state (QOS enabled/disabled) for
    // a set of SSRCs (participant)
    STDMETHODIMP ModifyQOSList(
            DWORD *pdwSSRCList, // array of SSRCs to add/delete
            DWORD dwNumSSRC,    // number of SSRCs passed (0 == flush)
            DWORD dwOperation   // see bits description below
            // bit2=flush bit1=Add(1)/Delete(0) bit0=Enable Add/Delete
            // 1==delete, 3==add(merge), 4==flush, 7==add(replace)
        );
    enum {OP_BIT_ENABLEADDDEL,
          OP_BIT_ADDDEL,
          OP_BIT_FLUSH};

    //-----------------------------------------------------------------------//
    // INonDelegatingUnknown implemented methods                             //
    //-----------------------------------------------------------------------//

    // obtain pointers to active movie and private interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    //-----------------------------------------------------------------------//
    // Event Handling                                                        //
    //-----------------------------------------------------------------------//

    HRESULT HandleCRtpSessionNotify(
            DWORD        dwEventBase,
            DWORD        dwEventType,
            DWORD        dwP_1,
            DWORD        dwP_2
        );
};


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Socket manager class                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// Bits for dwFlag
enum {
    SOCKET_RECV, // Socket for a receiver
    SOCKET_SEND, // Socket for a sender
    SOCKET_LAST,
    
    SOCKET_INIT_RECV, // Initialize as receiver
    SOCKET_INIT_SEND, // Initialize as sender
    SOCKET_INIT_BIND, // Socket has been bound
    
    SOCKET_QOS_SES,   // Belongs to a QOS enabled session
    SOCKET_QOS_RQ,    // QOS is requested in this socket

    SOCKET_RTCPMATCH  // Force RTCP remote port to match
};
#define SOCKET_FIRST SOCKET_RECV
#define SOCKET_RTCP (SOCKET_SEND+1)

#define SOCKET_MASK(b) (1<<(b))
#define SOCKET_MASK_RECV  (SOCKET_MASK(SOCKET_RECV))
#define SOCKET_MASK_SEND  (SOCKET_MASK(SOCKET_SEND))
#define SOCKET_MASK_RS    (SOCKET_MASK_RECV|SOCKET_MASK_SEND)

#define SOCKET_MASK_INIT_RECV  (SOCKET_MASK(SOCKET_INIT_RECV))
#define SOCKET_MASK_INIT_SEND  (SOCKET_MASK(SOCKET_INIT_SEND))
#define SOCKET_MASK_INIT_BIND  (SOCKET_MASK(SOCKET_INIT_BIND))

#define SOCKET_MASK_QOS_SES  (SOCKET_MASK(SOCKET_QOS_SES))
#define SOCKET_MASK_QOS_RQ   (SOCKET_MASK(SOCKET_QOS_RQ))

#define SOCKET_MASK_RTCPMATCH  (SOCKET_MASK(SOCKET_RTCPMATCH))

#define RTPNTOASIZE 20

char *RtpNtoA(DWORD dwAddr, char *sAddr);

//////////////////////////////////////////////////////////////////////
//
// CRtpQOSReserve
//
//////////////////////////////////////////////////////////////////////

// Some bits for CRtpQOSReserve::m_dwFlags
enum {
    FG_RES_CONFIRMATION_REQUEST, // Selects or not to request confirmation
    FG_RES_DEST_ADDR_OBJECT_USED,// DestAddrObject must be issued ONCE
    FG_RES_LAST                  // Dummy flag, ignore
};

// Max QOS filters (aka participants) in the Shared Explicit filter
#define MAX_FILTERS 20

class CRtpQOSReserve
{
private:

    CCritSec          m_cStateLock; // lock for accessing RsvpFilterSpec list

    char              m_QOSclass[MAX_QOS_NAME];// QOS class (audio/video)
    char              m_QOSname[MAX_QOS_NAME]; // QOS template name
    QOS               m_qos;
    DWORD             m_MaxFilters;
    DWORD             m_NumFilters;
    DWORD             m_MaxBandwidth;
    DWORD            *m_pRsvpSSRC;
    RSVP_FILTERSPEC  *m_pRsvpFilterSpec;
    
    // WARNING: The next two member variables MUST remain contiguos memory
    QOS_DESTADDR      m_destaddr;
    SOCKADDR_IN       m_sockin_destaddr;
    
    CShSocket        *m_pCShSocket;
    
    DWORD m_Style;
    DWORD m_dwFlags;

    DWORD m_dwLastReserveTime;
    DWORD m_dwReserveIntervalTime;
public:

    CRtpQOSReserve(CShSocket *pCShSocket, DWORD dwMaxFilters);
    ~CRtpQOSReserve();

    // expose the max number of filters
    inline DWORD GetMaxFilters() { return(m_MaxFilters); }

    // change the max number of filters, flush the current list
    HRESULT SetMaxFilters(DWORD dwMaxFilters);
    
    // change the max target bandwidth
    inline DWORD SetMaxBandwidth(DWORD dwMaxBandwidth)
        { m_MaxBandwidth = dwMaxBandwidth; return(dwMaxBandwidth); }
    
    // Get the number of filters
    inline DWORD GetNumFilters() { return(m_NumFilters); }
    
    // Flush the reservation list
    inline HRESULT FlushFilters() { m_NumFilters = 0; return(NOERROR); }

    // expose the pointer to the SSRCs
    inline DWORD *GetpRsvpSSRC() { return(m_pRsvpSSRC); }

    // Get time (ticks) last reservation was done.
    // This is used only to specify the sender's flow spec
    // at exponentially increasing intervals so the chance for
    // the receiver to receive the PATH message is increased.
    // Once the receiver gets the PATH message, its reservation can succeed
    // and the sender can receive the RECEIVERS QOS notification and
    // then start sending.
    inline DWORD GetLastReserveTime() { return(m_dwLastReserveTime); }

    inline DWORD SetLastReserveTime(DWORD dwLastReserveTime)
        { return(m_dwLastReserveTime = dwLastReserveTime); }

    inline DWORD GetReserveIntervalTime() { return(m_dwReserveIntervalTime); }

    inline DWORD SetReserveIntervalTime(DWORD dwReserveIntervalTime)
        { return(m_dwReserveIntervalTime = dwReserveIntervalTime); }

    
    // Set/Reset one bit in m_dwFlags
    inline void ModifyFlags(DWORD bit, DWORD value)
    { if (value) flags_set(bit);else flags_rst(bit); }

    // Test a flag in m_dwFlags
    inline BOOL TestFlags(DWORD bit) { return(flags_tst(bit)); }

    // expose state lock to other objects
    CCritSec *pStateLock(void) { return &m_cStateLock; }

    // Ask for the template's names (e.g. G711, G723, H261CIF, etc.)
    HRESULT QueryTemplates(char *templates, int size);

    // Get just one template
    HRESULT GetTemplate(char *template_name, char *qosClass, QOS *qos);

    // Set the Sender/Receiver FlowSpec
    HRESULT SetFlowSpec(FLOWSPEC *pFlowSpec, DWORD dwIsSender);

    // Scale a flow spec
    HRESULT ScaleFlowSpec(FLOWSPEC *pFlowSpec,
                          DWORD     dwNumParticipants,
                          DWORD     dwMaxParticipants,
                          DWORD     dwBandwidth);
    
    // Select the style to be used (e.g. WF, FF, SEF)
    inline
    DWORD SetStyle(DWORD dwStyle) { return(m_Style = dwStyle); }

    // Get the reservation style used (e.g. WF, FF, SEF)
    inline
    DWORD GetStyle() { return(m_Style); }

    // Set the destination address (required for unicast)
    HRESULT SetDestAddr(LPBYTE pbDestAddr, DWORD dwAddrLen);
    
    // Select to have or not reservation confirmation
    inline
    HRESULT ConfirmRequest(DWORD dwConfirmRequest)
        { if (dwConfirmRequest)
            fg_set(m_dwFlags, FG_RES_CONFIRMATION_REQUEST);
        else
            fg_rst(m_dwFlags, FG_RES_CONFIRMATION_REQUEST);
        return(NOERROR); }

    // Find out if an SSRC is in the reservation list or not
    DWORD FindSSRC(DWORD ssrc);

    // Add/Delete one SSRC (participant) to the Shared Explicit Filter (SEF)
    HRESULT AddDeleteSSRC(DWORD ssrc, DWORD dwAddDel);

    // DO the reservation
    HRESULT Reserve(DWORD dwIsSender);

    // Set reservation to NO TRAFFIC
    HRESULT Unreserve(DWORD dwIsSender);

    // Ask for permission to send
    HRESULT AllowedToSend();
    
    // Inquire about the link's speed
    HRESULT LinkSpeed(DWORD *pdwLinkSpeed);

    // Inquire about the estimated available bandwidth
    HRESULT EstimatedAvailableBandwidth(DWORD *pdwBandwidth);
};


//////////////////////////////////////////////////////////////////////
//
// CShSocket
//
//////////////////////////////////////////////////////////////////////

// Some bits for CShSocket::m_dwFlags
enum {
    FG_SOCK_ENABLE_NOTIFY_RECV,  // Enable notifications for the receiver
    FG_SOCK_ENABLE_NOTIFY_SEND,  // Enable notifications for the sender
    FG_SOCK_LAST                 // Dummy flag, ignore.
};

#define LOCAL  0   // local addr/port
#define REMOTE 1   // remote addr/port

class CShSocket
{
    friend CSocketManager;

protected:
    LIST_ENTRY          Link;
    CRtpSession        *m_pCRtpSession[2];
    CRtpSession        *m_pCRtpSession2[2];

private:
    DWORD               m_dwAddr[2]; // NETWORK order (local and remote addr)
    WORD                m_wPort[2];  // NETWORK order (local and remote port)
    SOCKET              m_Socket;
    long                m_MaxCount[2];
    long                m_RefCount[2];
    DWORD               m_dwCookie;  // used to match sockets
    DWORD               m_dwKind;
    DWORD               m_dwFlags;
    RTP_SESSION        *m_pRTPSession; // RTP session this socket belongs to
    
    // thread starting QOS notifycations
    CRtpQOSReserve                  *m_pCRtpQOSReserve;
    
public:
    CShSocket(DWORD               dwRemAddr,
              long               *plMaxShare,
              WSAPROTOCOL_INFO   *pProtocolInfo,
              DWORD               dwMaxFilters,
              HRESULT            *phr);
    
    ~CShSocket();
    HRESULT CloseSocket();
    
    inline SOCKET GetShSocket() { return(m_Socket); }

    HRESULT ShSocketStopQOS(DWORD dwIsSender);
    
    inline CRtpQOSReserve *GetpCRtpQOSReserve()
    { return(m_pCRtpQOSReserve); }
    
    inline CRtpSession *GetpCRtpSession(DWORD sel)
        {
            if (!sel && m_pCRtpSession[0])
                return(m_pCRtpSession[0]);
            else if (sel == 1 && m_pCRtpSession[1])
                return(m_pCRtpSession[1]);
            else if (m_pCRtpSession[0])
                return(m_pCRtpSession[0]);
            else
                return(m_pCRtpSession[1]);
        }

    inline CRtpSession *GetpCRtpSession2(DWORD sel)
        {
            if (!sel && m_pCRtpSession2[0])
                return(m_pCRtpSession2[0]);
            else if (sel == 1 && m_pCRtpSession2[1])
                return(m_pCRtpSession2[1]);
            else if (m_pCRtpSession2[0])
                return(m_pCRtpSession2[0]);
            else
                return(m_pCRtpSession2[1]);
        }

    // Set/Reset one bit in m_dwFlags
    inline void ModifyFlags(DWORD bit, DWORD value)
    { if (value) flags_set(bit);else flags_rst(bit); }

    // Test a flag in m_dwFlags
    inline BOOL TestFlags(DWORD bit) { return(flags_tst(bit)); }

    // Set/Get the RTP session this soicket belongs to
    inline RTP_SESSION *SetRTPSession(RTP_SESSION *pRTPSession)
    { return( m_pRTPSession = pRTPSession ); }
    inline RTP_SESSION *GetRTPSession()
    { return(m_pRTPSession); }

protected:
    inline void  SetAddress(DWORD loc_rem, DWORD dwAddr)
        { m_dwAddr[loc_rem] = dwAddr; }
    inline void  SetPort(DWORD loc_rem, WORD wPort)
        { m_wPort[loc_rem] = wPort; }

    inline DWORD GetAddress(DWORD loc_rem)    { return(m_dwAddr[loc_rem]); }
    inline WORD  GetPort(DWORD loc_rem)        { return(m_wPort[loc_rem]); }

    inline DWORD GetCookie() { return(m_dwCookie); }
    inline void SetCookie(DWORD cookie) { m_dwCookie = cookie; }
    
    inline DWORD GetKind() { return(m_dwKind); }
    inline DWORD TstKind(DWORD dwKind) { return((m_dwKind & dwKind) != 0); }
    inline void  SetKind(DWORD dwKind) { m_dwKind |= dwKind; }
    inline void  RstKind(DWORD dwKind) { m_dwKind &= ~dwKind; }

    inline DWORD GetInit(DWORD type) { return((m_dwKind & type) != 0); }
    inline DWORD SetInit(DWORD type) { return(m_dwKind |= type); }

    inline long AddRefCount(DWORD kind)
    { return(InterlockedIncrement(&m_RefCount[kind])); }
    inline long DelRefCount(DWORD kind)
    { return(InterlockedDecrement(&m_RefCount[kind])); }
    inline long GetRefCount(DWORD kind)
    { return(m_RefCount[kind]); }
    inline long GetRefCountAll()
    { return(m_RefCount[SOCKET_RECV] + m_RefCount[SOCKET_SEND]); }

    inline long GetRefCountRecv() { return(m_RefCount[SOCKET_RECV]); }
    inline long GetRefCountSend() { return(m_RefCount[SOCKET_SEND]); }
    
    inline long AddRefRecv()
    { return(InterlockedIncrement(&m_RefCount[SOCKET_RECV])); }
    inline long DelRefRecv()
    { return(InterlockedDecrement(&m_RefCount[SOCKET_RECV])); }
    inline long AddRefSend()
    { return(InterlockedIncrement(&m_RefCount[SOCKET_SEND])); }
    inline long DelRefSend()
    { return(InterlockedDecrement(&m_RefCount[SOCKET_SEND])); }

    inline long GetMaxCount(DWORD kind)
    { return(m_MaxCount[kind]); }

    inline DWORD IsQOSEnabled()
    { return((m_dwKind & SOCKET_MASK(SOCKET_QOS_RQ)) != 0); }
    inline DWORD IsQOSSession()
    { return((m_dwKind & SOCKET_MASK(SOCKET_QOS_SES)) != 0); }
};

class CSocketManager
{
    LIST_ENTRY   m_SharedSockets;  // list of shared sockets
    CCritSec     m_cStateLock;     // lock for accessing list

public:

    // constructor
    CSocketManager(void);

    // destructor
    ~CSocketManager(void);

    // expose state lock to other objects
    CCritSec * pStateLock(void) { return &m_cStateLock; }

    DWORD
    GetSocket(
            SOCKET              *pSocket,
            struct sockaddr_in  *pAddr,
            struct sockaddr_in  *pLocalAddr,
            DWORD                dwScope,
            DWORD                dwKind,
            WSAPROTOCOL_INFO    *pProtocolInfo
        );

    DWORD
    ReleaseSocket(
            SOCKET               Socket
        );


    DWORD
    GetSharedSocket(
            CShSocket          **ppCShSocket,
            long                *pMaxShare,
            DWORD                cookie,
            DWORD               *pAddr, 
            WORD                *pPort, 
            DWORD                dwScope,
            DWORD                dwKind,
            WSAPROTOCOL_INFO    *pProtocolInfo,
            DWORD                dwMaxFilters,
            CRtpSession         *pCRtpSession
        );

    DWORD 
    ReleaseSharedSocket(
            CShSocket           *pCShSocket,
            DWORD                dwKind,
            CRtpSession         *pCRtpSession
        );
};

#endif // _INC_CLASSES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\dialogs.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    dialogs.h

Abstract:

    Dialog definitions for ActiveMovie RTP Network Filters.

Environment:

    User Mode - Win32

Revision History:

    02-Dec-1996 DonRyan
        Created.

--*/
 
#ifndef _INC_DIALOGS
#define _INC_DIALOGS

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Dialog IDs                                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define IDSBASE_AMRTPNET                3000

#define IDS_RTPPROPERTIES               3001
#define IDD_RTPPROPERTIES               3001
#define IDC_RTPADDR                     3002
#define IDC_RTPPORT                     3003
#define IDC_RTCPADDR                    3004
#define IDC_RTCPPORT                    3005
#define IDC_RTCPONOFF                   3006
#define IDC_USERNAME                    3007
#define IDC_SCOPE                       3008
#define IDC_QOS                         3009
#define IDC_MCLOOPBACK                  3010
#define IDC_STATIC                      -1

#endif // _INC_DIALOGS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpdmx\rtpdtype.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : RTPDType.h
// Purpose  : Define the types used internally by the RTP Demux filter.
// Contents : 
//*M*/

#ifndef _RTPDTYPE_H_
#define _RTPDTYPE_H_

// Need to predeclare this because this header is included before RTPDemux.h
class CRTPDemuxOutputPin;

/*D*
//  Name    : SSRCRecord_t
//  Purpose : Stores information about a SSRC that the RTP Demux filter
//            is currently aware of.
//  Fields  :
//      bPT     Last recorded payload type for this SSRC. 0 if unknown.
//      pPin    The output pin this SSRC is currently mapped to. NULL if unmapped.
*D*/
typedef struct  {
    BYTE                bPT;
    DWORD               m_dwFlag;
    CRTPDemuxOutputPin  *pPin;
} SSRCRecord_t;

                                                            
/*D*
//  Name    : SSRCRecordMap_t
//  Purpose : Used to keep track of SSRCs that the RTP demux
//            filter has received.  A single instance of it exists in the RTP Demux filter.
*D*/
typedef map<DWORD, SSRCRecord_t, less<DWORD> >              SSRCRecordMap_t;
typedef SSRCRecordMap_t::iterator                           SSRCRecordMapIterator_t;


typedef struct {
    BYTE                bPT;
    CRTPDemuxOutputPin  *pPin;
    GUID                mtsSubtype;
    DWORD               dwTimeout;
    BOOL                bAutoMapping;
	DWORD				dwPinNumber;  // ZCS 7-18-97
} IPinRecord_t;

/*D*
//  Name    : IPinRecordMap_t
//  Purpose : Used to figure out what output pin an app is talking
//            to when it calls one of the IIntelRTPDemuxFilter methods which accept an 
//            IPin as an in parameter. Since we cannot safely cast an IPin to a
//            CRTPDemuxOutputPin (because the app might pass us a different IPin
//            by mistake), this is our only option.
*D*/
typedef map <IPin *, IPinRecord_t, less<IPin *> >   IPinRecordMap_t;
typedef IPinRecordMap_t::iterator                   IPinRecordMapIterator_t;


#define PT_VALUE(pBuffer)   static_cast<BYTE>((reinterpret_cast<BYTE *>(pBuffer))[1] & 0x7F)
#define SSRC_VALUE(pBuffer) (ntohl(static_cast<DWORD>((reinterpret_cast<DWORD *>(pBuffer))[2])))

#define PAYLOAD_G711U   0
#define PAYLOAD_G711A   8
#define PAYLOAD_G723    4
#define PAYLOAD_H261    31
#define PAYLOAD_H263    34
#define PAYLOAD_SR      200
#define PAYLOAD_INVALID 255

#define CURRENT_PERSISTENCE_FILE_VERSION 1

#define szRegAMRTPKey				TEXT("SOFTWARE\\Intel\\ActiveMovie Filters")

#endif _RTPDTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpdmx\template.h ===
/*********************************************************************
 *
 * Copyright (c) 1997 Microsoft Corporation
 *
 * File: amrtpdmx\template.h
 *
 * Abstract:
 *     Macros to define CFactoryTemplate templates
 *
 * History:
 *     10/23/97    Created by AndresVG
 *
 **********************************************************************/
#if !defined(_AMRTPDMX_TEMPLATE_H_)
#define      _AMRTPDMX_TEMPLATE_H_

#if defined(AMRTPDMX_IN_DXMRTP)
extern void RtpDemuxRegisterResources();
#endif

#define RTP_DEMUX_FILTER        L"Intel RTP Demux Filter"
#define RTP_DEMUX_FILTER_PROP   L"Intel RTP Demux Filter Property Page"

#define CFT_AMRTPDMX_DMX_FILTER \
{ \
	  RTP_DEMUX_FILTER, \
      &CLSID_IntelRTPDemux, \
      CRTPDemux::CreateInstance, \
      NULL, \
      &g_RTPDemuxFilter \
	  }

#define CFT_AMRTPDMX_DMX_FILTER_PROP \
{ \
	  RTP_DEMUX_FILTER_PROP, \
      &CLSID_IntelRTPDemuxPropertyPage, \
      CRTPDemuxPropertyPage::CreateInstance \
	  }

#define CFT_AMRTPDMX_ALL_FILTERS \
CFT_AMRTPDMX_DMX_FILTER, \
CFT_AMRTPDMX_DMX_FILTER_PROP

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpdmx\ssrcenum.h ===
///*M*
// INTEL CORPORATION PROPRIETARY INFORMATION
// This software is supplied under the terms of a licence agreement or
// nondisclosure agreement with Intel Corporation and may not be copied
// or disclosed except in accordance with the terms of that agreement.
// Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
// Filename : SSRCEnum.h
// Purpose  : Define the class that implements the IEnumSSRCs interface
//            along with a SSRC enumerator.
// Contents : 
//      class CSSRCEnum     SSRC Enumerator Class that implements IEnumSSRCs.
//*M*/

#ifndef _SSRCENUM_H_
#define _SSRCENUM_H_

/*C*
//  Name    : CSSRCEnum
//  Purpose : Implements the IEnumSSRC interface
//  Context : Used in EnumSSRCs() in the RTP Demux filter.
*C*/
class 
CSSRCEnum
: public CUnknown,
  public IEnumSSRCs
{
public:
    // Constructor and destructor
    CSSRCEnum(
        CRTPDemux               *m_pFilter,
        SSRCRecordMapIterator_t iCurrentSSRCEntry);
    ~CSSRCEnum();

    DECLARE_IUNKNOWN 
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // IEnumSSRCs implementation
    STDMETHODIMP Next(
        ULONG       cSSRCs,
        DWORD       *pdwSSRCs,
        ULONG       *pcFetched);
    STDMETHODIMP Skip(
        ULONG       cSSRCs);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(
        IEnumSSRCs  **ppEnum);

private:
    BOOL AreWeOutOfSync() {
        return (m_pFilter->GetPinVersion() == m_iVersion ? FALSE : TRUE);
    };

    int                     m_iVersion;
    SSRCRecordMapIterator_t  m_iCurrentSSRC;
    CRTPDemux               *m_pFilter;
}; /* class CSSRCEnum */

#endif _SSRCENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\globals.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    globals.cpp

Abstract:

    Global data for ActiveMovie RTP Network Filters.

Environment:

    User Mode - Win32

Revision History:

    06-Nov-1996 DonRyan
        Created.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <winsock2.h>   // must include instead of windows.h
#include <streams.h>

#if !defined(AMRTPNET_IN_DXMRTP)
#include <initguid.h>   // add GUIDs to this module...
#define INITGUID
#endif

#include "globals.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ActiveMovie Setup Information                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

AMOVIESETUP_MEDIATYPE g_RtpInputType = { 
    &MEDIATYPE_RTP_Single_Stream,           // clsMajorType
    &MEDIASUBTYPE_NULL                      // clsMinorType 
}; 

AMOVIESETUP_MEDIATYPE g_RtpOutputType = {
#if defined(USE_H263)
    &MEDIATYPE_RTP_Single_Stream,	    // clsMajorType
    &MEDIASUBTYPE_RTP_Payload_H263	    // clsMinorType
#elif defined(USE_H261)
    &MEDIATYPE_RTP_Single_Stream,	    // clsMajorType
    &MEDIASUBTYPE_RTP_Payload_H261	    // clsMinorType
#elif defined(USE_G711U)
    &MEDIATYPE_RTP_Single_Stream,	    // clsMajorType
    &MEDIASUBTYPE_RTP_Payload_G711U	    // clsMinorType
#else
    &MEDIATYPE_RTP_Multiple_Stream,	    // clsMajorType
    &MEDIASUBTYPE_RTP_Payload_Mixed	    // clsMinorType
#endif
}; 

AMOVIESETUP_PIN g_RtpInputPin = { 
    RTP_PIN_INPUT,                          // strName
    FALSE,                                  // bRendered
    FALSE,                                  // bOutput
    FALSE,                                  // bZero
    TRUE,                                   // bMany
    &CLSID_NULL,                            // clsConnectsToFilter
    RTP_PIN_ANY,                            // strConnectsToPin
    1,                                      // nTypes
    &g_RtpInputType                         // lpTypes
};

AMOVIESETUP_PIN g_RtpOutputPin = {
    RTP_PIN_OUTPUT,                         // strName
    FALSE,                                  // bRendered
    TRUE,                                   // bOutput
    FALSE,                                  // bZero
    FALSE,                                  // bMany
    &CLSID_NULL,                            // clsConnectsToFilter
    RTP_PIN_ANY,                            // strConnectsToPin
    1,                                      // nTypes
    &g_RtpOutputType                        // lpTypes
};

AMOVIESETUP_FILTER g_RtpRenderFilter = { 
    &CLSID_RTPRenderFilter,                 // clsID
    RTP_RENDER_FILTER,                        // strName
    MERIT_DO_NOT_USE, //MERIT_UNLIKELY,                         // dwMerit
    1,                                      // nPins
    &g_RtpInputPin                          // lpPin
}; 

AMOVIESETUP_FILTER g_RtpSourceFilter = { 
    &CLSID_RTPSourceFilter,                 // clsID
    RTP_SOURCE_FILTER,                      // strName
    MERIT_DO_NOT_USE, //MERIT_UNLIKELY,                         // dwMerit
    1,                                      // nPins
    &g_RtpOutputPin                         // lpPin
};                              


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ActiveMovie Templates (used directly by ActiveMovie framework code)       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#if !defined(AMRTPNET_IN_DXMRTP)

CFactoryTemplate g_Templates[] = {
	CFT_AMRTPNET_ALL_FILTERS
};

int g_cTemplates = (sizeof(g_Templates)/sizeof(g_Templates[0]));

#endif


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Filter Vendor Information                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

WCHAR g_VendorInfo[] = RTP_FILTER_VENDOR_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\props.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    props.cpp

Abstract:

    Implementation of CRtpRenderFilterProperties class.

Environment:

    User Mode - Win32

Revision History:

    02-Dec-1996 DonRyan
        Created.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "dialogs.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRtpRenderFilterProperties Implementation                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRtpRenderFilterProperties::CRtpRenderFilterProperties(
    LPUNKNOWN pUnk, 
    HRESULT * phr
    )

/*++

Routine Description:

    Constructor for CRtpRenderFilterProperties class.    

Arguments:

    pUnk - IUnknown interface of the delegating object. 

    phr - pointer to the general OLE return value. 

Return Values:

    Returns an HRESULT value.

--*/

:   CBasePropertyPage(
      NAME("CRtpRenderFilterProperties"), 
      pUnk, 
      IDD_RTPPROPERTIES,
      IDS_RTPPROPERTIES
      ),
      m_pRtpStream(NULL),
      m_RtpScope(1)
{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpRenderFilterProperties::CRtpRenderFilterProperties")
        ));

    // initialize addresses to zero
    ZeroMemory(&m_RtpAddr, sizeof(m_RtpAddr));
}


CRtpRenderFilterProperties::~CRtpRenderFilterProperties(
    )

/*++

Routine Description:

    Destructor for CRtpRenderFilterProperties class.    

Arguments:

    None.

Return Values:

    None.

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpRenderFilterProperties::~CRtpRenderFilterProperties")
        ));

    //
    // nothing to do here...
    //
}


CUnknown * 
CRtpRenderFilterProperties::CreateInstance(
    LPUNKNOWN pUnk, 
    HRESULT * phr
    )

/*++

Routine Description:

    Called by COM to create a CRtpRenderFilterProperties object.    

Arguments:

    pUnk - pointer to the owner of this object. 

    phr - pointer to an HRESULT value for resulting information. 

Return Values:

    None.

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpRenderFilterProperties::CreateInstance")
        ));

    CRtpRenderFilterProperties * pNewObject;

    // attempt to create rtp properties object
    pNewObject = new CRtpRenderFilterProperties(pUnk, phr);

    // validate pointer
    if (pNewObject == NULL) {

        DbgLog((
            LOG_ERROR, 
            LOG_ALWAYS, 
            TEXT("Could not create CRtpRenderFilterProperties")
            ));

        // return default
        *phr = E_OUTOFMEMORY;
    }

    // return object
    return pNewObject;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CBasePropertyPage overrided methods                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT 
CRtpRenderFilterProperties::OnConnect(
    IUnknown * pUnk
    )

/*++

Routine Description:

    Called when the property page is connected to the filter. 
    
Arguments:

    pUnk - pointer to the filter associated with this object. 

Return Values:

    Returns an HRESULT value.

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpRenderFilterProperties::OnConnect")
        ));

    // obtain pointer to interface
    HRESULT hr = pUnk->QueryInterface(
                    IID_IRTPStream,
                    (void **)&m_pRtpStream
                    );

    // validate
    if (FAILED(hr)) {
        
        DbgLog((
            LOG_ERROR, 
            LOG_ALWAYS, 
            TEXT("QueryInterface returns 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    DWORD AddrLen;
    
    // initialize     
    AddrLen = sizeof(m_RtpAddr);

    // obtain current rtp address
    if ( ((CRtpSession *)m_pRtpStream)->IsSender() ) {
        // sender
        hr = m_pRtpStream->GetAddress(NULL,
                                      &m_RtpAddr.sin_port,
                                      &m_RtpAddr.sin_addr.s_addr);
    } else {
        // receiver
        hr = m_pRtpStream->GetAddress(&m_RtpAddr.sin_port,
                                      NULL,
                                      &m_RtpAddr.sin_addr.s_addr);
    }

    // validate
    if (FAILED(hr)) {
        
        DbgLog((
            LOG_ERROR, 
            LOG_ALWAYS, 
            TEXT("IRTPStream::GetAddress returns 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    // obtain current scope
    hr = m_pRtpStream->GetMulticastScope(&m_RtpScope);

    // validate
    if (FAILED(hr)) {
        
        DbgLog((
            LOG_ERROR, 
            LOG_ALWAYS, 
            TEXT("IRTPStream::GetScope returns 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    // obtain current QOS state
    hr = m_pRtpStream->GetQOSstate(&m_QOSstate);

    // validate
    if (FAILED(hr)) {
        
        DbgLog((
                LOG_ERROR, 
                LOG_ALWAYS, 
                TEXT("IRTPStream::GetQOSstate returns 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    // obtain current Multicast Loopback state
    hr = m_pRtpStream->GetMulticastLoopBack(&m_MulticastLoopBack);

    // validate
    if (FAILED(hr)) {
        
        DbgLog((
                LOG_ERROR, 
                LOG_ALWAYS, 
                TEXT("IRTPStream::GetMulticastLoopBack returns 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    return S_OK;
}


HRESULT 
CRtpRenderFilterProperties::OnDisconnect(
    )

/*++

Routine Description:

    Called when the property page is disconnected from the owning filter. 
    
Arguments:

    None. 

Return Values:

    Returns an HRESULT value.

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpRenderFilterProperties::OnDisconnect")
        ));

    // validate pointer    
    if (m_pRtpStream != NULL) {

        // decrement ref count
        m_pRtpStream->Release();    

        // re-initialize
        m_pRtpStream = NULL;
    }

    return S_OK; 
}


HRESULT 
CRtpRenderFilterProperties::OnActivate(
    )

/*++

Routine Description:

    Called when the property page is activated. 
    
Arguments:

    None. 

Return Values:

    Returns an HRESULT value.

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpRenderFilterProperties::OnActivate")
        ));

    return InitControls();; 
}


HRESULT 
CRtpRenderFilterProperties::OnDeactivate(
    )

/*++

Routine Description:

    Called when the property page is dismissed. 
    
Arguments:

    None. 

Return Values:

    Returns an HRESULT value.

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpRenderFilterProperties::OnDeactivate")
        ));

    return S_OK; 
}


HRESULT 
CRtpRenderFilterProperties::OnApplyChanges(
    )

/*++

Routine Description:

    Called when the user applies changes to the property page. 
    
Arguments:

    None. 

Return Values:

    Returns an HRESULT value.

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpRenderFilterProperties::OnApplyChanges")
        ));

    // ZCS 7-9-97: if the session is joined then all the fields
    // are disabled and the user couldn't have changed anything,
    // so there is nothing to set. (without this check, we will just fail,
    // which keeps apply and ok from working right)
    if ( ( (CRtpSession *) m_pRtpStream ) -> IsJoined() )
        return S_OK;

    LPSTR pAddr;
    BOOL fTrans;
    CHAR String[255];
    HRESULT hr;
    
    // retrieve rtp address
    GetDlgItemText(m_Dlg, IDC_RTPADDR, String, sizeof(String));
    
    // convert address to unsigned long    
    m_RtpAddr.sin_addr.s_addr = inet_addr(String);

    // retrieve rtp port control (unsigned)
    m_RtpAddr.sin_port = htons((short)GetDlgItemInt(m_Dlg, IDC_RTPPORT, &fTrans, FALSE));
    
    // attempt to modify the rtp address
    hr = m_pRtpStream->SetAddress(m_RtpAddr.sin_port,
                                  m_RtpAddr.sin_port,
                                  m_RtpAddr.sin_addr.s_addr);

    // validate
    if (FAILED(hr)) {
        
        DbgLog((
            LOG_ERROR, 
            LOG_ALWAYS, 
            TEXT("IRTPStream::SetAddress returns 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    // retrieve multicast scope from dialog
    m_RtpScope = GetDlgItemInt(m_Dlg, IDC_SCOPE, &fTrans, FALSE);

    // attempt to modify the scope
    hr = m_pRtpStream->SetMulticastScope(m_RtpScope);

    // validate
    if (FAILED(hr)) {
        
        DbgLog((
            LOG_ERROR, 
            LOG_ALWAYS, 
            TEXT("IRTPStream::SetScope returns 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    // retrive QOS state from dialog
    m_QOSstate = (DWORD)SendDlgItemMessage(m_Dlg, IDC_QOS, BM_GETCHECK, 0, 0);

    // attempt to modify the QOS state
    hr = m_pRtpStream->SetQOSstate(m_QOSstate);

    // validate
    if (FAILED(hr)) {
        
        DbgLog((
                LOG_ERROR, 
                LOG_ALWAYS, 
                TEXT("IRTPStream::SetQOSstate returns 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    // retrive Multicsat Loopback state from dialog
    m_MulticastLoopBack = (DWORD)SendDlgItemMessage(m_Dlg, IDC_MCLOOPBACK, BM_GETCHECK, 0, 0);

    // attempt to modify the Multicast Loopback state
    hr = m_pRtpStream->SetMulticastLoopBack(m_MulticastLoopBack);

    // validate
    if (FAILED(hr)) {
        
        DbgLog((
                LOG_ERROR, 
                LOG_ALWAYS, 
                TEXT("IRTPStream::SetMulticastLoopBack returns 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    return S_OK; 
}


INT_PTR 
CRtpRenderFilterProperties::OnReceiveMessage(
    HWND   hwnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Called when a message is sent to the property page dialog box window. 
    
Arguments:

    hwnd - window procedure that received the message. 

    uMsg - message. 

    wParam - additional message information. 

    lParam - additional message information. 

Return Values:

    Return value is the result of message processing and depends on message. 

--*/

{
#if 0
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpRenderFilterProperties::OnReceiveMessage")
        ));
#endif

    // check to see if anybody mucked with the values
    if ((uMsg == WM_COMMAND) && (HIWORD(wParam) == EN_CHANGE)) {

        // change state
        m_bDirty = TRUE;

        // notify site        
        if (m_pPageSite)
            m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);

        return (LRESULT)1;
    }

    // simply pass this along to the base class to process
    return CBasePropertyPage::OnReceiveMessage(hwnd, uMsg, wParam, lParam);
}


HRESULT
CRtpRenderFilterProperties::InitControls(
    )

/*++

Routine Description:

    Initializes property page dialog.
    
Arguments:

    None.

Return Values:

    Returns an HRESULT value.

--*/

{
    DbgLog((
            LOG_TRACE, 
            LOG_ALWAYS, 
            TEXT("CRtpRenderFilterProperties::InitControls")
        ));

    LPSTR pAddr;
    CHAR String[255];
    DWORD StringLen;

    // initialize string length
    StringLen = sizeof(String);
    
    // attempt to retrieve user name    
    if (GetUserName(String, &StringLen)) {

        // update user name control 
        SetDlgItemText(m_Dlg, IDC_USERNAME, String);
    }

    // initialize rtp address
    RtpNtoA(m_RtpAddr.sin_addr.s_addr, String);

    // update rtp address control
    SetDlgItemText(m_Dlg, IDC_RTPADDR, String);
    
    // update rtp port control (unsigned)
    SetDlgItemInt(m_Dlg, IDC_RTPPORT, ntohs(m_RtpAddr.sin_port), FALSE);
    
    // update multicast scope
    SetDlgItemInt(m_Dlg, IDC_SCOPE, m_RtpScope, FALSE);

    // update QOS state
    SendDlgItemMessage(m_Dlg, IDC_QOS, BM_SETCHECK, m_QOSstate, 0);

    // update Multicast Loopback state
    SendDlgItemMessage(m_Dlg, IDC_MCLOOPBACK, BM_SETCHECK, m_MulticastLoopBack, 0);

    // ZCS 7-9-97: disallow changes to these parameters if the session is joined
    if ( ( (CRtpSession *) m_pRtpStream ) -> IsJoined() )
        EnableWindow(m_Dlg, FALSE);
    else
        EnableWindow(m_Dlg, TRUE);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\input.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    input.cpp

Abstract:

    Implementation of CRtpInputPin class.

Environment:

    User Mode - Win32

Revision History:

    06-Nov-1996 DonRyan
        Created.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRtpInputPin Implementation                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRtpInputPin::CRtpInputPin(
    CRtpRenderFilter * pFilter,
    LPUNKNOWN         pUnk,  
    HRESULT *         phr
    )

/*++

Routine Description:

    Constructor for CRtpInputPin class.    

Arguments:

    pFilter - pointer to associated filter object.

    pUnk - IUnknown interface of the delegating object. 

    phr - pointer to the general OLE return value. 

Return Values:

    Returns an HRESULT value. 

--*/

:   CRenderedInputPin(
        NAME("CRtpInputPin"),
        pFilter,                   
        pFilter->pStateLock(),                     
        phr,                       
        RTP_PIN_INPUT              
        ),                 
    m_pFilter(pFilter),
	m_dwFlag(0)
{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpInputPin::CRtpInputPin")
        ));

    // create rtp session object as sending participant
    m_pRtpSession = new CRtpSession(GetOwner(), phr, TRUE,
									(CBaseFilter *)pFilter);

	if (FAILED(*phr)) {
		DbgLog((
				LOG_ERROR,
				LOG_DEVELOP,
				TEXT("CRtpInputPin::CRtpInputPin: "
					 "new CRtpSession() failed: 0x%X"),
				*phr
			));
		return;
	}
	
    // validate pointer
    if (m_pRtpSession == NULL) {

        DbgLog((
            LOG_ERROR, 
            LOG_DEVELOP, 
            TEXT("Could not create CRtpSession")
            ));

        // return default 
        *phr = E_OUTOFMEMORY;

        return; // bail...
    }

    // add pin to filter
	// BUGBUG, no error is being checked here
    m_pFilter->AddPin(this);
}


CRtpInputPin::~CRtpInputPin(
    )

/*++

Routine Description:

    Destructor for CRtpInputPin class.    

Arguments:

    None.

Return Values:

    None.

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpInputPin::~CRtpInputPin")
        ));

    // nuke session
    delete m_pRtpSession;

    // remove pin from filter
    m_pFilter->RemovePin(this);    
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRenderedInputPin overrided methods                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT 
CRtpInputPin::Active(
    )

/*++

Routine Description:

    Called by the CBaseFilter implementation when the state changes 
    from stopped to either paused or running. 

Arguments:

    None. 

Return Values:

    Returns an HRESULT value. 

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpInputPin::Active")
        ));

    // join multimedia session 
    HRESULT hr = m_pRtpSession->Join();

	// Make priority be reset again.
	// It may have been changed while in STOP
	m_dwFlag &= ~FLAG_INPUT_PIN_PRIORITYSET;
	
    // validate
    if (FAILED(hr)) {

        DbgLog((
            LOG_ERROR, 
            LOG_ALWAYS, 
            TEXT("CRtpSession::Join returned 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    // now call base class
    hr = CRenderedInputPin::Active();

    // validate
    if (FAILED(hr)) {

        DbgLog((
            LOG_ERROR, 
            LOG_ALWAYS, 
            TEXT("CRenderedInputPin::Active returned 0x%08lx"), hr
            ));
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CBaseInputPin overrided methods                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT 
CRtpInputPin::Inactive(
    )

/*++

Routine Description:

    Called by the CBaseFilter implementation when the state changes 
    from either paused or running to stopped. 

Arguments:

    None. 

Return Values:

    Returns an HRESULT value. 

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpInputPin::Inactive")
        ));

    // leave multimedia session 
    HRESULT hr = m_pRtpSession->Leave();

    // validate
    if (FAILED(hr)) {

        DbgLog((
            LOG_ERROR, 
            LOG_ALWAYS, 
            TEXT("CRtpSession::Leave returned 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    // now call base class
    hr = CRenderedInputPin::Inactive();

    // validate
    if (FAILED(hr)) {

        DbgLog((
            LOG_ERROR, 
            LOG_ALWAYS, 
            TEXT("CRenderedInputPin::Inactive returned 0x%08lx"), hr
            ));
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CBasePin overrided methods                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT 
CRtpInputPin::CheckMediaType(
    const CMediaType * pmt
    )

/*++

Routine Description:

    Determines if the pin can support a specific media type. 

Arguments:

    pmt - pointer to a media type object containing the proposed media type. 

Return Values:

    Returns an HRESULT value. 

--*/

{
#ifdef DEBUG_CRITICAL_PATH

    DbgLog((
        LOG_TRACE, 
        LOG_CRITICAL, 
        TEXT("CRtpInputPin::CheckMediaType")
        ));

#endif // DEBUG_CRITICAL_PATH

    // only accept media that is of type rtp stream
    return (*(pmt->Type()) == *g_RtpInputType.clsMajorType) 
                ? S_OK 
                : E_INVALIDARG
                ;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IMemInputPin implemented methods                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRtpInputPin::Receive(
    IMediaSample * pSample
    )

/*++

Routine Description:

    Retrieves next block of data from the stream. 

Arguments:

    pSample - pointer to a media sample. 

Return Values:

    Returns an HRESULT value. 

--*/

{
#ifdef DEBUG_CRITICAL_PATH
	
    DbgLog((
        LOG_TRACE, 
        LOG_CRITICAL, 
        TEXT("CRtpInputPin::Receive")
        ));

#endif // DEBUG_CRITICAL_PATH
	
    // check all is well with the base class
    HRESULT hr = CBaseInputPin::Receive(pSample);

    // validate
    if (FAILED(hr)) {
        
        DbgLog((
            LOG_ERROR, 
            LOG_ALWAYS, 
            TEXT("CBaseInputPin::Receive returned 0x%08lx"), hr
            ));
        
        return hr; // bail...
    }

    // forward sample to session object
	if (!(m_dwFlag & FLAG_INPUT_PIN_PRIORITYSET)) {
		m_dwFlag |= FLAG_INPUT_PIN_PRIORITYSET;
		long Class, Priority;
		m_pRtpSession->GetSessionClassPriority(&Class, &Priority);

#if defined(DEBUG)
		{
			HANDLE cThread = GetCurrentThread();
			int tPrio1 = GetThreadPriority(cThread);

			SetThreadPriority(cThread, Priority);

			int tPrio2 = GetThreadPriority(cThread);
		
			DbgLog((
					LOG_TRACE, 
					LOG_DEVELOP, 
					TEXT("CRtpInputPin::Receive: "
						 "ThreadH: %d (0x%X), Class: %d, Priority: %d,%d,%d"),
					cThread, cThread,
					Class, tPrio1, Priority, tPrio2
				));
		}
#else	
		SetThreadPriority(GetCurrentThread(), Priority);
#endif		
	}
	
    return m_pRtpSession->SendTo(pSample);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// INonDelegatingUnknown implemented methods                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRtpInputPin::NonDelegatingQueryInterface(
    REFIID riid, 
    void ** ppv
    )

/*++

Routine Description:

    Returns an interface and increments the reference count.

Arguments:

    riid - reference identifier. 

    ppv - pointer to the interface. 

Return Values:

    Returns a pointer to the interface.

--*/

{
#ifdef DEBUG_CRITICAL_PATH
	
    DbgLog((
        LOG_TRACE, 
        LOG_CRITICAL, 
        TEXT("CRtpInputPin::NonDelegatingQueryInterface")
        ));

#endif // DEBUG_CRITICAL_PATH
	
    // validate pointer
    CheckPointer(ppv,E_POINTER);

    // forward rtp and rtcp stream queries to session object
    if (riid == IID_IRTPStream ||
		riid == IID_IRTCPStream ||
		riid == IID_IRTPParticipant) {

        // forward request to rtp session object
        return m_pRtpSession->NonDelegatingQueryInterface(riid, ppv);

    } else {

        // forward this request to the base object
        return CRenderedInputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\output.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    output.cpp

Abstract:

    Implementation of CRtpOutputPin class.

Environment:

    User Mode - Win32

Revision History:

    06-Nov-1996 DonRyan
        Created.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "rtpalloc.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRtpOutputPin Implementation                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRtpOutputPin::CRtpOutputPin(
    CRtpSourceFilter * pFilter,
    LPUNKNOWN          pUnk,  
    HRESULT *          phr
    )

/*++

Routine Description:

    Constructor for CRtpOutputPin class.    

Arguments:

    pFilter - pointer to associated filter object.

    pUnk - IUnknown interface of the delegating object. 

    phr - pointer to the general OLE return value. 

Return Values:

    Returns an HRESULT value. 

--*/

:   CSharedSourceStream(
        NAME("CRtpOutputPin"),
        phr,                       
        pFilter,                   
        RTP_PIN_OUTPUT
        ),                 
    m_NumSamples(0),
    m_MaxSamples(0),
    m_pFilter(pFilter),
    m_pRtpAlloc(NULL)
{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpOutputPin::CRtpOutputPin")
        ));

	// Check what error returned CSharedSourceStream
	// the error can only be set by CSourceStream trough  CSource::AddPin
	if (FAILED(*phr)) {
		DbgLog((
				LOG_ERROR,
				LOG_DEVELOP,
				TEXT("CRtpOutputPin::CRtpOutputPin: "
					 "Base class CSharedSourceStream() init failed: 0x%X"),
				*phr
			));
		return;
	}
	
    // create rtp session object as receiving participant
    m_pRtpSession = new CRtpSession(GetOwner(), phr, FALSE,
									(CBaseFilter *)pFilter);

	if (FAILED(*phr)) {
		DbgLog((
				LOG_ERROR,
				LOG_DEVELOP,
				TEXT("CRtpOutputPin::CRtpOutputPin: "
					 "new CRtpSession() failed: 0x%X"),
				*phr
			));
		return;
	}
	
    // validate pointer
    if (m_pRtpSession == NULL) {

        DbgLog((
            LOG_TRACE, // LOG_ERROR, 
            LOG_DEVELOP, 
            TEXT("Could not create CRtpSession")
            ));

        // return default 
        *phr = E_OUTOFMEMORY;
    }

	*phr = NOERROR;
	
    //
    // pins automatically add themselves to filters's array...
    //
}


CRtpOutputPin::~CRtpOutputPin(
    )

/*++

Routine Description:

    Destructor for CRtpOutputPin class.    

Arguments:

    None.

Return Values:

    None.

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpOutputPin::~CRtpOutputPin")
        ));

    // nuke session
    delete m_pRtpSession;    

    //
    // pins automatically delete themselves from filters's array...
    //
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSourceStream overrided methods                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
 
HRESULT 
CRtpOutputPin::FillBuffer(
    IMediaSample *pSample
    )

/*++

Routine Description:

    Fills the stream buffer during the creation of a media sample that
    the current pin provides.  Not implemented by this filter.

Arguments:

    pSample - IMediaSample buffer to contain the data. 

Return Values:

    Returns an HRESULT value. 

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpOutputPin::FillBuffer")
        ));

    return S_OK; // never called
}


HRESULT 
CRtpOutputPin::CheckMediaType(
    const CMediaType * pmt
    )

/*++

Routine Description:

    Determines if the pin can support a specific media type. 

Arguments:

    pmt - pointer to a media type object containing the proposed media type. 

Return Values:

    Returns an HRESULT value. 

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpOutputPin::CheckMediaType")
        ));
/*
    // only accept media that is of type rtp stream
    return ((*(pmt->Type()) == *g_RtpOutputType.clsMajorType) &&
			(*(pmt->Subtype()) == *g_RtpOutputType.clsMinorType)) 
                ? S_OK 
                : E_INVALIDARG
                ;
*/
    return ((*(pmt->Type()) == *g_RtpOutputType.clsMajorType) ||
			(*(pmt->Type()) == MEDIATYPE_RTP_Single_Stream)) 
                ? S_OK 
                : E_INVALIDARG
                ;
}


HRESULT 
CRtpOutputPin::GetMediaType(
    CMediaType *pmt
    )

/*++

Routine Description:

    Determines media type the pin can support. 

Arguments:

    pmt - pointer to a media type object containing the proposed media type. 

Return Values:

    Returns an HRESULT value. 

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpOutputPin::GetMediaType")
        ));

    // set type to rtp stream
    pmt->SetType(g_RtpOutputType.clsMajorType);
    pmt->SetSubtype(g_RtpOutputType.clsMinorType);

    return S_OK;
}


HRESULT 
CRtpOutputPin::Active(
    )

/*++

Routine Description:

    Called by the CBaseFilter implementation when the state changes 
    from stopped to either paused or running. 

Arguments:

    None. 

Return Values:

    Returns an HRESULT value. 

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpOutputPin::Active")
        ));

    // disable async i/o
    EnableAsyncIo(FALSE);

    // now call base class
    HRESULT hr = CSharedSourceStream::Active();

    // validate
    if (FAILED(hr)) {

        DbgLog((
            LOG_TRACE, // LOG_ERROR, 
            LOG_ALWAYS, 
            TEXT("CSharedSourceStream::Active returned 0x%08lx"), hr
            ));
    }

    return hr;
}


HRESULT 
CRtpOutputPin::Inactive(
    )

/*++

Routine Description:

    Called by the CBaseFilter implementation when the state changes 
    from either paused or running to stopped. 

Arguments:

    None. 

Return Values:

    Returns an HRESULT value. 

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpOutputPin::Inactive")
        ));

    // disable async i/o
    EnableAsyncIo(FALSE);

    // now call base class
    HRESULT hr = CSharedSourceStream::Inactive();

    // validate
    if (FAILED(hr)) {

        DbgLog((
            LOG_TRACE, // LOG_ERROR, 
            LOG_ALWAYS, 
            TEXT("CSharedSourceStream::Inactive returned 0x%08lx"), hr
            ));
    }

    return hr;
}


#if defined(_0_)
HRESULT 
CRtpOutputPin::DoBufferProcessingLoop(
    )

/*++

Routine Description:

    Processing incoming samples and posts new receive buffers.

Arguments:

    None. 

Return Values:

    Returns an HRESULT value. 

--*/

{
#ifdef DEBUG_CRITICAL_PATH

    DbgLog((
        LOG_TRACE, 
        LOG_CRITICAL, 
        TEXT("CRtpOutputPin::DoBufferProcessingLoop")
        ));
    
#endif // DEBUG_CRITICAL_PATH

    // initialize
    HRESULT hr = S_OK;
        
    // media sample to use
    IMediaSample * pSample;
    
    // process samples
    while (hr == S_OK) {

        // retrieve next sample from queue
        hr = m_pRtpSession->RecvNext(&pSample);

        // validate
        if (hr == S_OK) {
                           
            // To this filter pause means don't deliver
            if (m_pFilter->GetState() != State_Paused)
            {
                // deliver sample
                hr = Deliver(pSample);
            }

            // release sample
            pSample->Release();

            // decrement 
            m_NumSamples--;

            // validate now
            if (FAILED(hr)) {

                DbgLog((
                    LOG_TRACE, // LOG_ERROR, 
                    LOG_ALWAYS, 
                    TEXT("CBaseOutputPin::Deliver returned 0x%08lx"), hr
                    ));

                // ignore error caused by stopping input pin
                return (hr == VFW_E_WRONG_STATE || hr == VFW_E_SAMPLE_REJECTED) ? S_OK : hr;
            }
        }
    }
    
    hr = ProcessFreeSamples();

    // adjust error status to okay
    return SUCCEEDED(hr) ? S_OK : hr;
}
#endif

HRESULT
CRtpOutputPin::ProcessFreeSamples()
/*++

Routine Description:

    Gives all available samples to WinSock

Arguments:

    None. 

Return Values:

    Return an HRESULT.

--*/
{
    HRESULT hr = S_OK;
    IMediaSample * pSample;
    ASSERT(m_pRtpAlloc != NULL);

    // post receive buffers until the allocator runs out
    while (SUCCEEDED(hr) && m_NumSamples < m_MaxSamples && m_pRtpAlloc->FreeCount() > 0) {

        DbgLog((
            LOG_TRACE,
            LOG_CRITICAL,
            TEXT("Calling GetDeliveryBuffer: FreeCount = %d"), m_pRtpAlloc->FreeCount()));                    
        
        // retrieve buffer from downstream filter
        hr = GetDeliveryBuffer(&pSample, NULL, NULL, 0);

        DbgLog((
            LOG_TRACE,
            LOG_CRITICAL,
            TEXT("GetDeliveryBuffer returned")));

        // validate
        if (hr == S_OK) {
                                
            // add sample to the receiving queue   
            hr = m_pRtpSession->RecvFrom(pSample);

            // validate
            if (hr == S_OK) {

                // increment
                m_NumSamples++;
            }
            
            // release sample
            pSample->Release();

        } else {

            DbgLog((
                LOG_TRACE, //LOG_ERROR, 
                LOG_ALWAYS, 
                TEXT("CBaseOutputPin::GetDeliveryBuffer returned 0x%08lx"), hr
                ));

            // ignore error caused by stopping input pin
            return (hr == VFW_E_NOT_COMMITTED) ? S_OK : hr;
        }
    }

    return hr;
}

HRESULT
CRtpOutputPin::ProcessIO(SAMPLE_LIST_ENTRY *pSLE)
{
	IMediaSample * pSample;
	HRESULT hr2;
	HRESULT hr = (pSLE->Status == NO_ERROR) ? S_OK : E_FAIL;

	if (SUCCEEDED(hr)) {

		// To this filter pause means don't deliver
		if (m_pFilter->GetState() != State_Paused)
			// deliver sample
			hr = Deliver(pSLE->pSample);
	}

	// Decrement outstanding samples
	m_NumSamples--;
	
	// release sample
	pSLE->pSample->Release();

	// release list entry
	pSLE->pCSampleQueue->Free(pSLE);

    while(m_NumSamples < m_MaxSamples && m_pRtpAlloc->FreeCount() > 0) {
		
		// retrieve buffer from downstream filter
        hr2 = GetDeliveryBuffer(&pSample, NULL, NULL, 0);

		// validate
        if (hr2 == S_OK) {
                                
            // add sample to the receiving queue   
            hr2 = m_pRtpSession->RecvFrom(pSample);

            // validate
            if (hr2 == S_OK) {

                // increment
                m_NumSamples++;
            } else
				break;
            
            // release sample
            pSample->Release();

        } else {

            DbgLog((
					LOG_TRACE, //LOG_ERROR, 
					LOG_ALWAYS, 
					TEXT("CBaseOutputPin::ProcessIO: fail: 0x%X"),
					hr2
                ));
			break;
        }
	}

	return(hr);
}

HRESULT
CRtpOutputPin::ProcessCmd(Command Request)
{
	HRESULT hr               = S_OK;

	CRtpSession *pRtpSession = GetRtpSession();

	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP2, 
			TEXT("CRtpOutputPin::ProcessCmd worker: command %s (%d)"),
			CMD_STRING(Request), Request
		));

	switch(Request) {

	case CMD_INIT:
		m_pRtpAlloc = (CRTPAllocator *)(m_pAllocator); // BUGBUG: Unsafe

		pRtpSession->SetSharedObjectsCtx( GetContext(),
										  GetSharedList(),
										  GetSharedLock() );
		break;

	case CMD_STOP:
		if (pRtpSession->IsJoined()) {

			DeliverEndOfStream(); // FIX (By Intel)
                
			DbgLog((
					LOG_TRACE, 
					LOG_ALWAYS, 
					TEXT("CRtpOutputPin::ProcessCmd worker stopping output")
				));

			// leave multimedia session 
			hr = pRtpSession->Leave();

			if (DecNumRun() <= 0)
				EnableAsyncIo(FALSE);
		
			// validate
			if (FAILED(hr)) {
				
				DbgLog((
						LOG_ERROR, 
						LOG_ALWAYS, 
						TEXT("CRtpSession::Leave returned 0x%08lx"), hr
					));
			}

			// process any recently freed samples
            HRESULT hr2 = ProcessFreeSamples();

			if (FAILED(hr) || FAILED(hr2))
				hr = E_FAIL;
		}
		break;

 	case CMD_RUN:
		// only need to start if the session is not joined
		if (!pRtpSession->IsJoined()) {
		
			DbgLog((
					LOG_TRACE, 
					LOG_ALWAYS, 
					TEXT("CRtpOutputPin::ProcessCmd worker starting output")
				));

			if (!m_pRtpAlloc) {
				DbgLog((
						LOG_ERROR, 
						LOG_DEVELOP, 
						TEXT("CRtpOutputPin::ProcessCmd(RUN): "
							 "not cmd INIT has been issued, ignoring...")
					));
				break;
			}
			
			if (IncNumRun() > 0)
				EnableAsyncIo(TRUE);
		
			// reset count
			SetNumSamples(0);
		
			// join multimedia session 
			hr = pRtpSession->Join();

			// validate
			if (SUCCEEDED(hr)) {
				
				// Allocate buffer samples
				hr = ProcessFreeSamples();
				
			} else {
				DecNumRun();

				DbgLog((
						LOG_ERROR,
						LOG_ALWAYS, 
						TEXT("CRtpSession::Join returned 0x%08lx"), hr
					));
			}
		}
		break;

	case CMD_EXIT:
		break;
	}
	
	return(hr);
}


HRESULT
CRtpOutputPin::GetClassPriority(long *plClass, long *plPriority)
{
	CRtpSession *pRtpSession = GetRtpSession();

	if (pRtpSession)
		return(pRtpSession->GetSessionClassPriority(plClass, plPriority));
	else
		return(E_FAIL);
}

#if defined(_0_)
DWORD
CRtpOutputPin::SharedThreadProc(LPVOID pv)
{
	DWORD i, idx;
	CSharedProc *pCSharedProc = GetSharedProcObject();

    DWORD Request, SharedRequest = CMD_INIT;
    HRESULT hr = (pCSharedProc->GetWaitObject() != NULL) ?
		S_OK : E_FAIL;

    // set the priority of this worker thread if necessary
    SetThreadPriority(GetCurrentThread(), GetSharedThreadPriority());

    while(SUCCEEDED(hr) && (SharedRequest != CMD_EXIT_SHARED)) {
		
		DWORD Status = WaitForSingleObjectEx(
				pCSharedProc->GetWaitObject(), 
				INFINITE, 
				(pCSharedProc->GetNumRun() > 0)? TRUE:FALSE);
		/////////////////////
		// WAIT_IO_COMPLETION
		/////////////////////
		if (Status == WAIT_IO_COMPLETION) {
			CRtpOutputPin *pCRtpOutputPin;
/*			
			for(i = 0; i < pCSharedProc->GetSharedCount(); i++) {

				pCRtpOutputPin = (CRtpOutputPin *)
					pCSharedProc->GetLocalClass(i+1);

				hr = pCRtpOutputPin->DoBufferProcessingLoop();
				if (FAILED(hr)) {
					DbgLog((
							LOG_TRACE,
							LOG_DEVELOP, 
							TEXT("DoBufferProcessingLoop failed")
						));
				}
			}
			*/		
		} else if (Status == WAIT_OBJECT_0) {

			hr = ProcessCmd(Request);

		} else {
			
            DbgLog((
					LOG_TRACE, // LOG_ERROR, 
					LOG_DEVELOP, 
                TEXT("WaitForSingleObjectEx returned:0x%08lx, error:%d"),
					Status, GetLastError()
                ));

            hr = E_FAIL; 
        }
	}

	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP, 
			TEXT("CSharedThreadProc: exiting ID: %d (0x%x) "),
			pCSharedProc->GetSharedThreadID(),
			pCSharedProc->GetSharedThreadID()
		));
	
	return(SUCCEEDED(hr)? 0 : 1);
}
#endif

DWORD 
CRtpOutputPin::ThreadProc()

/*++

Routine Description:

    Implements the worker thread procedure. 

Arguments:

    None. 

Return Values:

    0 - Thread completed successfully. 
    1 - Thread did not complete successfully. 

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpOutputPin::ThreadProc: "
			 "Should never be used")
        ));


    // map return status
    return(E_FAIL);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CBaseOutputPin overrided methods                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT 
CRtpOutputPin::DecideBufferSize(
    IMemAllocator *        pAlloc,
    ALLOCATOR_PROPERTIES * pProperties
    )

/*++

Routine Description:

    Retrieves the number and size of buffers required for the transfer. 

Arguments:

    pAlloc - Allocator assigned to the transfer. 

    pProperties - Requested allocator properties for count, size, 
    and alignment, as specified by the ALLOCATOR_PROPERTIES structure.     

Return Values:

    Returns an HRESULT value. 

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpOutputPin::DecideBufferSize")
        ));

    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("Proposed: cBuffers=%d,cbBuffer=%d,cbPrefix=%d,cbAlign=%d"), 
        pProperties->cBuffers,
        pProperties->cbBuffer,
        pProperties->cbPrefix,
        pProperties->cbAlign 
        ));

    // negotiated properties
    ALLOCATOR_PROPERTIES Actual;

    // default to something reasonable
    if (pProperties->cBuffers == 0) {

        // use hard-coded defaults values for now
        pProperties->cBuffers = DEFAULT_SAMPLE_NUM;
        pProperties->cbBuffer = DEFAULT_SAMPLE_SIZE;   
        pProperties->cbPrefix = DEFAULT_SAMPLE_PREFIX;      
        pProperties->cbAlign  = DEFAULT_SAMPLE_ALIGN;      
    }

    pProperties->cBuffers = max(pProperties->cBuffers, DEFAULT_SAMPLE_NUM)
		+ 0; // HUGEMEMORY 4->0;

    // attempt to set negotiated/default values
    HRESULT hr = pAlloc->SetProperties(pProperties, &Actual);

    // validate
    if (FAILED(hr)) {

        DbgLog((
            LOG_TRACE, // LOG_ERROR, 
            LOG_ALWAYS, 
            TEXT("IMemAllocator::SetProperties returned 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    // reset pointer
    pProperties = &Actual;

    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("Negotiated: cBuffers=%d,cbBuffer=%d,cbPrefix=%d,cbAlign=%d"),
        pProperties->cBuffers,
        pProperties->cbBuffer,
        pProperties->cbPrefix,
        pProperties->cbAlign 
        ));

    // record maximum number of buffers
    m_MaxSamples = 4;

    return S_OK;
}

HRESULT
CRtpOutputPin::DecideAllocator(
    IMemInputPin        *pPin,
    IMemAllocator      **ppAlloc
    )
/*++

Routine Description:

    Determines the allocator used for data transfer between the two pins

Arguments:

    pPin - Input pin to negociate with.

    ppAlloc - Output parameter for chosen allocator.

Return Values:

    Returns an HRESULT value. 

--*/
{
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;

    //
    // Get requested properties from downstream filter
    //
    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop));
    pPin->GetAllocatorRequirements(&prop);
    // if he doesn't care about alignment, then set it to 1
    if (prop.cbAlign == 0) { prop.cbAlign = 1; }

    //
    // We are very picky about the allocator we use.  Blocking allocators can
    //  cause the stream to deadlock.
    //
    *ppAlloc = new CRTPAllocator(NAME("RTP Source Filter Allocator"),
								 NULL, &hr);
	
    if (*ppAlloc != NULL && SUCCEEDED(hr))
    {
        //
        // We will either keep a reference to this or release it below on an
        //  error return.
        //
        (*ppAlloc)->AddRef();

	    hr = DecideBufferSize(*ppAlloc, &prop);
	    if (SUCCEEDED(hr))
        {
	        hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
	        if (SUCCEEDED(hr))
            {
    		    return NOERROR;
	        }
	    }
    }

    //
    // We may or may not have an allocator to release at this point.
    //
    if (*ppAlloc)
    {
	    (*ppAlloc)->Release();
	    *ppAlloc = NULL;
    }
    return hr;
}

#if 0
HRESULT
CRtpOutputPin::GetDeliveryBuffer(IMediaSample ** ppSample,
                                  REFERENCE_TIME * pStartTime,
                                  REFERENCE_TIME * pEndTime,
                                  DWORD dwFlags)
{
    if (m_pAllocator != NULL)
    {
        //
        // This must have been set before hand.
        //
        ASSERT(m_pRtpAlloc);
#if 0
        CRTPAllocator *pAlloc;
        try
        {
            pAlloc = dynamic_cast<CRTPAllocator *>m_pAllocator;
        }
        catch(...)
        {
            return E_UNEXPECTED;
        }
#endif
                
        return m_pAllocator->GetBuffer(ppSample, pStartTime, pEndTime, dwFlags);
    }
    else
    {
        return E_NOINTERFACE;
    }
}
#endif


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CBasePin overrided methods                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT 
CRtpOutputPin::Run(
    REFERENCE_TIME tStart
    )

/*++

Routine Description:

    Transitions pin to State_Running state if it is not in state already. 

Arguments:

    tStart - Reference time value corresponding to stream time 0. 

Return Values:

    Returns an HRESULT value.

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CRtpOutputPin::Run")
        ));

    // notify worker thread
    HRESULT hr = CSharedSourceStream::Run();

    // validate
    if (FAILED(hr)) {
        
        DbgLog((
            LOG_ERROR, 
            LOG_DEVELOP, 
            TEXT("CSharedSourceStream::Run failed: 0x%08lx"), hr
            ));
    }

    return hr;
}


STDMETHODIMP 
CRtpOutputPin::Notify(
    IBaseFilter * pSelf,
    Quality   q    
    )

/*++

Routine Description:

    Receives a notification that a quality change is requested.  

Arguments:

    pSelf - Pointer to the filter that is sending the quality notification. 

    q - Quality notification structure    

Return Values:

    Returns an HRESULT value.

--*/

{
#ifdef DEBUG_CRITICAL_PATH
	
    DbgLog((
        LOG_TRACE, 
        LOG_CRITICAL, 
        TEXT("CRtpOutputPin::Notify")
        ));

#endif // DEBUG_CRITICAL_PATH
	
    return S_FALSE; // bail...
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// INonDelegatingUnknown implemented methods                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRtpOutputPin::NonDelegatingQueryInterface(
    REFIID riid, 
    void ** ppv
    )

/*++

Routine Description:

    Returns an interface and increments the reference count.

Arguments:

    riid - reference identifier. 

    ppv - pointer to the interface. 

Return Values:

    Returns a pointer to the interface.

--*/

{
#ifdef DEBUG_CRITICAL_PATH
	
    DbgLog((
        LOG_TRACE, 
        LOG_CRITICAL, 
        TEXT("CRtpOutputPin::NonDelegatingQueryInterface")
        ));

#endif // DEBUG_CRITICAL_PATH
	
    // validate pointer
    CheckPointer(ppv,E_POINTER);

    // forward rtp and rtcp stream queries to session object
    if (riid == IID_IRTPStream ||
		riid == IID_IRTCPStream ||
		riid == IID_IRTPParticipant) {

        // forward request to rtp session object
        return m_pRtpSession->NonDelegatingQueryInterface(riid, ppv);

    } else {

        // forward this request to the base object
        return CSharedSourceStream::NonDelegatingQueryInterface(riid, ppv);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\queue.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       queue.h
//
//--------------------------------------------------------------------------

// This used to be in classes.h, but I moved it in a separate file
// because it is requiered also by shared.h

#if !defined(_AMRTPNET_QUEUE_H_)
#define      _AMRTPNET_QUEUE_H_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Sample queue class                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

class CSampleQueue;

typedef struct _SAMPLE_LIST_ENTRY  {
    WSAOVERLAPPED      Overlapped;
    LIST_ENTRY         Link;
    DWORD              Status;
    IMediaSample *     pSample;
    CSampleQueue *     pCSampleQueue; 
    DWORD              BytesTransferred;
    DWORD              Flags;
    struct sockaddr_in SockAddr;
    INT                SockAddrLen;
    WSABUF             Buffer;
} SAMPLE_LIST_ENTRY, *PSAMPLE_LIST_ENTRY;

class CSampleQueue
{
    LIST_ENTRY m_FreeList;       // list of available entries
    LIST_ENTRY m_SampleList;     // list of outstanding entries
    CCritSec   m_cStateLock;     // lock for accessing queue

	void             *m_pvContext;
	LIST_ENTRY       *m_pSharedList;
	CRITICAL_SECTION *m_pSharedLock;
	
public:

    // constructor
    CSampleQueue(HRESULT * phr);

    // destructor
    ~CSampleQueue();

	inline void SetSharedObjectsCtx( void             *pvContext,
									 LIST_ENTRY       *pSharedList,
									 CRITICAL_SECTION *pSharedLock)
	{
		m_pvContext   = pvContext;
		m_pSharedList = pSharedList;
		m_pSharedLock = pSharedLock;
	}
	
    // add entry to outstanding list
    HRESULT Push(PSAMPLE_LIST_ENTRY pSLE);

    // get completed entry from sample list
    HRESULT Pop(PSAMPLE_LIST_ENTRY * ppSLE);

	inline void *GetSampleContext() { return(m_pvContext); }
	
	// move completed entry from the samples list to the shared list
	void Ready(SAMPLE_LIST_ENTRY *pSLE);

    // get entry from free list and initialize with sample
    HRESULT Alloc(IMediaSample * pSample, PSAMPLE_LIST_ENTRY * ppSLE);

    // add entry to free list
    HRESULT Free(PSAMPLE_LIST_ENTRY pSLE);

    // free all entries
    HRESULT FreeAll();

    // expose state lock to other objects
    CCritSec * pStateLock(void) { return &m_cStateLock; }

    //CCritSec * pSharedStateLock(void) { return m_pSharedStateLock; }

    // block for completion event 
    HRESULT WaitForIoCompletion(void) {
                return (SleepEx(INFINITE, TRUE) == WAIT_IO_COMPLETION) 
                            ? S_OK 
                            : E_FAIL
                            ; 
                }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\globals.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    globals.h

Abstract:

    Global definitions for ActiveMovie RTP Network Filters.

Environment:

    User Mode - Win32

Revision History:

    06-Nov-1996 DonRyan
        Created.

--*/
 
#ifndef _INC_GLOBALS
#define _INC_GLOBALS

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define INCL_WINSOCK_API_PROTOTYPES 1
#define INCL_WINSOCK_API_TYPEDEFS 1

#include <winsock2.h>   // must include instead of windows.h

#include <qossp.h>
#include <qospol.h>

#include <ws2tcpip.h>
#include <streams.h>
#include <stdio.h>
#include <rrcm.h>

#include <olectl.h>

#include <amrtpuid.h>
#include <amrtpnet.h>
#include <rrcm_dll.h>
#include <rrcmprot.h>

#include "queue.h"
#include "shared.h"
#include "classes.h"

#include "trace.h"

#include "template.h"



#define AMRTP_EVENTBASE  DXMRTP_EVENTBASE

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Multicast Support                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define IS_CLASSD(i)            (((long)(i) & 0x000000f0) == 0x000000e0)
#define IS_MULTICAST(i)         IS_CLASSD(i)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Sampling defaults                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define DEFAULT_SAMPLE_NUM	4 // HUGEMEMORY 512->4

#define DEFAULT_SAMPLE_SIZE     1500
#define DEFAULT_SAMPLE_PREFIX   0
#define DEFAULT_SAMPLE_ALIGN    1


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Linked list support (from ntrtl.h)                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Debug Support                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define LOG_DEVELOP             1
#define LOG_DEVELOP1            1
#define LOG_DEVELOP2            2
#define LOG_DEVELOP3            3
#define LOG_DEVELOP4            4
#define LOG_ALWAYS              0x8
#define LOG_CRITICAL            0xF
#define LOG_EVERYTHING          0xFFFFFFFF
#define LOG_TYPES               (LOG_TRACE|LOG_ERROR|LOG_TIMING|LOG_LOCKING) 
#define LOG_LEVELS              (LOG_EVERYTHING)

#if DEBUG
void DbgLogIID(REFIID riid);
#endif 

#define CMD_STRING(cmd) \
    ((cmd == CMD_INIT) \
        ? TEXT("INIT") \
        : (cmd == CMD_PAUSE) \
            ? TEXT("PAUSE") \
            : (cmd == CMD_RUN) \
                ? TEXT("RUN") \
                : (cmd == CMD_STOP) \
                    ? TEXT("STOP") \
                    : (cmd == CMD_EXIT) \
                        ? TEXT("EXIT") \
                        : TEXT("UNKNOWN"))

#endif // _INC_GLOBALS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\render.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    render.cpp

Abstract:

    Implementation of CRtpRenderFilter class.

Environment:

    User Mode - Win32

Revision History:

    06-Nov-1996 DonRyan
        Created.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRtpRenderFilter methods                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRtpRenderFilter::CRtpRenderFilter(
    LPUNKNOWN pUnk,
    HRESULT * phr // MUST be a valid pointer
    )

/*++

Routine Description:

    Constructor for CRtpRenderFilter class.    

Arguments:

    pUnk - IUnknown interface of the delegating object. 

    phr - pointer to the general OLE return value. 

Return Values:

    Returns an HRESULT value.

--*/

:   CBaseFilter(
        NAME("CRtpRenderFilter"), 
        pUnk, 
        &m_cStateLock, 
        CLSID_RTPRenderFilter,
        phr // No point passing this, base class doesn't even touch it 
        ),
    CPersistStream(pUnk, phr),
    m_iPins(0),
    m_paStreams(NULL)
{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_DEVELOP, 
        TEXT("[%x:0x%X]CRtpRenderFilter::CRtpRenderFilter]"),
        GetCurrentThreadId(), this
        ));

    WSADATA WSAData;
    WORD VersionRequested = MAKEWORD(2,0);
    
    // initialize winsock first    
    if (WSAStartup(VersionRequested, &WSAData)) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_DEVELOP, 
            TEXT("WSAStartup returned %d"), 
            WSAGetLastError()
            ));

        *phr = E_FAIL;
        
        return; // bail...
    }

    // create default input pin object
    CRtpInputPin * pPin = new CRtpInputPin(
                                this,
                                GetOwner(),
                                phr
                                );

    if (FAILED(*phr)) {
        TraceDebug((
                TRACE_ERROR,
                TRACE_DEVELOP,
                TEXT("CRtpRenderFilter::CRtpRenderFilter: "
                     "new CRtpInputPin() failed: 0x%X"),
                *phr
            ));
        return;
    }

    // validate pointer
    if (pPin == NULL) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_DEVELOP, 
            TEXT("Could not create CRtpInputPin")
            ));

        // return default 
        *phr = E_OUTOFMEMORY;

        return; // bail...
    }

    ASSERT(m_paStreams != NULL);

    //
    // pins add themselves to filters's array...
    //
}


CRtpRenderFilter::~CRtpRenderFilter(
    )

/*++

Routine Description:

    Destructor for CRtpRenderFilter class.    

Arguments:

    None.

Return Values:

    None.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_DEVELOP, 
        TEXT("[%x:0x%X]CRtpRenderFilter::~CRtpRenderFilter"),
        GetCurrentThreadId(), this
        ));

    // rally thru pins
    while (m_iPins != 0) {

        // nuke each pin in array
        delete m_paStreams[m_iPins - 1];
    }

    // shutdown now
    if (WSACleanup()) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_DEVELOP, 
            TEXT("WSACleanup returned %d"), 
            WSAGetLastError()
            ));
    }

    ASSERT(m_paStreams == NULL);

    //
    // pins delete themselves from filter's array
    //
}


CUnknown *
CRtpRenderFilter::CreateInstance(
    LPUNKNOWN punk, 
    HRESULT * phr
    )

/*++

Routine Description:

    Called by COM to create a CRtpRenderFilter object.    

Arguments:

    pUnk - pointer to the owner of this object. 

    phr - pointer to an HRESULT value for resulting information. 

Return Values:

    None.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpRenderFilter::CreateInstance")
        ));

    // attempt to create rtp sender object
    CRtpRenderFilter * pNewObject = new CRtpRenderFilter(punk, phr);

    // validate pointer
    if (pNewObject == NULL) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_DEVELOP, 
            TEXT("Could not create CRtpRenderFilter")
            ));

        // return default
        *phr = E_OUTOFMEMORY;
    }

    // return object
    return pNewObject;
}


HRESULT 
CRtpRenderFilter::AddPin(
    CRtpInputPin * pPin
    )

/*++

Routine Description:

    Adds a pin to the network sink filter.

Arguments:

    pPin - input pin to be added to the filter.

Return Values:

    Returns an HRESULT value. 

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpRenderFilter::AddPin")
        ));

    // object lock on this object
    CAutoLock LockThis(&m_cStateLock);

    // allocate temporary array to hold the stream pointers
    CRtpInputPin ** paStreams = new CRtpInputPin *[m_iPins + 1];

    // validate pointer
    if (paStreams == NULL) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_DEVELOP, 
            TEXT("Could not create CRtpInputPin array")
            ));

        return E_OUTOFMEMORY; // bail...
    }

    // see if array exists
    if (m_paStreams != NULL) {

        // transfer existing pointers
        CopyMemory(
                (PVOID)paStreams, 
                (PVOID)m_paStreams,
                m_iPins * sizeof(m_paStreams[0])
            );

        // nuke old array
        delete [] m_paStreams;
    }

    // save new array pointer
    m_paStreams = paStreams;

    // add new pin to array
    m_paStreams[m_iPins] = pPin;

    // add
    m_iPins++;

    return S_OK;
}


HRESULT 
CRtpRenderFilter::RemovePin(
    CRtpInputPin * pPin
    )

/*++

Routine Description:

    Removes a pin from the network sink filter.

Arguments:

    pPin - input pin to be removed from the filter.

Return Values:

    Returns an HRESULT value. 

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpRenderFilter::RemovePin")
        ));

    // object lock on this object
    CAutoLock LockThis(&m_cStateLock);

    int i;

    // process each pin    
    for (i = 0; i < m_iPins; i++) {

        // see if this is the one
        if (m_paStreams[i] == pPin) {

            // single pin?
            if (m_iPins == 1) {
                
                // need to nuke array    
                delete [] m_paStreams;

                // re-initialize
                m_paStreams = NULL;

            } else {
                
                // adjust rest of pins
                while (++i < m_iPins) {

                    // slide pointers over one slot
                    m_paStreams[i - 1] = m_paStreams[i];
                }
            }
 
            // delete
            m_iPins--;

            return S_OK;
        }
    }

    return S_FALSE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CBaseFilter overrided methods                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CBasePin * 
CRtpRenderFilter::GetPin(
    int n
    )

/*++

Routine Description:

    Obtains specific CBasePin object associated with filter. 

Arguments:

    n - number of the specified pin. 

Return Values:

    Returns pointer to specified pin.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpRenderFilter::GetPin %d"), n
        ));

    // object lock on filter object
    CAutoLock LockThis(&m_cStateLock);

    // validate index passed in
    if ((n >= 0) && (n < m_iPins)) {

        ASSERT(m_paStreams[n]);

        // return input pin
        return m_paStreams[n];
    }
    
    return NULL;
}


int 
CRtpRenderFilter::GetPinCount(
    )

/*++

Routine Description:

    Obtains number of pins supported by filter. 

Arguments:

    None.

Return Values:

    Returns the number of supported pins.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpRenderFilter::GetPinCount")
        ));

    // object lock on filter object
    CAutoLock LockThis(&m_cStateLock);

    // return count
    return m_iPins;
}


LPAMOVIESETUP_FILTER 
CRtpRenderFilter::GetSetupData(
    )

/*++

Routine Description:

    Called by ActiveMovie to retrieve filter setup information.    

Arguments:

    None.

Return Values:

    Returns pointer to filter info structure.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpRenderFilter::GetSetupData")
        ));

    // get sink filter info
    return &g_RtpRenderFilter;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IBaseFilter implemented methods                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRtpRenderFilter::QueryVendorInfo(
    LPWSTR * ppVendorInfo
    )

/*++

Routine Description:

    Returns a vendor information string.  

Arguments:

    ppVendorInfo - Pointer to a string containing vendor information.

Return Values:

    Returns an HRESULT value. 

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpRenderFilter::QueryVendorInfo")
        ));

    // validate pointer
    CheckPointer(ppVendorInfo,E_POINTER);

    // allocate the description string
    *ppVendorInfo = (LPWSTR)CoTaskMemAlloc(
                                (lstrlenW(g_VendorInfo)+1) * sizeof(WCHAR)
                                );

    // validate pointer
    if (*ppVendorInfo == NULL) {
    
        TraceDebug((
            TRACE_ERROR, 
            TRACE_ALWAYS, 
            TEXT("Could not allocate vendor info")
            ));

        return E_OUTOFMEMORY; // bail...
    }
    
    // copy vendor description string
    lstrcpyW(*ppVendorInfo,g_VendorInfo);            

    return S_OK;    
}

//-----------------------------------------------------------------------//
// IAMFilterMiscFlags implemented methods                                //
//-----------------------------------------------------------------------//
/*++

  Routine Description:

  Implement the IAMFilterMiscFlags::GetMiscFlags method. Retrieves the
  miscelaneous flags. This consists of whether or not the filter moves
  data out of the graph system through a Bridge or None pin.

  Arguments:

  None.
  --*/

STDMETHODIMP_(ULONG)
CRtpRenderFilter::GetMiscFlags(void)
{
    return(AM_FILTER_MISC_FLAGS_IS_RENDERER);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IPersistStream implemented methods                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRtpRenderFilter::GetClassID(
    CLSID *pClsid
    )

/*++

Routine Description:

    Retrieves the class identifier for this filter. 

Arguments:

    pClsid - Pointer to a CLSID structure.  

Return Values:

    Returns an HRESULT value.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpRenderFilter::GetClassID")
        ));

    // transfer filter class id
    *pClsid = CLSID_RTPRenderFilter;

    return S_OK;
}


// ZCS: 6-22-97: copied this from the Demux filter code and modified it...
//
//  Name    : WriteEntry
//  Purpose : A macro that implements the stuff we do to write
//            a property of this filter to its persistent stream.
//  Context : Used in WriteToStream() to improve readability.
//  Returns : Will only return if an error is detected.
//  Params  : 
//      Entry       Pointer to a buffer containing the value to write.
//      InSize      Integer indicating the length of the buffer
//      OutSize     Integer to store the written length.
//      Description Char string used to describe the entry.
//  Notes   : 
#define WriteEntry(Entry, InSize, OutSize, Description) \
  { TraceDebug((TRACE_TRACE, 4, TEXT("CRtpRenderFilter::WriteToStream: Writing %s"), Description)); \
    hr = pStream->Write(Entry, InSize, &OutSize); \
    if (FAILED(hr)) { \
        TraceDebug((TRACE_ERROR, 2, TEXT("CRtpRenderFilter::WriteToStream: Error 0x%08x writing %s"), hr, Description)); \
        return hr; \
    } else if (OutSize != InSize) { \
        TraceDebug((TRACE_ERROR, 2,  \
                TEXT("CRtpRenderFilter::WriteToStream: Too few (%d/%d) bytes written for %s"), \
                uBytesWritten, sizeof(int), Description)); \
        return E_INVALIDARG; \
    } /* if */ }


HRESULT 
CRtpRenderFilter::WriteToStream(
    IStream *pStream
    )

/*++

Routine Description:

    Writes the filter's data to the given stream. 

Arguments:

    pStream - Pointer to an IStream to write the filter's data to. 

Return Values:

    Returns an HRESULT value.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpRenderFilter::WriteToStream")
        ));

    // validate pointer
    CheckPointer(pStream,E_POINTER);

    // obtain lock to this object
    CAutoLock LockThis(&m_cStateLock);

    //
    // Rest of this function added 6-22-97 by ZCS
    //

    HRESULT  hr; // used in the WriteEntry macro
    ULONG    uBytesWritten = 0;
    DWORD    dwRtpAddr;
    WORD     wRtpPort;
    DWORD    dwMulticastScope;
    DWORD    dwQOSstate;
    DWORD    dwMCLoopBack;

    // get the RTP session object so we can see the address, port, scope
    CRtpSession *pCRtpSession;
    ASSERT(m_iPins == 1);
    EXECUTE_ASSERT(SUCCEEDED((**m_paStreams).GetSession(&pCRtpSession)));

    // retrieve the address of the rtp stream object
    // for a sender, remote port matters
    EXECUTE_ASSERT(SUCCEEDED(pCRtpSession->GetAddress(NULL,
                                                      &wRtpPort,
                                                      &dwRtpAddr)));
    // retrieve multicast scope of rtp stream object
    EXECUTE_ASSERT(SUCCEEDED(pCRtpSession->GetMulticastScope(&dwMulticastScope)));
    // retrieve QOS state of rtp stream object
    EXECUTE_ASSERT(SUCCEEDED(pCRtpSession->GetQOSstate(&dwQOSstate)));

    // retrieve Multicast Loopback state of rtp stream object
    EXECUTE_ASSERT(SUCCEEDED(pCRtpSession->GetMulticastLoopBack(&dwMCLoopBack)));

    // write RTP address/port and multicast to the PersistStream
    WriteEntry(&dwRtpAddr, sizeof(dwRtpAddr), uBytesWritten, "RTP address");
    WriteEntry(&wRtpPort, sizeof(wRtpPort), uBytesWritten, "RTP port");
    WriteEntry(&dwMulticastScope, sizeof(dwMulticastScope), uBytesWritten, "multicast scope");
    WriteEntry(&dwQOSstate, sizeof(dwQOSstate), uBytesWritten, "QOS state");
    WriteEntry(&dwMCLoopBack, sizeof(dwMCLoopBack), uBytesWritten, "Multicast Loopback state");

    return S_OK;
}


// ZCS: 6-22-97: copied this from the Demux filter code and modified it...
//
//  Name    : ReadEntry
//  Purpose : A macro that implements the stuff we do to read
//            a property of this filter from its persistent stream.
//  Context : Used in ReadFromStream() to improve readability.
//  Returns : Will only return if an error is detected.
//  Params  : 
//      Entry       Pointer to a buffer containing the value to read.
//      InSize      Integer indicating the length of the buffer
//      OutSize     Integer to store the written length.
//      Description Char string used to describe the entry.
//  Notes   : 

#define ReadEntry(Entry, InSize, OutSize, Description) \
  { TraceDebug((TRACE_TRACE, 4, TEXT("CRtpRenderFilter::ReadFromStream: Reading %s"), Description)); \
    hr = pStream->Read(Entry, InSize, &OutSize); \
    if (FAILED(hr)) { \
        TraceDebug((TRACE_ERROR, 2, TEXT("CRtpRenderFilter::ReadFromStream: Error 0x%08x reading %s"), hr, Description)); \
        return hr; \
    } else if (OutSize != InSize) { \
        TraceDebug((TRACE_ERROR, 2,  \
                TEXT("CRtpRenderFilter::ReadFromStream: Too few (%d/%d) bytes read for %s"), \
                OutSize, InSize, Description)); \
        return E_INVALIDARG; \
    } /* if */ }

HRESULT 
CRtpRenderFilter::ReadFromStream(
    IStream *pStream
    )

/*++

Routine Description:

    Reads the filter's data from the given stream. 

Arguments:

    pStream - Pointer to an IStream to read the filter's data from. 

Return Values:

    Returns an HRESULT value.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpRenderFilter::ReadFromStream")
        ));

    // validate pointer
    CheckPointer(pStream,E_POINTER);

    // obtain lock to this object
    CAutoLock LockThis(&m_cStateLock);

    //
    // Rest of this function added 6-22-97 by ZCS based mostly on
    // Don Ryan's property page code...
    //

    HRESULT hr;
    ULONG uBytesWritten = 0;
    DWORD       dwRtpAddr;
    WORD        wRtpPort;
    DWORD       RtpScope;
    DWORD       QOSstate;
    DWORD       MCLoopBack;

    // get the RTP session object so we can see the address, port, scope
    CRtpSession *pCRtpSession = NULL;
    ASSERT(m_iPins == 1);
    EXECUTE_ASSERT(SUCCEEDED((**m_paStreams).GetSession(&pCRtpSession)));
    ASSERT(!IsBadReadPtr(pCRtpSession, sizeof(pCRtpSession)));

    // retrieve RTP address and port from stream
    ReadEntry(&dwRtpAddr, sizeof(dwRtpAddr), uBytesWritten, "RTP address");
    ReadEntry(&wRtpPort, sizeof(wRtpPort), uBytesWritten, "RTP port");

    // attempt to modify the rtp address
    // in unicast, the local port is what matters for a receiver
    // in multicast, they have to be the same, SetAddress takes care
    hr = pCRtpSession->SetAddress(wRtpPort, wRtpPort, dwRtpAddr);

    // validate
    if (FAILED(hr)) {
        
        TraceDebug((
            TRACE_ERROR, 
            TRACE_ALWAYS, 
            TEXT("IRTPStream::SetAddress returns 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    // retrieve multicast scope from stream
    ReadEntry(&RtpScope, sizeof(RtpScope), uBytesWritten, "multicast scope");

    // attempt to modify the scope
    hr = pCRtpSession->SetMulticastScope(RtpScope);

    // validate
    if (FAILED(hr)) {
        
        TraceDebug((
            TRACE_ERROR, 
            TRACE_ALWAYS, 
            TEXT("IRTPStream::SetScope returns 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    // retrieve QOS state from stream
    ReadEntry(&QOSstate, sizeof(QOSstate), uBytesWritten, "QOS state");

    // attempt to modify the QOS state
    hr = pCRtpSession->SetQOSstate(QOSstate);

    // validate
    if (FAILED(hr)) {
        
        TraceDebug((
                TRACE_ERROR, 
                TRACE_ALWAYS, 
                TEXT("IRTPStream::SetQOSstate returns 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    // retrieve Multicast Loopback state from stream
    ReadEntry(&MCLoopBack, sizeof(MCLoopBack), uBytesWritten, "Multicast Loopback state");

    // attempt to modify the Multicast Loopback state
    MCLoopBack = (MCLoopBack)? TRUE:FALSE;
    hr = pCRtpSession->SetMulticastLoopBack(MCLoopBack);

    // validate
    if (FAILED(hr)) {
        
        TraceDebug((
                TRACE_ERROR, 
                TRACE_ALWAYS, 
                TEXT("IRTPStream::SetMulticastLoopBack returns 0x%08lx"), hr
            ));

        return hr; // bail...
    }
    
    return S_OK;
}



int 
CRtpRenderFilter::SizeMax(
    )

/*++

Routine Description:

    Returns an interface and increments the reference count.

Arguments:

    riid - reference identifier. 

    ppv - pointer to the interface. 

Return Values:

    Returns a pointer to the interface.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpRenderFilter::SizeMax")
        ));

    // object lock on this object
    CAutoLock LockThis(&m_cStateLock);

    //    
    // CODEWORK...
    //

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ISpecifyPropertyPages implemented methods                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRtpRenderFilter::GetPages(
    CAUUID * pPages
    )

/*++

Routine Description:

    Returns property class id associated with filter.

Arguments:

    pPages - pointer to received property page class id.

Return Values:

    Returns an HRESULT value.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpRenderFilter::GetPages")
        ));

    // object lock on this object
    CAutoLock LockThis(&m_cStateLock);

    // number of pages
    pPages->cElems = 1;
    
    // allocate space to place property page guid
    pPages->pElems = (GUID *)CoTaskMemAlloc(sizeof(GUID));

    // validate pointer
    if (pPages->pElems == NULL) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_ALWAYS, 
            TEXT("Could not allocate property page guid")
            ));

        return E_OUTOFMEMORY;
    }
    
    // transfer property page guid to caller
    *(pPages->pElems) = CLSID_RTPRenderFilterProperties;

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// INonDelegatingUnknown implemented methods                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRtpRenderFilter::NonDelegatingQueryInterface(
    REFIID  riid, 
    void ** ppv
    )

/*++

Routine Description:

    Returns an interface and increments the reference count.

Arguments:

    riid - reference identifier. 

    ppv - pointer to the interface. 

Return Values:

    Returns a pointer to the interface.

--*/

{
#ifdef DEBUG_CRITICAL_PATH
    
    TraceDebug((
        TRACE_TRACE, 
        TRACE_CRITICAL, 
        TEXT("CRtpRenderFilter::NonDelegatingQueryInterface")
        ));

#endif // DEBUG_CRITICAL_PATH

    // validate pointer
    CheckPointer(ppv,E_POINTER);

    // obtain proper interface
    if (riid == IID_IPersistStream) {
        
        // return pointer to this object 
        return GetInterface((IPersistStream *)this, ppv);

    } else if (riid == IID_ISpecifyPropertyPages) {
        
        // return pointer to this object 
        return GetInterface((ISpecifyPropertyPages *)this, ppv);

    } else if ((riid == IID_IBaseFilter) || (riid == IID_IMediaFilter)) {

        // return pointer to this object 
        return GetInterface((IBaseFilter *)this, ppv);

    } else if (riid == IID_IAMFilterMiscFlags) {

        // return pointer to this object 
        return GetInterface((IAMFilterMiscFlags *)this, ppv);

    } else if (riid == IID_IRTPStream ||
               riid == IID_IRTCPStream ||
               riid == IID_IRTPParticipant) {

        // obtain pointer to default output pin object
        CRtpInputPin * pRtpInputPin = (CRtpInputPin *)GetPin(0);

        // forward request to default pin object
        return pRtpInputPin->NonDelegatingQueryInterface(riid, ppv);

    } else {

        // forward this request to the base object
        return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\queue.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    queue.cpp

Abstract:

    Implementation of CSampleQueue class.

Environment:

    User Mode - Win32

Revision History:

    02-Dec-1996 DonRyan
        Created.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSampleQueue Implementation                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CSampleQueue::CSampleQueue(
		HRESULT * phr
    )

/*++

Routine Description:

    Constructor for CSampleQueue class.    

Arguments:

    phr - pointer to the general OLE return value. 

Return Values:

    Returns an HRESULT value. 

--*/
	: m_pvContext(NULL),
	  m_pSharedList(NULL),
	  m_pSharedLock(NULL)
{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CSampleQueue::CSampleQueue")
        ));

    // initialize free list
    InitializeListHead(&m_FreeList);

    // initialize outstanding list
    InitializeListHead(&m_SampleList);
}


CSampleQueue::~CSampleQueue(
    )

/*++

Routine Description:

    Destructor for CSampleQueue class.    

Arguments:

    None.

Return Values:

    None.

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_ALWAYS, 
        TEXT("CSampleQueue::~CSampleQueue")
        ));

    // list entry
    PLIST_ENTRY pLE;

    // sample list entry
    PSAMPLE_LIST_ENTRY pSLE;

    // process free list entries
    while (!IsListEmpty(&m_FreeList)) {

        // remove from beginning of list
        pLE = RemoveHeadList(&m_FreeList);

        // obtain sample list entry from list entry
        pSLE = CONTAINING_RECORD(pLE, SAMPLE_LIST_ENTRY, Link);

        // nuke
		
		DbgLog((
				LOG_TRACE, 
				LOG_DEVELOP2, 
				TEXT("CSampleQueue::~CSampleQueue: delete pSLE: %X"),
				pSLE
			));
       delete pSLE;
    }

    // process used list entries
    while (!IsListEmpty(&m_SampleList)) {

        // remove from beginning of list
        pLE = RemoveHeadList(&m_SampleList);

        // obtain sample list entry from list entry
        pSLE = CONTAINING_RECORD(pLE, SAMPLE_LIST_ENTRY, Link);

		DbgLog((
				LOG_TRACE, 
				LOG_DEVELOP2, 
				TEXT("CSampleQueue::~CSampleQueue: delete SLE: 0x%X"),
				pSLE
			));
        // release sample
        pSLE->pSample->Release();

        // nuke
        delete pSLE;
    }
}


HRESULT
CSampleQueue::Alloc(
    IMediaSample *       pSample,
    PSAMPLE_LIST_ENTRY * ppSLE
    )

/*++

Routine Description:

    Allocates list entry and initializes with sample.

Arguments:

    pSample - sample to initialize with.

    ppSLE - pointer to list entry to fill in.

Return Values:

    Returns an HRESULT value.

--*/

{
#ifdef DEBUG_CRITICAL_PATH

    DbgLog((
        LOG_TRACE, 
        LOG_CRITICAL, 
        TEXT("CSampleQueue::Alloc")
        ));

#endif // DEBUG_CRITICAL_PATH

    // obtain lock to this object
    CAutoLock LockThis(pStateLock());

    // list entry
    PLIST_ENTRY pLE;

    // sample list entry
    PSAMPLE_LIST_ENTRY pSLE = NULL;

    // initialize
    HRESULT hr = S_OK;

    // check if any free buffers
    if (!IsListEmpty(&m_FreeList)) {

        // remove from beginning of list
        pLE = RemoveHeadList(&m_FreeList);

        // obtain sample list entry from list entry
        pSLE = CONTAINING_RECORD(pLE, SAMPLE_LIST_ENTRY, Link);

    } else {

        // allocate brand new one
        pSLE = new SAMPLE_LIST_ENTRY;
		
		DbgLog((
                LOG_TRACE, 
                LOG_DEVELOP2, 
                TEXT("CSampleQueue::Alloc: new SLE 0x%X"),
				pSLE
			));
		
        // validate
        if (pSLE == NULL) {

            DbgLog((
                LOG_ERROR, 
                LOG_ALWAYS, 
                TEXT("Could not allocate sample list entry")
                ));

            hr = E_OUTOFMEMORY; // fail..
        }
    }

    // make sure allocatation worked
    if (SUCCEEDED(hr) && (pSLE != NULL)) {

        // initialize buffer to zero
        ZeroMemory(pSLE, sizeof(SAMPLE_LIST_ENTRY));
		pSLE->pCSampleQueue = this;
		
        // retrieve a pointer to the actual data
        hr = pSample->GetPointer((PBYTE*)&pSLE->Buffer.buf);
        
        // validate
        if (SUCCEEDED(hr)) {

            // retrieve the actual data length
			pSLE->Buffer.len = pSample->GetSize();

            // initialize receive address length
            pSLE->SockAddrLen = sizeof(pSLE->SockAddr);

            // save pointer to sample
            pSLE->pSample = pSample;

        } else {

            DbgLog((
                LOG_ERROR, 
                LOG_ALWAYS, 
                TEXT("CMediaSample::GetPointer returned 0x%08lx"), hr 
                ));

            // add list entry back to free list
            InsertTailList(&m_FreeList, &pSLE->Link);
        }
    }

    // copy
    *ppSLE = pSLE;

    return hr;
}


HRESULT
CSampleQueue::Free(
    PSAMPLE_LIST_ENTRY pSLE
    )

/*++

Routine Description:

    Adds entry to free list.

Arguments:

    pSLE - pointer to list entry to free.

Return Values:

    Returns an HRESULT value.

--*/

{
#ifdef DEBUG_CRITICAL_PATH

    DbgLog((
        LOG_TRACE, 
        LOG_CRITICAL, 
        TEXT("CSampleQueue::Free")
        ));

#endif // DEBUG_CRITICAL_PATH

    // obtain lock to this object
    CAutoLock LockThis(pStateLock());

    // add to free list
    InsertTailList(&m_FreeList, &pSLE->Link);

    return S_OK;    
}


HRESULT
CSampleQueue::FreeAll(
    )

/*++

Routine Description:

    Initializes sample list to be empty.

Arguments:

    None.

Return Values:

    Returns an HRESULT value.

--*/

{
    DbgLog((
        LOG_TRACE, 
        LOG_DEVELOP, 
        TEXT("CSampleQueue::FreeAll")
        ));

    // obtain lock to this object
    CAutoLock LockThis(pStateLock());

    // list entry
    PLIST_ENTRY pLE, pLEAux;

    // sample list entry
    PSAMPLE_LIST_ENTRY pSLE;

    // process used list entries
    while (!IsListEmpty(&m_SampleList)) {

        // remove from sample list
        pLE = RemoveHeadList(&m_SampleList);

        // obtain sample list entry from list entry
        pSLE = CONTAINING_RECORD(pLE, SAMPLE_LIST_ENTRY, Link);

        // release sample
        pSLE->pSample->Release();

        // add to free list
        InsertTailList(&m_FreeList, pLE);
    }

	// process our items in shared list
	if (m_pSharedList && !IsListEmpty(m_pSharedList)) {
		
		EnterCriticalSection(m_pSharedLock);
		pLE = m_pSharedList->Flink;
		do {
			pSLE = CONTAINING_RECORD(pLE, SAMPLE_LIST_ENTRY, Link);

			pLEAux = pLE;
			pLE = pLE->Flink;
			
			if (pSLE->pCSampleQueue == this) {
				RemoveEntryList(pLEAux);
				pSLE->pSample->Release();
				InsertTailList(&m_FreeList, pLEAux);
			}
		} while(pLE != m_pSharedList);
		LeaveCriticalSection(m_pSharedLock);
	}

    return S_OK;
}


HRESULT
CSampleQueue::Pop(
    PSAMPLE_LIST_ENTRY * ppSLE
    )

/*++

Routine Description:

    Removes next processed entry list from list.

Arguments:

    ppSLE - pointer to list entry to fill in.

Return Values:

    Returns an HRESULT value.

--*/

{
#ifdef DEBUG_CRITICAL_PATH

    DbgLog((
        LOG_TRACE, 
        LOG_CRITICAL, 
        TEXT("CSampleQueue::Pop")
        ));

#endif // DEBUG_CRITICAL_PATH

    // obtain lock to this object
    CAutoLock LockThis(pStateLock());

    // list entry
    PLIST_ENTRY pLE;

    // sample list entry
    PSAMPLE_LIST_ENTRY pSLE = NULL;

    // check if any free buffers
    if (!IsListEmpty(&m_SampleList)) {

        // get first entry link
        pLE = m_SampleList.Flink;

        // obtain sample list entry from list entry
        pSLE = CONTAINING_RECORD(pLE, SAMPLE_LIST_ENTRY, Link);
    
        // check completion status
        if (pSLE->Status != ERROR_IO_PENDING) {

            // remove from list
            RemoveEntryList(&pSLE->Link);

        } else {

            // reset
            pSLE = NULL;
        }
    }

    // copy ptr 
    *ppSLE = pSLE;

    // adjust return code based on pointer
    return (pSLE != NULL) ? S_OK : E_PENDING;
}


HRESULT
CSampleQueue::Push(
    PSAMPLE_LIST_ENTRY pSLE
    )

/*++

Routine Description:

    Adds entry to list being processed.

Arguments:

    pSLE - pointer to list entry to queue.

Return Values:

    Returns an HRESULT value.

--*/

{
#ifdef DEBUG_CRITICAL_PATH

    DbgLog((
        LOG_TRACE, 
        LOG_CRITICAL, 
        TEXT("CSampleQueue::Push")
        ));

#endif // DEBUG_CRITICAL_PATH

    // obtain lock to this object
    CAutoLock LockThis(pStateLock());

    // initialize completion status
    pSLE->Status = ERROR_IO_PENDING;

    // add to free list
    InsertTailList(&m_SampleList, &pSLE->Link);

    return S_OK;    
}

void
CSampleQueue::Ready(SAMPLE_LIST_ENTRY *pSLE)
{
    // obtain lock to this object
    CAutoLock LockThis(pStateLock());

	// remove from sample list
	RemoveEntryList(&pSLE->Link);

	// put into shared list
	EnterCriticalSection(m_pSharedLock);
	
	InsertTailList(m_pSharedList, &pSLE->Link);
	
	LeaveCriticalSection(m_pSharedLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\rtpalloc.h ===
//
// rtpalloc.h - RTP Streaming allocator
//
// Copyright (C) Microsoft Corporation, 1996 - 1999  All rights reserved.
//


//
// derived media sample implementation
//  the reason for this is to add the special feature of being able
//  to adjust the buffer pointer.
class CRTPSample : public CMediaSample
{
public:
    CRTPSample(
        TCHAR *pName,
        CBaseAllocator *pAllocator,
        HRESULT *phr,
        LPBYTE pBuffer = NULL,
        LONG length = 0
        )

        : CMediaSample(pName, pAllocator, phr, pBuffer, length)
    {
    }

    //Overrides
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
};


//
// Create an allocator
//
// this class is really ripped off from the CMemAllocator implementation
//  in Quartz.  The difference here is that in Alloc this allocator 
//  creates CRTPSamples rather than CMediaSamples
//
class CRTPAllocator : public CBaseAllocator
{

    LPBYTE m_pBuffer;       // combined memory for all buffers

protected:
    STDMETHODIMP SetProperties(
                    ALLOCATOR_PROPERTIES* pRequest,
                    ALLOCATOR_PROPERTIES* pActual);

    // override to free the memory when decommit completes
    // - we actually do nothing, and save the memory until deletion.
    void Free(void);

    // called from the destructor (and from Alloc if changing size/count) to
    // actually free up the memory
    void ReallyFree(void);

    // overriden to allocate the memory when commit called
    HRESULT Alloc(void);

public:

    CRTPAllocator(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CRTPAllocator();

    // Provide access to a couple of base class members.
    int FreeCount() { return m_lFree.GetCount(); }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\session.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    session.cpp

Abstract:

    Implementation of CRtpSession class.

Environment:

    User Mode - Win32

Revision History:

    06-Nov-1996 DonRyan
        Created.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"

#define DBG_DWKIND 1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#if defined(DEBUG)
//#define _MYTHREAD_
#endif

#define DEBUG_ADDR 0xef020304  
#define DEBUG_PORT 0x5678      

// Registry QOS enable/disable
#define QOS_ROOT_REGISTRY HKEY_LOCAL_MACHINE
#define QOS_PATH_REGISTRY \
  "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\DxmRTP\\QOS"
#define QOS_KEY_OPEN_FLAGS (KEY_QUERY_VALUE|KEY_ENUMERATE_SUB_KEYS)
#define QOS_KEY_ENABLE        "Enabled"
#define QOS_KEY_DISABLEFLAGS  "DisableFlags"
#define QOS_KEY_ENABLEFLAGS   "EnableFlags"
#define QOS_KEY_TEMPLATE      "PayloadType"
 
DWORD GetRegistryQOSSetting(DWORD *pEnabled,
                            char *pName, DWORD NameLen,
                            DWORD *pdwDisableFlags,
                            DWORD *pdwEnableFlags);

// RTCP SDES items user defaults
#define RTP_INFO_ROOT_KEY HKEY_CURRENT_USER
#define RTP_INFO_SUBKEY   "RTP/RTCPSdesInfo"

#define NOT_ALLOWEDTOSEND_RATE 10  // kbits/s

#define YES 1
#define NO 0

class CQuerySocket
{
    SOCKET m_Socket;

public:
    CQuerySocket();
    ~CQuerySocket();
    
    inline SOCKET GetSocket()
        {
            return(m_Socket);
        }
};

// The query socket is used to query for local IP address(es)
// and default interface for a given destination address
CQuerySocket g_RTPQuerySocket;

#if 0
static int LookUpRegistryQOS(QOS *pQOS,int senderOnly);
static void CopyRegistryQOS(HKEY hk,QOS *pQOS,int senderOnly);
#endif

#define SOCKET_ISRX 0x01
#define SOCKET_ISTX 0x02
#define SOCKET_ISRXTX (SOCKET_ISRX | SOCKET_ISTX)

long g_lSessionID = 0;
CCritSec g_cJoinLeaveLock; // serializes access to Join, Leave

void CALLBACK
RRCMCallback(           
        DXMRTP_EVENT_T sEventType,
        DWORD        dwP_1,
        DWORD        dwP_2,
        void        *pvUserInfo);

#if defined(DEBUG)

static void loc_getsocketname(char *msg, SOCKET s, BOOL isSender);
#if defined(_MYTHREAD_)
typedef struct _MY_THREAD {
    HANDLE hThread;
    DWORD ThreadId;
    CRtpSession *pCRtps;
} MY_THREAD, *PMY_THREAD;

#define MAX_MY_THREAD 10
MY_THREAD MyThread[MAX_MY_THREAD];

int cMyThread = 0;

void StartMyThread(CRtpSession *pCRTPSession);
void StopMyThread(CRtpSession *pCRTPSession);
#endif

#endif


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Structures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CSocketManager g_SocketManager;

// Holds global information about the local IP address(es)

#define MAX_IPADDRS 16
#define MAX_USER_NAME 64
#define MAX_HOST_NAME 256

DWORD RTPValidateLocalIPAddress(SOCKADDR_IN *pSockAddrIn);
HRESULT RTPGetLocalIPAddress(SOCKET_ADDRESS_LIST **ppSockAddrList);

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


// Internal function, NULL pointer test in sAddr is not needed
char *RtpNtoA(DWORD dwAddr, char *sAddr)
{
    sprintf(sAddr, "%u.%u.%u.%u",
            (dwAddr & 0xff),
            (dwAddr >> 8) & 0xff,
            (dwAddr >> 16) & 0xff,
            (dwAddr >> 24) & 0xff);
            
    return(sAddr);
}

#if defined(DEBUG)
void dumpFlowSpec(char *str, FLOWSPEC *pFlowSpec)
{
    sprintf(str,
            "TokenRate:%d, "
            "TokenBucketSize:%d, "
            "PeakBandwidth:%d, "
            "ServiceType:%d "
            "MaxSduSize:%d "
            "MinPolicedSize:%d",
            pFlowSpec->TokenRate,
            pFlowSpec->TokenBucketSize,
            pFlowSpec->PeakBandwidth,
            pFlowSpec->ServiceType,
            pFlowSpec->MaxSduSize,
            pFlowSpec->MinimumPolicedSize
        );
}

void dumpQOS(char *msg, QOS *pQOS)
{
    char str[256];
    
    dumpFlowSpec(str, &pQOS->SendingFlowspec);
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("%s: SendingFlowspec:   %s"), msg, str
        ));

    dumpFlowSpec(str, &pQOS->ReceivingFlowspec);
    TraceDebug((
            TRACE_TRACE, 
            TRACE_DEVELOP, 
            TEXT("%s: ReceivingFlowspec: %s"), msg, str
        ));
}

void dumpSTATUS_INFO(char *msg, RSVP_STATUS_INFO *object)
{
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("%s: RSVP_STATUS_INFO: "
                 "StatusCode: %d, "
                 "ExStatus1: %d, "
                 "ExStatus2: %d"),
            msg, object->StatusCode,
            object->ExtendedStatus1, 
            object->ExtendedStatus2
        ));
}

void dumpRESERVE_INFO(char *msg, RSVP_RESERVE_INFO *object)
{
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("%s: RSVP_RESERVE_INFO: "
                 "Style: %d, "
                 "ConfirmRequest: %d, "
                 "PolicyElementList: %s, "
                 "NumFlowDesc: %d"
                ),
            msg, object->Style,
            object->ConfirmRequest,
            (object->PolicyElementList)? TEXT("Yes") : TEXT("No"),
            object->NumFlowDesc
        ));
}

void dumpADSPEC(char *msg, RSVP_ADSPEC *object)
{
    char str[256];

    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("%s: RSVP_ADSPEC: %d Service(s)"),
            msg, object->NumberOfServices
        ));

    str[0] = '\0';
    
    for(unsigned int i = 0; i < object->NumberOfServices; i++) {
        sprintf(str,
                "Service[%d]: %d, Guaranteed: "
                "CTotal: %d, "
                "DTotal: %d, "
                "CSum: %d, "
                "DSum: %d",
                i,
                object->Services[i].Service,
                object->Services[i].Guaranteed.CTotal,
                object->Services[i].Guaranteed.DTotal,
                object->Services[i].Guaranteed.CSum,
                object->Services[i].Guaranteed.DSum);

        TraceDebug((
                TRACE_TRACE,
                TRACE_DEVELOP, 
                TEXT("%s: %s"),
                msg, str
            ));
    }
}

void dumpObjectType(char *msg, char *ptr, unsigned int len)
{
    QOS_OBJECT_HDR *hdr;
        
    while(len > sizeof(QOS_OBJECT_HDR)) {

        hdr = (QOS_OBJECT_HDR *)ptr;

        if (len >= hdr->ObjectLength) {
            switch(hdr->ObjectType) {
            case RSVP_OBJECT_STATUS_INFO:
                dumpSTATUS_INFO(msg, (RSVP_STATUS_INFO *)hdr);
                break;
            case RSVP_OBJECT_RESERVE_INFO:
                dumpRESERVE_INFO(msg, (RSVP_RESERVE_INFO *)hdr);
                break;
            case RSVP_OBJECT_ADSPEC:
                dumpADSPEC(msg, (RSVP_ADSPEC *)hdr);
                break;
            case QOS_OBJECT_END_OF_LIST:
                len = hdr->ObjectLength; // Finish
                break;
            default:
                // don't have code to decode this, skip it
                break;
            }

            ptr += hdr->ObjectLength;
            len -= hdr->ObjectLength;
        } else {
            // Error
            len = 0;
        }
    }
}
#endif

const
char *sQOSEventString[] = {"NOQOS",
                           "RECEIVERS",
                           "SENDERS",
                           "NO_SENDERS",
                           "NO_RECEIVERS",
                           "REQUEST_CONFIRMED",
                           "ADMISSION_FAILURE",
                           "POLICY_FAILURE",
                           "BAD_STYLE",
                           "BAD_OBJECT",
                           "TRAFFIC_CTRL_ERROR",
                           "GENERIC_ERROR",
                           "NOT_ALLOWEDTOSEND",
                           "ALLOWEDTOSEND",
                           "????"};

DWORD
findQOSError(QOS *pQOS)
{
    DWORD dwError = -1;
    
    if (pQOS->ProviderSpecific.buf && 
        pQOS->ProviderSpecific.len >= sizeof(QOS_OBJECT_HDR)) {

        long            len = pQOS->ProviderSpecific.len;
        char           *ptr = pQOS->ProviderSpecific.buf;
        QOS_OBJECT_HDR *hdr = (QOS_OBJECT_HDR *)ptr;
        
        while(len > sizeof(QOS_OBJECT_HDR)) {

            hdr = (QOS_OBJECT_HDR *)ptr;

            if (len >= long(hdr->ObjectLength)) {
                switch(hdr->ObjectType) {
                case RSVP_OBJECT_STATUS_INFO:
                    dwError = ((RSVP_STATUS_INFO *)hdr)->StatusCode;
                    len = hdr->ObjectLength;
                    break;
                case RSVP_OBJECT_RESERVE_INFO:
                case RSVP_OBJECT_ADSPEC:
                    break;
                case QOS_OBJECT_END_OF_LIST:
                default:
                    len = hdr->ObjectLength; // Finish
                }
                
                ptr += hdr->ObjectLength;
                len -= hdr->ObjectLength;
            }
        }
    }

    return(dwError);
}

void
CRtpSessionQOSNotify(DWORD        dwError,
                     void        *pvCRtpSession,
                     QOS         *pQOS)
{
    if (pvCRtpSession && pQOS) {

        CRtpSession *pCRtpSession = (CRtpSession *)pvCRtpSession;
        
        DWORD dwSessionID = 0;
        
        pCRtpSession->GetSessionID(&dwSessionID);
        
        TraceRetail((
                TRACE_TRACE,
                TRACE_DEVELOP,
                TEXT("CRtpSessionQOSNotify: "
                     "Event:>>>%s<<<, SessionID:%d is %s"),
                sQOSEventString[dwError],
                dwSessionID,
                (pCRtpSession->IsSender())? "SEND":"RECV"
            ));

#if defined(DEBUG)
        dumpQOS("CRtpSessionQOSNotify", pQOS);
            
        if (pQOS->ProviderSpecific.buf && 
            pQOS->ProviderSpecific.len >= sizeof(QOS_OBJECT_HDR)) {
                
            dumpObjectType("CRtpSessionQOSNotify",
                           pQOS->ProviderSpecific.buf,
                           pQOS->ProviderSpecific.len);
        }
#endif
                
        // Post the event
        if (pCRtpSession->IsQOSEventEnabled(dwError)) {
            
            pCRtpSession->HandleCRtpSessionNotify(DXMRTP_QOSEVENTBASE,
                                                  dwError,
                                                  0, dwSessionID);
        }
        
        if (!pCRtpSession->IsSender())
            return; // Nothing else to do if not a sender
        
        // If RECEIVERS or NO_RECEIVERS update sender state
        if (dwError == DXMRTP_QOSEVENT_RECEIVERS) {
    
            // Was not allowed to send, now I will be,
            // post the event if enabled
            if (!pCRtpSession->TestFlags(FG_SENDSTATE) &&
                pCRtpSession->IsQOSEventEnabled(
                        DXMRTP_QOSEVENT_ALLOWEDTOSEND)) {
                
                TraceRetail((
                        TRACE_TRACE,
                        TRACE_DEVELOP,
                        TEXT("CRtpSessionQOSNotify: "
                             "Event:>>>%s<<<, SessionID:%d is %s"),
                        sQOSEventString[DXMRTP_QOSEVENT_ALLOWEDTOSEND],
                        dwSessionID,
                        (pCRtpSession->IsSender())? "SEND":"RECV"
                    ));

                pCRtpSession->HandleCRtpSessionNotify(
                        DXMRTP_QOSEVENTBASE,
                        DXMRTP_QOSEVENT_ALLOWEDTOSEND,
                        0, dwSessionID);
            }
            
            pCRtpSession->ModifyFlags(FG_RECEIVERSSTATE, 1);
            pCRtpSession->ModifyFlags(FG_SENDSTATE, 1);
            pCRtpSession->ModifyFlags(FG_SENDPATHMSG, 0);
            
        } else if (dwError == DXMRTP_QOSEVENT_NO_RECEIVERS) {
            
            pCRtpSession->ModifyFlags(FG_RECEIVERSSTATE, 0);
            
            if (pCRtpSession->TestFlags(FG_SENDIFALLOWED2) &&
                pCRtpSession->TestFlags(FG_SENDIFRECEIVERS2)) {

                // There are no receivers, instead of deciding not to
                // send, ask for the permission again, if permission
                // is granted, continue sending, otherwise, wait until
                // there are receivers.

                DWORD dwAllowedToSend = YES;
                
                if (pCRtpSession->GetpCShRtpSocket()) {

                    CRtpQOSReserve *pCRtpQOSReserve =
                        pCRtpSession->GetpCShRtpSocket()->GetpCRtpQOSReserve();

                    // Test if we want to force the result
                    if (pCRtpSession->TestFlags(FG_ENABLE_ALLOWEDTOSEND_WILLFAIL)) {
                        dwAllowedToSend =
                            pCRtpSession->TestFlags(FG_ALLOWEDTOSEND_WILLFAIL)?
                            NO:YES;
                    } else if (pCRtpQOSReserve) {
                        dwAllowedToSend = 
                            SUCCEEDED(pCRtpQOSReserve->AllowedToSend())?
                            YES:NO;
                    }
                }

                if (dwAllowedToSend) {
                    // we are allowed to send
                    pCRtpSession->ModifyFlags(FG_SENDSTATE, 1);
                    pCRtpSession->ModifyFlags(FG_SENDPATHMSG, 0);

                    return;
                }

                // Not allowed to send
                            
                pCRtpSession->ModifyFlags(FG_SENDSTATE, 0);
                pCRtpSession->SetCredits(0, GetTickCount());
                
                // I was sending, now I'm disallowed to send,
                // post the event if enabled
                if (pCRtpSession->IsQOSEventEnabled(
                        DXMRTP_QOSEVENT_NOT_ALLOWEDTOSEND)) {
                    
                    TraceRetail((
                            TRACE_TRACE,
                            TRACE_DEVELOP,
                            TEXT("CRtpSessionQOSNotify: "
                                 "Event:>>>%s<<<, SessionID:%d is %s"),
                            sQOSEventString[DXMRTP_QOSEVENT_NOT_ALLOWEDTOSEND],
                            dwSessionID,
                            (pCRtpSession->IsSender())? "SEND":"RECV"
                        ));
                
                    pCRtpSession->HandleCRtpSessionNotify(
                            DXMRTP_QOSEVENTBASE,
                            DXMRTP_QOSEVENT_NOT_ALLOWEDTOSEND,
                            0, dwSessionID);
                }
                
                pCRtpSession->ModifyFlags(FG_SENDPATHMSG, 1);
            }
        }
    } else {
        TraceDebug((
                TRACE_ERROR,
                TRACE_DEVELOP, 
                TEXT("CRtpSessionQOSNotify: "
                     "NULL pointer passed as argument")
            ));
    }
}

// Returns 1 if the address was found or if the
// address can not be validated.
// Returns 0 if address is invalid
// The function is responsible of freeing the buffer aloocated
// in RTPGetLocalIPAddress
DWORD RTPValidateLocalIPAddress(SOCKADDR_IN *pSockAddrIn)
{
    SOCKET_ADDRESS_LIST *pSockAddrList;

    if (FAILED(RTPGetLocalIPAddress(&pSockAddrList)))
        // If can not get address list say address is valid,
        // if it were not, bind will fail later
        return(1);

    // Scan list to validate
    SOCKADDR_IN *saddr_in;
    DWORD error = 0;
    
    for(int i = 0; i < pSockAddrList->iAddressCount; i++) {

        if (pSockAddrList->Address[i].lpSockaddr->sa_family != AF_INET)
            continue;

        saddr_in = (SOCKADDR_IN *)pSockAddrList->Address[i].lpSockaddr;

        if (saddr_in->sin_addr.s_addr == pSockAddrIn->sin_addr.s_addr) {
            error = 1;
            break;
        }
    }

    free((void *)pSockAddrList);
    return(error);
}
    
// Find the list of addresses, return a buffer allocated
// using malloc, the caller is responsible of freeing that buffer
HRESULT RTPGetLocalIPAddress(SOCKET_ADDRESS_LIST **ppSockAddrList)
{
    if (!ppSockAddrList)
        return(E_POINTER);

    DWORD   dwStatus;
    SOCKET  sock;

    HRESULT hr = E_FAIL;

    *ppSockAddrList = NULL;
    
    if ( (sock = g_RTPQuerySocket.GetSocket()) == INVALID_SOCKET ) {

        TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("RTPGetLocalIPAddress: no query socket available")
            ));
    } else {

        // Query for addresses
        DWORD dwSockAddrListSize = 0;

        for(;;) {
            
            DWORD dwNumBytesReturned = 0;
            
            if ((dwStatus = WSAIoctl(
                    sock, // SOCKET s
                    SIO_ADDRESS_LIST_QUERY, // DWORD dwIoControlCode
                    NULL,                // LPVOID lpvInBuffer
                    0,                   // DWORD cbInBuffer
                    *ppSockAddrList,     // LPVOID lpvOUTBuffer
                    dwSockAddrListSize,  // DWORD cbOUTBuffer
                    &dwNumBytesReturned, // LPDWORD lpcbBytesReturned
                    NULL, // LPWSAOVERLAPPED lpOverlapped
                    NULL  // LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompROUTINE
                )) == SOCKET_ERROR) {
                
                // retrive error, WSAEFAULT means buffer not enough big
                if ((dwStatus = WSAGetLastError()) == WSAEFAULT) {

                    if (*ppSockAddrList)
                        free((void *)*ppSockAddrList);
                    
                    *ppSockAddrList = (SOCKET_ADDRESS_LIST *)
                        malloc(dwNumBytesReturned);

                    if (!*ppSockAddrList) {
                        // Not enough memory
                        TraceDebug((
                                TRACE_ERROR, 
                                TRACE_DEVELOP, 
                                TEXT("RTPGetLocalIPAddress: "
                                     "malloc failed")
                                ));
                        break;
                    }
                    
                    dwSockAddrListSize = dwNumBytesReturned;
                    
                } else {
                    // WSAIoctl failed
                    TraceRetail((
                            TRACE_ERROR, 
                            TRACE_DEVELOP, 
                            TEXT("RTPGetLocalIPAddress: "
                                 "WSAIoctl failed: %d (0x%X)"),
                            dwStatus, dwStatus
                        ));

                    break;
                }
            } else {
                // WSAIoctl succeded
                if (dwNumBytesReturned) {
#if defined(DEBUG)
                    TraceDebug((
                            TRACE_TRACE, 
                            TRACE_DEVELOP, 
                            TEXT("RTPGetLocalIPAddress: local IP address(es):")
                        ));
            
                    for(int i = 0; i < (*ppSockAddrList)->iAddressCount; i++) {
                        if ((*ppSockAddrList)->
                            Address[i].lpSockaddr->sa_family == AF_INET) {

                            SOCKADDR_IN *saddr_in = (SOCKADDR_IN *)
                                (*ppSockAddrList)->Address[i].lpSockaddr;
                            
                            char LocalAddr[RTPNTOASIZE];
                            
                            TraceDebug((
                                    TRACE_TRACE, 
                                    TRACE_DEVELOP, 
                                    TEXT("            IP Address[%d]: %s"),
                                    i,
                                    RtpNtoA(saddr_in->sin_addr.s_addr,
                                            LocalAddr)
                                ));
                        }
                    }
#endif
                    hr = NOERROR;
                }
                break;
            }
        }
    }

    if (FAILED(hr) && *ppSockAddrList) {
        free(*ppSockAddrList);
        *ppSockAddrList = NULL;
    }
    
    return(hr);
}

void CALLBACK 
RecvCompletionRoutine(  
    IN  DWORD           Status, 
    IN  DWORD           BytesTransferred, 
    IN  LPWSAOVERLAPPED pOverlapped, 
    IN  DWORD           Flags
    )

/*++

Routine Description:

    Callback for completing asynchronous reads.

Arguments:

    Status - completion status for the overlapped operation. 

    BytesTransferred - number of bytes transferred.

    pOverlapped - pointer to overlapped structure.

    Flags - receive flags.

Return Values:

    None.

--*/

{
#ifdef DEBUG_CRITICAL_PATH

    TraceDebug((
        TRACE_TRACE,
        TRACE_CRITICAL, 
        TEXT("RecvCompletionRoutine")
        ));
        
#endif // DEBUG_CRITICAL_PATH

    // obtain pointer to sample from context buffer
    PSAMPLE_LIST_ENTRY pSLE = (PSAMPLE_LIST_ENTRY)pOverlapped;

    // obtain lock to this object
    CAutoLock LockThis(pSLE->pCSampleQueue->pStateLock());

    // update list entry status
    pSLE->BytesTransferred = BytesTransferred;
    pSLE->Status           = Status;          
    pSLE->Flags            = Flags;

    // report status
    if (Status == NOERROR) {

        // adjust actual sample packet size
        pSLE->pSample->SetActualDataLength(BytesTransferred);

#ifdef DEBUG_CRITICAL_PATH

        TraceDebug((
            TRACE_TRACE,
            TRACE_CRITICAL, 
            TEXT("RecvCompletionRoutine (bytes=%d)"),
            BytesTransferred
            ));

#endif // DEBUG_CRITICAL_PATH
    
#if DBG

    } else {

        TraceDebug((
            TRACE_ERROR,
            TRACE_ALWAYS, 
            TEXT("RecvCompletionRoutine (status=0x%08lx)"),
            Status
            ));

#endif // DBG

    }

    // Remove this sample from the samples list and
    // put it in the shared list.
    pSLE->pCSampleQueue->Ready(pSLE);
}


void CALLBACK 
SendCompletionRoutine(  
    IN  DWORD           Status, 
    IN  DWORD           BytesTransferred, 
    IN  LPWSAOVERLAPPED pOverlapped, 
    IN  DWORD           Flags
    )

/*++

Routine Description:

    Callback for completing asynchronous writes.

Arguments:

    Status - completion status for the overlapped operation. 

    BytesTransferred - number of bytes transferred.

    pOverlapped - pointer to overlapped structure.

    Flags - receive flags.

Return Values:

    None.

--*/

{
#ifdef DEBUG_CRITICAL_PATH

    TraceDebug((
        TRACE_TRACE,
        TRACE_CRITICAL, 
        TEXT("SendCompletionRoutine")
        ));
        
#endif // DEBUG_CRITICAL_PATH

    // obtain pointer to sample from context buffer
    PSAMPLE_LIST_ENTRY pSLE = (PSAMPLE_LIST_ENTRY)pOverlapped;

    // obtain lock to this object
    CAutoLock LockThis(pSLE->pCSampleQueue->pStateLock());

    // update list entry status
    pSLE->BytesTransferred = BytesTransferred;
    pSLE->Status           = Status;          
    pSLE->Flags            = Flags;

#if DBG

    // report status
    if (Status != NOERROR) {

        TraceDebug((
            TRACE_ERROR,
            TRACE_ALWAYS, 
            TEXT("SendCompletionRoutine 0x%08lx"),
            Status
            ));
    }

#endif // DBG
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRtpSession Implementation                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static char *sdes_name[] = {"END", "CNAME", "NAME", "EMAIL", "PHONE",
                            "LOC", "TOOL",  "TXT",  "PRIV",  NULL};
static DWORD sdes_freq[] = {0, 1, 5, 21, 23,
                            29, 31, 33, 37};
static DWORD sdes_encr[] = {0, 0, 0, 0, 0, 0, 0, 0, 0};

CRtpSession::CRtpSession(
    LPUNKNOWN    pUnk, 
    HRESULT     *phr,
    BOOL         fSender,
    CBaseFilter *pCBaseFilter
    )

/*++

Routine Description:

    Constructor for CRtpSession class.    

Arguments:

    pUnk - IUnknown interface of the delegating object. 

    phr - pointer to the general OLE return value. 

    fSender - true if this object is for sending over rtp session. 

Return Values:

    Returns an HRESULT value. 

--*/

:   CUnknown(NAME("CRtpSession"), pUnk, phr),
    m_pRtpSocket(NULL),
    m_pRtcpSocket(NULL),
    m_pSampleQueue(NULL), 
    m_pRTPSession(NULL),
    m_RtpScope(DEFAULT_TTL),
    m_RtcpScope(DEFAULT_TTL),
    m_pCBaseFilter(pCBaseFilter),
    m_dwRTCPEventMask(B2M(DXMRTP_NEW_SOURCE_EVENT) |
                      B2M(DXMRTP_BYE_EVENT) |
                      B2M(DXMRTP_INACTIVE_EVENT) |
                      B2M(DXMRTP_ACTIVE_AGAIN_EVENT) |
                      B2M(DXMRTP_TIMEOUT_EVENT)),
    m_dwMaxFilters(1),    // by default just 1 participant
    m_dwMaxBandwidth(-1), // by default no limit (use flowspec as it is)
    m_dwSdesMask(-1),
    m_dwDataClock(0),
    m_lSessionClass(0)
{
    int idx;

    if (fSender)
        m_dwQOSEventMask =
            B2M(DXMRTP_QOSEVENT_NOT_ALLOWEDTOSEND) |
            B2M(DXMRTP_QOSEVENT_ALLOWEDTOSEND) |
            B2M(DXMRTP_QOSEVENT_RECEIVERS) |
            B2M(DXMRTP_QOSEVENT_NO_RECEIVERS) |
            0;
    else
        m_dwQOSEventMask =
            B2M(DXMRTP_QOSEVENT_SENDERS) |
            B2M(DXMRTP_QOSEVENT_NO_SENDERS) |
            B2M(DXMRTP_QOSEVENT_REQUEST_CONFIRMED) |
            0;
    
    m_dwQOSEventMask |= B2M(DXMRTP_QOSEVENT_ADMISSION_FAILURE);
    
    TraceRetail((
        TRACE_TRACE,
        TRACE_ALWAYS, 
        TEXT("CRtpSession::CRtpSession(%s)"),
        fSender? TEXT("SEND") : TEXT("RECV")
        ));

    // Flag defaults
    m_dwFlags =
        flags_par(FG_ENABLEREPORTS) |   /* RTCP reports enabled */
        flags_par(FG_SENDIFALLOWED) |   /* Ask for permission to send */
        flags_par(FG_SENDIFRECEIVERS) | /* Don't send if there are no
                                         * receivers */
        //flags_par(FG_SHAREDSTYLE)   | /* Initial defaults to SE */
        flags_par(FG_SHAREDSOCKETS) |   /* Shared sockets */
        0;
    
    // Set default priority
    if (fSender) {
        flags_set(FG_ISSENDER);
        m_lSessionPriority = THREAD_PRIORITY_TIME_CRITICAL - 5; // Sender
    } else {
        m_lSessionPriority = THREAD_PRIORITY_TIME_CRITICAL;     // Receiver
    }
    
    m_lSessionID = InterlockedIncrement(&g_lSessionID) - 1;

    // Initial value to local IP address to bind sockets
    ZeroMemory((void *)&m_LocalIPAddress, sizeof(m_LocalIPAddress));
    m_LocalIPAddress.sin_addr.s_addr = INADDR_ANY;
    m_LocalIPAddress.sin_family = AF_INET;
    m_LocalIPAddress.sin_port = htons(0);

#if defined(RRCMLIB)
    initRTP();
#endif
    //strcpy(m_QOSname,"G711");
    m_QOSname[0] = '\0';
    
    // allocate queue for media samples   
    m_pSampleQueue = new CSampleQueue(phr);

    // validate pointer
    if (m_pSampleQueue == NULL) {

        TraceDebug((
            TRACE_ERROR,
            TRACE_ALWAYS, 
            TEXT("Could not allocate sample queue") 
            ));

        *phr = E_OUTOFMEMORY;
        
        return; // bail...      
    }

#if DBG

    // initialize rtp address 
    m_RtpAddr.sin_family        = AF_INET;                   
    m_RtpAddr.sin_addr.s_addr   = htonl(DEBUG_ADDR);     
    m_RtpAddr.sin_port          = htons(DEBUG_PORT);     

    // initialize rtcp address 
    m_RtcpAddr.sin_family       = AF_INET;               
    m_RtcpAddr.sin_addr.s_addr  = htonl(DEBUG_ADDR);     
    m_RtcpAddr.sin_port         = htons(DEBUG_PORT + 1);   

#else  // DBG

    // initialize rtp address 
    m_RtpAddr.sin_family        = AF_INET;                   
    m_RtpAddr.sin_addr.s_addr   = 0;     
    m_RtpAddr.sin_port          = 0;     

    // initialize rtcp address 
    m_RtcpAddr.sin_family       = AF_INET;               
    m_RtcpAddr.sin_addr.s_addr  = 0;
    m_RtcpAddr.sin_port         = 0; 

#endif // DBG

    // initialize description strings
    ZeroMemory((char *)m_SdesData, sizeof(m_SdesData));
    
    // initialize length of description string buffer
    DWORD dwDataSize;
    DWORD dwDataType;
    SDES_DATA *pSdes;
    
    // Try to lookup RTP info from registry first,
    // then use default values.
    HKEY rtphk;
    if (RegOpenKeyEx(RTP_INFO_ROOT_KEY, RTP_INFO_SUBKEY, 0,
                     KEY_READ, &rtphk) == ERROR_SUCCESS) {

        DWORD dwfEnable = 0;

        dwDataSize = sizeof(dwfEnable);
        // Read the Enable flag
        RegQueryValueEx(rtphk, "Enable", 0,
                        &dwDataType,
                        (unsigned char *)&dwfEnable,
                        &dwDataSize);

        if (dwfEnable) {

            pSdes = &m_SdesData[SDES_INDEX(RTCP_SDES_CNAME)];
            
            for(idx = RTCP_SDES_CNAME; idx < RTCP_SDES_LAST; idx++, pSdes++) {

                dwDataSize = MAX_SDES_LEN;
                RegQueryValueEx(rtphk, sdes_name[idx], 0,
                                &dwDataType,
                                (unsigned char *)pSdes->sdesBfr,
                                &dwDataSize);
                // Disable this parameter if first char is '-'
                if (pSdes->sdesBfr[0] == '-')
                    pSdes->sdesBfr[0] = '\0';
            }
        }

        RegCloseKey(rtphk);
    }
    
    // attempt to retrieve user name
    char str[MAX_HOST_NAME + MAX_USER_NAME];
    char hostname[MAX_HOST_NAME];
    unsigned long strLen;

    strLen = sizeof(str);
    GetUserName(str,&strLen);

    ////////////////////////////////////
    // initialize remainder of structure
    ////////////////////////////////////

    // Name
    if (m_SdesData[SDES_INDEX(RTCP_SDES_NAME)].sdesBfr[0] == '\0')
        strcpy(m_SdesData[SDES_INDEX(RTCP_SDES_NAME)].sdesBfr, str);

    // CName
    // CNAME is always stablished by algorithm
    pSdes = &m_SdesData[SDES_INDEX(RTCP_SDES_CNAME)];
    strcpy(pSdes->sdesBfr, str);

    // Get host name
    if (gethostname(hostname, sizeof(hostname))) {

        TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::CRtpSession: gethostname failed: %d\n"),
                WSAGetLastError()
            ));
        
        hostname[0] = '\0';
    } else {
        
        TraceDebug((
                TRACE_TRACE,
                TRACE_DEVELOP2, 
                TEXT("CRtpSession::CRtpSession: gethostname: %s"),
                hostname
            ));

        struct hostent *he;
        
        if ( !(he = gethostbyname(hostname)) ) {

            TraceDebug((
                    TRACE_ERROR,
                    TRACE_DEVELOP, 
                    TEXT("CRtpSession::CRtpSession: gethostbyname failed: %d\n"),
                    WSAGetLastError()
                ));
        } else {
            strcpy(hostname, he->h_name);

            TraceDebug((
                    TRACE_TRACE,
                    TRACE_DEVELOP2, 
                    TEXT("CRtpSession::CRtpSession: gethosbytname: %s"),
                    hostname
                ));
        }
    }

    
    if (hostname[0]) {
        strcat(pSdes->sdesBfr, "@");

        strcat(pSdes->sdesBfr, hostname);
    }
    
    // Tool
    // TOOL is stablished by algorithm
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(os);
    pSdes = &m_SdesData[SDES_INDEX(RTCP_SDES_TOOL)];
    if (GetVersionEx(&os))
        wsprintf(pSdes->sdesBfr,
#if defined(_X86_) 
                 "Win%s-x86-%u.%u.%u",
#else
                 "Win%s-alpha-%u.%u.%u",
#endif               
                 (os.dwPlatformId == VER_PLATFORM_WIN32_NT)? "NT":"",
                 os.dwMajorVersion,
                 os.dwMinorVersion,
                 os.dwBuildNumber);

    // Finish to initialize fields
    pSdes = &m_SdesData[SDES_INDEX(RTCP_SDES_CNAME)];
    for(idx = RTCP_SDES_CNAME; idx < RTCP_SDES_LAST; idx++, pSdes++) {
        pSdes->dwSdesType      = idx;
        pSdes->dwSdesLength    = strlen(pSdes->sdesBfr);
        if (pSdes->dwSdesLength)
            pSdes->dwSdesLength++;
        pSdes->dwSdesFrequency = sdes_freq[idx];
        pSdes->dwSdesEncrypted = sdes_encr[idx];
    }

#if defined(DEBUG) && defined(_MYTHREAD_)
    StartMyThread(this);
#endif

    *phr = NOERROR;
}


CRtpSession::~CRtpSession(
    )

/*++

Routine Description:

    Destructor for CRtpSession class.    

Arguments:

    None.

Return Values:

    None.

--*/

{
    TraceRetail((
        TRACE_TRACE,
        TRACE_ALWAYS, 
        TEXT("CRtpSession::~CRtpSession(%s)"),
        IsSender()? TEXT("SEND") : TEXT("RECV")
        ));

    if (IsJoined()) {

        TraceRetail((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::~CRtpSession: Leave first...")
           ));

        Leave();
    }

#if defined(RRCMLIB)
    deleteRTP();
#endif  
    // nuke sample queue
    delete m_pSampleQueue;

#if defined(DEBUG) && defined(_MYTHREAD_)
    StopMyThread(this);
#endif
}



HRESULT
CRtpSession::Join(
    )

/*++

Routine Description:

    Join a multimedia session. 

Arguments:

    None. 

Return Values:

    Returns an HRESULT value. 

--*/

{
    TraceRetail((
            TRACE_TRACE, 
            TRACE_DEVELOP, 
            TEXT("CRtpSession::Join +++++++++++++++++++++++++++++++++")
        ));

    TraceRetail((
            TRACE_TRACE, 
            TRACE_DEVELOP, 
            TEXT("CRtpSession::Join(%s/%s)"),
            IsSender()? "SEND" : "RECV",
            m_lSessionClass == RTP_CLASS_AUDIO? "AUDIO" : "VIDEO"
        ));

    // First get the lock to this object then the global, so
    // is some other member function of this object gets blocked,
    // this one doesn't hold also the global lock and
    // other threads can Join/Leave.

    // object lock to this object
    CAutoLock LockThis(pStateLock());

    CAutoLock gJoinLeave(&g_cJoinLeaveLock);
    
    // validate
    if (IsJoined()) {

        TraceRetail((
            TRACE_ERROR, 
            TRACE_DEVELOP, 
            TEXT("CRtpSession::Join: session already joined"), 
            WSAGetLastError()
            ));

        return S_OK; // bail...
    }

    HRESULT hr;
    DWORD dwStatus; 

    WSAPROTOCOL_INFO *pProtocolInfo = NULL;

    // Allow to disable QOS from the registry
    int do_qos = 0;
    
    if (flags_tst(FG_QOSSTATE)) {
        char  qos_name[MAX_QOS_NAME];
        DWORD qos_enabled;
        DWORD dwDisableFlags, dwEnableFlags;
        
        if (GetRegistryQOSSetting(&qos_enabled,
                                  qos_name, sizeof(qos_name),
                                  &dwDisableFlags,
                                  &dwEnableFlags)) {
            if ( (!strlen(m_QOSname) || flags_tst(FG_REG_QOSTEMPLATE)) &&
                strlen(qos_name)) {
                strncpy(m_QOSname, qos_name, sizeof(m_QOSname));
                // remember the template was got from the registry so
                // it is updated every time we come here
                flags_set(FG_REG_QOSTEMPLATE);
            }
            
            if (strlen(m_QOSname))
                do_qos = 1;
        }
        
        // These flags are not allowed to
        // be modified.
        DWORD inv_mask =
            fg_par(FG_ISJOINED) |
            fg_par(FG_ISSENDER) |
            fg_par(FG_SENDSTATE) |
            fg_par(FG_SENDIFALLOWED2) |
            fg_par(FG_RECEIVERSSTATE) |
            fg_par(FG_SENDIFRECEIVERS2) |
            fg_par(FG_EVENT_READY) |
            fg_par(FG_ISMULTICAST) |
            fg_par(FG_QOSNOTIFY_STARTED) |
            0;

        dwDisableFlags &= ~inv_mask;
        dwEnableFlags  &= ~inv_mask;

        // Flags that need to be disabled
        if (dwDisableFlags) {
            m_dwFlags &= ~dwDisableFlags;
        }

        // Flags that need to be enabled
        if (dwEnableFlags) {
            m_dwFlags |= dwEnableFlags;
        }
    }

    // Get local IP address(es)
    if (m_LocalIPAddress.sin_addr.s_addr == INADDR_ANY)
        SelectLocalIPAddressToDest((LPBYTE)&m_LocalIPAddress,
                                   sizeof(m_LocalIPAddress),
                                   (LPBYTE)&m_RtpAddr,
                                   sizeof(m_RtpAddr));

    // disable QoS for localhost address
    if (m_LocalIPAddress.sin_addr.s_addr == 0x0100007f)
        do_qos = 0;

    
    // QOS setting, step 1/2 (before socket creation)
    if (do_qos) {
        // Find out the protocol supporting QOS

        TraceDebug((
                TRACE_TRACE,
                TRACE_DEVELOP2, 
                TEXT("CRtpSession::Join: QOSstate=1 %s"),
                IsSender()? "Sender" : "Receiver"
            ));

        int status;
        int Protocols[2] = {IPPROTO_UDP, 0};
        WSAPROTOCOL_INFO AllProtoInfo[16];
        unsigned long cbAllProtoInfo = sizeof(AllProtoInfo);

        ZeroMemory((char *)&AllProtoInfo[0], sizeof(AllProtoInfo));
        
        status = WSAEnumProtocols(Protocols,
                                  &AllProtoInfo[0],
                                  &cbAllProtoInfo);

        if (status == SOCKET_ERROR) {

            TraceRetail((
                    TRACE_ERROR, 
                    TRACE_DEVELOP, 
                    TEXT("CRtpSession::Join: WSAEnumProtocols failed: %d\n"),
                    WSAGetLastError()
                ));

            // Disable QOS
            do_qos = 0;
            flags_rst(FG_QOSSTATE);
            
            // Notify upper layer of failure
            // TODO

            if (flags_tst(FG_FAILIFNOQOS)) {
                goto cleanup;
            }
        } else {
            
            for(pProtocolInfo = &AllProtoInfo[0];
                status > 0;
                status--, pProtocolInfo++) {

                if (pProtocolInfo->dwServiceFlags1 & XP1_QOS_SUPPORTED)
                    break;
            }
            
            if (!status) {

                TraceRetail((
                        TRACE_ERROR, 
                        TRACE_DEVELOP, 
                        TEXT("CRtpSession::Join: WSAEnumProtocols: "
                             "Unable to find QOS capable protocol\n")
                    ));

                // Disable QOS
                flags_rst(FG_QOSSTATE);
                do_qos = 0;
                pProtocolInfo = NULL;
                
                // Notify upper layer of failure
                // TODO
                
                if (flags_tst(FG_FAILIFNOQOS)) {
                    goto cleanup;
                }
            } else {
                TraceDebug((
                        TRACE_TRACE,
                        TRACE_DEVELOP2, 
                        TEXT("CRtpSession::Join: WSAEnumProtocols: "
                             "QOS capable protocol found")
                    ));
            }
        }
    }

    // ask socket manager for rtp socket. Init either for RECV or SEND
    DWORD dwKind;
    dwKind  = IsSender()? SOCKET_MASK_SEND : SOCKET_MASK_RECV;
    dwKind |= IsSender()? SOCKET_MASK_INIT_SEND : SOCKET_MASK_INIT_RECV;
    dwKind |= do_qos? SOCKET_MASK_QOS_SES : 0;
    dwKind |= do_qos? SOCKET_MASK_QOS_RQ  : 0;
    
    long  maxshare[2];
    
    if (flags_tst(FG_SHAREDSOCKETS)) {
        // allow up to 1 sender and 1 receiver per socket
        // this is the default
        maxshare[SOCKET_RECV] = 1;
        maxshare[SOCKET_SEND] = 1;
    } else {
        // just 1 sender or 1 receiver per socket
        if (IsSender()) {
            maxshare[SOCKET_RECV] = 0;
            maxshare[SOCKET_SEND] = 1;
        } else {
            maxshare[SOCKET_RECV] = 1;
            maxshare[SOCKET_SEND] = 0;
        }
    }
    
    DWORD cookie;

    // this cookie is used to help differentiate sockets that can be
    // shared on the same RTP session
    if (IS_MULTICAST(m_RtcpAddr.sin_addr.s_addr)) {
        /* use both ports in multicast ... */
        cookie = m_wRtcpLocalPort | (m_RtcpAddr.sin_port << 16);
    } else {
        /* ... but only local port in unicast */
        cookie = m_wRtcpLocalPort;
    }
    
    DWORD pAddr[2];
    WORD  pPort[2];

    pAddr[LOCAL]  = m_LocalIPAddress.sin_addr.s_addr;
    pAddr[REMOTE] = m_RtpAddr.sin_addr.s_addr;
    pPort[LOCAL]  = m_wRtpLocalPort;
    pPort[REMOTE] = m_RtpAddr.sin_port;
    
    dwStatus = g_SocketManager.GetSharedSocket(
            &m_pRtpSocket,
            maxshare,
            cookie,
            pAddr,
            pPort,
            m_RtpScope,
            dwKind,
            pProtocolInfo,       // Want QOS reservations
            m_dwMaxFilters,      // Max filters in QOS
            this                 // Session this socket belongs to
        );    

    m_pRtpSocket2 = m_pRtpSocket;
    
    // validate status
    if (dwStatus != NOERROR) {
        TraceRetail((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::Join: "
                     "GetSharedSocket(RTP): failed with error %d"),
                WSAGetLastError()
            ));
        
        goto cleanup; // bail...
    } else {
        TraceDebug((
                TRACE_TRACE,
                TRACE_DEVELOP2, 
                TEXT("CRtpSession::Join: "
                     "GetSharedSocket(RTP): %d"),
                m_pRtpSocket->GetShSocket()
            ));
    }
    
#if DEBUG
    // get RTP socket name
    loc_getsocketname("CRtpSession::Join: getsockname(RTP)",
                      m_pRtpSocket->GetShSocket(),
                      IsSender());
#endif

    // ask socket manager for RTCP socket. Init for RECV and SEND
    dwKind |= SOCKET_MASK_INIT_SEND | SOCKET_MASK_INIT_RECV;
    dwKind &=  ~SOCKET_MASK_QOS_RQ;

    // pAddr[LOCAL] doesn't change for RTCP, the same may apply to
    // REMOTE, but I better update it
    pAddr[REMOTE] = m_RtcpAddr.sin_addr.s_addr;
    pPort[LOCAL]  = m_wRtcpLocalPort;
    pPort[REMOTE] = m_RtcpAddr.sin_port;
    
    if (!IS_MULTICAST(m_RtcpAddr.sin_addr.s_addr)) {
        /* In unicast do not use remote RTCP port to match RTCP
         * sockets, i.e. force remote port to match */
        dwKind |= SOCKET_MASK_RTCPMATCH;
    }
    
    dwStatus = g_SocketManager.GetSharedSocket(
            &m_pRtcpSocket,
            maxshare,
            cookie,
            pAddr,
            pPort,
            m_RtcpScope,
            dwKind, // Receiver and Sender
            NULL,   // pProtocolInfo (don't want reservations in RTCP ...)
            0,      // No reservation, no filters
            this    // Session this socket belongs to.
        );

    m_pRtcpSocket2 = m_pRtcpSocket;

    if (dwStatus != NOERROR) {
        TraceRetail((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::Join: "
                     "GetSharedSocket(RTCP): failed with error %d"),
                WSAGetLastError()
            ));
        goto cleanup; // bail...
    } else {
        TraceDebug((
                TRACE_TRACE,
                TRACE_DEVELOP2, 
                TEXT("CRtpSession::Join: "
                     "GetSharedSocket(RTCP): %d"),
                m_pRtcpSocket->GetShSocket()
            ));
    }

#if DEBUG
    // get RTCP socket name
    loc_getsocketname("CRtpSession::Join: getsockname(RTCP)",
                      m_pRtcpSocket->GetShSocket(),
                      IsSender());
#endif

    // use rrcm to actually join
    dwKind = IsSender()? SOCKET_MASK_SEND : SOCKET_MASK_RECV;

    // if the sockets have already owner,
    // it MUST be the same for both sockets
    if (m_pRtpSocket->GetRTPSession() && m_pRtcpSocket->GetRTPSession()) {
        if (m_pRtpSocket->GetRTPSession() != m_pRtcpSocket->GetRTPSession()) {
            TraceRetail((
                    TRACE_ERROR, 
                    TRACE_DEVELOP, 
                    TEXT("CRtpSession::Join: failed, "
                         "sockets found have differnt owner")
                ));
            goto cleanup;
        }
    }

    // RTP Recv socket
    m_pSocket[SOCKET_RECV] = IsSender() ? 0 : m_pRtpSocket->GetShSocket();
    // RTP Send socket
    m_pSocket[SOCKET_SEND] = IsSender() ? m_pRtpSocket->GetShSocket() : 0;
    // RTCP Recv/Send socket
    m_pSocket[SOCKET_RTCP] = m_pRtcpSocket->GetShSocket();
    
    hr = CreateRTPSession(
            (void **)&m_pRTPSession,      // RTP session to be returned
            m_pSocket,                    // RTP recv, RTP send, RTCP socks
            (LPVOID)&m_RtcpAddr,          // RTCP To address
            sizeof(m_RtcpAddr),           // RTCP To addr len
            (SDES_DATA *)&m_SdesData[SDES_INDEX(RTCP_SDES_CNAME)], // SDES
            m_dwDataClock, // streamClock
            NULL,     // pEncryptionInfo
            0,        // SSRC
            RRCMCallback,   // pfnRRCMCallback
            (void *)this,   // CallbackUserInfo
            RTCP_ON,   // miscInfo
            0,         // bandwidth
            dwKind,    // Sender or Receiver
            maxshare   // Max senders/receivers
        );

    m_pRTPSession2 = m_pRTPSession;

    // validate session id
    if (FAILED(hr)) {

        TraceRetail((
            TRACE_ERROR, 
            TRACE_DEVELOP, 
            TEXT("CRtpSession::Join: CreateRTPSession: failed: 0x%08lx"), hr
            ));

        goto cleanup; // bail...
    } 

    TraceRetail((
            TRACE_TRACE, 
            TRACE_DEVELOP, 
            TEXT("CRtpSession::Join: CreateRTPSession(0x%X, %d, %d)"),
            m_pRTPSession,
            m_pRtpSocket->GetShSocket(),
            m_pRtcpSocket->GetShSocket()
        ));

    // set owner for shared sockets
    if (!m_pRtpSocket->GetRTPSession()) {
        m_pRtpSocket->SetRTPSession(m_pRTPSession);
    }
    if (!m_pRtcpSocket->GetRTPSession()) {
        m_pRtcpSocket->SetRTPSession(m_pRTPSession);
    }

    // both have owner, it MUST be the same
    if (m_pRtpSocket->GetRTPSession() != m_pRtcpSocket->GetRTPSession()) {
        TraceRetail((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::Join: failed, "
                     "sockets used have different owner")
            ));
        goto cleanup;
    }
    
    // Set now the event mask notification
    if (m_pRTPSession &&
        m_pRTPSession->pRTCPSession) {

        if (m_pRTPSession->pRTCPSession->pRRCMcallback)
            m_pRTPSession->pRTCPSession->dwEventMask[IsSender()? 1:0] =
                m_dwRTCPEventMask;

        m_pRTPSession->pRTCPSession->dwSdesMask |= m_dwSdesMask;
    }
        
    // now say we are ready to pass up events
    flags_set(FG_EVENT_READY);
                            
    // Turn off RTCP report transmission if necessary.
    if (!flags_tst(FG_ENABLEREPORTS)) {
        hr = RTCPSendSessionCtrl(
                  (void *)m_pRTPSession,
                  0xFFFFFFFF);
        if (FAILED(hr)) {
            TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("RTCPSendSessionCtrl returned 0x%08lx"), hr
                ));

            goto cleanup; // bail...
        } /* if */
    } /* if */

    // Set some current flags
    if (flags_tst(FG_SENDIFALLOWED))
        flags_set(FG_SENDIFALLOWED2);
    else
        flags_rst(FG_SENDIFALLOWED2);
    

    if (flags_tst(FG_SENDIFRECEIVERS))
        flags_set(FG_SENDIFRECEIVERS2);
    else
        flags_rst(FG_SENDIFRECEIVERS2);

    // Set the master flag to enable sending
    flags_set(FG_SENDSTATE);

    if ( do_qos && m_pRtpSocket->GetpCRtpQOSReserve() ) {
        
        // QOS setting, step 2/2 (after socket creation)
        CRtpQOSReserve *pCRtpQOSReserve = m_pRtpSocket->GetpCRtpQOSReserve();

#if defined(DEBUG)
        {
            char QOStypes[256];

            if (pCRtpQOSReserve->QueryTemplates(QOStypes, sizeof(QOStypes)) !=
                NOERROR) {

                TraceDebug((
                        TRACE_ERROR,
                        TRACE_DEVELOP,
                        TEXT("CRtpSession::Join: "
                             "QueryTemplates: failed: %d"),
                        WSAGetLastError()
                    ));
                
                if (flags_tst(FG_FAILIFNOQOS)) {
                    goto cleanup;
                }
            } else {
                
                TraceDebug((
                        TRACE_TRACE,
                        TRACE_DEVELOP,
                        TEXT("CRtpSession::Join: QueryTemplates: %s"),
                        QOStypes
                    ));
            }
        }
#endif

        QOS qos;

        char *qosClass;
        if (m_lSessionClass == RTP_CLASS_AUDIO)
            qosClass = "AUDIO";
        else if (m_lSessionClass == RTP_CLASS_VIDEO)
            qosClass = "VIDEO";
        else
            qosClass = "UNKNOWN";
        
        if (pCRtpQOSReserve->GetTemplate(m_QOSname,qosClass,&qos) != NOERROR) {

            TraceRetail((
                    TRACE_ERROR,
                    TRACE_DEVELOP,
                    TEXT("CRtpSession::Join: GetTemplate(%s): failed: %d"),
                    m_QOSname, WSAGetLastError()
                ));
            // Notify upper layer of failure
            // TODO

            if (flags_tst(FG_FAILIFNOQOS)) {
                goto cleanup;
            }
        } else {
            
            m_dwQOSEventMask2 = m_dwQOSEventMask;
            
            TraceRetail((
                    TRACE_TRACE,
                    TRACE_DEVELOP,
                    TEXT("CRtpSession::Join: GetTemplate(%s) succeeded"),
                    m_QOSname
                ));

            // Set the flow spec
            pCRtpQOSReserve->SetFlowSpec(IsSender()? &qos.SendingFlowspec :
                                         &qos.ReceivingFlowspec,
                                         IsSender());

            // Select the reservation style
            
            if (IS_MULTICAST(m_RtpAddr.sin_addr.s_addr)) {
                // Multicast
                DWORD Style = RSVP_WILDCARD_STYLE;
                
                if (flags_tst(FG_FORCE_MQOSSTYLE)) {
                    if (flags_tst(FG_MQOSSTYLE))
                        Style = RSVP_SHARED_EXPLICIT_STYLE;
                } else {
                    if (flags_tst(FG_SHAREDSTYLE)) 
                        Style = RSVP_SHARED_EXPLICIT_STYLE;
                }

                pCRtpQOSReserve->SetStyle(Style);
                
            } else {
                // Unicast (default is RSVP_FIXED_FILTER_STYLE)
                // but setting FF would oblige me
                // to set also a filter (address/port)

                pCRtpQOSReserve->SetStyle(RSVP_DEFAULT_STYLE);
            }

            // Set the destination address
            if (IsSender()) {
                pCRtpQOSReserve->SetDestAddr((LPBYTE)&m_RtpAddr,
                                             sizeof(m_RtpAddr));
            }

            // Set to a valid value the max number of filters
            if (flags_tst(FG_AUTO_SHAREDEXPLICIT)) {
                if (!m_dwMaxFilters)
                    m_dwMaxFilters = 3;
            }

            // Set the number of participants for wilcard
            // and the max number for shared explicit
            SetMaxQOSEnabledParticipants(m_dwMaxFilters,
                                         m_dwMaxBandwidth,
                                         flags_tst(FG_SHAREDSTYLE));


            // Ask for the reservation.
            // Specify FlowSpec if a sender and
            // Make a "real" reservation request if a receiver
            if (pCRtpQOSReserve->Reserve(IsSender()) != NOERROR) {
                // Notify upper layer of failure
                // TODO
                TraceRetail((
                        TRACE_ERROR, 
                        TRACE_DEVELOP, 
                        TEXT("CRtpSession::Join: "
                             "QOS Reserve(%s/%s) failed: %d: "),
                        IsSender()? "SEND":"RECV",
                        m_QOSname,
                        WSAGetLastError()
                    ));

                // Failed, disable notifications
                m_pRtpSocket->ModifyFlags(
                        IsSender()? FG_SOCK_ENABLE_NOTIFY_SEND:
                        FG_SOCK_ENABLE_NOTIFY_RECV,
                        0);
                
                if (flags_tst(FG_FAILIFNOQOS)) {
                    goto cleanup;
                }
            } else {

                TraceRetail((
                        TRACE_TRACE, 
                        TRACE_DEVELOP, 
                        TEXT("CRtpSession::Join: "
                             "QOS Reserve(%s/%s) succeeded"),
                        IsSender()? "SEND":"RECV",
                        m_QOSname
                    ));

                if (IsSender()) {
                    if (flags_tst(FG_SENDIFALLOWED2)) {
                        // Ask for permission to send
                        DWORD dwAllowedToSend;

                        // Test if we want to force the result
                        if (flags_tst(FG_ENABLE_ALLOWEDTOSEND_WILLFAIL)) {
                            dwAllowedToSend =
                                flags_tst(FG_ALLOWEDTOSEND_WILLFAIL)? NO:YES;
                        } else {
                            dwAllowedToSend = 
                              SUCCEEDED(pCRtpQOSReserve->AllowedToSend())? YES:NO;                        }
                        
                        TraceRetail((
                                TRACE_WARN,
                                TRACE_DEVELOP, 
                                TEXT("CRtpSession::Join: AllowedToSend: %s"),
                                (dwAllowedToSend)? "YES":"NO"
                            ));

                        if (!dwAllowedToSend) {
                            // If not allowed to send, wait until
                            // RECEIVERS to change this flag
                            flags_rst(FG_SENDSTATE);
                            flags_set(FG_SENDPATHMSG);
                            m_lCredits = 0;
                            m_dwLastSent = GetTickCount();

                            DWORD dwSessionID;
                            GetSessionID(&dwSessionID);
                                
                            TraceDebug((
                                    TRACE_TRACE, 
                                    TRACE_DEVELOP,
                                    TEXT("CRtpSession::Join: "
                                         "Event:>>>%s<<<, SessionID:%d "
                                         "is %s"),
                                    sQOSEventString[
                                            DXMRTP_QOSEVENT_NOT_ALLOWEDTOSEND],
                                    dwSessionID,
                                    IsSender()? "SEND":"RECV"
                                ));

                            // Test QOS event mask,
                            // post the event if enabled
                            if (IsQOSEventEnabled(
                                    DXMRTP_QOSEVENT_NOT_ALLOWEDTOSEND)) {

                                HandleCRtpSessionNotify(
                                        DXMRTP_QOSEVENTBASE,
                                        DXMRTP_QOSEVENT_NOT_ALLOWEDTOSEND,
                                        0, dwSessionID);
                            }
                        }
                    }

                    // Initial reserve interval
                    // 250ms seems to be too short for QOS,
                    // I'm putting rather 2s
                    pCRtpQOSReserve->SetReserveIntervalTime(
                            INITIAL_RESERVE_INTERVAL_TIME /* ms */);
                }

                // Start QOS notifications
                // (this will signal the RTCP thread to start QOS
                // notifications, they will not really be started
                // from the caller thread, i.e. calling Join() )

                // we enable RECEIVERS and NO_RECEIVERS for senders
                // here, to allow posting NOT_ALLOWED_TO_SEND and
                // ALLOWED_TO_SEND which are generated depending on
                // the state of receivers
                DWORD mask = m_dwQOSEventMask2;
                
                if (IsSender())
                    mask |=
                        B2M(DXMRTP_QOSEVENT_RECEIVERS) |
                        B2M(DXMRTP_QOSEVENT_NO_RECEIVERS);

                
                HRESULT qoshr = RTCPStartQOSNotify(m_pRtpSocket->GetShSocket(),
                                                   this,
                                                   IsSender(),
                                                   mask,
                                                   CRtpSessionQOSNotify);
                ModifyFlags(FG_QOSNOTIFY_STARTED, SUCCEEDED(qoshr));
            }
        } // WSAGetQOSByName
    } else {// do_qos
        // If no QOS, these flags must be reseted
        // to enable sending
        flags_rst(FG_SENDIFALLOWED2);
        flags_rst(FG_SENDIFRECEIVERS2);
        m_lCredits = 0;

        TraceRetail((
                TRACE_TRACE,
                TRACE_DEVELOP, 
                TEXT("CRtpSession::Join: QOS not enabled")
            ));
    }
    
    // now change state
    flags_set(FG_ISJOINED);
     
    // Set Multicast loop-back.
    SetMulticastLoopBack(flags_tst(FG_MULTICASTLOOPBACK));

#if defined(_0_)    
    ModifyRTCPSDESMask(-1, 0);
    ModifyRTCPSDESMask(6, 1);

    unsigned char str[256];
    DWORD strlen;

    strlen = 256;
    GetLocalSDESItem(RTCP_SDES_NAME, str, &strlen);
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP2, 
            TEXT("CRtpSession::Join: Old NAME: %s"),
            str
        ));
    SetLocalSDESItem(RTCP_SDES_NAME, (unsigned char *)"Cocou c'est nous", 17);
    strlen = 256;
    GetLocalSDESItem(RTCP_SDES_NAME, str, &strlen);
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP2, 
            TEXT("CRtpSession::Join: New NAME: %s"),
            str
        ));
#endif
    
#if 0
    // Autoenable all the events
    ModifyRTCPEventMask(-1, 1);
    ModifyQOSEventMask(-1, 1);
#endif

    TraceRetail((
        TRACE_TRACE, 
        TRACE_DEVELOP, 
        TEXT("CRtpSession::Join ---------------------------------")
        ));
    
    return S_OK;

cleanup:

    dwKind = IsSender()? SOCKET_MASK_SEND : SOCKET_MASK_RECV;

    // see if we created socket
    if (m_pRtpSocket) {

        // release socket retrieved from manager
        g_SocketManager.ReleaseSharedSocket(m_pRtpSocket, dwKind, this);
        m_pSocket[IsSender() ? SOCKET_SEND : SOCKET_RECV] = 0;

        // invalidate socket handle
        m_pRtpSocket = NULL;
    }

    // see if we created socket
    if (m_pRtcpSocket) {

        // release socket retrieved from manager
        g_SocketManager.ReleaseSharedSocket(m_pRtcpSocket, dwKind, this);

        // invalidate socket handle
        m_pRtcpSocket = NULL;
        m_pSocket[SOCKET_RTCP] = 0;
   }

    if (m_pRTPSession) {
        CloseRTPSession((void *)m_pRTPSession, 0, dwKind);
        m_pRTPSession = NULL;
    }

    return E_FAIL; 
}

#if defined(DEBUG)
// Get socket name and display it
static void loc_getsocketname(char *msg, SOCKET s, BOOL isSender)
{
    char AddrStr[64];
    struct sockaddr_in SaddrIn;
    int localAddrLen = sizeof(SaddrIn);
    char *txrx = isSender? "SEND" : "RECV";

    if (getsockname(s, (struct sockaddr*)&SaddrIn, &localAddrLen)) {
        
        TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("%s: %s socket:%d failed: %d"),
                msg, txrx, s, WSAGetLastError()
            ));
    } else {

        TraceDebug((
                TRACE_TRACE, 
                TRACE_DEVELOP, 
                TEXT("%s: %s sock:%d,%d:%s/%d"),
                msg,
                txrx,
                s,
                SaddrIn.sin_family,
                RtpNtoA(SaddrIn.sin_addr.s_addr, AddrStr),
                (int)ntohs(SaddrIn.sin_port)
            ));
    }
}
#endif // defined(DEBUG)


HRESULT
CRtpSession::Leave(
    )

/*++

Routine Description:

    Leave a multimedia session. 

Arguments:

    None. 

Return Values:

    Returns an HRESULT value. 

--*/

{
    SOCKET rtpsock = (m_pRtpSocket)? m_pRtpSocket->GetShSocket() : -1;
    SOCKET rtcpsock = (m_pRtcpSocket)? m_pRtcpSocket->GetShSocket() : -1;

    TraceRetail((
            TRACE_TRACE, 
            TRACE_DEVELOP, 
            TEXT("CRtpSession::Leave(%s/%s) +++++++++++"),
            IsSender()? "SEND" : "RECV",
            m_lSessionClass == RTP_CLASS_AUDIO? "AUDIO" : "VIDEO"
        ));

    TraceRetail((
            TRACE_TRACE, 
            TRACE_DEVELOP, 
            TEXT("CRtpSession::Leave: Sockets(%d, %d)"),
            rtpsock, rtcpsock
        ));

    // Disable all events
    m_dwQOSEventMask2 = 0;
    if (m_pRTPSession && m_pRTPSession->pRTCPSession)
        m_pRTPSession->pRTCPSession->dwEventMask[IsSender()? 1:0] = 0;
    
    
    // First get the lock to this object then the global, so
    // is some other member function of this object gets blocked,
    // this one doesn't hold also the global lock and
    // other threads can Join/Leave.

    // object lock to this object
    CAutoLock LockThis(pStateLock());

    CAutoLock gJoinLeave(&g_cJoinLeaveLock);

    // validate
    if (!IsJoined()) {

        TraceRetail((
            TRACE_ERROR, 
            TRACE_DEVELOP, 
            TEXT("CRtpSession::Leave: session not joined")
            ));

        return S_OK; // bail...
    }

    DWORD dwKind = IsSender()? SOCKET_MASK_SEND : SOCKET_MASK_RECV;
    DWORD dwStatus;
    
    // shutdown session
    if (m_pRTPSession) {

        // shut down session first before nuking sockets
        dwStatus = ShutdownRTPSession((void *)m_pRTPSession, NULL, dwKind);
        
        if (dwStatus != NOERROR) {

            TraceRetail((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::Leave: ShutdownRTPSession "
                     "failed: 0x%08lx"), 
                dwStatus
                ));
        }
    }

    // see if we created socket
    if (m_pRtpSocket) {

        // stop QOS notifications if started
        if (TestFlags(FG_QOSNOTIFY_STARTED))
            RTCPStopQOSNotify(m_pRtpSocket->GetShSocket(), this, IsSender());
        
        // Set QOS to NO TRAFFIC
        m_pRtpSocket->ShSocketStopQOS(IsSender());
                
        // release socket retrieved from manager
        g_SocketManager.ReleaseSharedSocket(m_pRtpSocket, dwKind, this);

        // invalidate socket handle
        m_pRtpSocket = NULL;
        m_pSocket[IsSender() ? SOCKET_SEND : SOCKET_RECV] = 0;

        // Leave a trace that we released the socket
        if (m_pRTPSession)
            m_pRTPSession->dwStatus |= (dwKind << 16);
    } else {
        if (m_pRTPSession)
            m_pRTPSession->dwStatus |= (dwKind << 18);
    }

    // see if we created socket
    if (m_pRtcpSocket) {

        // release socket retrieved from manager
        g_SocketManager.ReleaseSharedSocket(m_pRtcpSocket, dwKind, this);

        // invalidate socket handle
        m_pRtcpSocket = NULL;
        m_pSocket[SOCKET_RTCP] = 0;

        // Leave a trace that we released the socket
        if (m_pRTPSession)
            m_pRTPSession->dwStatus |= (dwKind << 20);
    } else {
        if (m_pRTPSession)
            m_pRTPSession->dwStatus |= (dwKind << 22);
    }


    // nuke session
    if (m_pRTPSession) {
        dwStatus = CloseRTPSession((void *)m_pRTPSession, 0, dwKind);

        // validate
        if (dwStatus != NOERROR) {

            TraceRetail((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::Leave: CloseRTPSession failed: 0x%08lx"), 
                dwStatus
                ));
        }

        // re-initialize
        m_pRTPSession = NULL;    
    }

    // re-initialize sample queue
    HRESULT hr = m_pSampleQueue->FreeAll(); 

    // validate
    if (FAILED(hr)) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_DEVELOP, 
            TEXT("CSampleQueue::FreeAll returned 0x%08lx"), hr
            ));
    }

    // change state now
    flags_rst(FG_ISJOINED);

    TraceRetail((
            TRACE_TRACE, 
            TRACE_DEVELOP, 
            TEXT("CRtpSession::Leave(%s/%s) -----------"),
            IsSender()? "SEND":"RECV",
            m_lSessionClass == RTP_CLASS_AUDIO? "AUDIO" : "VIDEO"
            ));
    
    return S_OK; 
}


HRESULT
CRtpSession::SendTo(
    IMediaSample * pSample    
    )

/*++

Routine Description:

    Sends next block of data from the stream to the network. 

Arguments:

    pSample - pointer to a media sample. 

Return Values:

    Returns an HRESULT value. 

--*/

{
#ifdef DEBUG_CRITICAL_PATH

    TraceDebug((
        TRACE_TRACE,
        TRACE_CRITICAL, 
        TEXT("CRtpSession::SendTo")
        ));

#endif // DEBUG_CRITICAL_PATH

    HRESULT hr = NOERROR;

    // object lock to this object
    CAutoLock LockThis(pStateLock());

    // validate
    if (!IsJoined()) {

        TraceDebug((
            TRACE_ERROR,
            TRACE_ALWAYS, 
            TEXT("session not joined") 
            ));

        return VFW_E_WRONG_STATE; // bail...
    }

    // pointer to list entry
    PSAMPLE_LIST_ENTRY pSLE;

#if defined(DBG_DWKIND)
    m_pRTPSession->dwKind &= 0xffff;
#endif
    
    // retrieve the actual data length
    int data_len = pSample->GetActualDataLength();

    // Verify if we are currently enabled to send
    if (flags_tst(FG_SENDSTATE) || (m_lCredits >= data_len)) {

        // allocate new list entry from sample 
        hr = m_pSampleQueue->Alloc(pSample,&pSLE);

        // validate 
        if (FAILED(hr)) {
                
            TraceDebug((
                    TRACE_ERROR,
                    TRACE_ALWAYS, 
                    TEXT("CSampleQueue::Alloc returned 0x%08lx"), hr 
                ));
                
            return hr; // bail...
        }
            
        pSLE->Buffer.len = data_len;

        // Reduce our credit accordingly
        if (!flags_tst(FG_SENDSTATE))
            m_lCredits -= data_len;
            
#if defined(DBG_DWKIND)
        m_pRTPSession->dwKind |= (1<<16); // SendTo
#endif
        // post async receive buffer
        DWORD dwStatus = RTPSendTo(
                m_pSocket,
                &pSLE->Buffer,
                1, // dwBufferCount 
                &pSLE->BytesTransferred,
                (int)pSLE->Flags,
                (struct sockaddr *)&m_RtpAddr,
                sizeof(m_RtpAddr),
                &pSLE->Overlapped,
                SendCompletionRoutine
            );
        
        int sync_sendto = 1;
        
        if (dwStatus == SOCKET_ERROR) {
            
            if (WSAGetLastError() != ERROR_IO_PENDING) {
                
                TraceDebug((
                        TRACE_ERROR,
                        TRACE_ALWAYS, 
                        TEXT("CRtpSession::SendTo returned: %d (0x%X)"), 
                        dwStatus, dwStatus
                    ));
                
                // fail...
                sync_sendto = 0;
                hr = E_FAIL; 
            }
        } else if (dwStatus) {
            // A different error (No overlapped IO started)
            sync_sendto = 0;
        }
        
        if (sync_sendto) {
            do {
                // As I always wait until the sendto finishes,
                // it may be a good idea to do this send
                // a blocking call avoiding all the complexity
                // of having a completion callback routine.
                // Here I'm having in many cases to loop 2 times,
                // one for any or this packet IO completion, and
                // a second time when the event is signaled.
                //
                // Passing into a blocking call may have the
                // problem of not having control any more over an
                // alertable mode wait so other callbacks in this
                // thread/socket can be fired (QOS).
                dwStatus = WaitForSingleObjectEx(m_pRTPSession->hSendTo,
                                                 10*1000, TRUE);
            } while(dwStatus != WAIT_OBJECT_0 &&
                    dwStatus != WAIT_ABANDONED);
        }
            
#if defined(DBG_DWKIND)
        m_pRTPSession->dwKind &= 0xffff; //Reset all flags
#endif
        // release list entry
        m_pSampleQueue->Free(pSLE);
    } else {
        // Instead of not being allowed to send, allow the sender to
        // accumulate credits so it can send at N kbits/s.  Only when
        // enough credits are available, the sender is allowed to send
        // the current packet

        DWORD curTime = GetTickCount();
        DWORD delta;
        
        if (curTime > m_dwLastSent)
            delta = curTime - m_dwLastSent;
        else 
            delta = curTime + ((DWORD)-1 - m_dwLastSent) + 1;

        m_lCredits += (delta * NOT_ALLOWEDTOSEND_RATE) / 8;
        
        m_dwLastSent = curTime;
    }

    
    if (!flags_tst(FG_SENDSTATE)) {
        // QOS is enabled and we are waiting for RECEIVERS

        if (flags_tst(FG_SENDPATHMSG)) {
            // Do reserve again.
            // Here to reserve means to do a SIO_SET_QOS, specifying
            // the sending flow spec. This in turns will make RSVP to
            // send a PATH message immediatly (I name it reserve
            // because I have abstracted the SIO_SET_QOS for the
            // sender and receiver under the Reserve() method.
            CRtpQOSReserve *pCRtpQOSReserve;
            
            if ( (pCRtpQOSReserve = m_pRtpSocket->GetpCRtpQOSReserve()) ) {
                
                DWORD curTime = GetTickCount();
                
                if ( (curTime - pCRtpQOSReserve->GetLastReserveTime()) >=
                     pCRtpQOSReserve->GetReserveIntervalTime() ) {
                    
                    pCRtpQOSReserve->Reserve(IsSender());

                    // Double the interval
                    pCRtpQOSReserve->SetReserveIntervalTime(
                            pCRtpQOSReserve->GetReserveIntervalTime() * 2
                        );
                    
                    if (pCRtpQOSReserve->GetReserveIntervalTime() >=
                        MAX_RESERVE_INTERVAL_TIME) {
                        // Disable this after 20 secs and prepare for the
                        // next time
                        pCRtpQOSReserve->SetReserveIntervalTime(
                                INITIAL_RESERVE_INTERVAL_TIME);
                        flags_rst(FG_SENDPATHMSG);
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT
CRtpSession::RecvFrom(
    IMediaSample * pSample    
    )

/*++

Routine Description:

    Receives next block of data from the network and adds to stream. 

Arguments:

    pSample - pointer to a media sample. 

Return Values:

    Returns an HRESULT value. 

--*/

{
#ifdef DEBUG_CRITICAL_PATH

    TraceDebug((
        TRACE_TRACE,
        TRACE_CRITICAL, 
        TEXT("CRtpSession::RecvFrom")
        ));

#endif // DEBUG_CRITICAL_PATH

    // object lock to this object
    CAutoLock LockThis(pStateLock());

    // validate
    if (!IsJoined()) {

        TraceDebug((
            TRACE_ERROR,
            TRACE_ALWAYS, 
            TEXT("session not joined") 
            ));

        return VFW_E_WRONG_STATE; // bail...
    }

    // pointer to list entry
    PSAMPLE_LIST_ENTRY pSLE;

    // allocate new list entry from sample 
    HRESULT hr = m_pSampleQueue->Alloc(pSample,&pSLE);

    // validate 
    if (FAILED(hr)) {

        TraceDebug((
            TRACE_ERROR,
            TRACE_ALWAYS, 
            TEXT("CSampleQueue::Alloc returned 0x%08lx"), hr 
            ));

        return hr; // bail...
    }

    // post async receive buffer
    DWORD dwStatus = RTPRecvFrom(
                            m_pSocket,
                            &pSLE->Buffer,
                            1, // dwBufferCount 
                            &pSLE->BytesTransferred,
                            &pSLE->Flags,
                            (struct sockaddr *)&pSLE->SockAddr,
                            &pSLE->SockAddrLen,
                            &pSLE->Overlapped,
                            RecvCompletionRoutine
                            );

    // make sure nothing went wrong
    if (dwStatus == SOCKET_ERROR) {

        dwStatus = WSAGetLastError();
        
        if ( !((dwStatus == WSA_IO_PENDING)  ||
               (dwStatus == WSAECONNRESET)) ) {
    
            // ignore large buffers
            if (dwStatus == WSAEMSGSIZE) {

                TraceDebug((
                        TRACE_TRACE, 
                        TRACE_ALWAYS, 
                        TEXT("Ignoring large buffer") 
                    ));

            } else {

                TraceDebug((
                        TRACE_ERROR, 
                        TRACE_ALWAYS, 
                        TEXT("RecvFrom returned %d"), 
                        dwStatus
                    ));

                // fail...
                hr = E_FAIL; 
            }
        }

        if (dwStatus == WSAECONNRESET) {
            TraceDebug((
                    TRACE_ERROR, 
                    TRACE_DEVELOP, 
                    TEXT("RecvFrom: WSACONNRESET")
                ));
        }
    }                    

    // add to queue
    if (SUCCEEDED(hr)) {

        // add ref sample
        pSample->AddRef();  

        // add sample to queue
        m_pSampleQueue->Push(pSLE);
    } else {

        // release list entry
        m_pSampleQueue->Free(pSLE);
    }

    return hr;
}


#if defined(_0_)
HRESULT
CRtpSession::RecvNext(
    IMediaSample ** ppSample    
    )

/*++

Routine Description:

    Receives next block of data from the network. 

Arguments:

    ppSample - pointer to a media sample pointer. 

Return Values:

    Returns an HRESULT value. 

--*/

{
#ifdef DEBUG_CRITICAL_PATH

    TraceDebug((
        TRACE_TRACE, 
        TRACE_CRITICAL, 
        TEXT("CRtpSession::RecvNext")
        ));

#endif // DEBUG_CRITICAL_PATH

    // object lock to this object
    CAutoLock LockThis(pStateLock());

    // validate
    if (!IsJoined()) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_ALWAYS, 
            TEXT("session not joined") 
            ));

        return VFW_E_WRONG_STATE; // bail...
    }

    // pointer to list entry
    PSAMPLE_LIST_ENTRY pSLE;

    // retrieve next processed list entry 
    HRESULT hr = m_pSampleQueue->Pop(&pSLE);

    // validate 
    if (SUCCEEDED(hr)) {

        // adjust error according to completion status
        hr = (pSLE->Status == NO_ERROR) ? S_OK : E_FAIL;

        // validate 
        if (SUCCEEDED(hr)) {

            // transfer stored sample
            *ppSample = pSLE->pSample;
                 
#if defined(DEBUG_CRITICAL_PATH) || defined(DEBUG_SEQUENCE_NUMBERS)

            TraceDebug((
                TRACE_TRACE, 
                TRACE_CRITICAL,                      
                TEXT("CBaseOutputPin::Deliver delivering 0x%04x"),                
                ntohs(((RTP_HEADER*)(pSLE->Buffer.buf))->SequenceNum)
                ));                    

#endif // DEBUG_CRITICAL_PATH

        } else {

            TraceDebug((
                TRACE_ERROR, 
                TRACE_ALWAYS, 
                TEXT("Invalid completion status 0x%08lx"), 
                pSLE->Status 
                ));

            // nuke sample now
            pSLE->pSample->Release();
        }

        // release list entry
        m_pSampleQueue->Free(pSLE);

    } else if (hr == E_PENDING) {

        // reset
        hr = S_FALSE;

#ifdef DEBUG_CRITICAL_PATH
    
        TraceDebug((
            TRACE_TRACE, 
            TRACE_CRITICAL, 
            TEXT("No more entries available") 
            ));

#endif // DEBUG_CRITICAL_PATH
    
    } else {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_ALWAYS, 
            TEXT("CSampleQueue::Pop returned 0x%08lx"), hr 
            ));
    }

    return hr;
}
#endif // defined(_0_)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IRTPStream implemented methods                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// selects IP address only, not port
//
HRESULT
CRtpSession::SelectLocalIPAddress(DWORD dwLocalAddr)
{
    struct in_addr *pInAddr = (struct in_addr *) &dwLocalAddr;
    
    ZeroMemory((void *)&m_LocalIPAddress, sizeof(m_LocalIPAddress));
    m_LocalIPAddress.sin_addr = * ((struct in_addr *) &dwLocalAddr);
    m_LocalIPAddress.sin_family = AF_INET;

    return(SelectLocalIPAddressToDest((LPBYTE)&m_LocalIPAddress,
                                      sizeof(m_LocalIPAddress),
                                      (LPBYTE)&m_RtpAddr,
                                      sizeof(m_RtpAddr)));
}

// If the local address is specified, the function just validates it,
// if it is set to INADDR_ANY, then the function tries to figure out
// automatically which interface to use based on the destination
// address. If no destination address is provided, then the function
// selects the first local address.
// A local address is always returned (if there is any in the host).

HRESULT
CRtpSession::SelectLocalIPAddressToDest(LPBYTE pLocSAddr,
                                        DWORD  dwLocSAddrLen,
                                        LPBYTE pDestSAddr,
                                        DWORD  dwDestSAddrLen)
{
    SOCKET sock;

    SOCKADDR_IN *pLocAddr = (SOCKADDR_IN *)pLocSAddr;
    SOCKADDR_IN *pDestAddr = (SOCKADDR_IN *)pDestSAddr;

    DWORD no_dest = 0;
    HRESULT result = E_FAIL;

    // if we don't have where to put the local address, do nothing
    if (!pLocAddr)
        return(E_POINTER);

    if ( (pLocSAddr  && (dwLocSAddrLen  < sizeof(SOCKADDR))) ||
         (pDestSAddr && (dwDestSAddrLen < sizeof(SOCKADDR))) )
        return(E_INVALIDARG);
    
    if (pLocSAddr && IsBadReadPtr(pLocSAddr, dwLocSAddrLen))
        return(E_POINTER);
    
    if (IsBadWritePtr(pDestSAddr, dwDestSAddrLen))
        return(E_POINTER);
    
    if (pLocAddr->sin_addr.s_addr != INADDR_ANY) {

        // user has already specified the local address to use,
        // then validate and use it!
        if ( (pLocAddr->sin_addr.s_addr == 0x0100007f) ||
             RTPValidateLocalIPAddress(pLocAddr) )
            result = NOERROR;
        else
            result = E_INVALIDARG;

    } else {
    
        // check if we have a destination address
        if (!pDestAddr || pDestAddr->sin_addr.s_addr == INADDR_ANY) {
            // no destination address was given, use first valid address
            no_dest = 1;
        }
        
        // check we have a query socket
        if ( (sock = g_RTPQuerySocket.GetSocket()) == INVALID_SOCKET ) {

            TraceDebug((
                    TRACE_ERROR, 
                    TRACE_DEVELOP, 
                    TEXT("RTPGetLocalIPAddress: no query socket available")
                ));

            // nothing can be done if we
            // don't have the query socket, E_FAIL
            
        } else if (!no_dest) {

            // query for default address based on destination

            DWORD dwStatus;
            DWORD dwLocAddrSize = sizeof(SOCKADDR_IN);
            DWORD dwNumBytesReturned = 0;
            
            if ((dwStatus = WSAIoctl(
                    sock, // SOCKET s
                    SIO_ROUTING_INTERFACE_QUERY, // DWORD dwIoControlCode
                    pDestAddr,           // LPVOID  lpvInBuffer
                    sizeof(SOCKADDR_IN), // DWORD   cbInBuffer
                    pLocAddr,            // LPVOID  lpvOUTBuffer
                    dwLocAddrSize,       // DWORD   cbOUTBuffer
                    &dwNumBytesReturned, // LPDWORD lpcbBytesReturned
                    NULL, // LPWSAOVERLAPPED lpOverlapped
                    NULL  // LPWSAOVERLAPPED_COMPLETION_ROUTINE lpComplROUTINE
                )) == SOCKET_ERROR) {

                dwStatus = WSAGetLastError();
            
                TraceRetail((
                        TRACE_ERROR, 
                        TRACE_DEVELOP, 
                        TEXT("RTPGetDefaultLocalIPAddress: "
                             "WSAIoctl failed: %d (0x%X)"),
                        dwStatus, dwStatus
                    ));
                
            } else {
                // we obtained the local address to reach
                // the specified destination
                
                result = NOERROR;
            }
        } else {
            
            // no destination address was given,
            // get just the first address
            
            SOCKET_ADDRESS_LIST *pSockAddrList;
            
            if (SUCCEEDED(RTPGetLocalIPAddress(&pSockAddrList))) {
                
                SOCKADDR_IN *saddr_in;
                
                // scan list to get the first AF_INET address
                for(int i = 0; i < pSockAddrList->iAddressCount; i++) {
                    
                    if (pSockAddrList->Address[i].lpSockaddr->sa_family ==
                        AF_INET) {
                        
                        CopyMemory((void *)pLocAddr,
                                   (void *)pSockAddrList->Address[i].lpSockaddr,
                                   sizeof(*pLocAddr));
                        
                        result = NOERROR;
                        break;
                    }
                }
                
                free((void *)pSockAddrList);
            }
        }
    }

    if (SUCCEEDED(result)) {

        char addrstr[RTPNTOASIZE];

        TraceRetail((
                TRACE_TRACE, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::SelectLocalIPAddressToDest: "
                     "valid local IP address selected: %s"),
                RtpNtoA(pLocAddr->sin_addr.s_addr, addrstr)
            ));
    }

    return(result);
}

// Enable sharing the sockets between a sender and a receiver,
// an efect of doing so is that the RTP/RTCP sessions are also
// shared, then the sender and the receiver are seen as
// a single participant.
// If sockets are not shared, a sender and a receiver are seen
// as independent participants, each sending RTCP reports.
// Th default is to share sockets.
HRESULT
CRtpSession::SelectSharedSockets(DWORD dwfSharedSockets)
{
    if (IsJoined()) {
        
        TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::SelectSharedSockets: "
                     "session already joined") 
            ));
        
        return(VFW_E_WRONG_STATE);
    }

    if (dwfSharedSockets)
        flags_set(FG_SHAREDSOCKETS);
    else
        flags_rst(FG_SHAREDSOCKETS);

    return(NOERROR);
}

HRESULT
CRtpSession::GetSessionClassPriority(long *plSessionClass,
                                     long *plSessionPriority)
{
    if (IsBadWritePtr(plSessionClass, sizeof(long)))
        return(E_POINTER);

    if (IsBadWritePtr(plSessionPriority, sizeof(long)))
        return(E_POINTER);

    *plSessionClass = m_lSessionClass;
    *plSessionPriority = m_lSessionPriority;

    return(NOERROR);
}

HRESULT
CRtpSession::SetSessionClassPriority(long lSessionClass,
                                     long lSessionPriority)
{
    // what could be a valid class and priority?

    if (IsJoined()) {

        TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::SetSessionClassPriority: "
                     "session already joined") 
            ));

        return(VFW_E_WRONG_STATE);
    }
    
    m_lSessionClass = lSessionClass;
    m_lSessionPriority = lSessionPriority;

    return(NOERROR);
}

// Get the session's QoS event mask
HRESULT
CRtpSession::GetQOSEventMask(DWORD *pdwQOSEventMask)
{
    if (IsBadWritePtr(pdwQOSEventMask, sizeof(DWORD)))
        return(E_POINTER);
    
    *pdwQOSEventMask = m_dwQOSEventMask;
    
    return(NOERROR);    
}

// Modify (enable/disable items) the QoS event mask
HRESULT
CRtpSession::ModifyQOSEventMask(DWORD dwSelectItems, DWORD dwEnableItems)
{
    if (dwEnableItems)
        m_dwQOSEventMask |= dwSelectItems;
    else
        m_dwQOSEventMask &= ~dwSelectItems;

    m_dwQOSEventMask2= m_dwQOSEventMask;

    if (IsJoined() && flags_tst(FG_QOSSTATE)) {

        // we enable RECEIVERS and NO_RECEIVERS for senders
        // here, to allow posting NOT_ALLOWED_TO_SEND and
        // ALLOWED_TO_SEND which are generated depending on
        // the state of receivers

        DWORD mask = m_dwQOSEventMask2;
                
        if (IsSender())
            mask |=
                B2M(DXMRTP_QOSEVENT_RECEIVERS) |
                B2M(DXMRTP_QOSEVENT_NO_RECEIVERS);
        
        RTCPSetQOSEventMask(m_pRtpSocket->GetShSocket(),
                            this,
                            IsSender(),
                            mask);
    }
    
    return(NOERROR);
}

//
// All parameters returned are in NETWORK order
//
STDMETHODIMP 
CRtpSession::GetAddress(
        LPWORD  pwRtpLocalPort,
        LPWORD  pwRtpRemotePort,
        LPDWORD pdwRtpRemoteAddr
    )
{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpSession::GetAddress")
        ));

    DWORD Valid = 0;

    if (!IsBadWritePtr(pwRtpLocalPort, sizeof(WORD))) Valid |= 0x1;
    if (!IsBadWritePtr(pwRtpRemotePort, sizeof(WORD))) Valid |= 0x2;
    if (!IsBadWritePtr(pdwRtpRemoteAddr, sizeof(DWORD))) Valid |= 0x4;

    if (!Valid)
        // only fails if all pointers are INVALID, otherwise just
        // return values for the valid pointers
        return(E_POINTER);

    if (Valid & 0x1)
        *pwRtpLocalPort = m_wRtpLocalPort;

    if (Valid & 0x2)
        *pwRtpRemotePort = m_RtpAddr.sin_port;

    if (Valid & 0x4)
        *pdwRtpRemoteAddr = m_RtpAddr.sin_addr.s_addr;
    
    return(S_OK);
}

//
// All parameters returned are in NETWORK order
//
STDMETHODIMP 
CRtpSession::GetRTCPAddress(
        LPWORD  pwRtcpLocalPort,
        LPWORD  pwRtcpRemotePort,
        LPDWORD pdwRtcpRemoteAddr
    )
{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpSession::GetRTCPAddress")
        ));

    DWORD Valid = 0;
    
    if (!IsBadWritePtr(pwRtcpLocalPort, sizeof(WORD))) Valid |= 0x1;
    if (!IsBadWritePtr(pwRtcpRemotePort, sizeof(WORD))) Valid |= 0x2;
    if (!IsBadWritePtr(pdwRtcpRemoteAddr, sizeof(DWORD))) Valid |= 0x4;

    if (!Valid)
        // only fails if all pointers are INVALID, otherwise just
        // return values for the valid pointers
        return(E_POINTER);

    if (Valid & 0x1)
        *pwRtcpLocalPort = m_wRtcpLocalPort;

    if (Valid & 0x2)
        *pwRtcpRemotePort = m_RtpAddr.sin_port;

    if (Valid & 0x4)
        *pdwRtcpRemoteAddr = m_RtcpAddr.sin_addr.s_addr;
    
    return(S_OK);
}


/*++

Routine Description:

    Sets address associated with rtp or RTCP stream.

Arguments:


Return Values:

    Returns an HRESULT value. 

--*/
HRESULT
CRtpSession::SetAddress_(
        WORD  wLocalPort,  // NETWORK order
        WORD  wRemotePort, // NETWORK order
        DWORD dwRemoteAddr,// NETWORK order
        DWORD doRTP
    )
{
    struct in_addr *pInAddr = (struct in_addr *) &dwRemoteAddr;
    
    // object lock to this object
    CAutoLock LockThis(pStateLock());

    // validate
    if (IsJoined()) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_ALWAYS, 
            TEXT("session is joined") 
            ));

        return VFW_E_WRONG_STATE; // bail...
    }

    if ( pInAddr->s_addr == INADDR_ANY )
        // I may add a check against the local IP address(es)
        return(E_INVALIDARG);
    
    // at least one port must be specified
    if (!wLocalPort && !wRemotePort)
        return(E_INVALIDARG);

    if (IS_MULTICAST(pInAddr->s_addr)) {
        //
        // in multicast remote and local ports are the same.
        //
        // if any port is non zero,
        // make the other have the same value
        if (wLocalPort && wRemotePort) {
            if (wLocalPort != wRemotePort)
                return(E_INVALIDARG);
        } else if (wLocalPort) {
            wRemotePort = wLocalPort;
        } else if (wRemotePort) {
            wLocalPort = wRemotePort;
        }
    } else {
        // unicast
        if (IsSender()) {
            // for a sender, the remote port must be specified, it is
            // not tested, it is the remote's responsibility to select
            // a right port to use
            if (!wRemotePort)
                return(E_INVALIDARG);
        } else {
            // for a receiver, local port must be > 1024
            if (!wLocalPort || (ntohs(wLocalPort) <= 1024))
                return(E_INVALIDARG);
        }
    }
    
#if 0
    // validate port so the following rules apply:
    // RTP  -> event port
    // RTCP -> odd port
    // RTP port + 1 == RTCP port
    {
        WORD lport = ntohs(wLocalPort);
        WORD rport = ntohs(wRemotePort);

        if (
                // test local port
                (doRTP && (lport & 0x1))     /* RTP  port is odd  */ ||
                (!doRTP && !(lport & 0x1))   /* RTCP port is even */ ||

                // test remote port
                // NOTE: this test could be removed by the same reason
                // as above (remote's responsibility)
                (doRTP && (rport & 0x1))     /* RTP  port is odd  */ ||
                (!doRTP && !(rport & 0x1))   /* RTCP port is even */
            )
            
            return(E_INVALIDARG);
    }
#else
    // No odd/even validations are done
#endif 

    // transfer the actual remote address
    ZeroMemory(&m_RtcpAddr, sizeof(m_RtcpAddr));
    m_RtcpAddr.sin_family      = AF_INET;
    m_RtcpAddr.sin_addr.s_addr = pInAddr->s_addr;
    m_RtcpAddr.sin_port        = wRemotePort;
    m_wRtcpLocalPort           = wLocalPort;
    
    if (doRTP) {
        // what is copied becomes RTP's info
        CopyMemory(&m_RtpAddr, &m_RtcpAddr, sizeof(m_RtpAddr));
        m_wRtpLocalPort = m_wRtcpLocalPort;

        // if local or remote port is zero, the default is to
        // initialize RTCP port to be the same for local and remote
        if (!wLocalPort)
            wLocalPort = wRemotePort;
        else if (!wRemotePort)
            wRemotePort = wLocalPort;
        
        // now update ports for RTCP
        m_RtcpAddr.sin_port = htons(ntohs(wRemotePort) + 1);
        m_wRtcpLocalPort = htons(ntohs(wLocalPort) + 1);
    }
    
    return S_OK;
}

HRESULT
CRtpSession::SetAddress(
        WORD  wRtpLocalPort,
        WORD  wRtpRemotePort,
        DWORD dwRtpRemoteAddr
    )
{
    char addrstr[RTPNTOASIZE];
    
    TraceRetail((
            TRACE_TRACE, 
            TRACE_DEVELOP,
            TEXT("CRtpSession::SetAddress(%d,%d,%s)"),
            ntohs(wRtpLocalPort), ntohs(wRtpRemotePort),
            RtpNtoA(dwRtpRemoteAddr, addrstr)
        ));

    return( SetAddress_(wRtpLocalPort, wRtpRemotePort, dwRtpRemoteAddr,
                        1 /* 1 = RTP + RTCP */) );

}

HRESULT
CRtpSession::SetRTCPAddress(
        WORD  wRtcpLocalPort,
        WORD  wRtcpRemotePort,
        DWORD dwRtcpRemoteAddr
    )
{
    char addrstr[RTPNTOASIZE];

    TraceRetail((
            TRACE_TRACE, 
            TRACE_DEVELOP,
            TEXT("CRtpSession::SetRTCPAddress(%d,%d,%s)"),
            ntohs(wRtcpLocalPort), ntohs(wRtcpRemotePort),
            RtpNtoA(dwRtcpRemoteAddr, addrstr)
        ));

    return( SetAddress_(wRtcpLocalPort, wRtcpRemotePort, dwRtcpRemoteAddr,
                        0 /* 0 = RTCP only */) ); 
}


/*++

Routine Description:

    Retrieves multicast scope associated with rtp stream.

Arguments:

    pdwMulticastScope - buffer to receive scope.

Return Values:

    Returns an HRESULT value. 

--*/

HRESULT
CRtpSession::GetMulticastScope_(
        LPDWORD pdwMulticastScope,
        PDWORD pScope
    )
{
    // object lock to this object
    CAutoLock LockThis(pStateLock());

    // validate pointers passed in
    //#if defined(DEBUG) || defined(VFWROBUST) 
    //ValidateReadWritePtr(pdwMulticastScope,sizeof(DWORD));

    if (IsBadWritePtr(pdwMulticastScope, sizeof(DWORD)))
        return(E_POINTER);

    // return rtp/rtcp multicast scope
    *pdwMulticastScope = *pScope;    

    return S_OK;
}

STDMETHODIMP 
CRtpSession::GetMulticastScope(
        LPDWORD pdwMulticastScope
    )
{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpSession::GetMulticastScope")
        ));

    return(GetMulticastScope_(pdwMulticastScope, &m_RtpScope));
}

STDMETHODIMP 
CRtpSession::GetRTCPMulticastScope(
        LPDWORD pdwMulticastScope
    )
{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpSession::GetMulticastScope")
        ));

    return(GetMulticastScope_(pdwMulticastScope, &m_RtcpScope));
}



/*++

Routine Description:

    Sets multicast scope associated with rtp stream.

Arguments:

    dwMulticastScope - multicast scope of rtp stream.

Return Values:

    Returns an HRESULT value. 

--*/
HRESULT 
CRtpSession::SetMulticastScope_(
        DWORD dwMulticastScope,
        DWORD doRTP
    )
{
    if (dwMulticastScope > 255)
        return(E_INVALIDARG);
    
    // object lock to this object
    CAutoLock LockThis(pStateLock());

    // validate
    if (IsJoined()) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_ALWAYS, 
            TEXT("session is joined") 
            ));

        return VFW_E_WRONG_STATE; // bail...
    }

    // change ttl
    m_RtcpScope = dwMulticastScope;

    if (doRTP)
        m_RtpScope = m_RtcpScope;

    return S_OK;
}

STDMETHODIMP 
CRtpSession::SetMulticastScope(
        DWORD dwMulticastScope
    )
{
    TraceRetail((
            TRACE_TRACE, 
            TRACE_ALWAYS, 
            TEXT("CRtpSession::SetMulticastScope(%d)"),
            dwMulticastScope
        ));

    return(SetMulticastScope_(dwMulticastScope, 1)); // 1 = RTP + RTCP
}

STDMETHODIMP 
CRtpSession::SetRTCPMulticastScope(
        DWORD dwMulticastScope
    )
{
    TraceRetail((
            TRACE_TRACE, 
            TRACE_ALWAYS, 
            TEXT("CRtpSession::SetRTCPMulticastScope(%d)"),
            dwMulticastScope
        ));

    return(SetMulticastScope_(dwMulticastScope, 0)); // 0 = RTCP
}



////////////////////////////////////////////////////////////
// Set the QOS template name associated to the requested QOS.
// The actual setting will take palce until the Join() is
// done, because before we have not created the sockets yet.
////////////////////////////////////////////////////////////
STDMETHODIMP 
CRtpSession::SetQOSByName(char *psQOSname, DWORD fFailIfNoQOS)


{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpSession::SetQOSByName")
        ));

    // object lock to this object
    CAutoLock LockThis(pStateLock());

    // validate
    if (IsJoined()) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_ALWAYS, 
            TEXT("CRtpSession::SetQOSByName: session is joined") 
            ));

        return VFW_E_WRONG_STATE; // bail...
    }

    __try {
        // check for null string
        if (!strlen(psQOSname))
            return(E_INVALIDARG);

        strncpy(m_QOSname, psQOSname, sizeof(m_QOSname));
    }
    __except(1) {
        return(E_POINTER);
    }
    
    flags_set(FG_QOSSTATE); // Implicitly enable QOS

    if (fFailIfNoQOS)
        flags_set(FG_FAILIFNOQOS); // Fail if QOS is not available or fails
    else
        flags_rst(FG_FAILIFNOQOS);
    
    return(NOERROR);
}


////////////////////////////////////////////////////////////
// Query QOS state (enabled/disabled)
////////////////////////////////////////////////////////////

STDMETHODIMP 
CRtpSession::GetQOSstate(DWORD *pdwQOSstate)
{
    TraceDebug((
            TRACE_TRACE, 
            TRACE_ALWAYS, 
            TEXT("CRtpSession::GetQOSstate")
        ));
  
    // validate pointer
    if (IsBadWritePtr(pdwQOSstate, sizeof(DWORD)))
        return(E_POINTER);

    // object lock to this object
    CAutoLock LockThis(pStateLock());

    *pdwQOSstate = flags_tst(FG_QOSSTATE);

    return(NOERROR);
}

////////////////////////////////////////////////////////////
// Set QOS state (enabled/disabled)
////////////////////////////////////////////////////////////

STDMETHODIMP 
CRtpSession::SetQOSstate(DWORD dwQOSstate)
{
    TraceDebug((
            TRACE_TRACE, 
            TRACE_ALWAYS, 
            TEXT("CRtpSession::SetQOSstate")
        ));

    // object lock to this object
    CAutoLock LockThis(pStateLock());

    // validate
    if (IsJoined()) {

        TraceDebug((
                TRACE_ERROR, 
                TRACE_ALWAYS, 
                TEXT("CRtpSession::SetQOSstate: session is joined") 
            ));
        
        return VFW_E_WRONG_STATE; // bail...
    }

    if (dwQOSstate)
        flags_set(FG_QOSSTATE);
    else
        flags_rst(FG_QOSSTATE);

    return(NOERROR);
}

////////////////////////////////////////////////////////////
// Get Multicast loop-back state (enbled/disabled)
////////////////////////////////////////////////////////////

STDMETHODIMP 
CRtpSession::GetMulticastLoopBack(DWORD *pdwMulticastLoopBack)
{
    TraceDebug((
            TRACE_TRACE, 
            TRACE_ALWAYS, 
            TEXT("CRtpSession::GetMulticastLoopBack")
        ));

    
    // validate pointer
    if (IsBadWritePtr(pdwMulticastLoopBack, sizeof(DWORD)))
        return(E_POINTER);

    // object lock to this object
    CAutoLock LockThis(pStateLock());

    // validate
    if (IsJoined()) {
        TraceDebug((
                TRACE_TRACE, 
                TRACE_ALWAYS, 
                TEXT("CRtpSession::GetMulticastLoopBack: "
                     "(session joined) %d"),
                flags_tst(FG_MULTICASTLOOPBACK)
            ));
        
    } else {
        TraceDebug((
                TRACE_TRACE, 
                TRACE_ALWAYS, 
                TEXT("CRtpSession::GetMulticastLoopBack: "
                     "(session not joined) %d"),
                flags_tst(FG_MULTICASTLOOPBACK)
            ));
    }

    *pdwMulticastLoopBack = flags_tst(FG_MULTICASTLOOPBACK)? 1:0;

    return(NOERROR);
}

////////////////////////////////////////////////////////////
// Set Multicast loop-back state (enbled/disabled)
//
// NOTE: Take care of calling this function with the
//       joined/not_joined flag up to date.
////////////////////////////////////////////////////////////

STDMETHODIMP 
CRtpSession::SetMulticastLoopBack(DWORD dwMulticastLoopBack)
{
    TraceDebug((
            TRACE_TRACE, 
            TRACE_ALWAYS, 
            TEXT("CRtpSession::SetMulticastLoopBack(%d)"),
            dwMulticastLoopBack
        ));

    HRESULT dwError = NOERROR;

    // object lock to this object
    CAutoLock LockThis(pStateLock());

    if (IsJoined() && !IsSender() &&
        IS_MULTICAST(m_RtpAddr.sin_addr.s_addr) ) {
        // If joined, set the socket option...
        unsigned long tmpOutbufsize=0;

        // RTCP
        if (WSAIoctl(m_pRtcpSocket->GetShSocket(),
                     SIO_MULTIPOINT_LOOPBACK,
                     (LPVOID)&dwMulticastLoopBack,
                     sizeof(dwMulticastLoopBack),
                     NULL, 0,
                     &tmpOutbufsize, NULL,
                     NULL)) {

            dwError = E_FAIL;
            TraceDebug((
                    TRACE_ERROR, 
                    TRACE_DEVELOP, 
                    TEXT("CRtpSession::SetMulticastLoopBack(%d): "
                         "WSAIoctl(SIO_MULTIPOINT_LOOPBACK)=%d failed"),
                    dwMulticastLoopBack, WSAGetLastError()
                ));
        }
            
        // RTP
        if (WSAIoctl(m_pRtpSocket->GetShSocket(),
                     SIO_MULTIPOINT_LOOPBACK,
                     (LPVOID)&dwMulticastLoopBack,
                     sizeof(dwMulticastLoopBack),
                     NULL, 0,
                     &tmpOutbufsize, NULL,
                     NULL)) {

            dwError = E_FAIL;
            TraceDebug((
                    TRACE_ERROR, 
                    TRACE_ALWAYS, 
                    TEXT("CRtpSession::SetMulticastLoopBack(%d): "
                         "WSAIoctl(SIO_MULTIPOINT_LOOPBACK)=%d failed"),
                    dwMulticastLoopBack, WSAGetLastError()
                ));
            
        }
    }

    if (dwMulticastLoopBack)
        flags_set(FG_MULTICASTLOOPBACK);
    else
        flags_rst(FG_MULTICASTLOOPBACK);

    return(dwError);
}

// Get the session's RTCP event mask
STDMETHODIMP
CRtpSession::GetRTCPEventMask(DWORD *pdwRTCPEventMask)
{
    if (IsBadWritePtr(pdwRTCPEventMask, sizeof(DWORD)))
        return(E_POINTER);
    
    *pdwRTCPEventMask = m_dwRTCPEventMask;
    
    return(NOERROR);    
}

// Modify (enable/disable items) the RTCP event mask
STDMETHODIMP
CRtpSession::ModifyRTCPEventMask(DWORD dwSelectItems,
                                 DWORD dwEnableItems)
{
    TraceRetail((
            TRACE_TRACE, 
            TRACE_DEVELOP, 
            TEXT("CRtpSession::ModifyRTCPEventMask(0x%X, %d)"),
            dwSelectItems, dwEnableItems
        ));
    
    if (dwEnableItems) {
        m_dwRTCPEventMask |= dwSelectItems;
        //m_dwRTCPEventMask |= fg_par(DXMRTP_NEW_SOURCE_EVENT);
    } else {
        m_dwRTCPEventMask &= ~dwSelectItems;
    }
    
    if (m_pRTPSession &&
        IsJoined()   &&
        m_pRTPSession->pRTCPSession &&
        m_pRTPSession->pRTCPSession->pRRCMcallback)

        m_pRTPSession->pRTCPSession->dwEventMask[IsSender? 1:0] =
            m_dwRTCPEventMask;

    return(NOERROR);
}

// Get a specific local SDES item
STDMETHODIMP
CRtpSession::GetLocalSDESItem(DWORD   dwSDESItem,
                              LPBYTE  psSDESData,
                              LPDWORD pdwSDESLen)
{
    if (IsBadWritePtr(pdwSDESLen, sizeof(DWORD)))
        return(E_POINTER);

    if (IsBadWritePtr(psSDESData, *pdwSDESLen))
        return(E_POINTER);

    DWORD dwLen = *pdwSDESLen;
    *pdwSDESLen = 0;
    int idx = SDES_INDEX(dwSDESItem); // (dwSDESItem-1)
    
    if (idx < SDES_INDEX(RTCP_SDES_FIRST+1) ||
        idx > SDES_INDEX(RTCP_SDES_LAST-1))
        return(E_INVALIDARG);

    if (dwLen < m_SdesData[idx].dwSdesLength)
        return(E_INVALIDARG);

    *pdwSDESLen = m_SdesData[idx].dwSdesLength;

    if (*pdwSDESLen)
        CopyMemory(psSDESData, m_SdesData[idx].sdesBfr, *pdwSDESLen);
    else
        psSDESData[0] = '\0';
        
    return(NOERROR);    
}
    
// Set a specific local SDES item
STDMETHODIMP
CRtpSession::SetLocalSDESItem(DWORD   dwSDESItem,
                              LPBYTE  psSDESData,
                              DWORD   dwSDESLen)
{
    CheckPointer(psSDESData, E_POINTER);

    if (!dwSDESLen)
        return(E_INVALIDARG);

    int idx = SDES_INDEX(dwSDESItem);

    if (idx < SDES_INDEX(RTCP_SDES_FIRST+1) ||
        idx > SDES_INDEX(RTCP_SDES_LAST-1))
        return(E_INVALIDARG);

    if (dwSDESLen > MAX_SDES_LEN)
        return(E_INVALIDARG);
    
    if (IsBadReadPtr(psSDESData, dwSDESLen))
        return(E_POINTER);

    // Update local copy
    CopyMemory(m_SdesData[idx].sdesBfr, psSDESData, dwSDESLen);
    m_SdesData[idx].dwSdesLength = dwSDESLen;

    // Try to update in RTCP
    if (!m_pRTPSession || !IsJoined())
        // postpone to the time a session is created and joined
        return(NOERROR);
    
    HRESULT error = updateSDESinfo((void *)m_pRTPSession->pRTCPSession,
                                   dwSDESItem,
                                   psSDESData,
                                   dwSDESLen);

    if (error == RRCM_NoError)
        return(NOERROR);
    else
        return(E_FAIL);
}

STDMETHODIMP
CRtpSession::GetRTCPSDESMask(DWORD *pdwSdesMask)
{
    if (IsBadWritePtr(pdwSdesMask, sizeof(DWORD)))
        return(E_POINTER);

    *pdwSdesMask = m_dwSdesMask;
    
    return(NOERROR);    
}

STDMETHODIMP
CRtpSession::ModifyRTCPSDESMask(DWORD dwSelectItems,
                                DWORD dwEnableItems)
{
    TraceRetail((
            TRACE_TRACE, 
            TRACE_DEVELOP, 
            TEXT("CRtpSession::ModifyRTCPSDESMask(0x%X, %d)"),
            dwSelectItems, dwEnableItems
        ));
    
    if (dwEnableItems)
        m_dwSdesMask |= dwSelectItems;
    else
        m_dwSdesMask &= ~dwSelectItems;

    // Now try to reflect this in RTCP
    if (m_pRTPSession &&
        IsJoined()   &&
        m_pRTPSession->pRTCPSession)
        m_pRTPSession->pRTCPSession->dwSdesMask = m_dwSdesMask;
    
    return(NOERROR);    
}

// retrieve the SSRC of each participant
STDMETHODIMP
CRtpSession::EnumParticipants(
        LPDWORD pdwSSRC,
        LPDWORD pdwNum)
{
//  TraceDebug((
    //      TRACE_TRACE, 
    //      TRACE_DEVELOP, 
    //      TEXT("CRtpSession::EnumRTPParticipants")
    //  ));

    // check pointer
    if (IsBadWritePtr(pdwNum, sizeof(DWORD)))
        return(E_POINTER);

    if (*pdwNum) {
        if (IsBadWritePtr(pdwSSRC, *pdwNum*sizeof(DWORD)))
            return(E_POINTER);
    }
    
    // object lock to this object
    CAutoLock LockThis(pStateLock());

    // No session created, no possible participants
    if (!m_pRTPSession)
        return(VFW_E_WRONG_STATE);

    if (!IsJoined()) {
        TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::EnumParticipants: session not joined") 
            ));
        
        return(VFW_E_WRONG_STATE);
    }
    
    if (!m_pRTPSession->pRTCPSession)
        return(VFW_E_WRONG_STATE);

    HRESULT error = getSSRCinSession( (void *)m_pRTPSession->pRTCPSession,
                                      pdwSSRC,
                                      pdwNum );
    if (error == RRCM_NoError)
        return(NOERROR);
    else
        return(E_FAIL);
}

// retrieve an specific SDES item from an specific SSRC (participant)
STDMETHODIMP
CRtpSession::GetParticipantSDESItem(
        DWORD dwSSRC,       // specific SSRC
        DWORD dwSDESItem,   // specific item (CNAME, NAME, etc.)
        LPBYTE psSDESData,  // data holder for item retrieved
        LPDWORD pdwLen      // [IN]size of data holder [OUT] size of item
    )
{
    if (IsBadWritePtr(pdwLen, sizeof(DWORD)))
        return(E_POINTER);

    if (!*pdwLen)
        return(E_INVALIDARG);
    
    if (IsBadWritePtr(psSDESData, *pdwLen))
        return(E_POINTER);

    *psSDESData = '\0'; // Set the safe value
    
    int idx = SDES_INDEX(dwSDESItem); // (dwSDESItem-1)
    
    if (idx < SDES_INDEX(RTCP_SDES_FIRST+1) ||
        idx > SDES_INDEX(RTCP_SDES_LAST-1))
        return(E_INVALIDARG);

    // No session created, no possible participants
    if (!m_pRTPSession)
        return(VFW_E_WRONG_STATE);

    if (!IsJoined()) {
        TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::GetParticipantSDESItem: session not joined") 
            ));
        
        return(VFW_E_WRONG_STATE);
    }

    if (!m_pRTPSession->pRTCPSession)
        return(VFW_E_WRONG_STATE);

    // object lock to this object
    CAutoLock LockThis(pStateLock());

    HRESULT error = getSSRCSDESItem( (void *)m_pRTPSession->pRTCPSession,
                                     dwSSRC,
                                     dwSDESItem,
                                     (char *)psSDESData,
                                     pdwLen);

    if (error == RRCM_NoError)
        return(NOERROR);
    else
        return(E_FAIL);
}

// retrieve any number of SDES items from an specific SSRC (participant)
STDMETHODIMP
CRtpSession::GetParticipantSDESAll(
        DWORD dwSSRC,       // specific SSRC
        PSDES_DATA pSdes,   // Array of SDES_DATA structures
        DWORD dwNum         // Number of SDES_DATA items
    )
{
    if (!dwNum)
        return(E_INVALIDARG);
    
    // check pointer
    if (IsBadWritePtr(pSdes, dwNum*sizeof(SDES_DATA)))
        return(E_POINTER);

    // object lock to this object
    CAutoLock LockThis(pStateLock());

    // No session created, no possible participants
    if (!m_pRTPSession)
        return(VFW_E_WRONG_STATE);

    if (!IsJoined()) {
        TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::GetParticipantSDESAll: session not joined") 
            ));
        
        return(VFW_E_WRONG_STATE);
    }

    if (!m_pRTPSession->pRTCPSession)
        return(VFW_E_WRONG_STATE);

    HRESULT error = getSSRCSDESAll((void *)m_pRTPSession->pRTCPSession,
                                   dwSSRC,
                                   pSdes,
                                   dwNum);

    if (error == RRCM_NoError)
        return(NOERROR);
    else
        return(E_FAIL);
}

// retrieves the participant's IP address and port
STDMETHODIMP
CRtpSession::GetParticipantAddress(
        DWORD  dwSSRC,     // specific SSRC
        LPBYTE pbAddr,     // address holder
        int    *piAddrLen  // address lenght
    )
{
    if (IsBadWritePtr(piAddrLen, sizeof(int)))
        return(E_POINTER);

    if (!*piAddrLen || *piAddrLen < sizeof(SOCKADDR))
        return(E_INVALIDARG);

    if (IsBadWritePtr(pbAddr, *piAddrLen))
        return(E_POINTER);

    // No session created, no possible participants
    if (!m_pRTPSession)
        return(VFW_E_WRONG_STATE);

    if (!m_pRTPSession->pRTCPSession)
        return(VFW_E_WRONG_STATE);

    if (!IsJoined()) {
        TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::GetParticipantAddress: session not joined") 
            ));
        
        return(VFW_E_WRONG_STATE);
    }

    // object lock to this object
    CAutoLock LockThis(pStateLock());

    HRESULT error = getSSRCAddress((void *)m_pRTPSession->pRTCPSession,
                                   dwSSRC,
                                   pbAddr,
                                   piAddrLen,
#if 0 && defined(DEBUG)
                                   3 /* Retrieve whatever is availble
                                      * looking first for RTP, if not
                                      * available, then use RTCP
                                      * to fake the RTP address */
#else
                                   2 /* Retrieve whatever
                                      * address is available
                                      * looking first for RTP */
#endif
                                   );

    if (error == RRCM_NoError)
        return(NOERROR);
    else
        return(E_FAIL);
}

// Enable/Disable checking for permission to send
// default is to check
STDMETHODIMP
CRtpSession::SetQOSSendIfAllowed(DWORD dwEnable)
{
    if (IsJoined())
        return(VFW_E_WRONG_STATE);
    
    if (dwEnable) {
        flags_set(FG_SENDIFALLOWED);
        flags_set(FG_SENDIFALLOWED2);
    } else {
        flags_rst(FG_SENDIFALLOWED);
        flags_rst(FG_SENDIFALLOWED2);
    }
    
    return(NOERROR);
}

// Enable/Disable waiting until receivers before start sending
// default is not to wait
STDMETHODIMP
CRtpSession::SetQOSSendIfReceivers(DWORD dwEnable)
{
    if (IsJoined())
        return(VFW_E_WRONG_STATE);
    
    if (dwEnable) {
        flags_set(FG_SENDIFRECEIVERS);
        flags_set(FG_SENDIFRECEIVERS2);
    } else {
        flags_rst(FG_SENDIFRECEIVERS);
        flags_rst(FG_SENDIFRECEIVERS2);
    }
    
    return(NOERROR);
}

// get the current maximum number of QOS enabled participants as well
// as the maximum target bandwidth.
// Fail with E_POINTER only if both pointers are NULL
STDMETHODIMP
CRtpSession::GetMaxQOSEnabledParticipants(DWORD *pdwMaxParticipants,
                                          DWORD *pdwMaxBandwidth)
{
    TraceDebug((
            TRACE_TRACE, 
            TRACE_DEVELOP, 
            TEXT("CRtpSession::GetMaxQOSEnabledParticipants(0x%X, 0x%X)"),
            pdwMaxParticipants, pdwMaxBandwidth
        ));

    DWORD Valid = 0;
    
    if (!IsBadWritePtr(pdwMaxParticipants, sizeof(DWORD))) Valid |= 0x1;

    if (!IsBadWritePtr(pdwMaxBandwidth, sizeof(DWORD))) Valid |= 0x2;

    if (!Valid) {

        TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::GetMaxQOSEnabledParticipants: failed")
            ));
        return(E_POINTER);
    }
    
    // object lock to this object
    CAutoLock LockThis(pStateLock());

    if (Valid & 0x1)
        *pdwMaxParticipants = m_dwMaxFilters;
    
    if (Valid & 0x2)
        *pdwMaxBandwidth = m_dwMaxBandwidth;
    
    return(NOERROR);
}

// The first parametr pass the maximum number of QOS enabled
// participants (this parameter is used by receivers), flush the
// QOS filter list for receivers.  The second parameter specifies
// the target bandwidth and allows to scale some of the parameters
// in the flowspec so the reservation matches the available
// bandwidth. The third parameter defines the reservation style to
// use (0=Wilcard, other=Shared Explicit)the second parameter
STDMETHODIMP
CRtpSession::SetMaxQOSEnabledParticipants(DWORD dwMaxParticipants,
                                          DWORD dwMaxBandwidth,
                                          DWORD fSharedStyle)
{
    HRESULT hr = NOERROR;
    
    TraceRetail((
            TRACE_TRACE, 
            TRACE_DEVELOP, 
            TEXT("CRtpSession::SetMaxQOSEnabledParticipants"
                 "(MaxPars:%u, Bw:%u, Style:%u)"),
            dwMaxParticipants, dwMaxBandwidth, fSharedStyle
        ));
    
    // object lock to this object
    CAutoLock LockThis(pStateLock());

    if (!dwMaxParticipants || !dwMaxBandwidth) {
        TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::SetMaxQOSEnabledParticipants: "
                     "failed: E_INVALIDARG (0x%X)"),
                E_INVALIDARG
            ));

        return(E_INVALIDARG);
    }
    
    if (dwMaxParticipants > MAX_FILTERS)
        dwMaxParticipants = MAX_FILTERS;
    
    m_dwMaxFilters = dwMaxParticipants;
    m_dwMaxBandwidth = dwMaxBandwidth;
    
    if (m_pRtpSocket && m_pRtpSocket->GetpCRtpQOSReserve()) {

        m_pRtpSocket->GetpCRtpQOSReserve()->SetMaxBandwidth(dwMaxBandwidth);

        if (!IsSender()) {
            hr = m_pRtpSocket->GetpCRtpQOSReserve()->
                SetMaxFilters(dwMaxParticipants);
            
            m_dwMaxFilters =
                m_pRtpSocket->GetpCRtpQOSReserve()->GetMaxFilters();
        }
    }
    
    if (fSharedStyle)
        flags_set(FG_SHAREDSTYLE);
    else
        flags_rst(FG_SHAREDSTYLE);
#if defined(DEBUG)
    if (FAILED(hr)) {
        TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::SetMaxQOSEnabledParticipants: "
                     "failed: 0x%X"),
                hr
            ));
    }
#endif
    return(hr);
}

// retrieves the QOS state (QOS enabled/disabled) for
// an specific SSRC (participant)
STDMETHODIMP
CRtpSession::GetParticipantQOSstate(
        DWORD dwSSRC,       // specific SSRC
        DWORD *pdwQOSstate  // the participant's QOS current state
    )
{
    HRESULT hr = NOERROR;

    // check pointer
    if (IsBadWritePtr(pdwQOSstate, sizeof(DWORD)))
        return(E_POINTER);

    *pdwQOSstate = 0;

    // object lock to this object
    CAutoLock LockThis(pStateLock());

    if (m_pRtpSocket && m_pRtpSocket->GetpCRtpQOSReserve())
        if (m_pRtpSocket->GetpCRtpQOSReserve()->FindSSRC(dwSSRC)) {
            *pdwQOSstate = 1;
        }
    else
        hr = VFW_E_WRONG_STATE;

    return(hr);
}

// sets the QOS state (QOS enabled/disabled) for
// an specific SSRC (participant)
STDMETHODIMP
CRtpSession::SetParticipantQOSstate(
        DWORD dwSSRC,       // specific SSRC
        DWORD dwQOSstate    // sets the participant's QOS state
    )
{
    return( ModifyQOSList(&dwSSRC,
                          1,
                          fg_par(OP_BIT_ENABLEADDDEL) |
                          (dwQOSstate? fg_par(OP_BIT_ADDDEL) : 0) ) );
}

// Retrieves the current list of SSRCs that are sharing the
// SE reservation
STDMETHODIMP
CRtpSession::GetQOSList(
        DWORD *pdwSSRCList, // array to place the SSRCs from the list
        DWORD *pdwNumSSRC   // number of SSRCs that can be hold, returned
    )
{
    TraceDebug((
            TRACE_TRACE, 
            TRACE_DEVELOP, 
            TEXT("CRtpSession::GetQOSList")
        ));
    
    if (IsBadWritePtr(pdwNumSSRC, sizeof(DWORD)))
        return(E_POINTER);

    // object lock to this object
    CAutoLock LockThis(pStateLock());

    if (m_pRtpSocket && m_pRtpSocket->GetpCRtpQOSReserve()) {

        CRtpQOSReserve *pCRtpQOSReserve = m_pRtpSocket->GetpCRtpQOSReserve();

        DWORD num_filt = pCRtpQOSReserve->GetNumFilters();

        if (!pdwSSRCList) {
            // Ask only for the number of filters (SSRCs)
            *pdwNumSSRC = num_filt;
        } else {
            // Copy the SSRCs
            if (IsBadWritePtr(pdwSSRCList, *pdwNumSSRC*sizeof(DWORD)))
                return(E_POINTER);

            if (*pdwNumSSRC > num_filt)
                *pdwNumSSRC = num_filt;

            CopyMemory((char *)pdwSSRCList,
                       (char *)pCRtpQOSReserve->GetpRsvpSSRC(),
                       *pdwNumSSRC*sizeof(DWORD));
        }
    } else {
        *pdwNumSSRC = 0;
    }

    return(NOERROR);
}
    

// Modify the QOS state (QOS enabled/disabled) for
// a set of SSRCs (participant)
STDMETHODIMP
CRtpSession::ModifyQOSList(
        DWORD *pdwSSRCList, // array of SSRCs to add/delete
        DWORD dwNumSSRC,    // number of SSRCs passed (0 == flush)
        DWORD dwOperation   // see bits description below
        // bit2=flush bit1=Add(1)/Delete(0) bit0=Enable Add/Delete
        // 1==delete, 3==add(merge), 4==flush, 7==add(replace)
    )
{
    HRESULT hr = NOERROR;

    TraceDebug((
            TRACE_TRACE, 
            TRACE_DEVELOP, 
            TEXT("CRtpSession::ModifyQOSList(%d,%s%s)"),
            dwNumSSRC,
            (fg_tst(dwOperation, OP_BIT_FLUSH))? " FLUSH":"",
            (fg_tst(dwOperation, OP_BIT_ENABLEADDDEL))?
            ((fg_tst(dwOperation, OP_BIT_ADDDEL))? " ADD":" DEL") : ""
        ));

    if (!dwNumSSRC) {
        return(E_INVALIDARG);
    } else if (IsBadReadPtr(pdwSSRCList, dwNumSSRC*sizeof(DWORD))) {
        return(E_POINTER);
    }

    // object lock to this object
    CAutoLock LockThis(pStateLock());

    // this is only valid for a receiver
    if (IsSender()) {
        TraceDebug((
                TRACE_TRACE, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::ModifyQOSList: Do nothing for a sender")
            ));
        return(hr);
    }
    
    if (m_pRtpSocket && m_pRtpSocket->GetpCRtpQOSReserve()) {

        CRtpQOSReserve *pCRtpQOSReserve = m_pRtpSocket->GetpCRtpQOSReserve();

        // this is only valid for Shared Explicit
        if (pCRtpQOSReserve->GetStyle() != RSVP_SHARED_EXPLICIT_STYLE) {
            TraceDebug((
                    TRACE_TRACE, 
                    TRACE_DEVELOP, 
                    TEXT("CRtpSession::ModifyQOSList: Do nothing "
                         "if not SHARED EXPLICIT")
                ));
            return(hr);
        }
        
        if (fg_tst(dwOperation, OP_BIT_FLUSH))
            hr = pCRtpQOSReserve->FlushFilters();

        if (fg_tst(dwOperation, OP_BIT_ENABLEADDDEL)) {
            
            if (pCRtpQOSReserve->GetMaxFilters() > 0) {
                // modify list
                DWORD count = 0;
                    
                for(DWORD i = 0; SUCCEEDED(hr) && i < dwNumSSRC; i++) {
                    hr = pCRtpQOSReserve->
                        AddDeleteSSRC(pdwSSRCList[i],
                                      fg_tst(dwOperation, OP_BIT_ADDDEL));
                    if (SUCCEEDED(hr))
                        count++;
                }

                if (count) {
                    // Succeeds even if some of the participants
                    // could not been added
                    TraceDebug((
                            TRACE_TRACE, 
                            TRACE_DEVELOP, 
                            TEXT("CRtpSession::ModifyQOSList: succeded "
                                 "adding/deleting %d/%d current:%d"),
                            count, dwNumSSRC,
                            pCRtpQOSReserve->GetNumFilters()
                        ));
                    
                    hr = NOERROR;
                } else
                    // Fails only if the change failed for
                    // all the requested participants
                    hr = E_FAIL;
            }
        } else {
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr)) {
            hr = pCRtpQOSReserve->Reserve(0); // Receiver

            // Start QOS notifications
                
            // we enable RECEIVERS and NO_RECEIVERS for senders
            // here, to allow posting NOT_ALLOWED_TO_SEND and
            // ALLOWED_TO_SEND which are generated depending on
            // the state of receivers

            DWORD mask = m_dwQOSEventMask2;
                
            if (IsSender())
                mask |=
                    B2M(DXMRTP_QOSEVENT_RECEIVERS) |
                    B2M(DXMRTP_QOSEVENT_NO_RECEIVERS);
            
            HRESULT qoshr = RTCPStartQOSNotify(m_pRtpSocket->GetShSocket(),
                                               this,
                                               IsSender(),
                                               mask,
                                               CRtpSessionQOSNotify);
            ModifyFlags(FG_QOSNOTIFY_STARTED, SUCCEEDED(qoshr));
        }
    } else {
        hr = VFW_E_WRONG_STATE;
    }
    
#if defined(DEBUG)
    if (FAILED(hr))
        TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CRtpSession::ModifyQOSList: failed: %d (0x%X)"),
                hr, hr
            ));
#endif  
    return(hr);
}

DWORD GetRegistryQOSSetting(DWORD *pEnabled,
                            char *pName, DWORD NameLen,
                            DWORD *pdwDisableFlags,
                            DWORD *pdwEnableFlags)
{
    HKEY hk;
    unsigned long hkDataType;
    unsigned char hkData[MAX_QOS_NAME];
    unsigned long hkcbData;

    // Set defaults
    *pEnabled = 1;
    pName[0] = '\0';
    *pdwDisableFlags = 0;
    *pdwEnableFlags = 0;
    
    if ( RegOpenKeyEx(QOS_ROOT_REGISTRY,QOS_PATH_REGISTRY,
                      0,QOS_KEY_OPEN_FLAGS,&hk) !=  ERROR_SUCCESS )
        
        return(*pEnabled);

    hkcbData = sizeof(hkData);
    if ( RegQueryValueEx(hk, QOS_KEY_ENABLE, 0,
                         &hkDataType,
                         hkData,
                         &hkcbData) == ERROR_SUCCESS ) {

        *pEnabled = *(DWORD *)hkData;
    }

    hkcbData = sizeof(hkData);
    if ( RegQueryValueEx(hk, QOS_KEY_TEMPLATE, 0,
                         &hkDataType,
                         hkData,
                         &hkcbData) == ERROR_SUCCESS ) {

        strncpy(pName, (const char *)hkData, NameLen);
    }

    hkcbData = sizeof(hkData);
    if ( RegQueryValueEx(hk, QOS_KEY_DISABLEFLAGS, 0,
                         &hkDataType,
                         hkData,
                         &hkcbData) == ERROR_SUCCESS ) {

        *pdwDisableFlags = *(DWORD *)hkData;
    }

    hkcbData = sizeof(hkData);
    if ( RegQueryValueEx(hk, QOS_KEY_ENABLEFLAGS, 0,
                         &hkDataType,
                         hkData,
                         &hkcbData) == ERROR_SUCCESS ) {

        *pdwEnableFlags = *(DWORD *)hkData;
    }

    RegCloseKey(hk);
    return(*pEnabled);
}

////////////////////////////////////////////////////////////
//
// Predefined QOS specifications
//
////////////////////////////////////////////////////////////
#if defined(_0_)
#define QOS_UNUSED -1

typedef struct _sflowspec {
    char *qos_name;
    FLOWSPEC fspec;
} SFLOWSPEC;

static SFLOWSPEC s_flowspec[]={
    {"G711",{8000,180,8000,QOS_UNUSED,QOS_UNUSED,
             SERVICETYPE_CONTROLLEDLOAD,180,180} },
    {"G723.1",{1467,44,1467,QOS_UNUSED,QOS_UNUSED,
               SERVICETYPE_CONTROLLEDLOAD,44,44} },
    {"G729",{2000,80,4000,QOS_UNUSED,QOS_UNUSED,
             SERVICETYPE_CONTROLLEDLOAD,40,40} },
    {"DVI4",{4000,100,4000,QOS_UNUSED,QOS_UNUSED,
             SERVICETYPE_CONTROLLEDLOAD,100,100} },
    {"GSM",{2650,53,2650,QOS_UNUSED,QOS_UNUSED,
            SERVICETYPE_CONTROLLEDLOAD,53,53} },
    {(char*)0,{QOS_UNUSED,QOS_UNUSED,QOS_UNUSED,QOS_UNUSED,QOS_UNUSED,
               SERVICETYPE_BESTEFFORT,QOS_UNUSED,QOS_UNUSED} }
};

////////////////////////////////////////////////////////////
// 
// LookUpRegistryQOS()
//
// Looks at the registry for QOS specification.
// return:
//      DO_QOS if QOS parameters have been found
//      DONT_DO_QOS if no QOS parameters available
//             or the parameters say no to use QOS
////////////////////////////////////////////////////////////

static int LookUpRegistryQOS(QOS *pQOS,int senderOnly)
{
    HKEY hk;
    unsigned long hkDataType;
    unsigned char hkData[64];
    unsigned long hkcbData=sizeof(hkData);
    
    if ( RegOpenKeyEx(QOS_ROOT_REGISTRY,QOS_PATH_REGISTRY,
                      0,QOS_KEY_FLAGS,&hk) != 
         ERROR_SUCCESS ) {
        TraceDebug((
                TRACE_ERROR, 
                TRACE_ALWAYS, 
                TEXT("LookUpRegistryQOS: Unable to open registry path: %s"), QOS_PATH_REGISTRY
            ));
        return(DONT_DO_QOS);
    }
    
    // Read type of QOS selected by user
    if ( RegQueryValueEx(hk,"SelectedQOS",0,&hkDataType,
                         hkData,&hkcbData) != 
         ERROR_SUCCESS ) {
        TraceDebug((
                TRACE_ERROR, 
                TRACE_ALWAYS, 
                TEXT("LookUpRegistryQOS: Unable to read item SelectedQOS")
            ));
        RegCloseKey(hk);
        return(DONT_DO_QOS);
    }
    
    // Check if user set NONE use of QOS parameters
    if (!strcmp((const char *)hkData,"NONE")) {
        RegCloseKey(hk);
        TraceDebug((
                TRACE_TRACE, 
                TRACE_ALWAYS, 
                TEXT("LookUpRegistryQOS: QOS NONE") 
            ));
        return(DONT_DO_QOS);
    }
    
    // Use the user defined QOS parameters
    if (!strcmp((const char *)hkData,"USER")) {
        // Read parameters from registry
        
        TraceDebug((
                TRACE_TRACE, 
                TRACE_ALWAYS, 
                TEXT("LookUpRegistryQOS: Copy QOS spec from registry")
            ));
        
        CopyRegistryQOS(hk,pQOS,senderOnly);
        
        RegCloseKey(hk);
        return(DO_QOS);
    }
    
    RegCloseKey(hk);
    
    // Lookup the requested HardCoded QOS
    for(int i=0; s_flowspec[i].qos_name &&
            strcmp((const char *)s_flowspec[i].qos_name,
                   (const char *)hkData); 
        i++);
    if (s_flowspec[i].qos_name) {
        // Copy  parameters from hardcoded set
        
        TraceDebug((
                TRACE_TRACE, 
                TRACE_ALWAYS, 
                TEXT("LookUpRegistryQOS: Predefined QOS set: %s"), s_flowspec[i].qos_name 
            ));
        
        LPFLOWSPEC pFspec;
        
        if (senderOnly) {
            pQOS->SendingFlowspec=s_flowspec[i].fspec;
            pFspec = &pQOS->ReceivingFlowspec;
        } else {
            pQOS->ReceivingFlowspec=s_flowspec[i].fspec;
            pFspec = &pQOS->SendingFlowspec;
        }
        
        pFspec->TokenRate = QOS_UNUSED;
        pFspec->TokenBucketSize = QOS_UNUSED;
        pFspec->PeakBandwidth = QOS_UNUSED;
        pFspec->Latency = QOS_UNUSED;
        pFspec->DelayVariation = QOS_UNUSED;
        pFspec->ServiceType = QOS_UNUSED;
        pFspec->MaxSduSize = QOS_UNUSED;
        pFspec->MinimumPolicedSize = QOS_UNUSED;
        
        return(DO_QOS);
    }
    
    return(DONT_DO_QOS);
}

////////////////////////////////////////////////////////////
//
// CopyRegistryQOS()
//
// Copy QOS specification from registry
////////////////////////////////////////////////////////////

static void CopyRegistryQOS(HKEY hk,QOS *pQOS,int senderOnly)
{
    unsigned long hkDataType;
    unsigned char hkData[64];
    unsigned long hkbcData;
    FLOWSPEC *sendFSpec=&pQOS->SendingFlowspec;
    FLOWSPEC *recvFSpec=&pQOS->ReceivingFlowspec;
    
    TraceDebug((
            TRACE_TRACE, 
            TRACE_ALWAYS, 
            TEXT("CopyRegistryQOS...") 
        ));
    
    hkbcData=sizeof(hkData);
    if (RegQueryValueEx(hk,"TokenRate",
                        0,&hkDataType,hkData,&hkbcData) ==
        ERROR_SUCCESS) {
        if (senderOnly) {
            sendFSpec->TokenRate=*(ULONG*)hkData;
            recvFSpec->TokenRate=QOS_UNUSED;
        } else {
            sendFSpec->TokenRate=QOS_UNUSED;
            recvFSpec->TokenRate=*(ULONG*)hkData;
        }
    } else
        sendFSpec->TokenRate=recvFSpec->TokenRate=QOS_UNUSED;
    
    hkbcData=sizeof(hkData);
    if (RegQueryValueEx(hk,"TokenBucketSize",
                        0,&hkDataType,hkData,&hkbcData) ==
        ERROR_SUCCESS) {
        if (senderOnly) {
            sendFSpec->TokenBucketSize=*(ULONG*)hkData;
            recvFSpec->TokenBucketSize=QOS_UNUSED;
        } else {
            sendFSpec->TokenBucketSize=QOS_UNUSED;
            recvFSpec->TokenBucketSize=*(ULONG*)hkData;
        }
    } else
        sendFSpec->TokenBucketSize=recvFSpec->TokenBucketSize=QOS_UNUSED;
    
    hkbcData=sizeof(hkData);
    if (RegQueryValueEx(hk,"PeakBandwidth",
                        0,&hkDataType,hkData,&hkbcData) ==
        ERROR_SUCCESS) {
        if (senderOnly) {
            sendFSpec->PeakBandwidth=*(ULONG*)hkData;
            recvFSpec->PeakBandwidth=QOS_UNUSED;
        } else {
            sendFSpec->PeakBandwidth=QOS_UNUSED;
            recvFSpec->PeakBandwidth=*(ULONG*)hkData;
        }
    } else
        sendFSpec->PeakBandwidth=recvFSpec->PeakBandwidth=QOS_UNUSED;
    
    hkbcData=sizeof(hkData);
    if (RegQueryValueEx(hk,"Latency",
                        0,&hkDataType,hkData,&hkbcData) ==
        ERROR_SUCCESS) {
        if (senderOnly) {
            sendFSpec->Latency=*(ULONG*)hkData;
            recvFSpec->Latency=QOS_UNUSED;
        } else {
            sendFSpec->Latency=QOS_UNUSED;
            recvFSpec->Latency=*(ULONG*)hkData;
        }
    } else
        sendFSpec->Latency=recvFSpec->Latency=QOS_UNUSED;
    
    hkbcData=sizeof(hkData);
    if (RegQueryValueEx(hk,"DelayVariation",
                        0,&hkDataType,hkData,&hkbcData) ==
        ERROR_SUCCESS) {
        if (senderOnly) {
            sendFSpec->DelayVariation=*(ULONG*)hkData;
            recvFSpec->DelayVariation=QOS_UNUSED;
        } else {
            sendFSpec->DelayVariation=QOS_UNUSED;
            recvFSpec->DelayVariation=*(ULONG*)hkData;
        }
    } else
        sendFSpec->DelayVariation=recvFSpec->DelayVariation=QOS_UNUSED;
    
    hkbcData=sizeof(hkData);
    if (RegQueryValueEx(hk,"ServiceType",
                        0,&hkDataType,hkData,&hkbcData) ==
        ERROR_SUCCESS) {
        if (senderOnly) {
            sendFSpec->ServiceType=*(ULONG*)hkData;
            recvFSpec->ServiceType=QOS_UNUSED;
        } else {
            sendFSpec->ServiceType=QOS_UNUSED;
            recvFSpec->ServiceType=*(ULONG*)hkData;
        }
    } else
        sendFSpec->ServiceType=recvFSpec->ServiceType=QOS_UNUSED;
    
    hkbcData=sizeof(hkData);
    if (RegQueryValueEx(hk,"MaxSduSize",
                        0,&hkDataType,hkData,&hkbcData) ==
        ERROR_SUCCESS) {
        if (senderOnly) {
            sendFSpec->MaxSduSize=*(ULONG*)hkData;
            recvFSpec->MaxSduSize=QOS_UNUSED;
        } else {
            sendFSpec->MaxSduSize=QOS_UNUSED;
            recvFSpec->MaxSduSize=*(ULONG*)hkData;
        }
    } else
        sendFSpec->MaxSduSize=recvFSpec->MaxSduSize=QOS_UNUSED;
    
    hkbcData=sizeof(hkData);
    if (RegQueryValueEx(hk,"MinimumPolicedSize",
                        0,&hkDataType,hkData,&hkbcData) ==
        ERROR_SUCCESS) {
        if (senderOnly) {
            sendFSpec->MinimumPolicedSize=*(ULONG*)hkData;
            recvFSpec->MinimumPolicedSize=QOS_UNUSED;
        } else {
            sendFSpec->MinimumPolicedSize=QOS_UNUSED;
            recvFSpec->MinimumPolicedSize=*(ULONG*)hkData;
        }
    } else
        sendFSpec->MinimumPolicedSize=recvFSpec->MinimumPolicedSize=QOS_UNUSED;
}
#endif // defined(_0_)


HRESULT
CRtpSession::GetSessionID(DWORD *pdwID)
{
    // validate pointer
    if (IsBadWritePtr(pdwID, sizeof(DWORD)))
        return(E_POINTER);

    *pdwID = -1;
    
    // validate
    if (!IsJoined()) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_ALWAYS, 
            TEXT("session not joined") 
            ));

        return VFW_E_WRONG_STATE; // bail...
    }

    if (m_pRTPSession &&
        m_pRTPSession->pRTCPSession) {

        *pdwID = (DWORD)m_pRTPSession->pRTCPSession->lRTCP_ID;
    }

    return(NOERROR);
}

static char *sEventString[] = {"????",
                               "NEW_SOURCE",
                               "RECV_REPORT",
                               "SNDR_REPORT",
                               "LOC_COLLISION",
                               "REM_COLLISION",
                               "TIMEOUT",
                               "BYE",
                               "WS_RCV_ERROR",
                               "WS_XMT_ERROR",
                               "INACTIVE",
                               "ACTIVE_AGAIN",
                               "LOSS_RATE_RR",
                               "LOSS_RATE_LOCAL",
                                "XXXX"};

void CALLBACK
RRCMCallback(           
        DXMRTP_EVENT_T sEventType,
        DWORD        dwP_1,
        DWORD        dwP_2,
        void         *pvUserInfo)
{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_DEVELOP2, 
        TEXT("RRCMCallback")
        ));
        
    CRtpSession *pCRtpSession = (CRtpSession *) pvUserInfo;

    
    if (pCRtpSession) {

        DWORD dwSessionID;
        pCRtpSession->GetSessionID(&dwSessionID);

        if (sEventType != DXMRTP_RECV_RTCP_RECV_REPORT_EVENT &&
            sEventType != DXMRTP_RECV_RTCP_SNDR_REPORT_EVENT &&
            sEventType != DXMRTP_LOSS_RATE_RR_EVENT &&
            sEventType != DXMRTP_LOSS_RATE_LOCAL_EVENT) {
            // Don't want to be flood by sender/receiver reports
            // nor loss rate events
            TraceRetail((
                    TRACE_TRACE, 
                    TRACE_DEVELOP, 
                    TEXT("RRCMCallback: "
                         "Event:>>>%s<<<, SessionID:%d is %s, "
                         "P1:0x%X (%d) P2:0x%X (%d)"),
                    sEventString[sEventType],
                    dwSessionID,
                    (pCRtpSession->IsSender())? "SEND":"RECV",
                    dwP_1, dwP_1, dwP_2, dwP_2
                ));
        }

        // XXX Hack for my testing.
        // I need to make sure the Shared Explicit is called
        // at least with one participant
        if (pCRtpSession->TestFlags(FG_AUTO_SHAREDEXPLICIT) &&
            !pCRtpSession->IsSender() &&
            sEventType == DXMRTP_NEW_SOURCE_EVENT) {

            HRESULT res = pCRtpSession->SetParticipantQOSstate(dwP_1, 1);
        }
        // if (Event == BYE) Par2 = IP_ADDRESS (what is passed by RTCP)
        // else              Par2 = SessionID
        // (Original Par2 from RRCM is discarded)
        if (sEventType != DXMRTP_BYE_EVENT) {
            // XXX I need to change this to be native in RRCM
            dwP_2 = dwSessionID;
        }
        
        pCRtpSession->HandleCRtpSessionNotify(DXMRTP_EVENTBASE,
                                              sEventType,
                                              dwP_1,
                                              dwP_2);
    }
}
    
HRESULT
CRtpSession::HandleCRtpSessionNotify(
        DWORD dwEventBase,
        DWORD dwEventType,
        DWORD dwP_1,
        DWORD dwP_2)
{
    // object lock to this object
    //CAutoLock LockThis(pStateLock());

    // validate
    if (!IsJoined() && !flags_tst(FG_EVENT_READY)) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_ALWAYS, 
            TEXT("CRtpSession::HandleCRtpSessionNotify: "
                 "session is not joined") 
            ));

        return VFW_E_WRONG_STATE;
    }

    HRESULT hr;

    if (m_pCBaseFilter) {
        
        hr = m_pCBaseFilter->NotifyEvent(dwEventBase + dwEventType,
                                         dwP_1,
                                         dwP_2);
        //m_lSessionID);
        if ( SUCCEEDED(hr) ) {
            TraceDebug((
                    TRACE_TRACE, 
                    TRACE_DEVELOP2,
                    TEXT("CRtpSession::HandleCRtpSessionNotify: "
                         "Succeeded !!!")
                ));
        } else {
            TraceDebug((
                    TRACE_TRACE, 
                    TRACE_DEVELOP, 
                    TEXT("CRtpSession::HandleCRtpSessionNotify: "
                         "failed 0x%X"),
                    hr
                ));
        }
    }

    return(hr);
}

HRESULT
CRtpSession::GetDataClock(DWORD *pdwDataClock)
{
    // check pointer
    if (IsBadWritePtr(pdwDataClock, sizeof(DWORD)))
        return(E_POINTER);

    *pdwDataClock = m_dwDataClock;

    return(NOERROR);
}

HRESULT
CRtpSession::SetDataClock(DWORD dwDataClock)
{
    // Validate Clock frequency ??? E_INVALIDARG
    if (dwDataClock)
        m_dwDataClock = dwDataClock;

    return(NOERROR);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// INonDelegatingUnknown implemented methods                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRtpSession::NonDelegatingQueryInterface(
    REFIID  riid, 
    void ** ppv
    )

/*++

Routine Description:

    Returns an interface and increments the reference count.

Arguments:

    riid - reference identifier. 

    ppv - pointer to the interface. 

Return Values:

    Returns a pointer to the interface.

--*/

{
#ifdef DEBUG_CRITICAL_PATH
    
    TraceDebug((
        TRACE_TRACE, 
        TRACE_CRITICAL, 
        TEXT("CRtpSession::NonDelegatingQueryInterface")
        ));

#endif // DEBUG_CRITICAL_PATH

    // validate pointer
    CheckPointer(ppv,E_POINTER);

    // obtain proper interface
    if (riid == IID_IRTPStream) {
    
        // return pointer to this object 
        return GetInterface(dynamic_cast<IRTPStream *>(this), ppv);

    } else if (riid == IID_IRTCPStream) {
    
        // return pointer to this object 
        return GetInterface(dynamic_cast<IRTCPStream *>(this), ppv);

    } else if (riid == IID_IRTPParticipant) {
    
        // return pointer to this object 
        return GetInterface(dynamic_cast<IRTPParticipant *>(this), ppv);

    } else {

        // forward this request to the base object
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
} 

/////////////////////////////////////////////////////////////////////////
///  Query Socket methods
/////////////////////////////////////////////////////////////////////////

CQuerySocket::CQuerySocket()
{
    WSADATA WSAData;
    WORD VersionRequested = MAKEWORD(1,1);

    // initialize winsock first    
    if (WSAStartup(VersionRequested, &WSAData)) {

        TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CQuerySocket::CQuerySocket: WSAStartup failed: %d"), 
                WSAGetLastError()
            ));
    } else {

        // Create a socket for addresses query
        m_Socket = WSASocket(AF_INET,            // af
                             SOCK_DGRAM,         // type
                             IPPROTO_IP,         // protocol
                             NULL,               // lpProtocolInfo
                             0,                  // g
                             0                   // dwFlags
            );
    
        if (m_Socket == INVALID_SOCKET) {

            DWORD dwStatus = WSAGetLastError();

            TraceDebug((
                    TRACE_ERROR, 
                    TRACE_DEVELOP, 
                    TEXT("CQuerySocket::CQuerySocket: "
                         "WSASocket failed: %d (0x%X)"),
                    dwStatus, dwStatus
                ));
        } else {
            TraceDebug((
                    TRACE_TRACE, 
                    TRACE_DEVELOP, 
                    TEXT("CQuerySocket::CQuerySocket: "
                         "WSASocket created: %d"),
                    m_Socket
                ));
        }
    }
}

CQuerySocket::~CQuerySocket()
{
    if (m_Socket != INVALID_SOCKET) {
        if (closesocket(m_Socket) == SOCKET_ERROR) {

            DWORD dwStatus = WSAGetLastError();

            TraceDebug((
                    TRACE_ERROR, 
                    TRACE_DEVELOP, 
                    TEXT("CQuerySocket::~CQuerySocket: "
                         "closesocket failed: %d (0x%X)"),
                    dwStatus, dwStatus
                ));
            }
        m_Socket = INVALID_SOCKET;
    }

    // shutdown now
    if (WSACleanup()) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_DEVELOP, 
            TEXT("CQuerySocket::~CQuerySocket: WSACleanup failed %d"),
            WSAGetLastError()
            ));
    }
}

#if defined(DEBUG) && defined(_MYTHREAD_)

#define MY_MAX_SSRC 10

void displaySSRC(CRtpSession *pCRtps, DWORD ssrc)
{
#if defined(_0_)    
    char data[MAX_SDES_LEN];
    DWORD len, end=0;

    for(int item = RTCP_SDES_FIRST + 1; item < RTCP_SDES_LAST; item++) {
        len = sizeof(data);
        pCRtps->GetParticipantSDESItem(ssrc, item, (PBYTE)data, &len);
        if (len > 0) {
            end = 1;
            TraceDebug((
                    TRACE_TRACE, 
                    TRACE_DEVELOP, 
                    TEXT("[0x%08X] SDES %5s: %s"),
                    ssrc, sdes_name[item], data
                ));
        }
    }
#endif // defined(_0_)
    SDES_DATA sdesData[8];
    DWORD idx, end = 0;

    for(idx = 0; idx < 8; idx++)
        sdesData[idx].dwSdesType = idx + 1;

    pCRtps->GetParticipantSDESAll(ssrc, sdesData, 8);

    for(idx = 0; idx < 8; idx++) {
        if (sdesData[idx].dwSdesLength > 0) {
            end = 1;
            TraceDebug((
                    TRACE_TRACE, 
                    TRACE_DEVELOP, 
                    TEXT("[%08X] SDES %s: %s"),
                    ssrc,
                    sdes_name[sdesData[idx].dwSdesType],
                    sdesData[idx].sdesBfr
                ));
        }
    }

    if (end) 
        TraceDebug((
                TRACE_TRACE, 
                TRACE_DEVELOP, 
                TEXT("----------------------")
            ));
}

DWORD WINAPI MyThreadProc(LPVOID pvPar)
{
    TraceDebug((
            TRACE_TRACE, 
            TRACE_DEVELOP, 
            TEXT("MyThread: starting...")
        ));

    CRtpSession *pCRtps = (CRtpSession *)pvPar;
    
    while(1) {
        Sleep(1000*5);
        TraceDebug((
                TRACE_TRACE, 
                TRACE_DEVELOP, 
                TEXT("MyThread: awakening...")
            ));
        DWORD ssrc[MY_MAX_SSRC];
        DWORD len = 0;

        pCRtps->EnumParticipants(NULL, &len);

        if (len > 0) {
            TraceDebug((
                    TRACE_TRACE, 
                    TRACE_DEVELOP, 
                    TEXT("MyThread: session[%08X] num ssrc: %d"),
                    (int)pCRtps, len
                ));
            
            if (len > MY_MAX_SSRC)
                len = MY_MAX_SSRC;
                
            pCRtps->EnumParticipants(ssrc, &len);
                
            for(DWORD i=0; i<len; i++)
                displaySSRC(pCRtps, ssrc[i]);
        }
    }

    return(0);
}

void StartMyThread(CRtpSession *pCRTPSession)
{
    int i;

    if (!cMyThread) {
        ZeroMemory(MyThread, sizeof(MyThread));
        cMyThread++;
    }
    
    for(i=0; i < MAX_MY_THREAD; i++)
        if (MyThread[i].hThread == NULL)
            break;
    if (i == MAX_MY_THREAD)
        return;

    TraceDebug((
            TRACE_TRACE, 
            TRACE_DEVELOP, 
            TEXT("CreateMyThread: ...")
        ));
    MyThread[i].hThread = CreateThread(NULL, 0, MyThreadProc,
                                       (LPVOID)pCRTPSession, 0,
                                       &MyThread[i].ThreadId);
    if (MyThread[i].hThread) {
        MyThread[i].pCRtps = pCRTPSession;
        TraceDebug((
                TRACE_TRACE, 
                TRACE_DEVELOP, 
                TEXT("StartMyThread: Thread ID: %X"),
                MyThread[i].ThreadId
            ));
    } else
        TraceDebug((
                TRACE_TRACE, 
                TRACE_DEVELOP, 
                TEXT("StartMyThread: failed: %d"),
                GetLastError()
            ));
}

void StopMyThread(CRtpSession *pCRTPSession)
{
    int i;

    for(i=0; i < MAX_MY_THREAD; i++)
        if (MyThread[i].pCRtps == pCRTPSession)
            break;

    if (i == MAX_MY_THREAD)
        return;

    if (MyThread[i].hThread != NULL) {
        if (CloseHandle(MyThread[i].hThread))
            TraceDebug((
                    TRACE_TRACE, 
                    TRACE_DEVELOP, 
                    TEXT("StopMyThread: stoping thread: %X"),
                    MyThread[i].ThreadId
                ));
        else
            TraceDebug((
                    TRACE_ERROR, 
                    TRACE_DEVELOP, 
                    TEXT("StopMyThread: CloseHandle failed: %d"),
                    GetLastError()
                ));
    }

    MyThread[i].hThread = NULL;
    MyThread[i].pCRtps = NULL;
}

#endif // defined(DEBUG) && defined(_MYTHREAD_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\rtpalloc.cpp ===
//
// rtpalloc.cpp - RTP Streaming allocator
//
// Copyright (C) Microsoft Corporation, 1996 - 1999  All rights reserved.
//

#include "globals.h"
#include "rtpalloc.h"

//=====================================================================
//=====================================================================
// Implements CRTPAllocator
//=====================================================================
//=====================================================================

STDMETHODIMP_(ULONG) CRTPSample::NonDelegatingRelease()
{
    //
    // Decrement our own private reference count
    //
    LONG lRef = InterlockedDecrement(&m_cRef);
    ASSERT(lRef >= 0);

    DbgLog((LOG_MEMORY,3,TEXT("    Unknown %X ref-- = %d"),
            this, m_cRef));

    //
    // Did we release our final reference count
    //
    if (lRef == 0)
    {
        //
        // Free all resources
        //
        SetMediaType(NULL);
        m_dwFlags = 0;

        //
        // This may cause us to be deleted
        // Our refcount is reliably 0 thus no-one will mess with us
        //
        m_pAllocator->ReleaseBuffer(this);
    }
    return (ULONG)lRef;
}



//=====================================================================
//=====================================================================
// Implements CRTPAllocator
//=====================================================================
//=====================================================================

CRTPAllocator::CRTPAllocator(
                    TCHAR *pName,
                    LPUNKNOWN pUnk,
                    HRESULT *phr
                    )
    : CBaseAllocator(pName, pUnk, phr, TRUE, TRUE)
    , m_pBuffer(NULL)
{
    if (*phr != S_OK) return;

	*phr = S_OK;
}

//
// Destructor frees our memory resources
//
CRTPAllocator::~CRTPAllocator()
{
    Decommit();
    ReallyFree();
}

//
// This sets the size and count of the required samples. The memory isn't
// actually allocated until Commit() is called, if memory has already been
// allocated then assuming no samples are outstanding the user may call us
// to change the buffering, the memory will be released in Commit()
//
STDMETHODIMP CRTPAllocator::SetProperties(
    ALLOCATOR_PROPERTIES* pRequest,
    ALLOCATOR_PROPERTIES* pActual
    )
{
    CheckPointer(pActual,E_POINTER);
    ValidateReadWritePtr(pActual,sizeof(ALLOCATOR_PROPERTIES));
    CAutoLock cObjectLock(this);

    ZeroMemory(pActual, sizeof(ALLOCATOR_PROPERTIES));

    ASSERT(pRequest->cbBuffer > 0);

    SYSTEM_INFO SysInfo;
    GetSystemInfo(&SysInfo);

    /*  Check the alignment request is a power of 2 */
    if ((-pRequest->cbAlign & pRequest->cbAlign) != pRequest->cbAlign)
    {
	    DbgLog((LOG_ERROR, 1, TEXT("Alignment requested 0x%x not a power of 2!"),
	       pRequest->cbAlign));
    }
    /*  Check the alignment requested */
    if (pRequest->cbAlign == 0 ||
	    (SysInfo.dwAllocationGranularity & (pRequest->cbAlign - 1)) != 0)
    {
	    DbgLog((LOG_ERROR, 1, TEXT("Invalid alignment 0x%x requested - granularity = 0x%x"),
	       pRequest->cbAlign, SysInfo.dwAllocationGranularity));
	    return VFW_E_BADALIGN;
    }

    //
    // Can't do this if already committed, there is an argument that says we
    // should not reject the SetProperties call if there are buffers still
    // active. However this is called by the source filter, which is the same
    // person who is holding the samples. Therefore it is not unreasonable
    // for them to free all their samples before changing the requirements
    //
    if (m_bCommitted == TRUE)
    {
	    return VFW_E_ALREADY_COMMITTED;
    }

    //
    // Must be no outstanding buffers
    //
    if (m_lFree.GetCount() < m_lAllocated)
    {
	    return VFW_E_BUFFERS_OUTSTANDING;
    }

    //
    // There isn't any real need to check the parameters as they
    // will just be rejected when the user finally calls Commit
    //
    // round length up to alignment - remember that prefix is included in
    // the alignment
    //
    pActual->cbPrefix = m_lPrefix = pRequest->cbPrefix;

    LONG lSize = pRequest->cbBuffer + pRequest->cbPrefix;
    LONG lRemainder = lSize % pRequest->cbAlign;
    if (lRemainder != 0)
    {
	    lSize = lSize - lRemainder + pRequest->cbAlign;
    }
    pActual->cbBuffer = m_lSize = (lSize - pRequest->cbPrefix);

    pActual->cBuffers = m_lCount = pRequest->cBuffers;
    pActual->cbAlign = m_lAlignment = pRequest->cbAlign;

    m_bChanged = TRUE;
    return NOERROR;
}

//
// override this to allocate our resources when Commit is called.
//
// note that our resources may be already allocated when this is called,
// since we don't free them on Decommit. We will only be called when in
// decommit state with all buffers free.
//
// object locked by caller
//
HRESULT CRTPAllocator::Alloc(void)
{
    CAutoLock lck(this);

    //
    // Check he has called SetProperties
    //
    HRESULT hr = CBaseAllocator::Alloc();
    if (FAILED(hr))	return hr;
    
    //
    // If the requirements haven't changed then don't reallocate
    //
    if (hr == S_FALSE)
    {
	    ASSERT(m_pBuffer);
	    return NOERROR;
    }
    ASSERT(hr == S_OK); // we use this fact in the loop below

    //
    // Free the old resources
    //
    if (m_pBuffer) ReallyFree();

    //
    // Create the contiguous memory block for the samples
    // making sure it's properly aligned (64K should be enough!)
    //
    ASSERT(m_lAlignment != 0 &&
	   (m_lSize + m_lPrefix) % m_lAlignment == 0);

    m_pBuffer = (PBYTE)VirtualAlloc(NULL,
				    m_lCount * (m_lSize + m_lPrefix),
				    MEM_COMMIT,
				    PAGE_READWRITE);

    if (m_pBuffer == NULL) return E_OUTOFMEMORY;

    LPBYTE pNext = m_pBuffer;
    CMediaSample *pSample;

    ASSERT(m_lAllocated == 0);

    //
    // Create the new samples - we have allocated m_lSize bytes for each sample
    // plus m_lPrefix bytes per sample as a prefix. We set the pointer to
    // the memory after the prefix - so that GetPointer() will return a pointer
    // to m_lSize bytes.
    //
    for (; m_lAllocated < m_lCount; m_lAllocated++, pNext += (m_lSize + m_lPrefix))
    {
	    pSample = new CRTPSample(
                    NAME("Default memory media sample"),
                    this,
                    &hr,
                    pNext + m_lPrefix,      // GetPointer() value
                    m_lSize);               // not including prefix

	    if (FAILED(hr) || pSample == NULL)
        {
	        delete pSample;
	        return E_OUTOFMEMORY;
	    }

	    //
        // This CANNOT fail
        //
	    m_lFree.Add(pSample);
    }

    m_bChanged = FALSE;
    return NOERROR;
}

//
// override this to free up any resources we have allocated.
// called from the base class on Decommit when all buffers have been
// returned to the free list.
//
// caller has already locked the object.

// in our case, we keep the memory until we are deleted, so
// we do nothing here. The memory is deleted in the destructor by
// calling ReallyFree()
//
void CRTPAllocator::Free(void)
{
    return;
}

//
// called from the destructor (and from Alloc if changing size/count) to
// actually free up the memory
//

#if DEBUG_RTPALLOC > 2
#define DEBUGBREAK() DebugBreak()
#else
#define DEBUGBREAK()
#endif

void CRTPAllocator::ReallyFree(void)
{
    //
    // Should never be deleting this unless all buffers are freed
    //
    ASSERT(m_lAllocated == m_lFree.GetCount());

    //
    // Free up all the CMediaSamples
    //
    CMediaSample *pSample;
	long free_count = 0;
	
    for (;;)
    {
        pSample = m_lFree.RemoveHead();
        if (pSample != NULL)
        {
            delete pSample;
			free_count++;
        }
        else
        {
            break;
        }
    }

#if  DEBUG_RTPALLOC > 1
	if(free_count != m_lAllocated) {
		char msg[128];
		wsprintf(msg,"CRTPAllocator::ReallyFree: Memory leak "
				 "(free_count:%d != %d:m_Allocated)\n",
				 free_count, m_lAllocated);
		OutputDebugString(msg);
		DEBUGBREAK();
	}
#endif
	
    m_lAllocated = 0;

    //
    // free the block of buffer memory
    //
    if (m_pBuffer)
    {
	    EXECUTE_ASSERT(VirtualFree(m_pBuffer, 0, MEM_RELEASE));
	    m_pBuffer = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\source.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    source.cpp

Abstract:

    Implementation of CRtpSourceFilter class.

Environment:

    User Mode - Win32

Revision History:

    10-Nov-1996 DonRyan
        Created.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRtpSourceFilter Implementation                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRtpSourceFilter::CRtpSourceFilter(
    LPUNKNOWN pUnk,
    HRESULT * phr
    )

/*++

Routine Description:

    Constructor for CRtpSourceFilter class.    

Arguments:

    pUnk - IUnknown interface of the delegating object. 

    phr - pointer to the general OLE return value. 

Return Values:

    Returns an HRESULT value.

--*/

:   CSource(
        NAME("CRtpSourceFilter"), 
        pUnk, 
        CLSID_RTPSourceFilter, 
        phr
        ),
    CPersistStream(pUnk, phr)
{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_DEVELOP, 
        TEXT("[%x:0x%X]CRtpSourceFilter::CRtpSourceFilter"),
        GetCurrentThreadId(), this));

    WSADATA WSAData;
    WORD VersionRequested = MAKEWORD(1,1);

    // initialize winsock first    
    if (WSAStartup(VersionRequested, &WSAData)) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_DEVELOP, 
            TEXT("WSAStartup returned %d"), 
            WSAGetLastError()
            ));

        // default
        *phr = E_FAIL;

        return; // bail...
    }

    // allocate new rtp output pin to use as default
    CRtpOutputPin * pRtpOutputPin = new CRtpOutputPin(this, GetOwner(), phr);

    if (FAILED(*phr)) {
        TraceDebug((
                TRACE_ERROR,
                TRACE_DEVELOP,
                TEXT("CRtpSourceFilter::CRtpSourceFilter: "
                     "new CRtpOutputPin() failed: 0x%X"),
                *phr
            ));
        return;
    }
    
    // validate pointer
    if (pRtpOutputPin == NULL) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_DEVELOP, 
            TEXT("Could not create CRtpOutputPin")
            ));

        // return default 
        *phr = E_OUTOFMEMORY;

        return; // bail...
    }

    *phr = NO_ERROR;
    
    //
    // pins add themselves to filters's array...
    //
}


CRtpSourceFilter::~CRtpSourceFilter(
    )

/*++

Routine Description:

    Destructor for CRtpSourceFilter class.    

Arguments:

    None.

Return Values:

    None.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_DEVELOP, 
        TEXT("[%x:0x%X]CRtpSourceFilter::~CRtpSourceFilter"),
        GetCurrentThreadId(), this));

    // shutdown now
    if (WSACleanup()) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_DEVELOP, 
            TEXT("WSACleanup returned %d"), 
            WSAGetLastError()
            ));
    }

    //
    // pins delete themselves from filter's array
    //
}


CUnknown *
CRtpSourceFilter::CreateInstance(
    LPUNKNOWN punk, 
    HRESULT * phr
    )

/*++

Routine Description:

    Called by COM to create a CRtpSourceFilter object.    

Arguments:

    pUnk - pointer to the owner of this object. 

    phr - pointer to an HRESULT value for resulting information. 

Return Values:

    None.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpSourceFilter::CreateInstance")
        ));

    // attempt to create rtp sender object
    CRtpSourceFilter * pNewObject = new CRtpSourceFilter(punk, phr);

    // validate pointer
    if (pNewObject == NULL) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_DEVELOP, 
            TEXT("Could not create CRtpSourceFilter")
            ));

        // return default
        *phr = E_OUTOFMEMORY;
    }

    // return object
    return pNewObject;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CBaseFilter overrided methods                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LPAMOVIESETUP_FILTER 
CRtpSourceFilter::GetSetupData(
    )

/*++

Routine Description:

    Called by ActiveMovie to retrieve filter setup information.    

Arguments:

    None.

Return Values:

    Returns pointer to filter info structure.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpSourceFilter::GetSetupData")
        ));

    // get sink filter info
    return &g_RtpSourceFilter;
}


STDMETHODIMP
CRtpSourceFilter::Pause(
    )

/*++

Routine Description:

    Transitions filter to State_Paused state if it is not in state already. 

Arguments:

    None.

Return Values:

    Returns an HRESULT value. 

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpSourceFilter::Pause")
        ));

    // obtain lock to this object
    CAutoLock LockThis(pStateLock());

    // check current filter state
    if (m_State != State_Paused) { 

        // obtain number of pins
        int cPins = GetPinCount();

        // process each pin in filter
        for (int c = 0; c < cPins; c++) {

            // obtain interface pointer to output pins
            CRtpOutputPin * pPin = (CRtpOutputPin *)GetPin(c);

            // ignore unconnected pins
            if (pPin->IsConnected()) {

                // activate pin if stopped else pause
                HRESULT hr;
                if (m_State == State_Stopped) {
                    hr = pPin->Active();
                } else {
                    //
                    // Note: we no longer process pause in the stream thread because
                    //       renderers may block.  The stream thread pause actually
                    //       does nothing anyway as our current implementation simply
                    //       stops delivering when in paused state.
                    //
                    hr = S_OK;
                }
                
                // validate
                if (FAILED(hr)) {

                    TraceDebug((
                        TRACE_ERROR, 
                        TRACE_DEVELOP,
                        (m_State == State_Stopped) 
                            ? TEXT("CRtpOutputPin::Active returned 0x%08lx")
                            : TEXT("CRtpOutputPin::Pause returned 0x%08lx"), 
                        hr
                        ));

                    return hr; // bail...
                }
            }
        }
    }

    // change state now
    m_State = State_Paused;

    return NOERROR;
}

// ZCS bugfix 6-20-97 as per mail from amovie guys
// Here we overload the CBaseMediaFilter::GetState() method. The only
// difference is that we return VFW_S_CANT_CUE, which keeps the filter graph
// from hanging when we stop the graph before receiving any packets.
// (The video or audio renderer keeps waiting for a packet to "cue" on -- it
// is in an "inconsistent state" until it gets one -- unless we return
// VFW_S_CANT_CUE here!)

STDMETHODIMP
CRtpSourceFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));

    *State = m_State;
    if (m_State == State_Paused)
    {
      return VFW_S_CANT_CUE;
    }

    return S_OK;        
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IBaseFilter implemented methods                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRtpSourceFilter::QueryVendorInfo(
    LPWSTR * ppVendorInfo
    )

/*++

Routine Description:

    Returns a vendor information string.  

Arguments:

    ppVendorInfo - Pointer to a string containing vendor information.

Return Values:

    Returns an HRESULT value. 

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpSourceFilter::QueryVendorInfo")
        ));

    // validate pointer
    CheckPointer(ppVendorInfo,E_POINTER);

    // allocate the description string
    *ppVendorInfo = (LPWSTR)CoTaskMemAlloc(
                                (lstrlenW(g_VendorInfo)+1) * sizeof(WCHAR)
                                );

    // validate pointer
    if (*ppVendorInfo == NULL) {
    
        TraceDebug((
            TRACE_ERROR, 
            TRACE_ALWAYS, 
            TEXT("Could not allocate vendor info")
            ));

        return E_OUTOFMEMORY; // bail...
    }
    
    // copy vendor description string
    lstrcpyW(*ppVendorInfo,g_VendorInfo);            

    return S_OK;    
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IPersistStream implemented methods                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRtpSourceFilter::GetClassID(
    CLSID *pClsid
    )

/*++

Routine Description:

    Retrieves the class identifier for this filter. 

Arguments:

    pClsid - Pointer to a CLSID structure.  

Return Values:

    Returns an HRESULT value.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpSourceFilter::GetClassID")
        ));

    // transfer filter class id
    *pClsid = CLSID_RTPSourceFilter;

    return S_OK;
}


// ZCS: 6-22-97: copied this from the Demux filter code and modified it...
//
//  Name    : WriteEntry
//  Purpose : A macro that implements the stuff we do to write
//            a property of this filter to its persistent stream.
//  Context : Used in WriteToStream() to improve readability.
//  Returns : Will only return if an error is detected.
//  Params  : 
//      Entry       Pointer to a buffer containing the value to write.
//      InSize      Integer indicating the length of the buffer
//      OutSize     Integer to store the written length.
//      Description Char string used to describe the entry.
//  Notes   : 
#define WriteEntry(Entry, InSize, OutSize, Description) \
  { TraceDebug((TRACE_TRACE, 4, TEXT("CRtpSourceFilter::WriteToStream: Writing %s"), Description)); \
    hr = pStream->Write(Entry, InSize, &OutSize); \
    if (FAILED(hr)) { \
        TraceDebug((TRACE_ERROR, 2, TEXT("CRtpSourceFilter::WriteToStream: Error 0x%08x writing %s"), hr, Description)); \
        return hr; \
    } else if (OutSize != InSize) { \
        TraceDebug((TRACE_ERROR, 2,  \
                TEXT("CRtpSourceFilter::WriteToStream: Too few (%d/%d) bytes written for %s"), \
                uBytesWritten, sizeof(int), Description)); \
        return E_INVALIDARG; \
    } /* if */ }

HRESULT 
CRtpSourceFilter::WriteToStream(
    IStream *pStream
    )

/*++

Routine Description:

    Writes the filter's data to the given stream. 

Arguments:

    pStream - Pointer to an IStream to write the filter's data to. 

Return Values:

    Returns an HRESULT value.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpSourceFilter::WriteToStream")
        ));

    // validate pointer
    CheckPointer(pStream,E_POINTER);

    // obtain lock to this object
    CAutoLock LockThis(pStateLock());

    //
    // Rest of this function added 6-22-97 by ZCS
    //

    HRESULT  hr; // used in the WriteEntry macro
    ULONG    uBytesWritten = 0;
    DWORD    dwRtpAddr;
    WORD     wRtpPort;
    DWORD    dwMulticastScope;
    DWORD    dwQOSstate;
    DWORD    dwMCLoopBack;

    // get the RTP session object so we can see the address, port, scope
    CRtpSession *pCRtpSession;
    ASSERT(m_iPins == 1);
    EXECUTE_ASSERT(SUCCEEDED(((CRtpOutputPin *) *m_paStreams)->GetSession(&pCRtpSession)));

    // retrieve the address of the rtp stream object
    // for a receiver, local port matters
    EXECUTE_ASSERT(SUCCEEDED(pCRtpSession->GetAddress(&wRtpPort,
                                                      NULL,
                                                      &dwRtpAddr)));
    // retrieve multicast scope of rtp stream object
    EXECUTE_ASSERT(SUCCEEDED(pCRtpSession->GetMulticastScope(&dwMulticastScope)));
    // retrieve QOS state of rtp stream object
    EXECUTE_ASSERT(SUCCEEDED(pCRtpSession->GetQOSstate(&dwQOSstate)));

    // retrieve Multicast Loopback state of rtp stream object
    EXECUTE_ASSERT(SUCCEEDED(pCRtpSession->GetMulticastLoopBack(&dwMCLoopBack)));

    // write RTP address/port and multicast to the PersistStream
    WriteEntry(&dwRtpAddr, sizeof(dwRtpAddr), uBytesWritten,
               "RTP address");
    WriteEntry(&wRtpPort, sizeof(wRtpPort), uBytesWritten,
               "RTP port");

    WriteEntry(&dwMulticastScope, sizeof(dwMulticastScope), uBytesWritten, "multicast scope");
    WriteEntry(&dwQOSstate, sizeof(dwQOSstate), uBytesWritten, "QOS state");
    WriteEntry(&dwMCLoopBack, sizeof(dwMCLoopBack), uBytesWritten, "Multicast Loopback state");

    return S_OK;
}


// ZCS: 6-22-97: copied this from the Demux filter code and modified it...
//
//  Name    : ReadEntry
//  Purpose : A macro that implements the stuff we do to read
//            a property of this filter from its persistent stream.
//  Context : Used in ReadFromStream() to improve readability.
//  Returns : Will only return if an error is detected.
//  Params  : 
//      Entry       Pointer to a buffer containing the value to read.
//      InSize      Integer indicating the length of the buffer
//      OutSize     Integer to store the written length.
//      Description Char string used to describe the entry.
//  Notes   : 

HRESULT ReadEntry(IStream *pStream, void *Entry,
                  DWORD InSize, DWORD *pOutSize, char *Description)
{
    HRESULT hr;
    
    TraceDebug((TRACE_TRACE, 4,
            TEXT("CRtpSourceFilter::ReadFromStream: Reading %s"),
            Description));
    
    hr = pStream->Read(Entry, InSize, pOutSize);
    
    if (FAILED(hr)) {
        TraceDebug((TRACE_ERROR, 2,
                TEXT("CRtpSourceFilter::ReadFromStream: "
                     "Error 0x%08x reading %s"),
                hr, Description));
        return hr;
    } else if (*pOutSize != InSize) {
        TraceDebug((TRACE_ERROR, 2,
                TEXT("CRtpSourceFilter::ReadFromStream: "
                     "Too few (%d/%d) bytes read for %s"),
                *pOutSize, InSize, Description));
        return E_INVALIDARG;
    }

    return(S_OK);
}

HRESULT ReadEntry(IStream *pStream, void *Entry,
                  DWORD InSize, DWORD *pOutSize, char *Description);

HRESULT 
CRtpSourceFilter::ReadFromStream(
    IStream *pStream
    )

/*++

Routine Description:

    Reads the filter's data from the given stream. 

Arguments:

    pStream - Pointer to an IStream to read the filter's data from. 

Return Values:

    Returns an HRESULT value.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpSourceFilter::ReadFromStream")
        ));

    // validate pointer
    CheckPointer(pStream,E_POINTER);

    // obtain lock to this object
    CAutoLock LockThis(pStateLock());

    //
    // Rest of this function added 6-22-97 by ZCS based mostly on
    // Don Ryan's property page code...
    //

    HRESULT     hr;
    DWORD       uBytesWritten = 0;
    DWORD       dwRtpAddr;
    WORD        wRtpPort;
    DWORD       RtpScope;
    DWORD       QOSstate;
    DWORD       MCLoopBack;

    // get the RTP session object so we can see the address, port, scope
    CRtpSession *pCRtpSession = NULL;
    ASSERT(m_iPins == 1);

//  hr = ((CRtpOutputPin *) *m_paStreams)->GetSession(&pCRtpSession);
//  if (FAILED(hr)) {
//      pCRtpSession = NULL;
//  }
//  ASSERT(SUCCEEDED(hr));
    EXECUTE_ASSERT(SUCCEEDED(((CRtpOutputPin *) *m_paStreams)->
                             GetSession(&pCRtpSession)));
    ASSERT(!IsBadReadPtr(pCRtpSession, sizeof(pCRtpSession)));
    // retrieve RTP address and port from stream
    hr = ReadEntry(pStream, &dwRtpAddr, sizeof(dwRtpAddr), &uBytesWritten,
                   "RTP address");
    if (FAILED(hr)) return(hr);
    
    hr = ReadEntry(pStream, &wRtpPort, sizeof(wRtpPort), &uBytesWritten,
                   "RTP address");
    if (FAILED(hr)) return(hr);
    
    // attempt to modify the rtp address
    // in unicast, the remote port is what matters for a sender
    // in multicast, they have to be the same, SetAddress takes care
    hr = pCRtpSession->SetAddress(wRtpPort, wRtpPort, dwRtpAddr);

    // validate
    if (FAILED(hr)) {
        
        TraceDebug((
            TRACE_ERROR, 
            TRACE_ALWAYS, 
            TEXT("IRTPStream::SetAddress returns 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    // retrieve multicast scope from stream
    ReadEntry(pStream, &RtpScope, sizeof(RtpScope), &uBytesWritten,
               "multicast scope");

    // attempt to modify the scope
    hr = pCRtpSession->SetMulticastScope(RtpScope);

    // validate
    if (FAILED(hr)) {
        
        TraceDebug((
            TRACE_ERROR, 
            TRACE_ALWAYS, 
            TEXT("IRTPStream::SetScope returns 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    // retrieve QOS state from stream
    ReadEntry(pStream, &QOSstate, sizeof(QOSstate), &uBytesWritten,
               "QOS state");

    // attempt to modify the QOS state
    hr = pCRtpSession->SetQOSstate(QOSstate);

    // validate
    if (FAILED(hr)) {
        
        TraceDebug((
                TRACE_ERROR, 
                TRACE_ALWAYS, 
                TEXT("IRTPStream::SetQOSstate returns 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    // retrieve Multicast Loopback state from stream
    ReadEntry(pStream, &MCLoopBack, sizeof(MCLoopBack), &uBytesWritten,
               "Multicast Loopback state");

    // attempt to modify the QOS state
    MCLoopBack = (MCLoopBack)? TRUE:FALSE;
    hr = pCRtpSession->SetMulticastLoopBack(MCLoopBack);

    // validate
    if (FAILED(hr)) {
        
        TraceDebug((
                TRACE_ERROR, 
                TRACE_ALWAYS, 
                TEXT("IRTPStream::SetMulticastLoopBack returns 0x%08lx"), hr
            ));

        return hr; // bail...
    }

    return S_OK;
}



int 
CRtpSourceFilter::SizeMax(
    )

/*++

Routine Description:

    Returns an interface and increments the reference count.

Arguments:

    riid - reference identifier. 

    ppv - pointer to the interface. 

Return Values:

    Returns a pointer to the interface.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpSourceFilter::SizeMax")
        ));

    // obtain lock to this object
    CAutoLock LockThis(pStateLock());

    //    
    // CODEWORK...
    //

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ISpecifyPropertyPages implemented methods                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRtpSourceFilter::GetPages(
    CAUUID * pPages
    )

/*++

Routine Description:

    Returns property class id associated with filter.

Arguments:

    pPages - pointer to received property page class id.

Return Values:

    Returns an HRESULT value.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_ALWAYS, 
        TEXT("CRtpSourceFilter::GetPages")
        ));

    // number of pages
    pPages->cElems = 1;
    
    // allocate space to place property page guid
    pPages->pElems = (GUID *)CoTaskMemAlloc(sizeof(GUID));

    // validate pointer
    if (pPages->pElems == NULL) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_ALWAYS, 
            TEXT("Could not allocate property page guid")
            ));

        return E_OUTOFMEMORY;
    }
    
    // transfer property page guid to caller
    *(pPages->pElems) = CLSID_RTPRenderFilterProperties;

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// INonDelegatingUnknown implemented methods                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CRtpSourceFilter::NonDelegatingQueryInterface(
    REFIID  riid, 
    void ** ppv
    )

/*++

Routine Description:

    Returns an interface and increments the reference count.

Arguments:

    riid - reference identifier. 

    ppv - pointer to the interface. 

Return Values:

    Returns a pointer to the interface.

--*/

{
#ifdef DEBUG_CRITICAL_PATH
    
    TraceDebug((
        TRACE_TRACE, 
        TRACE_CRITICAL, 
        TEXT("CRtpSourceFilter::NonDelegatingQueryInterface")
        ));

#endif // DEBUG_CRITICAL_PATH
    
    // validate pointer
    CheckPointer(ppv,E_POINTER);

    // obtain proper interface
    if (riid == IID_IPersistStream) {
        
        // return pointer to this object 
        return GetInterface((IPersistStream *)this, ppv);

    } else if (riid == IID_ISpecifyPropertyPages) {
        
        // return pointer to this object 
        return GetInterface((ISpecifyPropertyPages *)this, ppv);

    } else if (riid == IID_IRTPStream ||
               riid == IID_IRTCPStream ||
               riid == IID_IRTPParticipant) {

        // obtain pointer to default output pin object
        CRtpOutputPin * pRtpOutputPin = (CRtpOutputPin *)GetPin(0);

        // forward request to default pin object
        return pRtpOutputPin->NonDelegatingQueryInterface(riid, ppv);

    } else {

        // forward this request to the base object
        return CSource::NonDelegatingQueryInterface(riid, ppv);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\shared.h ===
/*********************************************************************
 *
 * Copyright (C) Microsoft Corporation, 1997 - 1999
 *
 * File: shared.h
 *
 * Abstract:
 *     Overrides some methods from CSourceStream and CAMThread to
 *     enable sharing one thread for all the graphs whose render
 *     does not block.
 *
 * History:
 *     11/06/97    Created by AndresVG
 *
 **********************************************************************/
#if !defined(_SHARED_H_)
#define      _SHARED_H_

class CSharedProc;
class CSharedSourceStream;

#define ENUM_COMMAND \
enum Command {CMD_INIT, CMD_PAUSE, CMD_RUN, CMD_STOP, CMD_EXIT, \
				  CMD_INIT_SHARED, CMD_EXIT_SHARED}

class CSharedProc
{
	int      m_iShareID;
	CCritSec m_cStateLock;
	CCritSec m_cCountLock;

	CAMEvent m_EventSend;
    CAMEvent m_EventComplete;
    DWORD    m_dwParam;
    DWORD    m_dwReturnVal;
	void    *m_pvContext;
	
	long     m_lSharedCount;     // Number of threads emulated

	HANDLE   m_hSharedThread;    // Shared thread handle
	DWORD    m_dwSharedThreadID; // Thread ID
	long     m_lSharedThreadClass;    // e.g. audio, video, ...
	long     m_lSharedThreadPriority; // Shared thread priority
	
	long     m_dwNumRun;         // Emulated threads running


	LIST_ENTRY       m_SharedList; // Shared list to be exported
	CRITICAL_SECTION m_SharedLock; // Atomise access to shared list
	
public:
	
	CSharedProc(int   iShareID,
				long  lThreadClass,
				long  lThreadPriority);

	~CSharedProc();

	CCritSec *pStateLock(void) { return &m_cStateLock; }

	CCritSec *pCountLock(void) { return &m_cCountLock; }
	
	static DWORD WINAPI InitialThreadProc(LPVOID pv);

	DWORD SharedThreadProc(LPVOID pv);

	// Return TRUE if created or already created
	// FALSE otherwise.
	BOOL CreateSharedProc(void *pv);

	// Return TRUE if thread was stoped,
	// FALSE if not or already stoped.
	BOOL CloseSharedProc();

	inline DWORD GetShareID() { return(m_iShareID); }
	
	ENUM_COMMAND;
	DWORD CallSharedWorker(Command dwParam, void *pvContext);

	void Reply(DWORD dw);

    inline DWORD GetRequestParam() const { return(m_dwParam); }

    inline void *GetRequestContext() const { return(m_pvContext); }

	inline HANDLE GetWaitObject() { return(m_EventSend); }

	
	inline HANDLE GetSharedThreadHandle() { return(m_hSharedThread); }
	
	inline long GetSharedThreadClass()
	{ return(m_lSharedThreadClass); }

	inline long GetSharedThreadPriority()
	{ return(m_lSharedThreadPriority); }

	inline DWORD GetSharedThreadID() { return(m_dwSharedThreadID); }

	
	inline long GetSharedCount() { return(m_lSharedCount); }

	inline int GetNumRun() { return(m_dwNumRun); }

	inline int IncNumRun()
	{
		InterlockedIncrement(&m_dwNumRun);
		return(m_dwNumRun);
	}

	inline int DecNumRun()
	{
		InterlockedDecrement(&m_dwNumRun);
		return(m_dwNumRun);
	}

	inline  LIST_ENTRY *GetSharedList() { return(&m_SharedList); }
	
	inline CRITICAL_SECTION *GetSharedLock() { return(&m_SharedLock); }

	BOOL AddShared(void *pv);

	BOOL DelShared(void *pv);
};

class CSharedSourceStream : public CSourceStream
{
	DWORD m_fReceiveCanBlock;
	long  m_lSharedSourceClass;
	long  m_lSharedSourcePriority;
	
protected:
	CSharedProc *m_pCSharedProc;

public:
	
	CSharedSourceStream(TCHAR *pObjectName,
						HRESULT *phr,
						CSource *pms,
						LPCWSTR pName);
	
    ~CSharedSourceStream();

	// Override CSourceStream::Active()
    // Actually it contains the same code, but
	// it's needed here to allow the excution of
	// Create() that overrides CAMThread::Create()
	HRESULT Active();

	// Override CSourceStream::Inactive()
    // Actually it contains the same code, but
	// it's needed here to allow the excution of
	// Close() that overrides CAMThread::Close()
    HRESULT Inactive();

	// Override CAMThread::Create()
    // Starts up the worker thread if ReceiveCanBlock,
	// otherwise starts the SharedThreadProc if not started
	// yet, and pass to it the handles (Events + Free Buffers) 
	BOOL Create();

	// Override CAMThread::Close()
	// Closes the worker thread handle if was ReceiveCanBlock,
	// otherwise signals the SharedThreadProc that one set
	// of handles (a stream) is leaving the scene.
	void Close();

	inline CSharedProc *GetSharedProcObject() { return (m_pCSharedProc); }
	
	int IncNumRun()
	{
		if (!m_pCSharedProc)
			return(-1);
		
		m_pCSharedProc->IncNumRun();
		return(m_pCSharedProc->GetNumRun());
	}

	int DecNumRun()
	{
		if (!m_pCSharedProc)
			return(-1);
		
		m_pCSharedProc->DecNumRun();
		return(m_pCSharedProc->GetNumRun());
	}

	long GetSharedThreadPriority()
	{
		if (!m_pCSharedProc)
			return(THREAD_PRIORITY_LOWEST);

		return(m_pCSharedProc->GetSharedThreadPriority());
	}

	inline CSharedSourceStream *GetContext() { return(this); }
	
	LIST_ENTRY *GetSharedList()
	{
		if (m_pCSharedProc)
			return(m_pCSharedProc->GetSharedList());
		else
			return(NULL);
	}
	
	CRITICAL_SECTION *GetSharedLock()
	{
		if (m_pCSharedProc)
			return(m_pCSharedProc->GetSharedLock());
		else
			return(NULL);
	}

	// Overrided method from CAMThread. We can not check any more
	// against the per source thread, but the shared one.
	BOOL ThreadExists(void) const;

	ENUM_COMMAND;

	// Overrided method from CAMThread.
	DWORD CallWorker(Command dwParam)
	{
		if (m_pCSharedProc)
			return(m_pCSharedProc->CallSharedWorker(
					(CSharedProc::Command)dwParam, this));

		return(-1);
	}
	
	HRESULT Init(void) { return CallWorker(CMD_INIT); }
    HRESULT Exit(void) { return CallWorker(CMD_EXIT); }
    HRESULT Run(void) { return CallWorker(CMD_RUN); }
    HRESULT Pause(void) { return CallWorker(CMD_PAUSE); }
    HRESULT Stop(void) { return CallWorker(CMD_STOP); }

	// Overrided method from CAMThread.
	void Reply(DWORD dw) {
		if (m_pCSharedProc)
			m_pCSharedProc->Reply(dw);
	}

	/************************************************************
	 * This virtual methods have to be provided by the
	 * derived class who knows what to do in its specific
	 * kind of filter.
	 ************************************************************/

	virtual HRESULT ProcessIO(SAMPLE_LIST_ENTRY *pSLE) = 0;
	virtual HRESULT ProcessCmd(Command Request) = 0;
	virtual HRESULT GetClassPriority(long *plClass, long *plPriority) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\socket.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    socket.cpp

Abstract:

    Implementation of CSocketManager class.

Environment:

    User Mode - Win32

Revision History:

    10-Jan-1997 DonRyan
        Created.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"

#define SOCKET_ISRX 0x01
#define SOCKET_ISTX 0x02
#define SOCKET_ISRXTX (SOCKET_ISRX | SOCKET_ISTX)

#define DBG_DWKIND 1

const char g_sPolicyLocator[] = "APP=MICROSOFT TAPI,VER=3.0";
const char g_sAppName[]       = "MICROSOFT TAPI";

#define MAX_PROVIDERSPECIFIC_BUFFER \
                             (sizeof(RSVP_RESERVE_INFO) + \
                             sizeof(FLOWDESCRIPTOR) + \
                             (sizeof(RSVP_FILTERSPEC)*MAX_FILTERS) + \
                             sizeof(RSVP_POLICY_INFO) + \
                             RSVP_POLICY_HDR_LEN + \
                             (IDPE_ATTR_HDR_LEN * 2) + \
                             MAX_QOS_NAME + \
                             sizeof(g_sPolicyLocator) + 4 + \
                             sizeof(g_sAppName) + 4 + \
                             sizeof(",SAPP=UNKNOWN,SAPP="))
                                     
                                     
DWORD AddQosAppID(
        IN OUT  char       *pAppIdBuf,
        IN      WORD        wBufLen,
        IN      const char *szPolicyLocator,
        IN      const char *szAppName,
        IN      const char *szAppClass,
        IN      char       *szQosName
    );
                                     
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSocketManager implementation                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CSocketManager::CSocketManager(
    )

/*++

Routine Description:

    Constructor for CSocketManager class.

Arguments:

    None.

Return Values:

    Returns an HRESULT value. 

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_DEVELOP2, 
        TEXT("CSocketManager::CSocketManager")
        ));
        
    // initialize linked list of sockets        
    InitializeListHead(&m_SharedSockets);
}


CSocketManager::~CSocketManager(
    )

/*++

Routine Description:

    Destructor for CSocketManager class.

Arguments:

    None.

Return Values:

    Returns an HRESULT value. 

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_DEVELOP2, 
        TEXT("CSocketManager::~CSocketManager")
        ));
        
    // check for unaccounted for sockets
    if (!IsListEmpty(&m_SharedSockets)) {

        TraceDebug((
            TRACE_ERROR, 
            TRACE_DEVELOP, 
            TEXT("CSocketManager::~CSocketManager: Shared sockets still open")
            ));
    }
}


DWORD
CSocketManager::GetSocket(
    SOCKET              *pSocket,
    struct sockaddr_in  *pAddr, 
    struct sockaddr_in  *pLocalAddr,
    DWORD                dwScope,
    DWORD                dwKind,
    WSAPROTOCOL_INFO    *pProtocolInfo 
    )

/*++

Routine Description:

    Create a socket from an address structure.

Arguments:

    pSocket - pointer to socket which will be filled in.

    pAddr -  pointer to destination address structure.

    pLocalAddr - pointer to local address structure
    
    dwScope - multicast scope used for sending.    

    dwKind - if true, socket is just for sending.

    pProtocolInfo - specify the protocol to be used

Return Values:

    Returns error code from WSAGetLastError.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_DEVELOP2, 
        TEXT("CSocketManager::GetSocket")
        ));
        
    // object lock to this object
    CAutoLock LockThis(pStateLock());
    
    // initialize
    DWORD dwErr = NOERROR;

    BOOL fReuse;
    
    /////////////////////////////////////////////////////
    // If a protocol has been specified, use WSASocket(),
    // otherwise use socket()
    /////////////////////////////////////////////////////

    SOCKET NewSocket;

    int Flags = WSA_FLAG_OVERLAPPED;

    if (pProtocolInfo) {

        if (IS_MULTICAST(pAddr->sin_addr.s_addr))
            Flags |= WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_MULTIPOINT_D_LEAF;
    }
    
    NewSocket = WSASocket(AF_INET, SOCK_DGRAM, 0, pProtocolInfo, 0, Flags);
    
    // validate socket handle returned
    if (NewSocket == INVALID_SOCKET) {
        
        // obtain last error    
        dwErr = WSAGetLastError();

        TraceDebug((
            TRACE_ERROR, 
            TRACE_DEVELOP, 
            TEXT("CSocketManager::GetSocket: failed %d"), 
            dwErr
            ));

        goto cleanup; // bail...
    }

    struct sockaddr_in LocalAddr;

    // initialize 
    LocalAddr.sin_family = AF_INET;
    LocalAddr.sin_addr   = pLocalAddr->sin_addr;
    //INADDR_ANY;

    // determine whether we need to specify particular port
    LocalAddr.sin_port =
        (dwKind & SOCKET_MASK_RECV)? pAddr->sin_port : htons(0);

    // set socket options required before binding
    //if (IS_MULTICAST(pAddr->sin_addr.s_addr)) {

    fReuse = TRUE;

    if (setsockopt(
            NewSocket,
            SOL_SOCKET,
            SO_REUSEADDR,
            (PCHAR)&fReuse,
            sizeof(fReuse)
        ) == SOCKET_ERROR) {

        // obtain last error
        dwErr = WSAGetLastError();
        
        TraceDebug((
                TRACE_ERROR,
                TRACE_DEVELOP,
                TEXT("Could not modify REUSEADDR: %d"),
                dwErr
            ));
        
        goto cleanup; // bail...
    }

    // bind rtp socket to the local address specified
    if (bind(NewSocket, (sockaddr *)&LocalAddr, sizeof(LocalAddr))) {

        // obtain last error    
        dwErr = WSAGetLastError();

        TraceDebug((
            TRACE_ERROR, 
            TRACE_DEVELOP, 
            TEXT("bind returned %d"), 
            dwErr
            ));

        goto cleanup; // bail...
    }

    // set socket options required after binding

    // receiving?
    if ( (dwKind & SOCKET_MASK_RECV) ) {

        if (IS_MULTICAST(pAddr->sin_addr.s_addr)) {

            struct ip_mreq mreq;

            // initialize multicast group address
            mreq.imr_multiaddr.s_addr = pAddr->sin_addr.s_addr;
            mreq.imr_interface.s_addr = INADDR_ANY;
            
            // join multicast group 
            if(setsockopt(NewSocket,
                          IPPROTO_IP, 
                          IP_ADD_MEMBERSHIP,
                          (char*)&mreq, 
                          sizeof(mreq)
                ) == SOCKET_ERROR) {
                
                // obtain last error    
                dwErr = WSAGetLastError();
                
                TraceDebug((
                        TRACE_ERROR, 
                        TRACE_DEVELOP, 
                        TEXT("Could not join multicast group %d"), 
                        dwErr
                    ));
                
                goto cleanup; // bail...
            }
        }
    }

    // transmitting?
    if ( (dwKind & SOCKET_MASK_SEND) ) {
            
        // set ttl
        if (setsockopt( 
                NewSocket, 
                IPPROTO_IP, 
                IP_MULTICAST_TTL,
                (PCHAR)&dwScope,
                sizeof(dwScope)
            ) == SOCKET_ERROR) {
            
            // obtain last error    
            dwErr = WSAGetLastError();
            
            TraceDebug((
                    TRACE_ERROR, 
                    TRACE_DEVELOP, 
                    TEXT("Could not modify time-to-live %d"), 
                    dwErr 
                ));
            
            goto cleanup; // bail...
        }
    }

    // copy new socket
    *pSocket = NewSocket;

    return NOERROR;

cleanup:

    // see if we created socket
    if (NewSocket != INVALID_SOCKET) {

        // make sure socket is closed
        if (closesocket(NewSocket)) {

            TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("closesocket returned %d"), 
                WSAGetLastError()
                ));
        }
    }

    return dwErr;
}


DWORD
CSocketManager::ReleaseSocket(
    SOCKET Socket
    )

/*++

Routine Description:

    Releases a socket.

Arguments:

    Socket - socket to release.

Return Values:

    Returns error code from WSAGetLastError.

--*/

{
    TraceDebug((
        TRACE_TRACE, 
        TRACE_DEVELOP2, 
        TEXT("CSocketManager::ReleaseSocket")
        ));
        
    // object lock to this object
    CAutoLock LockThis(pStateLock());
    
    DWORD dwErr = NOERROR;

    // see if we created socket
    if (Socket != INVALID_SOCKET) {

        // make sure socket closed
        if (closesocket(Socket)) {

            // retrieve error code
            dwErr = WSAGetLastError();

            TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP2, 
                TEXT("closesocket returned %d"), 
                dwErr                
                ));
        }
    }

    return dwErr;
}



/* Sockets are shared IF the source and destination address/port
 * match, AND the cookie matches AND the QOS state matches.
 *
 * They are matched provided the max number of receiver(s) and/or
 * sender(s) hasn't been reached.
 *
 *           local    remote   cookie   local Addr  remote Addr  QOS enabled
 *           =======  =======  =======  =========== ===========  =========
 * Receiver: RlocRTP     0     RCookie  RlocAddr    RremAddr     RQOSstate
 * Sender:      0     SremRTP  SCookie  SlocAddr    SremAddr     SQOSstate
 *
 * The RTP sockets for sender and receiver will be matched provided
 * ALL the colums match, the wildcard value (0) matches anything.
 *
 * The RTCP sockets will be matched following the same rules, except
 * that in local and remote port, I will have the RTCP ports:
 *
 *           local    remote   cookie   local Addr  remote Addr  QOS enabled
 *           =======  =======  =======  =========== ===========  =========
 * Receiver: RlocRTCP RremRTCP RCookie  RlocAddr    RremAddr     RQOSstate
 * Sender:   SlocRTCP SremRTCP SCookie  SlocAddr    SremAddr     SQOSstate
 *
 * The cookie is constructed using the local and remote RTCP ports 
 *
 * For a sender and a receiver that should belong to the same RTP/RTCP
 * session, the session may end having 2 or 3 sockets depending on the
 * order on which the receiver and sender are started, and depending
 * on the use of wildcard ports (port 0 is the wildcard value).
 *
 * The different scenarios are as follow:
 *
 * 1. If wildcard is not used, and since the beggining both, receiver
 * and sender, receive the right local and remote ports (which will be
 * the same for the receiver and sender), then the sockets will be
 * shared no matter the order on which the receiver and sender
 * starts. The RTP/RTCP session will have 2 sockets.
 *
 * 2. Wildcard ports are used, i.e. the sender specify a local port 0,
 * and the receiver specifies a remote port 0, and the sender starts
 * first. In this case, as the socket needs to be bound (QOS), the
 * local port is system assigned, when the receiver is started,
 * everything will match except the local ports, so a new socket will
 * be created. The RTP/RTCP session will have 3 sockets.
 *
 * 3. Wildcard ports are used, i.e. the sender specify a local port 0,
 * and the receiver specifies a remote port 0, and the receiver starts
 * first. In this case, when the sender starts with a wildcard local
 * port, everything will match and the socket will be shared for the
 * receiver and sender. The RTP/RTCP session will have 2 sockets.
 *
 * The RTP/RTCP session is shared based on the 3 sockets (RTPRecv,
 * RTPSend, RTCP), in some cases of course RTPRecv == RTPSend.  */

DWORD
CSocketManager::GetSharedSocket(
    CShSocket          **ppCShSocket,
    long                *pMaxShare,
    DWORD                cookie,
    DWORD               *pAddr, 
    WORD                *pPort, 
    DWORD                dwScope,
    DWORD                dwKind,
    WSAPROTOCOL_INFO    *pProtocolInfo,
    DWORD                dwMaxFilters,
    CRtpSession         *pCRtpSession
    )
/*++

Routine Description:

    Create a shared socket from an address structure.

Arguments:

    pAddr -  pointer to local/remote address.

    pPort -  pointer to local/remote port.

    pSocket - pointer to socket which will be filled in.

    dwScope - multicast scope used for sending.    

Return Values:

    Returns error code from WSAGetLastError.

--*/
{
    HRESULT hr;

    if (!ppCShSocket || !pAddr[LOCAL] || !pAddr[REMOTE]) {
        TraceDebug((
                TRACE_TRACE, 
                TRACE_DEVELOP, 
                TEXT("CSocketManager::GetSharedSocket: "
                     "failed: NULL pointer")
            ));
        return(E_POINTER);
    }

    char remaddr[RTPNTOASIZE];
    char locaddr[RTPNTOASIZE];
    
    RtpNtoA(pAddr[LOCAL], locaddr);
    RtpNtoA(pAddr[REMOTE], remaddr);
    
    TraceRetail((
        TRACE_TRACE, 
        TRACE_DEVELOP, 
        TEXT("CSocketManager::GetSharedSocket: TTL:%d "
             "Local:%s/%d Remote:%s/%d Get(%d,%d), "
             "Max(%d,%d), Cook(%d,%d), Ini(%s,%s), QOS(%d,%d)"),
        dwScope,
        locaddr, ntohs(pPort[LOCAL]),
        remaddr, ntohs(pPort[REMOTE]),
        (dwKind & SOCKET_MASK_RECV)? 1:0,
        (dwKind & SOCKET_MASK_SEND)? 1:0,
        pMaxShare[0], pMaxShare[1],
        ntohs((WORD)(cookie & 0xffff)), ntohs((WORD)(cookie >> 16)),
        (dwKind & SOCKET_MASK_INIT_RECV)? "R":"-",
        (dwKind & SOCKET_MASK_INIT_SEND)? "S":"-",
        ((dwKind & SOCKET_MASK_QOS_SES) != 0),
        ((dwKind & SOCKET_MASK_QOS_RQ) != 0)
        ));
    
    if ( ((struct in_addr *)&pAddr[REMOTE])->s_addr == INADDR_ANY ) {
        // I may add a check against the local IP address(es)
        TraceRetail((
                TRACE_TRACE, 
                TRACE_DEVELOP, 
                TEXT("CSocketManager::GetSharedSocket: "
                     "failed: remote address == INADDR_ANY")
            ));
        return(E_INVALIDARG);
    }

    *ppCShSocket = NULL;

    if (!(dwKind & SOCKET_MASK_RS)) {
        TraceDebug((
                TRACE_TRACE, 
                TRACE_DEVELOP, 
                TEXT("CSocketManager::GetSharedSocket: "
                     "failed: no kind specified")
            ));
        return(E_INVALIDARG);
    }
    
    // object lock to this object
    CAutoLock LockThis(pStateLock());
    
    PLIST_ENTRY pLE;
    CShSocket *pCShSocket;
    
    BOOL found = FALSE;

    int count;
    // loop through shared sockets
    for(pLE = m_SharedSockets.Flink, count = 0;
        !found && (pLE != &m_SharedSockets);
        pLE = pLE->Flink, count++) {

        // obtain shared socket entry from list entry
        pCShSocket = CONTAINING_RECORD(pLE, CShSocket, Link);

        // check cookie
        if (cookie != pCShSocket->GetCookie())
            continue; // do not match
        
        // find out if local and remote address/port match with
        // current, take into account wildcard values
        // (in this case that is 0)
        DWORD match = 0;
        DWORD match_bit = 0x1;
        
        for(DWORD p = LOCAL; p <= REMOTE; p++) {

            // port
            if ( (p == REMOTE) && (dwKind & SOCKET_MASK_RTCPMATCH) ) {
                match |= match_bit; /* force remote port to match
                                     * (used for RTCP) */
            } else {
                if (!pCShSocket->GetPort(p) || !pPort[p])
                    match |= match_bit; // wildcard port match
                else if (pCShSocket->GetPort(p) == pPort[p])
                    match |= match_bit; // same port match
                else
                    break; // doesn't match, no need to continue
            }
            match_bit <<= 1;

            // address
            if (!pCShSocket->GetAddress(p) || !pAddr[p])
                match |= match_bit; // wildcard address match
            else if (pCShSocket->GetAddress(p) == pAddr[p])
                match |= match_bit; // same address match
            else
                break; // doesn't match, no need to continue
            match_bit <<= 1;
        }

        if (match == 0xf) {
            // local and remote address/port DO match
            found = TRUE;
            
            for(DWORD k = SOCKET_FIRST; k < SOCKET_LAST; k++) {
                if ( ( (dwKind & SOCKET_MASK(k)) &&

                       ( (pCShSocket->GetRefCount(k) >= pMaxShare[k]) ||
                         (pCShSocket->GetRefCount(k) >=
                          pCShSocket->GetMaxCount(k)) ) )

                     || 

                     ((dwKind & SOCKET_MASK_QOS_SES) !=
                      (pCShSocket->GetKind() & SOCKET_MASK_QOS_SES)) ) {

                    // This kind (recv/send) already exists
#if defined(DEBUG)
                    DWORD addr;

                    addr = pCShSocket->GetAddress(LOCAL);
                    RtpNtoA(addr, locaddr);

                    addr = pCShSocket->GetAddress(REMOTE);
                    RtpNtoA(addr, remaddr);

                    TraceDebug((
                            TRACE_TRACE, 
                            TRACE_DEVELOP, 
                            TEXT("CSocketManager::GetSharedSocket: "
                                 "Full socket %d:%s/%d-%s/%d "
                                 "Cook(%d, %d), "
                                 "Cur(%d,%d), Lim(%d,%d), "
                                 "Ini(%s,%s), "
                                 "QOS(%d,%d), Ctx(0x%X,0x%X)"
                                 ),
                            pCShSocket->GetShSocket(),
                            locaddr,
                            ntohs(pCShSocket->GetPort(LOCAL)),
                            remaddr,
                            ntohs(pCShSocket->GetPort(REMOTE)),
                            ntohs((WORD)(cookie & 0xffff)),
                            ntohs((WORD)(cookie >> 16)),
                            pCShSocket->GetRefCount(SOCKET_RECV),
                            pCShSocket->GetRefCount(SOCKET_SEND),
                            pCShSocket->GetMaxCount(SOCKET_RECV),
                            pCShSocket->GetMaxCount(SOCKET_SEND),
                            (pCShSocket->GetKind() & SOCKET_MASK_INIT_RECV) ?
                            "R":"-",
                            (pCShSocket->GetKind() & SOCKET_MASK_INIT_SEND) ?
                            "S":"-",
                            pCShSocket->IsQOSSession(),
                            pCShSocket->IsQOSEnabled(),
                            pCShSocket->m_pCRtpSession[SOCKET_RECV],
                            pCShSocket->m_pCRtpSession[SOCKET_SEND]
                        ));
#endif
                    // If multicast, create a new socket,
                    // if unicast, fail!
                    // Actually do not fail in unicast either
                    
                    // In both cases create a new socket
                    found = FALSE;
                }
            }

            if (found) {

                // initialize wildcards to right value
                
                for(DWORD p = LOCAL; p <= REMOTE; p++) {
                    // wildcard port
                    if (!pCShSocket->GetPort(p)) {
                        pCShSocket->SetPort(p, pPort[p]);
                    }

                    // wildcard address
                    if (!pCShSocket->GetAddress(p)) {
                        pCShSocket->SetAddress(p, pAddr[p]); 
                    }
                }
                
                TraceDebug((
                        TRACE_TRACE, 
                        TRACE_DEVELOP, 
                        TEXT("CSocketManager::GetSharedSocket: "
                             "requested socket %d already created."),
                        pCShSocket->GetShSocket()
                    ));
            }
        }
    }

    if (!found) {

        // Allocate new shared socket structure
        pCShSocket = new CShSocket(pAddr[REMOTE],
                                   pMaxShare,
                                   pProtocolInfo,
                                   dwMaxFilters,
                                   &hr);
        if (!pCShSocket) {
            TraceRetail((
                    TRACE_ERROR, 
                    TRACE_DEVELOP, 
                    TEXT("CSocketManager::GetSharedSocket: "
                         "out of memory: %d"),
                    GetLastError()
                ));
            return(E_FAIL);
        } else if (FAILED(hr)) {
            TraceRetail((
                    TRACE_ERROR, 
                    TRACE_DEVELOP, 
                    TEXT("CSocketManager::GetSharedSocket: "
                         "failed: 0x%X"),
                    hr
                ));
            pCShSocket->CloseSocket();
            delete pCShSocket;
            return(E_FAIL);
        } else {
            TraceRetail((
                    TRACE_TRACE, 
                    TRACE_DEVELOP, 
                    TEXT("CSocketManager::GetSharedSocket: "
                         "New socket created: %d"),
                    pCShSocket->GetShSocket()
                ));
        }
        
        // Save local and remote address/port (including wildcards)
        for(DWORD p = LOCAL; p <= REMOTE; p++) {
            // port
            pCShSocket->SetPort(p, pPort[p]);

            // address
            pCShSocket->SetAddress(p, pAddr[p]); 
        }

        pCShSocket->SetCookie(cookie);
        
        // Insert to list of shared sockets
        InsertHeadList(&m_SharedSockets, &pCShSocket->Link);

        pCShSocket->SetKind(dwKind & SOCKET_MASK_QOS_SES);
        pCShSocket->SetKind(dwKind & SOCKET_MASK_QOS_RQ);
    }

    // Now some final socket options may be requiered

    int errorR = 0;
    
    // Set socket kind and add ref count for that kind
    if (dwKind & SOCKET_MASK_RECV) {
        pCShSocket->AddRefCount(SOCKET_RECV);
        pCShSocket->SetKind(SOCKET_MASK_RECV);
    }
    
    // Do this just once per socket per receiver
    if ( (dwKind & SOCKET_MASK_INIT_RECV) &&
         !pCShSocket->GetInit(SOCKET_MASK_INIT_RECV) ) {

        // Mark socket as initialized for RECV
        pCShSocket->SetInit(SOCKET_MASK_INIT_RECV);
        
        if (!errorR && !pCShSocket->GetInit(SOCKET_MASK_INIT_BIND)) {
            pCShSocket->SetInit(SOCKET_MASK_INIT_BIND);
            
            SOCKADDR_IN localaddr;
            ZeroMemory(&localaddr, sizeof(localaddr));
            SOCKET sock = pCShSocket->GetShSocket();
            DWORD addr;

            addr = pCShSocket->GetAddress(LOCAL);
            localaddr.sin_family = AF_INET;
            localaddr.sin_addr = *(struct in_addr *) &addr;
            localaddr.sin_port = pCShSocket->GetPort(LOCAL);
            
            // bind rtp socket to the local address specified
            if (bind(sock, (SOCKADDR *)&localaddr, sizeof(localaddr))) {

                // obtain last error    
                TraceRetail((
                        TRACE_ERROR, 
                        TRACE_DEVELOP, 
                        TEXT("CSocketManager::GetSharedSocket: "
                             "RECV bind(%d) port: %d failed: %d"), 
                        sock, ntohs(localaddr.sin_port), WSAGetLastError()
                    ));

                errorR++;
            } else if (!pCShSocket->GetPort(LOCAL)) {
                /* if local port was assigned by the system, we need
                 * to update its value, we don't want the wildcard (0)
                 * to remain, because if it does, the socket may be
                 * erroneously shared with another socket requesting
                 * an specific local port */
                int localaddrlen = sizeof(localaddr);
                
                if (!getsockname(sock,
                                 (struct sockaddr *)&localaddr,
                                 &localaddrlen)) {
                     pCShSocket->SetPort(LOCAL, localaddr.sin_port);
                }
            }
        }
        
        if (!errorR) {
            if (IS_MULTICAST(pAddr[REMOTE])) {
                // Join the group for receivers

                SOCKADDR_IN joinaddr;
                ZeroMemory(&joinaddr, sizeof(joinaddr));
                DWORD addr;

                addr = pCShSocket->GetAddress(REMOTE);
                joinaddr.sin_family = AF_INET;
                joinaddr.sin_addr = *(struct in_addr *) &addr;
                joinaddr.sin_port = pCShSocket->GetPort(REMOTE);

                if (WSAJoinLeaf(pCShSocket->GetShSocket(),
                                (const struct sockaddr *)&joinaddr,
                                sizeof(joinaddr),
                                NULL, NULL, NULL, NULL,
                                JL_RECEIVER_ONLY) == INVALID_SOCKET) {

                    errorR++;
                    
                    TraceRetail((
                            TRACE_ERROR, 
                            TRACE_DEVELOP, 
                            TEXT("CSocketManager::GetSharedSocket: "
                                 "WSAJoinLeaf(RECEIVER) failed: %d"),
                            WSAGetLastError()
                        ));
                    
                } else {
                    
                    TraceRetail((
                            TRACE_TRACE, 
                            TRACE_DEVELOP, 
                            TEXT("CSocketManager::GetSharedSocket: "
                                 "WSAJoinLeaf(RECEIVER) succeded")
                        ));
                }
            }
        }
    }
    
    int errorS = 0;
    
    // Set socket kind and add ref count for that kind
    if (dwKind & SOCKET_MASK_SEND) {
        pCShSocket->AddRefCount(SOCKET_SEND);
        pCShSocket->SetKind(SOCKET_MASK_SEND);
    }
    
    // Do this just once per socket per sender
    if ( (dwKind & SOCKET_MASK_INIT_SEND) &&
         !pCShSocket->GetInit(SOCKET_MASK_INIT_SEND) ) {

        // Mark socket as initialized for SEND
        pCShSocket->SetInit(SOCKET_MASK_INIT_SEND);

        if (!errorS && !pCShSocket->GetInit(SOCKET_MASK_INIT_BIND)) {

            pCShSocket->SetInit(SOCKET_MASK_INIT_BIND);
            
            SOCKADDR_IN localaddr;
            ZeroMemory(&localaddr, sizeof(localaddr));
            SOCKET sock = pCShSocket->GetShSocket();
            DWORD addr;

            addr = pCShSocket->GetAddress(LOCAL);
            localaddr.sin_family = AF_INET;
            localaddr.sin_addr = *(struct in_addr *) &addr;
            localaddr.sin_port = pCShSocket->GetPort(LOCAL);
            
            // bind rtp socket to the local address specified
            if (bind(sock, (SOCKADDR *)&localaddr, sizeof(localaddr))) {

                // obtain last error    
                TraceRetail((
                        TRACE_ERROR, 
                        TRACE_DEVELOP, 
                        TEXT("CSocketManager::GetSharedSocket: "
                             "SEND bind(%d) port:%d failed:%d"), 
                        sock, ntohs(localaddr.sin_port), WSAGetLastError()
                    ));

                errorS++;
            } else if (!pCShSocket->GetPort(LOCAL)) {
                /* if local port was assigned by the system, we need
                 * to update its value, we don't want the wildcard (0)
                 * to remain, because if it does, the socket may be
                 * erroneously shared with another socket requesting
                 * an specific local port */
                int localaddrlen = sizeof(localaddr);
                
                if (!getsockname(sock,
                                 (struct sockaddr *)&localaddr,
                                 &localaddrlen)) {
                     pCShSocket->SetPort(LOCAL, localaddr.sin_port);
                }
            }
        }

        // TTL for senders
        if (!errorS) {
            if (setsockopt( 
                    pCShSocket->GetShSocket(), 
                    IPPROTO_IP, 
                    IS_MULTICAST(pAddr[REMOTE])?
                    IP_MULTICAST_TTL : IP_TTL,
                    (PCHAR)&dwScope,
                    sizeof(dwScope)
                ) == SOCKET_ERROR) {

                DWORD dwError = WSAGetLastError();

                // Only Administrators can change TTL,
                // that is not a reason to fail altogether
                if (dwError != WSAEACCES)
                    errorS++;

                TraceRetail((
                        TRACE_ERROR, 
                        TRACE_DEVELOP, 
                        TEXT("CSocketManager::GetSharedSocket: "
                             "setsockopt(%s)=%d failed: %d"), 
                        IS_MULTICAST(pAddr[REMOTE])?
                        "IP_MULTICAST_TTL" : "IP_TTL",
                        dwScope,
                        dwError
                    ));
            }
        }

        if (!errorS) {
            if (IS_MULTICAST(pAddr[REMOTE])) {
                // Set multicast address

                SOCKADDR_IN joinaddr;
                ZeroMemory(&joinaddr, sizeof(joinaddr));
                DWORD addr;

                addr = pCShSocket->GetAddress(REMOTE);
                joinaddr.sin_family = AF_INET;
                joinaddr.sin_addr = *(struct in_addr *) &addr;
                joinaddr.sin_port = pCShSocket->GetPort(REMOTE);

                if (WSAJoinLeaf(pCShSocket->GetShSocket(),
                                (const struct sockaddr *)&joinaddr,
                                sizeof(joinaddr),
                                NULL, NULL, NULL, NULL,
                                JL_SENDER_ONLY) == INVALID_SOCKET) {

                    errorS++;

                    TraceRetail((
                            TRACE_ERROR, 
                            TRACE_DEVELOP, 
                            TEXT("CSocketManager::GetSharedSocket: "
                                 "WSAJoinLeaf(SENDER) failed: %d"),
                            WSAGetLastError()
                        ));
                } else {
                    TraceRetail((
                            TRACE_TRACE, 
                            TRACE_DEVELOP, 
                            TEXT("CSocketManager::GetSharedSocket: "
                                 "WSAJoinLeaf(SENDER) succeded")
                        ));
                }
            }
        }
    }

    if (pCRtpSession) {
        if (pCRtpSession->IsSender()) {
            pCShSocket->m_pCRtpSession[SOCKET_SEND] = pCRtpSession;
            pCShSocket->m_pCRtpSession2[SOCKET_SEND] = pCRtpSession;
        } else {
            pCShSocket->m_pCRtpSession[SOCKET_RECV] = pCRtpSession;
            pCShSocket->m_pCRtpSession2[SOCKET_RECV] = pCRtpSession;
        }
    }
    
    ///////////////////////////////////////////////
#if defined(DEBUG)  
    {
        TraceDebug((
                TRACE_TRACE, 
                TRACE_DEVELOP2, 
                TEXT("CSocketManager::GetSharedSocket: "
                     "Searched on %d elements =================="),
                count
            ));

        char Str[512];
        CShSocket *pCShSocket;
        
        for(pLE = m_SharedSockets.Flink;
            pLE != &m_SharedSockets;
            pLE = pLE->Flink) {

            DWORD addr;

            // obtain shared socket entry from list entry
            pCShSocket = CONTAINING_RECORD(pLE, CShSocket, Link);

            addr = pCShSocket->GetAddress(LOCAL);
            RtpNtoA(addr, locaddr);

            addr = pCShSocket->GetAddress(REMOTE);
            RtpNtoA(addr, remaddr);

            wsprintf(Str,
                     "  {%d:%s/%05d-%s/%05d Cur(%d,%d), Max(%d,%d), "
                     "Cook(%05d,%05d), "
                     "Ini(%s,%s), QOS(%d,%d), Ctx(0x%X,0x%X)}",
                     pCShSocket->GetShSocket(),
                     locaddr, ntohs(pCShSocket->GetPort(LOCAL)),
                     remaddr, ntohs(pCShSocket->GetPort(REMOTE)),
                     pCShSocket->GetRefCount(0),
                     pCShSocket->GetRefCount(1),
                     pCShSocket->GetMaxCount(0),
                     pCShSocket->GetMaxCount(1),
                     ntohs((WORD)(pCShSocket->GetCookie() & 0xffff)),
                     ntohs((WORD)(pCShSocket->GetCookie() >> 16)),
                     (pCShSocket->GetKind() & SOCKET_MASK_INIT_RECV)? "R":"-",
                     (pCShSocket->GetKind() & SOCKET_MASK_INIT_SEND)? "S":"-",
                     pCShSocket->IsQOSSession(),
                     pCShSocket->IsQOSEnabled(),
                     pCShSocket->m_pCRtpSession[SOCKET_RECV],
                     pCShSocket->m_pCRtpSession[SOCKET_SEND]
                );

            TraceDebug((
                    TRACE_TRACE, 
                    TRACE_DEVELOP, 
                    TEXT("%s"), Str
                ));
        }
    }
#endif
    ///////////////////////////////////////////////
    
    if (errorR)
        ReleaseSharedSocket(pCShSocket, SOCKET_MASK_RECV, pCRtpSession);

    if (errorS)
        ReleaseSharedSocket(pCShSocket, SOCKET_MASK_SEND, pCRtpSession);

    if (errorR + errorS)
        return(E_FAIL);

    *ppCShSocket = pCShSocket;
    return(NOERROR);
}


DWORD 
CSocketManager::ReleaseSharedSocket(CShSocket *pCShSocket, DWORD dwKind,
                                    CRtpSession *pCRtpSession)
/*++

Routine Description:

    Releases a shared socket (RTCP).

Arguments:

    Socket - shared socket to release.

Return Values:

    Returns error code from WSAGetLastError.

--*/
{
    CShSocket *pCShSocket2;
    PLIST_ENTRY pLE;

    CheckPointer(pCShSocket, E_POINTER);
    
    TraceRetail((
            TRACE_TRACE, 
            TRACE_DEVELOP, 
            TEXT("CSocketManager::ReleaseSharedSocket: %d"),
            pCShSocket->GetShSocket()
        ));
    
    // object lock to this object
    CAutoLock LockThis(pStateLock());

    PRTP_SESSION pRTPSession = (PRTP_SESSION)NULL;
    
    if (pCRtpSession->GetpRTPSession()) {
        // This code to debug the hang in RTCP
        pRTPSession = pCRtpSession->GetpRTPSession();
    }
    
    // obtain pointer to first 
    pLE = m_SharedSockets.Flink;

    // loop through shared sockets to make shure this exist
    while (pLE != &m_SharedSockets) {

        // obtain shared socket entry from list entry
        pCShSocket2 = CONTAINING_RECORD(pLE, CShSocket, Link);

        // check for matching socket
        if (pCShSocket == pCShSocket2) {

            SOCKET sock = pCShSocket->GetShSocket();
            DWORD mask = 0x1;
            
            if (pRTPSession) {
                for(DWORD s = SOCK_RECV; s <= SOCK_RTCP; s++) {
                    if (sock == pRTPSession->pSocket[s])
                        break;
                    else
                        mask <<= 1;
                }

#if defined(DEBUG)
                if (mask > (1<<SOCK_RTCP)) {
                    char str[256];
                    wsprintf(str,
                             "CShSocket[0x%X] socket=%d "
                             "m_pCRtpSession[0x%X - 0x%X, 0x%X - 0x%X]\n"
                             "CRtpSession[0x%X] RTPSession[0x%X]\n",
                             pCShSocket, sock,
                             pCShSocket->m_pCRtpSession[0],
                             pCShSocket->m_pCRtpSession2[0],
                             pCShSocket->m_pCRtpSession[1],
                             pCShSocket->m_pCRtpSession2[1],
                             pCRtpSession, pRTPSession);
                    OutputDebugString(str);
                    //DebugBreak();
                }
#endif
            }
            
            for(DWORD k = SOCKET_FIRST; k < SOCKET_LAST; k++) {
                if (dwKind & SOCKET_MASK(k) & pCShSocket->GetKind()) {
                    // This kind (recv/send) exists

                    if (pCShSocket->GetRefCount(k) > 1)
                        if (pRTPSession)
                            pRTPSession->dwStatus |= (mask << 24);
                    
                    if (!pCShSocket->DelRefCount(k)) {
                        // if no more refs, reset kind and
                        // null the RtpSession pointer
                        pCShSocket->RstKind(SOCKET_MASK(k));
                        pCShSocket->m_pCRtpSession[k] = NULL;
                    }
                }
            }

            if (!pCShSocket->GetRefCountAll()) {

                RemoveEntryList(&pCShSocket->Link);

                HRESULT hr = pCShSocket->CloseSocket();
                
                delete pCShSocket;

                if (pRTPSession) {

                    if (!pRTPSession->dwCloseTime)
                        pRTPSession->dwCloseTime = GetTickCount();
                    
                    if (FAILED(hr)) {
                        // Close socket failed
                        pRTPSession->dwLastError = WSAGetLastError();
                    
                        pRTPSession->dwStatus |= (mask << 4);
                    } else {
                        pRTPSession->dwStatus |= mask;
                    }
                }

                return(hr);

            } else {
                
                if (pRTPSession)
                    pRTPSession->dwStatus |= (mask << 8);
            }
            
            return(NOERROR);
        }

        // goto next pointer
        pLE = pLE->Flink;
    }

    if (pRTPSession) {
        if (pRTPSession->dwStatus & (1<<12))
            pRTPSession->dwStatus |= (1<<13);
        else 
            pRTPSession->dwStatus |= (1<<12);
    }
    
    TraceRetail((
            TRACE_ERROR, 
            TRACE_DEVELOP, 
            TEXT("CSocketManager::ReleaseSharedSocket: "
                 "failed: structure not found: %d"), 
            pCShSocket->GetShSocket()
        ));

    // Structure not found
    return(E_INVALIDARG);
}

//////////////////////////////////////////////////////////////////////
//
// CShSocket
//
//////////////////////////////////////////////////////////////////////


CShSocket::CShSocket(DWORD               dwRemAddr,
                     long               *plMaxShare,
                     WSAPROTOCOL_INFO   *pProtocolInfo,
                     DWORD               dwMaxFilters,
                     HRESULT            *phr)
{
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("CShSocket::CShSocket(%d,%d)"),
            plMaxShare[0], plMaxShare[1]
        ));

    // Create a new socket
    int Flags = WSA_FLAG_OVERLAPPED;
    BOOL fReuse;
    DWORD dwLoopBack = 0;

    ZeroMemory(this, sizeof(CShSocket));
    
    // Record the limits
    m_MaxCount[0] = plMaxShare[0];
    m_MaxCount[1] = plMaxShare[1];

    if (pProtocolInfo) {
        // Asking for QOS, reserve the requiered structure
        // for the QOS reservation
        m_pCRtpQOSReserve = new CRtpQOSReserve(this, dwMaxFilters);

        if (!m_pCRtpQOSReserve) {
            // Log info about success/failure,
            // may also notify or fail.
            // TODO
            goto cleanup;
        }
    }
    
    if (IS_MULTICAST(dwRemAddr))
        Flags |= WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_MULTIPOINT_D_LEAF;
    
    m_Socket = WSASocket(AF_INET, SOCK_DGRAM, 0,
                         pProtocolInfo, 0, Flags);

    // validate socket handle returned
    if (m_Socket == INVALID_SOCKET) {
            
        // obtain last error    
        TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CShSocket::CShSocket: failed %d"), 
                WSAGetLastError()
            ));

        goto cleanup;
    }
#if 0
    // XXX: Don't close the handle so a second close will break
    SetHandleInformation((HANDLE)m_Socket,
                         HANDLE_FLAG_PROTECT_FROM_CLOSE,
                         HANDLE_FLAG_PROTECT_FROM_CLOSE);
#endif

    fReuse = TRUE;

    // BUG!!! (build 1735): WSARecv fails for QoS enabled sockets
    // in unicast with error WSAEINVAL=10022 when
    // I use REUSEADDR.
    //
    // Anyway, allowing REUSEADDR unicast is not a good thing,
    // in fact we want to prevent that -- suppose another application
    // is using the same address/port pair, we would get a weird
    // behavior withouth knowing the reason, so we better fail in such
    // a case.
    // In multicast that's a different matter, we want to be able to
    // REUSEADDR, WS2 delivers a copy of each packet ro every listener

    if (IS_MULTICAST(dwRemAddr)) {
        if (setsockopt(
                m_Socket,
                SOL_SOCKET,
                SO_REUSEADDR,
                (PCHAR)&fReuse,
                sizeof(fReuse)
            ) == SOCKET_ERROR) {

            // obtain last error
            TraceDebug((
                    TRACE_ERROR,
                    TRACE_DEVELOP,
                    TEXT("CShSocket::CShSocket: "
                         "setsockopt(SO_REUSEADDR) failed: %d"),
                    WSAGetLastError()
                ));

            goto cleanup;
        }

        // BUGBUG, this should be done only for receivers,
        // but if the socket is created first for a sender
        // this option would have already been set.
        // This is not a problem right now because this flag
        // is set first when the socket is created, and then
        // can be updated only by a receiver.
        if (setsockopt(
                m_Socket,
                IPPROTO_IP,
                IP_MULTICAST_LOOP,
                (PCHAR)&dwLoopBack,
                sizeof(dwLoopBack)
            ) == SOCKET_ERROR) {

            // obtain last error
            TraceDebug((
                    TRACE_ERROR,
                    TRACE_DEVELOP,
                    TEXT("CShSocket::CShSocket: "
                         "setsockopt(IP_MULTICAST_LOOP) failed: %d"),
                    WSAGetLastError()
                ));

            goto cleanup;
        }
    }
    
    // bind lives now in GetSharedSocket in the socket initialization,
    // done differently for a sender, a receiver, and a sender/reciever

    TraceDebug((
            TRACE_TRACE, 
            TRACE_DEVELOP2, 
            TEXT("CShSocket::CShSocket: succeded: %d"), 
            m_Socket
        ));
    
    *phr = NOERROR;
    return;
    
cleanup:

    if (m_pCRtpQOSReserve) {
        delete m_pCRtpQOSReserve;
        m_pCRtpQOSReserve = NULL;
    }
    
    if (m_Socket != INVALID_SOCKET) {
        closesocket(m_Socket);
        m_Socket = INVALID_SOCKET;
    }

    *phr = E_FAIL;
    return;
}

CShSocket::~CShSocket()
{

    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP,
            TEXT("CShSocket::~CShSocket"), 
            m_Socket
        ));
}

HRESULT
CShSocket::CloseSocket()
{
    HRESULT dwError = E_FAIL;
    
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP,
            TEXT("CShSocket::CloseSocket: Socket:%d"), 
            m_Socket
        ));

#if defined(DEBUG)
    if (m_RefCount[0] + m_RefCount[1])
        TraceDebug((
                TRACE_ERROR, 
                TRACE_DEVELOP, 
                TEXT("CShSocket::CloseSocket: Inconsistency detected "
                     "in socket:%d: m_RefCount[0,1]=%d,%d"),
                m_Socket, m_RefCount[0], m_RefCount[1]
            ));
#endif  

    ASSERT( !(m_RefCount[0] + m_RefCount[1]) );

    if (m_Socket != INVALID_SOCKET) {
#if 0
        // XXX: Now allow to close the handle
        SetHandleInformation((HANDLE)m_Socket,
                             HANDLE_FLAG_PROTECT_FROM_CLOSE,
                             0);
#endif
        if (closesocket(m_Socket)) {
            // On error, do not wait for any overlapped IO to complete
            TraceRetail((
                    TRACE_ERROR, 
                    TRACE_DEVELOP, 
                    TEXT("CShSocket::CloseSocket: closesocket(%d) failed: %d"), 
                    m_Socket, WSAGetLastError()
                ));
        } else {
            dwError = NOERROR;
            
            TraceRetail((
                    TRACE_TRACE,
                    TRACE_DEVELOP, 
                    TEXT("CShSocket::CloseSocket: closesocket(%d)"), 
                    m_Socket
                ));
        }
    }

    if (m_pCRtpQOSReserve) {
        delete m_pCRtpQOSReserve;
        m_pCRtpQOSReserve = NULL;
    }

    return(dwError);
}

HRESULT
CShSocket::ShSocketStopQOS(DWORD dwIsSender)
{
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP,
            TEXT("CShSocket::ShSocketStopQOS") 
        ));

    if (m_pCRtpQOSReserve)
        return(m_pCRtpQOSReserve->Unreserve(dwIsSender));

    return(NOERROR);
}

//////////////////////////////////////////////////////////////////////
//
// InitializeFlowSpec
//
//////////////////////////////////////////////////////////////////////
VOID
InitializeFlowSpec(
    IN OUT PFLOWSPEC FlowSpec,
    IN SERVICETYPE ServiceType
	)
{
    FlowSpec->TokenRate = QOS_NOT_SPECIFIED;
    FlowSpec->TokenBucketSize = QOS_NOT_SPECIFIED;
    FlowSpec->PeakBandwidth = QOS_NOT_SPECIFIED;
    FlowSpec->Latency = QOS_NOT_SPECIFIED;
    FlowSpec->DelayVariation = QOS_NOT_SPECIFIED;
    FlowSpec->ServiceType = ServiceType;
    FlowSpec->MaxSduSize = QOS_NOT_SPECIFIED;
    FlowSpec->MinimumPolicedSize = QOS_NOT_SPECIFIED;
}


//////////////////////////////////////////////////////////////////////
//
// CRtpQOSReserve
//
//////////////////////////////////////////////////////////////////////

CRtpQOSReserve::CRtpQOSReserve(CShSocket *pCShSocket, DWORD dwMaxFilters)
    : m_pCShSocket(pCShSocket),

      m_pRsvpSSRC(NULL),
      m_pRsvpFilterSpec(NULL),
      
      m_Style(RSVP_DEFAULT_STYLE),
      m_dwFlags(flags_par(FG_RES_CONFIRMATION_REQUEST)),
      
      m_dwLastReserveTime(0),
      m_dwReserveIntervalTime(INITIAL_RESERVE_INTERVAL_TIME) // ms
{
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("CRtpQOSReserve::CRtpQOSReserve")
        ));

    InitializeFlowSpec( &m_qos.ReceivingFlowspec, SERVICETYPE_NOCHANGE );
    InitializeFlowSpec( &m_qos.SendingFlowspec, SERVICETYPE_NOCHANGE );

    m_qos.ProviderSpecific.len = 0;
    m_qos.ProviderSpecific.buf = NULL;

    // Initial values for destination address
    ZeroMemory(&m_destaddr, sizeof(m_destaddr));
    m_destaddr.ObjectHdr.ObjectType = QOS_OBJECT_DESTADDR;
    m_destaddr.ObjectHdr.ObjectLength =
        sizeof(m_destaddr) +
        sizeof(m_sockin_destaddr);
    m_destaddr.SocketAddress = (SOCKADDR *)&m_sockin_destaddr;
    m_destaddr.SocketAddressLength = sizeof(m_sockin_destaddr);
    
    SetMaxFilters(dwMaxFilters);
}

CRtpQOSReserve::~CRtpQOSReserve()
{
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("CRtpQOSReserve::~CRtpQOSReserve")
        ));
    
    if (m_pRsvpSSRC)
        delete m_pRsvpSSRC;

    if (m_pRsvpFilterSpec)
        delete m_pRsvpFilterSpec;

    m_MaxFilters = m_NumFilters = 0;
    m_pRsvpSSRC = NULL;
    m_pRsvpFilterSpec = NULL;
}

// change the max number of filters,
// and flush the current list
HRESULT
CRtpQOSReserve::SetMaxFilters(DWORD dwMaxFilters)
{
    HRESULT hr = NOERROR;
    
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("CRtpQOSReserve::SetMaxFilters(%d)"), dwMaxFilters
        ));

    if (dwMaxFilters > MAX_FILTERS)
        return(E_INVALIDARG);
    
    if (m_MaxFilters != dwMaxFilters) {

        // release old memory
        if (m_pRsvpSSRC)
            delete m_pRsvpSSRC;
        if (m_pRsvpFilterSpec)
            delete m_pRsvpFilterSpec;

        m_MaxFilters = dwMaxFilters;
        
        if (dwMaxFilters > 0) {
            // get new memory
            m_pRsvpSSRC = new DWORD[dwMaxFilters];
        
            m_pRsvpFilterSpec = new RSVP_FILTERSPEC[dwMaxFilters];

            if (!(m_pRsvpSSRC && m_pRsvpFilterSpec)) {
                TraceDebug((
                        TRACE_ERROR,
                        TRACE_DEVELOP, 
                        TEXT("CRtpQOSReserve::SetMaxFilters(%d) failed"),
                        dwMaxFilters
                    ));

                if (m_pRsvpSSRC) {
                    delete m_pRsvpSSRC;
                    m_pRsvpSSRC = (DWORD *)NULL;
                }

                if (m_pRsvpFilterSpec) {
                    delete m_pRsvpFilterSpec;
                    m_pRsvpFilterSpec = (RSVP_FILTERSPEC *)NULL;
                }

                m_MaxFilters = 0;
                hr = E_FAIL;
            }
        }
    }

    m_NumFilters = 0;

    return(hr);
}

// Ask for the template's names (e.g. G711, G723, H261CIF, etc.)
HRESULT
CRtpQOSReserve::QueryTemplates(char *templates, int size)
{
    WSABUF wsabuf;
    QOS qos; // For query this parameter should be passed as NULL
    HRESULT hr = E_FAIL;

    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("CRtpQOSReserve::QueryTemplates")
        ));
    
    if ( !templates || size < 1 || !m_pCShSocket )
        return(hr);
    
    templates[0] = '\0';

    wsabuf.buf = templates;
    wsabuf.len = size;
    
    qos.ProviderSpecific.len = 0;
    qos.ProviderSpecific.buf = NULL;
        
    if (WSAGetQOSByName(m_pCShSocket->GetShSocket(), &wsabuf, &qos)) {
        char *str, *str0;

        // change NULLs by SPACE
        for(str0 = str = templates;
            (*str || *(str+1)) && ((str-str0) < size);
            str++) {
            if (!*str)
                *str = ' ';
        }
        
        hr = NOERROR;
    }

    return(hr);
}

// Get just one template
HRESULT
CRtpQOSReserve::GetTemplate(char *template_name, char *qosClass, QOS *pqos)
{
    WSABUF wsabuf;
    DWORD  dwNewTokenRate;
    DWORD  dwTokenBucketSize;
    DWORD  dwMaxSduSize;
    DWORD  dwMinimumPolicedSize;
    HRESULT hr = E_FAIL;

    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("CRtpQOSReserve::GetTemplate")
        ));

    if (!template_name || !pqos)
        return(hr);
    
    wsabuf.buf = template_name;
    wsabuf.len = strlen(template_name);
    if (wsabuf.len > 0)
        wsabuf.len++; // Include NULL character

    pqos->ProviderSpecific.len = 0;
    pqos->ProviderSpecific.buf = NULL;
    
    /*
     * RTP = 12 bytes.
     *
     * Add at least 3% to the nominal token rate
     *
     * For G711. It is (240 + 40) * (1000 / 30) = 9333.33 bytes => 9613
     * (currently 8500), Min size 252 (current 340)
     *
     * For G723. It is (24 + 40) * (1000 / 30) = 2133.33 bytes => 2200
     * (currently 1138), Min size 32 (current 68)
     *
     * For GSM. It is (65 + 40) * (1000 / 40) = 2625 bytes => 2704
     * (currently 2150), Min size 77 (current 86)
     * */
    
    if (WSAGetQOSByName(m_pCShSocket->GetShSocket(), &wsabuf, pqos)) {

        dwNewTokenRate = (DWORD)-1;
        dwTokenBucketSize = (DWORD)-1;
        dwMaxSduSize = (DWORD)-1;
        dwMinimumPolicedSize = (DWORD)-1;
        
        if (!strcmp("G711", template_name)) {
            
            dwNewTokenRate = 9613;
            dwMaxSduSize = (240 * 3) + 12; /* 732 */
            dwTokenBucketSize = dwMaxSduSize * 2;
            dwMinimumPolicedSize = 92;  /* Actually we support 10ms,
                                         * so change from 30ms to 10ms */
            
        } else if (!strcmp("G723", template_name)) {
            /*
             * WARNING: MSP passes G723, but template name is G723.1
             */
            dwNewTokenRate = 2198;
            dwMaxSduSize = (24 * 3) + 12; /* 84 */
            dwTokenBucketSize = dwMaxSduSize * 4;
            dwMinimumPolicedSize = 32;

        } else if (!strcmp("GSM6.10", template_name)) {
            
            dwNewTokenRate = 2704;
            dwMinimumPolicedSize = 77;
        }    

        /* TokenRate & PeakBandwidth */
        if (dwNewTokenRate != (DWORD)-1) {

            if (dwNewTokenRate > pqos->SendingFlowspec.TokenRate) {
                /* take the maximum */

                pqos->SendingFlowspec.TokenRate = dwNewTokenRate;

                pqos->ReceivingFlowspec.TokenRate = dwNewTokenRate;
            }

            pqos->SendingFlowspec.PeakBandwidth =
                (dwNewTokenRate * 17) / 10; /* + 70 % */

            pqos->ReceivingFlowspec.PeakBandwidth = 
                (dwNewTokenRate * 17) / 10; /* + 70 % */
        }

        /* TokenBucketSize */
        if (dwTokenBucketSize != (DWORD)-1) {

            if (dwTokenBucketSize > pqos->SendingFlowspec.TokenBucketSize) {
                /* take the maximum */
                
                pqos->SendingFlowspec.TokenBucketSize = dwTokenBucketSize;

                pqos->ReceivingFlowspec.TokenBucketSize = dwTokenBucketSize;
            }
        }

         /* MaxSduSize */
        if (dwMaxSduSize != (DWORD)-1) {

            if (dwMaxSduSize > pqos->SendingFlowspec.MaxSduSize) {
                /* take the maximum */
                
                pqos->SendingFlowspec.MaxSduSize = dwMaxSduSize;

                pqos->ReceivingFlowspec.MaxSduSize = dwMaxSduSize;
            }
        }

       /* MinimumPolicedSize */
        if (dwMinimumPolicedSize != (DWORD)-1) {

            if (dwMinimumPolicedSize <
                pqos->SendingFlowspec.MinimumPolicedSize) {
                /* take the minimum */
                
                pqos->SendingFlowspec.MinimumPolicedSize =
                    dwMinimumPolicedSize;
            
                pqos->ReceivingFlowspec.MinimumPolicedSize =
                    dwMinimumPolicedSize;
            }
        }
        
        hr = NOERROR;

        // Save class and name
        strncpy(m_QOSclass, qosClass, sizeof(m_QOSclass));
        strncpy(m_QOSname, template_name, sizeof(m_QOSname));
    }

    return(hr);
}

// Set the Sender/Receiver FlowSpec
HRESULT
CRtpQOSReserve::SetFlowSpec(FLOWSPEC *pFlowSpec, DWORD dwIsSender)
{
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("CRtpQOSReserve::SetFlowSpec")
        ));
    
    if (!pFlowSpec)
        return(E_FAIL);

    CopyMemory(dwIsSender? &m_qos.SendingFlowspec : &m_qos.ReceivingFlowspec,
               pFlowSpec,
               sizeof(m_qos.SendingFlowspec));

    return(NOERROR);
}

// Scale a flow spec
// Only scale the following parameters:
//
// TokenRate;              /* In Bytes/sec */
// TokenBucketSize;        /* In Bytes */
// PeakBandwidth;          /* In Bytes/sec */
//
// TokenBucketSize and PeakBandwidth are scaled up, but not down

HRESULT
CRtpQOSReserve::ScaleFlowSpec(FLOWSPEC *pFlowSpec,
                              DWORD     dwNumParticipants,
                              DWORD     dwMaxParticipants,
                              DWORD     dwBandwidth)
{
    DWORD dwOverallBW =  pFlowSpec->TokenRate * dwMaxParticipants;

    dwBandwidth /= 8;  // flowspec is in bytes/sec

    TraceRetail((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("CRtpQOSReserve::ScaleFlowSpec(%u, %u, %u b/s) "
                 "flowspec(Tr:%u, Tbs:%u, PBw:%u, ST:%u, "
                 "MaxSDU:%u MinSize:%u)"),
            dwNumParticipants, dwMaxParticipants, dwBandwidth*8,
            pFlowSpec->TokenRate,
            pFlowSpec->TokenBucketSize,
            (pFlowSpec->PeakBandwidth != QOS_NOT_SPECIFIED) ?
            pFlowSpec->PeakBandwidth : QOS_NOT_SPECIFIED,
            pFlowSpec->ServiceType,
            pFlowSpec->MaxSduSize, pFlowSpec->MinimumPolicedSize
        ));

    if (dwOverallBW <= dwBandwidth) {
        // use as it is, scale up to dwNumParticipants
        pFlowSpec->TokenRate *= dwNumParticipants;
        pFlowSpec->TokenBucketSize *= dwNumParticipants;
        if (pFlowSpec->PeakBandwidth != QOS_NOT_SPECIFIED)
            pFlowSpec->PeakBandwidth *= dwNumParticipants;
    } else {
        // don't have all we need, scale according
        // to number of participants
        
        DWORD fac1;
        DWORD fac2;
        
        if (dwNumParticipants == dwMaxParticipants) {
            // use all the bandwidth available

            // Scale = 1 + [ (Bw - TokenRate) / TokenRate ]
            // Scale = Bw / TokenRate = fac1 / fac2

            fac1 = dwBandwidth;
            fac2 = pFlowSpec->TokenRate;
        } else {
            // use the bandwidth according to num of participants
            
            // Scale = [ ((Bw / Max) * Num ] / TokenRate
            // Scale = (Bw * Num) / (TokenRate * Max) = fac1 / fac2
            
            fac1 = dwBandwidth * dwNumParticipants;
            fac2 = pFlowSpec->TokenRate * dwMaxParticipants;
        }

        // scale TokenRate up or down
        pFlowSpec->TokenRate =
            (pFlowSpec->TokenRate * fac1) / fac2;
            
        if (fac1 > fac2) {
            // can still scale up the other parameters
                
            pFlowSpec->TokenBucketSize =
                ((pFlowSpec->TokenBucketSize * fac1) / fac2);

            if (pFlowSpec->PeakBandwidth != QOS_NOT_SPECIFIED)
                pFlowSpec->PeakBandwidth =
                    ((pFlowSpec->PeakBandwidth * fac1) / fac2);
        }
    }

    // The bandwidth we request include RTP/UDP/IP headers overhead,
    // but RSVP also scales up to consider headers overhead, to ovoid
    // requesting more bandwidth than we intend, pass to RSVP a
    // smaller value such that the final one RSVP comes up with would
    // be the original value we request.

    DWORD RSVPTokenRate;
    
    if (pFlowSpec->MinimumPolicedSize > 0) {

        RSVPTokenRate =
            (pFlowSpec->TokenRate * 1000) /
            (1000 + 28000/pFlowSpec->MinimumPolicedSize);
    }

    DWORD RSVPPeakBandwidth;

    RSVPPeakBandwidth = pFlowSpec->PeakBandwidth;

    if (RSVPPeakBandwidth != QOS_NOT_SPECIFIED) {

        RSVPPeakBandwidth =
            (pFlowSpec->PeakBandwidth * 1000) /
            (1000 + 28000/pFlowSpec->MinimumPolicedSize);
    }
    
    TraceRetail((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("CRtpQOSReserve::ScaleFlowSpec: "
                 "flowspec(Tr:%u/%u, Tbs:%u, PBw:%u/%u ST:%u, "
                 "MaxSDU:%u MinSize:%u) scaled"),
            pFlowSpec->TokenRate, RSVPTokenRate,
            pFlowSpec->TokenBucketSize,
            (pFlowSpec->PeakBandwidth != QOS_NOT_SPECIFIED) ?
            pFlowSpec->PeakBandwidth : QOS_NOT_SPECIFIED,
            (RSVPPeakBandwidth != QOS_NOT_SPECIFIED) ?
            RSVPPeakBandwidth : QOS_NOT_SPECIFIED,
            pFlowSpec->ServiceType,
            pFlowSpec->MaxSduSize, pFlowSpec->MinimumPolicedSize
        ));
    
    pFlowSpec->TokenRate = RSVPTokenRate;
    pFlowSpec->PeakBandwidth = RSVPPeakBandwidth;

    return(NOERROR);
}

// Set the destination address (required for unicast)
HRESULT
CRtpQOSReserve::SetDestAddr(LPBYTE pbDestAddr, DWORD dwAddrLen)
{
    CheckPointer(pbDestAddr, E_POINTER);
    
    if (dwAddrLen != sizeof(m_sockin_destaddr))
        return(E_INVALIDARG);

    char addrstr[RTPNTOASIZE];
    SOCKADDR_IN *pSinAddr = (SOCKADDR_IN *)pbDestAddr;
    
    TraceRetail((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("CRtpQOSReserve::SetDestAddr(%s/%d)"),
            RtpNtoA(pSinAddr->sin_addr.s_addr, addrstr),
            ntohs(((SOCKADDR_IN *)pbDestAddr)->sin_port)
        ));
    
    // Update only the address as the other elements do not change
    // since they are first initialized
    CopyMemory(&m_sockin_destaddr, pbDestAddr, dwAddrLen);

    return(NOERROR);
}

// Find out if an SSRC is in the reservation list or not
DWORD
CRtpQOSReserve::FindSSRC(DWORD ssrc)
{
    if (m_pRsvpSSRC && m_NumFilters) {
        DWORD i;
    
        for(i = 0; i < m_NumFilters; i++)
            if (ssrc == m_pRsvpSSRC[i])
                break;
        
        if (i < m_NumFilters)
            return(i);
        else
            return(-1);
    }

    return(-1);
}

// Add/Delete one SSRC (participant) to the
// Shared Explicit Filter (SEF) list
// 0==delete; other==add
HRESULT
CRtpQOSReserve::AddDeleteSSRC(DWORD ssrc, DWORD dwAddDel)
{
    HRESULT hr = E_FAIL;
    
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("CRtpQOSReserve::AddDeleteSSRC(0x%X, %s)"),
            ssrc, dwAddDel? "ADD":"DEL"
        ));

    CAutoLock LockThis(pStateLock());

    if (m_pRsvpFilterSpec) {
            
        unsigned int i;
            
        // Lookup the SSRC and find out if it is already in
        // the priority list
            
        for(i = 0; i < m_NumFilters; i++)
            if (ssrc == m_pRsvpSSRC[i])
                break;
        
        if (i < m_NumFilters) { // if (in list)

            /////////////////////////
            // Found at the ith place
            /////////////////////////

            if (dwAddDel) {
                //////////////////////
                // ******* ADD *******
                //////////////////////
                hr = NOERROR;// Add -- do nothing, already in list

            } else {

                /////////////////////////
                // ******* DELETE *******
                /////////////////////////

                // remove from list
                RSVP_FILTERSPEC *rsvp1 = &m_pRsvpFilterSpec[i];
                RSVP_FILTERSPEC *rsvp2 = rsvp1 + 1;

                DWORD *ssrc1 = &m_pRsvpSSRC[i];
                DWORD *ssrc2 = ssrc1 + 1;
                
                for(m_NumFilters--;
                    i < m_NumFilters;
                    rsvp1++, rsvp2++, ssrc1++, ssrc2++, i++) {

                    MoveMemory(rsvp1, rsvp2, sizeof(*rsvp1));
                    *ssrc1 = *ssrc2;
                }
                
            }
            hr = NOERROR;
        } else { // else if (not in list)

            /////////////////////
            // Not found in list!
            /////////////////////

            if (dwAddDel) {

                //////////////////////
                // ******* ADD *******
                //////////////////////

                // add to the list
                
                // Validate the number of SRRCs in the list
                if (m_NumFilters < m_MaxFilters) {

                    CRtpSession *pCRtpSession =
                        m_pCShSocket->GetpCRtpSession(-1);
                    
                    if (pCRtpSession) {
                        
                        DWORD addrlen;
                        SOCKADDR_IN saddr;
                    
                        // Get SSRC's IP address/port (from RTP packets)
                        addrlen = sizeof(saddr);
                        hr = pCRtpSession->
                            GetParticipantAddress(ssrc,
                                                  (LPBYTE)&saddr,
                                                  (int *)&addrlen);

                        if (SUCCEEDED(hr)) {
                            RSVP_FILTERSPEC *rsvp =
                                &m_pRsvpFilterSpec[m_NumFilters];

                            rsvp->Type = FILTERSPECV4;
                            rsvp->FilterSpecV4.Address.Addr =
                                saddr.sin_addr.s_addr;

                            // Take the port from the RTP Session's address
                            // as the learned address may be from an
                            // RTCP packet and hence be the wrong port
                            // number.
                            //
                            // !!!!! Note
                            // The address from RTP packets may not be
                            // available yet, it will be once we receive
                            // a valid RTP packet.
                            // If that address is not available, then
                            // all 0's address will be returned
                            // but the function will not fail.
                            
                            // The sending port can be anything, as
                            // in NetMeeting, In this case,
                            // the MSP needs to lookup participants
                            // using the SSRC/CNAME, being CNAME
                            // the unique ID.
                            rsvp->FilterSpecV4.Port = saddr.sin_port;

                            if (saddr.sin_port) {
                                // Record the filter only if a valid
                                // address/port is available
                                m_pRsvpSSRC[m_NumFilters] = ssrc;
                            
                                m_NumFilters++;

                                // Succeeds only if really added
                                // to the list
                                char addrstr[RTPNTOASIZE];
                                
                                TraceDebug((
                                        TRACE_TRACE,
                                        TRACE_DEVELOP, 
                                        TEXT("CRtpQOSReserve::AddDeleteSSRC"
                                             "(%s: 0x%X/%s/%d)"),
                                        dwAddDel? "ADD":"DEL",
                                        ssrc,
                                        RtpNtoA(saddr.sin_addr.s_addr,addrstr),
                                        ntohs(saddr.sin_port)
                                    ));
                                
                                hr = NOERROR;
                            }
                        } else {
                            TraceDebug((
                                    TRACE_ERROR,
                                    TRACE_DEVELOP, 
                                    TEXT("CRtpQOSReserve::AddDeleteSSRC"
                                         ": could not get IP addr for 0x%X"),
                                    ssrc
                                ));
                        }
                    }
                }
            } else {

                /////////////////////////
                // ******* DELETE *******
                /////////////////////////

                hr = NOERROR;// do nothing, not in list
            }
        } // if (not in list)
    } // if (filters list exist)
    
    return(hr);
}

void dumpQOS(char *msg, QOS *pQOS);
void dumpObjectType(char *msg, char *ptr, unsigned int len);

HRESULT
CRtpQOSReserve::Reserve(DWORD dwIsSender)
{
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("CRtpQOSReserve::Reserve(%s) @ %d"),
            dwIsSender? "SEND":"RECV",
            GetTickCount() - m_dwLastReserveTime
        ));

    DWORD  len;
    char  *ptr;
    QOS    qos;
    char   buf[MAX_PROVIDERSPECIFIC_BUFFER];

    QOS_DESTADDR      *dest_addr;
    RSVP_RESERVE_INFO *reserve_info;
    FLOWDESCRIPTOR    *flow_desc;
    RSVP_FILTERSPEC   *filterspec;
    
    HRESULT hr = NOERROR;

    CopyMemory(&qos, &m_qos, sizeof(qos));
    
    // Always enable notifications,
    // except if the WSAIctl(SIO_SET_QOS) fails or
    // we are receiver and are requesting BEST_EFFORT
    m_pCShSocket->ModifyFlags(
            dwIsSender? FG_SOCK_ENABLE_NOTIFY_SEND:FG_SOCK_ENABLE_NOTIFY_RECV,
            1);

    if (m_pCShSocket->TestFlags(
            dwIsSender? FG_SOCK_ENABLE_NOTIFY_SEND:FG_SOCK_ENABLE_NOTIFY_RECV)) {
        TraceDebug((
                TRACE_TRACE,
                TRACE_DEVELOP, 
                TEXT("CRtpQOSReserve::Reserve(%s) Enable Notifications"),
                dwIsSender? "SEND":"RECV"
            ));
    } else {
            TraceDebug((
                TRACE_TRACE,
                TRACE_DEVELOP, 
                TEXT("CRtpQOSReserve::Reserve(%s) Disable Notifications"),
                dwIsSender? "SEND":"RECV"
            ));
    }

    qos.ProviderSpecific.len = 0;
    qos.ProviderSpecific.buf = NULL;
    ptr = buf;
        
    if (dwIsSender) {
        // Do not change the receiver
        qos.ReceivingFlowspec.ServiceType = SERVICETYPE_NOCHANGE;

        // Init the destination object if unicast
        if (!IS_MULTICAST(m_sockin_destaddr.sin_addr.s_addr) &&
            (m_sockin_destaddr.sin_addr.s_addr != INADDR_ANY)) {

            if (!fg_tst(m_dwFlags, FG_RES_DEST_ADDR_OBJECT_USED)) {

                // Specify the dest addr object only once,
                // to do so remember it was used
                fg_set(m_dwFlags, FG_RES_DEST_ADDR_OBJECT_USED);;
                
                dest_addr = (QOS_DESTADDR *)ptr;
                
                ZeroMemory((char *)dest_addr,
                           sizeof(m_destaddr) +
                           sizeof(m_sockin_destaddr));
                dest_addr->ObjectHdr.ObjectType = QOS_OBJECT_DESTADDR;
                dest_addr->ObjectHdr.ObjectLength =
                    sizeof(m_destaddr);
                //sizeof(m_sockin_destaddr);

                // Copy QOS_DESTADDR and SocketAddress, update pointer
                // to SocketAddress
                
                CopyMemory((char *)dest_addr,
                           (char *)&m_destaddr,
                           sizeof(m_destaddr));

                CopyMemory((char *)(dest_addr + 1),
                           (char *)&m_sockin_destaddr,
                           sizeof(m_sockin_destaddr));
                
                dest_addr->SocketAddress = (const struct sockaddr *)
                    (dest_addr + 1);
                dest_addr->SocketAddressLength = sizeof(m_sockin_destaddr);
                
                ptr += sizeof(m_destaddr) + sizeof(m_sockin_destaddr);
            }
        }

        reserve_info = (RSVP_RESERVE_INFO *)ptr;
        
        // Partially Init RSVP_RESERVE_INFO
        ZeroMemory(reserve_info, sizeof(RSVP_RESERVE_INFO));
        reserve_info->ObjectHdr.ObjectType = RSVP_OBJECT_RESERVE_INFO;
        reserve_info->ConfirmRequest =
            flags_tst(FG_RES_CONFIRMATION_REQUEST);
        reserve_info->Style          = m_Style;
        
        // Add QOS app ID later at ptr
        ptr += sizeof(RSVP_RESERVE_INFO);
        
        // Scale the flow spec for the sender (if needed)
        ScaleFlowSpec(&qos.SendingFlowspec, 1, 1, m_MaxBandwidth);
        
        // Remember when was the last time a reserve was done for the sender
        // (not really reserve but specify the flowspec)
        SetLastReserveTime(GetTickCount());

    } else {

        // Do not change the sender
        qos.SendingFlowspec.ServiceType = SERVICETYPE_NOCHANGE;

        reserve_info = (RSVP_RESERVE_INFO *)ptr;

        // Partially Init RSVP_RESERVE_INFO
        ZeroMemory(reserve_info, sizeof(RSVP_RESERVE_INFO));
        reserve_info->ObjectHdr.ObjectType = RSVP_OBJECT_RESERVE_INFO;
        reserve_info->ConfirmRequest =
            flags_tst(FG_RES_CONFIRMATION_REQUEST);
        reserve_info->Style          = m_Style;

        if (m_Style == RSVP_SHARED_EXPLICIT_STYLE) {
            // Shared Explicit filter -- SEF

            if (m_pRsvpFilterSpec && m_NumFilters > 0) {
                // We have some filters 
                TraceDebug((
                        TRACE_TRACE,
                        TRACE_DEVELOP, 
                        TEXT("CRtpQOSReserve::Reserve(RECV) "
                             "Multicast(SE, %d)"),
                        m_NumFilters
                    ));

                // Scale the flow descriptor to m_NumFilters
                ScaleFlowSpec(&qos.ReceivingFlowspec,
                              m_NumFilters,
                              m_MaxFilters,
                              m_MaxBandwidth);

                // Build the ProviderSpecific buffer

                flow_desc = (FLOWDESCRIPTOR *)(reserve_info + 1);

                filterspec = (RSVP_FILTERSPEC *)(flow_desc + 1);

                // Init RSVP_RESERVE_INFO
                reserve_info->ObjectHdr.ObjectLength =
                    sizeof(RSVP_RESERVE_INFO) +
                    sizeof(FLOWDESCRIPTOR) +
                    (sizeof(RSVP_FILTERSPEC) * m_NumFilters);
                reserve_info->NumFlowDesc = 1;
                reserve_info->FlowDescList = flow_desc;
                    
                // Init FLOWDESCRIPTOR
                CopyMemory(&flow_desc->FlowSpec,
                           &qos.ReceivingFlowspec,
                           sizeof(qos.ReceivingFlowspec));
                flow_desc->NumFilters = m_NumFilters;
                flow_desc->FilterList = filterspec;;

                // Init RSVP_FILTERSPEC
                CopyMemory(filterspec,
                           m_pRsvpFilterSpec,
                           m_NumFilters * sizeof(RSVP_FILTERSPEC));
                
                // Add QOS app ID later at ptr
                ptr = (char *)filterspec +
                    m_NumFilters * sizeof(RSVP_FILTERSPEC);

            } else {
                
                // Nothing selected yet, select BEST_EFFORT
                TraceDebug((
                        TRACE_TRACE,
                        TRACE_DEVELOP, 
                        TEXT("CRtpQOSReserve::Reserve(RECV) "
                             "Multicast(SE, %d) pass to BEST EFFORT"),
                        m_NumFilters
                    ));

                qos.ReceivingFlowspec.ServiceType = SERVICETYPE_BESTEFFORT;

                // no reserve_info needed
                // Don't add QOS app ID
                reserve_info = (RSVP_RESERVE_INFO *)NULL;

                // Not allowed to start notifications yet as
                // we are going to request BEST EFFORT
                m_pCShSocket->ModifyFlags(
                        dwIsSender? FG_SOCK_ENABLE_NOTIFY_SEND:
                        FG_SOCK_ENABLE_NOTIFY_RECV,
                        0);
            }

        } else if (m_Style == RSVP_WILDCARD_STYLE) {
            // Share N*FlowSpec -- WF
            TraceDebug((
                    TRACE_TRACE,
                    TRACE_DEVELOP, 
                    TEXT("CRtpQOSReserve::Reserve(RECV) Multicast(WF)")
                ));

            // Scale the flow spec to m_MaxFilters
            ScaleFlowSpec(&qos.ReceivingFlowspec,
                          m_MaxFilters,
                          m_MaxFilters,
                          m_MaxBandwidth);

            // Add QOS app ID later at ptr
            ptr = (char *)(reserve_info + 1);
            
        } else {
            // RSVP_DEFAULT_STYLE || RSVP_FIXED_FILTER_STYLE
            // Unicast -- FF
            TraceDebug((
                    TRACE_TRACE,
                    TRACE_DEVELOP, 
                    TEXT("CRtpQOSReserve::Reserve(RECV) Unicast(DEF STYLE)")
                ));
            
            // Scale the flow spec to m_MaxFilters
            ScaleFlowSpec(&qos.ReceivingFlowspec,
                          m_MaxFilters,
                          m_MaxFilters,
                          m_MaxBandwidth);

            // Add QOS app ID later at ptr
            ptr = (char *)(reserve_info + 1);
        }

    }

    if (reserve_info) {
        // Add QOS APP ID if reserve info is defined
        len = AddQosAppID(ptr,
                          sizeof(buf) - (ptr - buf),
                          g_sPolicyLocator,
                          g_sAppName,
                          m_QOSclass,
                          m_QOSname);

        if (len > 0) {
            reserve_info->PolicyElementList = (RSVP_POLICY_INFO *)ptr;
            ptr += len;
        }

        reserve_info->ObjectHdr.ObjectLength = (DWORD)
            (ptr - (char *)reserve_info);
            
        // Init ProviderSpecific
        qos.ProviderSpecific.len = ptr - buf;
        qos.ProviderSpecific.buf = buf;
    }

    DWORD outBufSize = 0;

    // Set QOS using WSAIoctl
#if defined(DEBUG)
    DWORD t0 = GetTickCount();

    dumpQOS("CRtpQOSReserve::Reserve(before)", &qos);
            
    if (qos.ProviderSpecific.buf && 
        qos.ProviderSpecific.len >= sizeof(QOS_OBJECT_HDR)) {
        
        dumpObjectType("CRtpQOSReserve::Reserve",
                       qos.ProviderSpecific.buf,
                       qos.ProviderSpecific.len);
    }
#endif    
    if ( WSAIoctl(m_pCShSocket->GetShSocket(),
                  SIO_SET_QOS,
                  (LPVOID)&qos,
                  sizeof(qos),
                  NULL,
                  0,
                  &outBufSize,
                  NULL,
                  NULL) ) {

        // WSAIoctl failed, disable notifications
        m_pCShSocket->ModifyFlags(
                dwIsSender? FG_SOCK_ENABLE_NOTIFY_SEND:
                FG_SOCK_ENABLE_NOTIFY_RECV,
                0);
        
        hr = E_FAIL;

        TraceDebug((
                TRACE_ERROR,
                TRACE_DEVELOP, 
                TEXT("CRtpQOSReserve::Reserve(%s) WSAIoctl failed: %d"),
                dwIsSender? "SEND":"RECV", WSAGetLastError()
            ));
    } else {
#if defined(DEBUG)
        DWORD t1 = GetTickCount();

        TraceDebug((
                TRACE_TRACE,
                TRACE_DEVELOP, 
                TEXT("CRtpQOSReserve::Reserve(%s) WSAIoctl succeeded, "
                     "DELAY: %d ms"),
                dwIsSender? "SEND":"RECV", t1-t0
            ));

        dumpQOS("CRtpQOSReserve::Reserve(after )", &qos);
            
        if (qos.ProviderSpecific.buf && 
            qos.ProviderSpecific.len >= sizeof(QOS_OBJECT_HDR)) {
                
            dumpObjectType("CRtpQOSReserve::Reserve",
                           qos.ProviderSpecific.buf,
                           qos.ProviderSpecific.len);
        }
#endif
    }
    
    return(hr);
}

HRESULT
CRtpQOSReserve::Unreserve(DWORD dwIsSender)
{
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("CRtpQOSReserve::Unreserve(%s)"),
            dwIsSender? "SEND":"RECV"
        ));

    QOS qos;
    CopyMemory(&qos, &m_qos, sizeof(qos));

    qos.ProviderSpecific.len = 0;
    qos.ProviderSpecific.buf = NULL;
    
    if (dwIsSender) {
        qos.SendingFlowspec.ServiceType   = SERVICETYPE_NOTRAFFIC;
        qos.ReceivingFlowspec.ServiceType = SERVICETYPE_NOCHANGE;
    } else {
        qos.SendingFlowspec.ServiceType   = SERVICETYPE_NOCHANGE;
        qos.ReceivingFlowspec.ServiceType = SERVICETYPE_NOTRAFFIC;
    }

    // Disable notifications
    m_pCShSocket->ModifyFlags(
            dwIsSender? FG_SOCK_ENABLE_NOTIFY_SEND:FG_SOCK_ENABLE_NOTIFY_RECV,
            0);

    DWORD outBufSize = 0;
    
    // Set QOS using WSAIoctl
    if ( WSAIoctl(m_pCShSocket->GetShSocket(),
                  SIO_SET_QOS,
                  (LPVOID)&qos,
                  sizeof(qos),
                  NULL,
                  0,
                  &outBufSize,
                  NULL,
                  NULL) )
        return(E_FAIL);

    return(NOERROR);
}

// Ask for permission to send
HRESULT
CRtpQOSReserve::AllowedToSend()
{
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("CRtpQOSReserve::AllowedToSend")
        ));
    
#if defined(SIO_CHK_QOS)

    DWORD request = ALLOWED_TO_SEND_DATA;
    DWORD result;
    DWORD bytes_returned = 0;

    if ( WSAIoctl(m_pCShSocket->GetShSocket(),
                  SIO_CHK_QOS,
                  (LPVOID)&request,
                  sizeof(request),
                  (LPVOID)&result,
                  sizeof(result),
                  &bytes_returned,
                  NULL,
                  NULL) ) {

        TraceDebug((
                TRACE_ERROR,
                TRACE_DEVELOP, 
                TEXT("CRtpQOSReserve::AllowedToSend: "
                     "WSAIoctl(SIO_CHK_QOS) failed: %d"),
                WSAGetLastError()
            ));
        
        return(NO_ERROR); // For safety, return NOEROR
    }

    result = result? NOERROR : E_FAIL;
#else
    result = NOERROR;
#endif
    
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("CRtpQOSReserve::AllowedToSend: %s"),
            (SUCCEEDED(result))? "YES":"NO"
        ));

    return(result);
}

// Inquire about the link's speed
HRESULT
CRtpQOSReserve::LinkSpeed(DWORD *pdwLinkSpeed)
{
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("CRtpQOSReserve::LinkSpeed")
        ));

    CheckPointer(pdwLinkSpeed, E_POINTER);
    
    *pdwLinkSpeed = 0;
    
#if defined(SIO_CHK_QOS)

    DWORD request = LINE_RATE;

    if ( WSAIoctl(m_pCShSocket->GetShSocket(),
                  SIO_CHK_QOS,
                  (LPVOID)&request,
                  sizeof(request),
                  NULL,
                  0,
                  pdwLinkSpeed,
                  NULL,
                  NULL) ) {
        return(E_FAIL);
    }
#endif

    return(NOERROR);
}

// Inquire about the estimated available bandwidth
HRESULT
CRtpQOSReserve::EstimatedAvailableBandwidth(DWORD *pdwBandwidth)
{
    TraceDebug((
            TRACE_TRACE,
            TRACE_DEVELOP, 
            TEXT("CRtpQOSReserve::EstimatedAvailableBandwidth")
        ));

    return(E_NOTIMPL);
}

/*+++

  Description:

        This routine generates the application identity PE given the
        name and policy locator strings for the application.

        szAppName is used to construct the CREDENTIAL attribute of the
        Identity PE. Its subtype is set to ASCII_ID.

        szPolicyLocator is used to construct the POLICY_LOCATOR
        attribute of the Identity PE. Its subtype is set to ASCII_DN.

        Refer to draft-ietf-rap-rsvp-identity-03.txt and
        draft-bernet-appid-00.txt for details on the Identity Policy
        Elements.  Also draft-bernet-appid-00.txt conatins some
        examples for arguments szPolicyLocator and szAppName.

        The PE is generated in the supplied buffer. If the length of
        the buffer is not enough, zero is returned.

    Parameters:  szAppName          app name, string, caller supply
                 szPolicyLocator    Policy Locator string, caller supply
                 wBufLen            length of caller allocated buffer
                 pAppIdBuf          pointer to caller allocated buffer

    Return Values:
        Number of bytes used from buffer
---*/
DWORD AddQosAppID(
        IN OUT  char       *pAppIdBuf,
        IN      WORD        wBufLen,
        IN      const char *szPolicyLocator,
        IN      const char *szAppName,
        IN      const char *szAppClass,
        IN      char       *szQosName
    )
{
    RSVP_POLICY_INFO *pPolicyInfo = ( RSVP_POLICY_INFO* )pAppIdBuf;
	RSVP_POLICY* pAppIdPE;
    IDPE_ATTR   *pAttr;
    USHORT       nAppIdAttrLen;
    USHORT       nPolicyLocatorAttrLen;
    USHORT       nTotalPaddedLen;
    char         str[128];

    // Calculate the length of the buffer required
    strcpy(str,",SAPP=");
    strcat(str, szAppClass);
    strcat(str, ",SAPP=");
    strcat(str, szQosName);

    nPolicyLocatorAttrLen =
        IDPE_ATTR_HDR_LEN + strlen( szPolicyLocator ) + strlen( str ) + 1;
    
    nAppIdAttrLen   = IDPE_ATTR_HDR_LEN + strlen( szAppName ) + 1;
    
    nTotalPaddedLen = sizeof( RSVP_POLICY_INFO ) - ( sizeof( UCHAR ) * 4 ) +
                      RSVP_BYTE_MULTIPLE( nAppIdAttrLen ) +
                      RSVP_BYTE_MULTIPLE( nPolicyLocatorAttrLen );

    // If the supplied buffer is not long enough, return 0
    if( wBufLen < nTotalPaddedLen ) 
    {
        return 0;
    }

    ZeroMemory( pAppIdBuf, nTotalPaddedLen );
	
	// Set the RSVP_POLICY_INFO header
	pPolicyInfo->ObjectHdr.ObjectType = RSVP_OBJECT_POLICY_INFO;
	pPolicyInfo->ObjectHdr.ObjectLength = nTotalPaddedLen;
	pPolicyInfo->NumPolicyElement = 1;

    // Now set up RSVP_POLICY object header
	pAppIdPE = pPolicyInfo->PolicyElement;
    pAppIdPE->Len = RSVP_POLICY_HDR_LEN + 
					RSVP_BYTE_MULTIPLE( nAppIdAttrLen ) +
                    RSVP_BYTE_MULTIPLE( nPolicyLocatorAttrLen );
    pAppIdPE->Type = PE_TYPE_APPID;

    // The first application id attribute is the policy locator string
    pAttr = ( IDPE_ATTR * )( (char *)pAppIdPE + RSVP_POLICY_HDR_LEN );
    
    // Set the attribute length in network order.
    pAttr->PeAttribLength   = htons( nPolicyLocatorAttrLen );
    pAttr->PeAttribType     = PE_ATTRIB_TYPE_POLICY_LOCATOR;
    pAttr->PeAttribSubType  = POLICY_LOCATOR_SUB_TYPE_ASCII_DN;
    strcpy( (char *)pAttr->PeAttribValue, szPolicyLocator );
    strcat( (char *)pAttr->PeAttribValue, str );

    // The application name attribute comes next
    pAttr = ( IDPE_ATTR * )( (char*)pAttr +
                             RSVP_BYTE_MULTIPLE( nPolicyLocatorAttrLen ) );

    pAttr->PeAttribLength   = htons( nAppIdAttrLen );
    pAttr->PeAttribType     = PE_ATTRIB_TYPE_CREDENTIAL;
    pAttr->PeAttribSubType  = CREDENTIAL_SUB_TYPE_ASCII_ID;
    strcpy( ( char * )pAttr->PeAttribValue, szAppName );

    return( nTotalPaddedLen );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\shared.cpp ===
/*********************************************************************
 *
 * Copyright (C) Microsoft Corporation, 1997 - 1999
 *
 * File: shared.cpp
 *
 * Abstract:
 *     Overrides some methods from CSourceStream and CAMThrad to
 *     enable sharing one thread for all the graphs whose render
 *     doesn not block.
 *
 * History:
 *     11/06/97    Created by AndresVG
 *
 **********************************************************************/

#include "globals.h"

//Now defined in amrtpnet.h (am_rrcm.h)
//#define MAX_CLASSES 4  // e.g. class0:audio, class1:video, ...

CSharedProc **g_ppCSharedProc   = NULL;
int           g_iNumProcs       = 0;
long          g_lSharedContext  = 0;
long          g_lClassesCount[RTP_MAX_CLASSES] = {0, 0};
CCritSec      g_cCreateDeleteLock; // serializes access to Create/Delete

void
InitShared()
{
	int i;
	int NumProcs;
	SYSTEM_INFO si;
	
	// Find out how many processors we have.
	// always return 1 for Windows 9x
	GetSystemInfo(&si);
	NumProcs = g_iNumProcs = si.dwNumberOfProcessors;

	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP, 
			TEXT("GetNumProcs: Number of processors: %d"),
			g_iNumProcs
		));

	// If Windows 9x, reset number of processors to 1
	if (NumProcs > 1) {
		OSVERSIONINFO os;
		os.dwOSVersionInfoSize = sizeof(os);

		if (GetVersionEx(&os)) {
			if (os.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
				NumProcs = 1;

				DbgLog((
						LOG_TRACE, 
						LOG_DEVELOP, 
						TEXT("GetNumProcs: Number of processors "
							 "reset from %d to %d"),
						g_iNumProcs, NumProcs
					));
			}
		}
	}

	g_iNumProcs = NumProcs;

	g_ppCSharedProc = (CSharedProc **)
		new	CSharedProc*[g_iNumProcs * RTP_MAX_CLASSES];
	ASSERT(g_ppCSharedProc);
	
	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP2, 
			TEXT("InitShared: Allocate: g_ppCSharedProc: 0x%X"),
			g_ppCSharedProc
		));
	for(i = 0; i < g_iNumProcs * RTP_MAX_CLASSES; i++)
		g_ppCSharedProc[i] = (CSharedProc *)NULL;
}

CSharedProc *
CreateSharedContext(DWORD fShared,
					long  lThreadClass,
					long  lThreadPriority)
{
	CAutoLock gCreateDelete(&g_cCreateDeleteLock);

	if (!g_iNumProcs)
		InitShared();

	// If Class is out of range, select the last class
	if (lThreadClass >= RTP_MAX_CLASSES || lThreadClass < 0)
		lThreadClass = RTP_MAX_CLASSES - 1;

	if (fShared) {
		// Going to be a shared thread
		int index = ((g_lClassesCount[lThreadClass] % g_iNumProcs) *
					 RTP_MAX_CLASSES) + lThreadClass;
	
		if (!g_ppCSharedProc[index]) {
			g_ppCSharedProc[index] =
				new CSharedProc(index, lThreadClass, lThreadPriority);
			ASSERT(g_ppCSharedProc[index]);

			if (g_ppCSharedProc[index])
				InterlockedIncrement(&g_lSharedContext);
		}
		
		return(g_ppCSharedProc[index]);
	} else {
		// Going to be a thread for just one context,
		// always create it.
		CSharedProc *Aux_pCSharedProc =
			new CSharedProc(-1, lThreadClass, lThreadPriority);

		if (Aux_pCSharedProc)
			InterlockedIncrement(&g_lSharedContext);
		
		ASSERT(Aux_pCSharedProc);

		return(Aux_pCSharedProc);
	}
}

void
DeleteSharedContext(CSharedProc *pCSharedProc)
{
	int index = pCSharedProc->GetShareID();

	delete pCSharedProc;

	CAutoLock gCreateDelete(&g_cCreateDeleteLock);

	InterlockedDecrement(&g_lSharedContext);

	if (index >= 0)
		g_ppCSharedProc[index] = NULL;
	
	if (g_lSharedContext)
		return;

	if (g_ppCSharedProc) {

		DbgLog((
				LOG_TRACE, 
				LOG_DEVELOP, 
				TEXT("DeleteSharedContext: delete g_ppCSharedProc: 0x%X"),
				g_ppCSharedProc
			));
		DbgLog((
				LOG_TRACE, 
				LOG_DEVELOP, 
				TEXT("DeleteSharedContext: END ===========================\n")
			));

		delete g_ppCSharedProc;

		g_ppCSharedProc = NULL;
		g_iNumProcs = 0;
#if defined(DEBUG)
		for(int i = 0; i < RTP_MAX_CLASSES; i++)
			ASSERT(!g_lClassesCount[i]);
#endif
	}
}

/*********************************************************************
 * CSharedProc implemtation
 *********************************************************************/

CSharedProc::CSharedProc(int  iShareID,
						 long lThreadClass,
						 long lThreadPriority)
	: m_EventSend(TRUE),
	  m_EventComplete(FALSE),

	  m_lSharedCount(0),
	  m_dwNumRun(0),

	  m_hSharedThread(NULL),
	  m_dwSharedThreadID(0),
	  
	  m_iShareID(iShareID),
	  m_lSharedThreadClass(lThreadClass),
	  m_lSharedThreadPriority(lThreadPriority)
{
	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP, 
			TEXT("CSharedProc::CSharedProc: "
				 "ShareID:%d, Class:%d, Priority:%d"),
			m_iShareID, lThreadClass, lThreadPriority
		));
	
	InitializeCriticalSection(&m_SharedLock);
	InitializeListHead(&m_SharedList);
}

CSharedProc::~CSharedProc()
{
	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP, 
			TEXT("CSharedProc::~CSharedProc")
		));

	DeleteCriticalSection(&m_SharedLock);
}

DWORD WINAPI
CSharedProc::InitialThreadProc(void *pv)
{
	CSharedProc *pCSharedProc = (CSharedProc *)pv;
	return(pCSharedProc->SharedThreadProc(pv));
}

DWORD
CSharedProc::SharedThreadProc(void *pv)
{
    DWORD Request = CMD_INIT;
    HRESULT hr = (GetWaitObject() != NULL) ? S_OK : E_FAIL;

    // set the priority of this worker thread if necessary
#if defined(DEBUG)
	{
		HANDLE cThread = GetCurrentThread();
		int tPrio1 = GetThreadPriority(cThread);

		SetThreadPriority(cThread, GetSharedThreadPriority());

		int tPrio2 = GetThreadPriority(cThread);
		
		DbgLog((
				LOG_TRACE, 
				LOG_DEVELOP, 
				TEXT("CSharedProc::SharedThreadProc: "
					 "ThreadID: %d (0x%X), ThreadH: %d (0x%X), "
					 "Class: %d, Priority: %d,%d,%d"),
				GetSharedThreadID(), GetSharedThreadID(),
				cThread, cThread,
				GetSharedThreadClass(),
				tPrio1, GetSharedThreadPriority(), tPrio2
			));
	}
#else	
	SetThreadPriority(GetCurrentThread(), GetSharedThreadPriority());
#endif
	
    while(Request != CMD_EXIT_SHARED) {
		
		DWORD Status = WaitForSingleObjectEx(GetWaitObject(), 
											 INFINITE, 
											 (GetNumRun() > 0)? TRUE:FALSE);
		if (Status == WAIT_IO_COMPLETION) {
			///////////////////////////////////
			// WAIT_IO_COMPLETION: Receive data
			///////////////////////////////////
			
			PLIST_ENTRY        pLE;
			SAMPLE_LIST_ENTRY *pSLE;

			while(!IsListEmpty(&m_SharedList)) {

				EnterCriticalSection(&m_SharedLock);
				{
					// get first entry link
					pLE = m_SharedList.Flink;

					// obtain sample list entry from list entry
					pSLE = CONTAINING_RECORD(pLE, SAMPLE_LIST_ENTRY, Link);
    
					// remove from list
					RemoveEntryList(&pSLE->Link);
				}
				LeaveCriticalSection(&m_SharedLock);


				CSharedSourceStream *pCSharedSourceStream =
					(CSharedSourceStream *)
					pSLE->pCSampleQueue->GetSampleContext();
				
				pCSharedSourceStream->ProcessIO(pSLE);
			}
			
		} else if (Status == WAIT_OBJECT_0) {
			////////////////////////////////////////
			// WAIT_OBJECT_0: Signaled event (a CMD)
			////////////////////////////////////////

			Request = GetRequestParam();

			if (Request >= CMD_INIT && Request <= CMD_EXIT) {
				CSharedSourceStream *pCSharedSourceStream =
					(CSharedSourceStream *) GetRequestContext();

				hr = pCSharedSourceStream->ProcessCmd(
						(CSharedSourceStream::Command)Request);
			}
			
			Reply(hr);
			
		} else {
			
            DbgLog((
					LOG_TRACE, // LOG_ERROR, 
					LOG_DEVELOP2, 
                TEXT("WaitForSingleObjectEx returned:0x%08lx, error:%d"),
					Status, GetLastError()
                ));

            hr = E_FAIL; 
        }
	}

	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP, 
			TEXT("CSharedThreadProc: exiting ID: %d (0x%X) "),
			GetSharedThreadID(),
			GetSharedThreadID()
		));
	
	return(SUCCEEDED(hr)? 0 : 1);
}

BOOL
CSharedProc::CreateSharedProc(void *pv)
{
	if (m_hSharedThread) {
		DbgLog((
				LOG_TRACE, 
				LOG_DEVELOP, 
				TEXT("CSharedProc::CreateSharedProc: "
					 "already created: ThreadID: %d (0x%X)"),
				m_dwSharedThreadID, m_dwSharedThreadID
			));
		
		return(TRUE);
	}
	
	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP, 
			TEXT("CSharedProc::CreateSharedProc: creating...")
		));
	
	m_hSharedThread = CreateThread(
			NULL,
			0,
			CSharedProc::InitialThreadProc,
			pv,
			0,
			&m_dwSharedThreadID);

	if (m_hSharedThread) {
		DbgLog((
				LOG_TRACE, 
				LOG_DEVELOP, 
				TEXT("CSharedProc::CreateSharedProc: "
					 "new ThreadID: %d (0x%X)"),
				m_dwSharedThreadID, m_dwSharedThreadID
			));
	
		return(TRUE);
	}

	DbgLog((
			LOG_ERROR, 
			LOG_DEVELOP, 
			TEXT("CSharedProc::CreateSharedProc: "
				 "failed to create shared thread: %d"),
			GetLastError()
		));

	return(FALSE);
}

BOOL
CSharedProc::CloseSharedProc()
{
	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP2, 
			TEXT("CSharedProc::CloseSharedProc")
		));

	if (!m_hSharedThread)
		return(FALSE);

	if (m_lSharedCount)
		return(FALSE);

	// Actually close the thread because there are not
	// more thread to emulate.

	CallSharedWorker(CMD_EXIT_SHARED, NULL);

	WaitForSingleObject(m_hSharedThread, INFINITE);
	
	CloseHandle(m_hSharedThread);

	m_hSharedThread = NULL;

	return(TRUE);
}

BOOL
CSharedProc::AddShared(void *pv)
{
	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP2, 
			TEXT("CSharedProc::AddShared: 0x%X"),
			pv
		));

    CAutoLock LockThis(pCountLock());

	if (!CreateSharedProc(this))
			return(FALSE);

	InterlockedIncrement(&m_lSharedCount);
	InterlockedIncrement(&g_lClassesCount[GetSharedThreadClass()]);

	CallSharedWorker(CMD_INIT_SHARED, NULL);
		
	return(TRUE);
}

BOOL
CSharedProc::DelShared(void *pv)
{
	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP2, 
			TEXT("CSharedProc::DelShared: Context: 0x%X"),
			pv
		));

    CAutoLock LockThis(pCountLock());

	InterlockedDecrement(&m_lSharedCount);
	InterlockedDecrement(&g_lClassesCount[GetSharedThreadClass()]);
	
	return(TRUE);
}

DWORD
CSharedProc::CallSharedWorker(Command dwParam, void *pvContext)
{
	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP2, 
			TEXT("CSharedProc::CallSharedWorker")
		));

    // lock access to the worker thread for scope of this object
    CAutoLock lock(pStateLock());

    // set the parameter
    m_dwParam = dwParam;

    // set the context parameter
    m_pvContext = pvContext;

    // signal the worker thread
    m_EventSend.Set();

    // wait for the completion to be signalled
    m_EventComplete.Wait();

    // done - this is the thread's return value
    return(m_dwReturnVal);
}

void
CSharedProc::Reply(DWORD dw)
{
	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP2, 
			TEXT("CSharedProc::Reply")
		));

    m_dwReturnVal = dw;

    m_EventSend.Reset();

    m_EventComplete.Set();
}

/*********************************************************************
 * CSharedSourceStream implemtation
 *********************************************************************/

CSharedSourceStream::CSharedSourceStream(TCHAR *pObjectName,
										 HRESULT *phr,
										 CSource *pms,
										 LPCWSTR pName)
	: CSourceStream(pObjectName, phr, pms, pName),
	  m_pCSharedProc(NULL),
	  m_fReceiveCanBlock(1)
{
	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP, 
			TEXT("CSharedSourceStream::CSharedSourceStream")
		));
}

CSharedSourceStream::~CSharedSourceStream()
{
	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP, 
			TEXT("CSharedSourceStream::~CSharedSourceStream")
		));

}

BOOL
CSharedSourceStream::Create()
{
	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP2, 
			TEXT("CSharedSourceStream::Create")
		));

	if (IsConnected()) {
		
		IPin * pIPin = GetConnected();

		if (pIPin) {
			HRESULT hr;
			IMemInputPin *pInputPin;
		
			hr = pIPin->QueryInterface(IID_IMemInputPin,
									   (void **)&pInputPin);
			
			if (SUCCEEDED(hr)) {

				hr = pInputPin->ReceiveCanBlock();
				pInputPin->Release();

				if (hr != S_FALSE) {
					DbgLog((
							LOG_TRACE, 
							LOG_DEVELOP, 
							TEXT("CSharedSourceStream::Create: "
								 "Receive CAN block")
						));
					m_fReceiveCanBlock = 1;
				} else {
					DbgLog((
							LOG_TRACE, 
							LOG_DEVELOP, 
							TEXT("CSharedSourceStream::Create: "
								 "Receive CAN NOT block")
						));
					m_fReceiveCanBlock = 0;
				}
			}
		}
	}

	GetClassPriority(&m_lSharedSourceClass, &m_lSharedSourcePriority);
	
	m_pCSharedProc = CreateSharedContext(!m_fReceiveCanBlock,
										 m_lSharedSourceClass,
										 m_lSharedSourcePriority);

	if (!m_pCSharedProc)
		return(FALSE);
		
	if ( !(m_pCSharedProc->AddShared(this)) )
		return(FALSE);

	return(TRUE);
}

void
CSharedSourceStream::Close()
{
	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP2, 
			TEXT("CSharedSourceStream::Close")
		));

	if (m_pCSharedProc) {

		m_pCSharedProc->DelShared(this);
		
		if (m_pCSharedProc->CloseSharedProc())
			DeleteSharedContext(m_pCSharedProc);
	}
	
	m_pCSharedProc = NULL;
}

HRESULT
CSharedSourceStream::Active()
{
	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP2, 
			TEXT("CSharedSourceStream::Active")
		));

	CAutoLock lock(m_pFilter->pStateLock());

    HRESULT hr;

    if (m_pFilter->IsActive()) {
		return S_FALSE;
		// succeeded, but did not allocate resources (they already exist...)
    }

    // do nothing if not connected - its ok not to connect to
    // all pins of a source filter
    if (!IsConnected()) {
        return NOERROR;
    }

    hr = CBaseOutputPin::Active();
    if (FAILED(hr)) {
        return hr;
    }

    ASSERT(!ThreadExists());

    // start the thread
    if (!Create()) {
        return E_FAIL;
    }

    // Tell thread to initialize. If OnThreadCreate Fails, so does this.
    hr = Init();
    if (FAILED(hr))
		return hr;

    return Pause();
}

HRESULT
CSharedSourceStream::Inactive()
{
	DbgLog((
			LOG_TRACE, 
			LOG_DEVELOP2, 
			TEXT("CSharedSourceStream::Inactive")
		));
	
    CAutoLock lock(m_pFilter->pStateLock());

    HRESULT hr;

    // do nothing if not connected - its ok not to connect to
    // all pins of a source filter
    if (!IsConnected()) {
        return NOERROR;
    }

    // !!! need to do this before trying to stop the thread, because
    // we may be stuck waiting for our own allocator!!!

	// call this first to Decommit the allocator
    hr = CBaseOutputPin::Inactive();
    if (FAILED(hr)) {
		return hr;
    }

    if (ThreadExists()) {
		hr = Stop();

		if (FAILED(hr)) {
			return hr;
		}

		hr = Exit();
		if (FAILED(hr)) {
			return hr;
		}

		Close();	// Wait for the thread to exit, then tidy up.
    }

    return NOERROR;
}

// ThreadExists
// Return TRUE if the thread exists. FALSE otherwise
BOOL
CSharedSourceStream::ThreadExists(void) const
{
	if (m_pCSharedProc)
		return( (m_pCSharedProc->GetSharedThreadHandle() != NULL) );
	else
		return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpss\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sidlg.rc
//
#define IDSBASE_AMRTPSS                 3200

#define IDS_SILENCE                     3201
#define IDS_ERROR_CAPTION				3202
#define IDS_ERROR_POSTPLAY				3204
#define IDS_ERROR_KEEPPLAY  			3205
#define IDS_ERROR_THRESHOLDINC  		3206
#define IDS_ERROR_BASETHRESHOLD			3207
#define IDD_SILENCE                     102
#define IDC_POSTPLAY                    1002
#define IDC_KEEPPLAY                    1003
#define IDC_THRESHOLDINC                1004
#define IDC_BASETHRESHOLD               1005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpnet\template.h ===
/*********************************************************************
 *
 * Copyright (C) Microsoft Corporation, 1997 - 1999
 *
 * File: amrtpnet\template.h
 *
 * Abstract:
 *     Macros to define CFactoryTemplate templates
 *
 * History:
 *     10/22/97    Created by AndresVG
 *
 **********************************************************************/
#if !defined(_AMRTPNET_TEMPLATE_H_)
#define      _AMRTPNET_TEMPLATE_H_

extern WCHAR                    g_VendorInfo[];
extern AMOVIESETUP_MEDIATYPE    g_RtpInputType;
extern AMOVIESETUP_MEDIATYPE    g_RtpOutputType;
extern AMOVIESETUP_PIN          g_RtpInputPin;
extern AMOVIESETUP_PIN          g_RtpOutputPin;
extern AMOVIESETUP_FILTER       g_RtpRenderFilter;
extern AMOVIESETUP_FILTER       g_RtpSourceFilter;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Filter and Pin Names                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define RTP_PIN_ANY             L""
#define RTP_PIN_INPUT           L"Input"
#define RTP_PIN_OUTPUT          L"Output"
#define RTP_RENDER_FILTER       L"RTP Render Filter"
#define RTP_SOURCE_FILTER       L"RTP Source Filter"
#define RTP_FILTER_VENDOR_INFO  L"Microsoft RTP Network Filters"
#define RTP_STREAM              L"RTP Stream"
#define RTCP_STREAM             L"RTCP Stream"

#define CFT_AMRTPNET_RTP_RENDER_FILTER \
{ \
	  RTP_RENDER_FILTER, \
	  &CLSID_RTPRenderFilter, \
	  CRtpRenderFilter::CreateInstance, \
	  NULL, \
	  &g_RtpRenderFilter \
	  }

#define CFT_AMRTPNET_RTP_SOURCE_FILTER \
{ \
	  RTP_SOURCE_FILTER, \
	  &CLSID_RTPSourceFilter, \
	  CRtpSourceFilter::CreateInstance, \
	  NULL, \
	  &g_RtpSourceFilter \
	  }

#define CFT_AMRTPNET_RTP_RENDER_FILT_PROP \
{ \
	  RTP_RENDER_FILTER, \
	  &CLSID_RTPRenderFilterProperties, \
	  CRtpRenderFilterProperties::CreateInstance, \
	  }

#define CFT_AMRTPNET_ALL_FILTERS \
CFT_AMRTPNET_RTP_RENDER_FILTER, \
CFT_AMRTPNET_RTP_SOURCE_FILTER, \
CFT_AMRTPNET_RTP_RENDER_FILT_PROP

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpss\siprop.h ===
//
// siprop.h - Copyright (C) Microsoft Corporation, 1996 - 1999
//

///////////////////////////////////////////////////////////////////////////////
//=============================================================================
// Class Definitions
//=============================================================================
///////////////////////////////////////////////////////////////////////////////
#if !defined(_SIPROP_H_)
#define      _SIPROP_H_

class CSilenceProperties : public CBasePropertyPage
{
public:
    CSilenceProperties(LPUNKNOWN lpUnk, HRESULT *phr);
    static CUnknown * CALLBACK CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnApplyChanges();
    INT_PTR OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
	// ZCS 7-24-97: changed Count to Time    
	DWORD m_dwPrePlayTimeCurrent;
    DWORD m_dwPostPlayTimeCurrent;
	DWORD m_dwKeepPlayTimeCurrent;
	DWORD m_dwThresholdIncCurrent;
	DWORD m_dwBaseThresholdCurrent;

    ISilenceSuppressor *m_pSilenceSuppressor;

    void SetDirty();

	// ZCS 7-25-97
	typedef HRESULT (__stdcall ISilenceSuppressor::*SetMethod)(DWORD);
	typedef HRESULT (__stdcall ISilenceSuppressor::*GetMethod)(LPDWORD);
	HRESULT ChangeProperty(SetMethod pfSetMethod, DWORD *pSetting, int iControl,
						   GetMethod pfGetMethod, UINT uiText, UINT uiCaption);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\litesabr\filters\amrtpss\template.h ===
/*********************************************************************
 *
 * Copyright (C) Microsoft Corporation, 1997 - 1999
 *
 * File: amrtpss\template.h
 *
 * Abstract:
 *     Macros to define CFactoryTemplate templates
 *
 * History:
 *     10/24/97    Created by AndresVG
 *
 **********************************************************************/
#if !defined(_AMRTPSS_TEMPLATE_H_