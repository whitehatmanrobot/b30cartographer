-------------------------------------------------------------------------

void
CExtendedTagNamespaceBuiltin::Passivate()
{
    int                         i;
    CExtendedTagDescBuiltin **  ppTagDescBuiltin;

    for (i = 0, ppTagDescBuiltin = _aryItemsBuiltin; i < BUILTIN_COUNT; i++, ppTagDescBuiltin++)
    {
        if (*ppTagDescBuiltin)
        {
            (*ppTagDescBuiltin)->Release();
        }
    }

    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagNamespaceBuiltin::FindTagDesc
//
//-------------------------------------------------------------------------

CExtendedTagDesc *
CExtendedTagNamespaceBuiltin::FindTagDesc(LPTSTR pchTagName)
{
    HRESULT                     hr;
    CExtendedTagDesc *          pTagDesc = NULL;
    const CTagDescBuiltin *     pTagDescBuiltin;
    CExtendedTagDescBuiltin **  ppTagDesc;

    pTagDesc = super::FindTagDesc(pchTagName);

    if (!pTagDesc)
    {
        pTagDescBuiltin = GetTagDescBuiltin(pchTagName, _pTable);

        if (pTagDescBuiltin)
        {
            Assert (ARRAY_SIZE(_aryItemsBuiltin) == ARRAY_SIZE(g_aryTagDescsBuiltin) - 1);

            ppTagDesc = &_aryItemsBuiltin[GetTagDescBuiltinIdx(pTagDescBuiltin)];

            if (!(*ppTagDesc))
            {
                *ppTagDesc = new CExtendedTagDescBuiltin();
                if (!(*ppTagDesc))
                    goto Cleanup;

                hr = THR((*ppTagDesc)->Init(this, pTagDescBuiltin));
                if (hr)
                    goto Cleanup;

            }

            pTagDesc = *ppTagDesc;
        }
    }

Cleanup:
    return pTagDesc;
}

///////////////////////////////////////////////////////////////////////////
//
//  Class:      CExtendedTagTable
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable constructor
//
//-------------------------------------------------------------------------

CExtendedTagTable::CExtendedTagTable (CDoc * pDoc, CMarkup * pMarkup, BOOL fShareBooster)
{
    _pDoc = pDoc;
    _pMarkup = pMarkup;

    _fShareBooster = fShareBooster;

    // NOTE normally, CExtendedTabTable can't outlive CHtmInfo,
    // and CHtmInfo can't outlive markup and doc. However, this assumption
    // changes when the table pointer is handed out to anyone. Then _pDoc
    // and _pMarkup pointers have to be AddRef-ed. The problem in doing this
    // right here in constructor is that it is often called on tokenizer thread.
    // AddRef-ing doc and markup here would be a cross thread access in those cases,
    // which is not safe and therefore not allowed. Instead, _pDoc and _pMarkup are
    // AddRef-ed whenever the table is handed out to anyone (controlled by
    // EnsureContextLifetime).
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable destructor
//
//-------------------------------------------------------------------------

CExtendedTagTable::~CExtendedTagTable ()
{
    int         c;
    CItem **    ppItem;

    for (ppItem = _aryItems, c = _aryItems.Size(); 0 < c; ppItem++, c--)
    {
        (*ppItem)->_pTable = NULL;
        if ((*ppItem)->_pCollectionItem && (*ppItem)->_pCollectionItem->_cDownloads > 0)
        {
            (*ppItem)->SyncAbort();
            (*ppItem)->Sync2();
        }
        (*ppItem)->Release();
    }
    _aryItems.DeleteAll();

    if (_pNamespaceBuiltin)
        _pNamespaceBuiltin->Release();

    if (_fContextLifetimeEnsured)
    {
        _pDoc->SubRelease();
        if (_pMarkup)
            _pMarkup->SubRelease();
    }

    delete _pBooster;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::QueryInterface, per IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::QueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;

    EnsureContextLifetime();

    switch (iid.Data1)
    {
    QI_INHERITS((IElementNamespaceTable*)this, IUnknown)
    QI_INHERITS(this, IElementNamespaceTable)
    QI_INHERITS(this, IOleCommandTarget)
    }

    if (*ppv)
    {
        EnsureContextLifetime();

        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN (E_NOTIMPL);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::EnsureContextLifetime, helper
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::EnsureContextLifetime()
{
    HRESULT     hr = S_OK;

    if (!_fContextLifetimeEnsured)
    {
        _fContextLifetimeEnsured = TRUE;
        _pDoc->SubAddRef();
        if (_pMarkup)
            _pMarkup->SubAddRef();
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::EnsureBooster
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::EnsureBooster(CExtendedTagTableBooster ** ppBooster)
{
    HRESULT     hr = S_OK;
    CMarkup *   pMarkup;

    Assert (ppBooster);

    *ppBooster = NULL;

    if (_fShareBooster)
    {
        Assert (_pDoc->_dwTID == GetCurrentThreadId());

        Assert (_pMarkup);
        Assert (!_pBooster);

        if (!_pFrameOrPrimaryMarkup)
        {
            _pFrameOrPrimaryMarkup = _pMarkup->GetFrameOrPrimaryMarkup();
        }
        pMarkup = _pFrameOrPrimaryMarkup;

        Assert (pMarkup);

        hr = THR(pMarkup->EnsureExtendedTagTableBooster(ppBooster));
    }
    else
    {
        if (!_pBooster)
        {
            _pBooster = new CExtendedTagTableBooster();
            if (!_pBooster)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }

        *ppBooster = _pBooster;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::ClearBooster
//
//-------------------------------------------------------------------------

void
CExtendedTagTable::ClearBooster()
{
    delete _pBooster;
    _pBooster = NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::GetHint
//
//-------------------------------------------------------------------------

LONG
CExtendedTagTable::GetHint(LPCVOID pv, LPTSTR pch)
{
    CExtendedTagTableBooster * pBooster;

    IGNORE_HR(EnsureBooster(&pBooster));

    if (pBooster)
    {
        return pBooster->GetHint(pv, pch);
    }
    else
    {
        return -1;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::SetHint
//
//-------------------------------------------------------------------------

void
CExtendedTagTable::SetHint(LPCVOID pv, LPTSTR pch, LONG idx)
{
    CExtendedTagTableBooster * pBooster;

    IGNORE_HR(EnsureBooster(&pBooster));

    if (pBooster)
    {
        pBooster->SetHint(pv, pch, idx);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::CreateNamespaceBuiltin, helper
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::CreateNamespaceBuiltin(LPTSTR pchNamespace, CExtendedTagNamespace ** ppNamespace)
{
    HRESULT     hr = S_OK;

    Assert (ppNamespace);

    if (_pNamespaceBuiltin && pchNamespace &&
        0 != StrCmpIC (_pNamespaceBuiltin->_cstrNamespace, pchNamespace))
    {
        _pNamespaceBuiltin->Release();
        _pNamespaceBuiltin = NULL;
    }

    if (!_pNamespaceBuiltin)
    {
        _pNamespaceBuiltin = new CExtendedTagNamespaceBuiltin(this);
        if (!_pNamespaceBuiltin)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pNamespaceBuiltin->Init(pchNamespace, DEFAULT_NAMESPACE_URN));
    }

Cleanup:
    *ppNamespace = _pNamespaceBuiltin;

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::CreateNamespace, helper
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::CreateNamespace(LPTSTR pchNamespace, LPTSTR pchUrn, CExtendedTagNamespace ** ppNamespace)
{
    HRESULT                     hr = S_OK;
    BOOL                        fDefaultUrn;
    CExtendedTagNamespace *     pNamespace = NULL;

    Assert (ppNamespace);
    *ppNamespace = NULL;

    fDefaultUrn = IsDefaultUrn(pchUrn);

    if (!fDefaultUrn)
    {
        pNamespace = new CExtendedTagNamespace(this);
        if (!pNamespace)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pNamespace->Init(pchNamespace, pchUrn));
        if (hr)
            goto Cleanup;

        hr = THR(_aryItems.AppendIndirect(&pNamespace));
        if (hr)
            goto Cleanup;

        _ppLastItem = &_aryItems[_aryItems.Size() - 1];
        Assert (*_ppLastItem);

#ifdef HASHBOOST
        SetHint(this, pchNamespace, _ppLastItem - &(_aryItems[0]));
#endif
    }
    else
    {
        // someone is giving default namespace different name
        hr = THR(CreateNamespaceBuiltin(pchNamespace, &pNamespace));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    *ppNamespace = pNamespace;

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::EnsureHostNamespaces
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::EnsureHostNamespaces()
{
    HRESULT                 hr = S_OK;
    LPTSTR                  pch0, pch1;
    CExtendedTagNamespace * pNamespace = NULL;

    if (!_fHostNamespacesEnsured && _pDoc->_cstrHostNS.Length())
    {
        _fHostNamespacesEnsured = TRUE;

        pch0 = _pDoc->_cstrHostNS;
        for (;;)
        {
            pch1 = StrChr(pch0, _T(';'));
            {
                CStringNullTerminator   term(pch1);

                hr = THR(CreateNamespace(pch0, /* pchUrn = */NULL, &pNamespace));
                if (hr)
                    goto Cleanup;

                pNamespace->_fAllowAnyTag = TRUE;
            }

            if (!pch1)
                break;

            Assert (_T(';') == (*pch1));

            pch0 = pch1 + 1;
        }
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::FindNamespace
//
//-------------------------------------------------------------------------

CExtendedTagNamespace *
CExtendedTagTable::FindNamespace (LPTSTR pchNamespace, LPTSTR pchUrn, LONG * pidx)
{
    HRESULT                 hr;
    int                     c;
    int                     cchNamespace = pchNamespace ? _tcslen(pchNamespace) : 0;
    int                     cchUrn = pchUrn ? _tcslen(pchUrn) : 0;
    CItem **                ppItem;
    CExtendedTagNamespace * pNamespace = NULL;
    BOOL                    fDefaultUrn = IsDefaultUrn(pchUrn, cchUrn);
    LONG                    idx;

    if (!pidx)
        pidx = &idx;

    if (pchNamespace && pchNamespace[0] && !fDefaultUrn)
    {
#ifdef HASHBOOST
        idx = GetHint(this, pchNamespace);
        if (0 <= idx && idx < _aryItems.Size())
        {
            _ppLastItem = &_aryItems[idx];
        }
#endif

        // check cached value
        if (_ppLastItem)
        {
            if ((*_ppLastItem)->Match(pchNamespace, cchNamespace, pchUrn, cchUrn))
            {
                TraceTag ((tagPeerExtendedTagTableBoosterResults, "CExtendedTagTable::FindNamespace:   HIT for %ls", pchNamespace));

                pNamespace = *_ppLastItem;
                *pidx = _ppLastItem - _aryItems;
                goto Cleanup; // done
            }
        }

        TraceTag ((tagPeerExtendedTagTableBoosterResults, "CExtendedTagTable::FindNamespace:   LOOKUP {%ld} for %ls", _aryItems.Size(), pchNamespace));

        // do the search BACKWARDS - to find recently added namespaces first
        // (this is (1) minor optimization, (2) functionality that a namespace
        // added later overrides previously added namespace)
        c = _aryItems.Size();
        for (ppItem = _aryItems + c - 1; 0 < c; ppItem--, c--)
        {
            if (ppItem != _ppLastItem &&
                (*ppItem)->Match(pchNamespace, cchNamespace, pchUrn, cchUrn))
            {
                // found
                _ppLastItem = ppItem;
                *pidx = _ppLastItem - _aryItems;
                pNamespace = *_ppLastItem;

#ifdef HASHBOOST
                SetHint(this, pchNamespace, _ppLastItem - &(_aryItems[0]));
#endif
                goto Cleanup; // done
            }
        }

        _ppLastItem = NULL;
    }

    // still not found

    // default namespace?
    if ((IsDefaultNamespace(pchNamespace) ||
         (_pNamespaceBuiltin && _pNamespaceBuiltin->Match(pchNamespace, cchNamespace, pchUrn, cchUrn))) &&
        (!pchUrn || fDefaultUrn) &&
        _pMarkup)
    {
        if (!_pNamespaceBuiltin)
        {
            // (the reason why this is ensured here instead of EnsureNamespace is to optimize logic when
            // the namespace is considered declared by default, when the table created. With such logic we
            // never get EnsureNamespace call, but we optimize and don't create namespace when the table is
            // created but rather do that lazily only when it is requested)
            hr = THR(CreateNamespaceBuiltin(DEFAULT_NAMESPACE, &pNamespace));
            if (hr)
                goto Cleanup;
        }

        pNamespace = _pNamespaceBuiltin;
        *pidx = -1;

        goto Cleanup; // done
    }

    // failed to find

Cleanup:

    return pNamespace;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::EnsureNamespace
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::EnsureNamespace (
    LPTSTR                      pchNamespace,
    LPTSTR                      pchUrn,
    CExtendedTagNamespace **    ppNamespace,
    BOOL *                      pfChange)
{
    HRESULT                     hr = S_OK;
    CExtendedTagNamespace *     pNamespace;
    BOOL                        fChange;

    if (!ppNamespace)
         ppNamespace = &pNamespace;

    if (!pfChange)
        pfChange = &fChange;

    *pfChange = FALSE;

    (*ppNamespace) = FindNamespace(pchNamespace, pchUrn);

    if (!(*ppNamespace))
    {
        *pfChange = TRUE;

        hr = THR(CreateNamespace(pchNamespace, pchUrn, ppNamespace));
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::FindTagDesc
//
//-------------------------------------------------------------------------

CExtendedTagDesc *
CExtendedTagTable::FindTagDesc(LPTSTR pchNamespace,
                               LPTSTR pchTagName,
                               BOOL * pfQueryHost /* = NULL */)
{
    CExtendedTagDesc *      pDesc = NULL;
    CExtendedTagNamespace * pNamespace = FindNamespace(pchNamespace, /* pchUrn = */NULL);

    Assert (pchTagName && pchTagName[0]);

    if( pfQueryHost )
    {
        Assert( this == _pDoc->_pExtendedTagTableHost || _pDoc->IsShut());
        *pfQueryHost = FALSE;
    }

    if (pNamespace)
    {
        if (pNamespace->_fAllowAnyTag)
        {
            IGNORE_HR(pNamespace->AddTagDesc(
                pchTagName, /* fOverride = */FALSE, /* pchBaseTagName = */ NULL, 0, &pDesc));
        }
        else
        {
            pDesc = pNamespace->FindTagDesc(pchTagName);
        }

        if( pfQueryHost && !pDesc && pNamespace->_fQueryForUnknownTags && !_pDoc->IsShut())
        {
            *pfQueryHost = TRUE;
        }
    }

    return pDesc;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::EnsureTagDesc
//
//-------------------------------------------------------------------------

CExtendedTagDesc *
CExtendedTagTable::EnsureTagDesc(LPTSTR pchNamespace, LPTSTR pchTagName, BOOL fEnsureNamespace)
{
    HRESULT                 hr;
    CExtendedTagDesc *      pDesc = NULL;
    CExtendedTagNamespace * pNamespace;

    if (fEnsureNamespace)
    {
        hr = EnsureNamespace(pchNamespace, /* pchUrn = */NULL, &pNamespace);
        if (hr)
            goto Cleanup;
    }
    else
    {
        pNamespace = FindNamespace(pchNamespace, /* pchUrn = */NULL);
    }

    Assert (pchTagName && pchTagName[0]);

    if (pNamespace)
    {
        IGNORE_HR(pNamespace->AddTagDesc(pchTagName, /* fOverride = */FALSE, /* pchBaseTagName = */ NULL, 0, &pDesc));
    }

Cleanup:
    return pDesc;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::SaveXmlNamespaceStdPIs
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::SaveXmlNamespaceStdPIs(CStreamWriteBuff * pStreamWriteBuff)
{
    HRESULT                     hr = S_OK;
    int                         c;
    CExtendedTagNamespace **    ppNamespace;

    for (ppNamespace = _aryItems, c = _aryItems.Size(); c; ppNamespace++, c--)
    {
        hr = THR(pStreamWriteBuff->EnsurePIsSaved(
            _pDoc, _pMarkup,
            (*ppNamespace)->_cstrNamespace, (*ppNamespace)->_cstrUrn,
            /* pchImplementation = */ NULL,
            XMLNAMESPACEDECL_STD));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::Exec
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::Exec(
    const GUID *    pguidCmdGroup,
    DWORD           nCmdID,
    DWORD           nCmdExecOpt,
    VARIANT *       pvarArgIn,
    VARIANT *       pvarArgOut)
{
    HRESULT     hr;

    if (!pguidCmdGroup)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (IsEqualGUID(CGID_XmlNamespaceMapping, *pguidCmdGroup))
    {
        hr = OLECMDERR_E_NOTSUPPORTED;

        switch (nCmdID)
        {
        case XMLNAMESPACEMAPPING_GETURN:

            if (!pvarArgOut ||                                              // if no out arg or
                !pvarArgIn ||                                               // no in arg or
                VT_BSTR != V_VT(pvarArgIn) ||                               // in arg is not a string or
                !V_BSTR(pvarArgIn) || 0 == ((LPTSTR)V_BSTR(pvarArgIn))[0])  // the string is empty
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            {
                LPTSTR                  pchNamespace;
                CExtendedTagNamespace * pNamespace;

                pchNamespace = V_BSTR(pvarArgIn);

                pNamespace = FindNamespace(pchNamespace, /* pchUrn = */NULL);
                if (pNamespace && pNamespace->_cstrUrn.Length())
                {
                    hr = THR(FormsAllocString(pNamespace->_cstrUrn, &V_BSTR(pvarArgOut)));
                }
                else
                {
                    V_BSTR(pvarArgOut) = NULL;
                    hr = S_OK;
                }
            }

            break;
        }
    }
    else
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::Exec
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::AddNamespace(BSTR bstrNamespace, BSTR bstrUrn, LONG lFlags, VARIANT * pvarFactory)
{
    HRESULT                         hr;
    HRESULT                         hr2;
    IElementBehaviorFactory *       pPeerFactory = NULL;
    IElementNamespaceFactory *      pNamespaceFactory = NULL;
    IElementNamespaceFactory2 *     pNSFactory2 = NULL;
    CPeerFactoryBinary *            pPeerFactoryBinary = NULL;
    CExtendedTagNamespace *         pNamespace = NULL;

    //
    // validate and process params
    //

    if (!bstrNamespace ||
        (pvarFactory && VT_UNKNOWN  != V_VT(pvarFactory) &&
                        VT_DISPATCH != V_VT(pvarFactory)) ||
        ( ( lFlags & ELEMENTNAMESPACEFLAGS_ALLOWANYTAG ) &&
          ( lFlags & ELEMENTNAMESPACEFLAGS_QUERYFORUNKNOWNTAGS ) ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr2 = THR(V_UNKNOWN(pvarFactory)->QueryInterface(IID_IElementNamespaceFactory2, (void**)&pNSFactory2));
    if (hr2)
    {
        hr = THR(V_UNKNOWN(pvarFactory)->QueryInterface(IID_IElementNamespaceFactory, (void**)&pNamespaceFactory));
        if (hr)
            goto Cleanup;
    }

    hr = THR(V_UNKNOWN(pvarFactory)->QueryInterface(IID_IElementBehaviorFactory, (void**)&pPeerFactory));
    if (hr)
        goto Cleanup;

    //
    // create peer factory holder
    //

    pPeerFactoryBinary = new CPeerFactoryBinary();
    if (!pPeerFactoryBinary)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pPeerFactoryBinary->Init(pPeerFactory));
    if (hr)
        goto Cleanup;

    //
    // create namespace and use factory to populate it
    //

    hr = THR(CreateNamespace(bstrNamespace, bstrUrn, &pNamespace));
    if (hr)
        goto Cleanup;

    hr = THR(pNamespace->SetFactory(pPeerFactoryBinary, /* fPeerFactoryUrl = */ FALSE));
    if (hr)
        goto Cleanup;

    if (lFlags & ELEMENTNAMESPACEFLAGS_ALLOWANYTAG)
    {
        pNamespace->_fAllowAnyTag = TRUE;
    }
    else if (lFlags & ELEMENTNAMESPACEFLAGS_QUERYFORUNKNOWNTAGS)
    {
        pNamespace->_fQueryForUnknownTags = TRUE;
    }
    pNamespace->_fNonPersistable = TRUE;

    {
        CExtendedTagNamespace::CExternalUpdateLock  updateLock(pNamespace, pPeerFactoryBinary);

        if( pNSFactory2 )
        {
            hr = THR(pNSFactory2->CreateWithImplementation(pNamespace, bstrUrn));
        }
        else
        {
            hr = THR(pNamespaceFactory->Create(pNamespace));
        }
    }

Cleanup:

    ReleaseInterface (pPeerFactory);
    ReleaseInterface (pNamespaceFactory);
    ReleaseInterface (pNSFactory2);

    if (pPeerFactoryBinary)
        pPeerFactoryBinary->Release();

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::Sync1
//
//              The synchronization sequence:
//              - on HtmPre thread, the PI token is tokenized, recognized and emitted
//              - on HtmPre thread, HtmPre is suspended
//              - on HtmPost/UI thread, the PI token is received
//              - on HtmPost/UI thread, RegisterExtendedTagNamespace is called
//                                      (that initializes _ppLastItem)
//              - on HtmPost/UI thread, Sync1 is called to mark item to synchronize and
//                                      launch synchronization with CPeerFactoryUrl object
//              - on HtmPost/UI thread, when CPeerFactoryUrl is ready, Sync2 is called.
//                                      Sync2 is also called to finish synchronization prematurely
//              - on HtmPost/UI thread, Sync2 resumes preparser and completes the synchronization
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::Sync1
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::Sync1(BOOL fSynchronous)
{
    HRESULT     hr = S_OK;
    BOOL        fForceComplete = FALSE;

    Assert (_ppLastItem);

    _pSyncItem = *_ppLastItem;

#if DBG == 1
    TraceNamespace(_T("CExtendedTagTable::Sync1"), _pSyncItem);
#endif

    if (_pSyncItem->_pPeerFactory)
    {
        Assert (_pSyncItem->_fPeerFactoryUrl);

        // after this call we expect to get called back to Sync2() to complete the sequence
        hr = THR_NOTRACE(_pSyncItem->Sync1(CExtendedTagNamespace::SYNCMODE_TABLE));
        switch (hr)
        {
        case S_OK:
            // assert that Sync2 has been called, as indicated by _pSyncItem cleared
            Assert (!_pSyncItem);
            break;

        case E_PENDING:
            if (!fSynchronous)
            {
                // the operation is not synchronous; we can wait until we will get called
                // to Sync2 later, asynchronously
                hr = S_OK;
            }
            else
            {   // the operation is synchronous, so we can't wait and have to abort
                // (this is not a normal codepath)
                hr = THR(_pSyncItem->SyncAbort());
                if (hr)
                    goto Cleanup;

                fForceComplete = TRUE;
            }
            break;

        default:
            goto Cleanup;
        }
    }
    else // if (!_pSyncItem->_pPeerFactoryUrl)
    {
        fForceComplete = TRUE;
    }

    if (fForceComplete)
    {
        hr = THR(Sync2());
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::Sync2
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTable::Sync2()
{
    HRESULT     hr = S_OK;

    Assert (_pSyncItem);

    _pSyncItem->ClearFactory();

    // wake up parser now
    _pMarkup->HtmCtx()->ResumeAfterImportPI();

#if DBG == 1
    TraceNamespace(_T("CExtendedTagTable::Sync2"), _pSyncItem);
#endif

    _pSyncItem = NULL;

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTable::GetNamespace
//
//-------------------------------------------------------------------------

CExtendedTagNamespace *
CExtendedTagTable::GetNamespace(LONG idx)
{
    if (idx < 0 || _aryItems.Size() <= idx)
        return NULL;

    return _aryItems[idx];
}



#ifdef GETDHELPER
//+----------------------------------------------------------------------------
//
//  Method:     CExtendedTagTable::GetExtendedTagDesc   (static)
//
//  Synopsis:   Helper function to deal with searching through various
//              ExtendedTagTables for a TagDesc.  There are basically 3 levels
//              to search:
//              1) A specific table.  This is the case in parsing, where the
//              CHtmInfo has a tag table related to that parse.
//              2) A context markup.  The context markup may have a table in
//              its behavior context, or in its HtmInfo if it has not yet
//              been transferred
//              3) The host table.  This is where hosts can add their own
//              namespaces.
//
//              If a host wants a query on a namespace, we won't ensure the
//              tag no matter what fEnsure says.
//
//  Returns:    CExtendedTagDesc * - ExtendedTagDesc, if found
//
//  Arguments:
//          CExtendedTagTable * pExtendedTagTable - First table to search
//          CMarkup * pMarkupContext - Context markup
//          CExtendedTagTable * pExtendedTagTableHost - Host tag table
//          LPTSTR * pchNamespace - Namespace
//          LPTSTR * pchTagName - Tag
//          BOOL     fEnsureTag - Ensure tag if not found
//          BOOL     fEnsureNamespace - Ensure namespace if necessary to ensure tag
//          BOOL   * pfQueryHost - Set if host wants a query for this namespace
//
//+----------------------------------------------------------------------------

CExtendedTagDesc *
CExtendedTagTable::GetExtendedTagDesc( CExtendedTagTable * pExtendedTagTable,       // First check this table
                                       CMarkup * pMarkupContext,                    // Then this context markup
                                       CExtendedTagTable * pExtendedTagTableHost,   // Then the host table
                                       LPTSTR   pchNamespace,                       // Namespace we're looking in
                                       LPTSTR   pchTagName,                         // Tag we're looking for
                                       BOOL     fEnsureTag,                         // Ensure tag if not found
                                       BOOL     fEnsureNamespace,                   // Ensure namespace if needed
                                       BOOL   * pfQueryHost )                       // Does host want a query for this?
{
    CExtendedTagDesc        *   pDesc;
    CExtendedTagTable       *   pExtendedTagTableMarkupContext = NULL;

    // Check arguments
    Assert( pExtendedTagTable || pMarkupContext );
    Assert( !fEnsureNamespace || fEnsureTag );

    // Initialize
    pDesc = NULL;
    if( pfQueryHost )
        *pfQueryHost = FALSE;

    // First check the specific tag table
    if( pExtendedTagTable )
    {
        pDesc = pExtendedTagTable->FindTagDesc( pchNamespace, pchTagName );
        if( pDesc )
            goto Cleanup;
    }

    // Then check the context markup
    if( pMarkupContext )
    {
        pDesc = pMarkupContext->GetExtendedTagDesc( pchNamespace, pchTagName );
        if( pDesc )
            goto Cleanup;
#if 0
        // The table may be in the behavior context or the HtmCtx
        if( pMarkupContext->BehaviorContext() &&
            pMarkupContext->BehaviorContext()->_pExtendedTagTable )
        {
            pExtendedTagTableMarkupContext = pMarkupContext->BehaviorContext()->_pExtendedTagTable;
        }
        else if( pMarkupContext->HtmCtx() )
        {
            pExtendedTagTableMarkupContext = pMarkupContext->HtmCtx()->GetExtendedTagTable();
        }

        if( pExtendedTagTableMarkupContext )
        {
            pDesc = pExtendedTagTableMarkupContext->FindTagDesc( pchNamespace, pchTagName );
            if( pDesc )
                goto Cleanup;
        }
#endif // 0
    }

    // Then check the host tag table
    if( pExtendedTagTableHost )
    {
        pDesc = pExtendedTagTableHost->FindTagDesc( pchNamespace, pchTagName, pfQueryHost );
        if( pDesc )
            goto Cleanup;
    }

    // If we were asked to ensure, and we're not waiting to query, then go ahead
    if( fEnsureTag && pExtendedTagTable && ( !pfQueryHost || FALSE == *pfQueryHost ) )
    {
        if( pExtendedTagTable )
        {
            Verify( pDesc = pExtendedTagTable->EnsureTagDesc( pchNamespace, pchTagName, fEnsureNamespace ) );
            if( pDesc )
                goto Cleanup;
        }
        else
        {
            Assert( pMarkupContext );
            Verify( pDesc = pMarkupContext->GetExtendedTagDesc( pchNamespace, pchTagName, TRUE ) );
            if( pDesc )
                goto Cleanup;
        }
    }

Cleanup:
    return pDesc;
}
#endif // GETDHELPER


//+----------------------------------------------------------------------------
//
//  Method:     CExtendedTagTable::ResolveUnknownTag
//
//  Synopsis:   Queries the host to see if they want to add the tag to the
//              table
//
//  Returns:    HRESULT
//
//  Arguments:
//          CHtmTag * pht - The tag to resolve
//
//+----------------------------------------------------------------------------

HRESULT
CExtendedTagTable::ResolveUnknownTag( CHtmTag * pht )
{
    HRESULT                     hr;
    IElementNamespaceFactoryCallback * pNSResolver = NULL;
    CExtendedTagDesc         *  pDesc;
    BSTR                        bstrHTMLString = NULL;
    BSTR                        bstrNamespace = NULL;
    BSTR                        bstrTagname = NULL;

    // Sanity check arguments
    Assert( this == _pDoc->_pExtendedTagTableHost );
    Assert( pht && pht->Is(ETAG_RAW_RESOLVE) && !pht->IsEnd() );

    pht->SetTag( ETAG_UNKNOWN );

    //
    // Cook up the HTML BSTR to pass.
    // Do this before we create the tagname cracker, just for simplicity
    //
    if( pht->GetAttrCount() )
    {
        long                        cchHTMLString = 0;
        ULONG                       cAttr;
        CHtmTag::CAttr           *  pAttr;
        TCHAR                    *  pch;

        for( cAttr = 0; cAttr < pht->GetAttrCount(); cAttr++ )
        {
            pAttr = pht->GetAttr(cAttr);
            cchHTMLString += 2 +                                // Two terminators
                             pAttr->_cchName +                  // Add the name
                             pAttr->_cchVal;                    // Add the value
        }

        // Allocate a BSTR of the right length, but don't do initialize it
        hr = THR( FormsAllocStringLen( NULL, cchHTMLString, &bstrHTMLString ) );
        if( hr )
            goto Cleanup;

        pch = bstrHTMLString;

        for( cAttr = 0; cAttr < pht->GetAttrCount(); cAttr++ )
        {
            pAttr = pht->GetAttr(cAttr);

            // Copy name
            memcpy( pch, pAttr->_pchName, pAttr->_cchName * sizeof( TCHAR ) );
            pch += pAttr->_cchName;
            *pch = _T('\0');
            pch += 1;

            // Copy the value
            memcpy( pch, pAttr->_pchVal, pAttr->_cchVal * sizeof( TCHAR ) );
            pch += pAttr->_cchVal;
            *pch = _T('\0');
            pch += 1;
        }

        // Terminate (I don't think this is necessary for BSTR)
        *pch = _T('\0');
    }

    {   // Scope for TagNameCracker
        CExtendedTagNamespace    *  pNamespace;
        CTagNameCracker             tagNameCracker( pht->GetPch() );

        pNamespace = FindNamespace( tagNameCracker._pchNamespace, NULL );

        Assert( pNamespace && pNamespace->_fQueryForUnknownTags );
        Assert( pNamespace && pNamespace->_pPeerFactory );

        hr = THR( pNamespace->_pPeerFactory->GetElementNamespaceFactoryCallback( &pNSResolver ) );
        if( hr )
            goto Cleanup;

        hr = THR( FormsAllocString( tagNameCracker._pchNamespace, &bstrNamespace) );
        if (hr)
            goto Cleanup;

        hr = THR( FormsAllocString( tagNameCracker._pchTagName, &bstrTagname) );
        if (hr)
            goto Cleanup;

        {   // Scope for ExternalUpdateLock
            CExtendedTagNamespace::CExternalUpdateLock  updateLock(pNamespace, pNamespace->_pPeerFactory);

            hr = THR( pNSResolver->Resolve( bstrNamespace, bstrTagname, bstrHTMLString, pNamespace ) );
            if( hr )
                goto Cleanup;
        }

        pDesc = pNamespace->FindTagDesc( tagNameCracker._pchTagName );
        if( !pDesc )
            goto Cleanup;
    }

    pht->SetTag( pDesc->_etagBase );
    pht->SetExtendedTag();

Cleanup:
    FormsFreeString( bstrHTMLString );
    FormsFreeString( bstrNamespace );
    FormsFreeString( bstrTagname );
    ReleaseInterface( pNSResolver );

    RRETURN( hr );
}

///////////////////////////////////////////////////////////////////////////
//
//  CHTMLNamespace
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace constructor
//
//-------------------------------------------------------------------------

CHTMLNamespace::CHTMLNamespace(CExtendedTagNamespace * pNamespace)
{
    Assert (pNamespace);
    _pNamespace = pNamespace;
    _pNamespace->AddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace destructor
//
//-------------------------------------------------------------------------

CHTMLNamespace::~CHTMLNamespace()
{
    _pNamespace->_pCollectionItem = NULL;
    _pNamespace->Release();
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::PrivateQueryInterface, per IUnknown
//
//-------------------------------------------------------------------------

//..todo move to core\include\qi_impl.h
#define Data1_IHTMLNamespace 0x3050f6bb

HRESULT
CHTMLNamespace::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    if(!ppv)
        return E_POINTER;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_INHERITS(this, IHTMLNamespace)
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::Create
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::Create (CExtendedTagNamespace * pNamespace, CHTMLNamespace ** ppHTMLNamespace, IDispatch ** ppdispHTMLNamespace)
{
    HRESULT                 hr;
    CHTMLNamespace *        pHTMLNamespace = NULL;
    CHTMLNamespace *        pHTMLNamespaceCreated = NULL;

    Assert (pNamespace);

    if (!ppHTMLNamespace)
        ppHTMLNamespace = &pHTMLNamespace;

    if (!pNamespace->_pCollectionItem)
    {
        pHTMLNamespaceCreated = pNamespace->_pCollectionItem = new CHTMLNamespace(pNamespace);
        if (!pHTMLNamespaceCreated)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    *ppHTMLNamespace = pHTMLNamespace = pNamespace->_pCollectionItem;

    Assert (pHTMLNamespace);

    hr = THR(pHTMLNamespace->PrivateQueryInterface(IID_IDispatch, (void**)ppdispHTMLNamespace));
    if (hr)
        goto Cleanup;

Cleanup:
    if (pHTMLNamespaceCreated)
        pHTMLNamespaceCreated->Release();

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::get_name, per IHTMLNamespace
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::get_name(BSTR * pbstrName)
{
    HRESULT     hr = E_NOTIMPL;

    Assert (_pNamespace && _pNamespace->_cstrNamespace.Length());

    if (!pbstrName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(FormsAllocString(_pNamespace->_cstrNamespace, pbstrName));

Cleanup:
    RRETURN (SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::get_urn, per IHTMLNamespace
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::get_urn(BSTR * pbstrUrn)
{
    HRESULT     hr = S_OK;

    Assert (_pNamespace);

    if (!pbstrUrn)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (_pNamespace->_cstrUrn)
    {
        hr = THR(FormsAllocString(_pNamespace->_cstrUrn, pbstrUrn));
    }
    else
    {
        *pbstrUrn = NULL;
    }

Cleanup:
    RRETURN (SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::get_tagNames, per IHTMLNamespace
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::get_tagNames(IDispatch ** ppdispTagNameCollection)
{
    HRESULT     hr = E_NOTIMPL;

    RRETURN (SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::get_readyState, helper
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::get_readyState(VARIANT * pvarRes)
{
    HRESULT hr = S_OK;

    if (!pvarRes)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(s_enumdeschtmlReadyState.StringFromEnum(_cDownloads ? READYSTATE_LOADING : READYSTATE_COMPLETE, &V_BSTR(pvarRes)));
    if (S_OK == hr)
        V_VT(pvarRes) = VT_BSTR;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::doImport, helper
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::doImport(BSTR bstrImplementationUrl)
{
    HRESULT     hr = S_OK;

    //TODO understand and get rid of this
#if 1
    if (0 == StrCmpIC(bstrImplementationUrl, _T("null")))
        bstrImplementationUrl = NULL;
#endif

    if (!bstrImplementationUrl)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(Import(bstrImplementationUrl));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::Import, helper
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::Import(LPTSTR pchImplementationUrl)
{
    HRESULT     hr;

    if( !_pNamespace->_pTable )
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    hr = THR(_pNamespace->SetFactory(_pNamespace->_pTable->_pMarkup, pchImplementationUrl));
    if (hr ||                           // if fatal failure or
        !_pNamespace->_pPeerFactory)    // could not create factory (non existent file? security error?)
    {
        goto Cleanup;                   // bail out
    }

    if (0 == _cDownloads)
    {
        Fire_onreadystatechange();
    }

    _cDownloads++;

    // expected return values are S_OK and E_PENDING
    hr = THR(_pNamespace->Sync1(CExtendedTagNamespace::SYNCMODE_COLLECTIONITEM));
    if (E_PENDING == hr)
    {
        hr = S_OK;
    }

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::OnImportComplete, helper
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::OnImportComplete()
{
    HRESULT     hr = S_OK;

    _cDownloads--;

    Assert (0 <= _cDownloads);

    if (0 == _cDownloads)
    {
        Fire_onreadystatechange();
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::attachEvent, helper
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::attachEvent(BSTR bstrEvent, IDispatch * pdispFunc, VARIANT_BOOL * pResult)
{
    RRETURN(super::attachEvent(bstrEvent, pdispFunc, pResult));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::detachEvent, helper
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespace::detachEvent(BSTR bstrEvent, IDispatch * pdispFunc)
{
    RRETURN(super::detachEvent(bstrEvent, pdispFunc));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespace::Fire_onreadystatechange
//
//-------------------------------------------------------------------------

void
CHTMLNamespace::Fire_onreadystatechange()
{
    if (_pNamespace && _pNamespace->_pTable)
    {
        FireEvent(Doc(), NULL, _pNamespace->_pTable->_pMarkup, DISPID_EVMETH_ONREADYSTATECHANGE, DISPID_EVPROP_ONREADYSTATECHANGE, _T("readystatechange"));
    }
}


///////////////////////////////////////////////////////////////////////////
//
//  CHTMLNamespaceCollection
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection constructor
//
//-------------------------------------------------------------------------

CHTMLNamespaceCollection::CHTMLNamespaceCollection(CExtendedTagTable * pTable)
{
    Assert (pTable);
    _pTable = pTable;
    _pTable->AddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection destructor
//
//-------------------------------------------------------------------------

CHTMLNamespaceCollection::~CHTMLNamespaceCollection()
{
    _pTable->_pCollection = NULL;
    _pTable->Release();
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection::PrivateQueryInterface
//
//-------------------------------------------------------------------------

//..todo move to core\include\qi_impl.h
#define Data1_IHTMLNamespaceCollection 0x3050f6b8

HRESULT
CHTMLNamespaceCollection::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    if(!ppv)
        return E_POINTER;

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_INHERITS(this, IHTMLNamespaceCollection)
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection::Create
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespaceCollection::Create (CMarkup * pMarkup, IDispatch ** ppdispCollection)
{
    HRESULT                     hr = E_UNEXPECTED;
    CExtendedTagTable *         pTable;
    CMarkupBehaviorContext *    pContext;
    CHTMLNamespaceCollection *  pCollection = NULL;
    CHTMLNamespaceCollection *  pCollectionCreated = NULL;

    Assert (pMarkup);

    //
    // get or ensure the table in the right place
    //

    if (pMarkup->LoadStatus() < LOADSTATUS_DONE && pMarkup->HtmCtx() )
    {
        Assert (pMarkup->HtmCtx());

        hr = THR(pMarkup->HtmCtx()->EnsureExtendedTagTable(&pTable));
        if (hr)
            goto Cleanup;
    }
    else
    {
        Assert (LOADSTATUS_DONE <= pMarkup->LoadStatus() ||
                LOADSTATUS_UNINITIALIZED == pMarkup->LoadStatus() && !pMarkup->HtmCtx());

        Assert (pMarkup->Doc()->_dwTID == GetCurrentThreadId());

        // ensure behavior context
        hr = THR(pMarkup->EnsureBehaviorContext(&pContext));
        if (hr)
            goto Cleanup;

        // ensure the table in the context
        if (!pContext->_pExtendedTagTable)
        {
            pContext->_pExtendedTagTable = new CExtendedTagTable(pMarkup->Doc(), pMarkup, /* fShareBooster =*/TRUE);
            if (!pContext->_pExtendedTagTable)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }

        // get the table
        pTable = pContext->_pExtendedTagTable;
    }

    Assert (pTable);

    //
    // ensure collection for the table
    //

    if (!pTable->_pCollection)
    {
        pCollectionCreated = pTable->_pCollection = new CHTMLNamespaceCollection(pTable);
        if (!pCollectionCreated)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pTable->EnsureContextLifetime();
    }

    pCollection = pTable->_pCollection;

    Assert (pCollection);

    //
    // return the collection
    //

    hr = THR(pCollection->PrivateQueryInterface(IID_IDispatch, (void**)ppdispCollection));

Cleanup:
    if (pCollectionCreated)
        pCollectionCreated->Release();

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection::get_length
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespaceCollection::get_length(LONG * plLength)
{
    HRESULT     hr = S_OK;

    if (!plLength)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert (_pTable);

    *plLength = _pTable->_aryItems.Size();

Cleanup:
    RRETURN (SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection::item
//
//  TODO VARIANT -> VARIANT*
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespaceCollection::item (VARIANT varIndex, IDispatch** ppNamespace)
{
    HRESULT     hr;
    VARIANT     varRes;

    if (!ppNamespace)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(GetItemHelper(&varIndex, &varRes));
    if (hr)
        goto Cleanup;

    Assert (VT_DISPATCH == V_VT(&varRes));

    *ppNamespace = V_DISPATCH(&varRes);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection::add
//
//  TODO VARIANT -> VARIANT*
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespaceCollection::add(BSTR bstrNamespace, BSTR bstrUrn, VARIANT varImplementationUrl, IDispatch ** ppdispHTMLNamespace)
{
    HRESULT                     hr = E_NOTIMPL;
    CExtendedTagNamespace *     pNamespace;
    CHTMLNamespace *            pHTMLNamespace;
    LPTSTR                      pchImplementationUrl = NULL;

    //TODO understand and get rid of this
#if 1
    if (bstrNamespace && 0 == StrCmpIC(bstrNamespace, _T("null")))
        bstrUrn = NULL;
    if (bstrUrn && 0 == StrCmpIC(bstrUrn, _T("null")))
        bstrUrn = NULL;
#endif

    if (!bstrNamespace || !ppdispHTMLNamespace)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert (_pTable);

    switch (V_VT(&varImplementationUrl))
    {
    case VT_BSTR:
    case VT_LPWSTR:
        pchImplementationUrl = V_BSTR(&varImplementationUrl);
        break;

    case VT_NULL:
    case VT_EMPTY:
    case VT_ERROR:
        break;

    default:
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(_pTable->EnsureNamespace(bstrNamespace, bstrUrn, &pNamespace));
    if (hr)
        goto Cleanup;

    Assert (pNamespace);

    hr = THR(CHTMLNamespace::Create(pNamespace, &pHTMLNamespace, ppdispHTMLNamespace));
    if (hr)
        goto Cleanup;



    if (pchImplementationUrl)
    {
        hr = THR(pHTMLNamespace->Import(pchImplementationUrl));
        if(hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN (SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection::FindByName
//
//-------------------------------------------------------------------------

LONG
CHTMLNamespaceCollection::FindByName(LPCTSTR pchName, BOOL fCaseSensitive)
{
    LONG        idx = -1;

    Assert (_pTable);

    _pTable->FindNamespace((LPTSTR)pchName, /* pchUrn = */NULL, &idx);

    return idx;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection::GetName
//
//-------------------------------------------------------------------------

LPCTSTR
CHTMLNamespaceCollection::GetName(LONG idx)
{
    CExtendedTagNamespace *     pNamespace = _pTable->GetNamespace(idx);

    if (!pNamespace)
        return NULL;

    return pNamespace->_cstrNamespace;
}

//+------------------------------------------------------------------------
//
//  Member:     CHTMLNamespaceCollection::GetItem
//
//-------------------------------------------------------------------------

HRESULT
CHTMLNamespaceCollection::GetItem(LONG idx, VARIANT * pvar)
{
    HRESULT                     hr = S_OK;
    CExtendedTagNamespace *     pNamespace = _pTable->GetNamespace(idx);

    if (!pNamespace)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // (if pvar is NULL, we are just validating index. TODO (alexz) perf?)

    if (pvar)
    {
        V_VT(pvar) = VT_DISPATCH;

        hr = THR(CHTMLNamespace::Create(pNamespace, NULL, &V_DISPATCH(pvar)));
    }

Cleanup:
    RRETURN (hr);
}

///////////////////////////////////////////////////////////////////////////
//
//  CExtendedTagTableBooster
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTableBooster constructor
//
//-------------------------------------------------------------------------

CExtendedTagTableBooster::CExtendedTagTableBooster()
{
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTableBooster destructor
//
//-------------------------------------------------------------------------

CExtendedTagTableBooster::~CExtendedTagTableBooster()
{
    ResetMap();
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTableBooster::ResetMap
//
//-------------------------------------------------------------------------

void
CExtendedTagTableBooster::ResetMap()
{
    delete _pMap;
    _pMap = NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTableBooster::EnsureMap
//
//-------------------------------------------------------------------------

HRESULT
CExtendedTagTableBooster::EnsureMap()
{
    HRESULT hr = S_OK;

    if (!_pMap)
    {
        _pMap = new CStringTable(CStringTable::CASEINSENSITIVE);
        if (!_pMap)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTableBooster::GetHint
//
//-------------------------------------------------------------------------

LONG
CExtendedTagTableBooster::GetHint(LPCVOID pv, LPTSTR pch)
{
    HRESULT     hr2;
    LONG        idx;

    hr2 = THR(EnsureMap());
    if (hr2)
    {
        idx = -1;
        goto Cleanup;
    }

    hr2 = THR_NOTRACE(_pMap->Find(pch, (LPVOID*)&idx, /* pvAdditionalKey =*/pv));
    if (hr2)
        idx = -1;

Cleanup:
    TraceTag((
        tagPeerExtendedTagTableBooster,
        "CExtendedTagTableBooster::GetHint: %ls idx = %ld for [%lx] %ls",
        (LPTSTR)((-1 == idx) ? _T("MISS,") : _T("HIT, ")),
        idx, pv, pch));

    return idx;
}

//+------------------------------------------------------------------------
//
//  Member:     CExtendedTagTableBooster::SetHint
//
//-------------------------------------------------------------------------

void
CExtendedTagTableBooster::SetHint(LPCVOID pv, LPTSTR pch, LONG idx)
{
    HRESULT     hr2;

    Assert (-1 != idx);

    hr2 = THR(EnsureMap());
    if (hr2)
        goto Cleanup;

    IGNORE_HR(_pMap->Add(pch, LongToPtr(idx), /* pvAdditionalKey =*/pv));

    TraceTag((
        tagPeerExtendedTagTableBooster,
        "CExtendedTagTableBooster::SetHint: SET,  idx = %ld for [%lx] %ls",
        idx, pv, pch));

Cleanup:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\perhist.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       perhist.cxx
//
//  Contents:   IPersistHistory implementation
//
//  Classes:    CDoc (partial), CHistoryLoadCtx, CHistorySaveCtx
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_BOOKMARK_HXX_
#define X_BOOKMARK_HXX_
#include "bookmark.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

MtDefine(CHistoryLoadCtx, Dwn, "CHistoryLoadCtx");
MtDefine(CHistoryLoadCtx_arySubstreams_pv, CHistoryLoadCtx, "CHistoryLoadCtx::_arySubstreams::_pv");
MtDefine(COptionArray, Dwn, "COptionArray");
MtDefine(COptionArray_aryOption_pv, COptionArray, "COptionArray::_aryOption::_pv");
MtDefine(COptionArrayItem, COptionArray, "COptionArray item");
MtDefine(LOADINFO_pbRequestHeaders, Dwn, "LOADINFO::pbRequestHeaders");
MtDefine(LoadFailureUrl,CMarkup, "CMarkup::LoadFailureUrl");

BOOL IsInIEBrowser(CDoc * pDoc);

//+------------------------------------------------------------------------
//
//  Class:      CDoc (IPersistHistory implementation)
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CDoc::GetPositionCookie
//
//  Synopsis:   implementation of IPersistHistory::GetPositionCookie
//
//-------------------------------------------------------------------------
HRESULT
CDoc::GetPositionCookie(DWORD *pdwCookie)
{
    return _pWindowPrimary->Window()->GetPositionCookie(pdwCookie);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::SetPositionCookie
//
//  Synopsis:   implementation of IPersistHistory::SetPositionCookie
//
//-------------------------------------------------------------------------
HRESULT
CDoc::SetPositionCookie(DWORD dwCookie)
{
    return _pWindowPrimary->Window()->SetPositionCookie(dwCookie);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::SaveHistory
//
//  Synopsis:   implementation of IPersistHistory::SaveHistory
//
//-------------------------------------------------------------------------
HRESULT
CDoc::SaveHistory(IStream *pStream)
{
    RRETURN(_pWindowPrimary->Window()->SaveHistory(pStream));
}

//
// In LoadHistoryInternal sometimes we have the wrong value for fNonHTMLMimeType
// In code is designed for this to true for XML, but it is false. 
// In the XML case this is good because we end up remembering the filters HTML data,
// and it would be inefficient to FollowHyperLink.
//
// This method is designed to check the problematic case where we have a nonHTMLType 
// being recalled from history by the travellog. In this case certain nonHTML file types are 
// will break navigation. We know that VBD do. Unfortunately, at this point it the code we only have
// the URL on which to guess the mime type. In future version, we should store the source 
// files mime type. 
//
// For now we will use this function to test if we have mime type
// that is known to cause problems. 
//

BOOL IsKnownNonHTMLMime(const TCHAR * pszURL)
{
    const TCHAR * pszDot = NULL;
    const TCHAR * pszCurrent = pszURL;

    int nLen = 0;

    if (pszURL)
    {
        nLen = _tcslen(pszURL);

        for (int i=0; i < nLen; i++)
        {
            if ((*pszCurrent) == _TEXT('.'))
            {
                pszDot = pszCurrent;              // remember the last dot
            }                                     // before the ? or #
            else if ((*pszCurrent) == _TEXT('?') ||
                     (*pszCurrent) == _TEXT('#')) 
            {
                i = nLen;
            }

            pszCurrent++;
        }
    }

    if (pszDot == NULL) 
    {
        return FALSE;
    }

    // Use >=4 instead of ==4 to account for the query string or bookmark after the extension
    if (nLen - (pszDot - pszURL) >= 4)
    {
        if (_tcsnicmp(pszDot, 4, _T(".vbd"), -1) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::SaveHistory
//
//  Synopsis:   does SaveHistory but also takes an additional bool
//
//-------------------------------------------------------------------------
HRESULT
CMarkup::SaveHistoryInternal(IStream *pStream, DWORD dwOptions)
{
    HRESULT          hr          = S_OK;
    HRESULT          hr2         = S_OK;
    IStream *        pSubstream  = NULL;
    IStream *        pStmSource  = NULL;
    IMoniker *       pmkName = NULL;
    CHistorySaveCtx  hsc;
    DWORD            dwScrollPos = 0;
    DWORD            dwPosition;
    CLSID            clsidMk = {0};
    BOOL             fDoDefault = TRUE;
    CHtmCtx *        pHtmCtx = HtmCtx();
    THREADSTATE    * pts = GetThreadState();
    CMarkup::CLock   markupLock(this);
    COmWindowProxy * pWindowPrxy;
    CTaskLookForBookmark * pBookmarkTask = NULL;    

    if (!pStream)
        return E_POINTER;

    {
        CDataStream ds(pStream);
        IStream * pStmDirty = GetStmDirty();

        // save dirty stream
        if (pStmDirty)
        {
            ULARGE_INTEGER uliSize;

            hr = THR(ds.SaveDword(HISTORY_STMDIRTY));
            if (hr)
                goto Cleanup;

            hr = THR(ds.BeginSaveSubstream(&pSubstream));
            if (hr)
                goto Cleanup;

            hr = THR(pStmDirty->Seek(LI_ZERO.li, STREAM_SEEK_END, &uliSize));
            if (hr)
                goto Cleanup;

            hr = THR(pStmDirty->Seek(LI_ZERO.li, STREAM_SEEK_SET, NULL));
            if (hr)
                goto Cleanup;

            hr = THR(pStmDirty->CopyTo(pSubstream, uliSize, NULL, NULL));
            if (hr)
                goto Cleanup;

            pSubstream->Release();
            pSubstream = NULL;

            hr = THR(ds.EndSaveSubstream());
            if (hr)
                goto Cleanup;
        }
        // In the case of a document.open'ed doc, save the source
        else if (pHtmCtx && pHtmCtx->WasOpened())
        {
            hr = THR(ds.SaveDword(HISTORY_STMDIRTY));
            if (hr)
                goto Cleanup;

            hr = THR(ds.BeginSaveSubstream(&pSubstream));
            if (hr)
                goto Cleanup;

            if (!pHtmCtx->IsSourceAvailable())
                hr = THR(SaveToStream(pSubstream, 0, GetCodePage()));
            else
                hr = THR(pHtmCtx->CopyOriginalSource(pSubstream, 0));

            if (hr)
                goto Cleanup;

            pSubstream->Release();
            pSubstream = NULL;

            hr = THR(ds.EndSaveSubstream());
            if (hr)
                goto Cleanup;
        }

        // If the document was really just a repository for a refresh stream
        // then save the refresh stream
        if (pHtmCtx && pHtmCtx->IsKeepRefresh() && pHtmCtx->GetRefreshStream())
        {
            hr = THR(pHtmCtx->GetRefreshStream()->Clone(&pStmSource));
            if (hr)
                goto Cleanup;

            ULARGE_INTEGER uliSize;
            uliSize.HighPart = uliSize.LowPart = 0xFFFFFFFF;

            hr = THR(ds.SaveDword(HISTORY_STMREFRESH));
            if (hr)
                goto Cleanup;

            hr = THR(ds.BeginSaveSubstream(&pSubstream));
            if (hr)
                goto Cleanup;

            hr = THR(pStmSource->CopyTo(pSubstream, uliSize, NULL, NULL));
            if (hr)
                goto Cleanup;

            pSubstream->Release();
            pSubstream = NULL;

            pStmSource->Release();
            pStmSource = NULL;

            hr = THR(ds.EndSaveSubstream());
            if (hr)
                goto Cleanup;
        }

        if ((  pHtmCtx
            && pHtmCtx->FromMimeFilter())
            || (IsPrimaryMarkup() && Doc()->IsAggregated()))
        {
            // If original page came from a mime filter,
            // be sure to bind on apt when refreshing so that
            // urlmon can hook up the mime filter again

            hr = THR(ds.SaveDword(HISTORY_BINDONAPT));
            if (hr)
                goto Cleanup;
        }

        pmkName = GetNonRefdMonikerPtr();

        // TODO (JHarding): Should we even try creating this now?
        if( !pmkName )
            hr = CreateURLMoniker(NULL, CMarkup::GetUrl(this), &pmkName);
        else
            pmkName->AddRef();

        if (pmkName && S_OK != IsAsyncMoniker(pmkName))
        {
            hr = THR(ds.SaveDword(HISTORY_PMKNAME));
            if (hr)
                goto Cleanup;

            hr = THR(ds.SaveDataLater(&dwPosition, sizeof(hr2)));
            if (hr)
                goto Cleanup;

            hr2 = THR(pmkName->GetClassID(&clsidMk));

            hr = THR(ds.SaveData(&clsidMk, sizeof(CLSID)));
            if (hr)
                goto Cleanup;

            hr = THR(ds.BeginSaveSubstream(&pSubstream));
            if (hr)
                goto Cleanup;

            if (!hr2)
                hr2 = THR(pmkName->Save(pSubstream, FALSE));

            pSubstream->Release();
            pSubstream=NULL;

            hr = THR(ds.EndSaveSubstream());
            if (hr)
                goto Cleanup;

            hr = THR(ds.SaveDataNow(dwPosition, &hr2, sizeof(hr2)));
            if (hr)
                goto Cleanup;
        }
            // TODO (jbeda) hacking because
            // of PICS with window.open
        else if (!_fPICSWindowOpenBlank)
        {
            const TCHAR * pchUrl = GetUrl(this);

            if (pchUrl && *pchUrl)
            {
                hr = THR(ds.SaveDword(HISTORY_PCHURL));
                if (hr)
                    goto Cleanup;

                hr = THR(ds.SaveString((TCHAR*)pchUrl));
                if (hr)
                    goto Cleanup;
            }

            const TCHAR * pchUrlOriginal = GetUrlOriginal(this);

            if (pchUrlOriginal && *pchUrlOriginal)
            {
                hr = THR(ds.SaveDword(HISTORY_PCHURLORIGINAL));
                if (hr)
                    goto Cleanup;

                hr = THR(ds.SaveString((TCHAR*)pchUrlOriginal));
                if (hr)
                    goto Cleanup;
            }

            const TCHAR * pchUrlLocation = GetUrlLocation(this);

            if (pchUrlLocation && *pchUrlLocation)
            {
                hr = THR(ds.SaveDword(HISTORY_PCHURLLOCATION));
                if (hr)
                    goto Cleanup;

                hr = THR(ds.SaveString((TCHAR*)pchUrlLocation));
                if (hr)
                    goto Cleanup;
            }
        }

        // save postdata
        if (GetDwnPost() && GetDwnPost()->ShouldSave())
        {
            hr = THR(ds.SaveDword(HISTORY_POSTDATA));
            if (hr)
                goto Cleanup;

            hr = THR(ds.BeginSaveSubstream(&pSubstream));
            if (hr)
                goto Cleanup;

            hr = THR(CDwnPost::Save(GetDwnPost(), pSubstream));
            if (hr)
                goto Cleanup;

            hr = THR(ds.EndSaveSubstream());
            if (hr)
                goto Cleanup;

            pSubstream->Release();
            pSubstream = NULL;
        }

        CDwnDoc * pDwnDoc = GetDwnDoc();

        // save referers
        if (pDwnDoc)
        {
            if (pDwnDoc->GetDocReferer())
            {
                hr = THR(ds.SaveDword(HISTORY_PCHDOCREFERER));
                if (hr)
                    goto Cleanup;

                hr = THR(ds.SaveString((TCHAR *)pDwnDoc->GetDocReferer()));
                if (hr)
                    goto Cleanup;
            }

            if (pDwnDoc->GetSubReferer())
            {
                hr = THR(ds.SaveDword(HISTORY_PCHSUBREFERER));
                if (hr)
                    goto Cleanup;

                hr = THR(ds.SaveString((TCHAR *)pDwnDoc->GetSubReferer()));
                if (hr)
                    goto Cleanup;
            }
        }

        // Save Last-mod date of doc into history
        {
            FILETIME ftLastMod = GetLastModDate();
            hr = THR(ds.SaveDword(HISTORY_FTLASTMOD));
            if (hr)
                goto Cleanup;

            hr = THR(ds.SaveData(&ftLastMod, sizeof(FILETIME)));
            if (hr)
                goto Cleanup;
        }

        // Save echo headers as raw headers
        if (dwOptions & SAVEHIST_ECHOHEADERS)
        {
            BYTE *pb;
            ULONG cb;

            // TODO (johnbed) 03/26/98
            // Outlook 98 ends up somehow creating a new CDoc after
            // exec'ing a IDM_SAVEAS with a null _pHtmCtx. This code
            // is called while setting mshtml into edit mode.
            // There don't appear to be any problems with just falling
            // out here and continuing on.

            if (pHtmCtx)
            {
                pHtmCtx->GetRawEcho(&pb, &cb);

                if (pb && cb)
                {
                        hr = THR(ds.SaveDword(HISTORY_REQUESTHEADERS));

                        if (hr)
                                goto Cleanup;

                        hr = THR(ds.SaveDword(cb));

                        if (hr)
                                goto Cleanup;

                        hr = THR(ds.SaveData(pb, cb));

                        if (hr)
                                goto Cleanup;
                }
            }
        }

        // Save codepage of URL.
        hr = THR(ds.SaveDword(HISTORY_HREFCODEPAGE));
        if (hr)
            goto Cleanup;

        hr = THR(ds.SaveDword(GetURLCodePage()));
        if (hr)
            goto Cleanup;

        // Save default codepage of the document. Can be overridden by the shell, hlink etc.
        hr = THR(ds.SaveDword(HISTORY_CODEPAGE));
        if (hr)
            goto Cleanup;

        hr = THR(ds.SaveDword(GetCodePage()));
        if (hr)
            goto Cleanup;

        // if this markup is in a frame, save the Navigated bit of that frame so
        // that favorites can do the correct thing.
        if (HasWindowPending())
        {
            CWindow * pWindow = GetWindowPending()->Window();

            if (pWindow && pWindow->_fNavigated)
            {
                hr = THR(ds.SaveDword(HISTORY_NAVIGATED));
                if (hr)
                    goto Cleanup;
                hr = THR(ds.SaveDword(1));
                if (hr)
                    goto Cleanup;
            }
        }

        // provide oppurtunity to save user data, and cancel defualt
        // behavior
        if (dwOptions & SAVEHIST_INPUT)
        {
            NOTIFYTYPE      snType; 
            CNotification   nf;
            CMarkupBehaviorContext * pContext = NULL;

            // it he meta persist tag is not specified then do the default handling
            // see the coimment for the else clause for how history is handled when 
            //  the persistence XTag is enabled.
            CElement * pElemCurrent;
            long lSubCurrent;

            fDoDefault = !MetaPersistEnabled(htmlPersistStateHistory);
            pElemCurrent = Doc()->_pElemCurrent;
            lSubCurrent = Doc()->_lSubCurrent;

            THR(EnsureBehaviorContext(&pContext));
            
            // now worry about default/user input saving
            if (fDoDefault)
            {
                if (pElemCurrent->GetMarkup() == this)
                {
                    // Save the current site's index and tag

                    hr = THR(ds.SaveDword(HISTORY_CURRENTSITE));
                    if (hr)
                        goto Cleanup;

                    hr = THR(ds.SaveDword(pElemCurrent->GetSourceIndex()));
                    if (hr)
                        goto Cleanup;

                    hr = THR(ds.SaveDword(pElemCurrent->HistoryCode()));
                    if (hr)
                        goto Cleanup;

                    hr = THR(ds.SaveDword(lSubCurrent));
                    if (hr)
                        goto Cleanup;
                }    

                // now set up for the saving the control's values
                snType = NTYPE_SAVE_HISTORY_1;
            } // fDoDefault
            else
            {
                // now set up for the saving the control's values
                // using the persistence XTAG
                // The way that the persistence XTag works for history is that 
                // a SN_XTAGPERSISTHISTORY is broadcast. Elements with the History
                // XTag peer will repsond, by fireing their events, and by doing a 
                // BroadcastNotify(NTYPE_SAVE_HISTORY) on their scoped elements.  All this goes
                // into the stream under their ID.
                snType = NTYPE_XTAG_HISTORY_SAVE;
                // make sure this is cleared out..

                if (pContext)
                {
                    ClearInterface(&(pContext->_pXMLHistoryUserData));
                }
            }

            // save substreams by doing a BroadcastNotify
            hr = THR(ds.SaveDword(HISTORY_STMHISTORY));
            if (hr)
                goto Cleanup;

            hr = THR(ds.BeginSaveSubstream(&pSubstream));
            if (hr)
                goto Cleanup;

            hr = THR(hsc.Init(pSubstream));
            if (hr)
                goto Cleanup;

            ClearInterface(&pSubstream);

            hsc._dwOptions = dwOptions;
            nf.Initialize(
                snType, 
                Root(), 
                Root()->GetFirstBranch(),
                &hsc,
                0);
            Notify(&nf);

            hr = THR(hsc.Finish());
            if (hr)
                goto Cleanup;

            hr = THR(ds.EndSaveSubstream());
            if (hr)
                goto Cleanup;

            // now that the elements have all had their turn at saveing thier contents
            //  if the XTags saved a bucket of data, we need to save that too.
            if (snType==NTYPE_XTAG_HISTORY_SAVE && pContext && pContext->_pXMLHistoryUserData)
            {
                BSTR                bstrTemp = NULL;
                UINT                uSize    = 0;

                // get the text of the XML document
                hr = THR(pContext->_pXMLHistoryUserData->get_xml(&bstrTemp));
                if (hr)
                    goto LocalCleanup;

                // how big is the data?
                uSize = (1+SysStringLen(bstrTemp))*sizeof(OLECHAR);
                if (uSize < PERSIST_XML_DATA_SIZE_LIMIT)
                {
                    hr = THR(ds.SaveDword(HISTORY_USERDATA));
                    if (hr)
                        goto LocalCleanup;

                    hr = THR(ds.SaveString(bstrTemp));
                    if (hr) 
                        goto LocalCleanup;                
                }
LocalCleanup:
                SysFreeString(bstrTemp);
                // we don't need this around anymore
                ClearInterface(&(pContext->_pXMLHistoryUserData));
            }
        }

        //  Check for an active bookmark task. If we have one,
        //  use that instead of the current scroll position.

        pBookmarkTask = ( HasTransNavContext() ? 
                            GetTransNavContext()->_pTaskLookForBookmark : 
                            NULL );

        if(pBookmarkTask)
        {
            Assert(!(pBookmarkTask->_dwScrollPos && pBookmarkTask->_cstrJumpLocation));
            if(pBookmarkTask->_cstrJumpLocation)
            {
                // Save the document scroll position
                hr = THR(ds.SaveDword(HISTORY_BOOKMARKNAME));
                if (hr)
                    goto Cleanup;

                hr = THR(ds.SaveString((TCHAR *)pBookmarkTask->_cstrJumpLocation));
                if (hr)
                    goto Cleanup;
            }
            else if(pBookmarkTask->_dwScrollPos)
            {
                // Save the document scroll position
                hr = THR(ds.SaveDword(HISTORY_SCROLLPOS));
                if (hr)
                    goto Cleanup;

                hr = THR(ds.SaveDword(pBookmarkTask->_dwScrollPos));
                if (hr)
                    goto Cleanup;
            }
        }
        else if(dwOptions & SAVEHIST_INPUT)
        {
            // Save the document scroll position
            hr = THR(ds.SaveDword(HISTORY_SCROLLPOS));
            if (hr)
                goto Cleanup;

            IGNORE_HR(GetPositionCookie(&dwScrollPos));
            hr = THR(ds.SaveDword(dwScrollPos));
            if (hr)
                goto Cleanup;
        }

        // Save default codepage of the document. Can be overridden by the shell, hlink etc.
        hr = THR(ds.SaveDword(HISTORY_FONTVERSION));
        if (hr)
            goto Cleanup;

        hr = THR(ds.SaveDword(pts->_iFontHistoryVersion));  // save current font history version
        if (hr)
            goto Cleanup;

        // Save the document's direction. Can be overridden if a direction is explicitly given
        // in the HTML
        hr = THR(ds.SaveDword(HISTORY_DOCDIRECTION));
        if (hr)
            goto Cleanup;

        // TODO (jharding, scotrobe): The below line of code used to crash in stress 
        // because it was using HasWindow() to check for a window. HasWindow()
        // is returning TRUE (in stress) when there is no window. This code
        // now checks for the window by calling Window(). This will be changed
        // back to HasWindow() when the real culprit is found.
        //
        Assert(!HasWindow() || Window());
        pWindowPrxy = Window();

        WORD eHTMLDocDir = pWindowPrxy ? pWindowPrxy->Document()->_eHTMLDocDirection : htmlDirNotSet;

        hr = THR(ds.SaveData(&eHTMLDocDir, sizeof(WORD)));
        if (hr)
            goto Cleanup;

        // Save the window ID
        //
        if (pWindowPrxy)
        {
            hr = THR(ds.SaveDword(HISTORY_WINDOWID));
            if (hr)
                goto Cleanup;

            hr = THR(ds.SaveDword(pWindowPrxy->Window()->GetWindowIndex()));
            if (hr)
                goto Cleanup;

            const TCHAR * pchUrlOriginal = GetUrlOriginal(this);

            if (pWindowPrxy->Window()->_punkViewLinkedWebOC || 
                IsXML() || 
                _pDoc->_fDelegatedDownload ||
                IsKnownNonHTMLMime(pchUrlOriginal))
            {
                hr = THR(ds.SaveDword(HISTORY_NONHTMLMIMETYPE));
                if (hr)
                    goto Cleanup;
            }

            if (_pDoc->IsAggregated())
            {
                CStr & cstrName = pWindowPrxy->Window()->_cstrName;

                if (!cstrName.IsNull())
                {
                    hr = THR(ds.SaveDword(HISTORY_PCHFRAMENAME));
                    if (hr)
                        goto Cleanup;

                    hr = THR(ds.SaveString((TCHAR*)cstrName));
                    if (hr)
                        goto Cleanup;
                }
            }

            if (pWindowPrxy->Window()->_fNavFrameCreation)
            {             
                hr = THR(ds.SaveDword(HISTORY_FRAMECREATION));
                if (hr)
                    goto Cleanup;
            }

            if (pWindowPrxy->Window()->_fHttpErrorPage
                || _fServerErrorPage)
            {
                hr = THR(ds.SaveDword(HISTORY_ERRORPAGE));
                if (hr)
                    goto Cleanup;                
            }
        }
        else if (_fServerErrorPage)
        {
            hr = THR(ds.SaveDword(HISTORY_ERRORPAGE));
            if (hr)
                goto Cleanup;        
        }


        // Save creator url
        {
            const TCHAR * pchCreatorUrl = GetAAcreatorUrl();

            if (pchCreatorUrl && *pchCreatorUrl)
            {
                hr = THR(ds.SaveDword(HISTORY_CREATORURL));
                if (hr)
                    goto Cleanup;

                hr = THR(ds.SaveString((TCHAR*)pchCreatorUrl));
                if (hr)
                    goto Cleanup;
            }
        }       
            
        // Save history end marker
        hr = THR(ds.SaveDword(HISTORY_END));
        if (hr)
            goto Cleanup;
    }


Cleanup:
    ReleaseInterface(pSubstream);
    ReleaseInterface(pStmSource);
    ReleaseInterface(pmkName);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::LoadHistory
//
//  Synopsis:   implementation of IPersistHistory::LoadHistory
//
//-------------------------------------------------------------------------
HRESULT
CDoc::LoadHistory(IStream *pStream, IBindCtx *pbc)
{
    HRESULT hr;

    hr = THR(_pWindowPrimary->Window()->LoadHistory(pStream, pbc));

    if (_state < OS_LOADED)
        _state = OS_LOADED;

    if (OK(hr))
    {
        if (State() < OS_RUNNING)
        {
            IGNORE_HR(TransitionTo(OS_RUNNING));
        }
        else if (State() >= OS_UIACTIVE)
        {
            SetActiveObject();
        }
    }

    RRETURN(hr);

}

//----------------------------------------------------------------
//****************************************************************
// Making changes to history ? Also update CWindow::GetURLFromIStreamHelper
//****************************************************************
//----------------------------------------------------------------

HRESULT
CMarkup::LoadHistoryHelper(IStream        * pStream,
                           IBindCtx       * pbc,
                           DWORD            dwBindf,
                           IMoniker       * pmkHint,
                           IStream        * pstmLeader,
                           CDwnBindData   * pDwnBindData,
                           CODEPAGE         codepage,
                           ULONG          * pulHistoryScrollPos,
                           TCHAR         ** ppchBookMarkName,
                           CDoc::LOADINFO * pLoadInfo,
                           BOOL           * pfNonHTMLMimeType)
{
    HRESULT         hr = S_OK;
    HRESULT         hr2;
    HISTORY_CODE    historyCode;
    DWORD           dwCodePage;
    CLSID           clsidMk;
    IStream        *pSubstream = NULL;    

    CDataStream ds(pStream);

    for (;;)
    {
        hr = THR(ds.LoadDword((DWORD*)&historyCode));
        if (hr)
            goto Cleanup;

        switch (historyCode)
        {
        case HISTORY_STMREFRESH:
            hr = THR(ds.LoadSubstream(&pSubstream));
            if (hr)
                goto Cleanup;

            // Yes, recursive call
            hr = THR(LoadHistoryHelper(pSubstream,
                                       pbc,
                                       dwBindf,
                                       pmkHint,
                                       pstmLeader,
                                       pDwnBindData,
                                       codepage,
                                       pulHistoryScrollPos,
                                       ppchBookMarkName,
                                       pLoadInfo,
                                       pfNonHTMLMimeType));

            ClearInterface(&pSubstream);

            goto Cleanup;
            break;

        case HISTORY_STMDIRTY:
            ClearInterface(&pLoadInfo->pstmDirty);
            hr = THR(ds.LoadSubstream(&pLoadInfo->pstmDirty));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_PCHFILENAME:
            hr = THR(ds.LoadString(&pLoadInfo->pchFile));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_PCHURL:
            hr = THR(ds.LoadString(&pLoadInfo->pchDisplayName));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_PCHURLORIGINAL:
            hr = THR(ds.LoadString(&pLoadInfo->pchUrlOriginal));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_PCHURLLOCATION:
            hr = THR(ds.LoadString(&pLoadInfo->pchLocation));
            if( hr )
                goto Cleanup;
            break;

        case HISTORY_NAVIGATED:
            { 
                DWORD dwNavigated = 0;

                hr = THR(ds.LoadDword(&dwNavigated));
                if (hr)
                    goto Cleanup;

                if (HasWindowPending())
                    GetWindowPending()->Window()->NoteNavEvent();
            }
            break;

        case HISTORY_PMKNAME:
            hr = THR(ds.LoadDword((DWORD*)&hr2));
            if (hr)
                goto Cleanup;

            hr = THR(ds.LoadData(&clsidMk, sizeof(CLSID)));
            if (hr)
                goto Cleanup;

            hr = THR(ds.LoadSubstream(&pSubstream));
            if (hr)
                goto Cleanup;

            ClearInterface(&pLoadInfo->pmk);

            if (hr2)
            {
                // failed to get clsid or save to stream before...
                // but on refresh, we have a live moniker we can use instead
                if (pmkHint)
                {
                    pmkHint->AddRef();
                    pLoadInfo->pmk = pmkHint;
                }
            }
            else
            {
                hr = THR(CoCreateInstance(clsidMk, NULL, CLSCTX_INPROC_SERVER, IID_IMoniker, (void**)&pLoadInfo->pmk));
                if (hr)
                    goto Cleanup;
                hr = THR(pLoadInfo->pmk->Load(pSubstream));
                if (hr)
                    goto Cleanup;
            }

            pSubstream->Release();
            pSubstream = NULL;
            break;
        
        case HISTORY_BINDONAPT:
            pLoadInfo->fBindOnApt = TRUE;
            break;

        case HISTORY_POSTDATA:

            hr = THR(ds.LoadSubstream(&pSubstream));
            if (hr)
                goto Cleanup;

            if (pLoadInfo->pDwnPost)
            {
                pLoadInfo->pDwnPost->Release();
                pLoadInfo->pDwnPost = NULL;
            }

            hr = THR(CDwnPost::Load(pSubstream, &pLoadInfo->pDwnPost));
            if (hr)
                goto Cleanup;

            pSubstream->Release();
            pSubstream = NULL;

            break;

        case HISTORY_PCHDOCREFERER:
            hr = THR(ds.LoadString(&pLoadInfo->pchDocReferer));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_PCHSUBREFERER:
            hr = THR(ds.LoadString(&pLoadInfo->pchSubReferer));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_FTLASTMOD:
            hr = THR(ds.LoadData(&pLoadInfo->ftHistory, sizeof(FILETIME)));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_CURRENTSITE:
            {
                CMarkupTransNavContext * ptnc = EnsureTransNavContext();
                if (!ptnc)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                hr = THR(ds.LoadDword((DWORD *)&ptnc->_historyCurElem.lIndex));
                if (hr)
                    goto Cleanup;
                hr = THR(ds.LoadDword(&ptnc->_historyCurElem.dwCode));
                if (hr)
                    goto Cleanup;
                hr = THR(ds.LoadDword((DWORD *)&ptnc->_historyCurElem.lSubDivision));
                if (hr)
                    goto Cleanup;

                ptnc->_fDoDelayLoadHistory = TRUE;
            }
            break;

        case HISTORY_SCROLLPOS:
            hr = THR(ds.LoadDword(pulHistoryScrollPos));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_BOOKMARKNAME:
            hr = THR(ds.LoadString(ppchBookMarkName));
            if ( hr )
                goto Cleanup;
            break;

        case HISTORY_STMHISTORY:
            ClearInterface(&pLoadInfo->pstmHistory);
            hr = THR(ds.LoadSubstream(&pLoadInfo->pstmHistory));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_HREFCODEPAGE:
            hr = THR(ds.LoadDword(&dwCodePage));
            if (hr)
                goto Cleanup;
            pLoadInfo->codepageURL = (CODEPAGE)dwCodePage;
            break;

        case HISTORY_CODEPAGE:
            hr = THR(ds.LoadDword(&dwCodePage));
            if (hr)
                goto Cleanup;
            pLoadInfo->codepage = (CODEPAGE)dwCodePage;
            break;

        case HISTORY_USERDATA :
            Assert(!pLoadInfo->pchHistoryUserData);
            hr = THR(ds.LoadString(&pLoadInfo->pchHistoryUserData));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_REQUESTHEADERS:
            MemFree(pLoadInfo->pbRequestHeaders);
            pLoadInfo->pbRequestHeaders = NULL;
            hr = THR(ds.LoadDword(&pLoadInfo->cbRequestHeaders));
            if (hr)
                goto Cleanup;
            pLoadInfo->pbRequestHeaders = (BYTE*)MemAlloc(Mt(LOADINFO_pbRequestHeaders), pLoadInfo->cbRequestHeaders);
            if (!pLoadInfo->pbRequestHeaders)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            hr = THR(ds.LoadData(pLoadInfo->pbRequestHeaders, pLoadInfo->cbRequestHeaders));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_FONTVERSION:
            {
                LONG iFontHistoryVersion = -1;
                hr = THR(ds.LoadDword((DWORD *) &iFontHistoryVersion));
                if (hr)
                    goto Cleanup;
                IGNORE_HR(SetFontHistoryIndex(iFontHistoryVersion));
                break;
            }

        case HISTORY_DOCDIRECTION:
            hr = THR(ds.LoadData(&pLoadInfo->eHTMLDocDirection, sizeof(WORD)));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_WINDOWID:
            { 
                DWORD dwWindowID = 0;

                hr = THR(ds.LoadDword(&dwWindowID));
                if (hr)
                    goto Cleanup;

                if (HasWindowPending())
                    GetWindowPending()->Window()->SetWindowIndex(dwWindowID);
            }
            break;

        case HISTORY_NONHTMLMIMETYPE:
            if (pfNonHTMLMimeType)
                *pfNonHTMLMimeType = TRUE;
            break;
            
        case HISTORY_FRAMECREATION:
            
            if (HasWindowPending())
               GetWindowPending()->Window()->_fNavFrameCreation = TRUE;
            break;

        case HISTORY_CREATORURL:
            {
                TCHAR * pchCreatorUrl = NULL;
                  
                hr = THR(ds.LoadString(&pchCreatorUrl));
                if (hr)
                    goto Cleanup;
                
                if (pchCreatorUrl && *pchCreatorUrl)
                    SetAAcreatorUrl (pchCreatorUrl);

                delete pchCreatorUrl;
            }
            break;

        case HISTORY_ERRORPAGE:
            _fServerErrorPage = TRUE;
            break;

        case HISTORY_PCHFRAMENAME:
            {
                LPTSTR pchFrameName = NULL;

                hr = THR(ds.LoadString(&pchFrameName));
                if (hr)
                    goto Cleanup;

                if (HasWindowPending())
                {
                    IGNORE_HR(GetWindowPending()->Window()->_cstrName.Set(pchFrameName));
                }

                MemFreeString(pchFrameName);

                break;
            }        
        
        case HISTORY_END:
            goto Cleanup;
#if DBG==1
        default:
            AssertSz( FALSE, "Unknown code found in history!" );
            break;
#endif // DBG
        }
    }

Cleanup:
    ClearInterface(&pSubstream);
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::LoadHistoryInternal
//
//  Synopsis:   Does a LoadHistory; but also takes BINDF flags
//
//-------------------------------------------------------------------------
HRESULT
CMarkup::LoadHistoryInternal(IStream      * pStream,
                             IBindCtx     * pbc,
                             DWORD          dwBindf,
                             IMoniker     * pmkHint,
                             IStream      * pstmLeader,
                             CDwnBindData * pDwnBindData,
                             CODEPAGE       codepage,
                             CElement     * pElementMaster, /*=NULL*/
                             DWORD          dwFlags, /* = 0 */
                             const TCHAR *  pchName /*=NULL*/)

{
    HRESULT          hr                 = S_OK;
    CDoc::LOADINFO   LoadInfo           = { 0 };
    IStream        * pSubstream         = NULL;
    ULONG            ulHistoryScrollPos = 0;
    TCHAR          * pchBookMarkName    = NULL;
    BOOL             fNonHTMLMimeType   = FALSE;
    BOOL             fCancel            = FALSE;
    COmWindowProxy * pOmWindowPending   = GetWindowPending();

    const TCHAR * pchFrameName = NULL;

    if(pOmWindowPending && pOmWindowPending->Window()->_cstrName)
    {
        pchFrameName = pOmWindowPending->Window()->_cstrName;
    }
    else
    {
        pchFrameName = pchName;
    }

    Assert(!HasTransNavContext() || GetTransNavContext()->_historyCurElem.lIndex == -1L);

    _fSafeToUseCalcSizeHistory = TRUE;

    if (!pStream)
        RRETURN(E_POINTER);

    // Handle refresh
    LoadInfo.dwBindf = dwBindf;

    LoadInfo.pElementMaster = pElementMaster;

    // In the simplest form of refresh, we don't want a codepage switch to occur.
    LoadInfo.fNoMetaCharset = 0 == (dwBindf & (BINDF_RESYNCHRONIZE|BINDF_GETNEWESTVERSION));

    // Remember original history stream in case we need to replay it after failure
    hr = THR(pStream->Clone(&LoadInfo.pstmRefresh));
    if (hr)
        goto Cleanup;

    hr = LoadHistoryHelper(pStream,
                           pbc, 
                           dwBindf, 
                           pmkHint, 
                           pstmLeader, 
                           pDwnBindData, 
                           codepage,
                           &ulHistoryScrollPos,
                           &pchBookMarkName,
                           &LoadInfo,
                           &fNonHTMLMimeType);

    if (pOmWindowPending && (dwFlags & CDoc::FHL_RESTARTLOAD))
    {
       pOmWindowPending->Window()->_fNavFrameCreation = TRUE;
    }

    if (hr)
        goto Cleanup;

    if (   !_fInRefresh
        && !fNonHTMLMimeType
        && pOmWindowPending
        && !(Doc()->_fStartup && pOmWindowPending->Markup()->IsPrimaryMarkup())
        && !(dwFlags & CDoc::FHL_RESTARTLOAD))
    {
        TCHAR * pchUrl = NULL;

        if (!LoadInfo.pchDisplayName && LoadInfo.pmk)
        {
            IGNORE_HR(LoadInfo.pmk->GetDisplayName(LoadInfo.pbctx, NULL, &pchUrl));
        }

        _pDoc->_webOCEvents.BeforeNavigate2(pOmWindowPending,
                                            &fCancel,
                                            LoadInfo.pchDisplayName ? LoadInfo.pchDisplayName : pchUrl,
                                            LoadInfo.pchLocation,
                                            pchFrameName,
                                            NULL,
                                            0,
                                            NULL,
                                            !(dwFlags & CDoc::FHL_FRAMECREATION));
        CoTaskMemFree(pchUrl);

        if (fCancel)
            goto Cleanup;
    }

    if (_fServerErrorPage)
    {
        //
        // Tell shdocvw about the error page so it doesn't add it to history
        //
        
        NoteErrorWebPage();
    }
    
    if (fNonHTMLMimeType)
    {
        if (LoadInfo.pchDisplayName)
        {
            IGNORE_HR(Doc()->FollowHyperlink(LoadInfo.pchDisplayName,
                                             NULL,
                                             NULL,
                                             LoadInfo.pDwnPost,
                                             LoadInfo.pDwnPost ? TRUE : FALSE,
                                             NULL,
                                             FALSE,
                                             pOmWindowPending,
                                             NULL,
                                             0,
                                             ERROR_SUCCESS,
                                             FALSE,
                                             NULL,
                                             FALSE,
                                             (dwFlags | CDoc::FHL_LOADHISTORY),
                                             pchFrameName));
            goto Cleanup;
        }
        else if (LoadInfo.pmk)
        {
            TCHAR * pchTask = NULL;

            if (S_OK == LoadInfo.pmk->GetDisplayName(LoadInfo.pbctx, NULL, &pchTask))
            {
                IGNORE_HR(Doc()->FollowHyperlink(pchTask,
                                             NULL,
                                             NULL,
                                             LoadInfo.pDwnPost,
                                             LoadInfo.pDwnPost ? TRUE : FALSE,
                                             NULL,
                                             FALSE,
                                             pOmWindowPending,
                                             NULL,
                                             0,
                                             ERROR_SUCCESS,
                                             FALSE,
                                             NULL,
                                             FALSE,
                                             (dwFlags | CDoc::FHL_LOADHISTORY),
                                             pchFrameName));
                CoTaskMemFree(pchTask);
            }
            goto Cleanup;
        }
    }

    if (LoadInfo.pDwnPost && (LoadInfo.dwBindf & (BINDF_RESYNCHRONIZE | BINDF_GETNEWESTVERSION)))
    {
        int iAnswer = 0;

        IGNORE_HR(Doc()->ShowMessage(&iAnswer, MB_RETRYCANCEL | MB_ICONEXCLAMATION, 0, IDS_REPOSTFORMDATA));
        if (iAnswer == IDCANCEL)
        {
            LoadInfo.dwBindf &= ~(BINDF_RESYNCHRONIZE | BINDF_GETNEWESTVERSION | BINDF_PRAGMA_NO_CACHE);
            // NOTE: BINDF_OFFLINEOPERATION is set for the doc only in LoadFromInfo
        }
    }

    // override codepage
    if (codepage)
        LoadInfo.codepage = codepage;

    // Fill in/replace moniker
    if (LoadInfo.pchDisplayName && !LoadInfo.pmk)
    {
        hr = THR(CreateURLMoniker(NULL, LoadInfo.pchDisplayName, &LoadInfo.pmk));
        if (hr)
            goto Cleanup;
    }

    LoadInfo.pstmLeader = pstmLeader;
    LoadInfo.pDwnBindData = pDwnBindData;
    LoadInfo.pbctx = pbc;

    Doc()->_fInIEBrowser = IsInIEBrowser(Doc());

    // Fill in history substream
    hr = THR(LoadFromInfo(&LoadInfo,dwFlags));
    if (hr)
        goto Cleanup;

    if (Doc()->IsPrintDialogNoUI()) 
    {
        // don't scroll to anyplace if printing
        goto Cleanup;
    }

    // Scroll to the right place

    if ( pchBookMarkName )
    {
        hr = THR(NavigateHere(0, pchBookMarkName, 0, TRUE));
    }
    else
    {
        hr = THR(SetPositionCookie(ulHistoryScrollPos));
    }

    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(LoadInfo.pstmRefresh);
    ReleaseInterface(LoadInfo.pstmDirty);
    MemFree(LoadInfo.pchFile);
    MemFree(LoadInfo.pchDisplayName);
    MemFree(LoadInfo.pchUrlOriginal);
    MemFree(LoadInfo.pchLocation);
    MemFree(LoadInfo.pchDocReferer);
    MemFree(LoadInfo.pchSubReferer);
    MemFree(LoadInfo.pbRequestHeaders);
    delete pchBookMarkName;
    ReleaseInterface(LoadInfo.pmk);
    if (LoadInfo.pDwnPost)
        LoadInfo.pDwnPost->Release();
    ReleaseInterface(LoadInfo.pstmHistory);
    MemFreeString(LoadInfo.pchHistoryUserData);
    ReleaseInterface(pSubstream);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CMarkup::GetLoadHistoryStream
//
//  Synopsis:   Retrieves the history substream to load from, if any, that
//              corresponds to the given history index.
//
//              No stream will be returned if the dwCheck passed in
//              does not match the dwCheck passed into the saver.
//
//              *ppStream can be return NULL even for S_OK if there
//              is no substream for the specified index.
//
//-------------------------------------------------------------------------
HRESULT
CMarkup::GetLoadHistoryStream(ULONG index, DWORD dwCheck, IStream **ppStream)
{
    HRESULT hr = S_OK;

    *ppStream = NULL;

    if (HasTransNavContext())
    {
        CMarkupTransNavContext * ptnc = GetTransNavContext();

        hr = THR(ptnc->_HistoryLoadCtx.GetLoadStream(index, dwCheck, ppStream));

        EnsureDeleteTransNavContext(ptnc);
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CMarkup::ClearLoadHistoryStreams
//
//  Synopsis:   Clears the history streams; called before parsing the
//              document if we know we should not restore the user
//              state.
//
//-------------------------------------------------------------------------
void
CMarkup::ClearLoadHistoryStreams()
{
    if (HasTransNavContext())
    {
        CMarkupTransNavContext * ptnc = GetTransNavContext();

        ptnc->_HistoryLoadCtx.Clear();
        EnsureDeleteTransNavContext(ptnc);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CMarkup::LoadSlaveMarkupHistory()
//
//  Synopsis:   Load Slave Markup history
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::LoadSlaveMarkupHistory()
{
    HRESULT hr = S_OK;

    CNotification           nf;
    CMarkupTransNavContext *ptnc;
    CDoc::LOADINFO          LoadInfo = { 0 };
    ULONG                   ulHistoryScrollPos = 0;
    TCHAR                  *pchBookMarkName = NULL;
    IStream                *pStreamMaster = NULL;
    CElement               *pElementMaster;
    CMarkup                *pMarkupMaster;

    if (!Root()->HasMasterPtr())
        goto Cleanup;

    AssertSz(!IsPrimaryMarkup(), "should not be called in primary Markup");

    pElementMaster = Root()->GetMasterPtr();
    pMarkupMaster  = pElementMaster->GetMarkup();

    if (   !_fLoadHistoryReady
        || !pMarkupMaster || !pMarkupMaster->HasTransNavContext())
        goto Cleanup;

    ptnc = EnsureTransNavContext();
    if (!ptnc)
        goto Cleanup;

    hr = THR(pMarkupMaster->GetLoadHistoryStream((0xF000000 | pElementMaster->GetSourceIndex()),
                                                 pElementMaster->HistoryCode(),
                                                 &pStreamMaster));
    if (FAILED(hr) || !pStreamMaster)
        goto Cleanup;

    hr = THR(pStreamMaster->Seek(LI_ZERO.li, STREAM_SEEK_SET, NULL));
    if (hr)
        goto Cleanup;

    hr = THR(LoadHistoryHelper(pStreamMaster,
                               0, 
                               0, 
                               0, 
                               0, 
                               0, 
                               0,
                               &ulHistoryScrollPos,
                               &pchBookMarkName,
                               &LoadInfo,
                               NULL));

    if (hr)
        goto Cleanup;

    if (!HasWindowPending() && LoadInfo.pchHistoryUserData)
    {
        CMarkupBehaviorContext * pContext = NULL;

        if (S_OK == EnsureBehaviorContext(&pContext))
        {
            hr = pContext->_cstrHistoryUserData.Set(LoadInfo.pchHistoryUserData);
        }
    }

    if (    !LoadInfo.pstmHistory
        ||  !OK(ptnc->_HistoryLoadCtx.Init(LoadInfo.pstmHistory)))
    {
        ptnc->_HistoryLoadCtx.Clear();
    }
    else
    {
        ptnc->_fDoDelayLoadHistory = TRUE;
        nf.DelayLoadHistory(Root());
        Notify(&nf);
    }
    // Scroll to the right place
    if ( pchBookMarkName )
    {
        hr = THR(NavigateHere(0, pchBookMarkName, 0, TRUE));
    }
    else if (HasWindowPending())
    {
        hr = THR(SetPositionCookie(ulHistoryScrollPos));
    }

    EnsureDeleteTransNavContext( ptnc );

Cleanup:
    MemFree(LoadInfo.pchFile);
    MemFree(LoadInfo.pchDisplayName);
    MemFree(LoadInfo.pchUrlOriginal);
    MemFree(LoadInfo.pchLocation);
    MemFree(LoadInfo.pchDocReferer);
    MemFree(LoadInfo.pchSubReferer);
    MemFree(LoadInfo.pbRequestHeaders);
    ReleaseInterface(LoadInfo.pmk);
    delete pchBookMarkName;
    if (LoadInfo.pDwnPost)
        LoadInfo.pDwnPost->Release();
    ReleaseInterface(LoadInfo.pstmHistory);
    if (LoadInfo.pchHistoryUserData)
        MemFreeString(LoadInfo.pchHistoryUserData);
    ReleaseInterface(pStreamMaster);

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Class:      CHistoryLoadCtx
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CHistoryLoadCtx::dtor
//
//  Synopsis:   destructor - release any unused streams
//
//-------------------------------------------------------------------------
CHistoryLoadCtx::~CHistoryLoadCtx()
{
    Clear();
}

//+------------------------------------------------------------------------
//
//  Member:     CHistoryLoadCtx::Clear
//
//  Synopsis:   Clears and releases the substreams and bind ctx
//
//-------------------------------------------------------------------------
void CHistoryLoadCtx::Clear()
{
    int c;

    for (c = _arySubstreams.Size(); c;)
    {
        c--;
        ReleaseInterface(_arySubstreams[c].pStream);
    }

    _arySubstreams.DeleteAll();
    _cCountZeroed = 0;
    _iLastFound = 0;
}

//+------------------------------------------------------------------------
//
//  Member:     CHistoryLoadCtx::Init
//
//  Synopsis:   Loads the part of the history stream which contains
//              substreams.
//
//              Breaks the stream into substreams and sorts and stores
//              them by index.
//
//-------------------------------------------------------------------------
HRESULT CHistoryLoadCtx::Init(IStream *pStream)
{
    CDataStream ds(pStream);
    HRESULT hr;
    ULONG cSubstreams, c;
    DWORD dwCheck;


    hr = THR(ds.LoadDword(&cSubstreams));
    if (hr)
        goto Cleanup;

#if DBG==1
    {
        int cDbg = _arySubstreams.Size();
        SubstreamEntry * pEnt = _arySubstreams;
        for ( ; cDbg > 0; cDbg--, pEnt++)
        {
            Assert( pEnt->pStream == NULL );
        }
    }
#endif

    hr = THR(_arySubstreams.Grow(cSubstreams));
    if (hr)
        goto Cleanup;

    memset(_arySubstreams, 0, sizeof(SubstreamEntry) * cSubstreams);

    for (c=0; c < cSubstreams; c++)
    {
        DWORD    index;
        IStream *pSubstream;

        hr = THR(ds.LoadDword(&index));
        if (hr)
            goto Cleanup;

        hr = THR(ds.LoadDword(&dwCheck));
        if (hr)
            goto Cleanup;

        hr = THR(ds.LoadSubstream(&pSubstream));
        if (hr)
            goto Cleanup;

        if (_arySubstreams[c].pStream)
        {
            Assert(0);
            pSubstream->Release();
        }
        else
        {
            _arySubstreams[c].pStream = pSubstream;
            _arySubstreams[c].dwCheck = dwCheck;
            _arySubstreams[c].uCookieIndex = index;
        }

        pSubstream = NULL;
    }

    _cCountZeroed = 0;
    _iLastFound = 0;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHistoryLoadCtx::GetLoadStream
//
//  Synopsis:   Retrieves the substream, if any, that corresponds to the
//              given index.
//
//              *ppStream can be return NULL even for S_OK if there
//              is no substream for the specified index
//
//-------------------------------------------------------------------------
HRESULT CHistoryLoadCtx::GetLoadStream(ULONG index, DWORD dwCheck, IStream **ppStream)
{
    ULONG i;
    ULONG uStart = _iLastFound;
    ULONG uEnd = (unsigned)_arySubstreams.Size();
    BOOL  fBottomSearch = FALSE;

    if (!ppStream)
        goto Cleanup;

    *ppStream = NULL;

    // although we are doing a linear search, 2 things make the expected
    // performance to be a constant time algorithm. First the elements save and load
    // their data in source order, thus the keys are naturally ordered (by the save).
    // for loading, we're accessed in source order so by remembering the iLastFound 
    // position we expect to find the next element with only a single probe.
    //  The second thing that helps our performance in not deleting the data element
    // until the whole thing has been zeroed.  we *should* never have to search
    // the front part of the list

SearchForIt:
    // first time around we search the top (expect success)
    for (i=uStart; i < uEnd; i++)
    { 
        if ( i >= (unsigned)_arySubstreams.Size())
            goto Cleanup;

        if ((_arySubstreams[i].uCookieIndex == index) &&
            (_arySubstreams[i].dwCheck == dwCheck))
        {
            // we found the substream
            *ppStream = _arySubstreams[i].pStream;
            if (*ppStream)
            {
                // remember the found position so that the next
                // search will be faster.
                _iLastFound = i+1;

                // Transfer ref from _ary to *ppStream
                // adn remove this entry from the list
                _arySubstreams[i].pStream = NULL;
                _arySubstreams[i].dwCheck == -1;
                _arySubstreams[i].uCookieIndex=0;  // cooresponds to HTML element and is 
                                                   // unlikely to be legal
                _cCountZeroed++;
                if (_cCountZeroed == (unsigned)_arySubstreams.Size())
                {
#if DBG==1
                    {
                        int cDbg = _arySubstreams.Size();
                        SubstreamEntry * pEnt = _arySubstreams;
                        for ( ; cDbg > 0; cDbg--, pEnt++)
                        {
                            Assert( pEnt->pStream == NULL );
                        }
                    }
#endif
                    _arySubstreams.DeleteAll();
                    _cCountZeroed=0;
                    _iLastFound = 0;
                }
            }
            // found == true
            goto Cleanup;
        }
    }
    if (fBottomSearch)
        goto Cleanup;  // not found

    // not in the expected part.. be paranoid and search the bottom
    uStart = 0;
    uEnd = _iLastFound;
    fBottomSearch = TRUE;
    goto SearchForIt;

Cleanup:
    return(S_OK);
}

//+------------------------------------------------------------------------
//
//  Class:      CHistorySaveCtx
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CHistorySaveCtx::Init
//
//  Synopsis:   Begins saving to the part of the history stream which
//              contains substreams.
//
//              Must be matched by a call to Finish() to complete the save
//
//-------------------------------------------------------------------------
HRESULT CHistorySaveCtx::Init(IStream *pStream)
{
    HRESULT hr;

    _ds.Init(pStream);

    hr = THR(_ds.SaveDataLater(&_dwPoscSubstreams, sizeof(DWORD)));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHistorySaveCtx::BeginSaveStream
//
//  Synopsis:   Begins saving to a substream with the specified index
//              The index is most likely the sourceIndex of the element 
//              that wants to save into the substream,
//
//              The returned pStream has a ref (it must be released by
//              the caller).
//
//              Must be matched by a call to EndSaveSubstream()
//
//-------------------------------------------------------------------------
HRESULT CHistorySaveCtx::BeginSaveStream(DWORD dwCookieIndex, DWORD dwCheck, IStream **ppStream)
{
    HRESULT hr;

    _cSubstreams++;

    hr = THR(_ds.SaveDword(dwCookieIndex));
    if (hr)
        goto Cleanup;

    hr = THR(_ds.SaveDword(dwCheck));
    if (hr)
        goto Cleanup;

    hr = THR(_ds.BeginSaveSubstream(ppStream));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHistorySaveCtx::EndSaveStream
//
//  Synopsis:   Finishes the saving operation for a single substream
//
//-------------------------------------------------------------------------
HRESULT CHistorySaveCtx::EndSaveStream()
{
    HRESULT hr;

    hr = THR(_ds.EndSaveSubstream());
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CHistorySaveCtx::Finish
//
//  Synopsis:   Finishes the entire saving operation
//
//-------------------------------------------------------------------------
HRESULT CHistorySaveCtx::Finish()
{
    HRESULT hr;

//    hr = THR(_ds.SaveDataNow(_dwPosiMax, &_iMax, sizeof(DWORD)));
//    if (hr)
//        goto Cleanup;

    hr = THR(_ds.SaveDataNow(_dwPoscSubstreams, &_cSubstreams, sizeof(DWORD)));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::LoadFailureUrl
//
//  Synopsis:   Does a very simple load into the doc
//
//-------------------------------------------------------------------------
HRESULT 
CMarkup::LoadFailureUrl(TCHAR *pchUrl, IStream *pstmRefresh)
{
    CDoc::LOADINFO LoadInfo = { 0 };
    HRESULT hr;
    CMarkup* pMarkupNew = NULL;
    TCHAR * pchOriginalUrl = NULL;
    
    hr = CreateURLMoniker(NULL, pchUrl, &LoadInfo.pmk);
    if (hr || !LoadInfo.pmk)
        goto Cleanup;

    LoadInfo.pchDisplayName = pchUrl;

    LoadInfo.pstmRefresh = pstmRefresh;
    LoadInfo.fKeepRefresh = TRUE;

    //
    // Store the original url
    //
    hr = THR(MemAllocString(Mt(LoadFailureUrl), (TCHAR*)CMarkup::GetUrl(this), &pchOriginalUrl));
    if (hr)
        goto Cleanup;

    LoadInfo.fDontUpdateTravelLog = TRUE;

    //TODO (carled, scotrobe) - this hack for IsPrimary should be removed.
    // To do this, and fix the memory-leak/Assert in bug 106014, this function needs
    // to create a NEW markup for the failure URL, and then NEW markup needs to 
    // replace the current one (SwitchMarkup?).  This will allow the current one 
    // to be released and not to leak.  This is what CDoc::LoadFromINfo does, 
    // and that is why the hack stops the memory leak. 

    if (IsPrimaryMarkup())
        hr = Doc()->LoadFromInfo(&LoadInfo, & pMarkupNew);
    else
    {
        hr = LoadFromInfo(&LoadInfo);
        pMarkupNew = this;
    }    
    if (hr)
        goto Cleanup;

    Assert( pMarkupNew );
    hr = THR( pMarkupNew->SetUrlOriginal( pchOriginalUrl ));
    
Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member:     COptionArray::QueryInterface
//
//  Synopsis:   Simple QI Impl
//
//-------------------------------------------------------------------------
STDMETHODIMP
COptionArray::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == _iid)
        *ppv = (IOptionArray *)this;
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     COptionArray::AddRef
//
//  Synopsis:   Simple AddRef
//
//-------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
COptionArray::AddRef()
{
    return(super::AddRef());
}

//+------------------------------------------------------------------------
//
//  Member:     COptionArray::Release
//
//  Synopsis:   Simple Release
//
//-------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
COptionArray::Release()
{
    return(super::Release());
}


//+------------------------------------------------------------------------
//
//  Member:     COptionArray::~COptionArray
//
//  Synopsis:   Deletes all allocated memory
//
//-------------------------------------------------------------------------

COptionArray::~COptionArray()
{
    Option *pop;
    int c;

    for (pop = _aryOption, c = _aryOption.Size(); c; pop++, c--)
    {
        if (pop->cb > sizeof(DWORD))
        {
            MemFree(pop->pv);
        }
    }

    _aryOption.DeleteAll();
}

//+------------------------------------------------------------------------
//
//  Member:     COptionArray::QueryOption
//
//  Synopsis:   Copies the stored data to the buffer.
//
//              pBuffer is the buffer
//              *pcbBuf indicates the size of the incoming buffer
//
//              If pBuffer is NULL, *pcbBuf is set to the size of the
//              stored data (zero if no data has been stored) and S_OK
//              is returned.
//
//              If *pcbBuf is too small to copy all the data, it is set
//              to the required size and an error is returned.
//
//              If the buffer is big enough (or if no data was stored),
//              *pcbBuf is set to the size of the data and S_OK
//              is returned.
//
//-------------------------------------------------------------------------
STDMETHODIMP
COptionArray::QueryOption(DWORD dwOption, LPVOID pBuffer, ULONG *pcbBuf)
{
    ULONG index;
    ULONG cb;
    ULONG cbBuf = *pcbBuf;
    HRESULT hr = S_OK;

    if (!IndexFromOption(&index, dwOption))
    {
        *pcbBuf = 0;
        goto Cleanup;
    }

    cb = _aryOption[index].cb;
    *pcbBuf = cb;

    if (!pBuffer)
        goto Cleanup;

    if (cbBuf < cb)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (cb <= sizeof(DWORD))
    {
        memcpy(pBuffer, &(_aryOption[index].pv), cb);
    }
    else
    {
        memcpy(pBuffer, _aryOption[index].pv, cb);
    }

Cleanup:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     COptionArray::SetOption
//
//  Synopsis:   Stores the specified data
//
//              Overwrites any data that is stored at the same index.
//
//-------------------------------------------------------------------------
STDMETHODIMP
COptionArray::SetOption(DWORD dwOption, LPVOID pBuffer, DWORD cbBuf)
{
    ULONG index;
    void *pvNew = NULL;
    Option op;
    HRESULT hr = S_OK;

    if (cbBuf > sizeof(DWORD))
    {
        pvNew = MemAlloc(Mt(COptionArrayItem), cbBuf);
        if (!pvNew)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        memcpy(pvNew, pBuffer, cbBuf);
    }

    op.dwOption = dwOption;
    op.cb = cbBuf;
    if (!pvNew)
        memcpy(&op.pv, pBuffer, cbBuf);
    else
        op.pv = pvNew;

    if (!IndexFromOption(&index, dwOption))
    {
        hr = THR(_aryOption.InsertIndirect(index, &op));
        if (hr)
            goto Cleanup;
    }
    else
    {
        if (_aryOption[index].cb > sizeof(DWORD))
        {
            MemFree(_aryOption[index].pv);
        }
        memcpy(&_aryOption[index], &op, sizeof(Option));
    }

    pvNew = NULL;

Cleanup:

    MemFree(pvNew);
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     COptionArray::IndexFromDword
//
//  Synopsis:   Efficient binary search
//
//-------------------------------------------------------------------------
BOOL
COptionArray::IndexFromOption(ULONG *pindex, DWORD dwOption)
{
    ULONG min;
    ULONG max;
    ULONG mid;
    ULONG imin;
    ULONG imax;
    ULONG imid;

    if (!_aryOption.Size() || dwOption > (_aryOption[_aryOption.Size()-1].dwOption))
    {
        *pindex = _aryOption.Size();
        return FALSE;
    }

    imin = 0;
    min = _aryOption[0].dwOption;

    imax = _aryOption.Size() - 1;
    max = _aryOption[imax].dwOption;

    while (max - min > imax - imin)
    {
        imid = (imax + imin) / 2;
        mid = _aryOption[imid].dwOption;

        if (dwOption <= mid)
        {
            imax = imid;
            max = mid;
        }
        else
        {
            imin = imid + 1;
            min = _aryOption[imin].dwOption;
        }
    }

    Assert(max - min == imax - imin);

    if (dwOption < min)
    {
        *pindex = imin;
        return FALSE;
    }

    *pindex = imin + (dwOption - min);
    return TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     CreateOptionArray
//
//  Synopsis:   Creates an OptionArray object which supports IOptionArray
//              under the specified IID.
//
//-------------------------------------------------------------------------

HRESULT
CreateOptionArray(IOptionArray **ppOptionArray, REFIID iid)
{
    COptionArray *pHbi = new COptionArray(iid);
    if (!pHbi)
    {
        return(E_OUTOFMEMORY);
    }

    *ppOptionArray = (IOptionArray*)pHbi;

    return(S_OK);
}

//+------------------------------------------------------------------------
//
//  Member:     CreateHtmLoadOptions
//
//  Synopsis:   Creates an OptionArray which implements IID_IHtmLoadOptions
//
//-------------------------------------------------------------------------

HRESULT
CreateHtmlLoadOptions(IUnknown * pUnkOuter, IUnknown **ppUnk)
{
    if (pUnkOuter != NULL)
    {
        *ppUnk = NULL;
        return(CLASS_E_NOAGGREGATION);
    }

    RRETURN(THR(CreateOptionArray((IOptionArray **)ppUnk, IID_IHtmlLoadOptions)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\peermisc.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

///////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////

MtDefine(CPeerUrnCollection, Elements, "CPeerUrnCollection")

const CBase::CLASSDESC CPeerUrnCollection::s_classdesc =
{
    &CLSID_HTMLUrnCollection,               // _pclsid
    0,                                      // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                                   // _pcpi
    0,                                      // _dwFlags
    &IID_IHTMLUrnCollection,                // _piidDispinterface
    &s_apHdlDescs                           // _apHdlDesc
};

#define _cxx_
#include "urncoll.hdl"

//////////////////////////////////////////////////////////////////////////////
//
// Class:  CPeerUrnCollection
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Member:     CPeerUrnCollection constructor
//
//----------------------------------------------------------------------------

CPeerUrnCollection::CPeerUrnCollection( CElement *pElement ) : _pElement(pElement)
{
    pElement->AddRef();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerUrnCollection::Passivate
//
//----------------------------------------------------------------------------

void
CPeerUrnCollection::Passivate()
{
    super::Passivate();
    _pElement->Release();
}


//+---------------------------------------------------------------------------
//
//  Member:     CPeerUrnCollection::PrivateQueryInterface
//
//----------------------------------------------------------------------------

HRESULT
CPeerUrnCollection::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        default:
        {
            const CLASSDESC *pclassdesc = BaseDesc();

            // TODO (alexz) replace this with QI_TEAROFF
            if (pclassdesc &&
                pclassdesc->_piidDispinterface &&
                (iid == *pclassdesc->_piidDispinterface))
            {
                HRESULT hr = THR(CreateTearOffThunk(this, s_apfnIHTMLUrnCollection, NULL, ppv));
                if (hr)
                    RRETURN(hr);
            }
        }
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  Member  : CPeerUrnCollection::length
//
//----------------------------------------------------------------------------

HRESULT
CPeerUrnCollection::get_length(long * pLength)
{
    HRESULT                 hr = S_OK;
    CPeerHolder::CListMgr   List;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = 0;
    Assert(_pElement);

    if (_pElement->HasPeerHolder())
    {
        List.Init(_pElement->GetPeerHolder());

        *pLength = List.GetPeerHolderCount(/* fNonEmptyOnly = */TRUE);
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerUrnCollection::item
//
//----------------------------------------------------------------------------

HRESULT
CPeerUrnCollection::item(long lIndex, BSTR *ppUrn)
{
    HRESULT                 hr;
    VARIANT                 varBstr;

    if (!ppUrn)
    {
        RRETURN(E_POINTER);
    }

    hr = THR(GetItem(lIndex, &varBstr));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&varBstr) == VT_BSTR);
    *ppUrn = V_BSTR(&varBstr);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerUrnCollection::GetItem
//
//----------------------------------------------------------------------------

HRESULT 
CPeerUrnCollection::GetItem (long lIndex, VARIANT *pvar)
{
    HRESULT                 hr = E_INVALIDARG;
    CPeerHolder::CListMgr   List;
    CPeerHolder *           pPeerHolder;

    if (!_pElement)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (!_pElement->HasPeerHolder())
    {
        Assert (E_INVALIDARG == hr);
        goto Cleanup;
    }

    // this is NULL if we're validating lIndex 
    if (pvar)    
        V_BSTR(pvar) = NULL;

    List.Init(_pElement->GetPeerHolder());
    pPeerHolder = List.GetPeerHolderByIndex(lIndex, /* fNonEmptyOnly = */TRUE);

    if (!pPeerHolder)
        goto Cleanup;

    // pvar can be NULL when checking for valid index
    if (pvar)
    {
        hr = THR(pPeerHolder->_cstrUrn.AllocBSTR(&V_BSTR(pvar)));
        if (hr)
            goto Cleanup;

        V_VT(pvar) = VT_BSTR;
    }
    else
        hr = S_OK;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\peersite.cxx ===
//+-----------------------------------------------------------------------
//
//  File:       peersite.cxx
//
//  Contents:   peer site
//
//  Classes:    CPeerHolder::CPeerSite
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_PEERMGR_HXX_
#define X_PEERMGR_HXX_
#include "peermgr.hxx"
#endif

#ifndef X_PEERFACT_HXX_
#define X_PEERFACT_HXX_
#include "peerfact.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_PRGSNK_H_
#define X_PRGSNK_H_
#include <prgsnk.h>
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include "generic.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif // X_PEERXTAG_HXX_

#ifndef X_DISPCONTEXT_HXX_
#define X_DISPCONTEXT_HXX_
#include "dispcontext.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#include "ddraw.h"
#endif

extern IDirectDraw * g_pDirectDraw;

ExternTag(tagPainterHit);
ExternTag(tagFilterVisible);

extern CGlobalCriticalSection g_csOscCache;

#define PH MyCPeerHolder

///////////////////////////////////////////////////////////////////////////
//
// tearoff tables
//
///////////////////////////////////////////////////////////////////////////

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IElementBehaviorSiteOM2)
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, RegisterEvent,       registerevent,       (LPOLESTR pchEvent, LONG lFlags, LONG * plCookie))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, GetEventCookie,      geteventcookie,      (LPOLESTR pchEvent, LONG* plCookie))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, FireEvent,           fireevent,           (LONG lCookie, IHTMLEventObj * pEventObject))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, CreateEventObject,   createeventobject,   (IHTMLEventObj ** ppEventObject))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, RegisterName,        registername,        (LPOLESTR pchName))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, RegisterUrn,         registerurn,         (LPOLESTR pchUrn))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, GetDefaults,         getdefaults,         (IHTMLElementDefaults ** ppDefaults))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IElementBehaviorSiteRender)
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, Invalidate,              invalidate,             (LPRECT pRect))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, InvalidateRenderInfo,    invalidaterenderinfo,   ())
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, InvalidateStyle,         invalidatestyle,        ())
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IElementBehaviorSiteLayout)
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, InvalidateLayoutInfo, invalidatelayoutinfo, ())
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, InvalidateSize,       invalidatesize,       ())
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, GetMediaResolution,   getmediaresolution,   (SIZE *psizeResolution))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IElementBehaviorSiteLayout2)
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, GetFontInfo,          getfontinfo,          (LOGFONTW* plf))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IHTMLPaintSite)
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, InvalidatePainterInfo,   invalidatepainterinfo,  ())
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, InvalidateRect,          invalidaterect,         (RECT* prcInvalid))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, InvalidateRegion,        invalidateregion,       (HRGN rgnInvalid))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, GetDrawInfo,             getdrawinfo,            (LONG lFlags, HTML_PAINT_DRAW_INFO* pDrawInfo))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, TransformGlobalToLocal,  transformglobaltolocal, (POINT ptGlobal, POINT *pptLocal))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, TransformLocalToGlobal,  transformlocaltoglobal, (POINT ptLocal, POINT *pptGlobal))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, GetHitTestCookie,        gethittestcookie,       (LONG *plCookie))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IHTMLFilterPaintSite)
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, DrawUnfiltered,          drawunfiltered,         (HDC hdc, IUnknown *punkDrawObject, RECT rcBounds, RECT rcUpdate, LONG lDrawLayers))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, HitTestPointUnfiltered,  hittestpointunfiltered, (POINT pt, LONG lDrawLayers, BOOL *pbHit))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, InvalidateRectFiltered,  invalidaterectfiltered, (RECT *prcInvalid))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, InvalidateRgnFiltered,   invalidatergnfiltered,  (HRGN hrgnInvalid))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, ChangeFilterVisibility,  changefiltervisibility, (BOOL fVisible))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, EnsureViewForFilterSite, ensureviewforfiltersite,())
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, GetDirectDraw,           getdirectdraw,          (void ** ppDirectDraw))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, GetFilterFlags,          getfilterflags,         (DWORD * pdwFlags))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IElementBehaviorSiteCategory)
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, GetRelatedBehaviors, getrelatedbehaviors, (LONG lDirection, LPOLESTR pchCategory, IEnumUnknown ** ppEnumerator))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IServiceProvider)
     TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, QueryService, queryservice, (REFGUID rguidService, REFIID riid, void ** ppvObject))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IBindHost)
     TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, CreateMoniker,        createmoniker,       (LPOLESTR pchName, IBindCtx * pbc, IMoniker ** ppmk, DWORD dwReserved))
     TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, MonikerBindToStorage, monikerbindtostorage,(IMoniker * pmk, IBindCtx * pbc, IBindStatusCallback * pbsc, REFIID riid, void ** ppvObj))
     TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, MonikerBindToObject,  monikerbindtoobject, (IMoniker * pmk, IBindCtx * pbc, IBindStatusCallback * pbsc, REFIID riid, void ** ppvObj))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IPropertyNotifySink)
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, OnChanged,     onchanged,     (DISPID dispid))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, OnRequestEdit, onrequestedit, (DISPID dispid))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(CPeerHolder, CPeerSite, IOleCommandTarget)
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, QueryStatus,   querystatus,   (const GUID * pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT * pCmdText))
    TEAROFF_METHOD_SUB(CPeerHolder, CPeerSite, Exec,          exec,          (const GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANT * pvarArgIn, VARIANT * pvarArgOut))
END_TEAROFF_TABLE()

///////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////

IMPLEMENT_FORMS_SUBOBJECT_IUNKNOWN(CPeerHolder::CPeerSite, CPeerHolder, _PeerSite)

// defined in site\ole\OleBindh.cxx:
extern HRESULT
MonikerBind(
    CMarkup *               pMarkup,
    IMoniker *              pmk,
    IBindCtx *              pbc,
    IBindStatusCallback *   pbsc,
    REFIID                  riid,
    void **                 ppv,
    BOOL                    fObject,
    DWORD                   dwCompatFlags);

DeclareTag(tagPeerFireEvent, "Peer", "trace CPeerHolder::CPeerSite::FireEvent")

const CLSID CLSID_CPeerHolderSite = {0x3050f67f, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b};



//+------------------------------------------------------------------------
//
//  Member:     GetLayoutContext
//
//              Returns the layout context from the renderbag.
//              Never cache the layout context, it is valid only during this call
//-------------------------------------------------------------------------

CLayoutContext *
GetLayoutContext(CPeerHolder *pPH)
{
    CLayoutContext * pLayoutContext = GUL_USEFIRSTLAYOUT;

    if(pPH->_pRenderBag && pPH->_pRenderBag->_pCallbackInfo && pPH->_pRenderBag->_pCallbackInfo->_pContext)
        pLayoutContext = pPH->_pRenderBag->_pCallbackInfo->_pContext->GetLayoutContext();

    return pLayoutContext;
}


//+------------------------------------------------------------------------
//
//  Member:     InvalidateAllLayouts
//
//              Invalidate all the Peerholders if (pPH != 0), or
//                layouts (pPH == 0), for given element.
//              We assume that element has a LayoutAry
//-------------------------------------------------------------------------

void
InvalidateAllLayouts(CElement *pElemToUse, CPeerHolder *pPH)
{
    // Invalidate all the layouts
    Assert(pElemToUse->HasLayoutAry());

    CLayoutAry * pLayoutAry = pElemToUse->GetLayoutAry();
    CLayout    * pCurLayout;
    int nLayoutCookie = 0;

    for(;;)
    {
        pCurLayout = pLayoutAry->GetNextLayout(&nLayoutCookie);
        if(nLayoutCookie == -1)
            break;

        if (!pCurLayout)
            return;

        if(pPH)
        {
            CDispNode *pDispNode = pCurLayout->GetElementDispNode();
            if (pDispNode)
            {
                    pPH->InvalidateRect(pDispNode, NULL);
            }
        }
        else
        {
            pCurLayout->Invalidate();
        }
    }
}



///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::QueryInterface
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (!ppv)
        RRETURN(E_POINTER);

    *ppv = NULL;

    switch (iid.Data1)
    {
    QI_INHERITS((IElementBehaviorSite*)this, IUnknown)
    QI_INHERITS(this, IElementBehaviorSite)
    QI_INHERITS(this, ISecureUrlHost)
    QI_TEAROFF2(this, IElementBehaviorSiteOM, IElementBehaviorSiteOM2, NULL)
    QI_TEAROFF (this, IElementBehaviorSiteOM2, NULL)
    QI_TEAROFF (this, IElementBehaviorSiteRender, NULL)
    QI_TEAROFF (this, IHTMLPaintSite, NULL)
    QI_TEAROFF (this, IHTMLFilterPaintSite, NULL)
    QI_TEAROFF (this, IElementBehaviorSiteCategory, NULL)
    QI_TEAROFF (this, IServiceProvider, NULL)
    QI_TEAROFF (this, IBindHost, NULL)
    QI_TEAROFF (this, IPropertyNotifySink, NULL)
    QI_TEAROFF (this, IOleCommandTarget, NULL)
    QI_TEAROFF (this, IElementBehaviorSiteLayout, NULL)
    QI_TEAROFF (this, IElementBehaviorSiteLayout2, NULL)
    default:

        if (IsEqualGUID(iid, CLSID_CPeerHolderSite))
        {
            *ppv = this;
            RRETURN (S_OK);
        }

        break;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
        RRETURN(E_NOINTERFACE);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetElement
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::GetElement(IHTMLElement ** ppElement)
{
    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    RRETURN (THR(PH()->QueryInterface(IID_IHTMLElement, (void**)ppElement)));
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetDefaults
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::GetDefaults(IHTMLElementDefaults ** ppDefaults)
{
    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    if (!PH()->IsIdentityPeer())
        RRETURN(E_ACCESSDENIED);

    HRESULT             hr = S_OK;
    CPeerMgr *          pPeerMgr;
    CDefaults *         pDefaults = NULL;

    hr = THR(CPeerMgr::EnsurePeerMgr(PH()->_pElement, &pPeerMgr));
    if (hr)
        goto Cleanup;

    hr = THR(pPeerMgr->EnsureDefaults(&pDefaults));
    if (hr)
        goto Cleanup;

    hr = THR(pDefaults->PrivateQueryInterface(IID_IHTMLElementDefaults, (void**)ppDefaults));

Cleanup:
    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::RegisterNotification
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::RegisterNotification(LONG lEvent)
{
    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    PH()->SetFlag(PH()->FlagFromNotification(lEvent));

    switch (lEvent)
    {
    case BEHAVIOREVENT_APPLYSTYLE:

#if 1
        // 90810 applyStyle disabled

        AssertSz(0,"Apply Style behavior notification is disabled.");
        PH()->ClearFlag(CPeerHolder::NEEDAPPLYSTYLE);

        break;
#else
        if (PH()->_pElement->IsFormatCacheValid())
        {
            if (PH()->TestFlag(AFTERINIT))
            {
                IGNORE_HR(PH()->_pElement->ProcessPeerTask(PEERTASK_APPLYSTYLE_UNSTABLE));
            }
            else
            {
                IGNORE_HR(PH()->_pElement->OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */ FALSE));
            }
        }
#endif

        break;

    case BEHAVIOREVENT_CONTENTSAVE:

        PH()->_pElement->Doc()->_fContentSavePeersPossible = TRUE;

        break;
    }

    return S_OK;
}

HRESULT
CPeerHolder::CPeerSite::ValidateSecureUrl(BOOL* pfAllow, OLECHAR* pchUrl, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    CMarkup * pMarkup = GetWindowedMarkupContext();


    Assert(pMarkup);
    if(pMarkup == NULL)
    {
        hr = E_FAIL;
        goto done;
    }

    *pfAllow = (pMarkup->ValidateSecureUrl(FALSE, pchUrl,
        !!(SUHV_PROMPTBEFORENO & dwFlags),
        !!(SUHV_SILENTYES & dwFlags),
        !!(SUHV_UNSECURESOURCE & dwFlags)));
done:
    return hr;
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::QueryService
//
//-------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::QueryService(REFGUID rguidService, REFIID riid, void ** ppvObject)
{
    HRESULT             hr;
    CMarkup *           pMarkup;

    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    if (IsEqualGUID(rguidService, SID_SBindHost))
    {
        hr = THR_NOTRACE(QueryInterface(riid, ppvObject));
        goto Cleanup;
    }
    else if (IsEqualGUID(rguidService, SID_SElementBehaviorMisc))
    {
        hr = THR_NOTRACE(QueryInterface(riid, ppvObject));
        goto Cleanup;
    }
    else if (PH()->_pPeerFactoryUrl && IsEqualGUID(rguidService, IID_IMoniker))
    {
        hr = THR_NOTRACE(PH()->_pPeerFactoryUrl->QueryService(rguidService, riid, ppvObject));
        goto Cleanup;
    }
    else if( IsEqualGUID( rguidService, CLSID_CMarkup ) )
    {
        *ppvObject = PH()->_pElement->GetWindowedMarkupContext();
        hr = S_OK;
        goto Cleanup;
    }

    pMarkup = PH()->_pElement->GetMarkup();
    if (pMarkup)
    {
        CMarkupBehaviorContext * pBehaviorContext = pMarkup->BehaviorContext();

        if (pBehaviorContext && pBehaviorContext->_pHtmlComponent)
        {
            hr = THR(pBehaviorContext->_pHtmlComponent->QueryService(rguidService, riid, ppvObject));
            goto Cleanup;   // done
        }

        hr = THR_NOTRACE(pMarkup->QueryService(rguidService, riid, ppvObject));

        goto Cleanup; // done (markup will delegate to the doc)
    }

    hr = THR_NOTRACE(Doc()->QueryService(rguidService, riid, ppvObject));

Cleanup:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::CreateMoniker, per IBindHost
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::CreateMoniker(
    LPOLESTR    pchUrl,
    IBindCtx *  pbc,
    IMoniker ** ppmk,
    DWORD dwReserved)
{
    HRESULT     hr;
    TCHAR       achExpandedUrl[pdlUrlLen];

    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    hr = THR(CMarkup::ExpandUrl(GetWindowedMarkupContext(), pchUrl, ARRAY_SIZE(achExpandedUrl), achExpandedUrl, PH()->_pElement));
    if (hr)
        goto Cleanup;

    hr = THR(CreateURLMoniker(NULL, achExpandedUrl, ppmk));

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::MonikerBindToStorage, per IBindHost
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::MonikerBindToStorage(
    IMoniker *              pmk,
    IBindCtx *              pbc,
    IBindStatusCallback *   pbsc,
    REFIID                  riid,
    void **                 ppvObj)
{
    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    RRETURN1(MonikerBind(
        GetWindowedMarkupContext(),
        pmk,
        pbc,
        pbsc,
        riid,
        ppvObj,
        FALSE, // fObject = FALSE
        COMPAT_SECURITYCHECKONREDIRECT), S_ASYNCHRONOUS);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::MonikerBindToObject, per IBindHost
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::MonikerBindToObject(
    IMoniker *              pmk,
    IBindCtx *              pbc,
    IBindStatusCallback *   pbsc,
    REFIID                  riid,
    void **                 ppvObj)
{
    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    RRETURN1(MonikerBind(
        GetWindowedMarkupContext(),
        pmk,
        pbc,
        pbsc,
        riid,
        ppvObj,
        TRUE, // fObject = TRUE
        COMPAT_SECURITYCHECKONREDIRECT), S_ASYNCHRONOUS);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::RegisterEvent, per IElementBehaviorSiteOM
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::RegisterEvent(BSTR bstrEvent, LONG lFlags, LONG * plCookie)
{
    HRESULT     hr;
    LONG        lCookie;

    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    if (!bstrEvent)
        RRETURN (E_POINTER);

    if (!plCookie)
        plCookie = &lCookie;

    hr = THR(GetEventCookieHelper(bstrEvent, lFlags, plCookie, /* fEnsureCookie = */ TRUE));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}

HRESULT
CPeerHolder::CPeerSite::RegisterEventHelper(BSTR bstrEvent, LONG lFlags, LONG * plCookie, CHtmlComponent *pContextComponent)
{
    HRESULT     hr;
    LONG        lCookie;

    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    Assert(bstrEvent);
    Assert(!plCookie);
    Assert(pContextComponent);

    hr = THR(GetEventCookieHelper(bstrEvent, lFlags, &lCookie, /* fEnsureCookie = */ TRUE, pContextComponent));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetEventCookie, per IElementBehaviorSiteOM
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::GetEventCookie(BSTR bstrEvent, LONG * plCookie)
{
    HRESULT     hr;

    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    if (!plCookie || !bstrEvent)
        RRETURN (E_POINTER);

    hr = THR_NOTRACE(GetEventCookieHelper(bstrEvent, 0, plCookie, /* fEnsureCookie = */ FALSE));

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetEventDispid, helper
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::GetEventDispid(LPOLESTR pchEvent, DISPID * pdispid)
{
    HRESULT hr;
    LONG    lCookie;

    hr = THR_NOTRACE(GetEventCookieHelper(pchEvent, 0, &lCookie, /* fEnsureCookie = */ FALSE));
    if (hr)
        goto Cleanup;

    *pdispid = PH()->CustomEventDispid(lCookie);

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetEventCookieHelper, helper
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::GetEventCookieHelper(
    LPOLESTR pchEvent,
    LONG     lFlags,
    LONG *   plCookie,
    BOOL     fEnsureCookie,
    CHtmlComponent *pContextComponent)
{
    HRESULT     hr = DISP_E_UNKNOWNNAME;
    LONG        idx = -1, cnt;
    CHtmlComponent *pComponent = NULL;
    CHtmlComponent *pFactory = NULL;

    Assert (pchEvent && plCookie);

    //
    // ensure events bag
    //

    if (!PH()->_pEventsBag)
    {
        PH()->_pEventsBag = new CEventsBag();
        if (!PH()->_pEventsBag)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    //
    // do the lookup or registration
    //
    cnt = PH()->CustomEventsCount();
    if (PH()->_fHtcPeer && (cnt > 0 || fEnsureCookie))
    {
        Assert(PH()->_pPeer);

        pComponent = DYNCAST(CHtmlComponent, PH()->_pPeer);
        if (pComponent && !pComponent->Dirty() && pComponent->_pConstructor)
        {
            pFactory = pComponent->_pConstructor->_pFactoryComponent;
            Assert(pFactory != pComponent && !pComponent->_fFactoryComponent);
            if (pFactory && cnt > 0)
            {
                Assert(pFactory->_fFactoryComponent);
                idx = pFactory->FindEventCookie(pchEvent);

                // if name found is a property or method, allow custom event of
                // same name, but perf has to be turned off :-(
                if (fEnsureCookie && idx >= HTC_PROPMETHODNAMEINDEX_BASE)
                    pFactory->_fDirty = TRUE;
            }
        }
    }

    // make search in array of dispids
    if (!pFactory)
    {
        for (idx = 0; idx < cnt; idx++)
        {
            if (0 == StrCmpIC(pchEvent, PH()->CustomEventName(idx)))
                break;
        }
    }

    if (idx >= 0 && idx < cnt) // if found the event
    {
        Assert(!pFactory || (0 == StrCmpIC(pchEvent, PH()->CustomEventName(idx))));
        *plCookie = idx;
        hr = S_OK;
    }
    else // if not found the event
    {
        // depending on action
        if (!fEnsureCookie)
        {
            Assert (DISP_E_UNKNOWNNAME == hr);
        }
        else
        {
            //
            // register the new event
            //

            BOOL        fConnectNow = FALSE;
            DISPID      dispidSrc;
            DISPID      dispidHandler;
            long        c;

            CEventsBag::CEventsArray *  pEventsArray = &PH()->_pEventsBag->_aryEvents;

            hr = PH()->_pElement->CBase::GetDispID(pchEvent, 0, &dispidSrc);
            switch (hr)
            {
            case S_OK:

                if (IsStandardDispid(dispidSrc))
                {
                    if (PH()->_pElement->GetBaseObjectFor(dispidSrc) != PH()->_pElement)
                    {
                        // we don't allow yet to override events fired by window
                        hr = E_NOTIMPL;
                    }

                    dispidHandler = dispidSrc;
                }
                else
                {
                    Assert (IsExpandoDispid(dispidSrc));

                    dispidHandler = PH()->AtomToEventDispid(dispidSrc - DISPID_EXPANDO_BASE);
                    fConnectNow = TRUE;

                    lFlags &= ~BEHAVIOREVENTFLAGS_BUBBLE; // disable bubbling for anything but standard events
                }

                break;

            case DISP_E_UNKNOWNNAME:
                {

                    CAtomTable * pAtomTable = PH()->_pElement->GetAtomTable();

                    Assert(pAtomTable && "missing atom table");

                    hr = THR(pAtomTable->AddNameToAtomTable (pchEvent, &dispidHandler));
                    if (hr)
                        goto Cleanup;

                    dispidHandler = PH()->AtomToEventDispid(dispidHandler);

                    lFlags &= ~BEHAVIOREVENTFLAGS_BUBBLE; // disable bubbling for anything but standard events
                }
                break;

            default:
                // fatal error
                goto Cleanup;
            }

            c = pEventsArray->Size();

            hr = THR(pEventsArray->EnsureSize(c + 1));
            if (hr)
                goto Cleanup;

            pEventsArray->SetSize(c + 1);

            // c is now index of the last (yet uninitialized) item of the array

            (*pEventsArray)[c].dispid  = dispidHandler;
            (*pEventsArray)[c].lFlags = lFlags;

            *plCookie = c;

            if (pFactory && !pComponent->Dirty() && pComponent->_fFirstInstance)
            {
                AssertSz(c < HTC_PROPMETHODNAMEINDEX_BASE, "More than 4095 custom events in htc");
                Assert(pFactory->_fFactoryComponent && !pComponent->_fFactoryComponent);
                pFactory->AddAtom(pchEvent, LongToPtr(c));
            }

            if (fConnectNow && PH()->_pElement->IsInMarkup())
            {
                // case when the event handler is inlined: <A:B onFooEvent = "..." >

                BOOL fRunScript;
                hr = THR(PH()->_pElement->GetMarkup()->ProcessURLAction(URLACTION_SCRIPT_RUN, &fRunScript));
                if (hr || !fRunScript)
                    goto Cleanup;

                Assert(!pContextComponent || (TagNameToHtcBehaviorType(PH()->_pElement->TagName()) & HTC_BEHAVIOR_ATTACH));

                // construct and connect code
                hr = THR(PH()->_pElement->ConnectInlineEventHandler(
                    dispidSrc,          // dispid of expando with text of code
                    dispidHandler,      // dispid of function pointer in attr array
                    0, 0,               // line/offset info - not known here - will be retrieved from attr array
                    FALSE,              // fStandard
                    NULL,
                    pContextComponent));// this instance of lightwight htc for <ATTACH> builtins
                if (hr)
                    goto Cleanup;
            }
        }
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::CreateEventObject, per IElementBehaviorSiteOM
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::CreateEventObject(IHTMLEventObj ** ppEventObject)
{
    HRESULT     hr;

    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    hr = THR(CEventObj::Create(ppEventObject, Doc(), PH()->_pElement, NULL, /* fCreateAttached = */FALSE, PH()->_cstrUrn));

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::FireEvent, helper
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::FireEvent(
    LONG            lCookie,
    BOOL            fSameEventObject,
    IDispatch *     pdispContextThis)
{
    HRESULT         hr = S_OK;
    LONG            lFlags;
    DISPID          dispid;
    CDoc *          pDoc = Doc();
    CTreeNode *     pNode = PH()->_pElement->GetFirstBranch();

    if (PH()->CustomEventsCount() <= lCookie)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!fSameEventObject)
    {
        pDoc->_pparam->SetNodeAndCalcCoordinates(pNode);

        if (!pDoc->_pparam->GetSrcUrn())
             pDoc->_pparam->SetSrcUrn(PH()->_cstrUrn);
        // (do not check here pDoc->_pparam->GetSrcUrn()[0] - allow the string to be 0-length)

        if( !pDoc->_pparam->GetType() )
        {
            LPTSTR pStrEvent = PH()->CustomEventName( lCookie );

            // If the event name begins with "on",
            // and there's something after the "on",
            // strip it off for the type
            if(     !StrCmpNIC( pStrEvent, _T("on"), 2 )
                &&  pStrEvent[2] != _T('\0') )
            {
                pDoc->_pparam->SetType( pStrEvent + 2 );
            }
            else
            {
                pDoc->_pparam->SetType( pStrEvent );
            }
        }
    }

    dispid  = PH()->CustomEventDispid(lCookie);
    lFlags  = PH()->CustomEventFlags (lCookie);

    TraceTag((tagPeerFireEvent,
        "CPeerHolder::CPeerSite::FireEvent %08lX  Cookie: %d   DispID: %08lX  Flags: %08lX  Custom Name: %ls",
        PH(), lCookie, dispid, lFlags, STRVAL(PH()->CustomEventName(lCookie))));

    //
    // now fire
    //

    if (BEHAVIOREVENTFLAGS_BUBBLE & lFlags)
    {
        Assert (!pdispContextThis);

        IGNORE_HR(PH()->_pElement->BubbleEventHelper(
            pNode, 0, dispid, dispid, /* fRaisedByPeer = */ TRUE, NULL));
    }
    else
    {
        if (!PH()->_pElement->GetAAdisabled())
        {
            IGNORE_HR(PH()->_pElement->CBase::FireEvent(
                pDoc, PH()->_pElement, NULL, dispid, dispid, NULL, NULL, FALSE, pdispContextThis));
        }
    }

Cleanup:

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::FireEvent, per IElementBehaviorSiteOM
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::FireEvent(LONG lCookie, IHTMLEventObj * pEventObject)
{
    HRESULT     hr = S_OK;

    if (PH()->IllegalSiteCall() || !PH()->_pEventsBag)
        RRETURN(E_UNEXPECTED);

    hr = THR(FireEvent(lCookie, pEventObject, /* fReuseCurrentEventObject = */ FALSE, NULL));

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::FireEvent, helper (used by HTC)
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::FireEvent(
    LONG                lCookie,
    IHTMLEventObj *     pEventObject,
    BOOL                fReuseCurrentEventObject,
    IDispatch *         pdispContextThis)
{
    HRESULT     hr = S_OK;

    // NOTE any change here might have to be mirrored in CHtmlComponentAttach::FireHandler

    if (fReuseCurrentEventObject)
    {
        IGNORE_HR(FireEvent(lCookie, fReuseCurrentEventObject, pdispContextThis));
    }
    else if (pEventObject)
    {
        CEventObj::COnStackLock onStackLock(pEventObject);

        IGNORE_HR(FireEvent(lCookie, fReuseCurrentEventObject, pdispContextThis));
    }
    else
    {
        EVENTPARAM param(Doc(), PH()->_pElement, NULL, TRUE); // so to replace pEventObject

        IGNORE_HR(FireEvent(lCookie, fReuseCurrentEventObject, pdispContextThis));
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::RegisterName, per IElementBehaviorSiteOM
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::RegisterName(BSTR bstrName)
{
    HRESULT hr;

    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    hr = THR(PH()->_cstrName.Set(bstrName));

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::RegisterUrn, per IElementBehaviorSiteOM
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::RegisterUrn(BSTR bstrName)
{
    HRESULT hr;

    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    hr = THR(PH()->_cstrUrn.Set(bstrName));

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::Invalidate, per IElementBehaviorSiteRender
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::Invalidate(LPRECT pRect)
{
    CElement     * pElemToUse = GetElementToUseForPageTransitions();
    if(!pElemToUse)
        RRETURN(E_UNEXPECTED);

    CLayoutContext * pLayoutContext = GetLayoutContext(PH());

    // Invalidate all the layouts
    if(pElemToUse->HasLayoutAry() && pLayoutContext == GUL_USEFIRSTLAYOUT)
    {
        // We don't know which one to invalidate, invalidate all of the layouts
        // Passig null will invalidate Layouts versus Dispnodes
        InvalidateAllLayouts(pElemToUse, NULL);
        return S_OK;
    }


    CLayout * pLayout = pElemToUse->GetUpdatedLayout(pLayoutContext);

    if (PH()->IllegalSiteCall() || !pLayout)
        RRETURN(E_UNEXPECTED);


    // TODO (sambent) VML calls Invalidate before we've recognized it as a rendering peer
    // Assert(PH()->_pRenderBag->_pAdapter);

    pLayout->Invalidate(pRect);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::InvalidateRenderInfo, per IElementBehaviorSiteRender
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::InvalidateRenderInfo()
{
    HRESULT     hr;

    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag || !PH()->_pRenderBag->_pAdapter)
        RRETURN(E_UNEXPECTED);

    hr = THR(PH()->UpdateRenderBag());

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::InvalidateStyle, per IElementBehaviorSiteRender
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::InvalidateStyle()
{
    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    PH()->_pElement->EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES);

    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::InvalidateLayoutInfo, per IElementBehaviorSiteLayout
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::InvalidateLayoutInfo()
{
    HRESULT     hr;

     if (   PH()->IllegalSiteCall()
         || !PH()->_pLayoutBag
         || !PH()->_pLayoutBag->_pPeerLayout)
     {
         hr = E_UNEXPECTED;
         goto Cleanup;
     }

    hr = THR(PH()->_pLayoutBag->_pPeerLayout->GetLayoutInfo(&PH()->_pLayoutBag->_lLayoutInfo));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetElementToUseForPageTransitions
//                    This will return the element that the peer is attached.
//                    If in the middle of a page transition and the element is
//                  the root element it will return the canvas element of the
//                  old or new markup, depending on the transition state
//----------------------------------------------------------------------------

CElement *
CPeerHolder::CPeerSite::GetElementToUseForPageTransitions()
{
   return PH()->GetElementToUseForPageTransitions();
}


//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::InvalidateSize, per IElementBehaviorSiteLayout
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::InvalidateSize()
{
    if (   PH()->IllegalSiteCall()
        || !PH()->_pLayoutBag
        || !PH()->_pLayoutBag->_pPeerLayout
        || !PH()->_pElement->IsInMarkup())
    {
        return E_UNEXPECTED;
    }

    CElement * pElemToUse = GetElementToUseForPageTransitions();
    if(!pElemToUse)
        RRETURN(E_UNEXPECTED);

    //
    // if we are locked for sizing, this means that the LB
    // has called InvalidateSize DURING its GetSize callback.
    // We can't handle this, short of posting a new message to
    // ourselves to do the remeasure notification.  That is probably
    // proper, but more work than we can do now ie5.5 RTM. so
    // for now, just return an error
    //
    if (pElemToUse->TestLock(CElement::ELEMENTLOCK_SIZING))
        return E_PENDING;

    pElemToUse->RemeasureInParentContext(NFLAGS_FORCE);

    return S_OK;
}


HRESULT
CPeerHolder::CPeerSite::GetMediaResolution (SIZE* psizeResolution)
{
    HRESULT hr = S_OK;

    if (!psizeResolution)
    {
        hr = E_POINTER;
    }
    else
    {
        CElement           *pElem          = PH()->_pElement;
        CFancyFormat const *pFF = pElem->GetFirstBranch()->GetFancyFormat();
        mediaType           mediaReference = pFF->GetMediaReference();
        CSize               sizeInch       = g_Zero.size;
        CLayoutContext    * pLayoutContext = GetLayoutContext(PH());

        if (   mediaReference == mediaTypeNotSet
            && pElem->HasLayoutAry())
        {
            if(!pLayoutContext || pLayoutContext == GUL_USEFIRSTLAYOUT)
            {
                CLayout *pFirstLayout = pElem->GetUpdatedLayout(GUL_USEFIRSTLAYOUT);

                Assert(pFirstLayout); //should be true since we already tested for HasLayoutAry()
                pLayoutContext = pFirstLayout->LayoutContext();
            }

            mediaReference = pLayoutContext->GetMedia();
        }

        // if this element has a media set on it, then use that value and override the
        // context information.  This is probably a bug in multiple views (but above todo).
        sizeInch = pElem->Doc()->GetView()->GetMeasuringDevice(mediaReference)->GetResolution();

        *psizeResolution = sizeInch;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::InvalidatePainterInfo, per IHTMLPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::InvalidatePainterInfo()
{
    HRESULT     hr;

    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag)
        RRETURN(E_UNEXPECTED);

    hr = THR(PH()->UpdateRenderBag());

    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::InvalidateRect, per IHTMLPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::InvalidateRect(RECT* prcInvalid)
{
    if(PH()->IllegalSiteCall()  || !PH()->_pRenderBag || !PH()->_pElement->IsInMarkup())
        RRETURN(E_UNEXPECTED);

    CElement     * pElemToUse = GetElementToUseForPageTransitions();
    if(!pElemToUse)
        RRETURN(E_UNEXPECTED);

    CLayoutContext    * pLayoutContext = GetLayoutContext(PH());
    CDispNode         * pDispNode;
    CLayout           * pLayout;

    // Invalidate all the layouts
    if(pElemToUse->HasLayoutAry() && pLayoutContext == GUL_USEFIRSTLAYOUT)
    {
        // We don't know which one to invalidate, invalidate all of the layouts
        InvalidateAllLayouts(pElemToUse, PH());
        return S_OK;
    }

    pLayout = pElemToUse->GetUpdatedNearestLayout(pLayoutContext); // EnsureLayoutInDefaultContext

    if (!pLayout)
        RRETURN(E_UNEXPECTED);

    pDispNode = pLayout->GetElementDispNode();

    if (pDispNode)
    {
        PH()->InvalidateRect(pDispNode, prcInvalid);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::InvalidateRegion, per IHTMLPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::InvalidateRegion(HRGN rgnInvalid)
{
    CLayoutContext * pLayoutContext = GetLayoutContext(PH());
    CLayout * pLayout = PH()->_pElement->GetUpdatedLayout(pLayoutContext);
    CElement     * pElemToUse = GetElementToUseForPageTransitions();

    if(!pElemToUse)
        RRETURN(E_UNEXPECTED);

    // Invalidate all the layouts
    if(pElemToUse->HasLayoutAry() && pLayoutContext == GUL_USEFIRSTLAYOUT)
    {
        // We don't know which one to invalidate, invalidate all of the layouts
        // Passig null will invalidate Layouts versus Dispnodes
        InvalidateAllLayouts(pElemToUse, NULL);
        return S_OK;
    }

    if (PH()->IllegalSiteCall() || !pLayout || !PH()->_pRenderBag)
        RRETURN(E_UNEXPECTED);

    pLayout->Invalidate(rgnInvalid);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetDrawInfo, per IHTMLPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::GetDrawInfo(LONG lFlags, HTML_PAINT_DRAW_INFO* pDrawInfo)
{
    HRESULT          hr              = S_OK;
    CElement       * pElemToUse      = NULL;
    CDispNode      * pDispNode       = NULL;
    DWORD            dwPrivateFlags  = 0;
    CLayoutContext * pLayoutContext = GetLayoutContext(PH());
    RENDER_CALLBACK_INFO *pCallbackInfo;

    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag || !PH()->_pElement->IsInMarkup())
    {
        hr = E_UNEXPECTED;

        goto done;
    }

    pElemToUse = GetElementToUseForPageTransitions();

    if(NULL == pElemToUse)
    {
        hr = E_UNEXPECTED;

        goto done;
    }

    pCallbackInfo = PH()->_pRenderBag->_pCallbackInfo;

    // Are we measuring in high resolution coordinates?
    // (Usually when printing or print previewing.)

    if (   pLayoutContext
        && (pLayoutContext != GUL_USEFIRSTLAYOUT)
        && (pLayoutContext->GetMedia() & mediaTypePrint))
    {
        dwPrivateFlags |= HTMLPAINT_DRAWINFO_PRIVATE_PRINTMEDIA;
    }

    // Are we a filter peer?

    if (PH()->IsFilterPeer())
    {
        dwPrivateFlags |= HTMLPAINT_DRAWINFO_PRIVATE_FILTER;
    }

    pDispNode = pElemToUse->GetUpdatedLayout(pLayoutContext)->GetElementDispNode();

    Assert(pDispNode);

    hr = pDispNode->GetDrawInfo(
                        pCallbackInfo,
                        lFlags,
                        dwPrivateFlags,
                        pDrawInfo);

done:

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::TransformLocalToGlobal, per IHTMLPaintSite
//
//----------------------------------------------------------------------------
HRESULT
CPeerHolder::CPeerSite::TransformLocalToGlobal(POINT ptLocal, POINT *pptGlobal)
{
    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag)
        RRETURN(E_UNEXPECTED);

    CLayoutContext * pLayoutContext = GetLayoutContext(PH());

    CLayout *pLayout = PH()->_pElement->GetUpdatedLayout(pLayoutContext);
    AssertSz(pLayout, "Call to CPeerSite::TransformLocalToGlobal on element with no layout");
    if (!pLayout)
        RRETURN(E_UNEXPECTED);

    CDispNode * pDispNode = pLayout->GetElementDispNode();
    Assert(pDispNode);

    // TODO (michaelw) sambent needs to change this to look at some flag tbd so that the behavior chooses
    //                 to which rect it renders.
    //
    //                 For now we just check for window top (which catches edit grab handles)
    COORDINATE_SYSTEM cs = (PH()->_pRenderBag->_sPainterInfo.lZOrder == HTMLPAINT_ZORDER_WINDOW_TOP) ? COORDSYS_BOX : COORDSYS_CONTENT;

    ptLocal.x -= PH()->_pRenderBag->_sPainterInfo.rcExpand.left;
    ptLocal.y -= PH()->_pRenderBag->_sPainterInfo.rcExpand.top;
    pDispNode->TransformPoint((CPoint)ptLocal, cs, (CPoint *)pptGlobal, COORDSYS_GLOBAL);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::TransformGlobalToLocal, per IHTMLPaintSite
//
//----------------------------------------------------------------------------
HRESULT
CPeerHolder::CPeerSite::TransformGlobalToLocal(POINT ptGlobal, POINT *pptLocal)
{
    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag)
        RRETURN(E_UNEXPECTED);

    CLayoutContext * pLayoutContext = GetLayoutContext(PH());

    CLayout *pLayout = PH()->_pElement->GetUpdatedLayout(pLayoutContext);
    AssertSz(pLayout, "Call to CPeerSite::TransformGlobalToLocal on element with no layout");
    if (!pLayout)
        RRETURN(E_UNEXPECTED);

    CDispNode * pDispNode = pLayout->GetElementDispNode();
    Assert(pDispNode);

    // TODO (michaelw) sambent needs to change this to look at some flag tbd so that the behavior chooses
    //                 to which rect it renders.
    //
    //                 For now we just check for window top (which catches edit grab handles)
    COORDINATE_SYSTEM cs = (PH()->_pRenderBag->_sPainterInfo.lZOrder == HTMLPAINT_ZORDER_WINDOW_TOP) ? COORDSYS_BOX : COORDSYS_CONTENT;

    pDispNode->TransformPoint((CPoint)ptGlobal, COORDSYS_GLOBAL, (CPoint *)pptLocal, cs);

    pptLocal->x += PH()->_pRenderBag->_sPainterInfo.rcExpand.left;
    pptLocal->y += PH()->_pRenderBag->_sPainterInfo.rcExpand.top;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetHitTestCookie
//
//----------------------------------------------------------------------------
HRESULT
CPeerHolder::CPeerSite::GetHitTestCookie(LONG *plCookie)
{
    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag)
        RRETURN(E_UNEXPECTED);

    if (!plCookie)
        RRETURN(E_POINTER);

    *plCookie = PH()->CookieID();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::DrawUnfiltered, per IHTMLFilterPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::DrawUnfiltered(HDC hdc, IUnknown *punkDrawObject,
                                       RECT rcBounds, RECT rcUpdate,
                                       LONG lDrawLayers)
{
    HRESULT     hr = S_OK;
    RENDER_CALLBACK_INFO *pCallbackInfo;

    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag || !PH()->_pElement->IsInMarkup())
        RRETURN(E_UNEXPECTED);

    Assert(!PH()->_pRenderBag->_fInFilterCallback);

    PH()->_pRenderBag->_fInFilterCallback = TRUE;

    pCallbackInfo = PH()->_pRenderBag->_pCallbackInfo;
    CDispDrawContext *pContext = pCallbackInfo ? (CDispDrawContext*)pCallbackInfo->_pContext
                                                : NULL;

    CElement * pElemToUse = GetElementToUseForPageTransitions();
    if(!pElemToUse)
        RRETURN(E_UNEXPECTED);

    hr = Doc()->GetView()->RenderElement(
                                pElemToUse,
                                pContext,
                                hdc,
                                punkDrawObject,
                                &rcBounds,
                                &rcUpdate,
                                lDrawLayers);

    PH()->_pRenderBag->_fInFilterCallback = FALSE;

    // Since we're drawing to a surface that may need to be used immediately,
    // flush the GDI batch to make sure it's complete before leaving this
    // method.  GdiFlush can return an error that drawing failed, but it's
    // probably not the concern of this function to return that error.

    ::GdiFlush();

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::HitTestPointUnfiltered, per IHTMLFilterPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::HitTestPointUnfiltered(POINT pt, LONG lDrawLayers, BOOL *pbHit)
{
    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag || !PH()->_pElement->IsInMarkup())
        RRETURN(E_UNEXPECTED);
    // For page transitions we attach filters to the root element (only element available)
    // at that time and delagate everything to the body or frameset element.
    CElement   * pElemToUse = GetElementToUseForPageTransitions();

    if (!pElemToUse)
        RRETURN(E_UNEXPECTED);

    CLayoutContext * pLayoutContext = GetLayoutContext(PH());

    Assert(!PH()->_pRenderBag->_fInFilterCallback);
    Assert(pElemToUse->GetUpdatedLayout(pLayoutContext));
    Assert(PH()->_pRenderBag->_pCallbackInfo);

    CDispNode * pDispNode = pElemToUse->GetUpdatedLayout(pLayoutContext)->GetElementDispNode();
    Assert(pDispNode);

    PH()->_pRenderBag->_fInFilterCallback = TRUE;
    RENDER_CALLBACK_INFO *pCallbackInfo = PH()->_pRenderBag->_pCallbackInfo;

    TraceTag((tagPainterHit, "%x +HitTestUnfiltered at %ld,%ld", this, pt.x, pt.y));

    HRESULT hr = pDispNode->HitTestUnfiltered(
                            (CDispHitContext*)pCallbackInfo->_pContext,
                            PH()->_pRenderBag->_fHitContent,
                            &pt,
                            lDrawLayers,
                            pbHit);

    TraceTag((tagPainterHit, "%x -HitTestUnfiltered at %ld,%ld returns %s",
                        this, pt.x, pt.y, (*pbHit? "true" : "false") ));

    PH()->_pRenderBag->_fInFilterCallback = FALSE;

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::InvalidateRectFiltered, per IHTMLFilterPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::InvalidateRectFiltered(RECT *prcInvalid)
{
    if(PH()->IllegalSiteCall() || !PH()->_pRenderBag || !PH()->_pElement->IsInMarkup())
        RRETURN(E_UNEXPECTED);
    // For page transitions we attach filters to the root element (only element available)
    // at that time and delagate everything to the body or frameset element.
    CElement     * pElemToUse = GetElementToUseForPageTransitions();
    if(!pElemToUse)
        RRETURN(E_UNEXPECTED);

    CLayoutContext * pLayoutContext = GetLayoutContext(PH());

    CLayout * pLayout = pElemToUse->GetUpdatedNearestLayout(pLayoutContext); // EnsureLayoutInDefaultContext

    if (!pLayout)
        RRETURN(E_UNEXPECTED);

    CDispNode *pDispNode = pLayout->GetElementDispNode();

    if (pDispNode)
    {
        CRect rc;

        if (!prcInvalid)
        {
            rc.SetRect(pDispNode->GetSize());
            pDispNode->GetMappedBounds(&rc);
        }
        else
        {
            rc = *prcInvalid;
        }

        pDispNode->Invalidate(rc, COORDSYS_BOX, PH()->_pRenderBag->_fSyncRedraw, TRUE);
    }

    RRETURN (S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::InvalidateRgnFiltered, per IHTMLFilterPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::InvalidateRgnFiltered(HRGN hrgnInvalid)
{
    if(PH()->IllegalSiteCall()  || !PH()->_pRenderBag || !PH()->_pElement->IsInMarkup())
        RRETURN(E_UNEXPECTED);

    CElement     * pElemToUse = GetElementToUseForPageTransitions();
    if(!pElemToUse)
        RRETURN(E_UNEXPECTED);

    CLayoutContext * pLayoutContext = GetLayoutContext(PH());

    CLayout * pLayout = pElemToUse->GetUpdatedNearestLayout(pLayoutContext); // EnsureLayoutInDefaultContext

    if (!pLayout)
        RRETURN(E_UNEXPECTED);

    CDispNode *pDispNode = pLayout->GetElementDispNode();

    if (pDispNode)
    {
        pDispNode->Invalidate(hrgnInvalid, COORDSYS_BOX, PH()->_pRenderBag->_fSyncRedraw, TRUE);
    }

    RRETURN (S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::ChangeFilterVisibility, per IHTMLFilterPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::ChangeFilterVisibility(BOOL fVisible)
{
    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag)
        RRETURN(E_UNEXPECTED);

    CRenderBag *pRenderBag = PH()->_pRenderBag;
    fVisible = !!fVisible;

    if (!!pRenderBag->_fFilterInvisible != !fVisible)
    {
        pRenderBag->_fFilterInvisible = !fVisible;

        TraceTag((tagFilterVisible, "%ls %d (%x) set filVis=%d  Now eltVis=%d filVis=%d",
                    PH()->_pElement->TagName(), PH()->_pElement->SN(), PH()->_pElement,
                    fVisible,
                    !pRenderBag->_fElementInvisible,
                    !pRenderBag->_fFilterInvisible));

        if (!pRenderBag->_fBlockPropertyNotify)
        {
            PH()->_pElement->Doc()->RequestElementChangeVisibility(PH()->_pElement);
        }
    }

    RRETURN (S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::EnsureViewForFilterSite, per IHTMLFilterPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::EnsureViewForFilterSite()
{
    if (PH()->IllegalSiteCall() || !PH()->_pRenderBag)
        RRETURN(E_UNEXPECTED);

    PH()->_pElement->Doc()->GetView()->EnsureView(LAYOUT_SYNCHRONOUS);

    RRETURN (S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetDirectDraw, per IHTMLFilterPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::GetDirectDraw(void ** ppDirectDraw)
{
    HRESULT hr = S_OK;

    LOCK_SECTION(g_csOscCache);

    if (NULL == g_pDirectDraw)
    {
        hr = InitSurface();

        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (g_pDirectDraw)
    {
        hr = g_pDirectDraw->QueryInterface(IID_IDirectDraw, ppDirectDraw);
    }
    else
    {
        hr = E_NOINTERFACE;
    }

done:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetFilterFlags, per IHTMLFilterPaintSite
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::GetFilterFlags(DWORD *pdwFlags)
{
    HRESULT hr = S_OK;

    LOCK_SECTION(g_csOscCache);
    CElement * pElemToUse;

    if(!pdwFlags)
    {
        hr = E_POINTER;
        goto Done;
    }

    *pdwFlags = 0l;

    pElemToUse = PH()->_pElement;

    if(pElemToUse && pElemToUse->IsRoot())
    {
        CDocument * pDocument = pElemToUse->DocumentOrPendingDocument();
        if(pDocument && pDocument->HasPageTransitions())
        {
            *pdwFlags |= (DWORD)FILTER_FLAGS_PAGETRANSITION;
        }
    }

Done:
    RRETURN(hr);
}



///////////////////////////////////////////////////////////////////////////
//
// helper class: peers enumerator
//
///////////////////////////////////////////////////////////////////////////

class CPeerEnumerator : IEnumUnknown
{
public:

    // construction and destruction

    CPeerEnumerator (DWORD dwDir, LPTSTR pchCategory, CElement * pElementStart);
    ~CPeerEnumerator();

    static HRESULT Create(DWORD dwDir, LPTSTR pchCategory, CElement * pElementStart, IEnumUnknown ** ppEnumerator);

    // IUnknown

    DECLARE_FORMS_STANDARD_IUNKNOWN(CPeerEnumerator);

    // IEnumUnknown

    STDMETHOD(Next)(ULONG c, IUnknown ** ppUnkBehavior, ULONG * pcFetched);
    STDMETHOD(Skip)(ULONG c);
    STDMETHOD(Reset)(void);
    STDMETHOD(Clone)(IEnumUnknown ** ppEnumerator);

    // helpers

    BOOL Next();

    // data

    DWORD               _dwDir;
    CStr                _cstrCategory;
    CElement *          _pElementStart;
    CTreeNode *         _pNode;
    CElement *          _pElementCurrent;
    CPeerHolder *       _pPeerHolderCurrent;
};

//+---------------------------------------------------------------------------
//
//  Member:     CPeerEnumerator constructor
//
//----------------------------------------------------------------------------

CPeerEnumerator::CPeerEnumerator (DWORD dwDir, LPTSTR pchCategory, CElement * pElementStart)
{
    _ulRefs = 1;

    _dwDir = dwDir;
    _cstrCategory.Set(pchCategory);
    _pElementStart = pElementStart;

    _pNode = NULL;

    _pElementStart->AddRef(); // so that if someone blows this away from tree we won't not crash

    Reset();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerEnumerator destructor
//
//----------------------------------------------------------------------------

CPeerEnumerator::~CPeerEnumerator()
{
    _pElementStart->Release();

    if (_pNode)
        _pNode->NodeRelease();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerEnumerator::QueryInterface, per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPeerEnumerator::QueryInterface(REFIID riid, LPVOID * ppv)
{
    if (IsEqualGUID(IID_IUnknown, riid) || IsEqualGUID(IID_IEnumUnknown, riid))
    {
        *ppv = this;
        RRETURN(S_OK);
    }
    else
    {
        *ppv = NULL;
        RRETURN (E_NOINTERFACE);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerEnumerator::Reset, per IEnumUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPeerEnumerator::Reset(void)
{
    HRESULT hr = S_OK;

    // cleanup previously set values

    if (_pNode)
    {
        _pNode->NodeRelease();
        _pNode = NULL;
    }

    // init

    _pNode = _pElementStart->GetFirstBranch();
    if (!_pNode)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    hr = THR( _pNode->NodeAddRef() );
    if( hr )
    {
        _pNode = NULL;
        goto Cleanup;
    }

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerEnumerator::Next, helper
//
//----------------------------------------------------------------------------

BOOL
CPeerEnumerator::Next()
{
    if (!_pNode)
        return FALSE;

    for (;;)
    {
        // TODO: what if _pNode goes away after this release?!?!
        _pNode->NodeRelease();

        switch (_dwDir)
        {
        case BEHAVIOR_PARENT:

            _pNode = _pNode->Parent();

            break;
        }

        if (!_pNode)
            return FALSE;

        if( _pNode->NodeAddRef() )
        {
            _pNode = NULL;
            return FALSE;
        }

        _pElementCurrent = _pNode->Element();

        _pPeerHolderCurrent = NULL;

        if (_pElementCurrent->HasPeerHolder())
        {
            if (_pElementCurrent->GetPeerHolder()->IsRelatedMulti(_cstrCategory, &_pPeerHolderCurrent))
                return TRUE;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerEnumerator::Next, per IEnumUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPeerEnumerator::Next(ULONG c, IUnknown ** ppUnkBehaviors, ULONG * pcFetched)
{
    ULONG       i;
    HRESULT     hr = S_OK;
    IUnknown ** ppUnk;

    if (0 == c || !ppUnkBehaviors)
        RRETURN (E_INVALIDARG);

    for (i = 0, ppUnk = ppUnkBehaviors; i < c; i++, ppUnk++)
    {
        if (!Next())
        {
            hr = E_FAIL;
            break;
        }

        hr = THR(_pPeerHolderCurrent->QueryPeerInterface(IID_IUnknown, (void**)ppUnk));
        if (hr)
            break;
    }

    if (pcFetched)
        *pcFetched = i;

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerEnumerator::Skip, per IEnumUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPeerEnumerator::Skip(ULONG c)
{
    ULONG i;

    for (i = 0; i < c; i++)
    {
        if (!Next())
            break;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerEnumerator::Clone, per IEnumUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
CPeerEnumerator::Clone(IEnumUnknown ** ppEnumerator)
{
    RRETURN (Create(_dwDir, _cstrCategory, _pElementStart, ppEnumerator));
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerEnumerator::Create, per IEnumUnknown
//
//----------------------------------------------------------------------------

HRESULT
CPeerEnumerator::Create(DWORD dwDir, LPTSTR pchCategory, CElement * pElementStart, IEnumUnknown ** ppEnumerator)
{
    HRESULT             hr = S_OK;
    CPeerEnumerator *   pEnumerator = NULL;

    pEnumerator = new CPeerEnumerator (dwDir, pchCategory, pElementStart);
    if (!pEnumerator)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *ppEnumerator = pEnumerator;

Cleanup:
    // do not do pEnumerator->Release();

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::GetRelatedBehavior, per IElementBehaviorSiteCategory
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::GetRelatedBehaviors (LONG lDir, LPTSTR pchCategory, IEnumUnknown ** ppEnumerator)
{
    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    if (BEHAVIOR_PARENT != lDir)
        RRETURN (E_NOTIMPL);

    if (!pchCategory || !ppEnumerator ||
        lDir < BEHAVIOR_FIRSTRELATION || BEHAVIOR_LASTRELATION < lDir)
        RRETURN (E_INVALIDARG);

    RRETURN (CPeerEnumerator::Create(lDir, pchCategory, PH()->_pElement, ppEnumerator));
}

//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::OnChanged, per IPropertyNotifySink
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::OnChanged(DISPID dispid)
{
    HRESULT     hr = S_OK;
    CLock       lock(PH()); // reason to lock: whe might run onpropertychange and onreadystatechange scripts here

    if (PH()->IllegalSiteCall())
        RRETURN(E_UNEXPECTED);

    //
    // custom processing
    //

    switch (dispid)
    {
    case DISPID_READYSTATE:
        {
            HRESULT     hr;

            if (PH()->_readyState == READYSTATE_UNINITIALIZED)  // if the peer did not provide connection point
                goto Cleanup;                                   // don't support it's readyState changes

            hr = THR(PH()->UpdateReadyState());
            if (hr)
                goto Cleanup;

            CPeerMgr::UpdateReadyState(PH()->_pElement, PH()->_readyState);

            goto Cleanup; // done
        }
        break;
    }

    //
    // default processing
    //

    if (PH()->_pElement)
    {
        PH()->_pElement->OnPropertyChange(PH()->MapToExternalRange(dispid), 0);
    }

Cleanup:
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPeerHolder::CPeerSite::OnChanged, per IPropertyNotifySink
//
//----------------------------------------------------------------------------

HRESULT
CPeerHolder::CPeerSite::Exec(
    const GUID *    pguidCmdGroup,
    DWORD           nCmdID,
    DWORD           nCmdExecOpt,
    VARIANT *       pvarArgIn,
    VARIANT *       pvarArgOut)
{
    HRESULT     hr = OLECMDERR_E_UNKNOWNGROUP;

    if (!pguidCmdGroup)
        goto Cleanup;

    if (IsEqualGUID(CGID_ElementBehaviorMisc, *pguidCmdGroup))
    {
        hr = OLECMDERR_E_NOTSUPPORTED;

        switch (nCmdID)
        {
        case CMDID_ELEMENTBEHAVIORMISC_GETCONTENTS:

            if (!pvarArgOut)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            V_VT(pvarArgOut) = VT_BSTR;
            Assert( ETAG_GENERIC_NESTED_LITERAL != PH()->_pElement->Tag() );
            if ( ETAG_GENERIC_LITERAL == PH()->_pElement->Tag() )
            {
                hr = THR(FormsAllocString(
                    DYNCAST(CGenericElement, PH()->_pElement)->_cstrContents,
                    &V_BSTR(pvarArgOut)));
            }
            else
            {
                hr = THR(PH()->_pElement->get_innerHTML(&V_BSTR(pvarArgOut)));
            }

            break;

        case CMDID_ELEMENTBEHAVIORMISC_PUTCONTENTS:

            if (!pvarArgIn ||
                VT_BSTR != V_VT(pvarArgIn))
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            Assert( ETAG_GENERIC_NESTED_LITERAL != PH()->_pElement->Tag() );
            if ( ETAG_GENERIC_LITERAL == PH()->_pElement->Tag() )
            {
                CExtendedTagDesc *  pDesc = PH()->_pElement->GetExtendedTagDesc();

                // for Literal Identity behaviors, we have to dirty the doc
                if (pDesc && pDesc->_fLiteral)
                {
                    // TODO (JHarding): How is undo working with this?  Right now, we're going to
                    // dirty the doc and blow away the undo stack.
                    // TODO (alexz[v]) delete this
                    PH()->_pElement->QueryCreateUndo(TRUE, TRUE);
                }

                hr = THR(DYNCAST(CGenericElement, PH()->_pElement)->_cstrContents.Set(V_BSTR(pvarArgIn)));
            }
            else
            {
                hr = THR(PH()->_pElement->put_innerHTML(V_BSTR(pvarArgIn)));
            }

            break;

        case CMDID_ELEMENTBEHAVIORMISC_GETCURRENTDOCUMENT:

            if (!pvarArgOut)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            if (PH()->_pElement->IsInMarkup())
            {
                V_VT(pvarArgOut) = VT_UNKNOWN;
                hr = THR(PH()->_pElement->get_document((IDispatch**)&V_UNKNOWN(pvarArgOut)));
            }
            else
            {
                VariantClear(pvarArgOut);
                V_VT(pvarArgOut) = VT_NULL;
                hr = S_OK;
            }

            break;

        case CMDID_ELEMENTBEHAVIORMISC_ISSYNCHRONOUSBEHAVIOR:

            if (!pvarArgOut)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            hr = S_OK;

            // TODO (alexz) reconsider a better way to do this

            V_VT(pvarArgOut) = VT_I4;
            // V_I4(pvarArgOut) is now fRequestSynchronous

            if (PH()->IsIdentityPeer())
            {
                // identity peer can be asynchronous only when it is to be created for an element
                // in a markup being asynchronously parsed at this moment

                CMarkup * pMarkup = PH()->_pElement->GetMarkup();

                if (pMarkup)
                {
                    if (pMarkup->_LoadStatus < LOADSTATUS_QUICK_DONE)
                    {
                        // markup parsing is in progress

                        Assert (pMarkup->HtmCtx());

                        if (pMarkup->HtmCtx()->IsSyncParsing())
                        {
                            // the markup is being parsed synchronously, so request the identity peer
                            // to be created synchronously too
                            V_I4(pvarArgOut) = TRUE;
                        }
                        else
                        {
                            // the markup is being parsed asynchronously, so we can suspend parser
                            // if necessary and therefore we don't need to request synchronous creation

                            V_I4(pvarArgOut) = FALSE;
                        }
                    }
                    else
                    {
                        // element is created after markup has been parsed (using OM)
                        // so the identity peer is required to be synchronous
                        V_I4(pvarArgOut) = TRUE;
                    }
                }
                else
                {
                    // element is created outside markup (using OM), so the identity peer is
                    // required to be synchronous
                    V_I4(pvarArgOut) = TRUE;
                }
            }
            else
            {
                // attached peers never required to be synchronous
                V_I4(pvarArgOut) = FALSE;
            }


            break;

        case CMDID_ELEMENTBEHAVIORMISC_REQUESTBLOCKPARSERWHILEINCOMPLETE:

            // honor this only for identity behaviors
            if (PH()->IsIdentityPeer())
            {
                PH()->SetFlag(BLOCKPARSERWHILEINCOMPLETE);
            }
            hr = S_OK;

            break;

        }
    }

Cleanup:
    RRETURN (hr);
}

HRESULT
CPeerHolder::CPeerSite::GetFontInfo(LOGFONTW* plf)
{
    HRESULT hr = E_FAIL;

    if (!plf)
    {
        hr = E_POINTER;
    }
    else
    {
        CElement * pElem = PH()->_pElement;
        if (pElem && pElem->IsInMarkup())
        {
            CDocInfo dci(pElem);
            XHDC hdc(pElem->Doc()->GetHDC(), NULL);
            CCharFormat const * pcf = pElem->GetFirstBranch()->GetCharFormat();

            CCcs ccs;
            if (fc().GetCcs(&ccs, hdc, &dci, pcf))
            {
                const CBaseCcs * pBaseCcs = ccs.GetBaseCcs();
                if (pBaseCcs->GetLogFont(plf))
                    hr = S_OK;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\progsink.cxx ===
//+------------------------------------------------------------------------
//
//  File:       progsink.cxx
//
//  Contents:   IProgSink implementation for CDoc
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_PRGSNK_H_
#define X_PRGSNK_H_
#include "prgsnk.h"
#endif

#ifndef X_PROGSINK_HXX_
#define X_PROGSINK_HXX_
#include "progsink.hxx"
#endif

//+---------------------------------------------------------------------------
//  Debugging Support
//----------------------------------------------------------------------------

DeclareTag(tagProgSink, "ProgSink", "Trace ProgSink");
DeclareTag(tagProgSinkCookie, "ProgSink", "Don't reuse cookies for progsinks");

MtDefine(CProgSink, CDoc, "CProgSink")
MtDefine(CProgSink_aryProg_pv, CProgSink, "CProgSink::_aryProg::_pv")
MtDefine(CProgSinkText, CProgSink, "CProgSink (item text)")
MtDefine(CProgSinkFormat, CProgSink, "CProgSink (formatted text)")

#if DBG==1

static LPCSTR _apchProgClass[] =
{
    "HTML",
    "MULTIMEDIA",
    "CONTROL",
    "DATABIND",
    "OTHER",
    "NOREMAIN",
    "FRAME"
};

static LPCSTR _apchProgState[] =
{
    "IDLE",
    "FINISHING",
    "CONNECTING",
    "LOADING"
};

#endif

//+---------------------------------------------------------------------------
//  Definitions
//----------------------------------------------------------------------------

#define PROGSINK_CHANGE_COUNTERS    0x0001
#define PROGSINK_CHANGE_CURRENT     0x0002
#define PROGSINK_CHANGE_RESCAN      0x0004
#define PROGSINK_CHANGE_PROGRESS    0x0008

// these numbers should be scaled all togather not individually
// These numbers are intentionally set to a large number to take into account
// small download framents

#define PROGSINK_POTEN_HTML         4000    // potential for html
#define PROGSINK_POTEN_FRAME        2000    // potential for frame
#define PROGSINK_POTEN_BELOW        1000    // potential substract for lower level HTML/FRAME

#define PROGSINK_ADJUST_SCALE       1000    // adjust factor scale 1000 represent
#define PROGSINK_PROG_INIT          1000    // initial minimum
#define PROGSINK_PROG_MAX           10000   // total gauge range

#define PROGSINK_POTEN_MIN          100     // PROGSINK_ADJUST_SCALE * PROGSINK_PROG_INIT/PROGSINK_PROG_MAX
#define PROGSINK_POTEN_END          1

#define PROGSINK_PROG_MIN           0       // we start from this position

#define PROGSINK_PROG_STEP          100     // small progress step

#define PROGSINK_TEXT_LENGTH        512

//+---------------------------------------------------------------------------
//
//  Member:     FormatProgress
//
//  Synopsis:   Computes the final progress string for the entry
//
//----------------------------------------------------------------------------

void
FormatProgress(CDoc * pDoc, PROGDATA * ppd)
{
    Assert(ppd->pchFormat == NULL);

    TCHAR * pch = ppd->pchText;

    if (ppd->dwIds)
    {
        const TCHAR * pchArg   = pch ? pch : g_Zero.ach;
        TCHAR * pchAlloc = NULL;

        if (    *pchArg
            &&  (   ppd->dwIds == IDS_BINDSTATUS_DOWNLOADINGDATA_PICTURE
                ||  ppd->dwIds == IDS_BINDSTATUS_DOWNLOADINGDATA_TEXT
                ||  ppd->dwIds == IDS_BINDSTATUS_DOWNLOADINGDATA_BITS))
        {
            pchAlloc = GetFriendlyUrl(pchArg, NULL,
                pDoc->_pOptionSettings->fShowFriendlyUrl, FALSE);

            if (pchAlloc && *pchAlloc)
            {
                pchArg = pchAlloc;
            }
        }

        IGNORE_HR(Format(FMT_OUT_ALLOC, &ppd->pchFormat, 0,
            MAKEINTRESOURCE(ppd->dwIds), pchArg));

        MemFree(pchAlloc);

        if (ppd->pchFormat)
        {
            IGNORE_HR(MemRealloc(Mt(CProgSinkFormat), (void **)&ppd->pchFormat,
                (_tcslen(ppd->pchFormat) + 1) * sizeof(TCHAR)));
        }
    }
    else if (pch)
    {
        IGNORE_HR(MemAllocString(Mt(CProgSinkFormat), pch, &ppd->pchFormat));
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::CProgSink
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------

CProgSink::CProgSink(CDoc * pDoc, CMarkup * pMarkup)
    : CBaseFT(&_cs)
{
    _fCSInited = FALSE;

    _pDoc = pDoc;
    _pDoc->SubAddRef();

    _pMarkup = pMarkup;
    _pMarkup->SubAddRef();

    _pts = GetThreadState();

    SubAddRef();

#if DBG==1
    MemSetName((this, "CProgSink pDoc=%08x pProgSinkFwd=%08x", _pDoc, _pProgSinkFwd));

    if (_pProgSinkFwd)
        TraceTag((tagProgSink, "[%08lX] Construct (Forward to [%08lX])",
            this, _pProgSinkFwd));
    else
        TraceTag((tagProgSink, "[%08lX] Construct", this));
#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::Init
//
//  Synopsis:   Work around the error handling for InitializeCriticalSection
//
//----------------------------------------------------------------------------
HRESULT
CProgSink::Init()
{
    HRESULT     hr;

    hr = HrInitializeCriticalSection(&_cs);
    if (!hr)
        _fCSInited = TRUE;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::~CProgSink
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------

CProgSink::~CProgSink()
{
    if (_fCSInited)
        DeleteCriticalSection(&_cs);

    TraceTag((tagProgSink, "[%08lX] Destruct", this));
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::Passivate
//
//  Synopsis:   Releases all resources used by this object.  Puts it into
//              the passive state whereby all further progress calls are
//              rejected.
//
//----------------------------------------------------------------------------

void
CProgSink::Passivate()
{
    PROGDATA * ppd;
    UINT cSize;

    TraceTag((tagProgSink, "[%08lX] Passivate (enter)", this));

    EnterCriticalSection();

    _fPassive = TRUE;

    LeaveCriticalSection();

    if(_fSentSignal)
    {
        GWKillMethodCallEx(_pts, this, ONCALL_METHOD(CProgSink, OnMethodCall, onmethodcall), 0);
        // If we killed the pending window we need to Update the spin status synchronously
        // because the markup will go away soon, and we killed the posted message to update
        // the spin
        if(_pMarkup->_fWindowPending)
            DoUpdate(TRUE);
        _fSentSignal = FALSE;
    }

    cSize = _aryProg.Size();
    ppd = _aryProg;

    for (; cSize > 0; --cSize, ++ppd)
    {
        if (ppd->bFlags & PDF_FREE)
            continue;

        if (ppd->pchText)
            MemFree(ppd->pchText);

        if (ppd->pchFormat)
            MemFree(ppd->pchFormat);
    }

    _aryProg.DeleteAll();

    if (_fGotDefault)
    {
        MemFree(_pdDefault.pchText);
        _pdDefault.pchText = NULL;

        MemFree(_pdDefault.pchFormat);
        _pdDefault.pchFormat = NULL;

        _fGotDefault = FALSE;
    }


    _pDoc->SubRelease();
    _pDoc = NULL;

    _pMarkup->SubRelease();
    _pMarkup = NULL;

    ReleaseInterface(_pProgSinkFwd);

    TraceTag((tagProgSink, "[%08lX] Passivate (leave)", this));
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::Detach
//
//  Synopsis:   Called by CDoc before it releases it's final reference on
//              the CProgSink object.
//
//----------------------------------------------------------------------------

void
CProgSink::Detach()
{
    TraceTag((tagProgSink, "[%08lX] Detach", this));
    super::Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::QueryInterface, IUnknown
//
//  Synopsis:   As per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgSink::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IProgSink || iid == IID_IUnknown)
    {
        *ppv = (IProgSink *)this;
    }
    else
    {
        *ppv = 0;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::AddRef, IUnknown
//
//  Synopsis:   As per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CProgSink::AddRef()
{
    return(super::SubAddRef());
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::Release, IUnknown
//
//  Synopsis:   As per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CProgSink::Release()
{
    return(super::SubRelease());
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::AddProgress, IProgSink
//
//  Synopsis:   Allocates a slot in the progress vector
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgSink::AddProgress(DWORD dwClass, DWORD * pdwCookie)
{
    PROGDATA    pd;
    PROGDATA *  ppd;
    UINT        cSize;
    DWORD       dwCookie;
    HRESULT     hr = S_OK;

    if ((dwClass & ~(PROGSINK_CLASS_FORWARDED|PROGSINK_CLASS_NOSPIN)) > PROGSINK_CLASS_FRAME)
        RRETURN(E_INVALIDARG);

    memset(&pd, 0, sizeof(PROGDATA));
    pd.bClass = (BYTE)dwClass;
    pd.bState = PROGSINK_STATE_IDLE;
    pd.bBelow = !!(dwClass & PROGSINK_CLASS_FORWARDED);
    pd.bFlags = (dwClass & PROGSINK_CLASS_NOSPIN) ? PDF_NOSPIN : 0;

    EnterCriticalSection();

    if (_fPassive)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (_pProgSinkFwd)
    {
        hr = THR(_pProgSinkFwd->AddProgress(dwClass | PROGSINK_CLASS_FORWARDED,
                pdwCookie));
        if (hr)
            goto Cleanup;

        SetCounters(pd.bClass, FALSE, TRUE, FALSE);
        goto Cleanup;
    }

    if (_cFree > 0 WHEN_DBG(&& !IsTagEnabled(tagProgSinkCookie) ) )
    {
        // Look for a free slot to reuse

        ppd   = &_aryProg[0];
        cSize = _aryProg.Size();

        for (; cSize > 0; --cSize, ++ppd)
            if (ppd->bFlags & PDF_FREE)
                break;

        Assert(cSize > 0);

        *ppd = pd;
        _cFree -= 1;

        dwCookie = _aryProg.Size() - cSize + 1;
    }
    else
    {
        // Add a new slot to the end of the array

        hr = THR(_aryProg.AppendIndirect(&pd));
        if (hr)
            goto Cleanup;

        dwCookie = _aryProg.Size();
    }

    *pdwCookie = (dwCookie << 8) | pd.bClass;

    SetCounters(pd.bClass, !!pd.bBelow, TRUE, !(pd.bFlags & PDF_NOSPIN));

    TraceTag((tagProgSink, "[%08lX] AddProgress %2d%s %s",
        this, *pdwCookie >> 8, pd.bBelow ? "/b" : "",
        _apchProgClass[pd.bClass]));

Cleanup:
    LeaveCriticalSection();
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::SetProgress, IProgSink
//
//  Synopsis:   Sets the data associated with a progress slot
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgSink::SetProgress(DWORD dwCookie, DWORD dwFlags, DWORD dwState,
    LPCTSTR pchText, DWORD dwIds, DWORD dwPos, DWORD dwMax)
{
    PROGDATA * ppd;
    DWORD dwSlot;
    HRESULT hr = S_OK;

    EnterCriticalSection();

    if (_fPassive)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (_pProgSinkFwd)
    {
        hr = THR(_pProgSinkFwd->SetProgress(dwCookie, dwFlags, dwState,
                pchText, dwIds, dwPos, dwMax));
        goto Cleanup;
    }

    dwSlot = (dwCookie >> 8);

    if (dwSlot == 0 || dwSlot > (UINT)_aryProg.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    ppd = &_aryProg[dwSlot - 1];

    if (ppd->bFlags & PDF_FREE)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (dwFlags & PROGSINK_SET_STATE)
    {
        ppd->bState = (BYTE)dwState;
    }

    if (dwFlags & PROGSINK_SET_IDS)
    {
        ppd->dwIds = dwIds;

        if (ppd->pchFormat)
        {
            MemFree(ppd->pchFormat);
            ppd->pchFormat = NULL;
        }
    }

    if (dwFlags & PROGSINK_SET_TEXT)
    {
        if (pchText == NULL)
        {
            MemFree(ppd->pchText);
            ppd->pchText = NULL;
        }
        else
        {
            hr = THR(MemReplaceString(Mt(CProgSinkText), pchText, &ppd->pchText));
            if (hr)
                goto Cleanup;
        }

        if (ppd->pchFormat)
        {
            MemFree(ppd->pchFormat);
            ppd->pchFormat = NULL;
        }
    }

    if (dwFlags & (PROGSINK_SET_MAX | PROGSINK_SET_POS))
    {
        // update the progress
        // signal only if a progress is made
        if (UpdateProgress(ppd, dwFlags, dwPos, dwMax)
                    && !(_uChange & (PROGSINK_CHANGE_PROGRESS
                                    | PROGSINK_CHANGE_RESCAN
                                    | PROGSINK_CHANGE_CURRENT)))
        {
            Signal(PROGSINK_CHANGE_PROGRESS);
        }
    }

    if (!(_uChange & PROGSINK_CHANGE_RESCAN))
    {
        if (dwSlot == _dwSlotCur)
        {
            if (ppd->bState < _bStateCur || (!ppd->pchText && !ppd->dwIds))
                Signal(PROGSINK_CHANGE_RESCAN);
            else
                Signal(PROGSINK_CHANGE_CURRENT);
        }
        else if (   (ppd->pchText || ppd->dwIds)
                &&  ppd->bState > PROGSINK_STATE_IDLE
                &&  (   ppd->bBelow < _bBelowCur
                    ||  ppd->bState > _bStateCur))
        {
            Signal(PROGSINK_CHANGE_RESCAN);
        }
    }

#if DBG==1
    TraceTagEx((tagProgSink, TAG_NONEWLINE, "[%08lX] SetProgress %2d%s ",
        this, dwSlot, ppd->bBelow ? "/b" : ""));
    if (dwFlags & PROGSINK_SET_STATE)
        TraceTagEx((tagProgSink, TAG_NONAME|TAG_NONEWLINE, "%s ",
            _apchProgState[dwState]));
    if (dwFlags & (PROGSINK_SET_POS|PROGSINK_SET_MAX))
        TraceTagEx((tagProgSink, TAG_NONAME|TAG_NONEWLINE, "[%d/%d] ",
            ppd->dwPos, ppd->dwMax));
    if (dwFlags & PROGSINK_SET_IDS)
        TraceTagEx((tagProgSink, TAG_NONAME|TAG_NONEWLINE, "ids=%ld ",
            ppd->dwIds));
    if (dwFlags & PROGSINK_SET_TEXT)
        TraceTagEx((tagProgSink, TAG_NONAME|TAG_NONEWLINE, "\"%ls\"",
            pchText ? pchText : _T("")));
    TraceTagEx((tagProgSink, TAG_NONAME, ""));
#endif

Cleanup:
    LeaveCriticalSection();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::DelProgress, IProgSink
//
//  Synopsis:   Frees the given progress slot
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProgSink::DelProgress(DWORD dwCookie)
{
    PROGDATA * ppd;
    DWORD dwSlot;
    HRESULT hr = S_OK;

    EnterCriticalSection();

    if (_fPassive)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (_pProgSinkFwd)
    {
        hr = THR(_pProgSinkFwd->DelProgress(dwCookie));
        if (hr)
            goto Cleanup;

        SetCounters((BYTE)dwCookie, FALSE, FALSE, FALSE);
        goto Cleanup;
    }

    dwSlot = (dwCookie >> 8);

    if (dwSlot == 0 || dwSlot > (UINT)_aryProg.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    ppd = &_aryProg[dwSlot - 1];

    if (ppd->bFlags & PDF_FREE)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!ppd->bBelow && ppd->bClass == PROGSINK_CLASS_HTML && !_fGotDefault)
    {
        _pdDefault = *ppd;
        _fGotDefault = TRUE;
    }
    else
    {
        if (ppd->pchText)
            MemFree(ppd->pchText);
        if (ppd->pchFormat)
            MemFree(ppd->pchFormat);
    }

    if (ppd->dwPos && ppd->dwPos < ppd->dwMax)  // aborted download
    {
        _cOngoing --;
        // adjust dwMaxTotal so that we can let other download take the bar
        _dwMaxTotal = _dwMaxTotal - (ppd->dwMax - ppd->dwPos);
    }

    SetCounters(ppd->bClass, !!ppd->bBelow, FALSE, !(ppd->bFlags & PDF_NOSPIN));

    ppd->bFlags |= PDF_FREE;
    ppd->dwPos   = 0;
    ppd->dwMax   = 0;
    _cFree += 1;

    TraceTag((tagProgSink, "[%08lX] DelProgress %2d%s", this, dwSlot,
        ppd->bBelow ? "/b" : ""));

    if (_cFree == (UINT)_aryProg.Size())
    {
        _aryProg.DeleteAll();
        _cFree = 0;
    }

    // If we are currently displaying this progress slot, it's time to
    // look for a different one.

    if (dwSlot == _dwSlotCur)
    {
        Signal(PROGSINK_CHANGE_RESCAN);
    }

Cleanup:
    LeaveCriticalSection();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::SetCounters
//
//  Synopsis:   Adjusts the class counters to reflect the addition or
//              deletion of a progress slot.
//
//----------------------------------------------------------------------------

void
CProgSink::SetCounters(DWORD dwClass, BOOL fFwd, BOOL fAdd, BOOL fSpin)
{
    UINT *  pacClass = fFwd ? _acClassBelow : _acClass;
    UINT    cClass   = pacClass[dwClass];

    Assert(!fSpin || !_pProgSinkFwd);

    if (fAdd)
    {
        cClass += 1;
        _cActive += 1;
        _cSpin += !!fSpin;

        if (_cActive == 1)
        {
            _fSendProgDone = TRUE;
        }
    }
    else
    {
        Assert(cClass > 0);
        cClass -= 1;
        Assert(_cActive > 0);
        _cActive -= 1;
        Assert(!fSpin || _cSpin > 0);
        _cSpin -= !!fSpin;
        Assert(_cActive || !_cSpin);
    }

    pacClass[dwClass] = cClass;

    AdjustProgress(dwClass, fFwd, fAdd);

    // Certain transitions are interesting enough to wake up the client:
    //  a) If the HTML file is parsed
    //  b) If the HTML file, frames and controls have finished loading (connect scripts)
    //  c) If the total number of downloads reaches zero (send all done)
    //  d) If the total number of spin requests reaches zero (stop spinning)
    //  e) If the total number of spin requests reaches one (start spinning)

    if (_acClass[PROGSINK_CLASS_HTML] == 1)
    {
        _fSendParseDone = TRUE;
    }

    if (    !(_uChange & PROGSINK_CHANGE_COUNTERS)
        &&  (   (   !fFwd
                &&  !fAdd
                &&  dwClass == PROGSINK_CLASS_HTML
                &&  _acClass[PROGSINK_CLASS_HTML] == 0)
            ||  (   !fFwd
                &&  !fAdd
                &&  (   dwClass == PROGSINK_CLASS_HTML
                    ||  dwClass == PROGSINK_CLASS_FRAME
                    ||  dwClass == PROGSINK_CLASS_CONTROL)
                &&  _acClass[PROGSINK_CLASS_HTML] == 0
                &&  _acClass[PROGSINK_CLASS_FRAME] == 0
                &&  _acClass[PROGSINK_CLASS_CONTROL] == 0)
            ||  (!fAdd && _cActive == 0)
            ||  (!fAdd && fSpin && _cSpin == 0)
            ||  ( fAdd && fSpin && _cSpin == 1)))
    {
        Signal(PROGSINK_CHANGE_COUNTERS);
    }

    // If we are showing (n items remaining) and we've just removed one of
    // those items, then signal that client to update it.

    if (    !(_uChange & PROGSINK_CHANGE_RESCAN)
        &&  (!fAdd && _fShowItemsRemaining))
    {
        Signal(_dwSlotCur ? PROGSINK_CHANGE_CURRENT : PROGSINK_CHANGE_RESCAN);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::Signal
//
//  Synopsis:   Posts a message to the creation thread and requests a call
//              to OnProgSink.
//
//----------------------------------------------------------------------------

void
CProgSink::Signal(UINT uChange)
{
    TraceTag((tagProgSink, "[%08lX] Signal %s%s%s%s", this,
        (uChange & PROGSINK_CHANGE_COUNTERS) ? "COUNTERS " : "",
        (uChange & PROGSINK_CHANGE_CURRENT) ? "CURRENT " : "",
        (uChange & PROGSINK_CHANGE_RESCAN) ? "RESCAN " : "",
        (uChange & PROGSINK_CHANGE_PROGRESS) ? "PROGRESS " : ""));

    _uChange |= uChange;

    if (!_fSentSignal)
    {
        _fSentSignal = TRUE;

        IGNORE_HR(GWPostMethodCallEx(_pts, this,
            ONCALL_METHOD(CProgSink, OnMethodCall, onmethodcall), (DWORD_PTR)this, FALSE, "CProgSink::OnMethodCall"));
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::OnMethodCall
//
//  Synopsis:   Updates the status bar and sends progress feedback to the
//              doc in response to changes in the state of the progress sink.
//
//----------------------------------------------------------------------------

void BUGCALL
CProgSink::OnMethodCall(DWORD_PTR dwContext)
{
    Assert(dwContext == (DWORD_PTR)this);
    DoUpdate(FALSE);
    }

void BUGCALL
CProgSink::DoUpdate(BOOL fCleanupOnly)
{
    BOOL    fSendProgDone  = FALSE;
    BOOL    fSendSpin      = FALSE;
    BOOL    fSpin          = FALSE;
    DWORD   dwFlagsProg    = 0;
    DWORD   dwPos          = 0;
    DWORD   dwMax          = 0;
    TCHAR   achText[PROGSINK_TEXT_LENGTH];
    LOADSTATUS loadstatus  = LOADSTATUS_UNINITIALIZED;
    CDoc *  pDoc;

    Assert(GetCurrentThreadId() == _pts->dll.idThread);

    Assert(fCleanupOnly || !_fPassive);

    TraceTag((tagProgSink, "[%08lX] OnMethodCall (enter)", this));

    // Progsink refcounts are odd - this really is a SubAddRef.  We
    // only have 1 real ref, which is the creation ref the markup has,
    // and he releases that by calling Detach() which calls super::Release.
    // We don't want a real ref here, we just want to keep our memory around
    // because CDoc::SetProgress below can tear down our markup.
    AddRef();

    // Hack for ThumbNailView (IE5 bug #66938, #68010)
    // May need to compute formats now to initiate download of background
    // images, etc. Hosts like THUMBVW never make us inplace-active or give
    // us a window/view. This causes us to fire onload without ever needing
    // to compute formats. However, they call Draw() on us as soon as we fire
    // onload. We need the images loaded by then to be be able to render them.
    if (    _pDoc
        && !fCleanupOnly
        &&  _pDoc->_fThumbNailView
        &&  _pMarkup
        &&  (_uChange & PROGSINK_CHANGE_COUNTERS)
        &&  _fSendParseDone
        &&  !_fSentParseDone
        && _acClass[PROGSINK_CLASS_HTML] == 0
       )
    {
        _pMarkup->EnsureFormats();
    }

    EnterCriticalSection();

    if (_uChange & PROGSINK_CHANGE_COUNTERS)
    {
        if (!fCleanupOnly)
        {
            if (_fSendParseDone)
            {
                if (!_fSentParseDone && _acClass[PROGSINK_CLASS_HTML] == 0)
                {
                    TraceTag((tagProgSink, "[%08lX]   Sending ParseDone", this));
                    _fSentParseDone = TRUE;
                    if (loadstatus < LOADSTATUS_PARSE_DONE)
                        loadstatus = LOADSTATUS_PARSE_DONE;
                }

                if (    !_fSentQuickDone && _fSentParseDone
                    &&  _acClass[PROGSINK_CLASS_CONTROL] == 0
                    &&  _acClass[PROGSINK_CLASS_FRAME] == 0)
                {
                    TraceTag((tagProgSink, "[%08lX]   Sending QuickDone", this));
                    _fSentQuickDone = TRUE;
                    if (loadstatus < LOADSTATUS_QUICK_DONE)
                        loadstatus = LOADSTATUS_QUICK_DONE;
                }

                if (!_fSentDone && _cActive == 0)
                {
                    TraceTag((tagProgSink, "[%08lX]   Sending Done", this));
                    _fSentDone = TRUE;
                    if (loadstatus < LOADSTATUS_DONE)
                        loadstatus = LOADSTATUS_DONE;
                }
            }
        }
        if (!_pProgSinkFwd)
        {
            if (!!_fSpin != !!_cSpin)
            {
                TraceTag((tagProgSink, "[%08lX]   Setting fSpin to %s", this,
                    _fSpin ? "FALSE" : "TRUE"));
                _fSpin = !_fSpin;
                fSendSpin = TRUE;
                fSpin     = _fSpin;
            }

            if (_fSendProgDone && _cActive == 0)
            {
                fSendProgDone  = TRUE;
                _fSendProgDone = FALSE;
            }
        }
    }

    if (    (_uChange & (PROGSINK_CHANGE_RESCAN | PROGSINK_CHANGE_CURRENT | PROGSINK_CHANGE_PROGRESS))
        ||  fSendProgDone)
    {
        Assert(!_pProgSinkFwd);

        _bStateCur = PROGSINK_STATE_IDLE;
        achText[0] = 0;

        if (fSendProgDone)
        {
            Assert(_cActive == 0);
            LoadString(GetResourceHInst(), IDS_DONE,
                achText, ARRAY_SIZE(achText));

            if (_fGotDefault)
            {
                MemFree(_pdDefault.pchText);
                _pdDefault.pchText = NULL;

                MemFree(_pdDefault.pchFormat);
                _pdDefault.pchFormat = NULL;

                _fGotDefault = FALSE;
            }

            dwFlagsProg  = PROGSINK_SET_POS|PROGSINK_SET_MAX|PROGSINK_SET_TEXT;
            dwPos        = (ULONG)(-1);
            dwMax        = 0;

            _dwSlotCur   = 0;
            _bBelowCur   = TRUE;
            _dwMaxTotal  = 0;
            _dwProgCur   = 0;
            _dwProgMax   = 0;
            _dwProgDelta = 0;
            _cOngoing    = 0;
            _cPotential  = 0;
            _cPotTotal   = PROGSINK_POTEN_MIN;
            _cPotDelta   = 0;
            _fShowItemsRemaining = FALSE;
        }
        else
        {
            // If necessary, rescan for the best progress slot to show.

            if (_uChange & PROGSINK_CHANGE_RESCAN)
            {
                PROGDATA * ppd = &_aryProg[0];
                UINT cSize = _aryProg.Size();

                _dwSlotCur = 0;
                _bBelowCur = TRUE;

                for (UINT iSlot = 1; iSlot <= cSize; ++iSlot, ++ppd)
                {
                    if (    (ppd->bFlags & PDF_FREE)
                        ||  (!ppd->pchText && !ppd->dwIds)
                        ||  ppd->bState <= PROGSINK_STATE_IDLE
                        ||  ppd->bBelow > _bBelowCur
                        ||  (   ppd->bBelow == _bBelowCur
                            &&  ppd->bState <= _bStateCur))
                        continue;

                    _dwSlotCur = iSlot;
                    _bStateCur = ppd->bState;
                    _bBelowCur = ppd->bBelow;

                    if (_bStateCur == PROGSINK_STATE_LOADING && !_bBelowCur)
                        break;
                }
            }

            if (_uChange & (PROGSINK_CHANGE_RESCAN|PROGSINK_CHANGE_CURRENT))
            {
                // The progress text needs to be recomputed.

                LPTSTR pchText = achText;
                UINT   cchText = PROGSINK_TEXT_LENGTH;
                LPTSTR pchFormat = NULL;
                PROGDATA * ppd = NULL;

                if (_dwSlotCur)
                {
                    Assert(_dwSlotCur <= (UINT)_aryProg.Size());
                    ppd = &_aryProg[_dwSlotCur - 1];
                    _bStateCur = ppd->bState;
                }
                else if (_fGotDefault)
                {
                    ppd = &_pdDefault;
                }

                if (ppd)
                {
                    pchFormat = ppd->pchFormat;

                    if (pchFormat == NULL)
                    {
                        FormatProgress(_pDoc, ppd);
                        pchFormat = ppd->pchFormat;
                    }

                    if (pchFormat && !*pchFormat)
                    {
                        pchFormat = NULL;
                    }
                }

                // Prepend "(n items remaining)" if desired.

                if (_cPotential == 0)
                {
                    UINT cActive = _cActive -
                            _acClass[PROGSINK_CLASS_NOREMAIN] -
                            _acClassBelow[PROGSINK_CLASS_NOREMAIN];

                    if (_fShowItemsRemaining || cActive > 1)
                    {
                        _fShowItemsRemaining = TRUE;

                        if (cActive > 0)
                        {
                            Format(0, achText, cchText,
                                MAKEINTRESOURCE(IDS_BINDSTATUS_DOWNLOADING),
                                cActive);

                            UINT cch = _tcslen(achText);
                            pchText += cch;
                            cchText -= cch;
                        }
                    }
                }

                // Now append either the selected slot or the default string.

                if (pchFormat && cchText > 1)
                {
                    _tcsncpy(pchText, pchFormat, cchText - 1);
                    achText[ARRAY_SIZE(achText) - 1] = 0;
                }

                if (achText[0])
                {
                    dwFlagsProg |= PROGSINK_SET_TEXT;
                }
            }

            if (_uChange & PROGSINK_CHANGE_PROGRESS)
            {
                dwPos = _dwProgCur;
                dwMax = PROGSINK_PROG_MAX;
                dwFlagsProg |= PROGSINK_SET_POS | PROGSINK_SET_MAX;
            }
        }

        #if DBG==1
        if (dwFlagsProg)
            TraceTag((tagProgSink,
                "[%08lX]   SetProgress %c%c%c [%ld/%ld] \"%ls\" %s",
                this, (dwFlagsProg & PROGSINK_SET_POS) ? 'P' : ' ',
                (dwFlagsProg & PROGSINK_SET_MAX) ? 'M' : ' ',
                (dwFlagsProg & PROGSINK_SET_TEXT) ? 'T' : ' ',
                dwPos, dwMax, achText, fSendProgDone ? "(flash)" : ""));
        #endif
    }

     _fSentSignal = FALSE;
    _uChange = 0;
     GWKillMethodCallEx(_pts, this, ONCALL_METHOD(CProgSink, OnMethodCall, onmethodcall), 0);

    if (_pMarkup &&
        !fCleanupOnly &&
        _pMarkup->HtmCtx() &&
        _pMarkup->HtmCtx()->IsNoProgressUI())
    {
        dwFlagsProg &= ~PROGSINK_SET_TEXT;
    }

    LeaveCriticalSection();

    Assert(_pDoc->GetRefs());
// NOTE (lmollico): we need a local copy of _pDoc because CDoc::OnLoadStatus can cause
// this (CProgSink) to be destroyed if the doc is unloaded
    pDoc = _pDoc;
    // TODO (sramani): The doc could be passivated and if someone holds on to the markup
    // we could get here, so need to safeguard against it.
    if (pDoc && pDoc->_pWindowPrimary && pDoc->PrimaryMarkup())
    {
        pDoc->AddRef();

        if (dwFlagsProg)
            pDoc->SetProgress(dwFlagsProg, achText, dwPos, dwMax, fSendProgDone);

        if ( fSendSpin )
        {
            pDoc->SetSpin(fSpin);
        }
        
        // _pMarkup may be NULLed out here from passivation during SetProgress.  This is fine
        if (loadstatus > LOADSTATUS_UNINITIALIZED && _pMarkup && !_pMarkup->_fHardStopDone && !fCleanupOnly)
            _pMarkup->OnLoadStatus(loadstatus);

        pDoc->Release();
    }

    // Matched to addref above
    Release();

    TraceTag((tagProgSink, "[%08lX] OnMethodCall (leave)", this));
}



//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::AdjustProgress
//
//  Synopsis:   Adjust the current progress
//
//
//----------------------------------------------------------------------------

void CProgSink::AdjustProgress(DWORD dwClass, BOOL fFwd, BOOL fAdd)
{
    UINT    uiDelta = 0;
    UINT    cHtml   = _acClassBelow[PROGSINK_CLASS_HTML] +  _acClass[PROGSINK_CLASS_HTML];
    UINT    cFrame  = _acClassBelow[PROGSINK_CLASS_FRAME] +  _acClass[PROGSINK_CLASS_FRAME];

    switch(dwClass)
    {
    case    PROGSINK_CLASS_HTML:
        uiDelta = PROGSINK_POTEN_HTML;
        break;
    case    PROGSINK_CLASS_FRAME:
        uiDelta= PROGSINK_POTEN_FRAME;
        break;
    }

    if (!_cPotTotal)
    {
        _cPotTotal = PROGSINK_POTEN_MIN;
    }

    if (!cHtml && !cFrame)
    {
        if (!_cPotential)
        {
            return;
        }
        else if (!fAdd)
        {
            _cPotential     = 0;
            _dwProgMax      = PROGSINK_PROG_MAX;
            return;
        }
    }

    if (uiDelta)
    {
        uiDelta -= (!!fFwd) * PROGSINK_POTEN_BELOW;
        if (fAdd)
        {
            _cPotential += uiDelta;
            _cPotTotal  += uiDelta;
        }
        else
        {
            _cPotential += _cPotDelta;
            if (_cPotential <= uiDelta)
            {
                _cPotential = 1;            // set to 0 later
            }
            else
            {
                _cPotential -= uiDelta;
            }
            _cPotDelta = 0;
        }
    }

    Assert((cHtml + cFrame) || !_cPotential);
    TraceTag((tagProgSink,
        "[%08lX] AdjustProgress: a/f/h/p/pt/pd [%2d-(%2d, %2d) - %6d %6d %6d]",
                    this, _cActive, cFrame,
                    cHtml, _cPotential, _cPotTotal, _cPotDelta));
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::UpdateProgress
//
//  Synopsis:   Recalculate the current progress status
//
//  TODO:     need to add Databinding/OLE Controls
//----------------------------------------------------------------------------

BOOL
CProgSink::UpdateProgress(PROGDATA *ppd, DWORD dwFlags, DWORD dwPos, DWORD dwMax)
{
    DWORD       dwMaxOld    = ppd->dwMax;
    DWORD       dwPosOld    = ppd->dwPos;
    DWORD       dwProgDlt   = 0;            // progress delta
    BOOL        fSignal     = FALSE;

    TraceTag((tagProgSink,
            "[%08lX] UpdateProgress BEGIN [%08lX: <class=%2d,state=%2d,below=%2d,flags=%2d,pos=%2d,max=%2d> dwpos=%2d dwmax=%2d, setmax=%d, setpos=%d]",
            this, ppd, ppd->bClass, ppd->bState, ppd->bBelow, ppd->bFlags, ppd->dwPos, ppd->dwMax, dwPos, dwMax, dwFlags & PROGSINK_SET_MAX, dwFlags & PROGSINK_SET_POS));

    Assert (_dwProgMax <= PROGSINK_PROG_MAX);

    // TODO (mikhaill) - fixing bug 106536:
    // Code fragments that handle _dwMaxTotal and _cOngoing seem were
    // inconsistent with one another and contradicted comments
    // in header file. While making changes I used following definitions,
    // which I hope match author[s] ideas and require minimal amount
    // of correction.

    // CProgSink serves a number of clients caled "downloads".
    // Each download come into scope by calling AddProgress()
    // and run out of scope by DelProgress().
    // Downloads in scope are called "active downloads".
    // _cActive contains the number of active downloads.
    // Each active download is supplied with slot represented by
    // the struct PROGDATA that is allocated on AddProgress().
    // The PROGDATA values dwPos and dwMax reflect client progress state.
    // Initially dwPos and dwMax both contain zeros.
    // Their values can be changed only by SetProgress() call.
    // The download is considered "ongoing" if 0 < dwPos < dwMax
    // (i.e. download already started but not yet finished).
    // _cOngoing contains the number of ongoing downloads.
    // _dwMaxTotal contains the sum of (dwMax - dwPos) for all ongoing downloads.

    // Cleanup required!!

    if (ppd->dwPos && ppd->dwPos < ppd->dwMax)   // is ongoing?
    {
        // temporary remove this slot's affect from _dwMaxTotal & _cOngoing
        _dwMaxTotal -= ppd->dwMax - ppd->dwPos;
        _cOngoing--;
    }

    if (dwFlags & PROGSINK_SET_MAX)
    {
        ppd->dwMax = dwMax;
        if ( ppd->dwMax < dwMaxOld)
        {
            if (ppd->dwPos && ppd->dwPos < ppd->dwMax)   // is ongoing now?
            {
                // update this slot's affect to _dwMaxTotal & _cOngoing
                _dwMaxTotal += ppd->dwMax - ppd->dwPos;
                _cOngoing++;
            }
            goto Cleanup;
        }
    }

    if (dwFlags & PROGSINK_SET_POS)
    {
        ppd->dwPos = dwPos;
        if (dwPos < dwPosOld)
        {
            if (ppd->dwPos && ppd->dwPos < ppd->dwMax)   // is ongoing now?
            {
                // update this slot's affect to _dwMaxTotal & _cOngoing
                _dwMaxTotal += ppd->dwMax - ppd->dwPos;
                _cOngoing++;
            }
            goto Cleanup;
        }

        // adjust bogus data
        if (dwPos > ppd->dwMax)
        {
            ppd->dwMax = dwPos;
        }

        if (dwPos == 0 && _dwProgMax == 0)
        {
            _dwProgMax = PROGSINK_PROG_INIT;
            _dwProgCur = PROGSINK_PROG_MIN;
        }
        else if (_cPotential && (ppd->dwPos > dwPosOld) &&
                    (ppd->bClass == PROGSINK_CLASS_HTML ||
                    ppd->bClass == PROGSINK_POTEN_FRAME))
        {
            UINT    uiPotCur    = 0;              // Current potential pos
            UINT    uiDelta     = 0;

            switch (ppd->bClass)
            {
            case PROGSINK_CLASS_HTML:
                uiDelta = PROGSINK_POTEN_HTML;
                break;
            case PROGSINK_CLASS_FRAME:
                uiDelta = PROGSINK_POTEN_FRAME;
                break;
            }

            Assert(uiDelta);

            uiDelta = uiDelta  + (ppd->bBelow ? -PROGSINK_POTEN_BELOW : 0);
            Assert(ppd->dwMax);
            uiDelta = MulDivQuick(ppd->dwPos - dwPosOld,
                                    uiDelta, ppd->dwMax);

            if (_cPotential <= uiDelta)
            {
                // we consumed all the potential
                // but we will set _cPotential to 0 only later
                _cPotential     = PROGSINK_POTEN_END;
            }
            else
            {
                _cPotential -= uiDelta;

                _cPotDelta += uiDelta;

                Assert(_cPotTotal && _cPotTotal >= _cPotential);
                uiPotCur = MulDivQuick(_cPotTotal - _cPotential,
                                        PROGSINK_ADJUST_SCALE, _cPotTotal);

                if (uiPotCur < PROGSINK_POTEN_MIN)
                    uiPotCur = PROGSINK_POTEN_MIN;

                _dwProgMax = MulDivQuick(uiPotCur, PROGSINK_PROG_MAX,
                                            PROGSINK_ADJUST_SCALE);
                Assert(_dwProgMax <= PROGSINK_PROG_MAX);
            }
        }
    }

    if (ppd->dwPos && ppd->dwPos < ppd->dwMax)   // is ongoing now?
    {
        // update this slot's affect to _dwMaxTotal & _cOngoing
        _dwMaxTotal += ppd->dwMax - ppd->dwPos;
        _cOngoing++;
    }
    else
        goto Cleanup;

    Assert(_dwMaxTotal && _cOngoing);

    if (dwMaxOld && ppd->dwMax > dwMaxOld || ppd->dwPos <= dwPosOld) // we receive contradictory info
    {
        goto Cleanup;
    }

    if (_dwProgMax < _dwProgCur)
    {
        _dwProgCur = _dwProgMax;
        _dwProgDelta = 0;
        goto Cleanup;
    }

    // calculate the weight of this new progress against the current total
    // get relative delta
    // Assert(_cOngoing && _cActive >= _cOngoing);

    // We adjust the divider so that we allocate 100% more space for the
    // the last 50% of active downloads
    dwProgDlt = MulDivQuick(ppd->dwPos - dwPosOld,
                            _cOngoing * (_dwProgMax - _dwProgCur),
                            _dwMaxTotal * (_cActive + (_cActive >> 1)));

    // get absolute delta and add it to the last remaining delta
    _dwProgDelta += dwProgDlt;

    if (_dwProgDelta > (_dwProgMax - _dwProgCur))
    {
        _dwProgDelta = _dwProgMax - _dwProgCur;
    }

    if (_cPotential == PROGSINK_POTEN_END)
    {
         _dwProgMax      = PROGSINK_PROG_MAX;
    }

Cleanup:

    if (_dwProgDelta >= PROGSINK_PROG_STEP)
    {
        _dwProgCur += _dwProgDelta;
        _dwProgCur  = (_dwProgCur > _dwProgMax)? _dwProgMax : _dwProgCur;
        _dwProgDelta = 0;
        fSignal = TRUE;
    }

#if  DBG==1
    TraceTag((tagProgSink,
            "[%08lX] UpdateProgress [%2d/%2d/%2d - max = %-6d delta = %-3d - a/o %2d/%2d]",
            this, _dwProgCur, _dwProgMax, PROGSINK_PROG_MAX, _dwMaxTotal,
            _dwProgDelta, _cActive,_cOngoing));
#endif

    return fSignal;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgSink::GetClassCounter
//
//  Synopsis:   Returns quantity of class we are waiting for.
//
//----------------------------------------------------------------------------

UINT
CProgSink::GetClassCounter(DWORD dwClass, BOOL fBelow)
{
    UINT cQuantity;

    // IMPORTANT: We are not using a critical section here because we check
    // up often on this, and faulty readings will not make a difference
    // because they will be corrected in time.

    if (dwClass == (DWORD) -1)
        return _cActive;

    Assert(PROGSINK_CLASS_HTML == 0);
    Assert(dwClass <= PROGSINK_CLASS_FRAME);

    cQuantity = (fBelow ? (_acClassBelow[dwClass]) : (_acClass[dwClass]));

    return cQuantity;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\peerurlmap.cxx ===
//+----------------------------------------------------------------------------
//
//  File:       peer.cxx
//
//  Contents:   peer holder
//
//  Classes:    CPeerHolder
//
//-----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PEERFACT_HXX_
#define X_PEERFACT_HXX_
#include "peerfact.hxx"
#endif

#ifndef X_PEERURLMAP_HXX_
#define X_PEERURLMAP_HXX_
#include "peerurlmap.hxx"
#endif

///////////////////////////////////////////////////////////////////////////////
//
//  Misc
//
///////////////////////////////////////////////////////////////////////////////

MtDefine(CPeerFactoryUrlMap,                CDoc,               "CPeerFactoryUrlMap")
MtDefine(CPeerFactoryUrlMap_aryFactories,   CPeerFactoryUrlMap, "CDoc::_aryFactories")


///////////////////////////////////////////////////////////////////////////////
//
//  Class:      CPeerFactoryUrlMap
//
///////////////////////////////////////////////////////////////////////////////

//+----------------------------------------------------------------------------
//
//  Member:       CPeerFactoryUrlMap constructor
//
//-----------------------------------------------------------------------------

CPeerFactoryUrlMap::CPeerFactoryUrlMap(CMarkup * pHostMarkup) :
    _UrlMap(CStringTable::CASEINSENSITIVE)
{
    Assert(pHostMarkup);
    _pHostMarkup = pHostMarkup;
    _pHostMarkup->SubAddRef();
}

//+----------------------------------------------------------------------------
//
//  Member:       CPeerFactoryUrlMap destructor
//
//-----------------------------------------------------------------------------

CPeerFactoryUrlMap::~CPeerFactoryUrlMap()
{
    int                 c;
    CPeerFactoryUrl **  ppFactory;

    for (c = _aryFactories.Size(), ppFactory = _aryFactories;
         c;
         c--, ppFactory++)
    {
        (*ppFactory)->Release();
    }

    _aryFactories.DeleteAll();

    _pHostMarkup->SubRelease();
}

//+----------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrlMap::StopDownloads
//
//-----------------------------------------------------------------------------

HRESULT
CPeerFactoryUrlMap::StopDownloads()
{
    HRESULT             hr = S_OK;
    int                 c;
    CPeerFactoryUrl **  ppFactory;

    for (c = _aryFactories.Size(), ppFactory = _aryFactories;
         c;
         c--, ppFactory++)
    {
        (*ppFactory)->StopBinding();
    }

    RRETURN (hr);
}

//+----------------------------------------------------------------------------
//
//  Member:       CPeerFactoryUrlMap::HasPeerFactoryUrl
//
//  This function looks for a factory for the given URL.  If it is there, it
//  returns the factory, and TRUE.  Otherwise, it returns FALSE.
//
//-----------------------------------------------------------------------------
BOOL
CPeerFactoryUrlMap::HasPeerFactoryUrl(LPTSTR pchUrl, CPeerFactoryUrl ** ppFactory)
{
    HRESULT hr;

    Assert (ppFactory);

    hr = THR_NOTRACE(_UrlMap.Find(pchUrl, (void**)ppFactory));
    if (S_OK == hr)
        return TRUE;

    *ppFactory = NULL;
    return FALSE;

}

//+----------------------------------------------------------------------------
//
//  Member:       CPeerFactoryUrlMap::EnsurePeerFactoryUrl
//
// (for more details see also comments in the beginning of peerfact.cxx file)
// this function modifies _aryFactories in the following way:
//  - if there already is a factory for the url,
//          then no change happens;
//  - if the url is in form "http://...foo.bla" or "#foo" (but not "#foo#bla"),
//          then it creates a new factory for the url
//  - if the url is in form "#foo#bla",
//          then it creates 2 new factories: one for "#foo" and one for "#foo#bla"
//
//-----------------------------------------------------------------------------

HRESULT
CPeerFactoryUrlMap::EnsurePeerFactoryUrl(LPTSTR pchUrl, CMarkup * pMarkup, CPeerFactoryUrl ** ppFactory)
{
    HRESULT             hr = S_OK;
    CPeerFactoryUrl *   pFactory;
    LPTSTR              pchUrlSecondPound;
    LPTSTR              pchTemp = NULL;

    Assert (ppFactory);

    if (HasPeerFactoryUrl(pchUrl, &pFactory))
        goto Cleanup; // done

    // factory for the url not found

    pchUrlSecondPound = (_T('#') == pchUrl[0]) ? StrChr(pchUrl + 1, _T('#')) : NULL;

    if (!pchUrlSecondPound)
    {
        // url in form "http://...foo.bla"  or "#foo", but not in form "#foo#bar"

        hr = THR(CPeerFactoryUrl::Create(pchUrl, _pHostMarkup, pMarkup, &pFactory));
        if (hr)
            goto Cleanup;
    }
    else
    {
        // url in form "#foo#bar"

        // ensure factory for "#foo"
        {
            // We have to copy the memory here, because the string we were given
            // may be read-only and our string table requires null-terminated strings
            pchTemp = (TCHAR *)MemAlloc( Mt(CPeerFactoryUrl), (pchUrlSecondPound - pchUrl + 1) * sizeof( TCHAR ) );
            if( !pchTemp )
                goto Cleanup;

            _tcsncpy( pchTemp, pchUrl, pchUrlSecondPound - pchUrl );
            pchTemp[pchUrlSecondPound - pchUrl] = _T('\0');

            hr = THR(EnsurePeerFactoryUrl(pchTemp, pMarkup, &pFactory));
            if (hr)
                goto Cleanup;
        }

        // clone factory for "#foo#bar" from factory for "#foo"

        hr = THR(pFactory->Clone(pchUrl, &pFactory));
        if (hr)
            goto Cleanup;
    }

    hr = THR(_aryFactories.Append(pFactory));
    if (hr)
        goto Cleanup;

    hr = THR(_UrlMap.Add(pchUrl, pFactory));

Cleanup:

    if (S_OK == hr)
        *ppFactory = pFactory;
    else
        *ppFactory = NULL;

    MemFree( pchTemp );

    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\privacy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       PRIVACY.CXX
//
//  Contents:   Implementation of privacy list management
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_LOCKS_HXX_
#define X_LOCKS_HXX_
#include "locks.hxx"
#endif

#define ENUM_ENSURE_LIST_DOC        if (_pList->IsShutDown()) \
                                    {                         \
                                        hr = E_FAIL;          \
                                        goto Cleanup;         \
                                    }                         \

#define ENSURE_LIST_DOC             if (_fShutDown)           \
                                    {                         \
                                        hr = E_FAIL;          \
                                        goto Cleanup;         \
                                    }                         \

MtDefine(PrivacyList, Mem, "PrivacyList");
MtDefine(CEnumPrivacyRecords, PrivacyList, "CEnumPrivacyRecords")
MtDefine(CPrivacyList, PrivacyList, "CPrivacyList")
MtDefine(CStringAtomizer, PrivacyList, "CStringAtomizer")
MtDefine(CPrivacyRecord, PrivacyList, "CPrivacyRecord")
MtDefine(PrivacyUrl, PrivacyList, "Privacy Url - string")
MtDefine(CPrivacyRecord_pchUrl, PrivacyList, "CPrivacyRecord_pchUrl")
MtDefine(CPrivacyRecord_pchPolicyRefUrl, PrivacyList, "CPrivacyRecord_pchPolicyRefUrl")
MtDefine(StringAtom, PrivacyList, "StringAtom")
DeclareTag(tagPrivacyAddToList, "Privacy", "trace additions to CPrivacyList")
DeclareTag(tagPrivacySwitchList, "Privacy", "trace when pending and regular lists merge/switch")


CPrivacyList::~CPrivacyList()
{   
    ClearNodes();
    if (_pSA)
        delete _pSA;
}

HRESULT
CPrivacyList::QueryInterface(REFIID iid, LPVOID * ppv)
{
    HRESULT hr = THR(E_NOTIMPL);

    ENSURE_LIST_DOC

    if (!ppv)
    {
        hr = THR(E_POINTER);
        goto Cleanup;
    }    

    switch(iid.Data1)
    {
    QI_CASE(IUnknown)
        AddRef();
        *ppv = (LPVOID)this;
        hr = S_OK;
        goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

ULONG
CPrivacyList::AddRef()
{
    return ++_ulRefs;
}

ULONG 
CPrivacyList::Release()
{
    _ulRefs--;

    if (!_ulRefs)
    {
        delete this;
        return 0;
    }

    return _ulRefs;
}

HRESULT
CPrivacyList::Init()
{
    HRESULT hr = S_OK;

    _pSA = new(Mt(CStringAtomizer)) CStringAtomizer();
    if (!_pSA)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = _cs.Init();

Cleanup:
    RRETURN(hr);
}

HRESULT 
CPrivacyList::ClearNodes()
{
    // Don't check for shutdown state here since we call this from the destructor
    // In Doc passivate we set the shutdown state and release our reference but
    // there may be others who hold on to this via the enumerator

    HRESULT          hr       = S_OK;
    CPrivacyRecord * pTemp    = NULL;    

    // If InitializeCriticalSection for _cs fails, the doc will delete the privacy list obj
    // which will end up calling ClearNodes and will die on these CriticalSection calls
    // This is the only function where we need this check
    if (_cs.IsInited())
        EnterCriticalSection();

    CPrivacyRecord * pCurrent = _pHeadRec;
        
    _fPrivacyImpacted = 0;
    _pHeadRec = _pTailRec = _pPruneRec = _pSevPruneRec = NULL;    
       
    while (pCurrent != NULL)
    {
        IGNORE_HR(pCurrent->GetNext(&pTemp));        
        DeleteNode(pCurrent, pCurrent->IsGood());
        pCurrent = pTemp;
    }

    if (_pSA)
    {        
        _pSA->Clear();
    }

    Assert(_ulSize == 0);
    Assert(_ulGood == 0);

    if (_cs.IsInited())
        LeaveCriticalSection();

    RRETURN(hr);
}

CPrivacyRecord * 
CPrivacyList::CreateRecord(const TCHAR * pchUrl, const TCHAR * pchPolicyRef, DWORD dwFlags)
{
    CPrivacyRecord * pPR            = NULL;
    HRESULT          hr             = S_OK;
    TCHAR *          pchAtomizedUrl = NULL;
    TCHAR *          pchAtomizedRef = NULL;
    
    if (pchPolicyRef && *pchPolicyRef && _pSA)
    {
        pchAtomizedRef = _pSA->GetString(pchPolicyRef);
        if (!pchAtomizedRef)
        {
            hr = THR(E_OUTOFMEMORY);
            goto Cleanup;
        }
    }

    if (pchUrl && *pchUrl && _pSA)
    {
        pchAtomizedUrl = _pSA->GetString(pchUrl);
        if (!pchAtomizedUrl)
        {
            hr = THR(E_OUTOFMEMORY);
            goto Cleanup;
        }
    }

    pPR = new(Mt(CPrivacyRecord)) CPrivacyRecord(pchAtomizedUrl, pchAtomizedRef, dwFlags);
    
    if (!pPR)
    {
        hr = THR(E_OUTOFMEMORY);
        goto Cleanup;
    }
    
Cleanup:
    return pPR;
}

HRESULT 
CPrivacyList::AddNode(const TCHAR * pchUrl, const TCHAR * pchPolicyRef, DWORD dwFlags)
{
    HRESULT          hr         = S_OK;
    CPrivacyRecord * pRecord    = NULL;
    ENSURE_LIST_DOC
    
    if (!*pchUrl && !(dwFlags & PRIVACY_URLISTOPLEVEL))
        goto Cleanup;
        
    EnterCriticalSection();

    pRecord = CreateRecord(pchUrl, pchPolicyRef, dwFlags);
    if (!pRecord)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    if (pRecord->IsGood())
        _ulGood++;

    if (pRecord)
    {
        if (!_ulSize || !_pTailRec) // second clause is to fix a stress case
        {   
            AssertSz(!_ulSize, "Privacy list corruption!"); // hopefully this assert will allow us to
                                                            // catch that situation in the debugger
            _pHeadRec = _pTailRec = pRecord;
        }
        else
        {
            Assert(_pTailRec);
            _pTailRec->SetNext(pRecord);
            _pTailRec = pRecord;
        }
        _ulSize++;
    }        

    // Has global privacy been impacted?
    if ( (dwFlags & COOKIEACTION_REJECT) ||
         (dwFlags & COOKIEACTION_SUPPRESS) ||
         (dwFlags & COOKIEACTION_DOWNGRADE)) 
    {
        _fPrivacyImpacted = TRUE;
    }
        
Error:
    LeaveCriticalSection();

Cleanup:
    if (_ulSize >= MAX_ENTRIES)
    {
        AddRef();
        GWPostMethodCallEx(_pts, (void*)this,ONCALL_METHOD(CPrivacyList, PruneList, prunelist), 0, TRUE, "CPrivacyList::PruneList");
    }

    RRETURN(hr);
}

HRESULT
CPrivacyList::GetEnumerator(IEnumPrivacyRecords ** ppEnum)
{
    HRESULT               hr   = S_OK;
    CEnumPrivacyRecords * pEPR = NULL;
    
    ENSURE_LIST_DOC

    if (!ppEnum)
    {
        hr = THR(E_POINTER);
        goto Cleanup;
    }

    pEPR = new(Mt(CEnumPrivacyRecords)) CEnumPrivacyRecords(this);

    if (!pEPR)
    {
        hr = THR(E_OUTOFMEMORY);
        goto Cleanup;
    }

    *ppEnum = (IEnumPrivacyRecords*)pEPR;

Cleanup:
    RRETURN(hr);
}

void CPrivacyList::DeleteNode(CPrivacyRecord * pNode, BOOL fIsGood)
{
    if (fIsGood)
        _ulGood--;

    _ulSize--;

    if (pNode->GetUrl())
        _pSA->ReleaseString(pNode->GetUrl());

    if (pNode->GetPolicyRefUrl())
        _pSA->ReleaseString(pNode->GetPolicyRefUrl());

    delete pNode;      
}

void
CPrivacyList::PruneList(DWORD_PTR dwFlags)
{
    int i = 0;

    int refs = Release();
           
    if (refs == 0 || _fShutDown || _ulSize == 0)
        return;

    EnterCriticalSection();

    CPrivacyRecord * pNextRec = _pPruneRec ? _pPruneRec->GetNextNode() : _pHeadRec;

    Assert(pNextRec);  // shouldn't be calling this function if there are no nodes
  
    if (_ulSize < MAX_ENTRIES) // if we've been posted too many times
        goto Cleanup;

    if (_ulGood == 0)
    {
        SeverePruneList(0);
        goto Cleanup;
    }

    // handle the case when we're looking at the head of the list
    while (_pPruneRec == NULL && pNextRec != NULL && i < PRUNE_SIZE && _ulGood > 0) 
    {
        if (pNextRec->IsGood())
        {
            _pHeadRec = pNextRec->GetNextNode();
            DeleteNode(pNextRec, TRUE);
            pNextRec = _pHeadRec;
        }
        else
        {
            _pPruneRec = pNextRec;
            pNextRec = pNextRec->GetNextNode();
        }
        i++;
    }

    for (; i < PRUNE_SIZE && _ulGood > 0 && pNextRec != NULL; i++)
    {

        if (pNextRec->IsGood())
        {
            _pPruneRec->SetNext(pNextRec->GetNextNode());
            DeleteNode(pNextRec, TRUE);            
        }      
        else if (_pPruneRec->GetNextNode())   // _pPruneRec should never fall off the end of the list
        {
            _pPruneRec = _pPruneRec->GetNextNode();
        }

        pNextRec = _pPruneRec->GetNextNode();
    }

    if (_ulSize >= MAX_ENTRIES)
        SeverePruneList(0);

Cleanup:

    LeaveCriticalSection();    

    return;
}

void
CPrivacyList::SeverePruneList(DWORD_PTR dwFlags)
{

    if (_fShutDown || _ulSize == 0)
            return;

    CPrivacyRecord * pNextRec = _pSevPruneRec ? _pSevPruneRec->GetNextNode() : _pHeadRec; 
    CPrivacyRecord * pTempRec = pNextRec;

    for (int i = 0; i < PRUNE_SIZE && pNextRec != NULL; i++)
    {
        Assert(!pNextRec->IsGood());
        pTempRec = pNextRec->GetNextNode();
        DeleteNode(pNextRec, FALSE);
        pNextRec = pTempRec;        
    }

    // _pSevPruneRec shouldn't fall off end of the list
    if (_pSevPruneRec)
    {
        _pSevPruneRec->SetNext(pNextRec);
    }
    else
    {
        _pHeadRec = pNextRec;
    }

    _pPruneRec = _pSevPruneRec;

    Assert(_ulSize < MAX_ENTRIES); // all these prunes should be successful
    
    return;
}

inline void 
CPrivacyList::EnterCriticalSection() 
{
    _cs.Enter();
}

inline void 
CPrivacyList::LeaveCriticalSection() 
{
    _cs.Leave();
}

HRESULT
CPrivacyRecord::GetNext(CPrivacyRecord ** ppNextRec)
{
    HRESULT hr = S_OK;
    if (!ppNextRec)
    {
        hr = THR(E_POINTER);
        goto Cleanup;
    }

    *ppNextRec = _pNextNode;

Cleanup:
    RRETURN(hr);
}

HRESULT
CPrivacyRecord::SetNext(CPrivacyRecord * pNextRec)
{
    _pNextNode = pNextRec;
    return S_OK;
}

inline BOOL
CPrivacyRecord::IsGood()
{
    return (!(   _dwFlags & COOKIEACTION_REJECT 
              || _dwFlags & COOKIEACTION_SUPPRESS 
              || _dwFlags & COOKIEACTION_DOWNGRADE));
}

CEnumPrivacyRecords::CEnumPrivacyRecords(CPrivacyList * pList)
    : _ulRefs(1)
{
    Assert(pList);
    _pList = pList;
    _pList->AddRef();
    _pNextRec = _pList->GetHeadRec();
    _fAtEnd = FALSE;
}

CEnumPrivacyRecords::~CEnumPrivacyRecords()
{
    _pList->Release();
}

HRESULT
CEnumPrivacyRecords::QueryInterface(REFIID iid, LPVOID * ppv)
{
    HRESULT hr = E_NOTIMPL;
        
    ENUM_ENSURE_LIST_DOC

    if (!ppv)
    {
        hr = THR(E_POINTER);
        goto Cleanup;
    }

    switch (iid.Data1)
    {
    QI_CASE(IUnknown)
    QI_CASE(IEnumPrivacyRecords)    
        AddRef();
        *ppv = (void *)this;
        hr = S_OK;
        goto Cleanup;    
    }

Cleanup:
    RRETURN(hr);
}

ULONG
CEnumPrivacyRecords::AddRef()
{
    return ++_ulRefs;
}

ULONG
CEnumPrivacyRecords::Release()
{
    _ulRefs--;

    if (!_ulRefs)
    {
        delete this;
        return 0;
    }

    return _ulRefs;
}

HRESULT
CEnumPrivacyRecords::Reset()
{
    HRESULT hr = S_OK;
    
    ENUM_ENSURE_LIST_DOC

    _pNextRec = _pList->GetHeadRec();

Cleanup:
    RRETURN(hr);
}


HRESULT
CEnumPrivacyRecords::GetSize(ULONG * pSize)
{
    HRESULT hr = S_OK;
    
    ENUM_ENSURE_LIST_DOC

    if (!pSize)
    {
        hr = THR(E_POINTER);
        goto Cleanup;
    }

    *pSize = _pList->GetSize();

Cleanup:
    RRETURN(hr);
}

HRESULT
CEnumPrivacyRecords::GetPrivacyImpacted(BOOL * pImpacted)
{
    HRESULT hr = S_OK;
    
    ENUM_ENSURE_LIST_DOC

    if (!pImpacted)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pImpacted = _pList->GetPrivacyImpacted();

Cleanup:
    RRETURN(hr);
}

HRESULT 
CEnumPrivacyRecords::Next(BSTR  * pbstrUrl, 
                          BSTR  * pbstrPolicyRef, 
                          LONG  * pdwReserved, 
                          DWORD * pdwFlags)
{
    HRESULT hr = S_OK;
    
    ENUM_ENSURE_LIST_DOC

    if (!pbstrUrl|| !pbstrPolicyRef || !pdwFlags)
    {
        hr = THR(E_POINTER);
        goto Cleanup;
    }

    if (_fAtEnd)
    {
        if (_pNextRec->GetNextNode())  // at the end, is there more now?
        {
            _pNextRec = _pNextRec->GetNextNode();
            _fAtEnd = FALSE;
        }
        else
        {
            hr = S_FALSE;
            goto Cleanup;
        }

    }
    else if (!_pNextRec)   // no nodes when we were created
    {
        if (_pList->GetHeadRec())
        {
            _pNextRec = _pList->GetHeadRec();
        }
        else
        {
            hr = S_FALSE;
            goto Cleanup;
        }
    }

    if (_pNextRec->HasUrl())
    {
        hr = FormsAllocString(_pNextRec->GetUrl(), pbstrUrl);
        if (hr)
            goto Cleanup;
    }
    else
    {
        *pbstrUrl = NULL;
    }    

    if (_pNextRec->HasPolicyRefUrl())
    {
        hr = FormsAllocString(_pNextRec->GetPolicyRefUrl(), pbstrPolicyRef);
        if (hr)
            goto Cleanup;
    }
    else
    {
        *pbstrPolicyRef = NULL;
    }    

    *pdwFlags     = _pNextRec->GetPrivacyFlags();
    
    if (_pNextRec->GetNextNode())
        _pNextRec     = _pNextRec->GetNextNode();
    else
        _fAtEnd = TRUE;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

TCHAR *
PrivacyUrlFromUrl(const TCHAR * pchUrl)
{
    BOOL    fDone      = FALSE;
    TCHAR * pchPrivUrl = NULL;
    int     cSize      = 0;

    if (!pchUrl || !_tcslen(pchUrl))
        return NULL;

    for (const TCHAR * pchCur = pchUrl; !fDone; pchCur++)
    {                
        cSize++;
        switch(*pchCur)
        {
        case _T(':'):
            // if it's not http or https, don't add it
            if (   (cSize != 5 && cSize != 6)
                || (cSize == 5 && _tcsnicmp(pchUrl, 5, _T("http:"), 5))
                || (cSize == 6 && _tcsnicmp(pchUrl, 6, _T("https:"), 6)))
            {
                return NULL;
            }
            if (*(pchCur+1) == _T('/') && *(pchCur+2) == _T('/'))
            {
                pchCur += 2;
                cSize += 2;
            }
            break;
        case _T('/'):
        case _T('\0'):
            cSize--;
            fDone = TRUE;
            break;
        default:            
            break;
        }
    }

    // now we have a size for the shortened URL
    
    pchPrivUrl = new(Mt(PrivacyUrl)) TCHAR[cSize + 1];
    if (!pchPrivUrl)
        return NULL;

    _tcsncpy(pchPrivUrl, pchUrl, cSize);
    pchPrivUrl[cSize] = _T('\0');

    return pchPrivUrl;
}

void
CStringAtomizer::Clear()
{    
    WHEN_DBG (void * pResult;)
    DWORD            dwHash;

    _ht.WriterClaim();

    UINT             uiIndex  = 0;
    CStringAtom *    pAtom   = (CStringAtom*)_ht.GetFirstEntryUnsafe(&uiIndex);

    while (pAtom != NULL)
    {
        Assert(pAtom->_cRefs == 0);

        dwHash = HashString(pAtom->_pchString, _tcslen(pAtom->_pchString), 0);
        dwHash <<= 2;
        if (dwHash == 0) dwHash = 1<<2;
    
        WHEN_DBG(pResult =) _ht.RemoveUnsafe((void*)((DWORD_PTR)dwHash), (void*)pAtom->_pchString);
        Assert(pResult);
        MemFree(pAtom);
        pAtom = (CStringAtom*)_ht.GetNextEntryUnsafe(&uiIndex);
    }

    _ht.WriterRelease();

    _ht.ReInit();
}

TCHAR * 
CStringAtomizer::GetString (const TCHAR * pchUrl)
{

    HRESULT        hr      = S_OK;
    int            iLen    = _tcslen(pchUrl);
    DWORD          dwHash  = HashString(pchUrl, iLen, 0);
    CStringAtom *  pAtom   = NULL;

    dwHash <<= 2;
    if (dwHash == 0) dwHash = 1<<2;

    hr = _ht.LookupSlow((void*)((DWORD_PTR)dwHash), (void*)pchUrl, (void**)&pAtom);

    if (!hr)
    {
        Assert(!_tcscmp(pAtom->_pchString, pchUrl));
        pAtom->_cRefs++;
        return pAtom->_pchString;
    }

    pAtom = (CStringAtom*)MemAlloc(Mt(StringAtom),(sizeof(CStringAtom) + (iLen+1)*sizeof(TCHAR)));
    if (!pAtom)
        return NULL;
    
    pAtom->_cRefs = 1;
    _tcscpy(pAtom->_pchString, pchUrl);

    THR(_ht.Insert((void*)((DWORD_PTR)dwHash), (void*)pAtom DBG_COMMA WHEN_DBG(pAtom->_pchString)));

    return pAtom->_pchString;
}

void    
CStringAtomizer::ReleaseString (const TCHAR * pchUrl)
{
    CStringAtom *  pAtom = NULL;
    
    pAtom = (CStringAtom *)((DWORD_PTR)pchUrl - (DWORD_PTR)sizeof(int));

    pAtom->_cRefs--;

    if (pAtom->_cRefs == 0)
    {        
        int            iLen    = _tcslen(pchUrl);
        DWORD          dwHash  = HashString(pchUrl, iLen, 0);

        dwHash <<= 2;
        if (dwHash == 0) dwHash = 1<<2;

        if (_ht.Remove((void*)((DWORD_PTR)dwHash), (void*)pAtom->_pchString))
            MemFree(pAtom);   
        else
            AssertSz(0, "Releasing a string not in the table");
    }
}

BOOL
CStringAtomizer::HashCompare(const void *pObject, const void * pvDataPassedIn, const void * pvVal2)
{
    TCHAR       * str1 = (TCHAR*)pvDataPassedIn;
    CStringAtom * str2 = (CStringAtom*)pvVal2;

    return !_tcscmp(str1, str2->_pchString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\recalchost.cxx ===
// ---------------------------------------------------------
//
// Microsoft Trident
// Copyright Microsoft corporation 1998
//
// File: recalchost.cxx
//
// Recalc engine hosting code
//
// ---------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include "mshtmdid.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_SITECNST_HXX_
#define X_SITECNST_HXX_
#include "sitecnst.hxx"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_ATOM_HXX
#define X_ATOM_HXX
#include "atomtbl.hxx"
#endif

#ifndef X_SHOLDER_HXX_
#define X_SHOLDER_HXX_
#include "sholder.hxx"
#endif

#ifndef X_RECALC_HXX_
#define X_RECALC_HXX_
#include "recalc.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif

ExternTag(tagRecalcInfo);
ExternTag(tagRecalcDetail);
ExternTag(tagRecalcStyle);

DeclareTag(tagRecalcSync, "Recalc Sync", "Do recalc synchronously")
DeclareTag(tagRecalcHost, "Recalc Host", "Trace recalc host support")
DeclareTag(tagRecalcInfo, "Recalc", "Trace recalc behaviour")
DeclareTag(tagRecalcGetInfo, "Recalc", "Enable GetObjectInfo to get object id and prop name")
DeclareTag(tagRecalcDetail, "Recalc detail", "Detailed recalc trace")
DeclareTag(tagRecalcDisable, "Recalc", "Disable all recalc")
DeclareTag(tagRecalcDisableCSS, "Recalc", "Disable CSS expressions");
DeclareTag(tagRecalcDumpBefore, "Recalc", "Dump before every recalc");
DeclareTag(tagRecalcDumpAfter, "Recalc", "Dump after every recalc")
//------------------------------------
//
// CDoc::CRecalcHost::QueryInterface
//
// Description: IUnknown::QueryInterface
//
//------------------------------------

STDMETHODIMP
CDoc::CRecalcHost::QueryInterface(REFIID iid, LPVOID *ppv)
{
    if (ppv == 0)
        RRETURN(E_INVALIDARG);
    *ppv = 0;
    
    switch (iid.Data1)
    {
        QI_INHERITS((IRecalcHost *)this, IUnknown)
        QI_INHERITS(this, IRecalcHost)
        QI_INHERITS(this, IServiceProvider)
#if DBG == 1
        QI_INHERITS(this, IRecalcHostDebug)
#endif
    }

    if (*ppv == NULL)
        RRETURN(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}

//------------------------------------
//
// CDoc::CRecalcHost::AddRef
//
// Description: IUnknown::AddRef
//
//------------------------------------

STDMETHODIMP_(ULONG)
CDoc::CRecalcHost::AddRef()
{
    return MyDoc()->SubAddRef();
}

//------------------------------------
//
// CDoc::CRecalcHost::Release
//
// Description: IUnknown::Release
//
//------------------------------------

STDMETHODIMP_(ULONG)
CDoc::CRecalcHost::Release()
{
    return MyDoc()->SubRelease();
}

//------------------------------------
//
// CDoc::CRecalcHost::QueryService
//
// Description: IServiceProvider::QueryService
//
//------------------------------------

STDMETHODIMP
CDoc::CRecalcHost::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppv)
{
    RRETURN(MyDoc()->QueryService(guidService, riid, ppv));
}

//------------------------------------
//
// CDoc::CRecalcHost::Init
//
// Description: Actually creates the recalc engine
//
//------------------------------------

HRESULT
CDoc::CRecalcHost::Init()
{
    if (_pEngine)
        return S_OK;

    HRESULT hr;
    IRecalcEngine *pEngine = 0;
    IObjectWithSite *pObject = 0;

    hr = THR(CoCreateInstance(CLSID_CRecalcEngine, NULL, CLSCTX_INPROC_SERVER, IID_IRecalcEngine, (LPVOID *)&pEngine));
    if (hr)
        goto Cleanup;

    hr = THR(pEngine->QueryInterface(IID_IObjectWithSite, (LPVOID *)&pObject));
    if (hr)
        goto Cleanup;

    hr = THR(pObject->SetSite((IRecalcHost *)this));
    if (hr)
        goto Cleanup;

    _pEngine = pEngine;
    _pEngine->AddRef();

Cleanup:
    TraceTag((tagRecalcHost, "Creating recalc engine %08x", pEngine));
    ReleaseInterface(pObject);
    ReleaseInterface(pEngine);

    RRETURN(hr);
}

//------------------------------------
//
// CDoc::CRecalcHost::Detach
//
// Description: Cleanup, release the recalc engine
//
//------------------------------------

void
CDoc::CRecalcHost::Detach()
{
    if (_pEngine)
    {
        IObjectWithSite *pObject;

        if (SUCCEEDED(THR(_pEngine->QueryInterface(IID_IObjectWithSite, (LPVOID *)&pObject))))
        {
            pObject->SetSite(NULL);
            pObject->Release();
        }
        ClearInterface(&_pEngine);
    }
}

HRESULT
CDoc::CRecalcHost::SuspendRecalc(VARIANT_BOOL fSuspend)
{
    if (fSuspend)
    {
        _ulSuspend++;
        Assert(_ulSuspend != 0);
    }
    else if (_ulSuspend > 0)
    {
        _ulSuspend--;
        if (_ulSuspend == 0 && _fRecalcRequested)
        {
            MyDoc()->GetView()->RequestRecalc();
        }
    }
    else
        RRETURN(E_UNEXPECTED);

    return S_OK;
}

//------------------------------------
//
// CDoc::CRecalcHost::setExpression
//
// Description: A helper function for CElement and CStyle
//
//------------------------------------
HRESULT
CDoc::CRecalcHost::setExpression(CBase *pBase, BSTR strPropertyName, BSTR strExpression, BSTR strLanguage)
{
    WHEN_DBG(if (IsTagEnabled(tagRecalcDisable)) return S_OK; )

    HRESULT hr;
    DISPID dispid = 0;

    TraceTag((tagRecalcInfo, "setExpression(%08x, \"%ls\", \"%ls\", \"%ls\")", pBase, strPropertyName, strExpression, strLanguage));

    // Don't do this while we're in recalc!
    if (_fInRecalc)
        RRETURN(E_UNEXPECTED);

    if (!strPropertyName || !strExpression)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // If there are any pending tasks, do them now so that all
    // expressions are either applied or cleared before we actually
    // try to do any work.
    MyDoc()->ExecuteExpressionTasks();

    hr = THR(pBase->GetDispID(strPropertyName, fdexNameCaseSensitive | fdexNameEnsure, &dispid));
    if (hr)
        goto Cleanup;

    hr = THR(Init());
    if (hr)
        goto Cleanup;

    if (!strLanguage || (*strLanguage == 0))        // For consistency, the default is always javascript
    {
        strLanguage = _T("javascript");
    }

    hr = THR(_pEngine->SetExpression((IUnknown *)(IPrivateUnknown *)pBase, dispid, strExpression, strLanguage));
Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------
//
// Member:      CDoc::CRecalcHost::removeAllExpressions
//
// Description: Called when an element goes out of view
//
//---------------------------------------------------------

HRESULT
CDoc::CRecalcHost::removeAllExpressions(CElement *pElement)
{
    HRESULT              hr = S_OK;
    CRecalcObject * pObject = NULL;
    CRecalcEngine * pEngine = NULL;
    CStyle        * pStyle  = NULL;

    if ( ! _pEngine || _fInRecalc) // if engine is already gone or in recalc - just bail.
        goto Cleanup;

    // Get the CRecalcEngine from IRecalcEngine

    pEngine = DYNCAST( CRecalcEngine, _pEngine ); Assert(pEngine);

    // Get the CRecalcObject corresponding to this element (CElement or CStyle)

    hr = THR(pEngine->FindObject((IUnknown *)(IPrivateUnknown *)pElement, FALSE, &pObject));

    if (!hr)
    {
        Assert(pObject);

        // Remove the object from the recalc engine - By passing the "TRUE" 
        // argument we clean up the dependency graph for all its properties

        pEngine->RemoveObject(pObject, TRUE);
    }

    // Do the same thing for any expressions on CStyle

    hr = THR(pElement->GetStyleObject(&pStyle));
    
    if (!hr)
    {
        Assert(pStyle);
        hr = THR(pEngine->FindObject((IUnknown *)(IPrivateUnknown *)pStyle, FALSE, &pObject));

        if (!hr)
        {
            Assert(pObject);

            // Remove the object from the recalc engine 
            pEngine->RemoveObject(pObject, TRUE);
        }
    }

Cleanup:    
    hr = S_OK;
    RRETURN( hr );
}


//---------------------------------------------------------
//
// Member:      CDoc::CRecalcHost::setStyleExpression
//
// Description: Called by the stylesheet 
//
//---------------------------------------------------------
HRESULT
CDoc::CRecalcHost::setStyleExpressions(CElement *pElement)
{
    WHEN_DBG(if (IsTagEnabled(tagRecalcDisableCSS)) return S_OK; )

    HRESULT hr = S_OK;
    CStyle *pStyle;


    int iExpandos = pElement->GetFirstBranch()->GetFancyFormat()->_iExpandos;

    // It is possible for the element cache to have been cleared before
    // we get a chance to run.  In this case iExpandos will be negative.
    // Some later pass through ComputeFormats will once again determine
    // the appropriate set of expressions for this element.
    // REVIEW (michaelw) Is it possible that we will never be called
    // again because try to be so lazy?  If so will expressions that are
    // currently applied to the object not be removed when they should?

    if (iExpandos < 0)
        goto Cleanup;

    // No expressions in print media.
    // REVIEW: May not need to bother blocking here
    if ( pElement->IsPrintMedia() )
        goto Cleanup;

    // If we are in the middle of setting a value then we don't want to do anything
    if (_pElemSetValue)
        goto Cleanup;

    hr = Init();
    if (hr)
        goto Cleanup;

    hr = THR(pElement->GetStyleObject(&pStyle));
    if (hr)
        goto Cleanup;

    if (SUCCEEDED(_pEngine->BeginStyle((IUnknown *)pStyle)))
    {
        CAttrArray *pAA = GetExpandosAttrArrayFromCacheEx(iExpandos);
        CAttrValue *pAV = (CAttrValue *)*pAA;

        Assert(pAA);

        for ( int i = 0 ; i < pAA->Size() ; i++, pAV++ )
        {
            if (pAV->AAType() == CAttrValue::AA_Expression)
            {
                TraceTag((tagRecalcStyle, "\tsetting expression: this: %08x dispid: %08x expression:%ls", this, pAV->GetDISPID(), pAV->GetLPWSTR()));
                IGNORE_HR(_pEngine->SetExpression((IUnknown *)(IPrivateUnknown *)pStyle, pAV->GetDISPID(), pAV->GetLPWSTR(), _T("javascript")));
            }
        }
        IGNORE_HR(_pEngine->EndStyle((IUnknown *)(IPrivateUnknown *)pStyle));
    }

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------
//
//  Member:     CDoc::CRecalcHost::getExpression
//
// REVIEW michaelw : need to add a language parameter to allow
//                   the caller to get the expression language
//
//---------------------------------------------------------------
HRESULT
CDoc::CRecalcHost::getExpression(CBase *pBase, BSTR strPropertyName, VARIANT *pvExpression)
{
    HRESULT hr;
    BSTR strLanguage = 0;
    BSTR strExpression = 0;
    DISPID dispid = 0;

    TraceTag((tagRecalcInfo, "getExpression(%08x, \"%ls\")", pBase, strPropertyName));

    if (!strPropertyName || (*strPropertyName == 0) || (pvExpression == 0))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // If there are any pending tasks, do them now so that all
    // expressions are either applied or cleared before we actually
    // try to do any work.
    MyDoc()->ExecuteExpressionTasks();

    hr = THR(pBase->GetDispID(strPropertyName, fdexNameCaseSensitive, &dispid));
    if (hr == DISP_E_UNKNOWNNAME)
    {
        hr = S_FALSE;
        goto Cleanup;
    }
    else if (hr)
        goto Cleanup;

    if (!_pEngine)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR(_pEngine->GetExpression((IUnknown *)(IPrivateUnknown *)pBase, dispid, &strExpression, &strLanguage));
    if (!hr)
    {
        V_VT(pvExpression) = VT_BSTR;
        V_BSTR(pvExpression) = strExpression;
    }

Cleanup:
    if (hr == S_FALSE)
    {
        V_VT(pvExpression) = VT_EMPTY;
        hr = S_OK;
    }

    SysFreeString(strLanguage);
    RRETURN(hr);
}

//---------------------------------------------------------------
//
//  Member:     CDoc::CRecalcHost::removeExpression
//
//---------------------------------------------------------------
HRESULT
CDoc::CRecalcHost::removeExpression(CBase *pBase, BSTR strPropertyName, VARIANT_BOOL *pfSuccess)
{
    HRESULT hr = S_OK;
    DISPID dispid = 0;

    if (pfSuccess)
        *pfSuccess = VB_FALSE;

    TraceTag((tagRecalcInfo, "removeExpression(%08x, \"%ls\")", pBase, strPropertyName));

    // Don't do this while we're in recalc
    if (_fInRecalc)
        RRETURN(E_UNEXPECTED);

    if (!strPropertyName || (*strPropertyName == 0))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // If there are any pending tasks, do them now so that all
    // expressions are either applied or cleared before we actually
    // try to do any work.
    MyDoc()->ExecuteExpressionTasks();

    // Get the dispid for strPropertyName.  
    hr = THR(pBase->GetDispID(strPropertyName, fdexNameCaseSensitive, &dispid));
    if (hr == DISP_E_UNKNOWNNAME)
    {
        hr = S_OK;
        goto Cleanup;
    }
    else if (hr)
        goto Cleanup;

    if (!_pEngine)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = THR(_pEngine->ClearExpression((IUnknown *)(IPrivateUnknown *)pBase, dispid));
    if (hr)
        goto Cleanup;

    if (pfSuccess)
        *pfSuccess = VB_TRUE;

Cleanup:
    if (hr == S_FALSE)
        hr = S_OK;

    RRETURN(hr);
}

//------------------------------------
//
// CDoc::CRecalcHost::EngineRecalcAll
//
// Description: A little wrapper to RecalcAll on the engine.
//              Does not create the engine if it doesn't exist
//
//------------------------------------

HRESULT
CDoc::CRecalcHost::EngineRecalcAll(BOOL fForce)
{
    HRESULT hr = S_OK;

#if DBG==1
    if (IsTagEnabled(tagRecalcDumpBefore))
        Dump(0);
#endif

    // If someone explicitly calls document.recalc while we are actually
    // doing the recalc, we fail.
    if (_fInRecalc)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // TODO (sramani): Need context markup here?
    if (MyDoc()->_fEngineSuspended)
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (_ulSuspend == 0)
    {
        // Do any pending work for style expressions to be applied.
        MyDoc()->ExecuteExpressionTasks();

        if (_pEngine)
        {
            BOOL fRunScript;
            hr = THR(MyDoc()->PrimaryMarkup()->ProcessURLAction(URLACTION_SCRIPT_RUN, &fRunScript));
            if (hr || !fRunScript)
                goto Cleanup;

            // We clear the flag before calling RecalcAll
            // so that we don't ignore requests generated
            // while we're in recalc.
            _fRecalcRequested = FALSE;
 
            _fInRecalc = TRUE;
            if (SUCCEEDED(hr))
                hr = THR(_pEngine->RecalcAll(fForce));
            _fInRecalc = FALSE;
        }
    }
    else
        hr = S_OK;

Cleanup:
#if DBG==1
    if (IsTagEnabled(tagRecalcDumpBefore))
        Dump(0);
#endif

    RRETURN(hr);
}

//---------------------------------------------------------------
//
// Function:    CRecalcHost::RequestRecalc
//
// Description: The recalc engine has requested a recalc.  We choose
//              to do this async.
//
//---------------------------------------------------------------
STDMETHODIMP
CDoc::CRecalcHost::RequestRecalc()
{
    Assert(_pEngine);
#if DBG == 1
    if (IsTagEnabled(tagRecalcSync))
    {
        EngineRecalcAll(FALSE);
        return S_OK;
    }
#endif

    if (!_fRecalcRequested)
    {
        //
        // If we are suspended then the request to the view will be issued when we unsuspend
        //
        if (!_ulSuspend)
            MyDoc()->GetView()->RequestRecalc();
        _fRecalcRequested = TRUE;
    }

    return _fRecalcRequested ? S_OK : E_FAIL;
}
//------------------------------------
//
// CDoc::CRecalcHost::CompileExpression
//
// Description: IRecaclHost::ParseExpressionText
//
//------------------------------------

STDMETHODIMP
CDoc::CRecalcHost::CompileExpression(IUnknown *pUnk, DISPID dispid, BSTR strExpression, BSTR strLanguage, IDispatch **ppExpressionObject, IDispatch **ppThis)
{
    TraceTag((tagRecalcHost, "CompileExpression %ls %ls", strExpression, strLanguage));
    HRESULT     hr;
    CStr        sExpression;
    CElement    * pElement = NULL;

    // TODO this should be done by the script engine (beta 2)
    if (strLanguage[0] == _T('J') || strLanguage[0] == _T('j'))
    {
        sExpression.Append(_T("return ("));
        sExpression.Append(strExpression);
        sExpression.Append(_T(")"));
    }
    else
        RRETURN(E_INVALIDARG);

    TraceTag((tagRecalcHost, "CompileExpression generated: %ls", sExpression));

    //
	// pUnk can only be CElement or CStyle
	// Even if an expression is applied to the style of an element,
	// we need to make sure that the "this" pointer of the expression 
	// code is the element and not element.style.
	//

    pElement = GetElementFromUnk(pUnk);
    hr = pElement->PrivateQueryInterface(IID_IDispatch, (LPVOID *)ppThis);

    if (!hr)
    {
        CScriptCollection *pScriptCollection = pElement->GetNearestMarkupForScriptCollection()->GetScriptCollection();

        if (pScriptCollection)
        {
            BOOL fSafe = FALSE;
            hr = THR(pElement->GetNearestMarkupForScriptCollection()->ProcessURLAction(URLACTION_SCRIPT_RUN ,&fSafe));
            if(!hr && fSafe) 
            {
                hr = THR(pScriptCollection->ConstructCode(
                    NULL,                           // pchScope
                    sExpression,                    // pchCode
                    NULL,                           // pchFormalParams
                    strLanguage,                    // pchLanguage
                    NULL,                           // pMarkup
                    NULL,                           // pchType
                    0,                              // ulOffset
                    0,                              // ulStartingLine
                    NULL,                           // pSourceObject
                    SCRIPTPROC_HOSTMANAGESSOURCE,   // dwFlags
                    ppExpressionObject,             // ppDispCode result
                    TRUE));                         // fSingleLine
            }
            else
            {
                hr = E_ACCESSDENIED;
            }
        }
        else
            hr = E_UNEXPECTED;
    }

    RRETURN(hr);
}

CElement *CDoc::CRecalcHost::GetElementFromUnk(IUnknown *pUnk)
{
    HRESULT hr;
    CStyle *pStyle;
    CElement *pElement = NULL;

    // pUnk can only be CElement or CStyle
    hr = THR(pUnk->QueryInterface(CLSID_CStyle, (LPVOID *)&pStyle));
    if (hr)
    {
        IGNORE_HR(pUnk->QueryInterface(CLSID_CElement, (LPVOID *)&pElement)); 
    }
    else
    {
        pElement = pStyle->GetElementPtr();
    }

    Assert(pElement);      

    return pElement;
}

//------------------------------------
//
// CDoc::CRecalcHost::EvalExpression
//
// Description: IRecalcHost::EvalExpression
//
// Apparently has no support for DISPID_THIS
//
STDMETHODIMP
CDoc::CRecalcHost::EvalExpression(IUnknown *pUnk, DISPID dispid, BSTR strExpression, BSTR strLanguage, VARIANT *pvResult)
{
    HRESULT hr;
    CScriptCollection * pScriptCollection;
    CElement *pElement;
    TCHAR *pchNamespace = NULL;

    if (!pvResult)
        RRETURN(E_INVALIDARG);

    TraceTag((tagRecalcHost, "Evaluating expression %ls", strExpression));

    VariantInit(pvResult);

    pElement = GetElementFromUnk(pUnk);
    pScriptCollection = pElement->GetNearestMarkupForScriptCollection()->GetScriptCollection();

    if (pScriptCollection)
    {
        CExcepInfo excepinfo;
        BOOL fSafe = FALSE;
        CMarkup *pMarkup = pElement->GetMarkup();
  
        if (pMarkup && !pMarkup->HasWindowPending())
        {
            CMarkupScriptContext *pScriptContext;
            hr = THR(pMarkup->EnsureScriptContext(&pScriptContext));
            if (!hr)
                pchNamespace = pScriptContext->_cstrNamespace;
        }

        hr = THR(pMarkup->ProcessURLAction(URLACTION_SCRIPT_RUN, &fSafe));
        if(!hr && fSafe) 
        {
            hr = THR(pScriptCollection->ParseScriptText(
                strLanguage,                    // pchLanguage
                NULL,                           // pMarkup
                NULL,                           // pchType
                strExpression,                  // pchCode
                pchNamespace,                   // pchItemName
                _T("\""),                       // pchDelimiter
                0,                              // ulOffset
                0,                              // ulStartingLine
                NULL,                           // pSourceObject
                SCRIPTTEXT_ISEXPRESSION,        // dwFlags
                pvResult,                       // pvarResult
                &excepinfo));                   // pExcepInfo
        }
        else
        {
            hr = E_ACCESSDENIED;
        }
    }
    else
        hr = E_FAIL;
  
    RRETURN(hr);
}
	
//------------------------------------
//
// CDoc::CRecalcHost::resolveName
//
// Description: An internal helper to resolve a single name
//
// This function walks the object.sub-object.sub-object.property string
//
// It doesn't handle arrays or anything other than strings
// This is by design.  Names involing arrays are very ambiguous
//
//------------------------------------

HRESULT
CDoc::CRecalcHost::resolveName(IDispatch *pDispatchThis, DISPID dispidThis,
                               LPOLESTR szName, IDispatch **ppDispatch, DISPID *pDispid)
{
    IDispatch *pDispatch = 0;
    CVariant v;
    HRESULT hr = S_OK;
    LPTSTR pchTemp;

    TraceTag((tagRecalcHost, "resolveName: %ls", szName));

    //
    // parsing a name of the form object.sub-object.sub-object.sub-object.property
    // need to know about scope so that "this" works properly.
    //
    // we tolerate nothing but name.name.name.name
    // no spaces, no nulls, no array references
    //

    CStr sTemp;
    
    hr = sTemp.Set(szName);
    if (hr)
        goto Cleanup;

    pchTemp = sTemp;

    // Check for "this."
    if (_tcsncmp(pchTemp, sTemp.Length(), _T("this."), 5) == 0)
    {
        //
        // Our initial scope is this
        //
        pDispatch = pDispatchThis;
        pDispatch->AddRef();

        pchTemp += 5;          // skip past "this."
    }
    else
    {
        //
        // The default initial scope is the "window" object or in the case of
        // htc's it is the default dispatch object
        //
        // REVIEW michaelw: this should also look for form objects
        //
        CBase *pDefaultInitialScope;
        CElement *pElement = GetElementFromUnk(pDispatchThis);
        CMarkup *pMarkup = pElement->GetMarkup();

        if (pMarkup && pMarkup->IsHtcMarkup())
        {
            pDefaultInitialScope = pMarkup->GetDefaultDocument();
        }
        else
        {
            pDefaultInitialScope = pElement->GetWindowedMarkupContext()->Window();
        }

        if (!pDefaultInitialScope)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        hr = THR(pDefaultInitialScope->PrivateQueryInterface(IID_IDispatchEx, (void **)&pDispatch));
        if (hr)
            goto Cleanup;
    }

    //
    // Now work our way through the names until we reach the end or something
    // doesn't map to sub-object
    //
    // REVIEW michaelw: is there any benefit (apart from complexity and case sensitivity)
    // REVIEW michaelw: to using IDispatchEx::GetDispID ?
    //

    while (*pchTemp)
    {
        LPTSTR pchEnd = pchTemp;

        // Skip over token characters
        while ((*pchEnd) && (*pchEnd != _T('.')))
            pchEnd++;

        if (pchEnd == pchTemp)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        BSTR strName = SysAllocStringLen(pchTemp, pchEnd - pchTemp);
        if (!strName)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // The token was terminated by a delimiter or the end of the string
        // in the case of a delimiter we need to skip past it.
        if (*pchEnd)
        {
            Assert(*pchEnd == _T('.'));
            pchTemp = pchEnd + 1;
            Assert(*pchTemp != _T('.'));
        }
        else
            pchTemp = pchEnd;

        hr = THR(GetNamedProp(pDispatch, strName, g_lcidUserDefault, &v, pDispid, NULL, FALSE, TRUE));

#if DBG == 1
        if (hr)
            TraceTag((tagRecalcHost, "resolveName: GetNamedProp(%ls) failed", strName));
#endif

        SysFreeString(strName);

        if (hr)
            goto Cleanup;

        if (*pchEnd == 0)
        {
            break;
        }
        else if (V_VT(&v) != VT_DISPATCH)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        else if (V_DISPATCH(&v) == 0)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        // We still have tokens and we still have a valid IDispatch, next token please!
        ReplaceInterface(&pDispatch, V_DISPATCH(&v));
        v.Clear();
    }

    Assert(*pchTemp == 0);

    //
    // CONSIDER (michaelw)
    // This is where we could try to detec if the object we've found is a 
    // builtin function or user-defined function.  In the case of a user-defined
    // function we would look for a ._recalcIgnore property that would allow us
    // to ignore this property for recalc purposes
    //

Cleanup:
    if (!hr)
    {
        TraceTag((tagRecalcHost, "resolveName %ls => %08x dispid: %08x", szName, pDispatch, *pDispid));
        *ppDispatch = pDispatch;
    }
    else
    {
        TraceTag((tagRecalcHost, "resolveName %ls failed", szName));
        *ppDispatch = 0;
        if (pDispatch)
            ReleaseInterface(pDispatch);
    }
    RRETURN(hr);
}


//------------------------------------
//
// CDoc::CRecalcHost::ResolveNames
//
// Description: IRecalcHost::ResolveNames
//
//------------------------------------

STDMETHODIMP
CDoc::CRecalcHost::ResolveNames(IUnknown *pUnk, DISPID dispid, unsigned cNames, BSTR *pstrNames, IDispatch **ppObjects, DISPID *pDispids)
{
    HRESULT hr;
    IDispatch *pDispatch = 0;
    unsigned i;

    if (pUnk == 0 || ppObjects == 0 || pDispids == 0)
        RRETURN(E_INVALIDARG);

    hr = THR(pUnk->QueryInterface(IID_IDispatch, (LPVOID *)&pDispatch));
    if (hr)
        goto Cleanup;

    for (i = 0 ; i < cNames ; i++)
    {
        hr = THR(resolveName(pDispatch, dispid, pstrNames[i], &ppObjects[i], &pDispids[i]));
        if (hr)
            goto Cleanup;
    }
Cleanup:
    ReleaseInterface(pDispatch);
    return hr;
}

STDMETHODIMP
CDoc::CRecalcHost::SetValue(IUnknown *pUnk, DISPID dispid, VARIANT *pv, BOOL fStyle)
{
    HRESULT hr;
    IDispatch *pDispatch = 0;
    CStyle *pStyle = 0;

    if (fStyle)
    {

        hr = pUnk->QueryInterface(CLSID_CStyle, (LPVOID *)&pStyle); // no AddRef
        if (hr)
            goto Cleanup;

        _pElemSetValue = pStyle->GetElementPtr();
        _dispidSetValue = dispid;
    }

    hr = THR(pUnk->QueryInterface(IID_IDispatch, (LPVOID *)&pDispatch));
    if (hr)
        goto Cleanup;

    hr = THR(SetDispProp(pDispatch, dispid, g_lcidUserDefault, pv));

    TraceTag((tagRecalcHost, "SetValue: put to %08x.%08x failed", pUnk, dispid));

    // Now we need to mark the value as something put there by an expression
    // so that we know to delete it when the expression goes away
    //
    // We only need to do this for style props (ie expressions that came in via the stylesheet)
    // Any other expression will have to be explicitly removed and the removeExpression will
    // remove the value at that time.
    //
    if (SUCCEEDED(hr) && fStyle)
    {
        CAttrArray **ppAA = 0;
        CAttrValue *pAV = 0;

        ppAA = pStyle->GetAttrArray();

        if (ppAA && *ppAA)
            pAV = (*ppAA)->Find(dispid, pStyle->IsExpandoDISPID(dispid) ? CAttrValue::AA_Expando : CAttrValue::AA_Attribute);
        
        if (pAV)
            pAV->SetExpression(TRUE);
    }

    _pElemSetValue = 0;

Cleanup:
    ReleaseInterface(pDispatch);
    RRETURN(hr);
}

//------------------------------------------------------------------
//
// Method:      RemoveValue
//
// Description: If the value in the target was put there by an expression
//              remove it.  If not then the value was explicitly put there
//              by someone else and we don't want to or need to remove it
//
//-------------------------------------------------------------------
STDMETHODIMP
CDoc::CRecalcHost::RemoveValue(IUnknown *pUnk, DISPID dispid)
{
    HRESULT hr = S_OK;
    CBase *pBase = (CBase *)pUnk;   // There really should be a better way!
    CAttrArray *pAA = *(pBase->GetAttrArray());
    if (pAA)
    {
        CAttrValue *pAV = pAA->Find(dispid);
        if (pAV && pAV->IsExpression())
        {
            PROPERTYDESC *pDesc = 0;
            hr = THR(pBase->FindPropDescFromDispID(dispid, &pDesc, 0, 0));
            if (!hr)
                hr = THR(pBase->removeAttributeDispid(dispid, pDesc) ? S_OK : E_FAIL);
        }
    }

    RRETURN(hr);
}

STDMETHODIMP
CDoc::CRecalcHost::GetScriptTextAttributes(LPCOLESTR szLanguage, LPCOLESTR pchCode, ULONG cch, LPCOLESTR szDelim, DWORD dwFlags, WORD *pattr)
{
    CScriptHolder *psholder = 0;
    IActiveScriptDebug *pdebug = 0;
    HRESULT hr = E_UNEXPECTED;
    CScriptCollection *pScriptCollection = MyDoc()->PrimaryMarkup()->GetScriptCollection();

    if (pScriptCollection)
    {
        hr = THR(pScriptCollection->GetHolderForLanguage(const_cast<LPOLESTR>(szLanguage), NULL, NULL, NULL, &psholder, NULL));
        if (hr)
            goto Cleanup;

        hr = THR(psholder->GetDebug(&pdebug));
        if (hr)
            goto Cleanup;

        hr = THR(pdebug->GetScriptTextAttributes(pchCode, cch, szDelim, dwFlags, pattr));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pdebug);
    RRETURN(hr);
}

#if DBG == 1
STDMETHODIMP
CDoc::CRecalcHost::GetObjectInfo(IUnknown *pUnk, DISPID dispid, BSTR *pstrID, BSTR *pstrMember, BSTR *pstrTag)
{
    if (pstrID)
        *pstrID = 0;
    if (pstrMember)
        *pstrMember = 0;
    if (pstrTag)
        *pstrTag = 0;

    if (!IsTagEnabled(tagRecalcGetInfo))
        RRETURN(E_FAIL);

    CElement *pElement = 0;
    IHTMLElement *pHTMLElement = 0;
    CStyle *pStyle = 0;
    HRESULT hr;
    BSTR bstrID = 0;

    // try to get the element
    hr = pUnk->QueryInterface(CLSID_CElement, (LPVOID *)&pElement);
    if (FAILED(hr))
    {
        // See if it's a style object and find the element

        hr = pUnk->QueryInterface(CLSID_CStyle, (LPVOID *)&pStyle);
        if (SUCCEEDED(hr))
        {
            pElement = pStyle->GetElementPtr();
        }
    }

    if (SUCCEEDED(hr))
    {
        // We have the element, now get the id, tag and member names

        if (pstrID)
        {
            hr = pElement->PrivateQueryInterface(IID_IHTMLElement, (LPVOID *)&pHTMLElement);
            Assert(!hr);

            IGNORE_HR(pHTMLElement->get_id(&bstrID));

            // No ID?  Try the name
            if (!bstrID || *bstrID == 0)
            {
                IGNORE_HR(pElement->get_name(&bstrID));
            }

            if (pStyle)
            {
                CBufferedStr cbuf;
                cbuf.Set(bstrID);
                cbuf.QuickAppend(_T(".style"));

                *pstrID = SysAllocString(cbuf);
            }
            else
            {
                *pstrID = bstrID;
                bstrID = 0; // prevent this from being freed
            }
        }

        if (pstrTag)
            pElement->get_tagName(pstrTag);

        if (pstrMember)
        {
            if (pStyle)
            {
                DISPID expDispid;
                LPCTSTR pszName = 0;

                PROPERTYDESC *ppropdesc = 0;
                if (pStyle->FindPropDescFromDispID(dispid, &ppropdesc, NULL, NULL) == S_OK)
                {
                    pszName = ppropdesc->pstrExposedName ? ppropdesc->pstrExposedName : ppropdesc->pstrName;
                }
                else if (pStyle->IsExpandoDISPID(dispid, &expDispid))
                {
                    pStyle->GetExpandoName(expDispid, &pszName);
                }

                *pstrMember = SysAllocString(pszName);
            }
            else
            {
                pElement->GetMemberName(dispid, pstrMember);
            }
        }
    }

    if (pHTMLElement)
        pHTMLElement->Release();
    if (bstrID)
        FormsFreeString(bstrID);

    RRETURN(hr);
}

int
CDoc::CRecalcHost::Dump(DWORD dwFlags)
{
    extern BOOL RecalcDumpOpen();
    if (!RecalcDumpOpen())
        return 0;

    r_p(_T("<div class=recalchost>Recalc Host<br>\n"));
    r_p(_T("\t<div class=recalcmembers>Members\n"));
    r_p(_T("\t\t<div class=recalcvalues>"));

    r_pp(_pElemSetValue);
    r_pn(_dispidSetValue);
    r_pb(_fRecalcRequested);
    r_pb(_fInRecalc);
    r_pn(_ulSuspend);
    r_p(_T("\t\t</div>\n"));
    r_p(_T("\t</div>\n"));

    if (_pEngine)
    {
        ((CRecalcEngine *)_pEngine)->Dump(dwFlags);
    }

    r_p(_T("</div>\n"));
    if (g_hfileRecalcDump)
    {
        CloseHandle(g_hfileRecalcDump);
        g_hfileRecalcDump = INVALID_HANDLE_VALUE;
    }
    return 0;
}
#endif


//+----------------------------------------------------------------------------
//
//  Function:   CElement::GetCanonicalProperty
//
//  Synopsis:   Returns the canonical pUnk/dispid pair for a particular dispid
//              Used by the recalc engine to catch aliased properties.
//
//  Parameters: ppUnk will contain the canonical object
//              pdispid will contain the canonical dispid
//
//  Returns:    S_OK if successful
//              S_FALSE if property has no alias
//
//-----------------------------------------------------------------------------

HRESULT
CElement::GetCanonicalProperty(DISPID dispid, IUnknown **ppUnk, DISPID *pdispid)
{
    HRESULT hr = S_OK;

    switch (dispid)
    {
    case DISPID_IHTMLELEMENT2_CLIENTLEFT:
        hr = THR(PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        *pdispid = DISPID_IHTMLELEMENT_OFFSETLEFT;
        break;
    case DISPID_IHTMLELEMENT2_CLIENTTOP:
        hr = THR(PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        *pdispid = DISPID_IHTMLELEMENT_OFFSETTOP;
        break;
    case DISPID_IHTMLELEMENT2_CLIENTWIDTH:
        hr = THR(PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        *pdispid = DISPID_IHTMLELEMENT_OFFSETWIDTH;
        break;
    case DISPID_IHTMLELEMENT2_CLIENTHEIGHT:
        hr = THR(PrivateQueryInterface(IID_IUnknown, (LPVOID *) ppUnk));
        *pdispid = DISPID_IHTMLELEMENT_OFFSETHEIGHT;
        break;
    default:
        *ppUnk = 0;
        *pdispid = 0;
        hr = S_FALSE;
    }
    
    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\rootelem.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       rootelem.cxx
//
//  Contents:   Implementation of CRootElement
//
//  Classes:    CRootElement
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

MtDefine(CRootElement, Elements, "CRootElement")


//////////////
//  Globals //
//////////////

const CElement::CLASSDESC CRootElement::s_classdesc =
{
    {
        NULL,                   // _pclsid
        0,                      // _idrBase
#ifndef NO_PROPERTY_PAGE
        0,                      // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                   // _pcpi
        ELEMENTDESC_NOLAYOUT,   // _dwFlags
        NULL,                   // _piidDispinterface
        NULL
    },
    NULL,

    NULL                        // _paccelsRun
};

void
CRootElement::Notify(CNotification *pNF)
{
    NOTIFYTYPE              ntype = pNF->Type();

    CMarkup *               pMarkup = GetMarkup();

    super::Notify(pNF);

    switch (ntype)
    {
    case NTYPE_SET_CODEPAGE:
        //
        // Directly switch the codepage (do not call SwitchCodePage)
        //
        {
            ULONG ulData;
            UINT WindowsCodePageFromCodePage( CODEPAGE cp );
        
            pNF->Data(&ulData);

            IGNORE_HR(pMarkup->SetCodePage(CODEPAGE(ulData)));
            IGNORE_HR(pMarkup->SetFamilyCodePage(WindowsCodePageFromCodePage(CODEPAGE(ulData))));
        }
        break;

    case NTYPE_END_PARSE:
        pMarkup->SetLoaded(TRUE);
        break;

    case NTYPE_ELEMENT_ENTERVIEW_1:
        // Inherit media property from our master
        if (HasMasterPtr())
        {
            CElement *pMasterElem = GetMasterPtr();
            CMarkup  *pMasterMarkup = pMasterElem->GetMarkup();
            CMarkup  *pMarkup = GetMarkup();
            mediaType mtMasterMarkup;

            Assert( pMasterMarkup && pMarkup );

            mtMasterMarkup = pMasterMarkup->GetMedia();

            // Only inherit if the master has a media set.
            if ( mtMasterMarkup != mediaTypeNotSet )
                pMarkup->SetMedia( mtMasterMarkup );
        }
        break;
    }
    return;
}

HRESULT
CRootElement::ComputeFormatsVirtual(CFormatInfo * pCFI, CTreeNode * pNodeTarget FCCOMMA FORMAT_CONTEXT FCPARAM )
{
    BOOL fParentFrameHidden      = FALSE;   
    BOOL fParentFrameDisplayNone = FALSE;              
    BOOL fInheritEditableFalse   = FALSE;
    BOOL fParentEditable         = IsDesignMode();

    if (HasMasterPtr())
    {
        CElement *          pElemMaster = GetMasterPtr();        
        ELEMENT_TAG         etag        = pElemMaster->TagType();

        fInheritEditableFalse = (etag==ETAG_GENERIC) || (etag==ETAG_FRAME) || (etag==ETAG_IFRAME);                 
        fParentEditable = pElemMaster->IsEditable(/*fCheckContainerOnly*/TRUE);        

        if (etag == ETAG_IFRAME || etag == ETAG_FRAME)
        {
            fParentFrameHidden      = pElemMaster->IsVisibilityHidden();  
            fParentFrameDisplayNone = pElemMaster->IsDisplayNone();                  
        }            

        if (pElemMaster->IsInMarkup())
        {
            CDefaults *pDefaults = pElemMaster->GetDefaults();                 
        
            if (    (!pDefaults && pElemMaster->TagType() == ETAG_GENERIC)
                ||  (pDefaults && pDefaults->GetAAviewInheritStyle())
                ||  pElemMaster->Tag() == ETAG_INPUT)
            {
                return super::ComputeFormatsVirtual(pCFI, pNodeTarget FCCOMMA FCPARAM);
            }          
        }       
    }

    SwitchesBegTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    CDoc *       pDoc = Doc();
    THREADSTATE *pts = GetThreadState();
    CColorValue  cv;
    COLORREF     cr;
    HRESULT      hr = S_OK;
    CMarkup *   pMarkup = GetMarkup();
    BOOL        fEditable;

    Assert(pCFI);
    Assert(SameScope( this, pNodeTarget));
#ifdef MULTI_FORMAT    
    Assert(   pCFI->_eExtraValues != ComputeFormatsType_Normal 
           || (    !pNodeTarget->HasFormatAry()
                && IS_FC(FCPARAM)
              )
           || (   (    pNodeTarget->GetICF(FCPARAM) == -1 
                    && pNodeTarget->GetIPF(FCPARAM) == -1
                  ) 
               || pNodeTarget->GetIFF(FCPARAM) == -1
              )
          );
#else
    Assert(   pCFI->_eExtraValues != ComputeFormatsType_Normal 
           || (   (    pNodeTarget->GetICF(FCPARAM) == -1 
                    && pNodeTarget->GetIPF(FCPARAM) == -1
                  ) 
               || pNodeTarget->GetIFF(FCPARAM) == -1
              )
          );
#endif //MULTI_FORMAT

    AssertSz(!TLS(fInInitAttrBag), "Trying to compute formats during InitAttrBag! This is bogus and must be corrected!");

    pCFI->Reset();
    pCFI->_pNodeContext = pNodeTarget;

    //
    // Setup Char Format
    //
    
    if (!pMarkup->_fDefaultCharFormatCached)
    {
        hr = THR(pMarkup->CacheDefaultCharFormat());
        if (hr)
            goto Cleanup;
    }

    if (pMarkup->_fHasDefaultCharFormat)
    {
        pCFI->_icfSrc = pMarkup->GetDefaultCharFormatIndex();
        pCFI->_pcfSrc = pCFI->_pcf = &(*pts->_pCharFormatCache)[pCFI->_icfSrc];
    }
    else
    {
        pCFI->_icfSrc = pDoc->_icfDefault;
        pCFI->_pcfSrc = pCFI->_pcf = pDoc->_pcfDefault;
    }
   
    if (pMarkup->_fInheritDesignMode) 
    {        
        if (fInheritEditableFalse)
        {
            fEditable = FALSE;
        }
        else
        {
            fEditable = fParentEditable;
        }
    } 
    else
    {
        fEditable = IsDesignMode();
    }

    if (pCFI->_pcf->_fEditable != fEditable)
    {
        pCFI->PrepareCharFormat();
        pCFI->_cf()._fEditable = fEditable;
        pCFI->UnprepareForDebug();
    }

    //
    // Setup Para Format
    //

    pCFI->_ipfSrc = pts->_ipfDefault;
    pCFI->_ppfSrc = pCFI->_ppf = pts->_ppfDefault;

    //
    // Setup Fancy Format
    //

    pCFI->_iffSrc = pts->_iffDefault;
    pCFI->_pffSrc = pCFI->_pff = pts->_pffDefault;
    
    if (fParentFrameHidden)
    {
        pCFI->PrepareCharFormat();
        pCFI->_cf()._fVisibilityHidden = TRUE;
        pCFI->UnprepareForDebug();
    }

    if (fParentFrameDisplayNone)
    {
        pCFI->PrepareCharFormat();
        pCFI->_cf()._fDisplayNone = TRUE;
        pCFI->UnprepareForDebug();
    }

    // TODO (JHarding): Per stress bug 90174, we think we have a window
    // here, but we really don't, so adding extra protection.
    // NB: (jbeda) I checked this out and it looks kosher.
    if (IsInMarkup() && GetMarkup()->HasWindow() && GetMarkup()->HasWindow() )
    {
        cv = GetMarkup()->Document()->GetAAbgColor();
    }

    if (cv.IsDefined())
        cr = cv.GetColorRef();
    else
        cr = pDoc->_pOptionSettings->crBack();

    if (   !pCFI->_pff->_ccvBackColor.IsDefined() 
        ||  pCFI->_pff->_ccvBackColor.GetColorRef() != cr)
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._ccvBackColor = cr;
        pCFI->UnprepareForDebug();
    }

    Assert(pCFI->_pff->_ccvBackColor.IsDefined());

    if(pCFI->_eExtraValues == ComputeFormatsType_Normal)
    {
        hr = THR(pNodeTarget->CacheNewFormats(pCFI FCCOMMA FCPARAM ));
        if (hr)
            goto Cleanup;

        // If the markup codepage is Hebrew visual order, set the flag.
        GetMarkup()->_fVisualOrder = (GetMarkup()->GetCodePage() == CP_ISO_8859_8);
    }

Cleanup:

    SwitchesEndTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRootElement::YieldCurrency
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
CRootElement::YieldCurrency(CElement *pElemNew)
{
    return super::YieldCurrency( pElemNew );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRootElement::YieldUI
//
//  Synopsis:
//
//----------------------------------------------------------------------------

void
CRootElement::YieldUI(CElement *pElemNew)
{
    // Note: We call Doc()->RemoveUI() if an embedded control
    // calls IOIPF::SetBorderSpace or IOIPF::SetMenu with non-null
    // values.

    Doc()->ShowUIActiveBorder(FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CRootElement::BecomeUIActive
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
CRootElement::BecomeUIActive()
{
    HRESULT hr = S_OK;
    CDoc *pDoc = Doc();

    // Nothing to do?

    // if the doc is not currently UIActive but a UIActive site exists, allow the
    // doc to go into UIACTIVE state.
    if (!pDoc->InPlace())
    {
        return E_FAIL;
    }

    if (    pDoc->_pElemUIActive == this 
        &&  GetFocus() == pDoc->InPlace()->_hwnd
        &&  pDoc->State() >= OS_UIACTIVE)
    {
        return S_OK;
    }

    // Tell the document that we are now the UI active site.
    // This will deactivate the current UI active site.

    hr = THR(pDoc->SetUIActiveElement(this));
    if (hr || pDoc->State() < OS_UIACTIVE)
        goto Cleanup;

    if (!pDoc->_pInPlace->_fDeactivating)
    {
        // We're now the UI active object, so tell the frame that.

        IGNORE_HR(pDoc->SetActiveObject());

#ifndef NO_OLEUI
        // Get our menus and toolbars up.

        IGNORE_HR(pDoc->InstallUI(FALSE));

        // If appropriate, show our grab handles.

        if (    !pDoc->_fMsoDocMode 
           &&   !pDoc->_fInWindowsXP_HSS 
           &&   (   pDoc->GetAmbientBool(DISPID_AMBIENT_SHOWHATCHING, TRUE)
                ||  pDoc->GetAmbientBool(DISPID_AMBIENT_SHOWGRABHANDLES, TRUE)))
        {
            pDoc->ShowUIActiveBorder(TRUE);
        }
#endif // NO_OLEUI
    }

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Method:     CRootElement::QueryStatusUndoRedo
//
//  Synopsis:   Helper function for QueryStatus(). Check if in our current
//              state we suport these commands.
//
//--------------------------------------------------------------------

#ifndef NO_EDIT
HRESULT
CRootElement::QueryStatusUndoRedo(
        BOOL fUndo,
        MSOCMD * pcmd,
        MSOCMDTEXT * pcmdtext)
{
    BSTR        bstr = NULL;
    HRESULT     hr;

    // Get the Undo/Redo state.
    if (fUndo)
        hr = THR_NOTRACE(Doc()->_pUndoMgr->GetLastUndoDescription(&bstr));
    else
        hr = THR_NOTRACE(Doc()->_pUndoMgr->GetLastRedoDescription(&bstr));

    // Return the command state.
    pcmd->cmdf = hr ? MSOCMDSTATE_DISABLED : MSOCMDSTATE_UP;

    // Return the command text if requested.
    if (pcmdtext && pcmdtext->cmdtextf == MSOCMDTEXTF_NAME)
    {


#if !defined(_MAC)
        if (hr)
        {
            pcmdtext->cwActual = LoadString(
                    GetResourceHInst(),
                    fUndo ? IDS_CANTUNDO : IDS_CANTREDO,
                    pcmdtext->rgwz,
                    pcmdtext->cwBuf);
        }
        else
        {
            hr = Format(
                    0,
                    pcmdtext->rgwz,
                    pcmdtext->cwBuf,
                    MAKEINTRESOURCE(fUndo ? IDS_UNDO : IDS_REDO),
                    bstr);
            if (!hr)
                pcmdtext->cwActual = _tcslen(pcmdtext->rgwz);
        }
#endif
    }

    if (bstr)
        FormsFreeString(bstr);

    return S_OK;
}
#endif // NO_EDIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\scollect.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       scollect.cxx
//
//  Contents:   Implementation of CScriptCollection class
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_SAFETY_HXX_
#define X_SAFETY_HXX_
#include "safety.hxx"
#endif

#ifndef X_SHOLDER_HXX_
#define X_SHOLDER_HXX_
#include "sholder.hxx"
#endif

#ifndef X_ESCRIPT_HXX_
#define X_ESCRIPT_HXX_
#include "escript.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_DEBUGGER_HXX_
#define X_DEBUGGER_HXX_
#include "debugger.hxx"
#endif

#define MAX_PROGID_LENGTH 39

MtDefine(CScriptCollection, ObjectModel, "CScriptCollection")
MtDefine(CScriptCollection_aryHolder_pv, CScriptCollection, "CScriptCollection::_aryHolder::_pv")
MtDefine(CScriptCollection_aryCloneHolder_pv, CScriptCollection, "CScriptCollection::_aryCloneHolder::_pv")
MtDefine(CScriptCollection_aryNamedItems_pv, CScriptCollection, "CScriptCollection::_aryNamedItems::_pv")
MtDefine(CNamedItemsTable_CItemsArray, CScriptCollection, "CNamedItemsTable::CItemsArray")
MtDefine(CScriptCollection_CScriptMethodsArray, CScriptCollection, "CScriptCollection::CScriptMethodsArray")
MtDefine(CScriptContext, ObjectModel, "CScriptContext")

const GUID CATID_ActiveScriptParse = { 0xf0b7a1a2, 0x9847, 0x11cf, { 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64 } };

const CLSID CLSID_VBScript = {0xB54F3741, 0x5B07, 0x11CF, 0xA4, 0xB0, 0x00, 0xAA, 0x00, 0x4A, 0x55, 0xE8};
const CLSID CLSID_JScript  = {0xF414C260, 0x6AC0, 0x11CF, 0xB6, 0xD1, 0x00, 0xAA, 0x00, 0xBB, 0xBB, 0x58};

#ifndef NO_SCRIPT_DEBUGGER
interface IProcessDebugManager *g_pPDM;
interface IDebugApplication *g_pDebugApp;


static BOOL g_fScriptDebuggerInitFailed;
static DWORD g_dwAppCookie;

HRESULT InitScriptDebugging();
void DeinitScriptDebugging();
#endif

DeclareTag(tagScriptCollection, "Script Collection", "Script collection methods")
ExternTag(tagSecureScriptWindow);

//---------------------------------------------------------------------------
//
//  Function:   CLSIDFromLanguage
//
//  Synopsis:   Given name of script language, find clsid of script engine.
//
//---------------------------------------------------------------------------

HRESULT
CLSIDFromLanguage(TCHAR *pchLanguage, REFGUID catid, CLSID *pclsid)
{
    HKEY    hkey;
    HRESULT hr;
    TCHAR   achBuf[256];
    long    lResult;

    if ( _tcslen(pchLanguage)> MAX_PROGID_LENGTH)
    {
        // Progid can ONLY have no more than 39 characters.
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(CLSIDFromProgID(pchLanguage, pclsid));
    if (hr)
        goto Cleanup;
#if !defined(WIN16) && !defined(WINCE) && !defined(_MAC)
    // Check to see that class supports required category.

    hr = THR(Format(0,
            achBuf,
            ARRAY_SIZE(achBuf),
            _T("CLSID\\<0g>\\Implemented Categories\\<1g>"),
            pclsid,
            &catid));
    if (hr)
        goto Cleanup;

    lResult = RegOpenKey(HKEY_CLASSES_ROOT, achBuf, &hkey);
    if (lResult == ERROR_SUCCESS)
    {
        RegCloseKey(hkey);
    }
    else
    {
        hr = REGDB_E_CLASSNOTREG;
        goto Cleanup;
    }
#endif // WINCE

Cleanup:
    RRETURN(hr);
}

//+--------------------------------------------------------------------------
//
//  Member:     CScriptCollection::CDebugDocumentStack constructor
//
//---------------------------------------------------------------------------

CScriptCollection::CDebugDocumentStack::CDebugDocumentStack(CScriptCollection * pScriptCollection)
{
    _pScriptCollection = pScriptCollection;
    
    //FerhanE:  This class instances are created in the stack mostly. There
    //          is a chance that the function using them will give control to the 
    //          outside (script or script engine) and cause the script engine 
    //          to be released. Since the class instances are in stack, the subref is
    //          released when the function exits. 
    _pScriptCollection->SubAddRef();

    _pDebugDocumentPrevious = pScriptCollection->_pCurrentDebugDocument;
}

//+--------------------------------------------------------------------------
//
//  Member:     CScriptCollection::CDebugDocumentStack destructor
//
//---------------------------------------------------------------------------

CScriptCollection::CDebugDocumentStack::~CDebugDocumentStack()
{
    if (_pScriptCollection->_pCurrentDebugDocument)
        _pScriptCollection->_pCurrentDebugDocument->UpdateDocumentSize();

    _pScriptCollection->_pCurrentDebugDocument = _pDebugDocumentPrevious;

    _pScriptCollection->SubRelease();
}

//+--------------------------------------------------------------------------
//
//  Function:   CScriptCollection::CScriptCollection
//
//---------------------------------------------------------------------------

CScriptCollection::CScriptCollection()
    : _aryHolder(Mt(CScriptCollection_aryHolder_pv)),
      _aryCloneHolder(Mt(CScriptCollection_aryCloneHolder_pv))
{
    _ulRefs = 1;
    _ulAllRefs = 1;
    Assert (!_fInEnginesGetDispID);
    Assert (!_fHasPendingMarkup);
}

//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::Init
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::Init(CDoc * pDoc, COmWindowProxy * pOmWindowProxy)
{
    HRESULT hr = S_OK;

    TraceTag((tagScriptCollection, "Init"));

    MemSetName((this, "ScrptColl pDoc=%08x %ls", pDoc, pDoc->GetPrimaryUrl() ? pDoc->GetPrimaryUrl() : _T("")));

    Assert (pDoc && !_pDoc);

    _pDoc = pDoc;
    _pDoc->SubAddRef();

    _pOmWindowProxy = pOmWindowProxy;
    _pOmWindowProxy->SubAddRef();

    if(_pOmWindowProxy->Window()->_pMarkupPending)
    {
        _fHasPendingMarkup = TRUE;
    }

#ifndef NO_SCRIPT_DEBUGGER
    // Has the user has chosen to disable script debugging?
    _pDoc->UpdateFromRegistry();
    if (!_pDoc->_pOptionSettings->fDisableScriptDebugger)
    {
        // If this fails we just won't have smart host debugging
        IGNORE_HR(InitScriptDebugging());
    }
#endif

#if DBG==1
    // optionally get a secure window proxy to be given to script engine
    if (IsTagEnabled(tagSecureScriptWindow))
    {
        if (_pOmWindowProxy->_fTrusted)
        {
            IHTMLWindow2 *pw2Secured;
            hr = THR(pOmWindowProxy->SecureObject(pOmWindowProxy->Window(), &pw2Secured));
            if (!hr)
            {
                hr = pw2Secured->QueryInterface(CLSID_HTMLWindowProxy, (void**) &_pSecureWindowProxy);
                Assert(!hr);
                _pSecureWindowProxy->AddRef();
                pw2Secured->Release();
            }
        }
        else
        {
            _pSecureWindowProxy = _pOmWindowProxy;
            _pSecureWindowProxy->AddRef();
        }
    }
#endif

    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::~CScriptCollection
//
//---------------------------------------------------------------------------

CScriptCollection::~CScriptCollection()
{
    int             c;

    _NamedItemsTable.FreeAll();

    for (c = _aryHolder.Size(); --c >= 0; )
    {
        IGNORE_HR(_aryHolder[c]->Close());
        _aryHolder[c]->Release();
    }
    _aryHolder.DeleteAll();

    for (c = _aryCloneHolder.Size(); --c >= 0; )
    {
        if (_aryCloneHolder[c] == NULL)
            continue;
        IGNORE_HR(_aryCloneHolder[c]->Close());
        _aryCloneHolder[c]->Release();
    }
    _aryCloneHolder.DeleteAll();

    _pDoc->SubRelease();
    _pOmWindowProxy->SubRelease();

#if DBG==1
    if (_pSecureWindowProxy)
        _pSecureWindowProxy->Release();
#endif
}


//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::Release
//
//  Synposis:   Per IUnknown
//
//---------------------------------------------------------------------------

ULONG
CScriptCollection::Release()
{
    ULONG ulRefs;
    if (--_ulRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        Deinit();
        _ulRefs = 0;
    }
    ulRefs = _ulRefs;
    SubRelease();
    return ulRefs;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptCollection::SubRelease
//
//---------------------------------------------------------------------------

ULONG
CScriptCollection::SubRelease()
{
#ifndef NO_SCRIPT_DEBUGGER
    if (_pDoc->_dwTID != GetCurrentThreadId())
    {
        Assert(0 && "Debugger called across thread boundary (not an MSHTML bug)");
        return TRUE;
    }
#endif //NO_SCRIPT_DEBUGGER

    if (--_ulAllRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        _ulAllRefs = ULREF_IN_DESTRUCTOR;
        delete this;
        return 0;
    }
    return _ulAllRefs;
}


//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::Deinit
//
//---------------------------------------------------------------------------

void
CScriptCollection::Deinit()
{
    TraceTag((tagScriptCollection, "Deinit"));

    //
    // Disconnect any VBScript event sinks.  Need to do this to ensure that
    // other events are not continually fired if the document is reused.
    //
    SetState(SCRIPTSTATE_DISCONNECTED);
}


CMarkup* 
CScriptCollection::GetMarkup()
{
    if(_fHasPendingMarkup && _pOmWindowProxy->Window()->_pMarkupPending)
    {
        return _pOmWindowProxy->Window()->_pMarkupPending;
    }    
    return _pOmWindowProxy->Markup();
}

//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::AddNamedItem
//
//  Synopsis:   Let script engine know about any named items that were
//              added.
//
//  Notes:      Assumed to be added with SCRIPTITEM_ISVISIBLE|SCRIPTITEM_ISSOURCE
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::AddNamedItem(CElement *pElement)
{
    TraceTag((tagScriptCollection, "AddNamedItem"));

    HRESULT             hr = S_OK;
    CStr                cstr;
    LPTSTR              pch;
    BOOL                fDidCreate;
    CDoc *              pDoc;
    CCollectionCache *  pCollectionCache;

    Assert(pElement->Tag() == ETAG_FORM);

    pch = (LPTSTR) pElement->GetIdentifier();
    if (!pch || !*pch)
    {
        hr = THR(pElement->GetUniqueIdentifier(&cstr, TRUE, &fDidCreate));
        if (hr)
            goto Cleanup;
        pch = cstr;
        pDoc = Doc();

        pCollectionCache = pDoc->PrimaryMarkup()->CollectionCache();
        if ( fDidCreate && pCollectionCache)
            pCollectionCache->InvalidateItem(CMarkup::WINDOW_COLLECTION);
    }

    hr = THR(AddNamedItem(pch, NULL, (IUnknown*)(IPrivateUnknown*)pElement));

Cleanup:

    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::AddNamedItem
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::AddNamedItem(LPTSTR pchName, CScriptContext * pScriptContext, IUnknown * pUnkItem)
{
    HRESULT             hr;
    int                 c;
    CScriptHolder **    ppHolder;

    //
    // ensure name
    //

    if (!pchName)
    {
        Assert (pScriptContext);

        hr = THR(_pDoc->GetUniqueIdentifier(&pScriptContext->_cstrNamespace));
        if (hr)
            goto Cleanup;

        pchName = pScriptContext->_cstrNamespace;
    }

    //
    // register it in our table
    //

    hr = THR(_NamedItemsTable.AddItem(pchName, pUnkItem));
    if (hr)
        goto Cleanup;

    //
    // broadcast to script engines
    //

    for (c = _aryHolder.Size(), ppHolder = _aryHolder; c > 0; c--, ppHolder++)
    {
        // (do not pass in the ISVISIBLE flag.  This will break form access by name from the window collection)
        IGNORE_HR((*ppHolder)->_pScript->AddNamedItem(pchName, SCRIPTITEM_ISSOURCE));
    }

Cleanup:
    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::SetState
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::SetState(SCRIPTSTATE ss)
{
    TraceTag((tagScriptCollection, "SetState"));
    HRESULT hr = S_OK;
    int c;

    CDoc::CLock Lock(_pDoc);

    for (c = _aryHolder.Size(); --c >= 0; )
    {
        hr = THR(_aryHolder[c]->SetScriptState(ss));
        if (hr)
            goto Cleanup;
    }

    for (c = _aryCloneHolder.Size(); --c >= 0; )
    {
        if (_aryCloneHolder[c] == NULL)
            continue;

        hr = THR(_aryCloneHolder[c]->SetScriptState(ss));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::AddHolderForObject
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::AddHolderForObject(IActiveScript *pScript, CLSID *pClsid)
{
    TraceTag((tagScriptCollection, "AddHolderForObject"));

    HRESULT                 hr=S_OK;
    CScriptHolder *         pHolder;
    IActiveScriptParse *    pScriptParse = NULL;
    BOOL                    fRunScripts;
    IUnknown *              pUnk;

    hr = THR(GetMarkup()->ProcessURLAction(URLACTION_SCRIPT_RUN, &fRunScripts));    
    if (hr || !fRunScripts)
        goto Cleanup;
        
    // Ok for this to fail
    THR_NOTRACE(pScript->QueryInterface(
        IID_IActiveScriptParse,
        (void **)&pScriptParse));

    if (pScriptParse)
    {
        pUnk = pScriptParse;
    }
    else
    {
        pUnk = pScript;
    }
    
    if (!IsSafeToRunScripts(pClsid, pUnk))
        goto Cleanup;
        
    {
        CDoc::CLock Lock(_pDoc);

        pHolder = new CScriptHolder(this);
        if (!pHolder)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(pHolder->Init(IsEqualGUID(*pClsid, CLSID_JScript), pScript, pScriptParse, pClsid));
        if (hr)
            goto Error;

        hr = THR(_aryHolder.Append(pHolder));
        if (hr)
            goto Error;
    }

Cleanup:
    ReleaseInterface(pScriptParse);
    RRETURN(hr);

Error:
    delete pHolder;
    pHolder = NULL;
    goto Cleanup;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptCollection::IsSafeToRunScripts
//
//  Synopsis:   Decide whether script engine is safe to instantiate.
//
//---------------------------------------------------------------------------

BOOL 
CScriptCollection::IsSafeToRunScripts(CLSID *pClsid, IUnknown *pUnk, BOOL fCheckScriptOverrideSafety)
{
    BOOL    fSafe = FALSE;
    HRESULT hr;
    
    // We need a clsid and an interface pointer!
    if (!pClsid || !pUnk)
        goto Cleanup;

    if (fCheckScriptOverrideSafety)
    {
        hr = THR(GetMarkup()->ProcessURLAction(
                    URLACTION_SCRIPT_OVERRIDE_SAFETY,
                    &fSafe));

        if (hr || fSafe)
            goto Cleanup;
    }

    // WINCEREVIEW - ignore script safety checking !!!!!!!!!!!!!!!!
#ifndef WINCE

    fSafe = ::IsSafeTo(
                SAFETY_SCRIPTENGINE, 
                IID_IActiveScriptParse, 
                *pClsid, 
                pUnk, 
                GetMarkup());
    if (fSafe)
        goto Cleanup;

    fSafe = ::IsSafeTo(
                SAFETY_SCRIPTENGINE, 
                IID_IActiveScript, 
                *pClsid, 
                pUnk, 
                GetMarkup());


#else // !WINCE
      // blindly say that this is safe.
    fSafe = TRUE;
#endif // !WINCE
    
Cleanup:
    return fSafe;
}


//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::GetHolderForLanguage
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::GetHolderForLanguage(
    TCHAR *             pchLanguage,
    CMarkup *           pMarkup,
    TCHAR *             pchType,
    TCHAR *             pchCode,
    CScriptHolder **    ppHolder,
    TCHAR **            ppchCleanCode,
    CHtmlComponent *    pComponent,
    CStr *              pcstrNamespace)
{
    HRESULT     hr;
    TCHAR *     pchColon;

    // ( TODO perf(alexz) this functions shows up in perf numbers, up to 4%, on pages with lots of HTCs.
    // By hashing and caching pchLanguage, pMarkup, etc we should be able to speed it up and remove
    // the 4% from the picture )

    if (pchCode)
    {
        // check if this is a case like "javascript: alert('hello')"

        pchColon = _tcschr (pchCode, _T(':'));

        if (pchColon)
        {
            // we assume here that we can modify string at pchColon temporarily
            *pchColon = 0;

            // We shouldn't get a "fooLanguage:" w/ a type.
            Assert(!pchType || (StrCmpIC(pchCode, _T("javascript")) && StrCmpIC(pchCode, _T("vbscript")) && (pchColon-pchCode > 15)));
            hr = THR_NOTRACE(GetHolderForLanguageHelper(pchCode, pMarkup, pchType, pComponent, pcstrNamespace, ppHolder));

            *pchColon = _T(':');

            if (S_OK == hr)                         // if successful
            {
                if (ppchCleanCode)
                {
                    *ppchCleanCode = pchColon + 1;  // adjust ppchCleanCode so to skip prefix 'fooLanguage:'
                }
                goto Cleanup;                       // and nothing more to do
            }
        }
    }

    if (ppchCleanCode)
    {
        *ppchCleanCode = pchCode;
    }

    hr = THR_NOTRACE(GetHolderForLanguageHelper(pchLanguage, pMarkup, pchType, pComponent, pcstrNamespace, ppHolder));

Cleanup:

    RRETURN (hr);
}


//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::GetHolderForLanguageHelper
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::GetHolderForLanguageHelper(
    TCHAR *             pchLanguage,
    CMarkup *           pMarkup,
    TCHAR *             pchType,
    CHtmlComponent *    pComponent,
    CStr *              pcstrNamespace,
    CScriptHolder **    ppHolder)
{
    HRESULT                 hr = S_OK;
    int                     idx = -1;
    int                     cnt;
    CLSID                   clsid;
    BOOL                    fNoClone = FALSE;
    BOOL                    fCaseSensitive = FALSE;
    IActiveScript *         pScript = NULL;
    IActiveScriptParse *    pScriptParse = NULL;
    CHtmlComponent *        pFactory = NULL;
    CMarkupScriptContext *  pMarkupScriptContext = NULL;

    // (sramani) FaultInIEFeatureHelper can throw up a dlg that can push a msg loop causing this
    // scriptcollection to be passivated. See Stress bug #105268
    Assert(_ulRefs);
    AddRef();

    Assert(ppHolder);
    *ppHolder = NULL;

    if (pComponent)
    {
        // for lightweight htc's with one script element, the component is passed in.
        Assert(pComponent && !pComponent->_fFactoryComponent);
        pFactory = pComponent->_pConstructor->_pFactoryComponent;
        Assert(pFactory && pFactory->_fLightWeight);
        
        // does htc contain only one SE?
        if (!pFactory->_fClonedScript)
        {
            // No, create engine\holder the old way but use factory markup's script context
            pFactory = NULL;
            Assert(pMarkup && pMarkup->HasScriptContext());
            pMarkupScriptContext = pMarkup->ScriptContext();
            Assert(pMarkupScriptContext);
            Assert(!pMarkupScriptContext->_fClonedScript);
        }
        else
        {
            // Yes, use this component instance's script context 
            hr = THR(pComponent->GetScriptContext((CScriptContext **)&pMarkupScriptContext));
            Assert(pMarkupScriptContext->_fClonedScript);
        }

        if (hr)
            goto Cleanup;
    }
    else if (pMarkup)
    {
        // Non-lightweight htc's and non-htc holders
        Assert(!pComponent);
        hr = THR(pMarkup->EnsureScriptContext(&pMarkupScriptContext));
        if (hr)
            goto Cleanup;

        if (pMarkup->HasBehaviorContext())
        {
            pComponent = pMarkup->BehaviorContext()->_pHtmlComponent;
            if (pComponent)
            {
                Assert(!pComponent->_fFactoryComponent);
                pFactory = pComponent->_pConstructor->_pFactoryComponent;
                Assert(pFactory && !pFactory->_fLightWeight);
                // does normal htc contain only one SE?
                if (!pFactory->_fClonedScript)
                {
                    // No, create engine\holder the old way and use this htc instance markup's script context
                    Assert(!pMarkupScriptContext->_fClonedScript);
                    pFactory = NULL;
                }
                else
                    Assert(pMarkupScriptContext->_fClonedScript); // yes, create clone
            }
        }
    }

    if (pFactory)
    {
        // Clone to be created
        Assert(pComponent);
        Assert(pFactory->_fClonedScript);
        Assert(pMarkupScriptContext);
        idx = pMarkupScriptContext->_idxDefaultScriptHolder;
        if (idx != -1)
        {
            // clone already created.
            Assert (_aryCloneHolder.Size() > idx &&
                    _aryCloneHolder[idx] &&
                    _aryCloneHolder[idx]->_pScriptParse);

            // if language of current SE being requested is not specified, then we are done as it uses the first created
            // engine (the clone) as the default, else check further down if they are different.
            if((!pchType || !*pchType) && (!pchLanguage || !*pchLanguage))
                goto Cleanup;
        }
    }

    //
    // The type attribute should be of the form:
    // text/script-type.  If it is not of this 
    // type, then it's invalid.
    // Additionally, the type attribute takes precedence
    // over the language attribute, so if it's present,
    // we use it instead.
    //
    if(pchType && *pchType)
    {
        // TODO (t-johnh): Maybe we should do a check on the
        // type attribute as a MIME type instead of checking
        // for text/fooLanguage

        // Make sure we've got text/fooLanguage
        if(!_tcsnipre(_T("text"), 4, pchType, 4))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        // Skip to what's past the "text/"
        pchLanguage = pchType + 5;
    }
    else if (!pchLanguage || !pchLanguage[0]) // if no language nor type specified 
    {
        if (pMarkup)
        {
            AssertSz ((pMarkup->GetScriptCollection(FALSE) == this), "Script collection of markup does not match. Contact sramani if this happpens.");

            if (pMarkupScriptContext &&                                 // if default holder is indicated                      
                pMarkupScriptContext->_idxDefaultScriptHolder != -1 &&  // in the markup context
                pMarkup->GetScriptCollection(FALSE) == this)               
            {
                Assert (0 <= pMarkupScriptContext->_idxDefaultScriptHolder &&
                             pMarkupScriptContext->_idxDefaultScriptHolder < _aryHolder.Size());

                idx = pMarkupScriptContext->_idxDefaultScriptHolder;

                Assert (   _aryHolder.Size() > idx 
                        && _aryHolder[idx] 
                        && _aryHolder[idx]->_pScriptParse);

                goto Cleanup;   // done
            }
        }
        else if (!pFactory)
        {
            // pick the first script holder that supports scripting
            for (idx = 0, cnt = _aryHolder.Size(); idx < cnt; idx++)
            {
                if (_aryHolder[idx]->_pScriptParse)
                {
                    goto Cleanup;   // done
                }
            }
        }

        // if not found: there were no script holders (for scripting) created so use JavaScript as default
        pchLanguage = _T("JavaScript");
    }
    else if (0 == StrCmpIC(pchLanguage, _T("LiveScript")))
    {
        // LiveScript is the old name for JavaScript, so convert if necessary
        pchLanguage = _T("JavaScript");
    }

    //
    // Get the clsid for this language.
    //

    // Perf optimization for Win98 and Win95 to not hit the registry with
    // CLSIDFromPROGID.

    // TODO: ***TLL*** better solution is to remember
    // the language name and clsid in the script holder as a cache and check
    // in the holder first.
    if ((*pchLanguage == _T('j') || *pchLanguage == _T('J'))    &&
        (0 == StrCmpIC(pchLanguage, _T("jscript"))          ||
         0 == StrCmpIC(pchLanguage, _T("javascript"))))
    {
        clsid = CLSID_JScript;
        fCaseSensitive = TRUE;
        if (pFactory)
        {
            if (idx != -1)
            {
                // There is already a cloned SE, check to see if it is for the same language as the one being requested
                Assert (_aryCloneHolder.Size() > idx &&
                        _aryCloneHolder[idx] &&
                        _aryCloneHolder[idx]->_pScriptParse);

                if (_aryCloneHolder[idx] == NULL)
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }

                if (_aryCloneHolder[idx]->_fCaseSensitive)
                    goto Cleanup; // engine matched, done
                else
                {
                    fNoClone = TRUE;
                    pFactory = NULL; // need to create new engine the old way (no clone), default is cloned engine
                }
            }
            else
            {
                // There is one only Script element, but no holder is created for it yet. Check to see if the language
                // of the SE being requested is the same as the one that will be cloned later
                Assert(pComponent && pComponent->_pConstructor);
                Assert(pFactory == pComponent->_pConstructor->_pFactoryComponent);
                Assert(pComponent->_pConstructor->_pelFactoryScript);
                LPCTSTR pchLang = pComponent->_pConstructor->_pelFactoryScript->GetAAlanguage();
                if (pchLang &&
                    (*pchLang == _T('v') || *pchLang == _T('V')) &&
                    (0 == StrCmpIC(pchLang, _T("vbs")) ||
                     0 == StrCmpIC(pchLang, _T("vbscript"))))
                {
                    // No match.
                    fNoClone = TRUE;
                    pFactory = NULL; // need to create new engine the old way (no clone), default is cloned engine
                }
            }
        }
    }
    else if ((*pchLanguage == _T('v') || *pchLanguage == _T('V'))    &&
             (0 == StrCmpIC(pchLanguage, _T("vbs"))         ||
              0 == StrCmpIC(pchLanguage, _T("vbscript"))))
    {
        clsid = CLSID_VBScript;
        if (pFactory)
        {
            if (idx != -1)
            {
                // There is already a cloned SE, check to see if it is for the same language as the one being requested
                Assert (_aryCloneHolder.Size() > idx &&
                        _aryCloneHolder[idx] &&
                        _aryCloneHolder[idx]->_pScriptParse);

                if (_aryCloneHolder[idx] == NULL)
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }

                if (_aryCloneHolder[idx]->_fCaseSensitive)
                {
                    fNoClone = TRUE;
                    pFactory = NULL;  // need to create new engine the old way (no clone), default is cloned engine
                }
                else
                    goto Cleanup;  // engine matched, done
            }
            else
            {
                // There is one only Script element, but no holder is created for it yet. Check to see if the language
                // of the SE being requested is the same as the one that will be cloned later
                Assert(pComponent && pComponent->_pConstructor);
                Assert(pFactory == pComponent->_pConstructor->_pFactoryComponent);
                Assert(pComponent->_pConstructor->_pelFactoryScript);
                if (pComponent->_pConstructor->_pelFactoryScript->_fJScript)
                {
                    // No match.
                    fNoClone = TRUE;
                    pFactory = NULL; // need to create new engine the old way (no clone), default is cloned engine
                }
            }
        }
    }
    else
    {
        hr = THR(CLSIDFromLanguage(pchLanguage, CATID_ActiveScriptParse, &clsid));
        if (hr)
        {
            goto Cleanup;
        }
        if (pFactory)
        {
            BOOL fOtherScript = TRUE;

            Assert(pComponent && pComponent->_pConstructor);
            Assert(pFactory == pComponent->_pConstructor->_pFactoryComponent);
            Assert(pComponent->_pConstructor->_pelFactoryScript);

            // there is only one Script Element (js or vbs), but the current SE requested is for another
            // language, so not not clone this one as only the engine for the script element can be cloned.
            if (idx == -1 && !pComponent->_pConstructor->_pelFactoryScript->_fJScript)
            {
                LPCTSTR pchLang = pComponent->_pConstructor->_pelFactoryScript->GetAAlanguage();
                fOtherScript = (pchLang &&
                                (*pchLang == _T('v') || *pchLang == _T('V')) &&
                                (0 == StrCmpIC(pchLang, _T("vbs")) ||
                                 0 == StrCmpIC(pchLang, _T("vbscript"))));
                    
            }

            if (fOtherScript)
            {
                fNoClone = TRUE;
                pFactory = NULL;
            }
        }
    }

    //
    // Do we already have one on hand?
    //
    if (!pFactory)
    {
        if (fNoClone)
        {
            Assert(pMarkupScriptContext &&
                   pMarkupScriptContext->_fClonedScript &&
                   pMarkupScriptContext->GetNamespace());

            Assert(pComponent &&
                   !pComponent->_fFactoryComponent &&
                   pComponent->_pConstructor->_pFactoryComponent->_fClonedScript);

            // lang of current Se is different from already exisiting or to be created clone, so create a new namespace
            // if one is being requested (from ConstructCode() only)
            if (pcstrNamespace)
            {
                hr = THR(_pDoc->GetUniqueIdentifier(pcstrNamespace));
                if (hr)
                    goto Cleanup;

                hr = THR(_NamedItemsTable.AddItem(*pcstrNamespace, (IUnknown*)(IPrivateUnknown*)&(pComponent->_DD)));
                if (hr)
                    goto Cleanup;
            }
        }

        for (idx = 0, cnt = _aryHolder.Size(); idx < cnt; idx++)
        {
            if (*(_aryHolder[idx]->_pclsid) == clsid)
            {
                if (fNoClone && pcstrNamespace)
                {
                    // if a namespace was created above add it to the already created SE just found.
                    Assert((LPTSTR)*pcstrNamespace);
                    Assert(_aryHolder[idx]->_pScript);
                    hr = THR(_aryHolder[idx]->_pScript->AddNamedItem(*pcstrNamespace, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE));
                }

                goto Cleanup;   // done - found
            }
        }
    }

    // Create one.
    if (!pFactory || pComponent->_fFirstInstance)
    {
        if (IsEqualGUID(clsid, CLSID_VBScript))
        {
            uCLSSPEC classpec;

            classpec.tyspec = TYSPEC_CLSID;
            classpec.tagged_union.clsid = clsid;

            hr = THR(FaultInIEFeatureHelper(_pDoc->GetHWND(), &classpec, NULL, 0));

            // TODO (lmollico): should Assert(hr != S_FALSE) before we ship
            if (FAILED(hr))
            {
                hr = REGDB_E_CLASSNOTREG;
                goto Cleanup;
            }
        }

        hr = THR(CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void **)&pScript));
        if (hr)
            goto Cleanup;

        hr = THR(pScript->QueryInterface(IID_IActiveScriptParse, (void **)&pScriptParse));
        if (hr)
            goto Cleanup;

        if (!IsSafeToRunScripts(&clsid, pScript))
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    
    *ppHolder = new CScriptHolder(this);
    if (!*ppHolder)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (!pFactory || pComponent->_fFirstInstance)
    {
        if (pFactory)
        {
            // init SE for first instance of htc. This will be the original for other instances to clone from
            Assert(pMarkupScriptContext->GetNamespace());
            (*ppHolder)->_fOriginal = TRUE;
            (*ppHolder)->_pUnkItem = (IUnknown*)(IPrivateUnknown*)&(pComponent->_DD);
            (*ppHolder)->_pUnkItem->AddRef();
        }

        // Clones need not store the classid and can share the same namespace string as each clone has a unique holder
        // and there is a 1:1 relationship between the two -- The _idxDefaultScriptHolder of the corresponding instance's
        // script context always refers to the correct clone in _aryCloneHolder
        hr = THR((*ppHolder)->Init(fCaseSensitive,
                                   pScript,
                                   pScriptParse,
                                   pFactory ? NULL : &clsid,
                                   pFactory ? pMarkupScriptContext->GetNamespace() : NULL));
    }
    else if (pFactory->_pMarkup->ScriptContext()->_idxDefaultScriptHolder != -1)
    {
        // Clone the SE from original is this htc instance is not the first one. the factory markup's _idxDefaultScriptHolder
        // stores the index of the original holder\engine in _aryCloneHolder.
        (*ppHolder)->_pUnkItem = (IUnknown*)(IPrivateUnknown*)&(pComponent->_DD);
        (*ppHolder)->_pUnkItem->AddRef();

        Assert(pFactory->_pMarkup && pFactory->_pMarkup->HasScriptContext());
        Assert(pFactory->_pMarkup->ScriptContext()->_idxDefaultScriptHolder != -1);
        hr = THR(_aryCloneHolder[pFactory->_pMarkup->ScriptContext()->_idxDefaultScriptHolder]->Clone(&clsid, *ppHolder));
    }
    else
    {
        // we are here because the original holder was n't created for some reason. So fail the clones too.
        hr = E_FAIL;
    }

    if (hr)
        goto Cleanup;

    if (pFactory)
    {
        hr = THR(_aryCloneHolder.Append(*ppHolder));
        idx = _aryCloneHolder.Size() - 1;
    }
    else
        hr = THR(_aryHolder.Append(*ppHolder));

    if (hr)
        goto Cleanup;

    Assert ((!pFactory && idx == _aryHolder.Size() - 1) || (pFactory && idx == _aryCloneHolder.Size() - 1));

Cleanup:

    // (sramani) FaultInIEFeatureHelper can throw up a dlg that can push a msg loop causing this
    // scriptcollection to be passivated. See Stress bug #105268
    if (_ulRefs == 1)
        hr = E_FAIL;

    if (S_OK == hr)
    {
        Assert (0 <= idx && ((!pFactory && idx < _aryHolder.Size()) || (pFactory && idx < _aryCloneHolder.Size())));

        (*ppHolder) = pFactory ? _aryCloneHolder[idx] : _aryHolder[idx];

        if (!fNoClone && 
            pMarkupScriptContext &&                                 // if default holder is not yet set in the
            pMarkupScriptContext->_idxDefaultScriptHolder == -1)    // markup context
        {
            pMarkupScriptContext->_idxDefaultScriptHolder = idx;
            if (pFactory && pComponent->_fFirstInstance)
            {
                // index of original script holder in factory markup script context
                Assert(pFactory->_pMarkup && pFactory->_pMarkup->HasScriptContext());
                pFactory->_pMarkup->ScriptContext()->_idxDefaultScriptHolder = idx; 
                pFactory->_fOriginalSECreated = TRUE;
            }
        }
    }
    else // if (hr)
    {
        delete *ppHolder;
        *ppHolder = NULL;
    }

    ReleaseInterface(pScript);
    ReleaseInterface(pScriptParse);

    Assert(_ulRefs);
    Release();

    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::AddScriptlet
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::AddScriptlet(
    LPTSTR      pchLanguage,
    CMarkup *   pMarkup,
    LPTSTR      pchType,
    LPTSTR      pchCode,
    LPTSTR      pchItemName,
    LPTSTR      pchSubItemName,
    LPTSTR      pchEventName,
    LPTSTR      pchDelimiter,
    ULONG       ulOffset,
    ULONG       ulStartingLine,
    CBase *     pSourceObject,
    DWORD       dwFlags,
    BSTR *      pbstrName,
    CHtmlComponent *pComponent)
{
    TraceTag((tagScriptCollection, "AddScriplet"));

    HRESULT                 hr = S_OK;
    CScriptHolder *         pHolder;
    CExcepInfo              ExcepInfo;
    DWORD_PTR               dwSourceContextCookie = NO_SOURCE_CONTEXT;
    TCHAR *                 pchCleanCode = NULL;
    CDebugDocumentStack     debugDocumentStack(this);
    CDoc::CLock             Lock(_pDoc);

    hr = THR(GetHolderForLanguage(pchLanguage, pMarkup, pchType, pchCode, &pHolder, &pchCleanCode, pComponent));
    if (hr)
        goto Cleanup;

    if (!pchCleanCode)
    {
        Assert (!hr);
        goto Cleanup;
    }

    Assert(pHolder->_pScriptParse);
    if(!pHolder->_pScriptParse)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // If the engine supports IParseProcedure then we don't need to do AddScriptlet
    // instead we'll use function pointers.
    if (pchCleanCode && !pHolder->_pParseProcedure)
    {

        hr = THR(CreateSourceContextCookie(
            pHolder->_pScript, pchCode, ulOffset, /* fScriptlet = */ TRUE, pSourceObject, dwFlags, &dwSourceContextCookie));
        if (hr)
            goto Cleanup;

        hr = THR(pHolder->_pScriptParse->AddScriptlet (
                         NULL,
                         pchCleanCode,
                         pchItemName,
                         pchSubItemName,
                         pchEventName,
                         pchDelimiter,
                         dwSourceContextCookie,
                         ulStartingLine,
                         dwFlags,
                         pbstrName,
                         &ExcepInfo));
    }

Cleanup:
    RRETURN(hr);
}

//#define COMPLUS_SCRIPTENGINES 1

#ifdef COMPLUS_SCRIPTENGINES

DeclareTag(tagComplusScriptEngines, "COMPLUS", "hook up COM+ script engines")

const CLSID CLSID_ScriptEngineHost = {0x63B38C13, 0x5D5D, 0x39AF, 0x8E, 0x24, 0xBF, 0x6B, 0xCE, 0xEF, 0x05, 0xCA};

static IDispatch * g_pdispScriptEngineHost = NULL; // TODO (alexz) (1) make this ref a member of CDoc or script collection
                                                   //              (2) release it on shutdown

//---------------------------------------------------------------------------
//
//  Function:   CorEnsureScriptEngine
//
//---------------------------------------------------------------------------

HRESULT
CorEnsureScriptEngine(CDoc * pDoc)
{
    HRESULT             hr = S_OK;
    IUnknown *          punk = NULL;
    IUnknown *          punkEngine = NULL;
    IUnknown *          punkHost = NULL;
    LPTSTR              pchInit = _T("Init");
    DISPID              dispid;
    CInvoke             invoke;

    if (g_pdispScriptEngineHost)
        goto Cleanup;

    //
    // create scriptEngineHost
    //

    hr = THR(CoCreateInstance(CLSID_ScriptEngineHost, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&punkHost));
    if (hr)
        goto Cleanup;

    hr = THR(punkHost->QueryInterface(IID_IDispatch, (void **)&g_pdispScriptEngineHost));
    if (hr)
        goto Cleanup;

    //
    // init
    //

    hr = THR(g_pdispScriptEngineHost->GetIDsOfNames(IID_NULL, &pchInit, 1, LCID_SCRIPTING, &dispid));
    if (hr)
        goto Cleanup;
    
    hr = THR(invoke.Init(g_pdispScriptEngineHost));
    if (hr)
        goto Cleanup;

    invoke.AddArg();
    V_VT(invoke.Arg(0)) = VT_UI4;
    V_UI4(invoke.Arg(0)) = (UINT) pDoc->_pOmWindow;

    hr = THR(invoke.Invoke(dispid, DISPATCH_METHOD));
    if (hr)
        goto Cleanup;

    invoke.Clear();

    //
    // cleanup
    //

Cleanup:
    ReleaseInterface(punkHost);
    ReleaseInterface(punkEngine);
    ReleaseInterface(punk);

    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Function:   CorCompileScript
//
//---------------------------------------------------------------------------

HRESULT
CorCompileScript(LPTSTR pchCode)
{
    HRESULT             hr;
    DISPID              dispid;
    LPTSTR              pchExecute = _T("execute");
    CInvoke             invoke;

    //
    // call execute
    //

    hr = THR(g_pdispScriptEngineHost->GetIDsOfNames(IID_NULL, &pchExecute, 1, LCID_SCRIPTING, &dispid));
    if (hr)
        goto Cleanup;

    hr = THR(invoke.Init(g_pdispScriptEngineHost));
    if (hr)
        goto Cleanup;

    invoke.AddArg();
    V_VT(invoke.Arg(0)) = VT_BSTR;
    hr = THR(FormsAllocString(pchCode, &V_BSTR(invoke.Arg(0))));
    if (hr)
        goto Cleanup;

    hr = THR(invoke.Invoke(dispid, DISPATCH_METHOD));
    if (hr)
        goto Cleanup;

    invoke.Clear();

    //
    // cleanup
    //

Cleanup:

    RRETURN (hr);
}
#endif

//---------------------------------------------------------------------------
//
//  Function:   CScriptCollection::ParseScriptText
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::ParseScriptText(
    LPTSTR          pchLanguage,
    CMarkup *       pScriptMarkup,  
    LPTSTR          pchType,
    LPTSTR          pchCode,
    LPTSTR          pchItemName,
    LPTSTR          pchDelimiter,
    ULONG           ulOffset,
    ULONG           ulStartingLine,
    CBase *         pSourceObject,
    DWORD           dwFlags,
    VARIANT  *      pvarResult,
    EXCEPINFO *     pexcepinfo,
    BOOL            fCommitOutOfMarkup,
    CHtmlComponent *pComponent)
{
    TraceTag((tagScriptCollection, "ParseScriptText"));

    HRESULT                 hr = S_OK;
    CScriptHolder *         pHolder;
    CMarkup *               pScriptCollectionMarkup = _pOmWindowProxy->Markup();
    DWORD_PTR               dwSourceContextCookie;
    CDebugDocumentStack     debugDocumentStack(this);

    pScriptCollectionMarkup->ProcessPeerTasks(0); // this call is important to prevent processing the queue while in the middle of
                                                  // executing inline escripts. See scenario listed past the end of this method

#if DBG == 1
    if (pScriptMarkup &&
        pScriptMarkup->HasBehaviorContext() &&
        pScriptMarkup->BehaviorContext()->_pHtmlComponent)
    {
        AssertSz (pScriptMarkup != pScriptCollectionMarkup, "an HTC appears to be using script collection on the HTC markup");
    }
#endif

#ifdef COMPLUS_SCRIPTENGINES

#if DBG==1
    if (IsTagEnabled(tagComplusScriptEngines))
#endif
    {
        hr = THR(Doc()->EnsureOmWindow());
        if (hr)
            goto Cleanup;

        Assert (Doc()->_pOmWindow);

        hr = CorEnsureScriptEngine(Doc());
        if (hr)
            goto Cleanup;

        hr = CorCompileScript(pchCode);

        goto Cleanup; // done;
    }
#endif

    if (!CMarkup::CanCommitScripts(fCommitOutOfMarkup ? NULL : pScriptMarkup))
        goto Cleanup;

    {
        CDoc::CLock     Lock(_pDoc);

        hr = THR(GetHolderForLanguage(pchLanguage, pScriptMarkup, pchType, NULL, &pHolder, NULL, pComponent));
        if (hr)
            goto Cleanup;

        Assert(pHolder->_pScriptParse);
        if(!pHolder->_pScriptParse)
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }

        hr = THR(CreateSourceContextCookie(
            pHolder->_pScript, pchCode, ulOffset, /* fScriptlet = */ FALSE,
            pSourceObject, dwFlags, &dwSourceContextCookie));
        if (hr)
            goto Cleanup;

        if (pHolder->_fClone)
        {
            hr = THR(pHolder->_pScript->SetScriptState(SCRIPTSTATE_STARTED));
        }
        else
        {
            hr = THR(pHolder->_pScriptParse->ParseScriptText(
                             STRVAL(pchCode),
                             pchItemName,
                             NULL,
                             pchDelimiter,
                             dwSourceContextCookie,
                             ulStartingLine,
                             dwFlags | (pHolder->_fOriginal ? SCRIPTTEXT_ISPERSISTENT : 0),
                             pvarResult,
                             pexcepinfo));
        }
    }


Cleanup:

    RRETURN(hr);
}

//
// (alexz)
//
// Scenario why dequeuing is necessary before doing ParseScriptText:
//
// <PROPERTY name = foo put = put_foo />
// <SCRIPT>
//    alert (0);
//    function put_foo()
//    {
//      alert (1);
//    }
// </SCRIPT>
//
//      - HTC PROPERTY element is in the queue waiting for PROPERTY behavior to be attached
//      - inline script runs, and executes "alert(0)"
//      - HTC DD is being asked for name "alert"
//      - HTC DD asks element for name "alert"
//      - element makes call to dequeue the queue
//      - HTC PROPERTY is constructed
//      - it attempts to load property from element (EnsureHtmlLoad)
//      - it successfully finds property to load, finds putter to invoke, and calls put_foo
//      - now we are trying to execute put_foo, before even inline script completed executing - which is bad
//
//

//---------------------------------------------------------------------------
//
//  Member:     CScriptCollection::CreateSourceContextCookie
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::CreateSourceContextCookie(
    IActiveScript *     pActiveScript, 
    LPTSTR              pchSource,
    ULONG               ulOffset, 
    BOOL                fScriptlet, 
    CBase *             pSourceObject,
    DWORD               dwFlags,
    DWORD_PTR *         pdwSourceContextCookie)
{
    HRESULT                 hr = S_OK;
    CScriptCookieTable *    pScriptCookieTable;

    if (!pSourceObject)
    {
        *pdwSourceContextCookie = NO_SOURCE_CONTEXT;
        goto Cleanup;
    }

    *pdwSourceContextCookie = (DWORD_PTR)pSourceObject;

#ifndef NO_SCRIPT_DEBUGGER
    if (!g_pPDM || !g_pDebugApp)
    {
        WHEN_DBG(CMarkup *pDbgMarkup=NULL;)
        Assert((S_OK == pSourceObject->PrivateQueryInterface(CLSID_CMarkup, (void **)&pDbgMarkup)) && (pSourceObject == pDbgMarkup));
        goto Cleanup;
    }

    *pdwSourceContextCookie = NO_SOURCE_CONTEXT;

    hr = THR(_pDoc->EnsureScriptCookieTable(&pScriptCookieTable));
    if (hr)
        goto Cleanup;

    //
    // if there is script debugger installed and we want to use it
    //

    hr = THR(GetScriptDebugDocument(pSourceObject, &_pCurrentDebugDocument));
    if (hr)
        goto Cleanup;

    if ((dwFlags & SCRIPTPROC_HOSTMANAGESSOURCE) && _pCurrentDebugDocument)
    {
        ULONG ulCodeLen = _tcslen(STRVAL(pchSource));

        hr = THR(_pCurrentDebugDocument->DefineScriptBlock(
            pActiveScript, ulOffset, ulCodeLen, fScriptlet, pdwSourceContextCookie));
        if (hr)
        {
            hr = S_OK;      // return S_OK and NO_SOURCE_CONTEXT
            goto Cleanup;
        }

        hr = THR(_pCurrentDebugDocument->RequestDocumentSize(ulOffset + ulCodeLen));
        if (hr)
            goto Cleanup;

        hr = THR(pScriptCookieTable->MapCookieToSourceObject(*pdwSourceContextCookie, pSourceObject));

        goto Cleanup;// done
    }
#endif // NO_SCRIPT_DEBUGGER

Cleanup:
    RRETURN (hr);
}

#ifndef NO_SCRIPT_DEBUGGER
//+---------------------------------------------------------------------------
//
//  Member:     CScriptCollection::ViewSourceInDebugger
//
//  Synopsis:   Launches the script debugger at a particular line
//
//----------------------------------------------------------------------------

HRESULT
CScriptCollection::ViewSourceInDebugger (const ULONG ulLine, const ULONG ulOffsetInLine)
{
    HRESULT                 hr = S_OK;
    CScriptDebugDocument *  pDebugDocument = NULL;
    CMarkupScriptContext *  pMarkupScriptContext = _pDoc->PrimaryMarkup()->ScriptContext();

    pDebugDocument = pMarkupScriptContext ? pMarkupScriptContext->_pScriptDebugDocument : NULL;

    if (pDebugDocument)
    {
        hr = THR(pDebugDocument->ViewSourceInDebugger(ulLine, ulOffsetInLine));
    }

    RRETURN(hr);
}
#endif // !NO_SCRIPT_DEBUGGER

//+---------------------------------------------------------------------------
//
//  Member:     CScriptCollection::ConstructCode
//
//----------------------------------------------------------------------------

HRESULT
CScriptCollection::ConstructCode(
    TCHAR *      pchScope,
    TCHAR *      pchCode,
    TCHAR *      pchFormalParams,
    TCHAR *      pchLanguage,
    CMarkup *    pMarkup,
    TCHAR *      pchType,
    ULONG        ulOffset,
    ULONG        ulStartingLine,
    CBase *      pSourceObject,
    DWORD        dwFlags,
    IDispatch ** ppDispCode,
    BOOL         fSingleLine,
    CHtmlComponent *pComponent)
{
    TraceTag((tagScriptCollection, "ConstructCode"));

    HRESULT                 hr = S_OK;
    CScriptHolder *         pHolder;
    DWORD_PTR               dwSourceContextCookie;
    TCHAR *                 pchCleanSource;
    CStr                    cstrNamespace;
    CDebugDocumentStack     debugDocumentStack(this);

    dwFlags |= SCRIPTPROC_IMPLICIT_THIS | SCRIPTPROC_IMPLICIT_PARENTS | SCRIPTPROC_HOSTMANAGESSOURCE;

    if (!ppDispCode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    ClearInterface(ppDispCode);

    if (!pchCode)
        goto Cleanup;

    if (fSingleLine)
    {
        hr = THR (GetHolderForLanguage (pchLanguage, pMarkup, pchType, pchCode, &pHolder, &pchCleanSource, pComponent, &cstrNamespace));
        if (hr)
            goto Cleanup;
    }
    else
    {
        pchCleanSource = pchCode;

        if (!pchCleanSource || !*pchCleanSource)
            goto Cleanup;

        hr = THR (GetHolderForLanguage (pchLanguage, pMarkup, pchType, NULL, &pHolder, NULL, pComponent, &cstrNamespace));
        if (hr)
            goto Cleanup;
    }

    Assert (pchCleanSource);

    if (!pHolder->_pParseProcedure)
    {
        hr = E_NOTIMPL;
        goto Cleanup;
    }

    hr = THR(CreateSourceContextCookie(
        pHolder->_pScript, pchCleanSource, ulOffset, /* fScriptlet = */ TRUE,
        pSourceObject, dwFlags, &dwSourceContextCookie));
    if (hr)
        goto Cleanup;

    hr = THR(pHolder->_pParseProcedure->ParseProcedureText(
        pchCleanSource,
        pchFormalParams,
        _T("\0"),                                   // procedure name
        cstrNamespace ? cstrNamespace : pchScope,   // item name
        NULL,                                       // pUnkContext
        fSingleLine ? _T("\"") : _T("</SCRIPT>"),   // delimiter
        dwSourceContextCookie,                      // source context cookie
        ulStartingLine,                             // starting line number
        dwFlags,
        ppDispCode));

Cleanup:
    RRETURN (hr);
}


#ifndef NO_SCRIPT_DEBUGGER

//+---------------------------------------------------------------------------
//
//  Function:     InitScriptDebugging
//
//----------------------------------------------------------------------------

// don't hold the global lock because InitScriptDebugging makes RPC calls (bug 26308)
static CGlobalCriticalSection g_csInitScriptDebugger;

HRESULT 
InitScriptDebugging()
{
   TraceTag((tagScriptCollection, "InitScriptDebugging"));
    if (g_fScriptDebuggerInitFailed || g_pDebugApp)
        return S_OK;

    HRESULT hr = S_OK;
    HKEY hkeyProcessDebugManager = NULL;
    LPOLESTR pszClsid = NULL;
    TCHAR *pchAppName = NULL;
    LONG lResult;
    TCHAR pchKeyName[MAX_PROGID_LENGTH+8];   // only needs to be MAX_PROGID_LENGTH+6, but let's be paranoid

    g_csInitScriptDebugger.Enter();

    // Need to check again after locking the globals.
    if (g_fScriptDebuggerInitFailed || g_pDebugApp)
        goto Cleanup;

    //
    // Check to see if the ProcessDebugManager is registered before
    // trying to CoCreate it, as CoCreating can be expensive.
    //
    hr = THR(StringFromCLSID(CLSID_ProcessDebugManager, &pszClsid));
    if (hr)
        goto Cleanup;

    hr = THR(Format(0, &pchKeyName, MAX_PROGID_LENGTH+8, _T("CLSID\\<0s>"), pszClsid));
    if (hr)
        goto Cleanup;

    lResult = RegOpenKeyEx(HKEY_CLASSES_ROOT, pchKeyName, 0, KEY_READ, &hkeyProcessDebugManager);
    if (lResult != ERROR_SUCCESS)
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

    hr = THR_NOTRACE(CoCreateInstance(
            CLSID_ProcessDebugManager,
            NULL,
            CLSCTX_ALL,
            IID_IProcessDebugManager,
            (void **)&g_pPDM));
    if (hr)
        goto Cleanup;

    hr = THR(g_pPDM->CreateApplication(&g_pDebugApp));
    if (hr)
        goto Cleanup;

    hr = THR(Format(FMT_OUT_ALLOC, &pchAppName, 0, MAKEINTRESOURCE(IDS_MESSAGE_BOX_TITLE)));
    if (hr)
        goto Cleanup;

    hr = THR(g_pDebugApp->SetName(pchAppName));
    if (hr)
        goto Cleanup;

    // This will fail if there is no MDM on the machine. That is OK.
    THR_NOTRACE(g_pPDM->AddApplication(g_pDebugApp, &g_dwAppCookie));

Cleanup:
    CoTaskMemFree(pszClsid);
    delete pchAppName;

    if (hkeyProcessDebugManager)
        RegCloseKey(hkeyProcessDebugManager);

    if (hr)
    {
        g_fScriptDebuggerInitFailed = TRUE;
        DeinitScriptDebugging();
    }

    g_csInitScriptDebugger.Leave();
    
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:     DeinitScriptDebugging
//
//----------------------------------------------------------------------------

void 
DeinitScriptDebugging()
{
    TraceTag((tagScriptCollection, "DeinitScriptDebugging"));

    g_csInitScriptDebugger.Enter();

    if (g_pPDM)
        g_pPDM->RemoveApplication( g_dwAppCookie );

    if (g_pDebugApp)
        g_pDebugApp->Close();

    ClearInterface(&g_pPDM);
    ClearInterface(&g_pDebugApp);

    g_csInitScriptDebugger.Leave();
}

#endif // NO_SCRIPT_DEBUGGER

//---------------------------------------------------------------------------
//
//  Member:   CNamedItemsTable::AddItem
//
//---------------------------------------------------------------------------

HRESULT
CNamedItemsTable::AddItem(LPTSTR pchName, IUnknown * pUnkItem)
{
    HRESULT         hr;
    CNamedItem *    pItem;

    pItem = new CNamedItem(pchName, pUnkItem);
    if (!pItem)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(Append(pItem));

Cleanup:
    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Member:   CNamedItemsTable::GetItem
//
//---------------------------------------------------------------------------

HRESULT
CNamedItemsTable::GetItem(LPTSTR pchName, IUnknown ** ppUnkItem)
{
    int             c;
    CNamedItem **   ppItem;

    // ( TODO perf(alexz) this search actually shows up on perf numbers, by
    // introducing quadratic behavior (on pages with lots of HTCs).
    // It should be optimized to do access by hashing. )

    for (c = Size(), ppItem = (CNamedItem**)PData(); c; c--, ppItem++)
    {
        if (0 == StrCmpIC(pchName, (*ppItem)->_cstrName))
        {
            *ppUnkItem = (*ppItem)->_pUnkItem;
            (*ppUnkItem)->AddRef();
            RRETURN (S_OK);
        }
    }
    RRETURN (DISP_E_MEMBERNOTFOUND);
}

//---------------------------------------------------------------------------
//
//  Member:   CNamedItemsTable::FreeAll
//
//---------------------------------------------------------------------------

HRESULT
CNamedItemsTable::FreeAll()
{
    int             c;
    CNamedItem **   ppItem;

    for (c = Size(), ppItem = (CNamedItem**)PData(); c; c--, ppItem++)
    {
        delete (*ppItem);
    }
    super::DeleteAll();

    RRETURN (S_OK);
}

//---------------------------------------------------------------------------
//
//  Member:   CScriptMethodsTable::FreeAll
//
//---------------------------------------------------------------------------

CScriptMethodsTable::~CScriptMethodsTable()
{
    int             c;
    SCRIPTMETHOD *  pScriptMethod;

    for (c = Size(), pScriptMethod = (SCRIPTMETHOD*)PData();
         c > 0;
         c--, pScriptMethod++)
    {
        pScriptMethod->cstrName.Free();
    }
    DeleteAll();
}

//---------------------------------------------------------------------------
//
//  Member:   CScriptCollection::GetDispID
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::GetDispID(
    CScriptContext *        pScriptContext,
    BSTR                    bstrName,
    DWORD                   grfdex,
    DISPID *                pdispid)
{
    HRESULT                 hr;
    HRESULT                 hr2;
    LPTSTR                  pchNamespace;
    CScriptMethodsTable *   pScriptMethodsTable;
    int                     i, c;
    STRINGCOMPAREFN         pfnStrCmp;
    CScriptHolder **        ppHolder;
    SCRIPTMETHOD            scriptMethod;
    SCRIPTMETHOD *          pScriptMethod;
    IDispatch *             pdispEngine = NULL;
    IDispatchEx *           pdexEngine  = NULL;
    int                     idx;
    DISPID                  dispidEngine;

    //
    // startup
    //

    grfdex &= (~fdexNameEnsure);    // don't allow name to be ensured here
    pfnStrCmp = (grfdex & fdexNameCaseSensitive) ? StrCmpC : StrCmpIC;

    Assert(pScriptContext);

    pchNamespace        =  pScriptContext->GetNamespace();
    pScriptMethodsTable = &pScriptContext->_ScriptMethodsTable;

    //
    // try existing cached names
    //

    for (i = 0, c = pScriptMethodsTable->Size(); i < c; i++)
    {
        if (0 == pfnStrCmp((*pScriptMethodsTable)[i].cstrName, bstrName))
        {
            *pdispid = DISPID_OMWINDOWMETHODS + i;
            hr = S_OK;
            goto Cleanup;
        }
    }

    //
    // query all the engines for the name
    //

    hr = DISP_E_UNKNOWNNAME;

    if (pScriptContext->_fClonedScript)
    {
        Assert(pScriptContext->_idxDefaultScriptHolder != -1);
        c = 1;
        ppHolder = &_aryCloneHolder[pScriptContext->_idxDefaultScriptHolder];
        Assert(ppHolder && *ppHolder);
        if (!ppHolder || !(*ppHolder))
            c = 0;
    }
    else
    {
        c = _aryHolder.Size();
        ppHolder = _aryHolder;
    }

    for (; c > 0; c--, ppHolder++)
    {
        Assert (!pdispEngine && !pdexEngine);

        // get IDispatch and IDispatchEx

        if (!(*ppHolder)->_pScript)
            continue;

        hr2 = THR((*ppHolder)->_pScript->GetScriptDispatch(pchNamespace, &pdispEngine));
        if (hr2)
            continue;

        _fInEnginesGetDispID = TRUE;

        if (0 == (grfdex & fdexFromGetIdsOfNames))
        {
            IGNORE_HR(pdispEngine->QueryInterface(IID_IDispatchEx, (void **)&pdexEngine));
        }

        // query for the name

        if (pdexEngine)
        {
            hr2 = THR_NOTRACE(pdexEngine->GetDispID(bstrName, grfdex, &dispidEngine));
        }
        else
        {
            hr2 = THR_NOTRACE(pdispEngine->GetIDsOfNames(IID_NULL, &bstrName, 1, LCID_SCRIPTING, &dispidEngine));
        }

        _fInEnginesGetDispID = FALSE;

        if (S_OK != hr2)        // if name is unknown to this engine
            goto LoopCleanup;   // this is not a fatal error; goto loop cleanup and then continue

        // name is known; assign it our own dispid, and append all the info to our list for remapping

        hr = THR(pScriptMethodsTable->AppendIndirect(&scriptMethod));
        if (hr)
            goto Cleanup;

        idx = pScriptMethodsTable->Size() - 1;
        *pdispid = DISPID_OMWINDOWMETHODS + idx;

        pScriptMethod = &((*pScriptMethodsTable)[idx]);
        pScriptMethod->dispid  = dispidEngine;
        pScriptMethod->pHolder = *ppHolder;
        hr = THR(pScriptMethod->cstrName.Set(bstrName));
        if (hr)
            goto Cleanup;

        // loop cleanup

LoopCleanup:
        ClearInterface(&pdispEngine);
        ClearInterface(&pdexEngine);
    }

Cleanup:
    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Member:   CScriptCollection::InvokeEx
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::InvokeEx(
    CScriptContext *        pScriptContext,
    DISPID                  dispid,
    LCID                    lcid,
    WORD                    wFlags,
    DISPPARAMS *            pDispParams,
    VARIANT *               pvarRes,
    EXCEPINFO *             pExcepInfo,
    IServiceProvider *      pServiceProvider)
{
    HRESULT                 hr;
    HRESULT                 hr2;
    LPTSTR                  pchNamespace;
    CScriptMethodsTable *   pScriptMethodsTable;
    IDispatch *             pdispEngine = NULL;
    IDispatchEx *           pdexEngine  = NULL;
    SCRIPTMETHOD *          pScriptMethod;
    int                     idx = dispid - DISPID_OMWINDOWMETHODS;

    //
    // startup
    //

    Assert (pScriptContext);

    AddRef();

    pchNamespace        =  pScriptContext->GetNamespace();
    pScriptMethodsTable = &pScriptContext->_ScriptMethodsTable;

    if (idx < 0 || pScriptMethodsTable->Size() <= idx)
    {
        hr = DISP_E_MEMBERNOTFOUND;
        goto Cleanup;
    }

    //
    // invoke
    //

    pScriptMethod = &((*pScriptMethodsTable)[idx]);

    hr = THR(pScriptMethod->pHolder->_pScript->GetScriptDispatch(pchNamespace, &pdispEngine));
    if (hr)
        goto Cleanup;

    hr2 = THR_NOTRACE(pdispEngine->QueryInterface(IID_IDispatchEx, (void**)&pdexEngine));

    if (pdexEngine)
    {
        hr = THR(pdexEngine->InvokeEx(
                pScriptMethod->dispid, lcid, wFlags, pDispParams,pvarRes, pExcepInfo, pServiceProvider));

        ReleaseInterface(pdexEngine);
    }
    else
    {
        hr = THR(pdispEngine->Invoke(
                pScriptMethod->dispid, IID_NULL, lcid, wFlags, pDispParams, pvarRes, pExcepInfo, NULL));
    }

Cleanup:
    ReleaseInterface (pdispEngine);
    Release();
    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Member:   CScriptCollection::InvokeName
//
//---------------------------------------------------------------------------

HRESULT
CScriptCollection::InvokeName(
    CScriptContext *        pScriptContext,
    LPTSTR                  pchName,
    LCID                    lcid,
    WORD                    wFlags,
    DISPPARAMS *            pDispParams,
    VARIANT *               pvarRes,
    EXCEPINFO *             pExcepInfo,
    IServiceProvider *      pServiceProvider)
{
    HRESULT             hr = S_OK;
    HRESULT             hr2;
    CScriptHolder **    ppHolder = NULL;
    IDispatch *         pdispEngine = NULL;
    IDispatchEx *       pdexEngine  = NULL;
    BSTR                bstrName = NULL;
    DISPID              dispid;
    int                 c;

    Assert (pScriptContext);

    //
    // startup
    //

    if (pScriptContext->_fClonedScript)
    {
        if (pScriptContext->_idxDefaultScriptHolder == -1)
        {
            c = 0;
        }
        else
        {
            c = 1;
            ppHolder = &_aryCloneHolder[pScriptContext->_idxDefaultScriptHolder];
            Assert(ppHolder && *ppHolder);
            if (!ppHolder || !(*ppHolder))
                c = 0;
        }
    }
    else
    {
        c = _aryHolder.Size();
        ppHolder = _aryHolder;
    }

    if (0 == c)
    {
        hr = DISP_E_UNKNOWNNAME;
        goto Cleanup;
    }

    hr = THR(FormsAllocString (pchName, &bstrName));
    if (hr)
        goto Cleanup;

    //
    // find an engine that knows the name and invoke it
    //

    hr = DISP_E_UNKNOWNNAME;
    for (; c > 0; c--, ppHolder++)
    {
        // get IDispatch / IDispatchEx

        hr2 = THR((*ppHolder)->_pScript->GetScriptDispatch(pScriptContext->GetNamespace(), &pdispEngine));
        if (hr2)
            continue;

        hr2 = THR_NOTRACE(pdispEngine->QueryInterface(IID_IDispatchEx, (void **)&pdexEngine));
        if (S_OK == hr2)
        {
            // invoke via IDispatchEx

            hr2 = THR_NOTRACE(pdexEngine->GetDispID(bstrName, fdexNameCaseInsensitive, &dispid));
            if (S_OK == hr2)
            {
                hr = THR(pdexEngine->InvokeEx(
                    dispid, lcid, wFlags, pDispParams, pvarRes, pExcepInfo, pServiceProvider));

                goto Cleanup; // done
            }
            ClearInterface(&pdexEngine);
        }
        else
        {
            // invoke via IDispatch

            hr2 = THR_NOTRACE(pdispEngine->GetIDsOfNames(IID_NULL, &pchName, 1, lcid, &dispid));
            if (S_OK == hr2)
            {
                hr = THR(pdispEngine->Invoke(
                    dispid, IID_NULL, lcid, wFlags, pDispParams, pvarRes, pExcepInfo, NULL));

                goto Cleanup; // done
            }
        }

        // loop cleanup

        ClearInterface(&pdispEngine);
    }

Cleanup:

    ReleaseInterface(pdispEngine);
    ReleaseInterface(pdexEngine);

    FormsFreeString(bstrName);

    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\rtftohtm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       rtftohtm.cxx
//
//  Contents:   CRtfToHtmlConverter
//
//----------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_RTFTOHTM_HXX_
#define X_RTFTOHTM_HXX_
#include "rtftohtm.hxx"
#endif

MtDefine(CRtfToHtmlConverter, Locals, "CRtfToHtmlConverter")
MtDefine(CRtfToHtmlConverter_pchModuleName, CRtfToHtmlConverter, "CRtfToHtmlConverter::_pchModuleName")

// TODO (johnv) Taken from convapi.h which is not part of our project
// Tells RTF converter to not show any UI.
#define fRegAppPreview      4

#ifdef WIN16
#define CharToOem(x, y)
#endif
 
struct RTF_CONVERTER
{
    void *  pOut;
    HANDLE  hTransferBuffer;
    HRESULT hr;
}
g_RtfConverter;

CRITICAL_SECTION CRtfToHtmlConverter::_cs;
BOOL             CRtfToHtmlConverter::_fCSInited = FALSE;

//+---------------------------------------------------------------------------
//
//  Function:   AcceptRtfForExternalWrite
//
//  Synopsis:   Accepts chunks of RTF from the Word RTF to HTML converter.
//              Writes them to disk in a file opened by
//              CRtfToHtmlConverter::InternalHtmlToExternalRtf().
//
//----------------------------------------------------------------------------
SHORT PASCAL
AcceptRtfForExternalWrite(LONG cch, INT nPercentComplete)
{
    BOOL    fWriteOpSuccess;
    LONG    lSetFpRetVal;
    HANDLE  hFile;
    char *  pchTransferBuffer;
    DWORD   dwBytesWritten;

    Assert(g_RtfConverter.pOut);
    Assert(cch <= (LONG) GlobalSize(g_RtfConverter.hTransferBuffer));

    if (cch >0)
    {
        hFile = (HANDLE) g_RtfConverter.pOut;

        lSetFpRetVal = SetFilePointer(hFile, 0, NULL, FILE_END);
        if (lSetFpRetVal == -1)
            return -1;

        pchTransferBuffer = (char *) GlobalLock(g_RtfConverter.hTransferBuffer);
        if (!pchTransferBuffer)
            return -1;
        fWriteOpSuccess = WriteFile(
                hFile,
                pchTransferBuffer,
                cch,
                &dwBytesWritten,
                NULL);
        GlobalUnlock(g_RtfConverter.hTransferBuffer);

        if (!fWriteOpSuccess)
            return -1;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   FeedExternalRtfToConverter
//
//  Synopsis:   Sends chunks of HTML to the Word RTF to HTML converter.  Reads
//              from the file opened by
//              CRtfToHtmlConverter::ExternalRtfToInternalHtml().
//
//----------------------------------------------------------------------------
SHORT PASCAL
FeedExternalRtfToConverter(BOOL * afFlags /* array of size 16 */, INT nZero)
{
    BOOL    fReadOpSuccess;
    DWORD   dwBytesRead;
    HANDLE  hFile;
    char *  pchTransferBuffer;

    Assert(g_RtfConverter.pOut);

    hFile = (HANDLE) g_RtfConverter.pOut;

    pchTransferBuffer = (char *) GlobalLock(g_RtfConverter.hTransferBuffer);
    if (!pchTransferBuffer)
        return -1;
    fReadOpSuccess = ReadFile(
            hFile,
            pchTransferBuffer,
            (DWORD) GlobalSize(g_RtfConverter.hTransferBuffer),
            &dwBytesRead,
            NULL);
    GlobalUnlock(g_RtfConverter.hTransferBuffer);

    if (fReadOpSuccess)
        return dwBytesRead; // 0 indicates completion
    else
        return -1;
}

//+---------------------------------------------------------------------------
//
//  Function:   AcceptRtfForStreamWrite
//
//  Synopsis:   Accepts chunks of RTF from the Word RTF to HTML converter.
//              Writes them to disk in a file opened by
//              CRtfToHtmlConverter::InternalHtmlToExternalRtf().
//
//----------------------------------------------------------------------------
SHORT PASCAL
AcceptRtfForStreamWrite(LONG cch, INT nPercentComplete)
{
    HRESULT     hr;
    IStream *   pstm;
    char *      pchTransferBuffer;

    Assert(g_RtfConverter.pOut);
    Assert(cch <= (LONG) GlobalSize(g_RtfConverter.hTransferBuffer));

    if (cch > 0)
    {
        pstm = (IStream *) g_RtfConverter.pOut;

        pchTransferBuffer = (char *) GlobalLock(g_RtfConverter.hTransferBuffer);
        if (!pchTransferBuffer)
        {
            hr = E_FAIL;
            goto Error;
        }
        hr = THR(pstm->Write(pchTransferBuffer, cch, NULL));
        if (hr)
            goto Error;
        GlobalUnlock(g_RtfConverter.hTransferBuffer);

        g_RtfConverter.hr = hr;
        if (hr)
            goto Error;
    }

    return 0;

Error:
    g_RtfConverter.hr = hr;
    return -1;
}



//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::Create
//  Factory method
//----------------------------------------------------------------------------
HRESULT 
CRtfToHtmlConverter::Create(CRtfToHtmlConverter  **ppConverter, CDoc *pDoc)
{
    HRESULT   hr = S_OK;
    HKEY    hkey = NULL;
    DWORD   dwLength;
    TCHAR   achConverterPath[MAX_PATH];
    static const TCHAR* s_szImportPath = _T("Software\\Microsoft\\Shared Tools\\Text Converters\\Import\\HTML");
    static const TCHAR* s_szExportPath = _T("Software\\Microsoft\\Shared Tools\\Text Converters\\Export\\HTML");

    Assert( ppConverter );
    *ppConverter = new CRtfToHtmlConverter(pDoc);
    if (!*ppConverter)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    (*ppConverter)->_hTransferBuffer = GlobalAlloc(GMEM_MOVEABLE, 2048);
    (*ppConverter)->_pchModuleName = new(Mt(CRtfToHtmlConverter_pchModuleName)) char[7+1];
    if( !(*ppConverter)->_hTransferBuffer || !(*ppConverter)->_pchModuleName )
    {
        // should have used GetLastError for the GlobalAlloc failure
        // simplify it for now
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    strcpy((*ppConverter)->_pchModuleName, "HTMLPAD") ;

    
    // Try to load it from the path.
#ifdef _WIN64
    (*ppConverter)->_hConverter = LoadLibraryEx(_T("html64.iec"), NULL, 0);
#else
    (*ppConverter)->_hConverter = LoadLibraryEx(_T("html32.cnv"), NULL, 0);
#endif

    // Can't find the converter in the path, check the registry.
    if (!(*ppConverter)->_hConverter)
    {
        // Try the import and export file paths as specified in the registry
        if ( RegOpenKey( HKEY_LOCAL_MACHINE, s_szImportPath, &hkey ) == ERROR_SUCCESS ||
             RegOpenKey( HKEY_LOCAL_MACHINE, s_szExportPath, &hkey ) == ERROR_SUCCESS )
        {

            dwLength = sizeof(TCHAR) * MAX_PATH;
            if (ERROR_SUCCESS == RegQueryValueEx(
                        hkey,
                        _T("Path"),
                        NULL,
                        NULL,
                        (BYTE *) achConverterPath,
                        &dwLength))
            {
                (*ppConverter)->_hConverter = LoadLibraryEx(achConverterPath, NULL, 0);
            }

            RegCloseKey (hkey);
        }
    }

    if ((*ppConverter)->_hConverter)
    {
        long (WINAPI * pfnInitConverter)(HWND, char *);
        HGLOBAL (WINAPI * pfnRegisterApp)(long, void *);
        
        pfnInitConverter = (long (WINAPI *)(HWND, char *)) GetProcAddress(
                (*ppConverter)->_hConverter,
                "InitConverter32");

        pfnRegisterApp = (HGLOBAL (WINAPI *)(long, void *)) GetProcAddress(
                (*ppConverter)->_hConverter,
                "RegisterApp");

        (*ppConverter)->_pfnIsFormatCorrect = (short (WINAPI *)(HANDLE, HANDLE)) GetProcAddress(
                (*ppConverter)->_hConverter,
                "IsFormatCorrect32");
        (*ppConverter)->_pfnHtmlToRtf = (short (WINAPI *)(
                    HANDLE,
                    IStorage *,
                    HANDLE,
                    HANDLE,
                    HANDLE,
                    short (FAR PASCAL *)(LONG, INT))) GetProcAddress(
                (*ppConverter)->_hConverter,
                "ForeignToRtf32");
        (*ppConverter)->_pfnRtfToHtml = (short (WINAPI *)(
                    HANDLE,
                    IStorage *,
                    HANDLE,
                    HANDLE,
                    short (FAR PASCAL *)(BOOL *, INT))) GetProcAddress(
                (*ppConverter)->_hConverter,
                "RtfToForeign32");

        //
        // The RTF convert is not multi-threaded, so syncronize access
        //
        //
        g_RtfConverter.hTransferBuffer = (*ppConverter)->_hTransferBuffer;

        if (pfnInitConverter
            && (*ppConverter)->_pfnIsFormatCorrect
            && (*ppConverter)->_pfnHtmlToRtf
            && (*ppConverter)->_pfnRtfToHtml
            && (*ppConverter)->_hTransferBuffer)
        {
            (*ppConverter)->_fInitSuccessful = (BOOL) (*pfnInitConverter)(
                    GetForegroundWindow(),
                    (*ppConverter)->_pchModuleName);

            if (pfnRegisterApp)
            {
                // Disable any UI from the converter
                HGLOBAL hGlobal = pfnRegisterApp(fRegAppPreview, NULL);
                
                if (hGlobal)
                {
                    // We do not care about the converter's prefs
                    GlobalFree(hGlobal);
                }
            }
        }
    }
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::CRtfToHtmlConverter
//
//----------------------------------------------------------------------------
CRtfToHtmlConverter::CRtfToHtmlConverter(CDoc * pDoc)
{
    memset(this, 0, sizeof(*this));
    _pDoc = pDoc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::~CRtfToHtmlConverter
//
//----------------------------------------------------------------------------
CRtfToHtmlConverter::~CRtfToHtmlConverter(void)
{
    if (_hConverter)
    {
        FreeLibrary(_hConverter);
    }

    if (_hExternalFile)
    {
        CloseHandle(_hExternalFile);
    }

    if (_hTransferBuffer)
    {
        GlobalFree(_hTransferBuffer);
    }
    
    delete _pchModuleName;
 }

//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::InternalHtmlToExternalRtf
//
//  Synopsis:   Uses the Word RTF to HTML converter to convert HTML
//              to RTF, writing it into a file on disk. If _pDoc is not
//              NULL, it is used as the source of HTML. Otheriwse,
//              pszHtmlPath is assumed to be the name of the HTML source
//              file.
//
//  Arguments:  pszRtfPath  Specifies the name the file in which the RTF is
//                       to be saved.
//              pszHtmlPath Ignored if _pDoc is not NULL. Otherwise, it
//                          specifies the name of the HTML source file.
//  Returns:    TRUE if the conversion was successful, FALSE if it was not.
//
//----------------------------------------------------------------------------
HRESULT
CRtfToHtmlConverter::InternalHtmlToExternalRtf(LPCTSTR pszRtfPath,
                                               LPCTSTR pszHtmlPath)
{
    HRESULT hr = S_OK;
    HANDLE  hPath = 0;
    TCHAR   achTmpPath[MAX_PATH];
    TCHAR   achTmpFile[MAX_PATH];  
    char *  pchPath;
    INT     i;

    if (!_fInitSuccessful)
        goto Error;

    if (!pszRtfPath || !pszRtfPath[0] || (_tcslen(pszRtfPath) <= 4))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    Assert((!StrCmpIC(_T(".rtf"), pszRtfPath+_tcslen(pszRtfPath)-4))
        || (!StrCmpIC(_T(".tmp"), pszRtfPath+_tcslen(pszRtfPath)-4)));

    if (!_pDoc)
    {
        if (!pszHtmlPath || !pszHtmlPath[0] || (_tcslen(pszHtmlPath) <= 4))
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        Assert((!StrCmpIC(_T(".htm"), pszHtmlPath+_tcslen(pszHtmlPath)-4))
            || (!StrCmpIC(_T(".tmp"), pszHtmlPath+_tcslen(pszHtmlPath)-4)));
        _tcsncpy(achTmpFile, pszHtmlPath, MAX_PATH);
        achTmpFile[MAX_PATH-1] = _T('\0');
    }
    else
    {
        GetTempPath(MAX_PATH, achTmpPath);
        GetTempFileName(achTmpPath, _T("h2r"), 0, achTmpFile);
        
        for (i = 0; achTmpFile[i] != _T('.') && achTmpFile[i]; ++i)
            ;   // empty loop
        Assert(achTmpFile[i] == _T('.'));
        _tcscpy(achTmpFile+i+1, _T("htm"));
        hr = THR(_pDoc->Save(achTmpFile, FALSE));
        if (hr)
            goto Cleanup;
    }

    _hExternalFile = CreateFile(
            pszRtfPath,
            GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (_hExternalFile == INVALID_HANDLE_VALUE)
        goto Error;

    hPath = GlobalAlloc(GMEM_MOVEABLE, sizeof(char) * MAX_PATH);

    if (!hPath)
        goto Error;


    pchPath = (char *) GlobalLock(hPath);
    if (!pchPath)
        goto Error;
    CharToOem(achTmpFile, pchPath);
    GlobalUnlock(hPath);

    g_RtfConverter.pOut = (void *) _hExternalFile;

    // IEV6-26193
    // Per smueller, this call is indeed redundant for both
    // 32-bit and 64-bit. _pfnHtmlToRtf will call this function
    // internally.  This call caused reentrancy into the 
    // converter DLL.
    // [zhenbinx]
    // if ((*_pfnIsFormatCorrect)(hPath, hBuffer) == 1)
    {
        BOOL    fRet;

        fRet = (*_pfnHtmlToRtf)(
                hPath,
                NULL,
                _hTransferBuffer,
                NULL,
                NULL,
                AcceptRtfForExternalWrite);

        if (fRet)
            goto Error;
    }

Cleanup:
    
    if (_hExternalFile)
    {    CloseHandle(_hExternalFile);
        _hExternalFile = NULL;
    }
    if (hPath)
        GlobalFree(hPath);
    RRETURN(hr);

Error:
    hr = E_FAIL;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::ExternalRtfToInternalHtml
//
//  Synopsis:   Uses the Word RTF to HTML converter to convert external RTF
//              to HTML, loading it from a file on disk.
//
//  Arguments:  pszPath specifies the filename of the file to load. If _pDoc
//              is NULL,this returns the name of the file that contains HTML.
//
//  Returns:    TRUE if the conversion was successful, FALSE if it was not.
//
//----------------------------------------------------------------------------
HRESULT
CRtfToHtmlConverter::ExternalRtfToInternalHtml(TCHAR * pszPath)
{
    HRESULT hr = S_OK;
    HANDLE  hPath = 0;
    TCHAR   achTmpPath[MAX_PATH];
    TCHAR   achTmpFile[MAX_PATH];  
    char *  pchPath;
    INT     i;
    BOOL    fRet;


    if (!pszPath || !pszPath[0] || (_tcslen(pszPath) <= 4))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    Assert((!StrCmpIC(_T(".rtf"), pszPath+_tcslen(pszPath)-4))
        || (!StrCmpIC(_T(".tmp"), pszPath+_tcslen(pszPath)-4)));

    // We do not Assert(_pDoc) because if _pDoc is NULL this function will return the path of the 
    // HTML file created.

    if (!_fInitSuccessful)
        goto Error;

    hPath = GlobalAlloc(GMEM_MOVEABLE, sizeof(char) * MAX_PATH);

    if (!hPath)
        goto Error;

    _hExternalFile = CreateFile(
            pszPath,
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

    if (_hExternalFile == INVALID_HANDLE_VALUE)
        goto Error;

    GetTempPath(MAX_PATH, achTmpPath);
    GetTempFileName(achTmpPath, _T("h2r"), 0, achTmpFile);
    
    for (i = 0; achTmpFile[i] != _T('.') && achTmpFile[i]; ++i)
        ;   // empty loop
    Assert(achTmpFile[i] == _T('.'));
    _tcscpy(achTmpFile+i+1, _T("htm"));

    pchPath = (char *) GlobalLock(hPath);
    if (!pchPath)
        goto Error;
    CharToOem(achTmpFile, pchPath);
    GlobalUnlock(hPath);

    g_RtfConverter.pOut= (void *) _hExternalFile;

    fRet = (*_pfnRtfToHtml)(
            hPath,
            NULL,
            _hTransferBuffer,
            NULL,
            FeedExternalRtfToConverter);

    
    if (fRet)
        goto Error;

    // This function will return the name and location of the new file if _pDoc is NULL,
    // otherwise it will call pDoc's load function.

    if(_pDoc)
    { 
        hr = THR(_pDoc->Load(achTmpFile,0));
        if (hr)
           goto Cleanup;
    }
    else
        _tcscpy(pszPath, achTmpFile);

Cleanup:

    if (hPath)
        GlobalFree(hPath);
    RRETURN(hr);

Error:
    hr = E_FAIL;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::InternalHtmlToStreamRtf
//
//  Synopsis:   Uses the Word RTF to HTML converter to convert internal HTML
//              to RTF, writing it into the specified stream.
//
//  Arguments:  pstm   the stream into which the RTF should be written
//
//----------------------------------------------------------------------------
HRESULT
CRtfToHtmlConverter::InternalHtmlToStreamRtf(IStream * pstm)
{
    HRESULT hr;
    HANDLE  hPath = 0;
    TCHAR   achTmpPath[MAX_PATH];
    TCHAR   achTmpFile[MAX_PATH];
    char *  pchPath;
    INT     i;

    Assert(pstm);
    Assert(_pDoc);

    if (!_fInitSuccessful)
        goto Error;

    hPath = GlobalAlloc(0, sizeof(char) * MAX_PATH);

    if (!hPath)
        goto Error;

    GetTempPath(MAX_PATH, achTmpPath);
    GetTempFileName(achTmpPath, _T("h2r"), 0, achTmpFile);
    
    for (i = 0; achTmpFile[i] != _T('.') && achTmpFile[i]; ++i)
        ;   // empty loop
    Assert(achTmpFile[i] == _T('.'));
    _tcscpy(achTmpFile+i+1, _T("htm"));

    hr = THR(_pDoc->Save(achTmpFile, FALSE));
    if (hr)
        goto Cleanup;

    pchPath = (char *) GlobalLock(hPath);
    if (!pchPath)
        goto Error;
    CharToOem(achTmpFile, pchPath);
    GlobalUnlock(hPath);

    g_RtfConverter.hr = E_FAIL;
    g_RtfConverter.pOut= (void *) pstm;
    
    // IEV6-26193
    // Per smueller, this call is indeed redundant for both
    // 32-bit and 64-bit. _pfnHtmlToRtf will call this function
    // internally.  This call caused reentrancy into the 
    // converter DLL.
    // [zhenbinx]
    // if ((*_pfnIsFormatCorrect)(hPath, hBuffer) == 1)
    {
        BOOL    fRet;

        fRet = (*_pfnHtmlToRtf)(
                hPath,
                NULL,
                _hTransferBuffer,
                NULL,
                NULL,
                AcceptRtfForStreamWrite);

        hr = g_RtfConverter.hr;

        if (hr)
            goto Cleanup;
        if (fRet)
            goto Error;
    }

Cleanup:

    if (hPath)
        GlobalFree(hPath);
    RRETURN1(hr, S_FALSE);

Error:
    hr = E_FAIL;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::StringHtmlToStringRtf
//
//  Synopsis:   Uses the Word HTML to RTF converter to convert a string of HTML
//              to a string of RTF.
//
//----------------------------------------------------------------------------
HRESULT
CRtfToHtmlConverter::StringHtmlToStringRtf(LPSTR pszHtml, HGLOBAL *phglobalRtf)
{
    HRESULT  hr = S_OK;
    HANDLE   hfileRTF, hfileHTM;
    TCHAR    achTmpPath[MAX_PATH];
    TCHAR    achHtmlFile[MAX_PATH];
    TCHAR    achRtfFile[MAX_PATH];
    DWORD    nBytesToRead, nBytesRead, nBytesWritten = 0;
    BOOL     fRet;
    char *   szTemp = NULL; 

    GetTempPath(MAX_PATH, achTmpPath);
    GetTempFileName(achTmpPath, _T("h2r"), 0, achHtmlFile);

    GetTempFileName(achTmpPath, _T("h2r"), 0, achRtfFile);
 
    hfileHTM = CreateFile(
                achHtmlFile,
                GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
    

    if (hfileHTM == INVALID_HANDLE_VALUE)
        goto Error;

    fRet = WriteFile(
            hfileHTM,
            pszHtml,
            strlen(pszHtml),
            &nBytesWritten,
            NULL);

    CloseHandle(hfileHTM);

    if(fRet == FALSE)
        goto Error;

    hr = THR(InternalHtmlToExternalRtf(achRtfFile, achHtmlFile));

    if(hr)
        goto Error;

    hfileRTF = CreateFile(
                achRtfFile,
                GENERIC_READ,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_DELETE_ON_CLOSE,
                NULL);

    if (hfileRTF == INVALID_HANDLE_VALUE)
        goto Error;

    nBytesToRead = GetFileSize(hfileRTF, NULL);

    if (nBytesToRead == 0xFFFFFFFF)
        goto Error;

    *phglobalRtf = GlobalAlloc(0, nBytesToRead + 1);

    szTemp = (LPSTR)GlobalLock(*phglobalRtf);
    if (szTemp == NULL)
    	goto Error;

    fRet = ReadFile(
            hfileRTF,
            szTemp,
            nBytesToRead,
            &nBytesRead,
            NULL);

    CloseHandle(hfileRTF);

    if(fRet == FALSE)
        goto Error;

    szTemp[nBytesRead] = '\0';

Cleanup:
    if (szTemp)
        GlobalUnlock(*phglobalRtf);
    
    // No need to delete RtfFile - we used FILE_FLAG_DELETE_ON_CLOSE.
    DeleteFile(achHtmlFile);
    RRETURN(hr);

Error:
    hr = E_FAIL;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::StringRtfToStringHtml
//
//  Synopsis:   Uses the Word RTF to HTML converter to convert a string of RTF
//              to a string of HTML.
//
//  Arguments:  lptsz   the stream into which the RTF should be written
//
//----------------------------------------------------------------------------
HRESULT
CRtfToHtmlConverter::StringRtfToStringHtml(LPSTR pszRtf, HGLOBAL * phglobalHtml)
{
    HRESULT  hr = S_OK;
    HANDLE   hfileRTF, hfileHTM;
    TCHAR    achTmpPath[MAX_PATH];
    TCHAR    achTmpFile[MAX_PATH];
    DWORD    nBytesToRead, nBytesRead, nBytesWritten = 0;
    BOOL     fRet;
    char    *szPtrHead, *szPtrClose, *szTemp = NULL; 
    int      iClosing, iHeading;

    GetTempPath(MAX_PATH, achTmpPath);
    GetTempFileName(achTmpPath, _T("r2h"), 0, achTmpFile);
    
    // Keep a copy of the file location so we can delete it when we are done with it...
    _tcscpy(achTmpPath, achTmpFile);

    hfileRTF = CreateFile(
                achTmpFile,
                GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
    

    if (hfileRTF == INVALID_HANDLE_VALUE)
        goto Error;

    fRet = WriteFile(
            hfileRTF,
            pszRtf,
            strlen(pszRtf),
            &nBytesWritten,
            NULL);

    CloseHandle(hfileRTF);

    if(fRet == FALSE)
        goto Error;

    hr = THR(ExternalRtfToInternalHtml(achTmpFile));

    if(hr)
        goto Error;

    hfileHTM = CreateFile(
                achTmpFile,
                GENERIC_READ,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_DELETE_ON_CLOSE,
                NULL);

    if (hfileHTM == INVALID_HANDLE_VALUE)
        goto Error;

    nBytesToRead = GetFileSize(hfileHTM, NULL);

    if (nBytesToRead == 0xFFFFFFFF)
        goto Error;

    *phglobalHtml = GlobalAlloc(0, nBytesToRead + 1);

    szTemp = (LPSTR)GlobalLock(*phglobalHtml);    
    if (szTemp == NULL)
    	goto Error;

    fRet = ReadFile(
            hfileHTM,
            szTemp,
            nBytesToRead,
            &nBytesRead,
            NULL);

    CloseHandle(hfileHTM);

    if(fRet == FALSE)
        goto Error;

    szTemp[nBytesRead] = '\0';

    // The RTFtoHTML converter will put header information on the HTML file.  
    // We want to remove these headers, since this is just supposed to return an HTML string.

    szPtrHead = szTemp;
    while(strncmp(szPtrHead, "<BODY", 5) != 0)
    {
        szPtrHead ++;
        szPtrHead = strchr(szPtrHead, '<');
        if(!szPtrHead)
            goto Error;
    }
    
    szPtrHead = strchr(szPtrHead, '>');
    szPtrHead ++;

    szPtrClose = szPtrHead;
    while(strncmp(szPtrClose, "</BODY", 6) != 0)
    {
        szPtrClose ++;
        szPtrClose = strchr(szPtrClose, '<');
        if(!szPtrClose)
            goto Error;
    }
 
    iHeading = strlen(szTemp) - strlen(szPtrHead);
    iClosing = strlen(szPtrClose);

    memcpy(szTemp, szPtrHead, nBytesToRead - iHeading - iClosing);

    szPtrClose = szTemp + nBytesToRead - iHeading - iClosing;
    // szPtrClose[0] = '\0';
    memset(szPtrClose, '\0', iHeading + iClosing);

Cleanup:
    if (szTemp)
        GlobalUnlock(*phglobalHtml);

    DeleteFile(achTmpPath);
    
    RRETURN(hr);

Error:

    hr = E_FAIL;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::Init, static
//
//  Synopsis:   Initializes the critical section for the RTF convert.  Since
//              the RTF converter isn't multi-threaded, we need to make sure that 
//              we serialize access.
//
//----------------------------------------------------------------------------
HRESULT
CRtfToHtmlConverter::Init()
{
    HRESULT hr = HrInitializeCriticalSection(&_cs);

    if (!hr)
        _fCSInited = TRUE;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRtfToHtmlConverter::Deinit, static
//
//  Synopsis:   Deletes the critical section for the RTF convert.
//
//----------------------------------------------------------------------------
void
CRtfToHtmlConverter::Deinit()
{
    if (_fCSInited)
        DeleteCriticalSection(&_cs);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\security.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       security.cxx
//
//  Contents:   Implementation of the security proxy for CWindow
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include "dispex.h"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_EOPTION_HXX_
#define X_EOPTION_HXX_
#include "eoption.hxx"
#endif

#ifndef X_JSPROT_HXX_
#define X_JSPROT_HXX_
#include "jsprot.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include <uwininet.h>
#endif

#ifndef X_HISTORY_H_
#define X_HISTORY_H_
#include "history.h"
#endif

#ifndef X_WINABLE_H_
#define X_WINABLE_H_
#include "winable.h"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_OLEACC_H
#define X_OLEACC_H
#include <oleacc.h>
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include <shell.h>
#endif

#ifndef X_SHLOBJP_H_
#define X_SHLOBJP_H_
#include <shlobjp.h>
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_FRAMET_H_
#define X_FRAMET_H_
#include "framet.h"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_HTIFRAME_H_
#define X_HTIFRAME_H_
#include <htiframe.h>
#endif

#if DBG==1
#ifndef X_VERIFYCALLSTACK_HXX_
#define X_VERIFYCALLSTACK_HXX_
#include "VerifyCallStack.hxx"
#endif
#ifndef X_DEBUGWINDOW_HXX_
#define X_DEBUGWINDOW_HXX_
#include "DebugWindow.h"
#endif
#endif

#define WINDOWDEAD() (RPC_E_SERVER_DIED_DNE == hr || RPC_E_DISCONNECTED == hr)

extern BOOL IsGlobalOffline(void);
extern BOOL g_fInInstallShield;

BOOL IsSpecialUrl(LPCTSTR pchUrl);   // TRUE for javascript, vbscript, about protocols
BOOL IsInIEBrowser(CDoc * pDoc);

DeclareTag(tagSecurity, "Security", "Security methods")
DeclareTag(tagSecurityProxyCheck, "Security Debug", "Check window proxy security");
DeclareTag(tagSecurityProxyCheckMore, "Security Debug", "More window proxy asserts");
DeclareTag(tagSecureScriptWindow, "Security Debug", "Secure window proxy for script engine")
ExternTag(tagSecurityContext);

PerfDbgTag(tagNFNav, "NF", "NF Navigation")

MtDefine(COmWindowProxy, ObjectModel, "COmWindowProxy")
MtDefine(COmWindowProxy_pbSID, COmWindowProxy, "COmWindowProxy::_pbSID")
MtDefine(CAryWindowTbl, ObjectModel, "CAryWindowTbl")
MtDefine(CAryWindowTbl_pv, CAryWindowTbl, "CAryWindowTbl::_pv")
MtDefine(CAryWindowTblAddTuple_pbSID, CAryWindowTbl, "CAryWindowTbl::_pv::_pbSID")

BEGIN_TEAROFF_TABLE(COmWindowProxy, IMarshal)
    TEAROFF_METHOD(COmWindowProxy, GetUnmarshalClass, getunmarshalclass, (REFIID riid,void *pvInterface,DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,CLSID *pCid))
    TEAROFF_METHOD(COmWindowProxy, GetMarshalSizeMax, getmarshalsizemax, (REFIID riid,void *pvInterface,DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,DWORD *pSize))
    TEAROFF_METHOD(COmWindowProxy, MarshalInterface, marshalinterface, (IStream *pistm,REFIID riid,void *pvInterface,DWORD dwDestContext,void *pvDestContext,DWORD mshlflags))
    TEAROFF_METHOD(COmWindowProxy, UnmarshalInterface, unmarshalinterface, (IStream *pistm,REFIID riid,void ** ppvObj))
    TEAROFF_METHOD(COmWindowProxy, ReleaseMarshalData, releasemarshaldata, (IStream *pStm))
    TEAROFF_METHOD(COmWindowProxy, DisconnectObject, disconnectobject, (DWORD dwReserved))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_(COmLocationProxy, IDispatchEx)
    TEAROFF_METHOD(COmLocationProxy, GetTypeInfoCount, gettypeinfocount, (UINT *pcTinfo))
    TEAROFF_METHOD(COmLocationProxy, GetTypeInfo, gettypeinfo, (UINT itinfo, ULONG lcid, ITypeInfo ** ppTI))
    TEAROFF_METHOD(COmLocationProxy, GetIDsOfNames, getidsofnames, (REFIID riid,
                                   LPOLESTR *prgpsz,
                                   UINT cpsz,
                                   LCID lcid,
                                   DISPID *prgid))
    TEAROFF_METHOD(COmLocationProxy, Invoke, invoke, (DISPID dispidMember,
                            REFIID riid,
                            LCID lcid,
                            WORD wFlags,
                            DISPPARAMS * pdispparams,
                            VARIANT * pvarResult,
                            EXCEPINFO * pexcepinfo,
                            UINT * puArgErr))
    TEAROFF_METHOD(COmLocationProxy, GetDispID, getdispid, (BSTR bstrName,
                               DWORD grfdex,
                               DISPID *pid))
    TEAROFF_METHOD(COmLocationProxy, InvokeEx, invokeex, (DISPID id,
                        LCID lcid,
                        WORD wFlags,
                        DISPPARAMS *pdp,
                        VARIANT *pvarRes,
                        EXCEPINFO *pei,
                        IServiceProvider *pSrvProvider)) 
    TEAROFF_METHOD(COmLocationProxy, DeleteMemberByName, deletememberbyname, (BSTR bstr,DWORD grfdex))
    TEAROFF_METHOD(COmLocationProxy, DeleteMemberByDispID, deletememberbydispid, (DISPID id))    
    TEAROFF_METHOD(COmLocationProxy, GetMemberProperties, getmemberproperties, (DISPID id,
                                         DWORD grfdexFetch,
                                         DWORD *pgrfdex))
    TEAROFF_METHOD(COmLocationProxy, GetMemberName, getmembername, (DISPID id,
                                   BSTR *pbstrName))
    TEAROFF_METHOD(COmLocationProxy, GetNextDispID, getnextdispid, (DWORD grfdex,
                                   DISPID id,
                                   DISPID *pid))
    TEAROFF_METHOD(COmLocationProxy, GetNameSpaceParent, getnamespaceparent, (IUnknown **ppunk))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_(COmWindowProxy, IServiceProvider)
    TEAROFF_METHOD(COmWindowProxy, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

#if DBG==1
BEGIN_TEAROFF_TABLE(COmWindowProxy, IDebugWindowProxy)
    TEAROFF_METHOD(COmWindowProxy, get_isSecureProxy, GET_isSecureProxy, (VARIANT_BOOL *))
    TEAROFF_METHOD(COmWindowProxy, get_trustedProxy, GET_trustedProxy, (IDispatch**))
    TEAROFF_METHOD(COmWindowProxy, get_internalWindow, GET_internalWindow, (IDispatch**))
    TEAROFF_METHOD(COmWindowProxy, enableSecureProxyAsserts, EnableSecureProxyAsserts, (VARIANT_BOOL))
END_TEAROFF_TABLE()
#endif

const BYTE byOnErrorParamTypes[4] = {VT_BSTR, VT_BSTR, VT_I4, 0};

HRESULT GetCallerURL(CStr &cstr, CBase *pBase, IServiceProvider *pSP);
HRESULT GetCallerCommandTarget (CBase *pBase, IServiceProvider *pSP, BOOL fFirstScriptSite, IOleCommandTarget **ppCommandTarget);
HRESULT GetCallerSecurityStateAndURL(SSL_SECURITY_STATE *pSecState, CStr &cstr, CBase *pBase, IServiceProvider * pSP);
#if DBG==1
HRESULT GetCallerIDispatch(IServiceProvider *pSP, IDispatch ** ppID);
#endif

extern void  ProcessValueEntities(TCHAR *pch, ULONG *pcch);

#ifndef WIN16
STDAPI HlinkFindFrame(LPCWSTR pszFrameName, LPUNKNOWN *ppunk);
#endif

extern CDummySecurityDispatchEx g_DummySecurityDispatchEx;

//+-------------------------------------------------------------------------
//
//  Member:     Free
//
//  Synopsis:   Clear out the contents of a WINDOWTBL structure
//
//--------------------------------------------------------------------------

void
WINDOWTBL::Free()
{
    delete [] pbSID;
    pbSID = NULL;
    cbSID = 0;
}


//+-------------------------------------------------------------------------
//
//  Function:   EnsureWindowInfo
//
//  Synopsis:   Ensures that a thread local window table exists
//
//--------------------------------------------------------------------------

HRESULT 
EnsureWindowInfo()
{
    if (!TLS(windowInfo.paryWindowTbl))
    {
        TLS(windowInfo.paryWindowTbl) = new CAryWindowTbl;
        if (!TLS(windowInfo.paryWindowTbl))
            RRETURN(E_OUTOFMEMORY);
    }

    if (!TLS(windowInfo.pSecMgr))
    {
        IInternetSecurityManager *  pSecMgr = NULL;
        HRESULT                     hr;
        
        hr = THR(CoInternetCreateSecurityManager(NULL, &pSecMgr, 0));
        if (hr)
            RRETURN(hr);
        
        TLS(windowInfo.pSecMgr) = pSecMgr;  // Implicit addref/release
    }
    
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   DeinitWindowInfo
//
//  Synopsis:   Clear out the thread local window table
//
//--------------------------------------------------------------------------

void 
DeinitWindowInfo(THREADSTATE *pts)
{
    WINDOWTBL * pwindowtbl;
    long        i;
    
    if (pts->windowInfo.paryWindowTbl)
    {
        for (i = pts->windowInfo.paryWindowTbl->Size(), pwindowtbl=*(pts->windowInfo.paryWindowTbl);
             i > 0;
             i--, pwindowtbl++)
        {
            pwindowtbl->Free();
        }
        delete pts->windowInfo.paryWindowTbl;
        pts->windowInfo.paryWindowTbl = NULL;
    }

    ClearInterface(&(pts->windowInfo.pSecMgr));
}


//+-------------------------------------------------------------------------
//
//  Member:     CAryWindowTbl::FindProxy
//
//  Synopsis:   Search in window table and return proxy given
//              a window and a string.
//
//--------------------------------------------------------------------------

HRESULT
CAryWindowTbl::FindProxy(
    IHTMLWindow2 *pWindow, 
    BYTE *pbSID, 
    DWORD cbSID, 
    BOOL fTrust,
    IHTMLWindow2 **ppProxy,
    BOOL fForceSecureProxy)
{
    WINDOWTBL * pwindowtbl;
    long        i;

    Assert(pWindow);
    
    for (i = Size(), pwindowtbl = *this;
         i > 0;
         i--, pwindowtbl++)
    {
        // Should we QI for IUnknown here?
        if (IsSameObject(pWindow, pwindowtbl->pWindow))
        {
            if ((!pbSID && pwindowtbl->pbSID) ||
                (pbSID && !pwindowtbl->pbSID))
                continue;

            // Trust status must match for this comparison to succeed.
            if (fTrust != pwindowtbl->fTrust)
                continue;
                
            if ((!pbSID && !pwindowtbl->pbSID) ||
                (cbSID == pwindowtbl->cbSID &&
                 !memcmp(pbSID, pwindowtbl->pbSID, cbSID)))
            {
                HRESULT             hr;
                COmWindowProxy *    pProxyListed = NULL;

                // the pProxyListed we receive here is a weak ref. no need to release.
                hr = THR(pwindowtbl->pProxy->QueryInterface(CLSID_HTMLWindowProxy, 
                                                            (void **)&pProxyListed));
                
                // we can only check for _fTrusted if the pProxyListed is provided
                if (!hr && pProxyListed)
                {
                    //
                    // found a proxy that is created for the window that we want
                    // to access from the domain that we are on. The last check is
                    // make sure that we don't return a main (_fTrusted=1) proxy to
                    // the script, or a non trusted object to the internal callers.
                    //
                    if ((fForceSecureProxy && pProxyListed->_fTrusted) ||
                        (!fForceSecureProxy && !pProxyListed->_fTrusted))
                        continue;
                }

                //
                // We have what we want, return this proxy.
                // This is a weak ref.
                //

                if (ppProxy)
                {
                    *ppProxy = pwindowtbl->pProxy;
                }
                return S_OK;
            }
        }
    }
    
    RRETURN(E_FAIL);
}


//+-------------------------------------------------------------------------
//
//  Member:     CAryWindowTbl::AddTuple
//
//  Synopsis:   Search in window table and return proxy given
//              a window and a string.
//
//--------------------------------------------------------------------------


HRESULT
CAryWindowTbl::AddTuple(
    IHTMLWindow2 *pWindow, 
    BYTE *pbSID,
    DWORD cbSID,
    BOOL fTrust,
    IHTMLWindow2 *pProxy)
{
    WINDOWTBL   windowtbl;
    WINDOWTBL * pwindowtbl;
    HRESULT     hr = S_OK;
    BYTE *      pbSIDTmp = NULL;
    
#if DBG == 1
    long        lProxyCount = 0;

    //
    // We better not be adding a proxy for an already existing tuple.
    //

    if (!(FindProxy(pWindow, pbSID, cbSID, fTrust, NULL, TRUE)))
        lProxyCount++;

    if (!(FindProxy(pWindow, pbSID, cbSID, fTrust, NULL, FALSE)))
        lProxyCount++;

    if (lProxyCount == 2)
        Assert(0 && "Adding a window proxy tuple twice");
#endif

    //
    // Weak ref.  The proxy deletes itself from this array upon 
    // its destruction.
    //
    
    windowtbl.pProxy = pProxy;
    windowtbl.cbSID = cbSID;
    windowtbl.fTrust = fTrust;
    windowtbl.pWindow = pWindow;    // No nead to addref here because the proxy already is

    
    pbSIDTmp = new(Mt(CAryWindowTblAddTuple_pbSID)) BYTE[cbSID];
    if (!pbSIDTmp)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    memcpy(pbSIDTmp, pbSID, cbSID);
    windowtbl.pbSID = pbSIDTmp;
    
    hr = THR(TLS(windowInfo.paryWindowTbl)->AppendIndirect(&windowtbl, &pwindowtbl));
    if (hr)
        goto Error;

    MemSetName(( *(GetThreadState()->windowInfo.paryWindowTbl), "paryWindowTbl c=%d", (TLS(windowInfo.paryWindowTbl))->Size()));

Cleanup:
    RRETURN(hr);

Error:
    delete [] pbSIDTmp;
    goto Cleanup;
}


//+-------------------------------------------------------------------------
//
//  Member:     CAryWindowTbl::DeleteProxyEntry
//
//  Synopsis:   Search in window table for the given proxy
//              and delete its entry.  Every proxy should appear
//              only once in the window table.
//
//--------------------------------------------------------------------------

void 
CAryWindowTbl::DeleteProxyEntry(IHTMLWindow2 *pProxy)
{
    WINDOWTBL * pwindowtbl;
    long        i;
    
    Assert(pProxy);
    
    for (i = Size(), pwindowtbl = *this;
         i > 0;
         i--, pwindowtbl++)
    {
        if (pProxy == pwindowtbl->pProxy)
        {
            pwindowtbl->Free();
            Delete(Size() - i);
            break;
        }
    }

#if DBG == 1
    //
    // In debug mode, just ensure that this proxy is not appearing
    // anywhere else in the table.
    //

    for (i = Size(), pwindowtbl = *this;
         i > 0;
         i--, pwindowtbl++)
    {
        // Should we QI for IUnknown here?
        Assert(pProxy != pwindowtbl->pProxy);
    }
#endif
}


//+-------------------------------------------------------------------------
//
//  Function:   GetSIDOfDispatch
//
//  Synopsis:   Retrieve the host name given an IHTMLDispatch *
//
//--------------------------------------------------------------------------

HRESULT 
GetSIDOfDispatch(IDispatch *pDisp, BYTE *pbSID, DWORD *pcbSID, BOOL *pfDomainExist = NULL)
{
    HRESULT         hr;
    CVariant        VarUrl;
    CVariant        VarDomain;
    TCHAR           ach[pdlUrlLen];
    DWORD           dwSize;

    if (pfDomainExist)
        *pfDomainExist = FALSE;

    // call invoke DISPID_SECURITYCTX off pDisp to get SID
    hr = THR_NOTRACE(GetDispProp(
            pDisp,
            DISPID_SECURITYCTX,
            LOCALE_SYSTEM_DEFAULT,
            &VarUrl,
            NULL,
            FALSE));
    if (hr) 
        goto Cleanup;

    if (V_VT(&VarUrl) != VT_BSTR || !V_BSTR(&VarUrl))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!OK(THR_NOTRACE(GetDispProp(
            pDisp,
            DISPID_SECURITYDOMAIN,
            LOCALE_SYSTEM_DEFAULT,
            &VarDomain,
            NULL,
            FALSE))))
    {
        VariantClear(&VarDomain);
    }
    else if (pfDomainExist)
        *pfDomainExist = TRUE;


    hr = THR(EnsureWindowInfo());
    if (hr)
        goto Cleanup;

    hr = THR(CoInternetParseUrl(
            V_BSTR(&VarUrl), 
            PARSE_ENCODE, 
            0, 
            ach, 
            ARRAY_SIZE(ach), 
            &dwSize, 
            0));
    if (hr)
        goto Cleanup;
        
    UnescapeAndTruncateUrl (ach, FALSE);

    hr = THR(TLS(windowInfo.pSecMgr)->GetSecurityId(
            ach, 
            pbSID, 
            pcbSID,
            (DWORD_PTR)(V_VT(&VarDomain) == VT_BSTR ? V_BSTR(&VarDomain) : NULL)));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CreateSecurityProxy
//
//  Synopsis:   Creates a new security proxy for marshalling across
//              thread & process boundaries.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CreateSecurityProxy(
        IUnknown * pUnkOuter,
        IUnknown **ppUnk)
{
    COmWindowProxy *    pProxy;
    
    if (pUnkOuter)
        RRETURN(CLASS_E_NOAGGREGATION);

    pProxy = new COmWindowProxy();
    if (!pProxy)
        RRETURN(E_OUTOFMEMORY);

    Verify(!pProxy->QueryInterface(IID_IUnknown, (void **)ppUnk));
    pProxy->Release();
    
    return S_OK;
}


const CONNECTION_POINT_INFO COmWindowProxy::s_acpi[] =
{
    CPI_ENTRY(IID_IDispatch, DISPID_A_EVENTSINK)
    CPI_ENTRY(DIID_HTMLWindowEvents, DISPID_A_EVENTSINK)
    CPI_ENTRY(IID_ITridentEventSink, DISPID_A_EVENTSINK)
    CPI_ENTRY(DIID_HTMLWindowEvents2, DISPID_A_EVENTSINK)
    CPI_ENTRY_NULL
};


const CBase::CLASSDESC COmWindowProxy::s_classdesc =
{
    &CLSID_HTMLWindowProxy,         // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    s_acpi,                         // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLWindow2,              // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};




//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::COmWindowProxy
//
//  Synopsis:   ctor
//
//--------------------------------------------------------------------------

COmWindowProxy::COmWindowProxy() : super()
{
#ifdef WIN16
    m_baseOffset = ((BYTE *) (void *) (CBase *)this) - ((BYTE *) this);
#endif
    IncrementObjectCount(&_dwObjCnt);

    _dwMyPicsState       = 0;      // Used to make sure we only get zero or one at a time
    _bDisabled           = FALSE;  // If user disabled for session
    _pMyPics             = NULL;   // Pointer to attached MyPics object
}    


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::Passivate
//
//  Synopsis:   1st phase destructor
//
//--------------------------------------------------------------------------

void
COmWindowProxy::Passivate()
{
    //
    // Go through the cache and delete the entry for this proxy
    //

    if (TLS(windowInfo.paryWindowTbl))
    {
        TLS(windowInfo.paryWindowTbl)->DeleteProxyEntry((IHTMLWindow2 *)this);
    }

    GWKillMethodCall (this, NULL, 0);
    
    ClearInterface(&_pWindow);
    _pCWindow = NULL;
    delete [] _pbSID;
    _pbSID = NULL;
    _fDomainChanged = 0;
    _cbSID = 0;
    super::Passivate();
    DecrementObjectCount(&_dwObjCnt);
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::Init
//
//  Synopsis:   Initializer
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::Init(IHTMLWindow2 *pWindow, BYTE *pbSID, DWORD cbSID)
{
    HRESULT hr = S_OK;

    Assert(pbSID && cbSID);

    _fDomainChanged = 0;
    delete [] _pbSID;
    
    _pbSID = new(Mt(COmWindowProxy_pbSID)) BYTE[cbSID];
    if (!_pbSID)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _cbSID = cbSID;
    memcpy(_pbSID, pbSID, cbSID);
    
    if (_pWindow != pWindow)
    {
        ReplaceInterface(&_pWindow, pWindow);
        _pCWindow = NULL;
        if(_pWindow && _fTrusted)
        {
            IGNORE_HR(_pWindow->QueryInterface(CLSID_HTMLWindow2, (void**)&_pCWindow));
        }
    }

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::SecureObject
//
//  Synopsis:   Wrap the correct proxy around this object if
//              necessary.
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::SecureObject(VARIANT *pvarIn,                   //
                             VARIANT *pvarOut,                  //
                             IServiceProvider *pSrvProvider,    //
                             CBase * pAttrAryBase,              //
                             BOOL fInvoked)                     //
{
    IHTMLWindow2 *      pWindow = NULL;
    IOleCommandTarget * pCommandTarget = NULL;
    HRESULT             hr = E_FAIL;
    BOOL                fForceSecureProxy = TRUE;
    BOOL                fSecurityCheck = TRUE;

    if (!pvarOut)
    {
        hr = S_OK;
        goto Cleanup;
    }
    
    // No need for a security check if this is a trusted context.
    if (_fTrustedDoc)
        fSecurityCheck = FALSE;

    if (V_VT(pvarIn) == VT_UNKNOWN && V_UNKNOWN(pvarIn))
    {
        hr = THR_NOTRACE(V_UNKNOWN(pvarIn)->QueryInterface(
                IID_IHTMLWindow2, (void **)&pWindow));
    }
    else if (V_VT(pvarIn) == VT_DISPATCH && V_DISPATCH(pvarIn))
    {
        hr = THR_NOTRACE(V_DISPATCH(pvarIn)->QueryInterface(
                IID_IHTMLWindow2, (void **)&pWindow));
    }

    if (hr)
    {
        //
        // Object being retrieved is not a window object.
        // Just proceed normally.
        //

        VariantCopy(pvarOut, pvarIn);
        hr = S_OK;
    }
    else
    {
        IHTMLWindow2 *  pWindowOut;

        if (fSecurityCheck)
        {
            BYTE        abSID[MAX_SIZE_SECURITY_ID];
            DWORD       cbSID = ARRAY_SIZE(abSID);
            CVariant    varCallerSID;
            CVariant    varCallerWindow;

            hr = THR(GetCallerCommandTarget(pAttrAryBase, pSrvProvider, FALSE, &pCommandTarget));
            if (FAILED(hr))
                goto Cleanup;

            if (hr == S_FALSE && pSrvProvider==NULL)
            {
                // the ONLY way for this to happen is if the call has come in on the VTable
                // rather than through script.  But lets be paranoid about that.
                // To work properly, and to be consistent with
                // the Java VM, if we don't have a securityProvicer in the AA, or passed in
                // then assume trusted.
                 if (pAttrAryBase && 
                     (AA_IDX_UNKNOWN == pAttrAryBase->FindAAIndex (DISPID_INTERNAL_INVOKECONTEXT,CAttrValue::AA_Internal)))
                 {

                    fForceSecureProxy = FALSE;
                 }
                 hr = S_OK;      // succeed anyhow, else leave the hr=S_FALSE
            }
            else if (pCommandTarget)
            {
                // get the security ID of the caller window.
                hr = THR(pCommandTarget->Exec(
                        &CGID_ScriptSite,
                        CMDID_SCRIPTSITE_SID,
                        0,
                        NULL,
                        &varCallerSID));
                if (hr)
                    goto Cleanup;

                Assert(V_VT(&varCallerSID) == VT_BSTR);

                Assert(FormsStringLen(V_BSTR(&varCallerSID)) == MAX_SIZE_SECURITY_ID);

                memset(abSID, 0, cbSID);
                hr = THR(GetSIDOfDispatch(_pWindow, abSID, &cbSID));
                if (hr)
                    goto Cleanup;

                if (memcmp(abSID, V_BSTR(&varCallerSID), MAX_SIZE_SECURITY_ID))
                {
                    DWORD dwPolicy = 0;
                    DWORD dwContext = 0;
                    CStr cstrCallerUrl;

                    hr = THR(GetCallerURL(cstrCallerUrl, pAttrAryBase, pSrvProvider));
                    if (hr)
                        goto Cleanup;

                    if (!SUCCEEDED(ZoneCheckUrlEx(cstrCallerUrl, &dwPolicy, sizeof(dwPolicy), &dwContext, sizeof(dwContext),
                                    URLACTION_HTML_SUBFRAME_NAVIGATE, 0, NULL))
                        ||  GetUrlPolicyPermissions(dwPolicy) != URLPOLICY_ALLOW)
                    {
                        hr = E_ACCESSDENIED;
                        goto Cleanup;
                    }
                }
            }
        }
        else
        {
            fForceSecureProxy = FALSE;
        }

        Assert(S_OK == hr);
        if (hr)
            goto Cleanup;

        Assert(pWindow);
        hr = THR(SecureObject(pWindow, &pWindowOut, fForceSecureProxy));
        if (hr)
            goto Cleanup;

        if (fInvoked && ((COmWindowProxy *)pWindowOut)->_fTrusted)
        {
            hr = pWindowOut->QueryInterface(IID_IDispatch, (LPVOID*)&V_DISPATCH(pvarOut));
            ReleaseInterface(pWindowOut);
            if (hr)
                goto Cleanup;
        }
        else
        {
            V_DISPATCH(pvarOut) = pWindowOut;
        }

        V_VT(pvarOut) = VT_DISPATCH;
    }
    
Cleanup:
    ReleaseInterface(pCommandTarget);
    ReleaseInterface(pWindow);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::SecureWindow
//
//  Synopsis:   Wrap the correct proxy around this object if
//              necessary.  Check in cache if a proxy already exists
//              for this combination.
//
//--------------------------------------------------------------------------
HRESULT
COmWindowProxy::SecureObject(
    IHTMLWindow2 *pWindowIn, 
    IHTMLWindow2 **ppWindowOut, 
    BOOL    fForceSecureProxy ) /*= TRUE*/
    {
    IHTMLWindow2 *      pWindow = NULL;
    HRESULT             hr = S_OK;
    COmWindowProxy *    pProxy = NULL;
    COmWindowProxy *    pProxyIn = NULL;

    if (!pWindowIn)
    {
        *ppWindowOut = NULL;
        goto Cleanup;
    }

    //
    // First if pWindowIn is itself a proxy, delve all the way
    // through to find the real IHTMLWindow2 that it's bound to
    //

    hr = THR_NOTRACE(pWindowIn->QueryInterface(
            CLSID_HTMLWindowProxy, (void **)&pProxyIn));
    if (!hr)
    {
        //
        // No need to further delve down because with this check
        // we're asserting that a proxy to a proxy can never exist.
        // Remember that pProxyIn is a weak ref.
        //
        
        pWindowIn = pProxyIn->_pWindow;
    }

    //
    // Create a new proxy with this window's security context for the 
    // new window.  Test the cache to see if we already have a proxy 
    // created for this combination first.
    //

    hr = THR(EnsureWindowInfo());
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(TLS(windowInfo.paryWindowTbl)->FindProxy(
            pWindowIn, 
            _pbSID,
            _cbSID,
            _fTrustedDoc,
            &pWindow, 
            fForceSecureProxy));     // fForceSecureProxy = TRUE.
    if (!hr)
    {
        //
        // We found an entry, just return this one.
        //

        *ppWindowOut = pWindow;
        pWindow->AddRef();
    }
    else
    {
        //
        // No entry in cache for this tuple, so create a new proxy
        // and add to cache
        //
        
        pProxy = new COmWindowProxy;
        if (!pProxy)
            RRETURN(E_OUTOFMEMORY);

        hr = THR(pProxy->Init(pWindowIn, _pbSID, _cbSID));
        if (hr)
            goto Cleanup;

        // Set the trusted attribute for this new proxy.  If this proxy is 
        // for a trusted doc, the new one should be too.
        pProxy->_fTrustedDoc = _fTrustedDoc;
        pProxy->_fDomainChanged = _fDomainChanged;

        // Implicit AddRef/Release for pProxy
        *ppWindowOut = (IHTMLWindow2 *)pProxy;

        hr = THR(TLS(windowInfo.paryWindowTbl)->AddTuple(
                pWindowIn, 
                _pbSID, 
                _cbSID,
                _fTrustedDoc,
                *ppWindowOut));
        if (hr)
            goto Cleanup;
    }
    
Cleanup:
    RRETURN(hr);
}



//+-------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::AccessAllowed
//
//  Synopsis:   Tell if access is allowed based on urls.
//
//  Returns:    TRUE if allowed, FALSE otherwise.
//
//  Notes:      Access is allowed if the second tier domain is the
//              same.  I.e. www.usc.edu and ftp.usc.edu can access
//              each other.  However, www.usc.com and www.usc.edu 
//              cannot.  Neither can www.stanford.edu and www.usc.edu.
//
//--------------------------------------------------------------------------

BOOL
COmWindowProxy::AccessAllowed()
{
    HRESULT hr;
    BOOL    fDomainChanged;
    BYTE    abSID[MAX_SIZE_SECURITY_ID];
    DWORD   cbSID = ARRAY_SIZE(abSID);
    
    if (_fTrusted || _fTrustedDoc)
        return TRUE;

    hr = THR(GetSIDOfDispatch(_pWindow, abSID, &cbSID, &fDomainChanged));
    if (hr)
        return FALSE;
        
    return (cbSID == _cbSID && !memcmp(abSID, _pbSID, cbSID) && (!!_fDomainChanged) == fDomainChanged);
}

// Same as above but use passed in IDispatch *
//
BOOL
COmWindowProxy::AccessAllowed(IDispatch *pDisp)
{
    HRESULT hr;
    BOOL    fDomainChanged;
    CStr    cstr;
    BYTE    abSID[MAX_SIZE_SECURITY_ID];
    DWORD   cbSID = ARRAY_SIZE(abSID);


    hr = THR(GetSIDOfDispatch(pDisp, abSID, &cbSID, &fDomainChanged));
    if (hr)
        return FALSE;
        
    return (cbSID == _cbSID && !memcmp(abSID, _pbSID, cbSID) && (!!_fDomainChanged) == fDomainChanged);
}



//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::FireEvent
//
//  Synopsis:   CBase doesn't allow an EVENTPARAM, which we need.
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::FireEvent(
    DISPID dispidEvent, 
    DISPID dispidProp, 
    LPCTSTR pchEventType,
    CVariant *pVarRet,
    BOOL *pfRet)
{
    HRESULT         hr;
    CWindow *       pWindow = Window();
    IHTMLEventObj  *pEventObj = NULL;
    CVariant        Var;

    AssertSz(pWindow && pWindow->Doc(),"Possible Async Problem Causing Watson Crashes");

#if DBG==1 
    // return secure object on QI while firing the event. otherwise script uses trusted proxy.
    if (IsTagEnabled(tagSecureScriptWindow))
        DebugHackSecureProxyForOm(pWindow->Markup()->GetScriptCollection()->_pSecureWindowProxy);
#endif

    // Creating this causes it to be added to a linked list on the
    // doc. Even though this looks like param is not used, DON'T REMOVE
    // THIS CODE!!
    EVENTPARAM param(pchEventType ? pWindow->Doc() : NULL, NULL, pWindow->Markup(), TRUE);

    if (pchEventType)
    {
        Assert(pWindow->Doc()->_pparam == &param);
        param.SetType(pchEventType);
    }

    if (pfRet && !pVarRet)
        pVarRet = &Var;

    // Get the eventObject.
    Assert(pWindow->Doc()->_pparam);
    CEventObj::Create(&pEventObj, pWindow->Doc(), NULL, pWindow->Markup());

    hr = THR(InvokeEvent(dispidEvent, 
                            dispidProp,
                            pEventObj,
                            pVarRet));

    if (pfRet)
    {
        Assert(pVarRet);
        VARIANT_BOOL vb;
        vb = (V_VT(pVarRet) == VT_BOOL) ? V_BOOL(pVarRet) : VB_TRUE;
        *pfRet = !pWindow->Doc()->_pparam->IsCancelled() && (VB_TRUE == vb);
    }

    // Any attachEvents?  Need to fire on window itself.
    hr = THR(pWindow->InvokeAttachEvents(dispidProp, NULL, NULL, pWindow, NULL, NULL, pEventObj));

    ReleaseInterface(pEventObj);

#if DBG==1 
    if (IsTagEnabled(tagSecureScriptWindow))
        DebugHackSecureProxyForOm(NULL);
#endif
    
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::Fire_onerror
//
//  Synopsis:   Fires the onerror event and returns S_FALSE if ther was not script
//              or the script returned S_FALSE requesting default processing
//
//       NOTE:  While this event handler returns TRUE to tell the browser to take no 
//                further action, most Form and form element event handles return false to 
//                prevent the browser from performing some action such as submitting a form.
//              This inconsistency can be confusing.
//--------------------------------------------------------------------------

BOOL 
COmWindowProxy::Fire_onerror(BSTR bstrMessage, BSTR bstrUrl,
                             long lLine, long lCharacter, long lCode,
                             BOOL fWindow)
{
    HRESULT         hr;
    VARIANT_BOOL    fRet = VB_FALSE;
    CWindow *       pWindow = Window();
    CDoc *          pDoc = pWindow ? pWindow->Doc() : NULL;

    // sanity check...
    // This window proxy MUST be a trusted proxy, since we only give 
    // trusted proxies to script engines
    Assert(_fTrusted && AccessAllowed());

    EVENTPARAM param(pDoc, NULL, pWindow ? pWindow->Markup() : NULL, TRUE);

    if (!pWindow || !pDoc)
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        hr = E_FAIL;
        goto Cleanup;
    }

    param.SetType(_T("error"));
    param.errorParams.pchErrorMessage = bstrMessage;
    param.errorParams.pchErrorUrl = bstrUrl;
    param.errorParams.lErrorLine = lLine;
    param.errorParams.lErrorCharacter = lCharacter;
    param.errorParams.lErrorCode = lCode;

    if (fWindow)
    {
        Assert(pWindow);

        hr = THR(pWindow->FireEventV(DISPID_EVMETH_ONERROR, DISPID_EVPROP_ONERROR, NULL, &fRet,
            byOnErrorParamTypes, bstrMessage, bstrUrl, lLine));
        if (hr)
            goto Cleanup;

        hr = pWindow->ShowErrorDialog(&fRet);
    }
    else
        hr = THR(FireEventV(DISPID_EVMETH_ONERROR, DISPID_EVPROP_ONERROR, NULL, &fRet,
            byOnErrorParamTypes, bstrMessage, bstrUrl, lLine));

    if (hr)
        goto Cleanup;

    if (    (fRet != VB_TRUE)
        &&  (V_VT(&param.varReturnValue) == VT_BOOL)
        &&  (V_BOOL(&param.varReturnValue) == VB_TRUE))
        fRet = VB_TRUE;

Cleanup:  
    return (fRet == VB_TRUE);
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::Fire_onscroll
//
//  Synopsis:
//
//--------------------------------------------------------------------------

void
COmWindowProxy::Fire_onscroll()
{
    FireEvent(DISPID_EVMETH_ONSCROLL, DISPID_EVPROP_ONSCROLL, _T("scroll"));
    Window()->Fire_onscroll();
}

void
COmWindowProxy::EnableAutoImageResize()
{

    CDoc             *pDoc     = Window()->Doc();
    ITridentService2 *pTriSvc2 = NULL;
    HRESULT           hr       = S_OK;
    
    // check to see if this is flagged as a single image on a page
    if (!pDoc->_fShouldEnableAutoImageResize)
        return; 

    // init CAutoImageResize
    if (pDoc->_pTridentSvc)
        hr = pDoc->_pTridentSvc->QueryInterface(IID_ITridentService2, (void **)&pTriSvc2);

    if (SUCCEEDED(hr) && pTriSvc2)
    {
        pTriSvc2->InitAutoImageResize();
        pTriSvc2->Release();
    }

}
    
void
COmWindowProxy::DisableAutoImageResize()
{
    
    CDoc             *pDoc     = Window()->Doc();
    ITridentService2 *pTriSvc2 = NULL;
    HRESULT           hr       = S_OK;
    
    if (pDoc->_pTridentSvc)
        hr = pDoc->_pTridentSvc->QueryInterface(IID_ITridentService2, (void **)&pTriSvc2);

    // uninit CAutoImageResize
    if (SUCCEEDED(hr) && pTriSvc2)
    {
        pTriSvc2->UnInitAutoImageResize();
        pTriSvc2->Release();
    }

    // turn off the feature
    pDoc->_fShouldEnableAutoImageResize = FALSE;

}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::AttachMyPics
//
//  Synopsis:   Creates a new CMyPics instance for this window via
//              ITridentService2
//
//--------------------------------------------------------------------------

HRESULT COmWindowProxy::AttachMyPics() 
{
    HRESULT           hr        = S_OK;
    CDoc             *pDoc      = Window() ? Window()->Doc() : NULL;
    CDocument        *pDocument = Document();
    IHTMLDocument2   *pDoc2     = NULL;
    ITridentService2 *pTriSvc2  = NULL;

    if (_pMyPics)
        ReleaseMyPics();
    
    if (!pDocument)
        goto Cleanup;

    if (_bDisabled || _dwMyPicsState != 0 )
        return (hr);

    if (pDocument)
        hr = pDocument->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc2);
    if (FAILED(hr))
        goto Cleanup;

    if (!Window() || !Window()->Doc())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        return(E_FAIL);
    }

    if (pDoc->_pTridentSvc)
        hr = pDoc->_pTridentSvc->QueryInterface(IID_ITridentService2, (void **)&pTriSvc2);
    if (FAILED(hr))
        goto Cleanup;

    if (pDoc2 && pTriSvc2) 
    {
        pTriSvc2->AttachMyPics(pDoc2, &_pMyPics);
        if (pDocument->GetGalleryMeta() == FALSE)
        {
            pTriSvc2->IsGalleryMeta(FALSE, _pMyPics);
        }
        hr = S_OK;
    }

    if (_pMyPics)
        _dwMyPicsState++;

Cleanup:
    if (pDoc2)
        pDoc2->Release();

    if (pTriSvc2)
        pTriSvc2->Release();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::ReleaseMyPics
//
//  Synopsis:   Destroys the CMyPics instance for this window via
//              ITridentService2
//
//--------------------------------------------------------------------------

HRESULT COmWindowProxy::ReleaseMyPics() 
{

    HRESULT           hr        = S_OK;
    CDoc             *pDoc      = Window()->Doc();
    ITridentService2 *pTriSvc2  = NULL;


    if (pDoc->_pTridentSvc)
        hr = pDoc->_pTridentSvc->QueryInterface(IID_ITridentService2, (void **)&pTriSvc2);

    if (FAILED(hr))
        goto Cleanup; 

    if (_pMyPics && pTriSvc2) {
        void *p = _pMyPics;
        _pMyPics = NULL;
        _bDisabled = pTriSvc2->ReleaseMyPics(p);
        _dwMyPicsState--;
    }

Cleanup:

    if (pTriSvc2)
        pTriSvc2->Release();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::DestroyMyPics
//
//  Synopsis:   Destroys the CMyPics instance for this window via
//              ITridentService2
//
//--------------------------------------------------------------------------

HRESULT COmWindowProxy::DestroyMyPics()
{
    if (_pMyPics)
        ReleaseMyPics();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::Fire_onload, Fire_onunload
//
//  Synopsis:   Fires the onload/onunload events of the window
//      these all call the CBase::FireEvent variant that takes the CBase *
//
//--------------------------------------------------------------------------

void
COmWindowProxy::Fire_onload()
{
    CWindow * pWindow = Window();
    CFrameSite * pFrameSite = NULL;

    if (!pWindow || !pWindow->Markup() || !pWindow->Markup()->Doc())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        return;
    }

    pFrameSite = pWindow->GetFrameSite();

    // Bugfix:27622: GWPostMethodCall is skipped only for InstallShield (g_fInInstallShield=TRUE)
    if (!_fQueuedOnload && 
        pWindow->Markup()->Doc()->GetView()->HasDeferredTransition() && !g_fInInstallShield)
    {
        IGNORE_HR(GWPostMethodCall(this, 
                                    ONCALL_METHOD(COmWindowProxy, DeferredFire_onload, deferredfire_onload), 
                                    0, FALSE, "COmWindowProxy::DeferredFire_onload"));
        _fQueuedOnload = TRUE;
    }
    else
    {
        // prepare for the next navigation of this window
        _fQueuedOnload = FALSE;

        if (pFrameSite)
            pFrameSite->AddRef();

        FireEvent(DISPID_EVMETH_ONLOAD, DISPID_EVPROP_ONLOAD, _T("load"));

        pWindow->Fire_onload();
    
        if (pFrameSite)
        {
            pFrameSite->FireEvent(&s_propdescCFrameSiteonload);
            pFrameSite->Release();
        }

        if (pWindow->IsPrimaryWindow())
        {
            CMarkupBehaviorContext * pContext = NULL;

            if (S_OK == Markup()->EnsureBehaviorContext(&pContext))
            {
                ClearInterface(&(pContext->_pXMLHistoryUserData));
                pContext->_cstrHistoryUserData.Free();
            }

            ClearInterface(&(pWindow->Doc()->_pShortcutUserData));
        }

        AttachMyPics();
        EnableAutoImageResize();

        IGNORE_HR(pWindow->FireAccessibilityEvents(DISPID_EVMETH_ONLOAD));

#ifdef V4FRAMEWORK
        {
            IExternalDocument *pFactory;
            pFactory = pWindow->Doc()->EnsureExternalFrameWork();
            if (pFactory) 
                IGNORE_HR(pFactory->OnLoad());
        }
#endif V4FRAMEWORK
    }
}

void
COmWindowProxy::DeferredFire_onload( DWORD_PTR dwContext )
{
    Fire_onload();
}

void
COmWindowProxy::Fire_onunload()
{
    CWindow * pWindow = Window();

    if (!pWindow || !pWindow->Markup() || !pWindow->Markup()->Doc())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        return;
    }

    FireEvent(DISPID_EVMETH_ONUNLOAD, DISPID_EVPROP_ONUNLOAD, _T("unload"));

    // fire for window connection points 
    pWindow->Fire_onunload();

    IGNORE_HR(pWindow->FireAccessibilityEvents(DISPID_EVMETH_ONUNLOAD));
        
    CMarkup *pMarkup = Markup(); 
    Assert(pMarkup);

    if (pMarkup->_fHasFrames)
    {
        CNotification   nf;    
                               
        nf.OnUnload(pMarkup->Root());
        pMarkup->Notify(&nf);
    }

    if (pMarkup->Doc()->_pClientSite)
    {
        IGNORE_HR(CTExec(pMarkup->Doc()->_pClientSite, &CGID_DocHostCmdPriv,
                         DOCHOST_READYSTATE_INTERACTIVE, NULL, NULL , NULL));
    }                                     

    if (_dwMyPicsState)
        ReleaseMyPics();

}

BOOL 
COmWindowProxy::Fire_onhelp()
{
    BOOL fRet = TRUE;
    FireEvent(DISPID_EVMETH_ONHELP, DISPID_EVPROP_ONHELP, _T("help"), NULL, &fRet);
    return (fRet && Window()->Fire_onhelp());
}

void 
COmWindowProxy::Fire_onresize()
{
    FireEvent(DISPID_EVMETH_ONRESIZE, DISPID_EVPROP_ONRESIZE, _T("resize"));
    Window()->Fire_onresize();
}

BOOL
COmWindowProxy::Fire_onbeforeunload()
{
    CWindow * pOmWindow2 = Window();
    BOOL fRetval = TRUE;
    CDocument *pDocument = Document();

    if (!pOmWindow2 || !pOmWindow2->Doc())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        return FALSE;
    }

    if (!pOmWindow2->_fOnBeforeUnloadFiring)
    {
        HRESULT hr = S_OK;
        CDoc *pDoc = pOmWindow2->Doc();
        CVariant    varRetval;
        CVariant  * pvarString = NULL;
        EVENTPARAM  param(pDoc, NULL, pOmWindow2->Markup(), TRUE);

        pOmWindow2->_fOnBeforeUnloadFiring = TRUE;

        param.SetType(_T("beforeunload"));

        hr = THR(FireEvent(DISPID_EVMETH_ONBEFOREUNLOAD, DISPID_EVPROP_ONBEFOREUNLOAD, NULL, &varRetval));

        // if we have an event.retValue use that rather then the varRetval
        if (S_FALSE != param.varReturnValue.CoerceVariantArg(VT_BSTR))
        {
            pvarString = &param.varReturnValue;
        }
        else if (S_FALSE != varRetval.CoerceVariantArg(VT_BSTR))
        {
            pvarString = &varRetval;
        }

        // if we have a return string, show it
        if (!hr && pvarString)
        {
            int iResult = 0;
            TCHAR *pstr;
            Format(FMT_OUT_ALLOC,
                   &pstr,
                   64,
                   _T("<0i>\n\n<2s>\n\n<3i>"),
                   GetResourceHInst(),
                   IDS_ONBEFOREUNLOAD_PREAMBLE,
                   V_BSTR(pvarString),
                   GetResourceHInst(),
                   IDS_ONBEFOREUNLOAD_POSTAMBLE);
            pDoc->ShowMessageEx(&iResult,
                          MB_OKCANCEL | MB_ICONWARNING | MB_SETFOREGROUND,
                          NULL,
                          0,
                          pstr);
            delete pstr;
            if (iResult == IDCANCEL)
                fRetval = FALSE;
        }

        CMarkup *pMarkup = Markup();        
        Assert(pMarkup);

        if (fRetval && pMarkup->_fHasFrames)
        {
            CNotification   nf;
            
            nf.BeforeUnload(pMarkup->Root(), &fRetval);        
            pMarkup->Notify(&nf);        
        }

        if (fRetval)
            fRetval = pOmWindow2->Fire_onbeforeunload();

        pOmWindow2->_fOnBeforeUnloadFiring = FALSE;
    }

    if (pDocument)
        pDocument->SetGalleryMeta(TRUE);

    DisableAutoImageResize();

    return fRetval;
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::Fire_onfocus, Fire_onblur
//
//  Synopsis:   Fires the onfocus/onblur events of the window
//
//--------------------------------------------------------------------------

void COmWindowProxy::Fire_onfocus(DWORD_PTR dwContext)
{                   
    CWindow *       pWindow = Window();

    if (pWindow->Doc()->IsPassivated())
        return;
    
    CDoc::CLock LockForm(pWindow->Doc(), FORMLOCK_CURRENT);

    FireEvent(DISPID_EVMETH_ONFOCUS, DISPID_EVPROP_ONFOCUS, _T("focus"));

    // fire for window connection points 
    pWindow->Fire_onfocus();


    // fire for accessibility, if its enabled
    IGNORE_HR(pWindow->FireAccessibilityEvents(DISPID_EVMETH_ONFOCUS));
}

void COmWindowProxy::Fire_onblur(DWORD_PTR dwContext)
{
    CWindow *       pWindow = Window();

    if (pWindow->Doc()->IsPassivated())
        return;

    CDoc::CLock LockForm(pWindow->Doc(), FORMLOCK_CURRENT);

    pWindow->Doc()->_fModalDialogInOnblur = (BOOL)dwContext;
    FireEvent(DISPID_EVMETH_ONBLUR, DISPID_EVPROP_ONBLUR, _T("blur"));

    // fire for window connection points 
    pWindow->Fire_onblur();

    // fire for accessibility, if its enabled
    IGNORE_HR(pWindow->FireAccessibilityEvents(DISPID_EVMETH_ONBLUR));

    pWindow->Doc()->_fModalDialogInOnblur = FALSE;
}

void COmWindowProxy::Fire_onbeforeprint()
{
    FireEvent(DISPID_EVMETH_ONBEFOREPRINT, DISPID_EVPROP_ONBEFOREPRINT, _T("beforeprint"));
    Window()->Fire_onbeforeprint();
}

void COmWindowProxy::Fire_onafterprint()
{
    FireEvent(DISPID_EVMETH_ONAFTERPRINT, DISPID_EVPROP_ONAFTERPRINT, _T("afterprint"));
    Window()->Fire_onafterprint();
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::CanMarshallIID
//
//  Synopsis:   Return TRUE if this iid can be marshalled.
//              Keep in sync with QI below.
//
//--------------------------------------------------------------------------

BOOL
COmWindowProxy::CanMarshalIID(REFIID riid)
{
    return (riid == IID_IUnknown ||
            riid == IID_IDispatch ||
            riid == IID_IHTMLFramesCollection2 ||
            riid == IID_IHTMLWindow2 ||
            riid == IID_IHTMLWindow3 ||
            riid == IID_IHTMLWindow4 ||
            riid == IID_IDispatchEx ||
            riid == IID_IObjectIdentity ||
            riid == IID_IServiceProvider) ? TRUE : FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::IsOleProxy
//
//  Returns:    BOOL      True if _pWindow is actually an OLE proxy.
//
//  Notes:      It performs this check by QI'ing for IClientSecurity.
//              Only OLE proxies implement this interface.
//
//----------------------------------------------------------------------------

BOOL
COmWindowProxy::IsOleProxy()
{
    BOOL                fRet = FALSE;

#ifndef WIN16       //BUGWIN16 deal with this for cross process support
    IClientSecurity *   pCL;

    if (OK(_pWindow->QueryInterface(IID_IClientSecurity, (void **)&pCL)))
    {
        ReleaseInterface(pCL);

        // Only proxy objects should support this interface.
        fRet = TRUE;
    }
#endif

    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::GetSecurityThunk
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::GetSecurityThunk(LPVOID * ppv, BOOL fPending)
{
    HRESULT                 hr = S_OK;
    CSecurityThunkSub *     pThunkSub;
    LPVOID  *               ppvSecurityThunk;


    // get the address of the variable we want to update.
    if (fPending)
    {
        ppvSecurityThunk = &_pvSecurityThunkPending;
    }
    else
    {
        ppvSecurityThunk = &_pvSecurityThunk;
    }

    if (!(*ppvSecurityThunk))
    {
        pThunkSub = new CSecurityThunkSub(this, 
                                          fPending ? CSecurityThunkSub::EnumSecThunkTypePendingWindow 
                                                   : CSecurityThunkSub::EnumSecThunkTypeWindow);
        if (!pThunkSub)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = CreateTearOffThunk(
            this,                                   // pvObject1
            (void*) s_apfnIDispatchEx,              // apfn1
            NULL,                                   // pUnkOuter
            ppvSecurityThunk,                       // ppvThunk
            pThunkSub,                              // pvObject2
            *(void **)(IUnknown*)pThunkSub,         // apfn2
            QI_MASK | ADDREF_MASK | RELEASE_MASK,   // dwMask
            g_apIID_IDispatchEx);                   // appropdescsInVtblOrder            

        if (hr)
            goto Cleanup;
    }

    // set the return value
    *ppv = *ppvSecurityThunk;

Cleanup:
    RRETURN (hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::PrivateQueryInterface
//
//  Synopsis:   Per IPrivateUnknown
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    void *  pvObject = NULL;
    HRESULT hr = S_OK;
    
    *ppv = NULL;

    if (_fTrusted && 
        (iid == IID_IUnknown || 
        iid == IID_IDispatch || 
        iid == IID_IDispatchEx))
    {
#if DBG==1
        if (_pSecureProxyForOmHack)
            return _pSecureProxyForOmHack->PrivateQueryInterface(iid, ppv);
#endif
        // create a security thunk and give its reference instead of giving this object.
        hr = GetSecurityThunk(ppv, FALSE);
        goto Cleanup;
    }
    //  else do nothing
    
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IHTMLWindow2)
        QI_INHERITS(this, IHTMLWindow3)
        QI_INHERITS(this, IHTMLWindow4)
        QI_INHERITS2(this, IHTMLFramesCollection2, IHTMLWindow2)

        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IMarshal, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        QI_TEAROFF(this, IServiceProvider, NULL);

#if DBG==1
        QI_TEAROFF(this,  IDebugWindowProxy, NULL)
#endif

        // NOTE: Any new tearoffs or inheritance classes in the QI need to have
        //       the appropriate IID placed in the COmWindowProxy::CanMarshallIID
        //       function.  This allows the marshaller/unmarshaller to actually
        //       support this object being created if any of the above interface
        //       are asked for first.  Once the object is marshalled all
        //       subsequent QI's are to the same marshalled object.

        QI_CASE(IConnectionPointContainer)
        {
            if (IsOleProxy())
            {
                // IConnectionPointerContainer interface is to the real
                // window object not this marshalled proxy.  The IUknown
                // will be this objects (for identity). 
                goto DelegateToWindow;
            }
            else
            {
                *((IConnectionPointContainer **)ppv) =
                        new CConnectionPointContainer(this, NULL);

                if (!*ppv)
                    RRETURN(E_OUTOFMEMORY);
            }
            break;
        }
            
        QI_FALLTHRU(IProvideMultipleClassInfo, IHTMLPrivateWindow2)
        QI_FALLTHRU(IProvideClassInfo, IHTMLPrivateWindow2)
        QI_FALLTHRU(IProvideClassInfo2, IHTMLPrivateWindow2)
        QI_FALLTHRU(ITravelLogClient, IHTMLPrivateWindow2)
        QI_FALLTHRU(IHTMLPrivateWindow, IHTMLPrivateWindow2)
        QI_CASE(IHTMLPrivateWindow2)
        {
DelegateToWindow:
            //
            // For these cases, just delegate on down to the real window
            // with our IUnknown.
            //
            hr = THR_NOTRACE(_pWindow->QueryInterface(iid, &pvObject));
            if (hr)
                RRETURN(hr);

            hr = THR(CreateTearOffThunk(
                    pvObject, 
                    *(void **)pvObject,
                    NULL,
                    ppv,
                    (IUnknown *)(IPrivateUnknown *)this,
                    *(void **)(IUnknown *)(IPrivateUnknown *)this,
                    1,      // Call QI on object 2.
                    NULL));

            ((IUnknown *)pvObject)->Release();
            if (!*ppv)
                RRETURN(E_OUTOFMEMORY);
            break;
        }
        
        default:
            if (DispNonDualDIID(iid))
            {
                *ppv = (IHTMLWindow2 *)this;
            }
            else if (iid == CLSID_HTMLWindowProxy)
            {
                *ppv = this; // Weak ref.
                return S_OK;
            }
            break;
    }

Cleanup:
    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        DbgTrackItf(iid, "COmWindowProxy", FALSE, ppv);
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::PrivateAddRef
//
//  Synopsis:   Per IPrivateUnknown
//
//--------------------------------------------------------------------------

ULONG
COmWindowProxy::PrivateAddRef()
{
    //
    // Transfer external references to markup.  
    //
    
    if (_ulRefs == 1 && 
        _fTrusted && 
        Window()->_pMarkup && 
        Window()->_pMarkup->Window() == this)
    {
        Window()->_pMarkup->AddRef();
    }

    return super::PrivateAddRef();
}


//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::PrivateRelease, IUnknown
//
//  Synopsis:   Private unknown Release.
//
//-------------------------------------------------------------------------

ULONG
COmWindowProxy::PrivateRelease()
{
    CMarkup * pMarkup = NULL;

    if (_ulRefs == 2 && 
        _fTrusted &&
        Window()->_pMarkup->Window() == this)
    {
        pMarkup = Window()->_pMarkup;
    }

    ULONG ret = super::PrivateRelease();

    if (pMarkup)
    {
        pMarkup->Release();
    }

    return ret;
}


//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::OnSetWindow
//
//  Synopsis:   Ref counting fixup as tree entered.
//
//-------------------------------------------------------------------------

void
COmWindowProxy::OnSetWindow()
{
    Assert(_fTrusted);

    // This is a ref from the Markup to the TWP
    super::PrivateAddRef();

    // One ref from the Markup to TWP
    // One ref from the stack
    Assert( _ulRefs >= 2 );
    Window()->_pMarkup->AddRef();
}


//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::OnClearWindow
//
//  Synopsis:   Ref counting fixup as tree exited.
//
//-------------------------------------------------------------------------

void
COmWindowProxy::OnClearWindow(CMarkup * pMarkupOld, BOOL fFromRestart /* FALSE */)
{
    CWindow * pWindow;
    CDocument *pDocument = Document();
    BOOL      fReleaseMarkup = _ulRefs > 1;

    Assert(_fTrusted);
    pWindow = Window();

    TraceTag((tagSecurity, "COmWindowProxy::OnClearWindow() - this:[0x%x] pWindow:[0x%x]", this, pWindow));

    // Kill all the timers
    pWindow->CleanupScriptTimers();  
    pWindow->KillMetaRefreshTimer();

    pWindow->ClearCachedDialogs();

    ClearInterface(&pWindow->_pBindCtx);

    if (!fFromRestart)
    {
        if (*pWindow->GetAttrArray())
        {
            (*pWindow->GetAttrArray())->FreeSpecial();
        }

        delete *GetAttrArray();
        SetAttrArray(NULL);

        if (*pDocument->GetAttrArray())
        {
            (*pDocument->GetAttrArray())->FreeSpecial();
        }
    }

    pDocument->_eHTMLDocDirection = htmlDirNotSet;
    
    GWKillMethodCall(Document(), ONCALL_METHOD(CDocument, FirePostedOnPropertyChange, firepostedonpropertychange), 0);

    pMarkupOld->TerminateLookForBookmarkTask();

    Assert(pWindow->_pMarkup == pMarkupOld);

    pWindow->_pMarkup->SubRelease();
    pWindow->_pMarkup = NULL;

    pWindow->_fNavFrameCreation = FALSE;

    super::PrivateRelease();
    if (fReleaseMarkup)
    {
        pMarkupOld->Release();
    }
}

void
CWindow::ReleaseMarkupPending(CMarkup * pMarkup)
{
    Assert(!pMarkup->_fWindow);
    Assert(pMarkup->_fWindowPending);

    // (jbeda) cover our asses here
    if (   !pMarkup->HasWindowPending() 
        || (pMarkup->GetWindowPending()->Window() != this)
        || (pMarkup->GetWindowPending()->Window()->_pMarkupPending != pMarkup))
    {
        TraceTag((tagSecurity, "CWindow::ReleaseMarkupPending inconsistent information about pending markups and windows"));
        return;
    }

    if (pMarkup->IsPendingPrimaryMarkup())
    {
        CDoc * pDoc = Doc();
        if (pDoc)
            pDoc->_fBlockNonPending = FALSE;
    }

    // handle the pending script errors without firing any events
    HandlePendingScriptErrors(FALSE);
    if (pMarkup != _pMarkupPending)
        return;

    ReleaseViewLinkedWebOC();
    if (pMarkup != _pMarkupPending)
        return;

    IGNORE_HR(pMarkup->CMarkup::UnloadContents(FALSE));
    if (pMarkup != _pMarkupPending)
        return;

    Assert(!pMarkup->_fWindow);
    Assert(pMarkup->_fWindowPending);

    Assert(  !(   pMarkup->IsPassivated()
               || pMarkup->IsPassivating())
           &&  pMarkup->GetWindowPending()->Window() == this);

    // TODO: (jbeda) this shouldn't be necessary but...
    pMarkup->_fWindow = FALSE;

    pMarkup->_fWindowPending = FALSE;
    pMarkup->DelWindow();

    pMarkup->Release();

    Assert(_pMarkupPending == pMarkup);
    _pMarkupPending = NULL;
}


BOOL    
CWindow::CanNavigate() 
{ 
    return !_ulDisableModeless && (!Doc()->_fDisableModeless && (Doc()->_ulDisableModeless == 0)); 
}

void
CWindow::EnableModelessUp( BOOL fEnable, BOOL fFirst /*=TRUE*/ )
{
    if (fEnable)
    {
        AssertSz(_ulDisableModeless > 0, "CWindow::EnableModeless(TRUE) called more than CWindow::EnableModeless(FALSE)");
        _ulDisableModeless--;

        if (_ulDisableModeless == 0)
        {
            // If we hit zero, then prop to parent
            if (_pWindowParent)
                _pWindowParent->EnableModelessUp( fEnable, FALSE );

            // If we are the first guy, kick all waiting markups
            if (fFirst)
                Doc()->NotifyMarkupsModelessEnable();
        }
    }
    else
    {
        _ulDisableModeless++;

        // first time, prop to parent
        if (_ulDisableModeless == 1 && _pWindowParent)
            _pWindowParent->EnableModelessUp( fEnable, FALSE );
    }
}

//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::SwitchMarkup
//
//  Synopsis:   Switch the current markup with the pending one.
//
//-------------------------------------------------------------------------

HRESULT
COmWindowProxy::SwitchMarkup(CMarkup * pMarkupNew,
                             BOOL      fViewLinkWebOC,          /* = FALSE */
                             DWORD     dwTravelLogFlags,        /* = 0     */
                             BOOL      fKeepSecurityIdentity,   /* = 0     */
                             BOOL      fFromRestart             /* = FALSE */)
{
    CWindow *       pWindow = NULL;
    CMarkup *       pMarkupOld = NULL;
    CElement *      pElementMaster;
    CDoc *          pDoc;
    CHtmCtx *       pHtmCtx = pMarkupNew->HtmCtx();
    HRESULT         hr = S_OK;
    htmlDesignMode  designMode;
    BOOL            fDispatchExThunkTrust;
    BOOL            fSetCurrentElementToNewRoot = FALSE;
    BOOL            fClearNewFormats = FALSE;
    BOOL            fPrimarySwitch;
    HRESULT         hrOnStopBind = S_OK;
    CBase::CLock    lock(this);  // we do this so that viewlinks don't crash
    IDispatch*      pIDispXML = NULL;
    IDispatch*      pIDispXSL = NULL;    

    TraceTag((tagSecurityContext, "COmWindowProxy::SwitchMarkup"));
    PerfDbgLog1(tagNFNav, this, "+COmWindowProxy::SwitchMarkup pWindow: %x", Window());

    if (!pMarkupNew->_fWindowPending)
        goto Cleanup;

    Assert( !pMarkupNew->_fPicsProcessPending );

    PerfDbgLog2(tagNFNav, this, "Old Markup %x \"%ls\"", pMarkupOld, pMarkupOld ? pMarkupOld->Url() : _T(""));


    pWindow = Window();

    // Work around because we should save ViewLinkedWebOC stuff on the markup
    // This is so I don't have to pass this flag through multiple levels

    pWindow->_fDelegatedSwitchMarkup = fViewLinkWebOC;

    if (pHtmCtx)
    {
        hr = pHtmCtx->GetBindResult(); 
        hrOnStopBind = pHtmCtx->GetDwnBindDataResult();
    }
    
    if (!fViewLinkWebOC || hr == INET_E_UNKNOWN_PROTOCOL)
        pWindow->ReleaseViewLinkedWebOC();

    ////////////////////////////////////////////////
    // Abort the switch if we have a bad bind result

    if (    (hr == INET_E_UNKNOWN_PROTOCOL)
        || ((hr == INET_E_TERMINATED_BIND || hr == INET_E_REDIRECT_TO_DIR)
            && !fViewLinkWebOC))
    {                   
        pMarkupNew->_fBindResultPending = TRUE;
        goto Cleanup;     
    }
    
    if (   hr == INET_E_RESOURCE_NOT_FOUND
       ||  hr == INET_E_DATA_NOT_AVAILABLE
       ||  hr == E_ACCESSDENIED 
       ||  hr == E_ABORT
       ||  pMarkupNew->_fStopDone
       ||  ( hrOnStopBind == INET_E_DOWNLOAD_FAILURE 
             && IsGlobalOffline() ) )
    {            
        pWindow->ReleaseMarkupPending(pMarkupNew);
        goto Cleanup;
    }

    pDoc       = pWindow->Doc();
	
    if (!pDoc)
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        hr = E_FAIL;
        goto Cleanup;
    }

    pMarkupOld = pWindow->_pMarkup;
    pMarkupOld->AddRef();   // ClearWindow could passivate it

    fPrimarySwitch = pWindow->IsPrimaryWindow();

    if (_fFiredOnLoad)
    {
        _fFiredOnLoad = FALSE;
        Fire_onunload();

        if (!pMarkupOld->Window() || !pMarkupNew->GetWindowPending())
        {
            // We've been reentered!
            hr = S_OK;
            goto Cleanup;
        }
    }

    // Update the travel log if we are told to do so.
    //
    if (dwTravelLogFlags & TLF_UPDATETRAVELLOG)
    {
        pDoc->UpdateTravelLog(pWindow,
                              FALSE,
                              !pMarkupNew->_fLoadingHistory,
                              !(dwTravelLogFlags & TLF_UPDATEIFSAMEURL),
                              pMarkupNew);
    }

    hr = S_OK;

    ////////////////////////////////////////////////
    ////////////////////////////////////////////////
    //
    // Start tearing down the old markup
    //
    ////////////////////////////////////////////////
    ////////////////////////////////////////////////

    // This is the latest possible point we need to apply the page transitions, because
    // the old markup will be destroyed soon. We need to do this as late as possible, because
    // we need to give the new markup a chance to parse the head section and META tags.
    // Right now SwitchMarkup is called too soon whenever there is a script block in the head
    // so META tags should come before the script tags.
    IGNORE_HR(Document()->ApplyPageTransitions(pMarkupOld, pMarkupNew));

    // TODO (alexz) SwitchMarkup causes events to fire and external code executed,
    // so it has to be called at a safce moment of time. Enable this in IE5.5 B3  (in B2 it asserts
    // all over the place)
    // AssertSz(!pMarkupNew->__fDbgLockTree, "SwitchMarkup is called when the new markup is unstable. This will lead to crashes, memory leaks, and script errors");
    // AssertSz(!pMarkupOld->__fDbgLockTree, "SwitchMarkup is called when the old markup is unstable. This will lead to crashes, memory leaks, and script errors");

    ////////////////////////////////////////////////
    // Tear down the editor for the old markup
    CMarkup* pSelectionMarkup ;
    IGNORE_HR( pDoc->GetSelectionMarkup( & pSelectionMarkup ));
    if (fPrimarySwitch || 
        pSelectionMarkup && pSelectionMarkup->GetElementTop()->IsConnectedToThisMarkup( pMarkupOld ) )
    {
        //
        // Release our edit router, however don't release the editor since this could be in iframe
        //
        if( pMarkupOld->HasEditRouter() )
        {
            pMarkupOld->GetEditRouter()->Passivate();
        }
        
        if (fPrimarySwitch || !pMarkupOld->GetParentMarkup()) // this is the topmost markup
        {
            IGNORE_HR( pDoc->NotifySelection(EDITOR_NOTIFY_DOC_ENDED, NULL) );
            pDoc->ReleaseEditor();
        }
        else
        {
            IUnknown* pUnknown = NULL;
            IGNORE_HR( pMarkupOld->QueryInterface( IID_IUnknown, ( void**) & pUnknown ));
            IGNORE_HR( pDoc->NotifySelection(EDITOR_NOTIFY_CONTAINER_ENDED, pUnknown) );
            ReleaseInterface( pUnknown );
        }
    }

    if ( fPrimarySwitch )
    {
        pDoc->_view.Unload();
        pDoc->_cDie++;
    }
    
    pDoc->FlushUndoData();

    if (fPrimarySwitch || 
        pDoc->GetCurrentMarkup() == pMarkupOld)
    {
        pDoc->_fCurrencySet = FALSE;
        pDoc->_fFirstTimeTab = IsInIEBrowser(pDoc);

        // let go of the security manager and its settings, so we can get it reset
        ClearInterface(&(pDoc->_pSecurityMgr));
    }

    

    ////////////////////////////////////////////////
    // Release nodes in old markup
    if (    pDoc->_pNodeLastMouseOver
        &&  pMarkupOld == pDoc->_pNodeLastMouseOver->GetMarkup())
        CTreeNode::ClearPtr(&pDoc->_pNodeLastMouseOver);
    if (    pDoc->_pNodeGotButtonDown
        &&  pMarkupOld == pDoc->_pNodeGotButtonDown->GetMarkup())
        CTreeNode::ClearPtr(&pDoc->_pNodeGotButtonDown);

    ////////////////////////////////////////////////
    // Reset view link info and copy over 
    // frame options
    pElementMaster = pMarkupOld->Root()->GetMasterPtr();
    if (pElementMaster)
    {
        Assert(pElementMaster->GetSlavePtr() == pMarkupOld->Root());
        hr = THR(pElementMaster->SetViewSlave(pMarkupNew->Root()));
        if (hr)
            goto Cleanup;
    }

    fSetCurrentElementToNewRoot = pDoc->_pElemCurrent->IsConnectedToThisMarkup(pMarkupOld);
    if( fSetCurrentElementToNewRoot )
    {
        pDoc->_pElemUIActive = NULL;
        pDoc->_pElemCurrent = (CElement *)pMarkupOld->Root();
        pDoc->_fCurrencySet = FALSE;
    }

    ////////////////////////////////////////////////
    // Clear the focus flag
    // Should fire window.onblur here?
    _fFiredWindowFocus = FALSE;

    fDispatchExThunkTrust = pMarkupNew->AccessAllowed(pMarkupOld);

    // VID hack (#106628) : allow initial transition from "about:blank"
    if (    !fDispatchExThunkTrust
        &&  fPrimarySwitch
        &&  pDoc->_fVID
        &&  pDoc->_fStartup
        &&  pMarkupOld->_fDesignMode
        &&  pMarkupNew->_fDesignMode
        &&  !(      pMarkupOld->HasLocationContext()
                &&  pMarkupOld->GetLocationContext()->_pchUrl
             )
       )
    {
        fDispatchExThunkTrust = TRUE;
    }


    //
    // Copy the zero grey border bit - IE5 behavior
    //
    if ( pMarkupOld->IsShowZeroBorderAtDesignTime() )
    {
        pMarkupNew->SetShowZeroBorderAtDesignTime( TRUE );
    }
    
    ////////////////////////////////////////////////
    // Actually tear down the old tree
    if( pMarkupOld->IsOrphanedMarkup() )
    {
        // Propagate the orphan-ness of the old markup 
        pMarkupNew->SetOrphanedMarkup( TRUE );
    }
    pMarkupOld->TearDownMarkup(TRUE, TRUE);   // fStop, fSwitch

    if (fPrimarySwitch && pDoc->_pInPlace && pDoc->_pInPlace->_hwnd)
    {
        ValidateRect(pDoc->_pInPlace->_hwnd, NULL);
    }

    ////////////////////////////////////////////////
    // 
    //  Important Note:  This above code can 
    //  cause this code to reenter.  We want
    //  to catch that situation and bail out
    //  of this switch.  Clear the window on
    //  the old markup just to be safe
    // 
    ////////////////////////////////////////////////
    {
        BOOL fEarlyExit = !pMarkupOld->Window() || !pMarkupNew->GetWindowPending();

        if (fEarlyExit)
        {
            // We've been reentered!
            hr = S_OK;
            goto Cleanup;
        }
    }

    ////////////////////////////////////////////////
    // Release current element
    if( fSetCurrentElementToNewRoot )
    {
        pDoc->_pElemUIActive = NULL;
        pDoc->_pElemCurrent = (CElement *) pMarkupNew->Root();  
        pDoc->_fCurrencySet = FALSE;
    }

    // We have to get the designMode before we call ClearWindow
    // because ClearWindow also clears the attrarrays on both 
    // the document and the window.
    designMode = Document()->GetAAdesignMode();

    //
    // IE6 Bug # 19870
    // MSXML has put special expandos on the document - before SwitchMarkup
    // We cache and restore these expandos....
    //
    if ( pMarkupNew->_fLoadingHistory &&
         pDoc->_fStartup &&                 // for XML/XSL viewer - doc has just been created. 
         *Document()->GetAttrArray() &&
         (*Document()->GetAttrArray())->HasExpandos() )
    {
        IGNORE_HR( Document()->GetXMLExpando( & pIDispXML, & pIDispXSL ));
    }
    

    pMarkupOld->ClearWindow(fFromRestart);

    ////////////////////////////////////////////////
    ////////////////////////////////////////////////
    //
    // Swap in the new markup!
    //
    ////////////////////////////////////////////////
    ////////////////////////////////////////////////

    pMarkupNew->_fWindowPending = FALSE;
    pMarkupNew->_fWindow = TRUE;

    if (fPrimarySwitch)
        pDoc->_fBlockNonPending = FALSE;

    // TODO: (jbeda) this if shouldn't be necessary but...
    if (!pMarkupNew->Window())
    {
        pMarkupNew->_fWindow = FALSE;
    }

    Assert(pMarkupNew->Window() == this);

    IGNORE_HR(Document()->SetAAdesignMode(designMode));


    // If either our design mode of the fact that we might inherit our
    // design mode has changed, then we must invalidate all formats (ouch).
    // This is necessary because we render differently depending on design mode.
    // We don't have to check the parent wrt inherit changing since our
    // parent isn't changing.
    if (    pMarkupNew->_fInheritDesignMode != pMarkupOld->_fInheritDesignMode 
        ||  pMarkupNew->_fDesignMode != pMarkupOld->_fDesignMode)
    {
        fClearNewFormats = TRUE;
    }

    // copy the design mode bits
    pMarkupNew->_fInheritDesignMode = pMarkupOld->_fInheritDesignMode;
    pMarkupNew->_fDesignMode = pMarkupOld->_fDesignMode;  

    pWindow->_pMarkup = pMarkupNew;
    pMarkupNew->SubAddRef();

    Assert(pWindow->_pMarkupPending == pMarkupNew);

    OnSetWindow();  // OnSetWindow will addref pMarkupNew

    pMarkupNew->UpdateSecurityID();

    if (pMarkupOld->HasCollectionCache())
    {
        CCollectionCacheItem *pCItem = pMarkupOld->CollectionCache()->GetCacheItem(CMarkup::ELEMENT_COLLECTION);
        Assert(pCItem);
        DYNCAST(CAllCollectionCacheItem, pCItem)->SetMarkup(NULL);
    }

    TraceTag((tagSecurityContext, "COmWindowProxy::SwitchMarkup - Switched markups from 0x%x to 0x%x", pMarkupOld, pMarkupNew));
    TraceTag((tagSecurityContext, "COmWindowProxy::SwitchMarkup - Reset Security Thunk is set to : %x", !fKeepSecurityIdentity && !fDispatchExThunkTrust));

    if ( pWindow->_pLicenseMgr )
    {
        ((IUnknown*) (pWindow->_pLicenseMgr))->Release();
        pWindow->_pLicenseMgr = NULL;

    }
    
    // if we are not asked to keep the security identity and 
    // the two markups are on different domains, then reset.
    if (!fKeepSecurityIdentity && !fDispatchExThunkTrust)
    {
        Document()->ResetSecurityThunk();
        ResetSecurityThunk();

        if (_pvSecurityThunkPending)
        {
            TEAROFF_THUNK *tmpThunk;
            CSecurityThunkSub *tmpThunkSub;

            _pvSecurityThunk = _pvSecurityThunkPending;
            _pvSecurityThunkPending = NULL;

            // We'll need to change the status of the SecurityThunk from Pending.
            tmpThunk = (TEAROFF_THUNK *)_pvSecurityThunk;
            tmpThunkSub = (CSecurityThunkSub *)(tmpThunk->pvObject2);
            Assert(tmpThunkSub->_dwThunkType == CSecurityThunkSub::EnumSecThunkTypePendingWindow);
            tmpThunkSub->_dwThunkType = CSecurityThunkSub::EnumSecThunkTypeWindow;
        }
    }

    pWindow->_pMarkupPending->Release();
    pWindow->_pMarkupPending = NULL;

    if (fPrimarySwitch)
    {
        LONG c;
        CStr *pcstr;

        for (pcstr = pDoc->_acstrStatus, c = STL_LAYERS; c; pcstr += 1, c -= 1)
            pcstr->Free();

        //
        // if we were fully embedded - clear the bit. 
        // 
        if ( pDoc->_fFullWindowEmbed )
        {
            pDoc->_fFullWindowEmbed = FALSE;
            pDoc->_cstrPluginCacheFilename.Free();
            pDoc->_cstrPluginContentType.Free();
        }                
        
        pDoc->_iStatusTop = STL_LAYERS;
        pDoc->_fSeenDefaultStatus = FALSE;

        pDoc->UpdateStatusText();
        pDoc->DeferUpdateUI();
        pDoc->DeferUpdateTitle(pMarkupNew);
        pDoc->Invalidate();

        // Move the SSL state over and update the host
        {
            SSL_SECURITY_STATE sss;
            SSL_PROMPT_STATE sps;

            pDoc->GetRootSslState( TRUE, &sss, &sps );

            pDoc->SetRootSslState( FALSE, sss, sps, TRUE );
        }


        if (pDoc->_pClientSite)
        {
            IGNORE_HR(pDoc->UpdateDocHostUI(TRUE));
        }
    }

    // initializes the window with any temporary dispids stored on the markup
    Verify (!pMarkupNew->InitWindow ());  

    PerfDbgLog2(tagNFNav, this, "New Markup %x \"%ls\"", pMarkupNew, pMarkupNew ? pMarkupNew->Url() : _T(""));

    pWindow->NoteNavEvent();           

    if (fClearNewFormats)
    {
        pMarkupNew->EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES|ELEMCHNG_REMEASUREALLCONTENTS);         
    }

    // Now that the markup is ready to be seen by the outside world, make sure that
    // any pending identity peer is hooked up
    if (pMarkupNew->HasIdentityPeerTask())
        pMarkupNew->ProcessIdentityPeerTask();
    
    if ( pIDispXML || pIDispXSL )
    {
        IGNORE_HR( Document()->SetXMLExpando( pIDispXML, pIDispXSL ));
    }
    
    // Hide any tooltips from the old markup
    FormsHideTooltip((DWORD_PTR)pMarkupOld);

Cleanup:

    if (pWindow)
    {
        pWindow->_fDelegatedSwitchMarkup = FALSE;
    }

    ReleaseInterface( pIDispXML );
    ReleaseInterface( pIDispXSL );

    if (pMarkupOld)
        pMarkupOld->Release();

    pMarkupNew->UnblockScriptExecutionHelper();

    PerfDbgLog(tagNFNav, this, "-COmWindowProxy::SwitchMarkup");

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::GetTypeInfoCount
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::GetTypeInfoCount(UINT FAR* pctinfo)
{
    TraceTag((tagSecurity, "GetTypeInfoCount"));

    RRETURN(_pWindow->GetTypeInfoCount(pctinfo));
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::GetTypeInfo
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo)
{
    TraceTag((tagSecurity, "GetTypeInfo"));

    RRETURN(_pWindow->GetTypeInfo(itinfo, lcid, pptinfo));
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::GetIDsOfNames
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::GetIDsOfNames(
    REFIID                riid,
    LPOLESTR *            rgszNames,
    UINT                  cNames,
    LCID                  lcid,
    DISPID FAR*           rgdispid)
{
    HRESULT hr;
    
    hr = THR(_pWindow->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid));

#ifndef WIN16
    if (OK(hr))
        goto Cleanup;

    //
    // Catch the case where the thread has already gone down.  Remember
    // that _pWindow may be a marshalled pointer to a window object.
    // In this case we want to try our own GetIDsOfNames to come up with
    // plausible responses.
    //
    
    if (WINDOWDEAD())
    {
        if (OK(super::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid)))
        {
            hr = S_OK;
            goto Cleanup;
        }
    }
Cleanup:
#endif //!WIN16    
    RRETURN(hr);
}

HRESULT
COmWindowProxy::Invoke(
    DISPID          dispid,
    REFIID,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    UINT *)
{
    return InvokeEx(dispid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    NULL);
}
//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::InvokeEx
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::InvokeEx(DISPID dispidMember,
                         LCID lcid,
                         WORD wFlags,
                         DISPPARAMS *pdispparams,
                         VARIANT *pvarResult,
                         EXCEPINFO *pexcepinfo,
                         IServiceProvider *pSrvProvider)
{
    TraceTag((tagSecurity, "Invoke dispid=0x%x", dispidMember));

    HRESULT     hr = S_OK;
    CVariant    Var;


#if DBG==1
    if (IsTagEnabled(tagSecurityProxyCheck))
    {
        // InvokeEx should only be called on secure proxy, with some exceptions
        if (_fTrusted)
        {
            // oh no!!! It is not a secure proxy! 
            // Look for known exceptions
            if (
                    dispidMember >=  DISPID_OMWINDOWMETHODS     // call from script engine
                ||  dispidMember <=  DISPID_WINDOWOBJECT        // reserved dispids aren't reacheable from script
               )
            {
                Assert(TRUE);   // benign call
            }
            else
            {
                BOOL fIgnoreThisOne = FALSE;

                if (!fIgnoreThisOne)
                {
                    AssertSz(FALSE, "COmWindowProxy::InvokeEx called on trusted proxy (shift+Ingore to debug script)");

                    // DEBUG FEATURE: deny access if verification failed and SHIFT pressed - shows the problem in script debugger
                    if (GetAsyncKeyState(VK_SHIFT) & 0x8000)
                    {
                        RRETURN(E_ACCESSDENIED);
                    }
                }
            }
        }

        AssertSz(hr == S_OK, "Failure in debug code");
    }
#endif


    //
    // In case this proxy is pointing to a viewlinked WebOC document ( such as XML document ) we
    // know that the window we want to talk to is not the _pWindow but the viewlinked window inside.
    // We try and delegate the call to the inner window first, if that fails we execute the invoke on 
    // _pWindow.
    //
    {
        IHTMLPrivateWindow2 * pPrivateWindow;
        BOOL fInnerInvoke = FALSE;

        if (S_OK == _pWindow->QueryInterface(IID_IHTMLPrivateWindow2, (void **) &pPrivateWindow))
        {
            IUnknown * pUnknown = NULL;

            if (S_OK == pPrivateWindow->GetInnerWindowUnknown(&pUnknown))
            {
                IHTMLWindow2 * pWindow = NULL;

                if (S_OK == pUnknown->QueryInterface(IID_IHTMLWindow2, (void **) &pWindow))
                {
                    IHTMLWindow2 * pWindowOut;

                    if (S_OK == SecureObject(pWindow, &pWindowOut))
                    {
                        IDispatchEx * pDispatchEx;

                        if (S_OK == pWindowOut->QueryInterface(IID_IDispatchEx, (void **) &pDispatchEx))
                        {
                            fInnerInvoke = TRUE;
                            
                            hr = THR(pDispatchEx->InvokeEx(dispidMember,
                                                           lcid,
                                                           wFlags,
                                                           pdispparams,
                                                           pvarResult,
                                                           pexcepinfo,
                                                           pSrvProvider));
                            pDispatchEx->Release();
                        }

                        pWindowOut->Release();
                    }

                    pWindow->Release();
                }

                pUnknown->Release();
            }

            pPrivateWindow->Release();
        }

        if (fInnerInvoke)
            RRETURN(hr);
    }

#if DBG==1
    // Let CWindow verify correct call sequence 
    CSecureProxyLock secureProxyLock(_pWindow, this);
#endif

    //
    // Look for known negative dispids that we can answer
    // or forward safely.
    //

    switch (dispidMember)
    {
    case DISPID_WINDOWOBJECT:
        //
        // Return a ptr to the real window object.
        //

        V_VT(pvarResult) = VT_DISPATCH;
        V_DISPATCH(pvarResult) = _pWindow;
        _pWindow->AddRef();
        hr = S_OK;
        goto Cleanup;

    case DISPID_LOCATIONOBJECT:
    case DISPID_NAVIGATOROBJECT:
    case DISPID_HISTORYOBJECT:
    case DISPID_SECURITYCTX:
    case DISPID_SECURITYDOMAIN:
        //
        // Forward these on safely.
        //

        // TODO rgardner need to QI for Ex2 & Invoke ??
        hr = THR(_pWindow->Invoke(dispidMember,
                                  IID_NULL,
                                  lcid,
                                  wFlags,
                                  pdispparams,
                                  pvarResult,
                                  pexcepinfo,
                                  NULL));
        goto Cleanup;

#if DBG==1
    case DISPID_DEBUG_ISSECUREPROXY:
        //
        // isSecureProxy - debug-only proxy property
        //
        if (pvarResult)
        {
            V_VT(pvarResult) = VT_BOOL;
            hr = THR(get_isSecureProxy((VARIANT_BOOL *)&pvarResult->iVal));
        }
        goto Cleanup;
        
    case DISPID_DEBUG_TRUSTEDPROXY:
        //
        // trustedProxy - debug-only trusted proxy access
        //
        if (pvarResult)
        {
            V_VT(pvarResult) = VT_DISPATCH;
            hr = THR(get_trustedProxy((IDispatch **)&pvarResult->pdispVal));
        }
        goto Cleanup;
    
    case DISPID_DEBUG_INTERNALWINDOW:
        //
        // internalWindow - debug-only CWindow access
        //
        if (pvarResult)
        {
            V_VT(pvarResult) = VT_DISPATCH;
            hr = THR(get_internalWindow((IDispatch **)&pvarResult->pdispVal));
        }
        goto Cleanup;

    case DISPID_DEBUG_ENABLESECUREPROXYASSERTS:
        if (pdispparams->cArgs == 1 && V_VT(&(pdispparams->rgvarg[0])) == VT_BOOL)
            hr = THR(enableSecureProxyAsserts(V_BOOL(&(pdispparams->rgvarg[0]))));
        else
            hr = E_INVALIDARG;
        goto Cleanup;
#endif

    default:
        break;
    }

    //
    // If dispid is within range for named or indexed frames
    // pass through and secure the returned object.
    //

    // Note that we don't try & verify which collection it's in - we just
    // want to know if its in any collection at all
    if ( dispidMember >= CMarkup::FRAME_COLLECTION_MIN_DISPID && 
        dispidMember <=  CMarkup::FRAME_COLLECTION_MAX_DISPID )
    {
        //
        // get the frame with the information in hand (name/index)
        //
        hr = THR(_pWindow->Invoke(dispidMember,
                                  IID_NULL,
                                  lcid,
                                  wFlags,
                                  pdispparams,
                                  &Var,
                                  pexcepinfo,
                                  NULL));
        if (!hr)
        {
            hr = THR(SecureObject(&Var, pvarResult, pSrvProvider, this, TRUE)); // fInvoked = TRUE
        }
        goto Cleanup;
    }
    
    //
    // Now try automation based invoke as long as the dispid
    // is not an expando or omwindow method dispid.
    //

    // also, disable getting in super::InvokeEx when DISPID_COmWindow_showModalDialog:
    // this will make us to invoke _pWindow directly so caller chain will be available there.

    if (!IsExpandoDISPID(dispidMember) && 
        dispidMember < DISPID_OMWINDOWMETHODS &&
        dispidMember != DISPID_CWindow_showModalDialog)
    {
        hr = THR(super::InvokeEx(dispidMember,
                                 lcid,
                                 wFlags,
                                 pdispparams,
                                 pvarResult,
                                 pexcepinfo,
                                 pSrvProvider));

        // if above failed, allow the dialogTop\Left\Width\Height properties to go through else bailout
        // Note that these std dispids are defined only for the dlg objeect and not the window object,
        // so if they fall in this range, it must be an invoke for the dialog properties
        if (!(hr && dispidMember >= STDPROPID_XOBJ_LEFT && dispidMember <= STDPROPID_XOBJ_HEIGHT))
            goto Cleanup;
    }
    
    //
    // If automation invoke also failed, then only allow the invoke to
    // pass through if the security allows it.
    // Is this too stringent?
    //

    if (AccessAllowed())
    {
        IDispatchEx *pDEX2=NULL;
        hr = THR(_pWindow->QueryInterface ( IID_IDispatchEx, (void**)&pDEX2 ));
        if ( hr )
            goto Cleanup;

        Assert(pDEX2);
        hr = THR(pDEX2->InvokeEx(dispidMember,
                                 lcid,
                                 wFlags,
                                 pdispparams,
                                 &Var,
                                 pexcepinfo,
                                 pSrvProvider));

        ReleaseInterface(pDEX2);

        if (!hr)
        {
            hr = THR(SecureObject(&Var, pvarResult, pSrvProvider, this, TRUE));  // fInvoked = TRUE
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        hr = SetErrorInfo(E_ACCESSDENIED);
    }
    
Cleanup:
    // for IE3 backward compat, map the below old dispids to their corresponding new
    // ones, on failure.
    if (hr && hr != E_ACCESSDENIED)
    {
        switch(dispidMember)
        {
        case 1:             dispidMember = DISPID_CWindow_length;
                            break;

        case 0x60020000:    dispidMember = DISPID_CWindow_name;
                            break;

        case 0x60020003:    dispidMember = DISPID_CWindow_item;
                            break;

        case 0x60020006:    dispidMember = DISPID_CWindow_location;
                            break;

        case 0x60020007:    dispidMember = DISPID_CWindow_frames;
                            break;

        default:
                            RRETURN_NOTRACE(hr);
        }

        hr = THR(super::InvokeEx(dispidMember,
                                 lcid,
                                 wFlags,
                                 pdispparams,
                                 pvarResult,
                                 pexcepinfo,
                                 pSrvProvider));
    }

    RRETURN_NOTRACE(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::GetDispID
//
//  Synopsis:   Per IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT          hr = S_OK;
    IDispatchEx *    pDispEx2 = NULL;
    BOOL             fDenied = FALSE;

    {
        IHTMLPrivateWindow2 * pPrivateWindow;
        BOOL fInnerGetDispID = FALSE;

        if (S_OK == _pWindow->QueryInterface(IID_IHTMLPrivateWindow2, (void **) &pPrivateWindow))
        {
            IUnknown * pUnknown = NULL;

            if (S_OK == pPrivateWindow->GetInnerWindowUnknown(&pUnknown))
            {
                IDispatchEx * pDispatchEx;

                if (S_OK == pUnknown->QueryInterface(IID_IDispatchEx, (void **) &pDispatchEx))
                {
                    fInnerGetDispID = TRUE;
                    
                    hr = THR(pDispatchEx->GetDispID(bstrName, grfdex, pid));

                    pDispatchEx->Release();
                }

                pUnknown->Release();
            }

            pPrivateWindow->Release();
        }

        if (fInnerGetDispID)
            RRETURN(hr);
    }

    // Cache the IDispatchEx ptr?
    hr = THR(_pWindow->QueryInterface(IID_IDispatchEx, (void **)&pDispEx2));
    if (hr)
        goto Cleanup;
        
    if ((grfdex & fdexNameEnsure) && !AccessAllowed())
    {
        //
        // If access is not allowed, don't even allow creation of an
        // expando on the remote side.
        //
        
        grfdex &= ~fdexNameEnsure;
        fDenied = TRUE;
    }

    hr = THR_NOTRACE(pDispEx2->GetDispID(bstrName, grfdex, pid));

    if (fDenied && DISP_E_UNKNOWNNAME == hr)
    {
        hr = E_ACCESSDENIED;
    }

#if DBG==1
    // DEBUG_ONLY: expose proxy's own interfaces (isSecureProxy)
    // note - this will occur even if access to window is not allowed
    if (hr && !(grfdex & fdexNameEnsure))
    {
        // TODO:alexmog: can we do anything more inteligent here?
        // debug-only, don't bother checking other flags
        if (0 == StrCmpC(bstrName, L"isSecureProxy"))
        {
            *pid = DISPID_DEBUG_ISSECUREPROXY;
            hr = S_OK;
        }
        else if (0 == StrCmpC(bstrName, L"trustedProxy"))
        {
            *pid = DISPID_DEBUG_TRUSTEDPROXY;
            hr = S_OK;
        }
        else if (0 == StrCmpC(bstrName, L"internalWindow"))
        {
            *pid = DISPID_DEBUG_INTERNALWINDOW;
            hr = S_OK;
        }
        else if (0 == StrCmpC(bstrName, L"enableSecureProxyAsserts"))
        {
            *pid = DISPID_DEBUG_ENABLESECUREPROXYASSERTS;
            hr = S_OK;
        }
    }
#endif

Cleanup:
#ifndef WIN16
    if (WINDOWDEAD())
    {
        //
        // This means the thread on the remote side has gone down.
        // Try to get out a plausible answer from CBase.  Otherwise
        // just bail.  Of course, never create an expando in such a
        // situation.
        //
        
        grfdex &= ~fdexNameEnsure;
        if (OK(super::GetDispID(bstrName, grfdex, pid)))
        {
            hr = S_OK;
        }
    }
#endif //!WIN16
    ReleaseInterface(pDispEx2);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::DeleteMember, IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::DeleteMemberByName(BSTR bstr,DWORD grfdex)
{
    return E_NOTIMPL;
}

HRESULT
COmWindowProxy::DeleteMemberByDispID(DISPID id)
{
    return E_NOTIMPL;
}



//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetMemberProperties, IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::GetMemberProperties(
                DISPID id,
                DWORD grfdexFetch,
                DWORD *pgrfdex)
{
    return E_NOTIMPL;
}


HRESULT
COmWindowProxy::GetMemberName (DISPID id, BSTR *pbstrName)
{
    HRESULT         hr;
    IDispatchEx *  pDispEx2 = NULL;
    
    // Cache the IDispatchEx ptr?
    hr = THR(_pWindow->QueryInterface(IID_IDispatchEx, (void **)&pDispEx2));
    if (hr)
        goto Cleanup;
        
    hr = THR(pDispEx2->GetMemberName(id, pbstrName));

Cleanup:
    ReleaseInterface(pDispEx2);
    RRETURN1(hr,S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::GetNextDispID
//
//  Synopsis:   Per IDispatchEx
//
//--------------------------------------------------------------------------
HRESULT
COmWindowProxy::GetNextDispID(DWORD grfdex,
                              DISPID id,
                              DISPID *prgid)
{
    HRESULT         hr;
    IDispatchEx *  pDispEx2 = NULL;
    
    // Cache the IDispatchEx ptr?
    hr = THR(_pWindow->QueryInterface(IID_IDispatchEx, (void **)&pDispEx2));
    if (hr)
        goto Cleanup;
        
    hr = THR(pDispEx2->GetNextDispID(grfdex, id, prgid));

Cleanup:
    ReleaseInterface(pDispEx2);
    RRETURN1(hr,S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::GetNameSpaceParent
//
//  Synopsis:   Per IDispatchEx
//
//--------------------------------------------------------------------------
HRESULT
COmWindowProxy::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT         hr;
    IDispatchEx *  pDEX = NULL;

    if (!ppunk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppunk = NULL;

    hr = THR(_pWindow->QueryInterface(IID_IDispatchEx, (void**) &pDEX));
    if (hr)
        goto Cleanup;
        
    hr = THR(pDEX->GetNameSpaceParent(ppunk));

#if DBG==1
    // optionally secure the window proxy given to script engine
    if (IsTagEnabled(tagSecureScriptWindow))
    {
        hr = THR(SecureProxyIUnknown(ppunk));
    }
#endif


Cleanup:
    ReleaseInterface (pDEX);
    RRETURN(hr);
}

#define IMPLEMENT_SECURE_OBJECTGET(meth)            \
    HRESULT hr = E_ACCESSDENIED;                    \
    *ppOut = NULL;                                  \
                                                    \
    if (AccessAllowed())                            \
    {                                               \
      hr = THR(_pWindow->meth(&pReal));             \
      if (SUCCEEDED(hr))                            \
      {                                             \
        *ppOut = pReal;                             \
        if (pReal)                                  \
            pReal->AddRef();                        \
      }                                             \
    }                                               \
    ReleaseInterface(pReal);                        

#define IMPLEMENT_SECURE_PROPGET(meth)              \
    HRESULT hr = E_ACCESSDENIED;                    \
    *ppOut = NULL;                                  \
                                                    \
    if (AccessAllowed())                            \
    {                                               \
       hr = THR(_pWindow->meth(ppOut));             \
    }                                               

#define IMPLEMENT_SECURE_PROPGET3(meth)             \
    HRESULT hr = E_ACCESSDENIED;                    \
    if (AccessAllowed())                            \
    {                                               \
        IHTMLWindow3 *pWin3 = NULL;                 \
        hr = THR(_pWindow->QueryInterface(IID_IHTMLWindow3, (void **)&pWin3));  \
        if (SUCCEEDED(hr))                          \
        {                                           \
          hr = THR(pWin3->meth);                    \
          ReleaseInterface(pWin3);                  \
        }                                           \
    }                                               


#define IMPLEMENT_SECURE_WINDOWGET_WITHIDCHECK(meth) \
    HRESULT             hr = S_OK;                   \
    IHTMLWindow2 *      pWindow = NULL;              \
                                                     \
    *ppOut = NULL;                                   \
    hr = THR(_pWindow->meth(&pWindow));              \
    if (hr)                                          \
        goto Cleanup;                                \
                                                     \
    hr = THR(SecureObject(pWindow,ppOut));           \
    if (hr)                                          \
        goto Cleanup;                                \
                                                     \
Cleanup:                                             \
    ReleaseInterface(pWindow);                       \
    

#define IMPLEMENT_SECURE_METHOD(meth)               \
    HRESULT hr = E_ACCESSDENIED;                    \
                                                    \
    if (AccessAllowed())                            \
    {                                               \
        hr = THR(_pWindow->meth);                   \
    }                                               


#define IMPLEMENT_SECURE_METHOD3(meth)              \
    HRESULT hr = E_ACCESSDENIED;                    \
    if (AccessAllowed())                            \
    {                                               \
        IHTMLWindow3 *pWin3 ;                       \
        hr = THR(_pWindow->QueryInterface(IID_IHTMLWindow3, (void **)&pWin3)); \
        if (SUCCEEDED(hr))                          \
        {                                           \
          hr = THR(pWin3->meth);                    \
          ReleaseInterface(pWin3);                  \
        }                                           \
    }                                               


#define IMPLEMENT_SECURE_METHOD4(meth)              \
    HRESULT hr = E_ACCESSDENIED;                    \
    if (AccessAllowed())                            \
    {                                               \
        IHTMLWindow4 *pWin4 ;                       \
        hr = THR(_pWindow->QueryInterface(IID_IHTMLWindow4, (void **)&pWin4)); \
        if (SUCCEEDED(hr))                          \
        {                                           \
          hr = THR(pWin4->meth);                    \
          ReleaseInterface(pWin4);                  \
        }                                           \
    }                                               

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::get_document
//
//  Synopsis:   Per IOmWindow
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::get_document(IHTMLDocument2 **ppOut)
{
    IHTMLDocument2 *    pReal = NULL;

    IMPLEMENT_SECURE_OBJECTGET(get_document)
    RRETURN(SetErrorInfo(hr));    
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::get_frames
//
//  Synopsis:   Per IOmWindow
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::get_frames(IHTMLFramesCollection2 ** ppOut)
{
    IHTMLFramesCollection2 *    pColl = NULL;
    HRESULT                     hr = S_OK;
    IHTMLWindow2 *              pWindow = NULL;
    IHTMLWindow2 *              pWindowOut = NULL;
    
    *ppOut = NULL;

    hr = THR(_pWindow->get_frames(&pColl));
    if (hr)
        goto Cleanup;

    hr = THR(pColl->QueryInterface(
            IID_IHTMLWindow2, (void **)&pWindow));
    if (hr)
        goto Cleanup;
      
    hr = THR(SecureObject(pWindow, &pWindowOut));
    if (hr)
        goto Cleanup;

    *ppOut = pWindowOut;

Cleanup:
    ReleaseInterface(pWindow);
    ReleaseInterface(pColl);
    RRETURN(SetErrorInfo(hr));    
}


//+----------------------------------------------------------------------------------
//
//  Member:     item
//
//  Synopsis:   object model implementation
//
//              we handle the following parameter cases:
//                  0 params:               returns IDispatch of this
//                  1 param as number N:    returns IDispatch of om window of
//                                          frame # N, or fails if doc is not with
//                                          frameset
//                  1 param as string "foo" returns the om window of the frame
//                                          element that has NAME="foo"
//
//-----------------------------------------------------------------------------------

HRESULT
COmWindowProxy::item(VARIANTARG *pvarArg1, VARIANTARG * pvarRes)
{
    HRESULT     hr = S_OK;
    CVariant    Var;

    hr = THR(_pWindow->item(pvarArg1, &Var));
    if (hr)
        goto Cleanup;

    hr = THR(SecureObject(&Var, pvarRes, NULL, this));  // fInvoked = FALSE
    if (hr)
        goto Cleanup;
        
Cleanup:
    RRETURN(SetErrorInfo(hr));    
}


//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::Get_newEnum
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
COmWindowProxy::get__newEnum(IUnknown **ppOut)
{
    IUnknown *          pReal = NULL;

    IMPLEMENT_SECURE_OBJECTGET(get__newEnum)
    RRETURN(SetErrorInfo(hr));    
}


//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::get_event
//
//  Synopsis:   Per IOmWindow
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::get_event(IHTMLEventObj **ppOut)
{
    IHTMLEventObj * pReal = NULL;

    IMPLEMENT_SECURE_OBJECTGET(get_event)
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::setTimeout
//
//  Synopsis:  Runs <Code> after <msec> milliseconds and returns a bstr <TimeoutID>
//      in case ClearTimeout is called.
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::setTimeout(
    BSTR strCode, 
    LONG lMSec, 
    VARIANT *language, 
    LONG * pTimerID)
{
    IMPLEMENT_SECURE_METHOD(setTimeout(strCode, lMSec, language, pTimerID))
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::setTimeout (w/ VARIANT pCode)
//
//  Synopsis:  Runs <Code> after <msec> milliseconds and returns a bstr <TimeoutID>
//      in case ClearTimeout is called.
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::setTimeout(
    VARIANT *pCode, 
    LONG lMSec, 
    VARIANT *language, 
    LONG * pTimerID)
{
    IMPLEMENT_SECURE_METHOD3(setTimeout(pCode, lMSec, language, pTimerID))
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::clearTimeout
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::clearTimeout(LONG timerID)
{
    IMPLEMENT_SECURE_METHOD(clearTimeout(timerID))
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::setInterval
//
//  Synopsis:  Runs <Code> every <msec> milliseconds 
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::setInterval(
    BSTR strCode, 
    LONG lMSec, 
    VARIANT *language, 
    LONG * pTimerID)
{
    IMPLEMENT_SECURE_METHOD(setInterval(strCode, lMSec, language, pTimerID))
    RRETURN(SetErrorInfo(hr));    
}

//+---------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::setInterval (w/ VARIANT pCode)
//
//  Synopsis:  Runs <Code> after <msec> milliseconds and returns a bstr <TimeoutID>
//      in case ClearTimeout is called.
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::setInterval(
    VARIANT *pCode, 
    LONG lMSec, 
    VARIANT *language, 
    LONG * pTimerID)
{
    IMPLEMENT_SECURE_METHOD3(setInterval(pCode, lMSec, language, pTimerID))
    RRETURN(SetErrorInfo(hr));    
}

//+---------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::clearInterval
//
//  Synopsis:   deletes the period timer set by setInterval
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::clearInterval(LONG timerID)
{
    IMPLEMENT_SECURE_METHOD(clearInterval(timerID))
    RRETURN(SetErrorInfo(hr));    
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::get_screen
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::get_screen(IHTMLScreen **ppOut)
{
    IHTMLScreen *   pReal = NULL;
    
    IMPLEMENT_SECURE_OBJECTGET(get_screen)
    RRETURN(SetErrorInfo(hr));    
}

//+---------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::showModalDialog
//
//  Synopsis:   Interface method to bring up a HTMLdialog given a url
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::showModalDialog(
    BSTR         bstrUrl,
    VARIANT *    pvarArgIn,
    VARIANT *    pvarOptions,
    VARIANT *    pvarArgOut)
{
    IMPLEMENT_SECURE_METHOD(showModalDialog(bstrUrl, pvarArgIn, pvarOptions, pvarArgOut))
    RRETURN(SetErrorInfo(hr));    
}


//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::alert
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

HRESULT
COmWindowProxy::alert(BSTR message)
{
    IMPLEMENT_SECURE_METHOD(alert(message))
    RRETURN(SetErrorInfo(hr));    
}

//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::confirm
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

HRESULT
COmWindowProxy::confirm(BSTR message, VARIANT_BOOL *pConfirmed)
{
    IMPLEMENT_SECURE_METHOD(confirm(message, pConfirmed))
    RRETURN(SetErrorInfo(hr));    
}


//+-------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_length
//
//  Synopsis:   object model implementation
//
//              returns number of frames in frameset of document;
//              fails if the doc does not contain frameset
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::get_length(long *ppOut)
{
    RRETURN(SetErrorInfo(_pWindow->get_length(ppOut)));
}



//+---------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::showHelp
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::showHelp(BSTR helpURL, VARIANT helpArg, BSTR features)
{
    IMPLEMENT_SECURE_METHOD(showHelp(helpURL, helpArg, features))
    RRETURN(SetErrorInfo(hr));    
}


//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::prompt
//
//  Synopsis:   Show a prompt dialog
//
//-------------------------------------------------------------------------

HRESULT
COmWindowProxy::prompt(BSTR message, BSTR defstr, VARIANT *retval)
{
    IMPLEMENT_SECURE_METHOD(prompt(message, defstr, retval))
    RRETURN(SetErrorInfo(hr));    
}


HRESULT
COmWindowProxy::toString(BSTR* String)
{
    IMPLEMENT_SECURE_METHOD(toString(String))
    RRETURN(SetErrorInfo(hr));    
};


//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_defaultStatus
//
//  Synopsis:   Retrieve the default status property
//
//-------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_defaultStatus(BSTR *ppOut)
{
    IMPLEMENT_SECURE_PROPGET(get_defaultStatus)
    RRETURN(SetErrorInfo(hr));    
}


//+-------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_status
//
//  Synopsis:   Retrieve the status property
//
//--------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_status(BSTR *ppOut)
{
    IMPLEMENT_SECURE_PROPGET(get_status)
    RRETURN(SetErrorInfo(hr));    
}


//+-------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::put_defaultStatus
//
//  Synopsis:   Set the default status property
//
//--------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: put_defaultStatus(BSTR bstr)
{
    RRETURN(SetErrorInfo(_pWindow->put_defaultStatus(bstr)));
}


//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::put_status
//
//  Synopsis:   Set the default status property
//
//-------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: put_status(BSTR bstr)
{
    RRETURN(SetErrorInfo(_pWindow->put_status(bstr)));
}


//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_Image
//
//  Synopsis:   Retrieve the image element factory
//
//-------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_Image(IHTMLImageElementFactory **ppOut)
{
    IHTMLImageElementFactory *  pReal = NULL;

    IMPLEMENT_SECURE_OBJECTGET(get_Image)
    RRETURN(SetErrorInfo(hr));    
}


//+------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_location
//
//  Synopsis:   Retrieve the location object
//-------------------------------------------------------------------------

HRESULT 
COmWindowProxy::get_location(IHTMLLocation **ppOut)
{
    HRESULT         hr = S_OK;

    if (!_pWindow)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (!ppOut)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    if (_fTrusted)
    {        
        IHTMLWindow2 * pNewWindow = NULL;

        IGNORE_HR(SecureObject(this, (IHTMLWindow2**)&pNewWindow, TRUE));

        hr =THR(pNewWindow->get_location(ppOut));

        ReleaseInterface(pNewWindow);
    }
    else
    {
        hr = THR(_Location.QueryInterface(IID_IHTMLLocation, (void **)ppOut));
    }
    
Cleanup:
    RRETURN(SetErrorInfo(hr));    
}


//+-------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_history
//
//  Synopsis:   Retrieve the history object
//
//--------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_history(IOmHistory **ppOut)
{
    IOmHistory *    pReal = NULL;

    IMPLEMENT_SECURE_OBJECTGET(get_history)
    RRETURN(SetErrorInfo(hr));    
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::close
//
//  Synopsis:   Close this windows
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: close()
{
    HRESULT hr;

    hr = THR(_pWindow->close());
#ifndef WIN16
    if (WINDOWDEAD())
    {
        hr = S_OK;
    }
#endif //!WIN16
    RRETURN(SetErrorInfo(hr));    
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::put_opener
//
//  Synopsis:   Set the opener (which window opened me) property
//
//  Notes:      This might allow the inner window to contain a
//              as it's opener a window with a bad security id.
//              However, when retrieving in get_opener, we check
//              for this and wrap it correctly.
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: put_opener(VARIANT v)
{
    RRETURN(SetErrorInfo(_pWindow->put_opener(v)));
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_opener
//
//  Synopsis:   Retrieve the opener (which window opened me) property
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::get_opener(VARIANT *pvarOut)
{
    CVariant            Real;
    HRESULT             hr;
    IHTMLWindow2 *      pWindow = NULL;

    V_VT(pvarOut) = VT_EMPTY;
    
    hr = THR(_pWindow->get_opener(&Real));
    if (hr)
        goto Cleanup;

    hr = E_FAIL;
    
    if (V_VT(&Real) == VT_UNKNOWN)
    {
        hr = THR_NOTRACE(V_UNKNOWN(&Real)->QueryInterface(
                IID_IHTMLWindow2, (void **)&pWindow));
    }
    else if (V_VT(&Real) == VT_DISPATCH)
    {
        hr = THR_NOTRACE(V_DISPATCH(&Real)->QueryInterface(
                IID_IHTMLWindow2, (void **)&pWindow));
    }

    if (hr)
    {
        //
        // Object being retrieved is not a window object.
        // Allow if the security allows it.
        //
      
        if (Real.IsEmpty() || AccessAllowed())
        {
            hr = THR(VariantCopy(pvarOut, &Real));
        }
        else
        {
            hr = SetErrorInfo(E_ACCESSDENIED);
        }
    }
    else
    {
        //
        // Object is a window object, so wrap it.
        // See note above in put_opener.
        //
        
        IHTMLWindow2 *  pWindowOut;
        
        Assert(pWindow);
        hr = THR(SecureObject(pWindow, &pWindowOut));
        if (hr)
            goto Cleanup;

        V_VT(pvarOut) = VT_DISPATCH;
        V_DISPATCH(pvarOut) = pWindowOut;
    }

Cleanup:
    ReleaseInterface(pWindow);
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_navigator
//
//  Synopsis:   Get the navigator object
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_navigator(IOmNavigator **ppOut)
{
    IOmNavigator *  pReal = NULL;

    IMPLEMENT_SECURE_OBJECTGET(get_navigator)
    RRETURN(SetErrorInfo(hr));    
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_clientInformation
//
//  Synopsis:   Get the navigator object though the client alias
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_clientInformation(IOmNavigator **ppOut)
{
    IOmNavigator *  pReal = NULL;

    IMPLEMENT_SECURE_OBJECTGET(get_clientInformation)
    RRETURN(SetErrorInfo(hr));    
}

//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::put_name
//
//  Synopsis:   Set the name property
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: put_name(BSTR bstr)
{
    RRETURN(SetErrorInfo(_pWindow->put_name(bstr)));
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_name
//
//  Synopsis:   Get the name property
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_name(BSTR *ppOut)
{
    IMPLEMENT_SECURE_PROPGET(get_name)
    RRETURN(SetErrorInfo(hr));    
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_screenTop
//
//  Synopsis:   Get the name property
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::get_screenTop(long *ppOut)
{
    IMPLEMENT_SECURE_PROPGET3(get_screenTop(ppOut));
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_screenLeft
//
//  Synopsis:   Get the name property
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::get_screenLeft(long *ppOut)
{
    IMPLEMENT_SECURE_PROPGET3(get_screenLeft(ppOut));
    RRETURN(SetErrorInfo(hr));
}

//+-------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::get_clipboardData
//
//  Synopsis:   Per IOmWindow
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::get_clipboardData(IHTMLDataTransfer **ppOut)
{
    IMPLEMENT_SECURE_PROPGET3(get_clipboardData(ppOut));
    RRETURN(SetErrorInfo(hr));
}

//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::createModelessDialog
//
//  Synopsis:   interface method, does what the name says.
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::showModelessDialog(BSTR strUrl, 
                                   VARIANT * pvarArgIn, 
                                   VARIANT * pvarOptions, 
                                   IHTMLWindow2 ** ppOut)
{
    HRESULT        hr = S_OK;
    IHTMLWindow3 * pWin3 = NULL;
    IHTMLWindow2 * pWindow=NULL;

    if (!ppOut)
        return E_POINTER;

    *ppOut = NULL;

    if (AccessAllowed())
    {
        hr = THR(_pWindow->QueryInterface(IID_IHTMLWindow3, (void **)&pWin3));
        if(hr)
            goto Cleanup;

        hr = THR(pWin3->showModelessDialog(strUrl, pvarArgIn, pvarOptions, &pWindow));
        if (hr)
            goto Cleanup;

        hr = THR(SecureObject(pWindow, ppOut));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pWindow);
    ReleaseInterface(pWin3);
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::attachEvent
//
//  Synopsis:   Attach the event
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::attachEvent(BSTR event, IDispatch* pDisp, VARIANT_BOOL *pResult)
{
    IMPLEMENT_SECURE_METHOD3(attachEvent(event, pDisp, pResult));
    RRETURN(SetErrorInfo(hr));
}
        

//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::detachEvent
//
//  Synopsis:   Detach the event
//
//---------------------------------------------------------------------------

HRESULT
COmWindowProxy::detachEvent(BSTR event, IDispatch* pDisp)
{
    IMPLEMENT_SECURE_METHOD3(detachEvent(event, pDisp));
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_parent
//
//  Synopsis:   Retrieve the parent window of this window
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::get_parent(IHTMLWindow2 **ppOut)
{
    IMPLEMENT_SECURE_WINDOWGET_WITHIDCHECK(get_parent);
    RRETURN(SetErrorInfo(hr));    
}

//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_frameElement
//
//  Synopsis:   Retrieve the frame Element that contains this window
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::get_frameElement(IHTMLFrameBase **ppOut)
{
    HRESULT             hr = E_ACCESSDENIED;
    IHTMLWindow4 *      pWindow4 = NULL;
    IHTMLWindow2 *      pProxyParent = NULL;
    CWindow *           pWindow;
    // Can we give access to the window we are pointing to ? 
    if (!AccessAllowed())
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    // if we have granted access to the window, then get the CWindow 
    // object from the IHTMLWindow2 * _pWindow
    hr = THR(_pWindow->QueryInterface( CLSID_HTMLWindow2, (void **)&pWindow));
    if (hr)
        goto Cleanup;

    Assert(pWindow);

    // Check if we have access rights to the parent window's object model.
    if (pWindow->_pWindowParent && pWindow->_pWindowParent->_pMarkup)
    {
        COmWindowProxy * pCProxy;

        // Get a secured window proxy for the parent window to check access rights.
        hr = THR(SecureObject((IHTMLWindow2*)(pWindow->_pWindowParent), &pProxyParent));
        if (hr)
            goto Cleanup;

        // get a weak ref for the COMWindowProxy within...
        hr = THR(pProxyParent->QueryInterface( CLSID_HTMLWindowProxy, (void**)&pCProxy));
        if (hr)
            goto Cleanup;

        // check security
        if (!pCProxy || !pCProxy->AccessAllowed())
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }
    }

    // We have access to the parent window too. Return the frame element pointer
    hr = THR(_pWindow->QueryInterface(IID_IHTMLWindow4, (void **)&pWindow4));
    if (hr)
        goto Cleanup;

    hr = THR(pWindow4->get_frameElement(ppOut));

Cleanup:
    ReleaseInterface(pProxyParent);
    ReleaseInterface(pWindow4);

    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Helper:     GetFullyExpandedUrl
//
//  Synopsis:   Helper method,
//              gets the fully expanded url from the calling document. 
//----------------------------------------------------------------------------

HRESULT GetFullyExpandedUrl(CBase *pBase, 
                            BSTR bstrUrl, 
                            BSTR *pbstrFullUrl, 
                            BSTR *pbstrBaseUrl = NULL,
                            IServiceProvider *pSP = NULL)
{
    HRESULT         hr = S_OK;
    CStr            cstrBaseURL;
    TCHAR           achBuf[pdlUrlLen];
    DWORD           cchBuf;
    TCHAR           achUrl[pdlUrlLen];
    ULONG           len;
    SSL_SECURITY_STATE sssCaller;
    TCHAR *         pchFinalUrl = NULL;

    if (!pbstrFullUrl)
        return E_INVALIDARG;

    if (pbstrBaseUrl)
        *pbstrBaseUrl = NULL;

    // Get the URL of the caller
    hr = THR(GetCallerSecurityStateAndURL(&sssCaller, cstrBaseURL,
                                          pBase, pSP));
    if(!SUCCEEDED(hr))
        goto Cleanup;
        
    //
    // Expand the URL before we pass it on.
    //

    len = bstrUrl ? SysStringLen(bstrUrl) : 0;

    if (len)
    {
        if (len > pdlUrlLen-1)
            len = pdlUrlLen-1;

        _tcsncpy(achUrl, bstrUrl, len);
        ProcessValueEntities(achUrl, &len);
    }

    achUrl[len] = _T('\0');

    if (cstrBaseURL.Length())
    {
        hr = THR(CoInternetCombineUrl(
                cstrBaseURL, 
                achUrl,
                URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE, 
                achBuf, 
                ARRAY_SIZE(achBuf), 
                &cchBuf, 0));
        if (hr)
            goto Cleanup;

        pchFinalUrl = achBuf;
        if (pbstrBaseUrl)
        {
            hr = THR(cstrBaseURL.AllocBSTR(pbstrBaseUrl));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        pchFinalUrl = achUrl;
    }

    // Change the URL to the fully expanded URL.
    hr = THR(FormsAllocString(pchFinalUrl, pbstrFullUrl));

Cleanup:
    if (hr && pbstrBaseUrl)
    {
        FormsFreeString(*pbstrBaseUrl);
    }

    RRETURN(hr);
}

// Determine if access is allowed to the named frame (by comparing the SID of the proxy with the SID
// of the direct parent of the target frame).
//
BOOL 
COmWindowProxy::AccessAllowedToNamedFrame(LPCTSTR pchTarget)
{
    HRESULT              hr;
    IUnknown           * pUnkTarget = NULL;
    ITargetFrame2      * pTargetFrame = NULL;
    IWebBrowser        * pWB = NULL;
    IDispatch          * pDispDoc = NULL;
    BSTR                 bstrURL = NULL;
    BOOL                 fAccessAllowed = TRUE;
    TARGET_TYPE          eTargetType;

    if (!pchTarget || !pchTarget[0])
        goto Cleanup;

    // Obtain a target frame pointer for the source window
    hr = THR(QueryService(IID_ITargetFrame2, IID_ITargetFrame2, (void**)&pTargetFrame));
    if (hr)
        goto Cleanup;

    // Find the target frame using the source window as context
    hr = THR(pTargetFrame->FindFrame(pchTarget, FINDFRAME_JUSTTESTEXISTENCE, &pUnkTarget));
    if (hr || !pUnkTarget)
        goto Cleanup;

    // Perform a cross-domain check on the pUnkTarget we've received.
    //

    // QI for IWebBrowser to determine frameness.
    //
    hr = THR(pUnkTarget->QueryInterface(IID_IWebBrowser,(void**)&pWB));
    if (hr)
        goto Cleanup;

    eTargetType = GetTargetType(pchTarget);
    if (   (eTargetType != TARGET_SEARCH)
        && (eTargetType != TARGET_MEDIA))
    {
        // Get the IDispatch of the container.  This is the containing Trident if a frameset.
        //
        hr = THR_NOTRACE(pWB->get_Container(&pDispDoc));
        if (hr || !pDispDoc)
            goto Cleanup;
    }
    else
    {
        hr = THR_NOTRACE(pWB->get_Document(&pDispDoc));
        if (hr || !pDispDoc)
            goto Cleanup;
    }

    fAccessAllowed = AccessAllowed(pDispDoc);

Cleanup:
    ReleaseInterface(pWB);
    ReleaseInterface(pDispDoc);
    ReleaseInterface(pTargetFrame);
    ReleaseInterface(pUnkTarget);
    SysFreeString(bstrURL);

    return fAccessAllowed;
}

//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::open
//
//  Synopsis:   Open a new window
//
//---------------------------------------------------------------------------

HRESULT
COmWindowProxy::open(BSTR bstrUrl,
                     BSTR bstrName,
                     BSTR bstrFeatures,
                     VARIANT_BOOL vbReplace,
                     IHTMLWindow2** ppWindow)
{
    HRESULT                 hr = S_OK;
    IHTMLWindow2 *          pWindow = NULL;
    TARGET_TYPE             eTargetType;    
    BSTR                    bstrFullUrl = NULL;
    BSTR                    bstrBaseUrl = NULL;
    IHTMLPrivateWindow3 *   pPrivWnd3 = NULL;

    if (bstrUrl && *bstrUrl)
    {
        hr = THR(GetFullyExpandedUrl(this, bstrUrl, &bstrFullUrl, &bstrBaseUrl));
        if (hr)
            goto Cleanup;
    }

    eTargetType = GetTargetType(bstrName);
    
    // If a frame name was given
    if (!_fTrustedDoc && bstrName && bstrName[0]
        && (   eTargetType == TARGET_FRAMENAME
            || eTargetType == TARGET_SEARCH
            || eTargetType == TARGET_MEDIA
           )
       )
    {
        // Determine if access is allowed to it
        if (!AccessAllowedToNamedFrame(bstrName))
        {
            CStr cstrCallerUrl;
            DWORD dwPolicy = 0;
            DWORD dwContext = 0;

            hr = THR(GetCallerURL(cstrCallerUrl, this, NULL));
            if (hr)
                goto Cleanup;

            if (    !SUCCEEDED(ZoneCheckUrlEx(cstrCallerUrl, &dwPolicy, sizeof(dwPolicy), &dwContext, sizeof(dwContext),
                              URLACTION_HTML_SUBFRAME_NAVIGATE, 0, NULL))
                ||  GetUrlPolicyPermissions(dwPolicy) != URLPOLICY_ALLOW)
            {
                hr = E_ACCESSDENIED;
                goto Cleanup;
            }
        }
    }

    *ppWindow = NULL;

    // get the IHTMLPrivateWindow3 
    hr = THR(_pWindow->QueryInterface(IID_IHTMLPrivateWindow3, (void**)&pPrivWnd3));
    if (hr)
        goto Cleanup;

    hr = THR(pPrivWnd3->OpenEx(
            bstrFullUrl ? bstrFullUrl : bstrUrl,
            bstrBaseUrl,
            bstrName, 
            bstrFeatures, 
            vbReplace, 
            &pWindow));
    if (hr)
    {
        if (hr == S_FALSE)  // valid return value
            hr = S_OK;
        else
            goto Cleanup;
    }
    
    if (pWindow)
    {
        hr = THR(SecureObject(pWindow, ppWindow));
        if (hr)
        {
            AssertSz(FALSE, "Window.open proxy: returning a secure object pointer failed");
            goto Cleanup;
        }
    }
    
Cleanup:
    ReleaseInterface(pPrivWnd3);
    ReleaseInterface(pWindow);
    FormsFreeString(bstrFullUrl);
    FormsFreeString(bstrBaseUrl);
    RRETURN(SetErrorInfo(hr));    
}

//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::print
//
//  Synopsis:   Send the print cmd to this window
//
//---------------------------------------------------------------------------

HRESULT
COmWindowProxy::print()
{
    IMPLEMENT_SECURE_METHOD3(print())
    RRETURN(SetErrorInfo(hr));    
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_self
//
//  Synopsis:   Retrieve this window
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::get_self(IHTMLWindow2**ppOut)
{
    IMPLEMENT_SECURE_WINDOWGET_WITHIDCHECK(get_self)
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_top
//
//  Synopsis:   Retrieve the topmost window from this window
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_top(IHTMLWindow2**ppOut)
{
    IMPLEMENT_SECURE_WINDOWGET_WITHIDCHECK(get_top)
    RRETURN(SetErrorInfo(hr));    
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_window
//
//  Synopsis:   Retrieve this window
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_window(IHTMLWindow2**ppOut)
{
    IMPLEMENT_SECURE_WINDOWGET_WITHIDCHECK(get_window);
    RRETURN(SetErrorInfo(hr));    
}

//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::execScript
//
//  Synopsis:   object model method implementation
//
//
//-----------------------------------------------------------------------------------

HRESULT
COmWindowProxy::execScript(BSTR bstrCode, BSTR bstrLanguage, VARIANT * pvarRet)
{
    if(_pCWindow)
    {
        BOOL fRunScript = FALSE;
        HRESULT hres = Markup()->ProcessURLAction(URLACTION_SCRIPT_RUN, &fRunScript);
        if(hres || !fRunScript)
        {
            return E_ACCESSDENIED;
        }
    }

    IMPLEMENT_SECURE_METHOD(execScript(bstrCode, bstrLanguage, pvarRet))
    RRETURN(SetErrorInfo(hr));    
}

//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::navigate
//
//  Synopsis:   Navigate to this url
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::navigate(BSTR url)
{
    HRESULT                 hr = S_OK;
    BSTR                    bstrFullUrl = NULL;
    BSTR                    bstrBaseUrl = NULL;
    IHTMLPrivateWindow2 *   pPrivateWnd = NULL;
    
    hr = THR(GetFullyExpandedUrl(this, url, &bstrFullUrl, &bstrBaseUrl));
    if (hr)
        goto Cleanup;

    // get the IHTMLPrivateWindow2 pointer to call NavigateEx
    hr = THR(_pWindow->QueryInterface( IID_IHTMLPrivateWindow2, (void**)&pPrivateWnd));
    if (hr)
        goto Cleanup;
    
    hr = THR(pPrivateWnd->NavigateEx(bstrFullUrl,
                                     NULL,
                                     NULL,
                                     bstrBaseUrl,
                                     NULL,
                                     0,
                                     CDoc::FHL_SETURLCOMPONENT | CDoc::FHL_DONTEXPANDURL));

Cleanup:
    FormsFreeString(bstrFullUrl);
    FormsFreeString(bstrBaseUrl);
    ReleaseInterface(pPrivateWnd);

    RRETURN(SetErrorInfo(hr));    
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_Option
//
//  Synopsis:   Retrieve the option element factory
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy:: get_Option(IHTMLOptionElementFactory **ppOut)
{
    IHTMLOptionElementFactory * pReal = NULL;

    IMPLEMENT_SECURE_OBJECTGET(get_Option)
    RRETURN(SetErrorInfo(hr));    
}

//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::focus
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

HRESULT
COmWindowProxy::focus()
{
    HRESULT hr;
    hr = THR(_pWindow->focus());
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::blur
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

HRESULT
COmWindowProxy::blur()
{
    HRESULT hr;
    hr = THR(_pWindow->blur());
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::focus
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

HRESULT
COmWindowProxy::get_closed(VARIANT_BOOL *p)
{
    HRESULT hr;
    
    //
    // No security check for the closed property.
    //

    hr = THR(_pWindow->get_closed(p));

    if (WINDOWDEAD())
    {
        *p = VB_TRUE;
        hr = S_OK;
    }

    RRETURN(SetErrorInfo(hr));    
}


//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::scroll
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

HRESULT
COmWindowProxy::scroll(long x, long y)
{
    IMPLEMENT_SECURE_METHOD(scroll(x, y))
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::scrollBy
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------
HRESULT
COmWindowProxy::scrollBy(long x, long y)
{
    IMPLEMENT_SECURE_METHOD(scrollBy(x, y))
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::scrollTo
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------
HRESULT
COmWindowProxy::scrollTo(long x, long y)
{
    // This method performs exactly the same action as scroll
    IMPLEMENT_SECURE_METHOD(scrollTo(x, y))
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::moveBy
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------
HRESULT
COmWindowProxy::moveBy(long x, long y)
{
    IMPLEMENT_SECURE_METHOD(moveBy(x, y))
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::moveTo
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------
HRESULT
COmWindowProxy::moveTo(long x, long y)
{
    // This method performs exactly the same action as scroll
    IMPLEMENT_SECURE_METHOD(moveTo(x, y))
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::resizeBy
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------
HRESULT
COmWindowProxy::resizeBy(long x, long y)
{
    // This method performs exactly the same action as scroll
    IMPLEMENT_SECURE_METHOD(resizeBy(x, y))
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::resizeTo
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------
HRESULT
COmWindowProxy::resizeTo(long x, long y)
{
    // This method performs exactly the same action as scroll
    IMPLEMENT_SECURE_METHOD(resizeTo(x, y))
    RRETURN(SetErrorInfo(hr));
}

HRESULT
COmWindowProxy::createPopup(VARIANT *pVarInArg, IDispatch** ppPopup)
{
    IMPLEMENT_SECURE_METHOD4(createPopup(pVarInArg, ppPopup))
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Method: COmWindowProxy : IsEqualObject
//
//  Synopsis; IObjectIdentity method implementation
//
//  Returns : S_OK if objects are equal, E_FAIL otherwise
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
COmWindowProxy::IsEqualObject( IUnknown * pUnk)
{
    HRESULT             hr = E_POINTER;
    IHTMLWindow2      * pWindow = NULL;
    IServiceProvider  * pISP = NULL;

    if (!pUnk)
        goto Cleanup;

    hr = THR_NOTRACE(pUnk->QueryInterface(IID_IServiceProvider, (void **) &pISP));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pISP->QueryService(SID_SHTMLWindow2, 
                                         IID_IHTMLWindow2,
                                         (void **) &pWindow));
    if (hr)
        goto Cleanup;

    // are the objects the same
    hr = IsSameObject(_pWindow, pWindow) ? S_OK : S_FALSE;

Cleanup:
    ReleaseInterface(pWindow);
    ReleaseInterface(pISP);
    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method : COmWindowProxy
//
//  Synopsis : IServiceProvider method Implementaion.
//
//--------------------------------------------------------------------------

HRESULT
COmWindowProxy::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    HRESULT            hr = E_POINTER;
    IServiceProvider * pISP = NULL;

    if (!ppvObject)
        goto Cleanup;

    *ppvObject = NULL;

    hr = THR_NOTRACE(_pWindow->QueryInterface(IID_IServiceProvider, (void**)&pISP));
    if (!hr)
        hr = THR_NOTRACE(pISP->QueryService(guidService, riid, ppvObject));

    ReleaseInterface(pISP);

Cleanup:
    RRETURN1(hr, E_NOINTERFACE);
}


//+---------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::ValidateMarshalParams
//
//  Synopsis:   Validates the standard set parameters that are passed into most
//              of the IMarshal methods
//
//----------------------------------------------------------------------------

HRESULT 
COmWindowProxy::ValidateMarshalParams(
    REFIID riid,
    void *pvInterface,
    DWORD dwDestContext,
    void *pvDestContext,
    DWORD mshlflags)
{
    HRESULT hr = NOERROR;
 
    if (CanMarshalIID(riid))
    {
        if ((dwDestContext != MSHCTX_INPROC && 
             dwDestContext != MSHCTX_LOCAL && 
             dwDestContext != MSHCTX_NOSHAREDMEM) ||
            (mshlflags != MSHLFLAGS_NORMAL && 
             mshlflags != MSHLFLAGS_TABLESTRONG))
        {
            Assert(0 && "Invalid argument");
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::GetUnmarshalClass
//
//  Synopsis:
//
//----------------------------------------------------------------------------

STDMETHODIMP
COmWindowProxy::GetUnmarshalClass(
    REFIID riid,
    void *pvInterface,
    DWORD dwDestContext, 
    void *pvDestContext, 
    DWORD mshlflags, 
    CLSID *pclsid)
{
    HRESULT hr;

    hr = THR(ValidateMarshalParams(
            riid, 
            pvInterface, 
            dwDestContext,
            pvDestContext, 
            mshlflags));
    if (!hr)
    {
        *pclsid = CLSID_HTMLWindowProxy;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::GetMarshalSizeMax
//
//  Synopsis:
//
//----------------------------------------------------------------------------

STDMETHODIMP
COmWindowProxy::GetMarshalSizeMax(
    REFIID riid,
    void *pvInterface,
    DWORD dwDestContext,
    void *pvDestContext,
    DWORD mshlflags,
    DWORD *pdwSize)
{
#ifdef WIN16
    return E_FAIL;
#else
    HRESULT hr;

    if (!pdwSize)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(ValidateMarshalParams(
            riid, 
            pvInterface, 
            dwDestContext,
            pvDestContext, 
            mshlflags));
    if (hr) 
        goto Cleanup;

    //
    // Size is the _cbSID + sizeof(DWORD) +
    // size of marshalling _pWindow
    //

    hr = THR(CoGetMarshalSizeMax(
            pdwSize,
            riid,
            _pWindow,
            dwDestContext,
            pvDestContext,
            mshlflags));
    if (hr)
        goto Cleanup;
        
    (*pdwSize) += sizeof(DWORD) + _cbSID;

Cleanup:
    RRETURN(hr);
#endif //ndef WIN16
}


//+---------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::MarshalInterface
//
//  Synopsis:   Write data of current proxy into a stream to read
//              out on the other side.
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::MarshalInterface(
    IStream *pStm,
    REFIID riid,
    void *pvInterface, 
    DWORD dwDestContext,
    void *pvDestContext, 
    DWORD mshlflags)
{
    HRESULT hr;

    hr = THR(ValidateMarshalParams(
            riid, 
            pvInterface, 
            dwDestContext,
            pvDestContext, 
            mshlflags));
    if (hr)
        goto Cleanup;

    //
    // Call the real worker
    //

    hr = THR(MarshalInterface(
            TRUE,
            pStm,
            riid,
            pvInterface,
            dwDestContext,
            pvDestContext,
            mshlflags));
    
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::MarshalInterface
//
//  Synopsis:   Actual worker of marshalling.  Takes an additional 
//              BOOL to signify what is actually getting marshalled,
//              the window proxy or location proxy.
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::MarshalInterface(
    BOOL fWindow,
    IStream *pStm,
    REFIID riid,
    void *pvInterface, 
    DWORD dwDestContext,
    void *pvDestContext, 
    DWORD mshlflags)
{
    HRESULT hr;

    //  Marshal _pWindow
    hr = THR(CoMarshalInterface(
            pStm,
            IID_IHTMLWindow2,
            _pWindow,
            dwDestContext,
            pvDestContext,
            mshlflags));
    if (hr)
        goto Cleanup;

    //  Write _pbSID
    hr = THR(pStm->Write(&_cbSID, sizeof(DWORD), NULL));
    if (hr)
        goto Cleanup;

    hr = THR(pStm->Write(_pbSID, _cbSID, NULL));
    if (hr)
        goto Cleanup;

    hr = THR(pStm->Write(&fWindow, sizeof(BOOL), NULL));
    if (hr)
        goto Cleanup;

    {
        BOOL fTrustedDoc = !!_fTrustedDoc; // convert from unsigned:1 to BOOL
        hr = THR(pStm->Write(&fTrustedDoc, sizeof(BOOL), NULL));
        if (hr)
            goto Cleanup;
    }

    {
        BOOL fDomainChanged = !!_fDomainChanged; // convert from unsigned:1 to BOOL
        hr = THR(pStm->Write(&fDomainChanged, sizeof(BOOL), NULL));
        if (hr)
            goto Cleanup;
    }
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::UnmarshalInterface
//
//  Synopsis:   Unmarshals the interface out of a stream
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::UnmarshalInterface(
    IStream *pStm,
    REFIID riid,
    void ** ppvObj)
{
    HRESULT         hr = S_OK;
    IHTMLWindow2 *  pWindow = NULL;
    IHTMLWindow2 *  pProxy = NULL;
    BOOL            fWindow = FALSE;
    BOOL            fTrustedDoc = FALSE;
    BOOL            fDomainChanged = FALSE;
    BYTE            abSID[MAX_SIZE_SECURITY_ID];
    DWORD           cbSID;
    
    if (!ppvObj)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppvObj = NULL;
    if (!CanMarshalIID(riid))
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    hr = THR(CoUnmarshalInterface(pStm, IID_IHTMLWindow2, (void **)&pWindow));
    if (hr)
        goto Cleanup;

    //  Read abSID
    hr = THR(pStm->Read(&cbSID, sizeof(DWORD), NULL));
    if (hr)
        goto Cleanup;

    hr = THR(pStm->Read(abSID, cbSID, NULL));
    if (hr)
        goto Cleanup;

    hr = THR(pStm->Read(&fWindow, sizeof(BOOL), NULL));
    if (hr)
        goto Cleanup;
        
    hr = THR(pStm->Read(&fTrustedDoc, sizeof(BOOL), NULL));
    if (hr)
        goto Cleanup;

    hr = THR(pStm->Read(&fDomainChanged, sizeof(DWORD), NULL));
    if (hr)
        goto Cleanup;

    
    //
    // Initialize myself with these values.  This is so the SecureObject
    // call below will know what to do.
    //

    _fTrustedDoc = !!fTrustedDoc;

    hr = THR(Init(pWindow, abSID, cbSID));
    if (hr)
        goto Cleanup;

    _fDomainChanged = !!fDomainChanged;
    //
    // Finally call SecureObject to return the right proxy.  This will
    // look in thread local storage to see if a security proxy for this
    // window already exists.  If so, it'll return that one, otherwise
    // it will create a new one with cstrSID as the security
    // context.  When OLE releases this object it will just disappear.
    //

    hr = THR(SecureObject(pWindow, &pProxy));
    if (hr)
        goto Cleanup;

    if (fWindow)
    {
        hr = THR_NOTRACE(pProxy->QueryInterface(riid, ppvObj));
    }
    else
    {
        COmWindowProxy *    pCProxy;

        Verify(!pProxy->QueryInterface(CLSID_HTMLWindowProxy, (void **)&pCProxy));
        hr = THR_NOTRACE(pCProxy->_Location.QueryInterface(riid, ppvObj));
    }
    if (hr)
        goto Cleanup;
        
Cleanup:
    ReleaseInterface(pWindow);
    ReleaseInterface(pProxy);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::ReleaseMarshalData
//
//  Synopsis:   Free up any data used while marshalling
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::ReleaseMarshalData(IStream *pStm)
{
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method:     COmWindowProxy::DisconnectObject
//
//  Synopsis:   Unmarshals the interface out of a stream
//
//----------------------------------------------------------------------------

HRESULT
COmWindowProxy::DisconnectObject(DWORD dwReserved)
{
    return S_OK;
}


class CGetLocation
{
public:
    CGetLocation(COmWindowProxy *pWindowProxy)
        { _pLoc = NULL; pWindowProxy->_pWindow->get_location(&_pLoc); }
    ~CGetLocation()
        { ReleaseInterface(_pLoc); }

    IHTMLLocation * _pLoc;
};

//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::put_offscreenBuffering
//
//  Synopsis:   Set the name property
//
//---------------------------------------------------------------------------

HRESULT 
COmWindowProxy::put_offscreenBuffering(VARIANT var)
{
    RRETURN(SetErrorInfo(_pWindow->put_offscreenBuffering(var)));
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_offscreenBuffering
//
//  Synopsis:   Get the name property
//
//---------------------------------------------------------------------------
HRESULT 
COmWindowProxy::get_offscreenBuffering(VARIANT *ppOut)
{
    // can't use IMPLEMENT_SECURE_PROPGET(get_offscreenBuffering) because of ppOut = NULL; line
    HRESULT hr = E_ACCESSDENIED;                              
                                                    
    if (AccessAllowed())                           
    {                                               
      hr = THR(_pWindow->get_offscreenBuffering(ppOut));                
    }                                               
    RRETURN(SetErrorInfo(hr));    
}


//+--------------------------------------------------------------------------
//
//  Member:     COmWindowProxy::get_external
//
//  Synopsis:   Get IDispatch object associated with the IDocHostUIHandler
//
//---------------------------------------------------------------------------
HRESULT 
COmWindowProxy::get_external(IDispatch **ppOut)
{
    IDispatch * pReal = NULL;

    IMPLEMENT_SECURE_OBJECTGET(get_external)
    RRETURN(SetErrorInfo(hr));    
}

#ifndef UNIX
//
// IEUNIX: Due to vtable pointer counts (I believe), the size is 8, not 4
//

StartupAssert(sizeof(void *) == sizeof(COmLocationProxy));
#endif

BEGIN_TEAROFF_TABLE_NAMED(COmLocationProxy, s_apfnLocationVTable)
    TEAROFF_METHOD(COmLocationProxy, QueryInterface, queryinterface, (REFIID riid, void **ppv))
    TEAROFF_METHOD_(COmLocationProxy, AddRef, addref, ULONG, ())
    TEAROFF_METHOD_(COmLocationProxy, Release, release, ULONG, ())
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD(COmLocationProxy, MarshalInterface, marshalinterface, (IStream *pistm,REFIID riid,void *pvInterface,DWORD dwDestContext,void *pvDestContext,DWORD mshlflags))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_(COmLocationProxy, IObjectIdentity)
    TEAROFF_METHOD(CCOmLocationProxy, IsEqualObject, isequalobject, (IUnknown*))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_(COmLocationProxy, IServiceProvider)
    TEAROFF_METHOD(COmLocationProxy, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::QueryInterface
//
//  Synopsis:   Per IUnknown
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::QueryInterface(REFIID iid, LPVOID * ppv)
{
    HRESULT         hr = S_OK;
    
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS2(this, IUnknown, IHTMLLocation)
        QI_TEAROFF(this, IDispatchEx, NULL)
        QI_TEAROFF(this, IObjectIdentity, NULL)
        QI_TEAROFF(this, IServiceProvider, NULL)
        QI_INHERITS(this, IHTMLLocation)
        QI_INHERITS2(this, IDispatch, IHTMLLocation)
        QI_CASE(IMarshal)
        {
            IMarshal *  pMarshal = NULL;
            
            hr = THR(MyWindowProxy()->QueryInterface(
                    IID_IMarshal,
                    (void **)&pMarshal));
            if (hr)
                RRETURN(hr);
                
            hr = THR(CreateTearOffThunk(
                    pMarshal,
                    *(void **)pMarshal,
                    NULL,
                    ppv,
                    (IHTMLLocation *)this,
                    (void *)s_apfnLocationVTable,
                    QI_MASK + ADDREF_MASK + RELEASE_MASK + METHOD_MASK(5), NULL));
            ReleaseInterface(pMarshal);
            if (hr)
                RRETURN(hr);
            break;
        }
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::GetTypeInfoCount
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::GetTypeInfoCount(UINT FAR* pctinfo)
{
    TraceTag((tagSecurity, "GetTypeInfoCount"));
    CGetLocation    cg(MyWindowProxy());
    
    if (!cg._pLoc)
        RRETURN(E_FAIL);
    
    RRETURN(cg._pLoc->GetTypeInfoCount(pctinfo));
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::GetTypeInfo
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo)
{
    TraceTag((tagSecurity, "GetTypeInfo"));

    CGetLocation    cg(MyWindowProxy());
    
    if (!cg._pLoc)
        RRETURN(E_FAIL);
    

    RRETURN(cg._pLoc->GetTypeInfo(itinfo, lcid, pptinfo));
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::GetIDsOfNames
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::GetIDsOfNames(
    REFIID                riid,
    LPOLESTR *            rgszNames,
    UINT                  cNames,
    LCID                  lcid,
    DISPID FAR*           rgdispid)
{
    CGetLocation    cg(MyWindowProxy());
    
    if (!cg._pLoc)
        RRETURN(DISP_E_UNKNOWNNAME);
    
    RRETURN(cg._pLoc->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid));
}

HRESULT
COmLocationProxy::Invoke(DISPID dispid,
                         REFIID riid,
                         LCID lcid,
                         WORD wFlags,
                         DISPPARAMS *pdispparams,
                         VARIANT *pvarResult,
                         EXCEPINFO *pexcepinfo,
                         UINT *puArgErr)
{
    return InvokeEx(dispid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    NULL);
}


HRESULT GetCallerIDispatch(IServiceProvider *pSP, IDispatch ** ppID)
{
    HRESULT             hr;
    IOleCommandTarget * pCommandTarget = NULL;
    VARIANT            Var;

    VariantInit(&Var);
    Assert(ppID);
    
    hr = THR(GetCallerCommandTarget(NULL, pSP, TRUE, &pCommandTarget));
    if (hr)
    {
        goto Cleanup;
    }

    // Get the security state
    hr = THR(pCommandTarget->Exec(
            &CGID_ScriptSite,
            CMDID_SCRIPTSITE_SECURITY_WINDOW,
            0,
            NULL,
            &Var));

    
    //in the case of pad, this command is not supported
    //so we return S_OK without setting the ppID...
    if (hr == OLECMDERR_E_NOTSUPPORTED)
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (hr)
    {
        goto Cleanup;
    }


    Assert(V_VT(&Var) == VT_DISPATCH);
    *ppID = (IDispatch *)(V_DISPATCH(&Var));

Cleanup:
    ReleaseInterface(pCommandTarget);
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::Invoke
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::InvokeEx(DISPID dispidMember,
                           LCID lcid,
                           WORD wFlags,
                           DISPPARAMS *pdispparams,
                           VARIANT *pvarResult,
                           EXCEPINFO *pexcepinfo,
                           IServiceProvider *pSrvProvider)
{
    TraceTag((tagSecurity, "Invoke dispid=0x%x", dispidMember));

    HRESULT         hr = S_OK;
    CGetLocation    cg(MyWindowProxy());
    BSTR            bstrOld = NULL;
    BSTR            bstrNew = NULL;
    BSTR            bstrBaseUrl = NULL;
    CStr            cstrSpecialURL;
    IDispatch     * pCaller = NULL;

    if (!cg._pLoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // If Access is allowed or if the invoke is for doing
    // a put on the href property, act as a pass through.
    //

    if (MyWindowProxy()->AccessAllowed() ||
        (!dispidMember && 
            wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF)) ||
        (dispidMember == DISPID_COmLocation_replace))
    {
        //
        // If this is a put_href, just expand the url correctly with
        // the base url of the caller.
        //


        if ( (!dispidMember || 
              dispidMember == DISPID_COmLocation_replace ||
              dispidMember == DISPID_COmLocation_assign ||
              dispidMember == DISPID_COmLocation_reload) &&
            pdispparams->cArgs==1 && 
            pdispparams->rgvarg[0].vt == VT_BSTR && 
            pSrvProvider )
        {
            IHTMLPrivateWindow2 * pPrivateWnd;

            bstrOld = V_BSTR(&pdispparams->rgvarg[0]);

            if (bstrOld)
            {
                hr = THR(GetFullyExpandedUrl(NULL, bstrOld, &bstrNew, &bstrBaseUrl, pSrvProvider));
                if (hr)
                    goto Cleanup;

                V_BSTR(&pdispparams->rgvarg[0]) = bstrNew;

                // get the IHTMLPrivateWindow2 pointer to call NavigateEx
                hr = THR(MyWindowProxy()->_pWindow->QueryInterface( IID_IHTMLPrivateWindow2, (void**)&pPrivateWnd));
                if (hr)
                    goto Cleanup;
    
                hr = THR(pPrivateWnd->NavigateEx(bstrNew, 
                                                 V_BSTR(&pdispparams->rgvarg[0]), 
                                                 NULL, 
                                                 bstrBaseUrl, 
                                                 NULL, (DWORD)(dispidMember == DISPID_COmLocation_replace),
                                                 CDoc::FHL_SETURLCOMPONENT | 
                                                 (dispidMember == DISPID_COmLocation_replace ? CDoc::FHL_REPLACEURL : 0 ) ));

                ReleaseInterface(pPrivateWnd);
            }
        }
        
        // if the call was not handled in the above if statement, then use the invoke        
        if ((!bstrOld || !bstrNew))
        {
            if (pSrvProvider)
                hr = GetCallerIDispatch(pSrvProvider, &pCaller);

            if (!pCaller || MyWindowProxy()->AccessAllowed(pCaller))
            {
                hr = THR(cg._pLoc->Invoke(
                        dispidMember,
                        IID_NULL,
                        lcid,
                        wFlags,
                        pdispparams,
                        pvarResult,
                        pexcepinfo,
                        NULL));
            }
            else 
            {
                hr = E_ACCESSDENIED;
            }
        }

        if (hr)
            hr = MyWindowProxy()->SetErrorInfo(hr);
    }
    else
    {
        //
        // Deny access otherwise.  
        // CONSIDER: Is this too stringent?
        //

        hr = MyWindowProxy()->SetErrorInfo(E_ACCESSDENIED);
    }
    
Cleanup:
    if (bstrOld || bstrNew)
    {
        // replace the original arg - supposed top be [in] parameter only
        V_BSTR(&pdispparams->rgvarg[0]) = bstrOld;
    }
    FormsFreeString(bstrNew);
    FormsFreeString(bstrBaseUrl);
    ReleaseInterface(pCaller);
    RRETURN_NOTRACE(hr);
}


HRESULT
COmLocationProxy::GetMemberName (DISPID id, BSTR *pbstrName)
{
    HRESULT         hr;
    IDispatchEx *  pDispEx2 = NULL;
    CGetLocation    cg(MyWindowProxy());
    
    if (!cg._pLoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    hr = THR(cg._pLoc->QueryInterface(IID_IDispatchEx, (void **)&pDispEx2));
    if (hr)
        goto Cleanup;
        
    hr = THR_NOTRACE(pDispEx2->GetMemberName(id, pbstrName));
            
Cleanup:
    ReleaseInterface(pDispEx2);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::GetDispID
//
//  Synopsis:   Per IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT         hr;
    IDispatchEx *  pDispEx2 = NULL;
    CGetLocation    cg(MyWindowProxy());
    
    if (!cg._pLoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    hr = THR(cg._pLoc->QueryInterface(IID_IDispatchEx, (void **)&pDispEx2));
    if (hr)
        goto Cleanup;
        
    hr = THR_NOTRACE(pDispEx2->GetDispID(bstrName, grfdex, pid));
            
Cleanup:
    ReleaseInterface(pDispEx2);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CBase::DeleteMember, IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::DeleteMemberByName(BSTR bstr,DWORD grfdex)
{
    return E_NOTIMPL;
}

HRESULT
COmLocationProxy::DeleteMemberByDispID(DISPID id)
{
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CBase::GetMemberProperties, IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::GetMemberProperties(
                DISPID id,
                DWORD grfdexFetch,
                DWORD *pgrfdex)
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::GetNextDispID
//
//  Synopsis:   Per IDispatchEx
//
//--------------------------------------------------------------------------
HRESULT
COmLocationProxy::GetNextDispID(DWORD grfdex,
                     DISPID id,
                     DISPID *prgid)
{
    HRESULT         hr;
    IDispatchEx *  pDispEx2 = NULL;
    CGetLocation    cg(MyWindowProxy());
    
    if (!cg._pLoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    // Cache the IDispatchEx ptr?
    hr = THR(cg._pLoc->QueryInterface(IID_IDispatchEx, (void **)&pDispEx2));
    if (hr)
        goto Cleanup;
        
    hr = THR(pDispEx2->GetNextDispID(grfdex, id, prgid));

Cleanup:
    ReleaseInterface(pDispEx2);
    RRETURN1(hr,S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::GetNameSpaceParent
//
//  Synopsis:   Per IDispatchEx
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT         hr;
    IDispatchEx *  pDEX = NULL;
    CGetLocation    cg(MyWindowProxy());
    
    if (!cg._pLoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!ppunk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppunk = NULL;

    Verify (!THR(cg._pLoc->QueryInterface(IID_IDispatchEx, (void**) &pDEX)));

    hr = THR(pDEX->GetNameSpaceParent(ppunk));

Cleanup:
    ReleaseInterface (pDEX);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::MarshalInterface
//
//  Synopsis:   Write data of current proxy into a stream to read
//              out on the other side.
//
//----------------------------------------------------------------------------

HRESULT
COmLocationProxy::MarshalInterface(
    IStream *pStm,
    REFIID riid,
    void *pvInterface, 
    DWORD dwDestContext,
    void *pvDestContext, 
    DWORD mshlflags)
{
    HRESULT hr;

    hr = THR(MyWindowProxy()->ValidateMarshalParams(
            riid, 
            pvInterface, 
            dwDestContext,
            pvDestContext, 
            mshlflags));
    if (hr)
        goto Cleanup;

    //
    // Call the real worker
    //

    hr = THR(MyWindowProxy()->MarshalInterface(
            FALSE,
            pStm,
            riid,
            pvInterface,
            dwDestContext,
            pvDestContext,
            mshlflags));
    
Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Method: COmLocationProxy : IsEqualObject
//
//  Synopsis; IObjectIdentity method implementation
//
//  Returns : S_OK if objects are equal, E_FAIL otherwise
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
COmLocationProxy::IsEqualObject( IUnknown * pUnk)
{
    HRESULT          hr = E_POINTER;
    IServiceProvider *pISP = NULL;
    IHTMLLocation    *pShdcvwLoc = NULL;
    CGetLocation     cg(MyWindowProxy());

    if (!pUnk || !cg._pLoc)
        goto Cleanup;

    hr = THR_NOTRACE(pUnk->QueryInterface(IID_IServiceProvider, (void**)&pISP));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pISP->QueryService(SID_SOmLocation, 
                                        IID_IHTMLLocation,
                                        (void**)&pShdcvwLoc));
    if (hr)
        goto Cleanup;

    // are the unknowns equal?
    hr = (IsSameObject(pShdcvwLoc, cg._pLoc)) ? S_OK : S_FALSE;

Cleanup:
    ReleaseInterface(pShdcvwLoc);
    ReleaseInterface(pISP);
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method : COmLocationProxy
//
//  Synopsis : IServiceProvider methoid Implementaion.
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    HRESULT hr = E_POINTER;

    if (!ppvObject)
        goto Cleanup;

    *ppvObject = NULL;

    if ( guidService == SID_SOmLocation)
    {
        CGetLocation    cg(MyWindowProxy());

        if (!cg._pLoc)
        {
            hr = E_FAIL;
        }
        else
        {
            hr = THR_NOTRACE(cg._pLoc->QueryInterface(riid, ppvObject));
        }
    }
    else
        hr = E_NOINTERFACE;

Cleanup:
    RRETURN1(hr, E_NOINTERFACE);
}

//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::put_href
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::put_href(BSTR bstr)
{
    CGetLocation    cg(MyWindowProxy());
    HRESULT         hr;
    
    if (!cg._pLoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    // Expand the URL using the base HREF of the caller

    //
    // Always allow puts on the href to go thru for netscape compat.
    //
    
    hr = THR(cg._pLoc->put_href(bstr));
    
Cleanup:
    RRETURN(MyWindowProxy()->SetErrorInfo(hr));
}


#define IMPLEMENT_SECURE_LOCATION_METH(meth)        \
    HRESULT         hr = S_OK;                      \
    CGetLocation    cg(MyWindowProxy());            \
                                                    \
    if (!cg._pLoc)                                  \
    {                                               \
        hr = E_FAIL;                                \
        goto Cleanup;                               \
    } \
    hr = MyWindowProxy()->AccessAllowed() ?         \
            cg._pLoc->meth(bstr) :                  \
            E_ACCESSDENIED;                         \
Cleanup:                                            \
    return MyWindowProxy()->SetErrorInfo(hr);       \



  
//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::get_href
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::get_href(BSTR *bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(get_href)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::put_protocol
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::put_protocol(BSTR bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(put_protocol)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::get_protocol
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::get_protocol(BSTR *bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(get_protocol)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::put_host
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::put_host(BSTR bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(put_host)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::get_host
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::get_host(BSTR *bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(get_host)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::put_hostname
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::put_hostname(BSTR bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(put_hostname)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::get_hostname
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::get_hostname(BSTR *bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(get_hostname)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::put_port
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::put_port(BSTR bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(put_port)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::get_port
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::get_port(BSTR *bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(get_port)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::get_pathname
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::get_pathname(BSTR *bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(get_pathname)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::put_pathname
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::put_pathname(BSTR bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(put_pathname)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::get_search
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::get_search(BSTR *bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(get_search)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::put_search
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::put_search(BSTR bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(put_search)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::put_hash
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::put_hash(BSTR bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(put_hash)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::get_hash
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::get_hash(BSTR *bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(get_hash)
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::reload
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::reload(VARIANT_BOOL flag)
{
    CGetLocation    cg(MyWindowProxy());
    HRESULT         hr = S_OK;
    
    if (!cg._pLoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = MyWindowProxy()->AccessAllowed() ? 
            cg._pLoc->reload(flag) : E_ACCESSDENIED;

Cleanup:
    RRETURN(MyWindowProxy()->SetErrorInfo(hr));
}


//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::replace
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::replace(BSTR bstr)
{
    CGetLocation    cg(MyWindowProxy());
    HRESULT         hr = S_OK;
    
    if (!cg._pLoc)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(cg._pLoc->replace(bstr));

Cleanup:
    RRETURN(MyWindowProxy()->SetErrorInfo(hr));
}

//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::assign
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::assign(BSTR bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(assign)
}

//+-------------------------------------------------------------------------
//
//  Method:     COmLocationProxy::toString
//
//  Synopsis:   Per IHTMLLocation
//
//--------------------------------------------------------------------------

HRESULT
COmLocationProxy::toString(BSTR * bstr)
{
    IMPLEMENT_SECURE_LOCATION_METH(toString)
}

//****************************************************************************
//
//  sub* IDispatchEx methods.
//
//****************************************************************************

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subGetTypeInfoCount(UINT FAR* pctinfo)
{
    RRETURN(GetTypeInfoCount(pctinfo));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subGetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo)
{
    RRETURN(GetTypeInfo(itinfo, lcid, pptinfo));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subGetIDsOfNames(
    REFIID                riid,
    LPOLESTR *            rgszNames,
    UINT                  cNames,
    LCID                  lcid,
    DISPID FAR*           rgdispid)
{
    RRETURN(GetIDsOfNames( riid, rgszNames, cNames, lcid, rgdispid));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subInvoke(
    DISPID          dispid,
    REFIID          riid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    UINT *          puArgErr)
{
    RRETURN(Invoke(dispid, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subGetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    RRETURN(GetDispID(bstrName, grfdex, pid));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subInvokeEx(DISPID dispidMember,
                         LCID lcid,
                         WORD wFlags,
                         DISPPARAMS *pdispparams,
                         VARIANT *pvarResult,
                         EXCEPINFO *pexcepinfo,
                         IServiceProvider *pSrvProvider)
{
    RRETURN(InvokeEx(dispidMember, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subDeleteMemberByName(BSTR bstr,DWORD grfdex)
{
    RRETURN(DeleteMemberByName(bstr, grfdex));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subDeleteMemberByDispID(DISPID id)
{
    RRETURN(DeleteMemberByDispID(id));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subGetMemberProperties(
                DISPID id,
                DWORD grfdexFetch,
                DWORD *pgrfdex)
{
    RRETURN(GetMemberProperties( id, grfdexFetch, pgrfdex));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subGetMemberName (DISPID id, BSTR *pbstrName)
{
    RRETURN(GetMemberName(id, pbstrName));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subGetNextDispID(DWORD grfdex,
                              DISPID id,
                              DISPID *prgid)
{
    RRETURN(GetNextDispID(grfdex, id, prgid));
}

//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
HRESULT
COmWindowProxy::subGetNameSpaceParent(IUnknown **ppunk)
{
    RRETURN(GetNameSpaceParent(ppunk));
}


#if DBG==1
//  
//  COmWindowProxy::get_isSecureProxy -- IDebugWindowProxy
//
//  debug-only read-only boolean property
//
HRESULT
COmWindowProxy::get_isSecureProxy(VARIANT_BOOL * p)
{
    if (!p)
        return E_INVALIDARG;
    
    if (_fTrusted)
        *p = VB_FALSE;
    else
        *p = VB_TRUE;

    return S_OK;
}

//  
//  COmWindowProxy::get_trustedProxy -- IDebugWindowProxy
//
// debug-only trusted proxy access
//
HRESULT
COmWindowProxy::get_trustedProxy(IDispatch ** p)
{
    if (!p)
        return E_INVALIDARG;
     *p = NULL;
    
    CWindow *pCWindow;
    HRESULT hr = _pWindow->QueryInterface(CLSID_HTMLWindow2, (void**)&pCWindow);
    if (hr == S_OK && pCWindow && pCWindow->_pWindowProxy)
    {
        hr = pCWindow->_pWindowProxy->QueryInterface(IID_IHTMLWindow2, (void**)p);
    }

    return hr;
}

//  
//  COmWindowProxy::get_internalWindow -- IDebugWindowProxy
//
//  debug-only unsafe CWindow access
//
HRESULT
COmWindowProxy::get_internalWindow(IDispatch ** p)
{
    if (!p)
        return E_INVALIDARG;
    *p = NULL;

    IHTMLWindow2 *pWindow2;
    HRESULT hr = _pWindow->get_window(&pWindow2);
    if (hr == S_OK)
    {
        *p = (IDispatch *)pWindow2;
    }

    return hr;
}

//  
//  COmWindowProxy::enableSecureProxyAsserts -- IDebugWindowProxy
//
//  debug-only read-only boolean property
//
HRESULT
COmWindowProxy::enableSecureProxyAsserts(VARIANT_BOOL vbEnable)
{
    BOOL fEnable = (vbEnable != VB_FALSE);
    
    EnableTag(tagSecurityProxyCheck, fEnable);
    EnableTag(tagSecurityProxyCheckMore, fEnable);
    EnableTag(tagSecureScriptWindow, fEnable);
    
    return S_OK;
}

//
// COmWindowProxy::CSecureProxyLock - must be set by a secure proxy before calling
// sript-accessible methods on CWindow (such as CWindow::Invoke) 
//
COmWindowProxy::CSecureProxyLock::CSecureProxyLock(IUnknown *pUnkWindow, COmWindowProxy *pProxy)
{
    _pWindow = NULL;
    
    if (S_OK == pUnkWindow->QueryInterface(IID_IDebugWindow, (void**)&_pWindow))
    {
        _pWindow->SetProxyCaller((IUnknown*)(void*)(IPrivateUnknown *) pProxy);
    }
}

COmWindowProxy::CSecureProxyLock::~CSecureProxyLock()
{
    if (_pWindow)
    {
        _pWindow->SetProxyCaller(NULL);
        _pWindow->Release();
    }
}

// helper
BOOL IsThisASecureProxy(IUnknown *punk)
{
    VARIANT vSecure = {VT_BOOL, VB_FALSE};
    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
    IDispatch *pdisp = NULL;
    
    if (S_OK == punk->QueryInterface(IID_IDispatch, (void **)&pdisp))
    {
        IGNORE_HR(pdisp->Invoke(DISPID_DEBUG_ISSECUREPROXY,
                                IID_NULL,
                                LCID_SCRIPTING,
                                DISPATCH_PROPERTYGET,
                                &dispparamsNoArgs,
                                &vSecure, NULL, NULL));
        pdisp->Release();
    }
    else
        Assert(FALSE);

    return V_BOOL(&vSecure) == VB_TRUE;
}

//
// secure a window proxy given its IDispatch
//
HRESULT COmWindowProxy::SecureProxyIUnknown(/*in, out*/IUnknown **ppunkProxy)
{
    IHTMLWindow2 *pw2Trusted;
    IHTMLWindow2 *pw2Secured;
    HRESULT hr = E_FAIL;

    if (ppunkProxy == NULL || *ppunkProxy == NULL)
        return S_OK;

    // check if it already secure
    if (IsThisASecureProxy(*ppunkProxy))
        return S_OK;
 
    if (S_OK == (hr = (*ppunkProxy)->QueryInterface(IID_IHTMLWindow2, (void **)&pw2Trusted)))
    {
        if (S_OK == (hr = SecureObject(pw2Trusted, &pw2Secured)))
        {
            (*ppunkProxy)->Release();
            (*ppunkProxy) = pw2Secured;
        }
        pw2Trusted->Release();
    }

    // Assert it is now actually secure
    AssertSz(IsThisASecureProxy(*ppunkProxy), "Failed to secure proxy");

    return hr;
}

void COmWindowProxy::DebugHackSecureProxyForOm(COmWindowProxy *pProxy)
{
    // No nesting or anything. hacks don't have to be robust
    Assert(pProxy == NULL || _pSecureProxyForOmHack == NULL);
    _pSecureProxyForOmHack = pProxy;
}

#endif // DBG==1

//----------------------------------------------------------------------------
// Checks if pMarkup can initiate navigation to pchurltarget.  Determines this
// by checking if pchurltarget is in the MyComputer zone and pMarkup is in
// the internet or restricted zone.  If pchurlcontext is provided, that will
// be used instead of pMarkup.
//----------------------------------------------------------------------------
BOOL
COmWindowProxy::CanNavigateToUrlWithLocalMachineCheck(CMarkup *pMarkup, LPCTSTR pchurlcontext,
                                                      LPCTSTR pchurltarget)
{
    // These are secure defaults, don't change unless for a good reason!
    HRESULT hr = E_ACCESSDENIED;
    BOOL bCanNavigate = FALSE;
    DWORD dwZoneIDSource = URLZONE_UNTRUSTED;
    DWORD dwZoneIDTarget = URLZONE_LOCAL_MACHINE;
    LPCTSTR pchurlsource = NULL;
    CMarkup *pWindowedMarkupContext = NULL;
    CDoc *pDoc = pMarkup->Doc();

    // Check the DOCHOSTUI flags.
    if (!(pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_LOCAL_MACHINE_ACCESS_CHECK))
    {
        bCanNavigate = TRUE;
        goto Cleanup;
    }

    // Check the registry option setting.
    if (!pDoc->_pOptionSettings->fLocalMachineCheck)
    {
        bCanNavigate = TRUE;
        goto Cleanup;
    }

    // Get the windowed markup context.
    pWindowedMarkupContext = pMarkup->GetWindowedMarkupContext();
    if (!pWindowedMarkupContext)
    {
        bCanNavigate = FALSE;
        goto Cleanup;
    }

    // Check if this is print media.
    if (pWindowedMarkupContext->IsPrintMedia())
    {
        bCanNavigate = TRUE;
        goto Cleanup;
    }

    // Set the source url, this is the initiator of the navigation.
    pchurlsource = pchurlcontext ? pchurlcontext : pWindowedMarkupContext->Url();
    if (!pchurlcontext && (!pchurlsource  || IsSpecialUrl(pchurlsource)))
    {
        // If the markup is a special url, get the creator url.
        pchurlsource = pWindowedMarkupContext->GetAAcreatorUrl();
    }

    // Get the security manager.
    pWindowedMarkupContext->Doc()->EnsureSecurityManager();
    IInternetSecurityManager *pSecMgr = pWindowedMarkupContext->GetSecurityManager();

    // Get the security zone for the initiating url.
    if (!pchurlsource || IsSpecialUrl(pchurlsource))
    {
        // Treat special urls as restricted.
        dwZoneIDSource = URLZONE_UNTRUSTED;
    }
    else if (!pchurlcontext && pWindowedMarkupContext->HasWindowPending() &&
             pWindowedMarkupContext->GetWindowPending()->Window()->_fRestricted)
    {
        // If there is no urlcontext specified, honor the restricted bit.
        dwZoneIDSource = URLZONE_UNTRUSTED;
    }
    else if (!SUCCEEDED(hr = pSecMgr->MapUrlToZone(pchurlsource, &dwZoneIDSource, 0)))
    {
        // If MapUrlToZone fails, treat the url as restricted.
        dwZoneIDSource = URLZONE_UNTRUSTED;
    }

    // Get the security zone for the target url.

    DWORD   cchWindowUrl = pdlUrlLen;
    TCHAR   achWindowUrl[pdlUrlLen];

    hr = UrlCanonicalize(
            pchurltarget,
            (LPTSTR) achWindowUrl,
            &cchWindowUrl,
            URL_FILE_USE_PATHURL);
    
    if(FAILED(hr) || (!SUCCEEDED(hr = pSecMgr->MapUrlToZone(achWindowUrl, &dwZoneIDTarget, 0))))
    {
        // If MapUrlToZone fails, treat the url as MyComputer.  This is safe.
        dwZoneIDTarget = URLZONE_LOCAL_MACHINE;
    }

    // Check if there is a zone elevation.
    if ((dwZoneIDSource != URLZONE_INTERNET &&
         dwZoneIDSource != URLZONE_UNTRUSTED) ||
        dwZoneIDTarget != URLZONE_LOCAL_MACHINE)
    {
        // There is no zone elevation.
        bCanNavigate = TRUE;
        goto Cleanup;
    }
    else
    {
        // There is zone elevation.
        bCanNavigate = FALSE;
        goto Cleanup;
    }

Cleanup:
    return bCanNavigate;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\saver.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       Saver.cxx
//
//  Contents:   Object to save to a stream
//
//  Class:      CTreeSaver
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#ifndef X_SAVER_HXX_
#define X_SAVER_HXX_
#include "saver.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_COMMENT_HXX_
#define X_COMMENT_HXX_
#include "comment.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif


MtDefine(CTreeSaver, Locals, "CTreeSaver")

//+---------------------------------------------------------------
//
//  Member:     CTreeSaver constructor from element
//
//  Synopsis:   Construct a range saver object for saving everything
//              under a specified element.  This is the normal case.
//
//---------------------------------------------------------------

CTreeSaver::CTreeSaver(CElement* pelToSave, CStreamWriteBuff * pswb, CElement * pelContainer /* = NULL */) :
        _mpStart( pelToSave->GetDocPtr() ), _mpEnd( pelToSave->GetDocPtr() )
{
    CTreePos * ptpStart, * ptpEnd;

    _pMarkup        = pelToSave->GetMarkup();

    pelToSave->GetTreeExtent( & ptpStart, & ptpEnd );

    Assert( ptpStart && ptpEnd );

    Verify( ! _tpgStart.MoveTo( ptpStart, TPG_RIGHT ) );
    Verify( ! _tpgEnd.MoveTo( ptpEnd, TPG_LEFT ) );
    Verify( ! _tpgEnd.MoveLeft( TPG_VALIDGAP | TPG_OKNOTTOMOVE ) );

    _pelFragment  = pelToSave;
    _pswb         = pswb;
    _fSymmetrical = FALSE;
    _fLBStartLeft = FALSE;
    _fSaveTextFrag= FALSE;
    _fLBEndLeft   = !!LineBreakChar( &_tpgEnd );
    _pelContainer = pelContainer;

    _mpStart.SetGravity( POINTER_GRAVITY_Left );
    _mpEnd.SetGravity( POINTER_GRAVITY_Right );
}


//+----------------------------------------------------------------------------
//  
//  Method:     CTreeSaver
//  
//  Synopsis:   Constructor from markup.  Only used by range saver
//  
//+----------------------------------------------------------------------------

CTreeSaver::CTreeSaver( CMarkup * pMarkup ) : 
    _mpStart( pMarkup->Doc() ), _mpEnd( pMarkup->Doc() )
{ 
    _fSaveTextFrag = FALSE; 
    _mpStart.SetGravity(POINTER_GRAVITY_Left); 
    _mpEnd.SetGravity(POINTER_GRAVITY_Right);
}

//+---------------------------------------------------------------
//
//  Member:     CTreeSaver::Save
//
//  Synopsis:   Dump our guts to the stream _pswb.
//
//---------------------------------------------------------------

MtDefine(CTreeSaver_aryElements_pv, Locals, "CTreeSaver::Save aryElements::_pv");
HRESULT
CTreeSaver::Save()
{
    HRESULT     hr = S_OK;
    CTreePos *  ptpWalk, * ptpAfterEnd, *ptpEnd, *ptpNext;
    CElement *  pelPendingForce = NULL;
    CElement *  pel;
    BOOL        fSelectionEndSaved = FALSE;
    BOOL        fSuppressingPrettyCRLF = FALSE;
    BOOL        fSeenContent = FALSE;
    MarkupTextFrag *ptf = NULL;
    long            ctf = 0;

    Assert( _tpgStart.Branch()->SearchBranchToRootForScope( _pelFragment ) );
    Assert( _tpgEnd.Branch()->SearchBranchToRootForScope( _pelFragment ) );

    if (_pelFragment && _pelFragment->Doc()->_fContentSavePeersPossible)
    {
        hr = THR( SaveGapsToPointers() );
        if( hr )
            goto Cleanup;

        hr = THR(CPeerHolder::ContentSavePass(this, _pswb->TestFlag(WBF_SAVE_PLAINTEXT)));
        if (hr)
            goto Cleanup;

        hr = THR( RestoreGapsFromPointers() );
        if( hr )
            goto Cleanup;
    }

    // If we are saving out text frags, then we must be starting at the beginning of the 
    // markup.  To change this later, we would need to search in the text frag list to
    // find the correct place to start.
    Assert( !_fSaveTextFrag || _tpgStart.AdjacentTreePos( TPG_LEFT ) == _pMarkup->FirstTreePos() );

    //
    // Initialize saver state
    //

    _pelLastBlockScope = NULL;
    _fPendingNBSP      = FALSE;

    if(     _fSaveTextFrag 
        &&  _pMarkup->HasTextFragContext() 
        &&  ! _pswb->TestFlag(WBF_SAVE_PLAINTEXT)
        &&  ! _pswb->TestFlag(WBF_FOR_RTF_CONV) )
    {
        CMarkupTextFragContext * ptfc = _pMarkup->GetTextFragContext();

        Assert( ptfc );

        ctf = ptfc->_aryMarkupTextFrag.Size();
        ptf = ptfc->_aryMarkupTextFrag;
    }

    //
    // If we are symmetrical then we want to save begin tags
    // from under the _pelFragment down to the node above _ptpStart
    //

    if( _fSymmetrical )
    {
        CTreeNode * pNodeCur = _tpgStart.Branch();
        CStackPtrAry<CElement *, 16> aryBeginElements(Mt(CTreeSaver_aryElements_pv));

        for( ; pNodeCur->Element() != _pelFragment; pNodeCur = pNodeCur->Parent() )
        {
            hr = THR( aryBeginElements.Append( pNodeCur->Element() ) );
            if (hr)
                goto Cleanup;
        }
        
        {
            int iElement = aryBeginElements.Size() - 1;

            while( iElement >= 0 )
            {
                hr = THR( SaveElement( aryBeginElements[iElement--], FALSE) );
                if (hr)
                    goto Cleanup;
            }
        }
    }

    //
    // Tell any derived classes that the selection is started
    //
    hr = THR( SaveSelection( FALSE ) );
    if (hr)
        goto Cleanup;

    // Start supressing all pretty CRLF until
    // we output real content (BUG 3844)
    if (!_pswb->TestFlag(WBF_NO_PRETTY_CRLF))
    {
        _pswb->SetFlags(WBF_NO_PRETTY_CRLF);
        fSuppressingPrettyCRLF = TRUE;
    }

    //
    // Handle any leading block breaks
    //
    if(     ! _fLBStartLeft 
        &&  _pswb->TestFlag(WBF_SAVE_PLAINTEXT)
        &&  LineBreakChar( &_tpgStart ) & BREAK_BLOCK_BREAK )
    {
        hr = THR(_pswb->NewLine());
        if (hr)
            goto Cleanup;
    }

    //
    // Walk the tree and save out tags and text
    //
    ptpEnd      = _tpgEnd.AdjacentTreePos( TPG_LEFT );
    ptpAfterEnd = _tpgEnd.AdjacentTreePos( TPG_RIGHT );

    for( ptpWalk = _tpgStart.AdjacentTreePos( TPG_RIGHT );
         ptpWalk != ptpAfterEnd;
         ptpWalk = ptpNext )
    {
        // Make sure we haven't somehow passed the top of our text frag list
        Assert( ctf <= 0 || ptpWalk->InternalCompare(ptf->_ptpTextFrag) != 1 );

        ptpNext = ptpWalk->NextTreePos();

        switch( ptpWalk->Type() )
        {
        case CTreePos::Pointer:
            if( ctf > 0 && ptpWalk == ptf->_ptpTextFrag )
            {
                // Write out the text frag...
                DWORD dwOldFlags = _pswb->ClearFlags(WBF_ENTITYREF);
                _pswb->SetFlags(WBF_SAVE_VERBATIM | WBF_NO_WRAP);
                _pswb->BeginPre();

                hr = THR(_pswb->Write(ptf->_pchTextFrag));

                _pswb->EndPre();
                _pswb->RestoreFlags(dwOldFlags);

                if (hr)
                    goto Cleanup;

                ctf--;
                ptf++;

                fSeenContent = TRUE;
            }
            break;
        case CTreePos::Text:
            if( ptpWalk->Cch() && pelPendingForce )
            {
                hr = THR( ForceClose( pelPendingForce ) );
                if (hr)
                    goto Cleanup;

                pelPendingForce = NULL;
            }

            hr = THR( SaveTextPos( ptpWalk ) );
            if (hr)
                goto Cleanup;

            fSeenContent = TRUE;

            break;
        case CTreePos::NodeBeg:
            if (!ptpWalk->IsEdgeScope())
                break;

            if(     pelPendingForce 
                &&  !TagProhibitedContainer( ptpWalk->Branch()->Tag(), 
                                             pelPendingForce->Tag() ) )
            {
                hr = THR( ForceClose( pelPendingForce ) );
                if (hr)
                    goto Cleanup;
            }

            pelPendingForce = NULL;

            hr = THR( SaveElement( ptpWalk->Branch()->Element(), FALSE ) );
            if (hr)
                goto Cleanup;

            fSeenContent = TRUE;

            break;
        case CTreePos::NodeEnd:
            if (!ptpWalk->IsEdgeScope())
                break;

            pel = ptpWalk->Branch()->Element();

            if( pel->HasFlag(TAGDESC_DONTSAVEAFTERIMPEND) && 
                !pel->_fExplicitEndTag )
                goto Cleanup;

            if(     pelPendingForce
                &&  !TagEndContainer( pel->Tag(),
                                      pelPendingForce->Tag() ) )
            {
                hr = THR( ForceClose( pelPendingForce ) );
                if (hr)
                    goto Cleanup;
            }

            pelPendingForce = pel;

            hr = THR( SaveElement( pel, TRUE ) );
            if (hr)
                goto Cleanup;

            fSeenContent = TRUE;

            break;
        }

        if ( fSuppressingPrettyCRLF && fSeenContent )
        {
            _pswb->ClearFlags(WBF_NO_PRETTY_CRLF);
            fSuppressingPrettyCRLF = FALSE;
        }


        // Handle any LB at this gap, but not if we are at the end
        // and the LB is not to the left
        if( _fLBEndLeft || ptpWalk != ptpEnd )
        {
            CTreePosGap tpgLB( ptpNext, TPG_LEFT );

            DWORD dwBreaks = LineBreakChar( &tpgLB );

            if( dwBreaks )
            {
                // To IE4, this looks like text so
                // write out the end tag
                if( pelPendingForce )
                {
                    hr = THR( ForceClose( pelPendingForce ) );
                    if (hr)
                        goto Cleanup;

                    pelPendingForce = NULL;
                }

                if(     _pswb->TestFlag(WBF_SAVE_PLAINTEXT)
                    &&  dwBreaks & BREAK_BLOCK_BREAK )
                {

                    hr = THR(_pswb->NewLine());
                    if (hr)
                        goto Cleanup;
                }

                // In IE4, anything besides BB and LB would
                // cause us to clear _fPendingNBSP
                if (dwBreaks & ~( BREAK_BLOCK_BREAK | BREAK_LINE_BREAK ))
                    _fPendingNBSP = FALSE;
            }
        } // LB Check

    }

    if ( fSuppressingPrettyCRLF )
    {
        _pswb->ClearFlags(WBF_NO_PRETTY_CRLF);
        fSuppressingPrettyCRLF = FALSE;
    }

    if (!pelPendingForce)
    {
        hr = THR( SaveSelection( TRUE ) );
        if (hr)
            goto Cleanup;

        fSelectionEndSaved = TRUE;
    }

    //
    // If we are symmetrical, then save out all the end tags starting
    // from above the end gap to _pelFragment
    //
     
    if( _fSymmetrical )
    {
        CTreeNode * pNodeCur = _tpgEnd.Branch();

        for( ; pNodeCur->Element() != _pelFragment ; pNodeCur = pNodeCur->Parent() )
        {
            CElement * pElementCur = pNodeCur->Element();

            if(     pelPendingForce
                &&  !TagEndContainer( pElementCur->Tag(),
                                      pelPendingForce->Tag() ) )
            {
                hr = THR( ForceClose( pelPendingForce ) );
                if (hr)
                    goto Cleanup;
            }

            if (!fSelectionEndSaved)
            {
                hr = THR( SaveSelection( TRUE ) );
                if (hr)
                    goto Cleanup;

                fSelectionEndSaved = TRUE;
            }

            pelPendingForce = pElementCur;

            hr = THR( SaveElement( pElementCur, TRUE ) );
            if (hr)
                goto Cleanup;
        }
    }

    //
    // Force the save of any pending close tag.
    //

    if (pelPendingForce)
    {
        hr = THR( ForceClose( pelPendingForce ) );
        if (hr)
            goto Cleanup;

        if (!fSelectionEndSaved)
        {
            hr = THR( SaveSelection( TRUE ) );
            if (hr)
                goto Cleanup;

            fSelectionEndSaved = TRUE;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CTreeSaver::SaveElement
//
//  Synopsis:   Open and close tags.
//
//---------------------------------------------------------------

HRESULT
CTreeSaver::SaveElement(CElement * pel, BOOL fEnd)
{
    HRESULT    hr;
    BOOL       fPersistWhitespacePre;

    if (fEnd)
    {
        if (_fPendingNBSP && pel == _pelLastBlockScope)
        {
            if (!_pswb->TestFlag(WBF_SAVE_PLAINTEXT))
            {
                TCHAR ch = TCHAR(160);          // &nbsp;
                hr = _pswb->Write(&ch, 1);
                if (hr)
                    goto Cleanup;
            }

            _fPendingNBSP = FALSE;
        }
    }
    else
    {
        // TODO: perhaps we should is IsBlockElement()
        if (pel->HasFlag(TAGDESC_BLOCKELEMENT))
        {
            // Remember the last block element which came into scope
            _pelLastBlockScope = pel;

            // We may have to write an nbsp if this block element has
            // break on empty set (the bit will get cleared in the event
            // that we see a non-empty run before closing).
            _fPendingNBSP = _pelLastBlockScope->_fBreakOnEmpty &&
                _pelLastBlockScope->HasFlag(TAGDESC_SAVENBSPIFEMPTY);
        }
    }

    fPersistWhitespacePre = _pMarkup->SupportsCollapsedWhitespace() 
                            && pel->GetFirstBranch()->IsPre();
    
    if (!fEnd && fPersistWhitespacePre)
        _pswb->BeginPre();

    hr = pel->Save(_pswb, fEnd);

    if (fEnd && fPersistWhitespacePre)
        _pswb->EndPre();


Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CTreeSaver::SaveTextPos
//
//  Synopsis:   Write out the entire text pos.
//
//---------------------------------------------------------------
HRESULT
CTreeSaver::SaveTextPos(CTreePos *ptp)
{
    Assert( ptp->IsText() );

    HRESULT hr = S_OK;
    LONG    cpStart  = ptp->GetCp();
    LONG    cchTotal = ptp->Cch();

    Assert( cpStart >= 0 );
    Assert( cchTotal >= 0 );

    if( cchTotal > 0 )
    {
        CTxtPtr tp(_pMarkup, cpStart );

        DWORD dwOldFlags;
        dwOldFlags = _pswb->SetFlags(WBF_NO_DQ_ENTITY); // IE5 bug 26812
        
        while (cchTotal > 0)
        {
            long            cch;
            const TCHAR *   pch = tp.GetPch(cch);  // sets cch

            if(!pch || cch == 0 )
                break;

            cch = min(cchTotal, cch);

            hr = _pswb->Write(pch, cch);
            if (hr)
                goto Cleanup;

            cchTotal -= cch;
            tp.AdvanceCp(cch);
            Assert( cch );

            Assert( cchTotal >= 0 );
        }

        _fPendingNBSP = FALSE;
        
Cleanup:

        _pswb->RestoreFlags(dwOldFlags);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Helper:     CTreeSaver::ForceClose
//
//  Synopsis:   Writes a close tag for the specified element if
//              the tag can have an end and it hasn't already been
//              written.
//
//---------------------------------------------------------------

HRESULT
CTreeSaver::ForceClose ( CElement * pel )
{
    HRESULT hr = S_OK;

    if (!pel->_fExplicitEndTag)
    {
        BOOL fHasNoEndTag = TagHasNoEndTag( pel->Tag() );

        if (pel->Tag() == ETAG_COMMENT && DYNCAST( CCommentElement, pel )->_fAtomic)
            fHasNoEndTag = TRUE;

        if (!fHasNoEndTag && !pel->HasFlag( TAGDESC_SAVEALWAYSEND ))
            hr = pel->WriteTag(_pswb, TRUE, TRUE);
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  IE4 Compat helpers
//
//---------------------------------------------------------------

// simulates the IE4 CTxtEdit::IsElementBlockInContext
BOOL 
CTreeSaver::IsElementBlockInContainer( CElement * pElement )
{
    Assert( pElement );

    if (pElement->IsBlockElement())
        return TRUE;

    if (pElement->Tag() == ETAG_ROOT)
        return TRUE;

    if (    pElement->HasFlowLayout()
        &&  pElement->GetFlowLayout()->GetContentMarkup() == _pMarkup )
        return TRUE;

    // TODO: what about text slaves?  Should we see if pElementContainer
    // has a flow layout and compare against it's content element?
    if( pElement == _pelContainer )
        return TRUE;
    
    return FALSE;
}

DWORD
CTreeSaver::LineBreakChar( CTreePosGap * ptpg )
{
    DWORD      dwBreaks = BREAK_NONE;
    CTreePos * ptpRight = ptpg->AdjacentTreePos( TPG_RIGHT );
    CTreePos * ptpLeft = ptpg->AdjacentTreePos( TPG_LEFT );
    CElement * pElement;

    // If we have an end node to the right and 
    // we don't have an end non edge to the left, then
    // we are at the beginning of an inclusion and
    // we go with it...
    if (    ptpRight->IsEndNode() 
        &&  !(  ptpLeft->IsEndNode() 
            &&  !ptpLeft->IsEdgeScope() ))
    {
        while( ! ptpRight->IsEndElementScope() )
            ptpRight = ptpRight->NextTreePos();
    }
    else if (!ptpRight->IsBeginElementScope())
        return dwBreaks;

    pElement = ptpRight->Branch()->Element();

    if( ptpRight->IsEndElementScope() )
    {
        // [TSE] at the end of text sites
        // [BB] at the end of block elements
        IGNORE_HR( _breaker.QueryBreaks( ptpg, & dwBreaks ) );

        // no scope elements (BR, IMG, etc.)
        if(     pElement->IsNoScope()
            ||  pElement->Tag() == ETAG_SELECT
            ||  pElement->Tag() == ETAG_OPTGROUP
            ||  pElement->Tag() == ETAG_OPTION)
        {
            switch( pElement->Tag() )
            {
            case ETAG_BR:
                dwBreaks |= BREAK_LINE_BREAK;
                break;
            case ETAG_WBR:
                dwBreaks |= BREAK_WORD_BREAK;
                break;
            default:
                // TODO: (jbeda) WCH_EMBEDDING/WCH_NOSCOPE?
                dwBreaks |= BREAK_NOSCOPE;
                break;
            }
        }
    }
    else if( ptpRight->IsBeginElementScope() )
    {
        // [TSB] when a new text site comes into scope
        // [BB] when a new block element comes into scope
        IGNORE_HR( _breaker.QueryBreaks( ptpg, & dwBreaks ) );
    }

    return dwBreaks;
}

// simulates the IE4 CElementRuns::ScopesLeft
BOOL 
CTreeSaver::ScopesLeftOfStart( CElement * pel )
{
    CTreePosGap     tpgCur( TPG_LEFT );

    Verify( ! tpgCur.MoveTo( &_tpgStart ) );

    Assert( tpgCur.Branch()->SearchBranchToRootForScope( pel ) );

    // If there is a LB to the left, then it
    // must scope
    if (_fLBStartLeft)
        return FALSE;

    while(  !(  tpgCur.AttachedTreePos()->IsText() 
            &&  tpgCur.AttachedTreePos()->Cch() ) )
    {
        // Check if we are about to cross that elements boundry
        if (tpgCur.AttachedTreePos()->IsBeginElementScope(pel))
            return FALSE;

        // never cross container boundries
        if(     tpgCur.AttachedTreePos()->IsNode()
            &&  tpgCur.AttachedTreePos()->IsEdgeScope()
            &&  tpgCur.AttachedTreePos()->Branch()->IsContainer() )
            return TRUE;

        // Move the gap left
        Verify( ! tpgCur.MoveLeft() );

        // Check for line break here
        if (LineBreakChar( &tpgCur ))
            break;
    }

    return TRUE;
}

// simulates the IE4 CElementRuns::ScopesRight
BOOL 
CTreeSaver::ScopesRightOfEnd( CElement * pel )
{
    CTreePosGap     tpgCur( TPG_RIGHT );
    BOOL            fLBLeft = _fLBEndLeft;

    Verify( ! tpgCur.MoveTo( &_tpgEnd ) );

    Assert( tpgCur.Branch()->SearchBranchToRootForScope( pel ) );

    while(  !(  tpgCur.AttachedTreePos()->IsText() 
            &&  tpgCur.AttachedTreePos()->Cch() ) )
    {
        // Check LB to our right
        if(     !fLBLeft 
            &&  LineBreakChar( &tpgCur ) )
            return TRUE;

        // Check edge of pel to our right
        if( tpgCur.AttachedTreePos()->IsEndElementScope(pel) )
            return FALSE;

        // never cross container boundries
        if(     tpgCur.AttachedTreePos()->IsNode()
            &&  tpgCur.AttachedTreePos()->IsEdgeScope()
            &&  tpgCur.AttachedTreePos()->Branch()->IsContainer() )
            return TRUE;

        fLBLeft = FALSE;

        Verify( ! tpgCur.MoveRight() );
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CTreeSaver::SaveGapsToPointers
//  
//  Synopsis:   Saves our internal TreePosGaps to pointers, for when we're
//              calling out to code that can mess with the tree.
//  
//  Returns:    HRESULT 
//  
//  Arguments:
//  
//+----------------------------------------------------------------------------

HRESULT 
CTreeSaver::SaveGapsToPointers()
{
    HRESULT hr;

    Assert( _tpgStart.IsPositioned() &&
            _tpgEnd.IsPositioned() );
    // TODO (JHarding): I'd like to be able to assert _mpStart/_mpEnd are unpositioned here

    // Remember the gaps
    hr = THR( _mpStart.MoveToGap( &_tpgStart, _pMarkup, TRUE ) );
    if( hr )
        goto Cleanup;
    hr = THR( _mpEnd.MoveToGap( &_tpgEnd, _pMarkup, TRUE ) );
    if( hr )
        goto Cleanup;

    // And unposition
    _tpgStart.UnPosition();
    _tpgEnd.UnPosition();

#if DBG==1
    AssertSz( !_fHaveSavedGaps, "Trying to save gaps after already saving them" );
    _fHaveSavedGaps = TRUE;
#endif // DBG

Cleanup:
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//  
//  Method:     CTreeSaver::RestoreGapsFromPointers
//  
//  Synopsis:   Retores our interanl TreePosGaps from our saved pointers, 
//              after calling dangerous code
//  
//  Returns:    HRESULT 
//  
//  Arguments:
//  
//+----------------------------------------------------------------------------

HRESULT 
CTreeSaver::RestoreGapsFromPointers()
{
    HRESULT hr;

    Assert( !_tpgStart.IsPositioned() &&
            !_tpgEnd.IsPositioned() &&
            _mpStart.IsPositioned() &&
            _mpEnd.IsPositioned() );

    Assert( !_mpEnd.IsLeftOf( &_mpStart ) );

    if( !_mpStart.GetEmbeddedTreePos() ||
        !_mpEnd.GetEmbeddedTreePos() )
    {
        return E_FAIL;
    }

    // Replace the gaps
    hr = THR( _tpgStart.MoveTo(_mpStart.GetEmbeddedTreePos(), TPG_RIGHT ) );
    if( hr )
        goto Cleanup;
    _tpgStart.SetAttachPreference( TPG_LEFT );
    hr = THR( _tpgStart.MoveLeft( TPG_OKNOTTOMOVE | TPG_SKIPPOINTERS ) );
    if( hr )
        goto Cleanup;
    hr = THR( _tpgEnd.MoveTo(_mpEnd.GetEmbeddedTreePos(), TPG_LEFT ) );
    if( hr )
        goto Cleanup;
    _tpgEnd.SetAttachPreference( TPG_RIGHT );
    hr = THR( _tpgEnd.MoveRight( TPG_OKNOTTOMOVE | TPG_SKIPPOINTERS ) );
    if( hr )
        goto Cleanup;

    // TODO (JHarding): I'd like to be able to unposition _mpStart/_mpEnd here.

#if DBG==1
    AssertSz( _fHaveSavedGaps, "Trying to restore gaps without ever saving them" );
    _fHaveSavedGaps = FALSE;
#endif // DBG

Cleanup:
    RRETURN( hr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\secmgr.cxx ===
//+------------------------------------------------------------------------
//
//  File:       secmgr.cxx
//
//  Contents:   Security manager call implementation
//
//  Classes:    (part of) CDoc, CSecurityMgrSite
//
//  History:    05-07-97  AnandRa   Created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_SAFETY_HXX_
#define X_SAFETY_HXX_
#include "safety.hxx"
#endif

#ifndef X_MARKUP_HXX_
#define X_MARKUP_HXX_
#include "markup.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_ACTIVSCP_H_
#define X_ACTIVSCP_H_
#include <activscp.h>
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

ExternTag(tagCDoc);
ExternTag(tagSecurityContext);

// external reference
BOOL IsSpecialUrl(LPCTSTR pszURL);

const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY = 
        { 0x10200490, 0xfa38, 0x11d0, { 0xac, 0xe, 0x0, 0xa0, 0xc9, 0xf, 0xff, 0xc0 }};

// Custom policy used to query before the scriptlet runtime creates an 
// interface handler. The semantics of this call are similar to the standard
// policy URLACTION_ACTIVEX_RUN. e.g. Input is the CLSID of the handler. Output
// is the policy in a DWORD.
static const GUID GUID_CUSTOM_CONFIRMINTERFACEHANDLER = 
        { 0x02990d50, 0xcd96, 0x11d1, { 0xa3, 0x75, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc }};

// automation handler
static const GUID CLSID_DexHandlerConstructor =
    { 0xc195d550, 0xa068, 0x11d1, { 0x89, 0xb6, 0x0, 0x60, 0x8, 0xc3, 0xfb, 0xfc }};
// event handler
static const GUID CLSID_CpcHandlerConstructor =
    { 0x3af5262e, 0x4e6e, 0x11d1, { 0xbf, 0xa5, 0x00, 0xc0, 0x4f, 0xc3, 0x0c, 0x45}};

static const GUID* knownScriptletHandlers[] = {
        &CLSID_CPeerHandler,
        &CLSID_DexHandlerConstructor,
        &CLSID_CpcHandlerConstructor,
        &CLSID_CHiFiUses,
        &CLSID_CCSSFilterHandler,
    &CLSID_CSvrOMUses,
};

//+------------------------------------------------------------------------
//
//  Member:     CDoc::EnsureSecurityManager
//
//  Synopsis:   Verify that the security manager is created
//
//-------------------------------------------------------------------------

HRESULT
CDoc::EnsureSecurityManager( BOOL fForPrinting /*=FALSE*/ )
{
    TraceTag((tagCDoc, "CDoc::EnsureSecurityManager"));

    HRESULT hr = S_OK;
    IInternetSecurityManager **ppISM = &_pSecurityMgr; 

    // (KTam) The doc may maintain an instance of a security manager to be used for
    // print content inside a printing dialog.  Because dialogs have their own
    // (very permissive) security model, if we make a call to a _pSecurityMgr
    // belonging to a dialog, it won't enforce browser zone restrictions.  Our
    // solution is to instantiate a separate security manager that doesn't get set to
    // delegate back to the dialog -- we avoid this delegation by _never_ calling
    // the new security manager's IInternetSecurityManager::SetSecuritySite() after
    // the dialog has attached itself to the CDoc via IOleObject::SetClientSite().
    // See also CDoc::SetClientSite() and CHTMLDlg::Create().
    if ( fForPrinting )
        ppISM = &_pPrintSecurityMgr;

    if (*ppISM)
    {
        // Do not use the cached security manager until the doc is inplace active
        // when we are being hosted within an ATL framework application that hosts 
        // the WebOC.
        if (_fATLHostingWebOC && (State() < OS_INPLACE))
        {
            ClearInterface(ppISM);
        }
        else
            goto Cleanup;
    }

    //
    // If we're ensuring the security manager for some reason, we
    // will be using the url down the road, so ensure that too.
    //
    Assert(!!GetDocumentSecurityUrl());

    hr = THR(CoInternetCreateSecurityManager(NULL, ppISM, 0));
    if (hr)
        goto Cleanup;

    hr = THR((*ppISM)->SetSecuritySite(&_SecuritySite));
    if (hr)
        goto Cleanup;

    AssertSz(!IsPrintDialog() || _pPrintSecurityMgr, "PrintPreview should always have a print security manager.");

Cleanup:
    RRETURN(hr);
}

HRESULT
CMarkup::AllowClipboardAccess(TCHAR *pchCmdId, BOOL *pfAllow)
{
    HRESULT    hr = E_FAIL;
    DWORD     dwCmdId;

    *pfAllow = FALSE;
    
    // (rolandt) Convert the command ID from string to number.  For *pfAllow=true, the command
    // must be in our command list.  We'll call ProcessURLAction for clipboard related commands
    // we know of now.  This is our inclusion list.  The inclusion list will need to be updated as
    // necessary as new commands are added to CBase::cmdTable[] in basemso.cxx.

    // (rolandt) May be prudent to add a security check member to CBase::CMDINFOSTRUCT as a
    // general security measure so that as new commands are added this member will need to be
    // explicitly set.  We could then check for that member here and see what security check we
    // need to do for the command.  Downside is adding at least a dword for every command (~100).
    
    hr = THR_NOTRACE(CmdIDFromCmdName(pchCmdId, &dwCmdId));
    if(hr)
    {
        *pfAllow = FALSE;
        goto Cleanup;
    }

    if (    dwCmdId == IDM_PASTE /* "Paste" */
        ||  dwCmdId == IDM_COPY /* "Copy" */
        ||  dwCmdId == IDM_CUT /* "Cut" */
        ||  dwCmdId == IDM_PARAGRAPH /* "InsertParagraph" */)
    {
        RRETURN(ProcessURLAction(URLACTION_SCRIPT_PASTE, pfAllow));
    }

    *pfAllow = TRUE;
    hr = S_OK;

Cleanup:
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::ProcessURLAction
//
//  Synopsis:   Query the security manager for a given action
//              and return the response.  This is basically a true/false
//              or allow/disallow return value.
//
//  Arguments:  dwAction [in]  URLACTION_* from urlmon.h
//              pfReturn [out] TRUE on allow, FALSE on any other result
//              fNoQuery [in]  TRUE means don't query
//              pfQuery  [out] TRUE if query was required
//              pchURL   [in]  The acting URL or NULL for the doc itself
//              pbArg    [in]  pbContext for IInternetSecurityManager::PUA
//              cbArg    [in]  cbContext for IInternetSecurityManager::PUA
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::ProcessURLAction(
    DWORD dwAction,
    BOOL *pfReturn,
    DWORD dwPuaf,
    DWORD *pdwPolicy,
    LPCTSTR pchURL,
    BYTE *pbArg,
    DWORD cbArg,
    PUA_Flags pua)
{
    HRESULT hr = S_OK;
    DWORD   dwPolicy = 0;
    DWORD   dwMask = 0;
    ULONG   cDie;
    BOOL    fDisableNoShowElement = pua & PUA_DisableNoShowElements;
    BOOL    fIgnoreLoadf = pua & PUA_NoLoadfCheckForScripts;
    IInternetSecurityManager *pSecMgr = NULL;

    *pfReturn = FALSE;

    // TODO (alexz) ProcessUrlAction can push message loop for a message box,
    // so it has to be called at a safe moment of time. Enable this in IE5.5 B3
    // (in B2 it asserts all over the place)
    // AssertSz(!__fDbgLockTree, "ProcessURLAction is called when the new markup is unstable. This will lead to crashes, memory leaks, and script errors");

    hr = THR(Doc()->EnsureSecurityManager());
    if (hr)
        goto Error;

    //
    // Check the action for special known guids.  In these cases
    // we want the min of the security settings and the _dwLoadf
    // that the host provided.
    //

    switch (dwAction)
    {
    case URLACTION_SCRIPT_RUN:
        dwMask = DLCTL_NO_SCRIPTS;
        break;

    case URLACTION_ACTIVEX_RUN:
        dwMask = DLCTL_NO_RUNACTIVEXCTLS;
        break;

    case URLACTION_HTML_JAVA_RUN:
        dwMask = DLCTL_NO_JAVA;
        break;

    case URLACTION_JAVA_PERMISSIONS:
        dwMask = DLCTL_NO_JAVA;
        break;
    }

    // TODO (KTam, JHarding) Temporary hack to stop scripts from
    // running when printing.  Right fix involves figuring out how
    // to read from the markup's _dwLoadF, and where we ought to be
    // checking DontRunScripts.
    // TODO again (Jharding): Verify this is no longer needed.
    if (   dwAction == URLACTION_SCRIPT_RUN
        && !fDisableNoShowElement               // only NOSCRIPT/NOEMBED parsing passes fDisableNoShowElement == TRUE
        && DontRunScripts() )
    {
        goto Cleanup;
    }

    // $$ktam: TODO In the insertAdjacentHTML case (and probably others),
    // we don't go through CMarkup::LoadFromInfo(), so we don't have a
    // CDwnDoc!  For now we'll delegate back to the CDoc in those situations.
    if (!fIgnoreLoadf && dwMask && ( (GetDwnDoc() ? GetDwnDoc()->GetLoadf() : _pDoc->_dwLoadf) & dwMask))
    {
        // 69976: If we are not running scripts only because we are printing,
        // don't disable noshow elements NOSCRIPT and NOEMBED.
        if (   !fDisableNoShowElement
            || dwMask != DLCTL_NO_SCRIPTS
            || !DontRunScripts())
        {
            goto Error;
        }
    }

    if (!pchURL)
    {
        pchURL = GetUrl(this);
    }
    cDie = Doc()->_cDie;

    if (GetWindowedMarkupContext()->HasWindow() || _fWindowPending)
    {
        COmWindowProxy * pProxy;

        if (!_fWindowPending)
        {
            pProxy = GetWindowedMarkupContext()->Window();
        }
        else
        {
            pProxy = GetWindowPending();            
        }

        if (pProxy->Window()->_fRestricted)
        {
            dwPuaf |= PUAF_ENFORCERESTRICTED;
        }
        else if (pProxy->_fTrustedDoc)
        {
            dwPuaf |= PUAF_TRUSTED;
        }

        if (Doc()->_fInTrustedHTMLDlg)
        {
            // If we're in a trusted HTML dialog, then toplevel pages
            // are considered trusted. Frames are considered trusted only
            // if application="yes", which means that _fTrustedFrame is
            // set on the CFrameSite. See CHTMLDlgSite::ProcessUrlAction
            // for more info.
            CFrameSite * pFrameSite = pProxy->Window()->GetFrameSite();

            if (pFrameSite == NULL || pFrameSite->_fTrustedFrame)
            {
                dwPuaf |= PUAF_TRUSTED;
            }
        }
        
    }

    pSecMgr = GetSecurityManager();

    // if NULL - see EnsureSecurityManager/GetSecurityManager for trouble.
    // or we have a low mem condition.
    Check(pSecMgr); 

    if(!pSecMgr) 
    {
        goto Error; //this will return FALSE (disallow)
    }
    
    hr = THR(pSecMgr->ProcessUrlAction(
        pchURL,
        dwAction,
        (BYTE *)&dwPolicy,
        sizeof(DWORD),
        pbArg,
        cbArg,
        dwPuaf,
        0));

    if (hr == S_FALSE)
        hr = S_OK;

    if (Doc()->_cDie != cDie)
        hr = E_ABORT;

    if (hr)
        goto Error;

    if (pdwPolicy)
        *pdwPolicy = dwPolicy;

    if (dwAction != URLACTION_JAVA_PERMISSIONS)
    {
        *pfReturn = (GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_ALLOW);
    }
    else
    {
        // query was for URL_ACTION_JAVA_PERMISSIONS
        *pfReturn = (dwPolicy != URLPOLICY_JAVA_PROHIBIT);
    }

Cleanup:
    TraceTag((tagCDoc, "CDoc::ProcessURLAction, Action=0x%x URL=%s Allowed=%d", dwAction, pchURL, *pfReturn));

    RRETURN(hr);

Error:
    *pfReturn = FALSE;

    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::GetSecurityID
//
//  Synopsis:   Retrieve a security ID from a url from the system sec mgr.
//
//-------------------------------------------------------------------------

void
CMarkup::UpdateSecurityID()
{
    HRESULT hr;

    COmWindowProxy *    pProxy = Window();

    if (pProxy)
    {
        BYTE    abSID[MAX_SIZE_SECURITY_ID];
        DWORD   cbSID = ARRAY_SIZE(abSID);

        hr = THR(GetSecurityID(abSID, &cbSID));
        if (hr)
            return;

        TraceTag((tagSecurityContext, "Update security id on proxy 0x%x to %s", pProxy, abSID));

        hr = THR(pProxy->Init(pProxy->_pWindow, abSID, cbSID));
        if (hr)
            return;

        //
        // Find and replace the main proxy. fOMAccess = FALSE
        //
        if ((TLS(windowInfo.paryWindowTbl)->FindProxy(pProxy->_pWindow, 
                                                        abSID, 
                                                        cbSID, 
                                                        IsMarkupTrusted(), 
                                                        NULL, 
                                                        /*fOMAccess = */ FALSE )))
        {
            TLS(windowInfo.paryWindowTbl)->DeleteProxyEntry(pProxy);

            THR(TLS(windowInfo.paryWindowTbl)->AddTuple(
                    pProxy->_pWindow,
                    abSID,
                    cbSID,
                    IsMarkupTrusted(),
                    pProxy));
        }
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CMarkup::AccessAllowed
//
//-------------------------------------------------------------------------

BOOL
CMarkup::AccessAllowed(LPCTSTR pchUrl)
{
    HRESULT hr = S_OK;
    BYTE    abSID1[MAX_SIZE_SECURITY_ID];
    BYTE    abSID2[MAX_SIZE_SECURITY_ID];
    DWORD   cbSID1 = ARRAY_SIZE(abSID1);
    DWORD   cbSID2 = ARRAY_SIZE(abSID2);
    BOOL    fAccessAllowed = FALSE;

    hr = THR_NOTRACE(GetSecurityID(abSID1, &cbSID1, pchUrl));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(GetSecurityID(abSID2, &cbSID2)); // get SID of doc itself
    if (hr)
        goto Cleanup;

    fAccessAllowed = (cbSID1 == cbSID2 && 0 == memcmp(abSID1, abSID2, cbSID1));

Cleanup:
    return fAccessAllowed;
}

//+------------------------------------------------------------------------
//
//  Member:     CDoc::AccessAllowed
//
//-------------------------------------------------------------------------

BOOL
CMarkup::AccessAllowed(CMarkup * pMarkupAnother)
{
    HRESULT hr = S_OK;
    BYTE    abSID1[MAX_SIZE_SECURITY_ID];
    BYTE    abSID2[MAX_SIZE_SECURITY_ID];
    DWORD   cbSID1 = ARRAY_SIZE(abSID1);
    DWORD   cbSID2 = ARRAY_SIZE(abSID2);
    BOOL    fAccessAllowed = FALSE;

    hr = THR_NOTRACE(pMarkupAnother->GetSecurityID(abSID1, &cbSID1));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(GetSecurityID(abSID2, &cbSID2)); // get SID of doc itself
    if (hr)
        goto Cleanup;

    fAccessAllowed = (cbSID1 == cbSID2 && 0 == memcmp(abSID1, abSID2, cbSID1));

Cleanup:
    return fAccessAllowed;
}

//+------------------------------------------------------------------------
//
//  Member:     CMarkup::GetFrameZone
//
//  Synopsis:   Pass out the zone of the current markup depending on variant
//              passed in.
//
//  Notes:      If the pvar is VT_EMPTY, nothing has been filled out yet.
//              If it is VT_UI4, it contains the current zone.  We have to
//              check zones with this and update it to mixed if appropriate.
//              If it is VT_NULL, the zone is mixed.
//
//-------------------------------------------------------------------------

HRESULT
CMarkup::GetFrameZone(VARIANT *pvar)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();
    DWORD   dwZone;
    DWORD   dwMUTZFlags = 0;
    CElement * pClient;
    TCHAR * pchCreatorUrl;
    TCHAR * pchURL;

    if (V_VT(pvar) == VT_NULL)
        goto Cleanup;

    hr = THR(pDoc->EnsureSecurityManager());
    if (hr)
        goto Cleanup;

    pchURL = (TCHAR *) GetUrl(this);

    if (IsSpecialUrl(pchURL))
    {
        pchCreatorUrl = (TCHAR *) GetAAcreatorUrl();
        if (pchCreatorUrl && *pchCreatorUrl)
        {
            pchURL = pchCreatorUrl;
        }
    }

    //
    // If this markup is attached to or created by a window that is 
    // restricted, then return restricted zone for all enquiries.
    //
    if ((HasWindow() && Window()->Window()->_fRestricted) || 
        (HasWindowedMarkupContextPtr() && 
         GetWindowedMarkupContext()->Window()->Window()->_fRestricted))
    {
        dwMUTZFlags |= MUTZ_ENFORCERESTRICTED;
    }

    hr = THR(pDoc->_pSecurityMgr->MapUrlToZone(pchURL, &dwZone, dwMUTZFlags));
    if (hr)
        goto Cleanup;

    if (V_VT(pvar) == VT_EMPTY)
    {
        V_VT(pvar) = VT_UI4;
        V_UI4(pvar) = dwZone;
    }
    else if (V_VT(pvar) == VT_UI4)
    {
        if (V_UI4(pvar) != dwZone)
        {
            V_VT(pvar) = VT_NULL;
        }
    }
    else
    {
        Assert(0 && "Unexpected value in variant");
    }

    // Send the notification to the Markup
    // TODO (jbeda) this may not work well with frames
    // in viewlinks
    if (_fHasFrames)
    {
        pClient = GetElementClient();

        if (pClient)
        {
            CNotification   nf;

            nf.GetFrameZone(pClient, (void *)pvar);
            Notify(&nf);
        }
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::HostGetSecurityId
//
//  Synopsis:   Retrieve a security ID from a url from the system sec mgr.
//
//-------------------------------------------------------------------------
HRESULT
CDocument::HostGetSecurityId(BYTE *pbSID, DWORD *pcb, LPCWSTR pwszDomain)
{
    HRESULT hr;

    CMarkup *   pMarkup = Markup();
    Assert( pMarkup );

    if (_pWindow && _pWindow->_punkViewLinkedWebOC && 
            _pWindow->_pWindowParent)
    {
        return _pWindow->_pWindowParent->Document()->HostGetSecurityId(
                        pbSID, pcb, pwszDomain);
    }

    hr = pMarkup->GetSecurityID(pbSID, pcb, NULL, pwszDomain, TRUE);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::ProcessUrlAction
//
//  Synopsis:   per IInternetHostSecurityManager
//
//-------------------------------------------------------------------------
HRESULT
CDocument::HostProcessUrlAction(
    DWORD dwAction,
    BYTE *pPolicy,
    DWORD cbPolicy,
    BYTE *pContext,
    DWORD cbContext,
    DWORD dwFlags,
    DWORD dwReserved)
{
    HRESULT hr;
    CMarkup *   pMarkup = Markup();
    Assert( pMarkup );
    CDoc *      pDoc = pMarkup->Doc();

    if(dwAction == URLACTION_ACTIVEX_RUN)
    {
        CLSID*  clsid = (CLSID*)pContext;
        WORD		wclsid;

        hr = THR(pDoc->_clsTab.AssignWclsid(pDoc, *clsid, &wclsid));
        if (hr)
        {
            return E_ACCESSDENIED;
        }

        INSTANTCLASSINFO* pici = pDoc->_clsTab.GetInstantClassInfo(wclsid);

        if (pici && (pici->dwCompatFlags & COMPAT_EVIL_DONT_LOAD))
        {
            return E_ACCESSDENIED;
        }
    }


    if (_pWindow && _pWindow->_punkViewLinkedWebOC && 
            _pWindow->_pWindowParent)
    {
        return _pWindow->_pWindowParent->Document()->HostProcessUrlAction(
                        dwAction, pPolicy, cbPolicy, pContext, cbContext,
                        dwFlags, dwReserved);
    }

    hr = pDoc->EnsureSecurityManager();
    if (hr)
        goto Cleanup;

    if ((_pWindow && _pWindow->_fRestricted) || 
        (pMarkup->HasWindowedMarkupContextPtr() && 
         pMarkup->GetWindowedMarkupContext()->Window()->Window()->_fRestricted))
    {
        dwFlags |= PUAF_ENFORCERESTRICTED;
    }
    else if (pMarkup->IsMarkupTrusted())
    {
        dwFlags |= PUAF_TRUSTED;
    }
   
    hr = THR(pDoc->_pSecurityMgr->ProcessUrlAction(
            CMarkup::GetUrl(pMarkup),
            dwAction,
            pPolicy,
            cbPolicy,
            pContext,
            cbContext,
            dwFlags,
            dwReserved));
    if (!OK(hr))
        goto Cleanup;

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     CDoc::QueryCustomPolicy
//
//  Synopsis:   per IInternetHostSecurityManager
//
//-------------------------------------------------------------------------
HRESULT
CDocument::HostQueryCustomPolicy(
    REFGUID guidKey,
    BYTE **ppPolicy,
    DWORD *pcbPolicy,
    BYTE *pContext,
    DWORD cbContext,
    DWORD dwReserved)
{
    HRESULT         hr;
    IActiveScript * pScript = NULL;
    BYTE            bPolicy = (BYTE)URLPOLICY_DISALLOW;
    CMarkup *       pMarkup = Markup();
    Assert( pMarkup );    
    CDoc *          pDoc = pMarkup->Doc();

    if (_pWindow && _pWindow->_punkViewLinkedWebOC && 
            _pWindow->_pWindowParent)
    {
        return _pWindow->_pWindowParent->Document()->HostQueryCustomPolicy(
                        guidKey, ppPolicy, pcbPolicy, pContext, cbContext,
                        dwReserved);
    }

    hr = pDoc->EnsureSecurityManager();
    if (hr)
        goto Cleanup;

    //
    // Forward all other custom policies to the real security
    // manager.
    //
    hr = THR_NOTRACE(pDoc->_pSecurityMgr->QueryCustomPolicy(
            CMarkup::GetUrl(pMarkup),
            guidKey,
            ppPolicy,
            pcbPolicy,
            pContext,
            cbContext,
            dwReserved));

    if (hr != INET_E_DEFAULT_ACTION &&
        hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
        goto Cleanup;
        
    if (guidKey == GUID_CUSTOM_CONFIRMOBJECTSAFETY)
    {
        CONFIRMSAFETY * pconfirm;
        DWORD           dwAction;
        BOOL            fSafe;
        SAFETYOPERATION safety;
        const IID *     piid;
        
        //
        // This is a special guid meaning that some embedded object
        // within is itself trying to create another object.  This might
        // just be some activex obj or a script engine.  We will need
        // to run through our IObjectSafety code on this object.  We
        // get the clsid and the IUnknown of the object passed in from
        // the context.
        //
        
        if (cbContext != sizeof(CONFIRMSAFETY))
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        if (!ppPolicy || !pcbPolicy)
        {
            hr = E_POINTER;
            goto Cleanup;
        }
        
        pconfirm = (CONFIRMSAFETY *)pContext;
        if (!pconfirm->pUnk)
            goto Cleanup;
            
        //
        // Check for script engine.  If so, then we need to use a different
        // action and IObjectSafety has slightly different restrictions.
        //

        if (OK(THR_NOTRACE(pconfirm->pUnk->QueryInterface(
                IID_IActiveScript,
                (void **)&pScript))) && 
            pScript)
        {
            dwAction = URLACTION_SCRIPT_OVERRIDE_SAFETY;
            safety = SAFETY_SCRIPTENGINE;
            piid = &IID_IActiveScript;
        }
        else
        {
            dwAction = URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY;
            safety = SAFETY_SCRIPT;
            piid = &IID_IDispatch;
        }
        hr = THR(pMarkup->ProcessURLAction(dwAction, &fSafe)); 
        if (hr)
            goto Cleanup;

        if (!fSafe)
        {
            fSafe = IsSafeTo(
                        safety, 
                        *piid, 
                        pconfirm->clsid, 
                        pconfirm->pUnk, 
                        pMarkup);
        }

        if (fSafe)
            bPolicy = (BYTE)URLPOLICY_ALLOW;

        hr = S_OK;
        goto ReturnPolicy;
    }
    else if (guidKey == GUID_CUSTOM_CONFIRMINTERFACEHANDLER)
    {
        if (cbContext == sizeof(GUID))
        {
            CLSID  *pHandlerCLSID = (CLSID *)pContext;

            for (int i = 0; i < ARRAY_SIZE(knownScriptletHandlers); i++)
                if (*pHandlerCLSID == *knownScriptletHandlers[i])
                {
                    bPolicy = (BYTE)URLPOLICY_ALLOW;
                    break;
                }
        }

        hr = S_OK;
        goto ReturnPolicy;
    }
    
Cleanup:
    ReleaseInterface(pScript);
    RRETURN(hr);

ReturnPolicy:
    *pcbPolicy = sizeof(DWORD);
    *ppPolicy = (BYTE *)CoTaskMemAlloc(sizeof(DWORD));
    if (!*ppPolicy)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *(DWORD *)*ppPolicy = (BYTE)bPolicy;

    goto Cleanup;
}



IMPLEMENT_SUBOBJECT_IUNKNOWN(CSecurityMgrSite, CDoc, Doc, _SecuritySite)


//+------------------------------------------------------------------------
//
//  Member:     CSecurityMgrSite::QueryInterface
//
//  Synopsis:   per IUnknown
//
//-------------------------------------------------------------------------

HRESULT
CSecurityMgrSite::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (riid == IID_IUnknown || riid == IID_IInternetSecurityMgrSite)
    {
        *ppv = (IInternetSecurityMgrSite *)this;
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppv = (IServiceProvider *)this;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}


//+------------------------------------------------------------------------
//
//  Member:     CSecurityMgrSite::GetWindow
//
//  Synopsis:   Return parent window for use in ui
//
//-------------------------------------------------------------------------

HRESULT
CSecurityMgrSite::GetWindow(HWND *phwnd)
{
    HRESULT         hr = S_OK;
    IOleWindow *    pOleWindow = NULL;
    
    if (Doc()->_dwLoadf & DLCTL_SILENT)
    {
        *phwnd = (HWND)INVALID_HANDLE_VALUE;
        hr = S_FALSE;
    }
    else
    {
        hr = THR(Doc()->GetWindow(phwnd));
        if (hr)
        {
            if (Doc()->_pClientSite &&
                S_OK == Doc()->_pClientSite->QueryInterface(IID_IOleWindow, (void **)&pOleWindow))
            {
                hr = THR(pOleWindow->GetWindow(phwnd));
            }
        }
    }

    ReleaseInterface(pOleWindow);  
    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     CSecurityMgrSite::EnableModeless
//
//  Synopsis:   Called before & after displaying any ui
//
//-------------------------------------------------------------------------

HRESULT
CSecurityMgrSite::EnableModeless(BOOL fEnable)
{
    // TODO: having window context would be good here.
    CDoEnableModeless   dem(Doc(), NULL, FALSE);

    if (fEnable)
    {
        dem.EnableModeless(TRUE);
    }
    else
    {
        dem.DisableModeless();

        // Return an explicit failure here if we couldn't do it.
        // This is needed to ensure that the count does not go
        // out of sync.
        if (!dem._fCallEnableModeless)
            return E_FAIL;
    }
    
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CSecurityMgrSite::QueryService
//
//  Synopsis:   per IServiceProvider
//
//-------------------------------------------------------------------------

HRESULT
CSecurityMgrSite::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    RRETURN(Doc()->QueryService(guidService, riid, ppv));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\selecobj.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       selecobj.cxx
//
//  Contents:   Implementation of the CSelectionObj class.
//
//  Classes:    CSelectionObj
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SELECOBJ_HXX_
#define X_SELECOBJ_HXX_
#include "selecobj.hxx"
#endif

#ifndef X_CTLRANGE_HXX_
#define X_CTLRANGE_HXX_
#include "ctlrange.hxx"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#define _cxx_
#include "selecobj.hdl"

MtDefine(CSelectionObject, ObjectModel, "CSelectionObject")

extern BOOL g_fInAccess;
extern BOOL g_fInVisualStudio;

const CBase::CLASSDESC CSelectionObject::s_classdesc =
{
    0,                          // _pclsid
    0,                          // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                       // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                       // _pcpi
    0,                          // _dwFlags
    &IID_IHTMLSelectionObject,  // _piidDispinterface
    &s_apHdlDescs,              // _apHdlDesc
};

#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}

//------------------------------------------------------------
//  Member   : CSelectionObject
//
//  Synopsis : Constructor
//
//------------------------------------------------------------

CSelectionObject::CSelectionObject(CDocument * pDocument)
: super(), _pDocument(pDocument)
{
    _pMarkup = _pDocument->Markup();
    _pMarkup->SubAddRef();
    _pDocument->SubAddRef();
}

//------------------------------------------------------------
//  Member   : CSelectionObject
//
//  Synopsis : Destructor:
//       clear out the storage that knows about this Interface.
//
//------------------------------------------------------------

CSelectionObject::~CSelectionObject()
{
    if (_pDocument->_pCSelectionObject == this)
        _pDocument->_pCSelectionObject = NULL;
    _pMarkup->SubRelease();
    _pDocument->SubRelease();
}

//------------------------------------------------------------
//  Member   : PrivateQUeryInterface
//
//------------------------------------------------------------

STDMETHODIMP
CSelectionObject::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown ||
        iid == IID_IDispatch ||
        iid == IID_IHTMLSelectionObject /*||
        iid == IID_IHTMLSelectionObject2*/ )
    {
        *ppv = (IHTMLSelectionObject *)this;
    }
    else if ( iid == IID_IHTMLSelectionObject2 )
    {
        *ppv = (IHTMLSelectionObject2 *)this;
    }
    else if (iid == IID_IDispatchEx)
    {
        *ppv = (IDispatchEx *)this;
    }
    else if (iid == IID_IObjectIdentity)
    {
        HRESULT hr = CreateTearOffThunk(this,
            (void *)s_apfnIObjectIdentity,
            NULL,
            ppv);
        if (hr)
            RRETURN(hr);
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     SameMarkup
//
//  Synopsis:   Helper function that determines if the segment list has segments
//              in the same markup as our own.
//
//  Arguments:  pIList = INPUT - Segment list to check
//              pfSameMarkup = OUTPUT - Same markup?
//
//  Returns:    HRESULT indicating success
//
//----------------------------------------------------------------------------

HRESULT
CSelectionObject::SameMarkup(BOOL *pfSameMarkup, ISelectionServices *pISelServIn /* = NULL */ )
{
    HRESULT             hr = S_OK;
    CMarkup             *pMarkup = NULL;
    
    Assert( pfSameMarkup );

    *pfSameMarkup = FALSE;

    IFC( _pDocument->Doc()->GetSelectionMarkup(& pMarkup));
    
    // Check that the markups are the same
    if( pMarkup == _pDocument->Markup())
    {
        *pfSameMarkup = TRUE;
    }
    else if( pMarkup && pMarkup->Root()->HasMasterPtr())
    {
        // For INPUT, expose the selection slave markup

        CElement * pElemMaster = pMarkup->Root()->GetMasterPtr();

        if (    pElemMaster->Tag() == ETAG_INPUT
            &&  pElemMaster->GetMarkup() == _pDocument->Markup())
        {
            *pfSameMarkup = TRUE;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     GetCreateRange
//
//  Synopsis: returns the specified item from the selection.
//              CElementCollection if structural
//              CRange             if text
//              CTable????         if table
//
//  Returns: S_OK if item found and the IDispatch * to the item
//
//----------------------------------------------------------------------------

HRESULT
CSelectionObject::createRange( IDispatch ** ppDisp )
{
    HRESULT                 hr = S_OK;
    IMarkupPointer          *pStart = NULL;
    IMarkupPointer          *pEnd = NULL;
    ISelectionServices      *pSelServ = NULL;
    ISegmentListIterator    *pIter = NULL;
    ISegmentList            *pList = NULL;
    ISegment                *pSegment = NULL;
    IHTMLElement            *pCurElement = NULL;
    CDoc                    *pDoc = _pDocument->Doc();
    BOOL                    fSameMarkup;
    CElement                *pElement =pDoc->_pElemCurrent;
    CMarkup                 *pMarkup = NULL;
    BOOL                    fEmpty = FALSE;
    IHTMLElement            *pIHTMLElement = NULL;
    htmlSelection           htmlSel;
    BOOL                    fIE4CompatControlRange = FALSE;
    IElementSegment         *pIElementSegment = NULL;
    CMarkupPointer          *pStartPointer = NULL;
    CMarkup                 *pTestMarkup = NULL;

    if (! pElement)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // APPCOMPAT (CHANDRAS) : ACCESS CHECK: not to break in MSAccess, access hack is added with if condition below 
    if (!(g_fInAccess || g_fInVisualStudio) && (!_pMarkup || !_pMarkup->AccessAllowed(pElement->GetMarkup())))
    {
	   hr = E_ACCESSDENIED;
      	   goto Cleanup;
    }
        
    // TODO (MohanB) Hack for INPUT's slave markup. Need to figure out
    // how to generalize this.
    if (pElement->Tag() == ETAG_INPUT && pElement->HasSlavePtr())
    {
        pElement = pElement->GetSlavePtr();
        pMarkup = pElement->GetMarkup();
        Assert( pMarkup );
    }
    else
    {
        pMarkup = pElement->GetMarkup();
        Assert( pMarkup );
        pElement = pMarkup->GetElementTop();        
    }

    if ( pDoc->GetHTMLEditor( FALSE ))
    {
        // HACK ALERT! We send this notification so the selection manager will complete any 
        // pending tasks. See bug 103144.
        hr = pDoc->GetHTMLEditor( FALSE )->Notify(EDITOR_NOTIFY_BEGIN_SELECTION_UNDO, NULL, 0);
        if (hr)
            goto Cleanup;

        hr = THR( pDoc->GetSelectionServices( & pSelServ));
        if ( hr )
            goto Cleanup;

        hr = THR( SameMarkup( &fSameMarkup, pSelServ ) );
        if( hr || !fSameMarkup )
        {
            //
            // Not in the same markup, we have an empty
            // selection.
            //
            fEmpty = TRUE;
        }
        else
        {
            hr = THR( pSelServ->QueryInterface(IID_ISegmentList, (void **)&pList ) );
            if ( hr )
                goto Cleanup;

            hr = THR( pList->IsEmpty( &fEmpty ) );
            if ( hr )
                goto Cleanup;
        }
    }
    else
    {
        fEmpty = TRUE;
    }
    
    hr = THR( GetType( & htmlSel, & fIE4CompatControlRange ));
    if ( hr )
        goto Cleanup;
        
    if ( htmlSel == htmlSelectionControl )
    {           
        //
        // Create a control range
        //
        CAutoTxtSiteRange* pControlRange =  new CAutoTxtSiteRange(pElement);

        if (! pControlRange)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // Put each selected element in to the control range
        if( fEmpty  || fIE4CompatControlRange )
        {
#if DBG == 1        
            //
            // If we didn't have something in the array - then we must be a UI-Active adorned
            // edit context with the caret not visible. So we double-check, and then assume pSelected
            // Element is the EditContext.
            //
            IHTMLEditor* ped = pDoc->GetHTMLEditor(FALSE);
            Assert(ped);
            AssertSz(( fEmpty ||
                       ( ped->IsEditContextUIActive() == S_OK && !pDoc->IsCaretVisible() ) ||
                       pDoc->_pElemCurrent->IsNoScope() ),
                         "Nothing UI-Active - why is selection type control ?" );

#endif            
            //
            // This handles the UI-active case.
            //
            if ( fIE4CompatControlRange )
            {
                pControlRange->AddElement(pDoc->_pElemCurrent);
            }
        }
        else 
        {   
            CElement* pSelectedElement = NULL;

            hr = THR( pDoc->CreateMarkupPointer( & pStart ));
            if ( hr )
                goto Cleanup;

            hr = THR( pDoc->CreateMarkupPointer( & pEnd ));
            if ( hr )
                goto Cleanup;

            hr = THR( pList->CreateIterator( &pIter ) );
            if( hr )
                goto Cleanup;

            while( pIter->IsDone() == S_FALSE )
            {
            
                hr = THR( pIter->Current(&pSegment) );
                if ( hr )
                    goto Cleanup;

                hr = THR( pSegment->QueryInterface( IID_IElementSegment , (void**) & pIElementSegment ));
                if ( hr )
                    goto Cleanup;
                    
                hr = THR( pIElementSegment->GetElement( & pCurElement ));
                if ( hr )
                    goto Cleanup;                

                if ( ! pCurElement)
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }
                
                hr = THR( pCurElement->QueryInterface( CLSID_CElement, (void**) & pSelectedElement ));
                if ( hr )
                    goto Cleanup;

                if ( ! pSelectedElement->GetFirstBranch())
                {
                    AssertSz(0,"Creating a control range on an element not in the Tree");
                    hr = E_FAIL;
                    goto Cleanup;
                }
                
                ClearInterface( &pCurElement );
                ClearInterface( &pSegment);
                ClearInterface( &pIElementSegment);
                Assert( pSelectedElement );
            
                pControlRange->AddElement( pSelectedElement );

                hr = THR( pIter->Advance() );
                if( hr )
                    goto Cleanup;
            }
        }

        hr = THR( pControlRange->QueryInterface(IID_IDispatch, (void **) ppDisp) );
        pControlRange->Release();
        if (hr)
        {
            *ppDisp = NULL;
            goto Cleanup;
        }            
    }
    else
    {

        hr = THR( pDoc->CreateMarkupPointer( & pStart ));
        if ( hr ) 
            goto Cleanup;
        hr = THR( pDoc->CreateMarkupPointer( & pEnd ));
        if ( hr ) 
            goto Cleanup;
            
        if( !fEmpty )
        {
            CMarkupPointer *pStartPointer = NULL;
            
            hr = THR( pList->CreateIterator( &pIter ) );
            if( hr )
                goto Cleanup;
        
            //
            //
            // Set the range pointers
            //

            hr = pIter->Current(&pSegment);
            if ( hr )
                goto Cleanup;
                
            //
            // Set pStart and pEnd using the segment list
            //
            hr = THR( pSegment->GetPointers( pStart, pEnd ));
            if ( hr )
                goto Cleanup;

            //
            // Retrieve the element and markup that owns selection
            //
            hr = THR( pStart->QueryInterface(CLSID_CMarkupPointer, (void **)&pStartPointer) );
            if( FAILED(hr) || !pStartPointer )
                goto Cleanup;

            pMarkup = pStartPointer->Markup();
            pElement = pMarkup->GetElementTop();

            if( !pElement || !pMarkup )
                goto Cleanup;
        }
        else
        {
            //  Bug 88110: There is no selection. If we have a caret, create an empty range
            //  at the caret location.  This is the functionality of IE 5.0.

            if ( pDoc->_pCaret && pDoc->_pCaret->IsPositioned() &&
                 (  pDoc->_pCaret->IsVisible() ||
                   (pDoc->_pInPlace && pDoc->_pInPlace->_pDataObj)) )
            {
                hr = THR( pDoc->_pCaret->MoveMarkupPointerToCaret(pStart) );
                if ( hr )
                    goto Cleanup;
                hr = THR( pDoc->_pCaret->MoveMarkupPointerToCaret(pEnd) );
                if ( hr )
                    goto Cleanup;
        
                // Make sure that the markup for the range is the same as the markup on the element

                hr = THR( pStart->QueryInterface(CLSID_CMarkupPointer, (void **)&pStartPointer) );
                pTestMarkup = pStartPointer->Markup();
                if (pTestMarkup != pMarkup)
                {
                    pElement = pTestMarkup->GetElementTop();
                    pMarkup = pElement->GetMarkup();
                }
            }
            else
            {
                hr = THR_NOTRACE(
                    pElement->QueryInterface( IID_IHTMLElement, (void**) & pIHTMLElement ) );
                Assert( pIHTMLElement );

                hr = THR( pStart->MoveAdjacentToElement( pIHTMLElement, ELEM_ADJ_AfterBegin ) );
                if ( hr )
                    goto Cleanup;
                hr = THR( pEnd->MoveAdjacentToElement( pIHTMLElement, ELEM_ADJ_AfterBegin ) );
                if ( hr )
                    goto Cleanup;
            }
        }

        // Create a Text Range
        //
        hr = THR( pMarkup->createTextRange(
                (IHTMLTxtRange **) ppDisp, pElement, pStart, pEnd, TRUE ) );
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface( pSelServ );
    ReleaseInterface( pCurElement );
    ReleaseInterface( pIter );
    ReleaseInterface( pList );
    ReleaseInterface( pSegment );
    ReleaseInterface( pStart );
    ReleaseInterface( pEnd );
    ReleaseInterface( pIHTMLElement );
    ReleaseInterface( pIElementSegment );
    RRETURN ( SetErrorInfo(hr) );
}


//+---------------------------------------------------------------------------
//
//  Member:     createRangeCollection
//
//  Synopsis:   returns the current selection.as a range collection
//
//----------------------------------------------------------------------------

HRESULT
CSelectionObject::createRangeCollection( IDispatch ** ppDisp )
{
    HRESULT hr;
    ISelectionServices* pSelServ = NULL;    
    ISegmentList* pSegmentList = NULL;
    ISegmentListIterator    *pIter = NULL; 
    ISegment* pSegment = NULL;
    htmlSelection eSelType;
    CDoc *pDoc = _pDocument->Doc();    
    CElement* pElement = pDoc->_pElemCurrent ;
    IMarkupPointer* pStart = NULL;
    IMarkupPointer* pEnd = NULL;
    IHTMLTxtRange* pITxtRange = NULL;
    CAutoRange* pRange = NULL;
    CMarkup* pMarkup;
    BOOL fSameMarkup=FALSE;
    BOOL fEmpty = FALSE;
    IHTMLElement* pIHTMLElement = NULL;
    
    if (!_pMarkup || !_pMarkup->AccessAllowed(pElement->GetMarkup()))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    IFC(GetType ( &eSelType ));

    if ( eSelType == htmlSelectionControl )
    {
        IFC( createRange( ppDisp ));
    }
    else
    {
        // TODO (MohanB) Hack for INPUT's slave markup. Need to figure out
        // how to generalize this.
        if (pElement->Tag() == ETAG_INPUT && pElement->HasSlavePtr())
        {
            pElement = pElement->GetSlavePtr();
            pMarkup = pElement->GetMarkup();
            Assert(pMarkup);
        }
        else
        {
            pMarkup = pElement->GetMarkup();
            Assert(pMarkup);
            pElement = pMarkup->GetElementTop();        
        }

        if ( pDoc->GetHTMLEditor( FALSE ))
        {
            IFC( pDoc->GetSelectionServices( & pSelServ));

            hr = THR( SameMarkup( &fSameMarkup, pSelServ ) );
            if( hr || !fSameMarkup )
            {
                //
                // Not in the same markup, we have an empty
                // selection.
                //
                fEmpty = TRUE;
            }
            else
            {       
                IFC( pSelServ->QueryInterface(IID_ISegmentList, (void **)&pSegmentList ) );
                IFC( pSegmentList->IsEmpty( &fEmpty ) );
            }
        }
        else
        {
            fEmpty = TRUE;
        }

        CAutoRangeCollection* pRangeColl = new CAutoRangeCollection();
        if(!pRangeColl)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        
        IFC( pDoc->CreateMarkupPointer( & pStart ));
        IFC( pDoc->CreateMarkupPointer( & pEnd ));
        
        if ( ! fEmpty )
        {
            IFC( pSelServ->QueryInterface( IID_ISegmentList, (void**) & pSegmentList ));
            IFC( pSegmentList->CreateIterator( & pIter ));

            while( pIter->IsDone() == S_FALSE )
            {
                IFC( pIter->Current( &pSegment ) );
                IFC( pSegment->GetPointers( pStart, pEnd ));

                //
                // Create a Text Range
                //
                IFC( pMarkup->createTextRange(
                        & pITxtRange, pElement, pStart, pEnd, TRUE ) );

                IFC( pITxtRange->QueryInterface( CLSID_CRange, ( void**) & pRange ));

                pRange->AddRef();
                pRangeColl->AddRange( pRange );
                
                IFC( pIter->Advance() );
                
                ClearInterface( & pITxtRange );
            }
        }
        else
        {
            IFC( pElement->QueryInterface( IID_IHTMLElement, (void**) & pIHTMLElement ) );
            Assert( pIHTMLElement );

            IFC( pStart->MoveAdjacentToElement( pIHTMLElement, ELEM_ADJ_AfterBegin ) );
            IFC( pEnd->MoveAdjacentToElement( pIHTMLElement, ELEM_ADJ_AfterBegin ) );

            //
            // Create a Text Range
            //
            IFC( pMarkup->createTextRange(
                    & pITxtRange, pElement, pStart, pEnd, TRUE ) );

            IFC( pITxtRange->QueryInterface( CLSID_CRange, ( void**) & pRange ));

            pRange->AddRef();
            pRangeColl->AddRange( pRange );
                
        }

        IFC( pRangeColl->QueryInterface( IID_IDispatch, (void**) ppDisp ));
        
    }
    
Cleanup:
    ReleaseInterface( pSelServ );
    ReleaseInterface( pSegmentList );
    ReleaseInterface( pIter );
    ReleaseInterface( pSegment );
    ReleaseInterface( pStart );
    ReleaseInterface( pEnd );
    ReleaseInterface( pIHTMLElement );
    
    RRETURN ( SetErrorInfo(hr ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     get_typeDetail
//
//  Synopsis:   returns the detailed type of the current selection
//
//----------------------------------------------------------------------------

HRESULT
CSelectionObject::get_typeDetail(BSTR * pbstrTypeDetail )
{
    HRESULT hr = S_OK ;
    ISelectionServices* pSelServ = NULL;
    ISelectionServicesListener* pSelServListener = NULL;
    CDoc *pDoc = _pDocument->Doc();    

    if (!pbstrTypeDetail)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( pDoc->GetSelectionServices(& pSelServ ));

    hr = THR( pSelServ->GetSelectionServicesListener( & pSelServListener ));
    if ( FAILED( hr ))
    {
        *pbstrTypeDetail = SysAllocString(_T("undefined"));
        goto Cleanup;
    }        

    if ( pSelServListener )
    {
        IFC( pSelServListener->GetTypeDetail( pbstrTypeDetail ));
    }
    else
    {
        *pbstrTypeDetail = SysAllocString(_T("undefined"));
    }
    
Cleanup:
    ReleaseInterface( pSelServ );
    ReleaseInterface( pSelServListener );
    
    RRETURN (SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     Gettype
//
//  Synopsis: returns, on the parameter, the enumerated value indicating the type
//              of the selection (htmlSelectionText, htmlSelectionTable,
//              htmlSelectionStructure)
//
//  Returns: S_OK if properly executes
//
//----------------------------------------------------------------------------

HRESULT
CSelectionObject::get_type( BSTR *pbstrSelType )
{
    HRESULT hr;
    htmlSelection eSelType;

    if (!pbstrSelType )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(GetType ( &eSelType ));
    if ( hr )
        goto Cleanup;

    hr = THR( STRINGFROMENUM ( htmlSelection, (long)eSelType, pbstrSelType ) );

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CSelectionObject::GetType( htmlSelection *pSelType , BOOL* pfIE4CompatControlRange )
{
    HRESULT             hr = S_FALSE;
    ISelectionServices  *pSelServ = NULL;
    ISegmentList        *pList = NULL;
    SELECTION_TYPE      eType = SELECTION_TYPE_None;
    
    BOOL                bSameMarkup;
    CDoc                *pDoc = _pDocument->Doc();

    CElement *  pElement    = pDoc->_pElemCurrent;
    CMarkup *   pMarkup;
    
    if ( pfIE4CompatControlRange )                         
        *pfIE4CompatControlRange = FALSE;
        
    // TODO (MohanB) Hack for INPUT's slave markup. Need to figure out
    // how to generalize this.
    if (pElement->Tag() == ETAG_INPUT && pElement->HasSlavePtr())
    {
        pElement = pElement->GetSlavePtr();
    }
    pMarkup = pElement->GetMarkup();

    if ( pDoc->GetHTMLEditor( FALSE )) 
    {
        hr = THR( pDoc->GetSelectionServices(& pSelServ ));
        if ( hr )
            goto Cleanup;

        //
        // Check to make sure the segment list is 
        // on the same markup as we are
        //
        hr = THR( SameMarkup( &bSameMarkup, pSelServ ) );
        if( hr || !bSameMarkup )
        {
            *pSelType = htmlSelectionNone;
            goto Cleanup;
        }

        hr = THR( pSelServ->QueryInterface(IID_ISegmentList, (void **)&pList ) );
        if ( hr )
            goto Cleanup;
           
        hr = THR( pList->GetType( &eType ));
        if ( hr )
            goto Cleanup;
    }
    else
    {
        eType = SELECTION_TYPE_None; // if we don't have an editor - how can we have a selection ?
        hr = S_OK;
    }
    
    switch( eType )
    {
        case SELECTION_TYPE_Control:
            *pSelType = htmlSelectionControl;
            break;

        case SELECTION_TYPE_Text:
            *pSelType = htmlSelectionText;
            break;

        //
        // A Caret should return a Selection of 'None', for IE 4.01 Compat
        //
        default:  
            //
            // We return 'none' - unless we're a UI-Active ActiveX Control
            // with an invisible caret - in which case we return "control"
            // for IE 4 compat.
                        
            *pSelType = htmlSelectionNone;

            IHTMLEditor* ped = pDoc->GetHTMLEditor(FALSE);
            if ( ped )
            {
                if ( pDoc->_pElemCurrent && ped->IsEditContextUIActive() == S_OK )
                {
                    *pSelType = ( !pDoc->IsCaretVisible() ) || 
                                  pDoc->_pElemCurrent->IsNoScope() ? 
                                    htmlSelectionControl : htmlSelectionNone;

                    if ( ( *pSelType == htmlSelectionControl ) && pfIE4CompatControlRange )
                    {
                        *pfIE4CompatControlRange = TRUE;
                    }
                }
            }
    }

Cleanup:
    ReleaseInterface( pSelServ );
    ReleaseInterface( pList );

    RRETURN(hr);
}




//+---------------------------------------------------------------------------
//
//  Member:     clear
//
//  Synopsis: clears the selection and sets the selction type to NONE
//              this is spec'd to behave the same as edit.clear
//
//  Returns: S_OK if executes properly.
//
//----------------------------------------------------------------------------

HRESULT
CSelectionObject::clear()
{
    HRESULT hr;
    BOOL    bSameMarkup;

    //
    // Check to make sure the segment list is 
    // on the same markup as we are
    //
    hr = THR( SameMarkup( &bSameMarkup ) );
    if( FAILED(hr) || !bSameMarkup )
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr  =   _pDocument->Doc()->ExecHelper(
            _pDocument,
            (GUID *) &CGID_MSHTML,
            IDM_DELETE,
            0,
            NULL,
            NULL);
Cleanup:

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:   empty
//
//  Synopsis: Nulls the selection and sets the selction type to NONE
//
//  Returns: S_OK if executes properly.
//
//----------------------------------------------------------------------------

HRESULT
CSelectionObject::empty()
{
    HRESULT hr;
    BOOL    bSameMarkup;
      
    hr = THR( SameMarkup( &bSameMarkup ) );
    if( FAILED(hr) || !bSameMarkup )
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR( _pDocument->Doc()->EmptySelection() );
    if( FAILED(hr) )
        goto Cleanup;

Cleanup:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\sui.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       sui.cxx
//
//  Contents:   Implementation of CServer UI
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#include "commctrl.h"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include "mshtmhst.h"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif

#ifndef X_FRAMELYT_HXX_
#define X_FRAMELYT_HXX_
#include "framelyt.hxx"
#endif

#ifndef X_HTIFRAME_H_
#define X_HTIFRAME_H_
#include <htiframe.h>
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#include "eventobj.h"

#ifndef NO_IME
extern HRESULT DeactivateDIMM(); // imm32.cxx
#endif // ndef NO_IME

#if DBG == 1
#define MAXLABELLEN 32

static HMENU hMenuHelp;

//+---------------------------------------------------------------
//
//  Member:     CDoc::InsertSharedMenus
//
//  Synopsis:   Inserts the objects menus into a shared menu after
//              the top-level application has inserted its menus
//
//  Arguments:  [hmenuShared] -- the shared menu to recieve the objects menus
//              [hmenuObject] -- all of the objects menus
//              [lpmgw] -- menu group widths indicating where the menus
//                          should be inserted
//              [lOffset] -- Server position offset for hmenuObject
//
//  Returns:    Success if the menus were merged successfully
//
//  Notes:      The function does most of the shared menu work
//              by the object between the IOleInPlaceFrame::InsertMenus and
//              IOleInPlaceFrame::SetMenu method calls.
//              c.f. RemoveServerMenus
//
//----------------------------------------------------------------

HRESULT
CDoc::InsertSharedMenus(
        HMENU hmenuShared,
        HMENU hmenuObject,
        LPOLEMENUGROUPWIDTHS lpmgw)
{
    int i, j;
    UINT SvrPos, ShdPos;
    HMENU hmenuXfer;
    TCHAR szLabel[MAXLABELLEN];

    SvrPos = 0;
    ShdPos = 0;

    // for each of the Edit, Object, and Help menu groups
    for (j = 1; j <= 5; j += 2)
    {
        // advance over container menus
        ShdPos += (UINT)lpmgw->width[j-1];

        // special consideration for j = 5 because of
        // DocObject HELP menu merging.

        if (j == 5)
        {
            if (lpmgw->width[j] != 0)
            {
                BOOL    fHide = FALSE;

                // check if host want hide our help menu,
                if (_pHostUIHandler &&
                    (_dwFlagsHostInfo & DOCHOSTUIFLAG_DISABLE_HELP_MENU))
                {
                    fHide = TRUE;
                }

                if (!fHide)
                {
                    GetMenuString(
                                hmenuObject,
                                ++SvrPos,
                                szLabel,
                                MAXLABELLEN,
                                MF_BYPOSITION);

                    hMenuHelp = GetSubMenu(hmenuShared, ShdPos);
                    hmenuXfer = GetSubMenu(hmenuObject, SvrPos);
                    if (!AppendMenu(
                            hMenuHelp,
                            MF_POPUP | MF_STRING,
                            (UINT_PTR) hmenuXfer,
                            szLabel))
                    {
                        return HRESULT_FROM_WIN32(GetLastError());
                    }
                }

                lpmgw->width[j - 1] += lpmgw->width[j];
                lpmgw->width[j]      = 0;
                continue;
            }
            else
            {
                // no HELP menu in the container
                //
                hMenuHelp = NULL;
                lpmgw->width[j] = 1;
            }
        }

        // pull out the popup menus from servers menu
        for (i = 0; i < lpmgw->width[j]; i++)
        {
            GetMenuString(hmenuObject,
                    SvrPos,
                    szLabel,
                    MAXLABELLEN,
                    MF_BYPOSITION);
            hmenuXfer = GetSubMenu(hmenuObject, SvrPos++);
            if (!InsertMenu(hmenuShared,
                        ShdPos++,
                        MF_BYPOSITION | MF_POPUP | MF_STRING,
                        (UINT_PTR)hmenuXfer,
                        szLabel))
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::RemoveSharedMenus
//
//  Synopsis:   Removes the objects menus from a shared menu
//
//  Arguments:  [hmenuShared] -- the menu contain both the application's
//                              and the object's menus
//              [lpmgw] -- menu group widths indicating which menus should
//                          be removed
//
//  Notes:      c.f. InsertServerMenus
//
//----------------------------------------------------------------

void
CDoc::RemoveSharedMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpmgw)
{
    int i, j;
    UINT ShdPos;

    ShdPos = 0;

    if (hMenuHelp)
    {
        // remove the Object part of the merged HELP menu
        //
        RemoveMenu(hMenuHelp, GetMenuItemCount(hMenuHelp) - 1, MF_BYPOSITION);
    }

    // for each of the Edit, Object, and Help menu groups
    for (j = 1; j <= 5; j += 2)
    {
        // advance over container menus
        ShdPos += (UINT)lpmgw->width[j-1];

        // pull out the popup menus from shared menu
        for (i = 0; i < lpmgw->width[j]; i++)
        {
            RemoveMenu(hmenuShared, ShdPos, MF_BYPOSITION);
        }
    }

    return;
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::CreateMenuUI
//
//  Synopsis:   Creates menu UI elements using menu specified
//              in class descriptor.
//
//---------------------------------------------------------------


HRESULT
CDoc::CreateMenuUI()
{
    HRESULT             hr = S_OK;
#ifndef NO_OLEUI
    HMENU               hmenu;
    HMENU               hmenuShared;
    OLEMENUGROUPWIDTHS *pmgw;

    Assert(InPlace());

    //  We ignore any failures; a failure just means some part of
    //    the UI won't appear.

    Assert((InPlace()->_hmenuShared) == NULL);
    Assert((InPlace()->_hmenu) == NULL);

    pmgw = &(InPlace()->_mgw);

    if (DesignMode())
    {
        hmenu = TFAIL_NOTRACE(0, LoadMenu(
                GetResourceHInst(),
                MAKEINTRESOURCE(IDR_HTMLFORM_MENUDESIGN)));
        *pmgw = s_amgw[0];
    }
    else
    {
        hmenu = TFAIL_NOTRACE(0, LoadMenu(
                GetResourceHInst(),
                MAKEINTRESOURCE(IDR_HTMLFORM_MENURUN)));
#if 0
        // Note: this will go away with BeomOh's com work
        extern HMENU CreateMimeCSetMenu();

        // Dynamic adding language menu
        if (hmenu)
        {
            // Get "View" menu
            HMENU hmenuView = GetSubMenu(hmenu, 1);

            // Consider: Write a wrapper for SetMenuItemInfo.  We are using
            //  SetMenuItemInfo directly since we never need to set the one
            //  LPTSTR member of the MENUITEMINFO structure.
            MENUITEMINFO mii;

            mii.cbSize = sizeof(mii);
            mii.fMask  = MIIM_SUBMENU;
            mii.hSubMenu = CreateMimeCSetMenu();
            SetMenuItemInfo(hmenuView, IDM_LANGUAGE, FALSE, &mii);
        }
#endif
        *pmgw = s_amgw[1];
    }
    if (!hmenu)
        goto Cleanup;

    hmenuShared = TFAIL(0, CreateMenu());
    if (!hmenuShared)
        goto Cleanup;

    hr = THR(InPlace()->_pFrame->InsertMenus(hmenuShared, pmgw));
    if (hr)
        goto Cleanup;

    hr = THR(InsertSharedMenus(hmenuShared, hmenu, pmgw));
    if (hr)
        goto Cleanup;

    InPlace()->_hmenu = hmenu;
    InPlace()->_hmenuShared = hmenuShared;
    InPlace()->_hOleMenu = OleCreateMenuDescriptor(hmenuShared, pmgw);

Cleanup:
#endif // NO_OLEUI
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::DestroyMenuUI, protected
//
//  Synopsis:   This method "undoes" everything that was done in
//              CreateMenuUI -- destroys the shared menu and OLE menu
//              descriptor.
//---------------------------------------------------------------

void
CDoc::DestroyMenuUI(void)
{
#ifndef NO_OLEUI
    Assert(InPlace());

    if (InPlace()->_hmenuShared)
    {
        HMENU hmenu = InPlace()->_hmenuShared;

        RemoveSharedMenus(hmenu, &InPlace()->_mgw);
        InPlace()->_pFrame->RemoveMenus(hmenu);
        DestroyMenu(hmenu);
        InPlace()->_hmenuShared = NULL;
    }

    if (InPlace()->_hmenu)
    {
        DestroyMenu(InPlace()->_hmenu);
        InPlace()->_hmenu = NULL;
    }
    if (InPlace()->_hOleMenu)
    {
        OleDestroyMenuDescriptor(InPlace()->_hOleMenu);
        InPlace()->_hOleMenu = NULL;
    }
#endif // NO_OLEUI
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::InstallMenuUI, protected
//
//  Synopsis:   This method uses IOleInPlaceFrame::SetMenu to
//              install the shared menu constructed in CreateMenuUI.
//
//---------------------------------------------------------------

HRESULT
CDoc::InstallMenuUI()
{
#ifdef NO_OLEUI
    return S_OK;
#else
    // Ignore spurious WM_ERASEBACKGROUNDs generated by SetMenu
    CLock   Lock(this, SERVERLOCK_IGNOREERASEBKGND);
    HRESULT hr;

    if (!InPlace()->_hOleMenu)
    {
        hr = CreateMenuUI();
        if (hr)
            goto Cleanup;
    }

    hr = THR(InPlace()->_pFrame->SetMenu(
            InPlace()->_hmenuShared,
            InPlace()->_hOleMenu,
            InPlace()->_hwnd));
    if (hr)
        goto Cleanup;

    InPlace()->_fMenusMerged = 1;

Cleanup:
    RRETURN(hr);
#endif // NO_OLEUI
}

//+-------------------------------------------------------------------
//
//  Window Procedure: ComboWndProc
//
//  Synopsis:
//
//--------------------------------------------------------------------

#if defined(DBG_TOOLTIPS)

static WNDPROC lpfnDefCombo;

LRESULT CALLBACK
ComboWndProc(HWND hWnd,
             UINT uMessage,
             WPARAM wParam,
             LPARAM lParam)
{
    MSG        msg;
    HWND       hwndTooltip;

    switch (uMessage)
    {
    case WM_MOUSEMOVE :
    case WM_LBUTTONDOWN :
    case WM_LBUTTONUP :
        msg.lParam  = lParam;
        msg.wParam  = wParam;
        msg.message = uMessage;
        msg.hwnd    = hWnd;
        hwndTooltip = (HWND) SendMessage(GetParent(hWnd), TB_GETTOOLTIPS, 0, 0);
        SendMessage(hwndTooltip, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)&msg);
        break;

    case WM_CHAR:
        // Don't allow the user to type anything into the combo
        return 0;
    }
    return CallWindowProc(lpfnDefCombo, hWnd, uMessage, wParam, lParam);
}

#endif

//+-------------------------------------------------------------------
//
// Local Helper Function: InstallComboboxTooltip
//
//--------------------------------------------------------------------

#if defined(DBG_TOOLTIPS)

void InstallComboboxTooltip(HWND hwndCombo, UINT IDMmessage)
{
    HWND     hwndTooltip;
    TOOLINFO tbToolInfo;

    hwndTooltip = (HWND) SendMessage(
            GetParent(hwndCombo),
            TB_GETTOOLTIPS,
            0,
            0);

    SetWindowLongPtr(hwndCombo, GWLP_WNDPROC, (LONG_PTR)ComboWndProc);

    tbToolInfo.cbSize   = sizeof(TOOLINFO);
    tbToolInfo.uFlags   = TTF_IDISHWND;
    tbToolInfo.hwnd     = GetParent(hwndCombo);
    tbToolInfo.uId      = (UINT) hwndCombo;
    tbToolInfo.hinst    = 0;

#ifndef WINCE
    DWORD dwVersion = GetVersion();
#else
    DWORD dwVersion = 0;
#endif

#ifdef WIN16
    // BUGWIN16: something different for Win16 ??
    // vamshi - 1/24/97
#else
    tbToolInfo.lpszText = (dwVersion < 0x80000000) ?
            ((LPTSTR) LPSTR_TEXTCALLBACKW) : ((LPTSTR) LPSTR_TEXTCALLBACKA);
    SendMessage(
            hwndTooltip,
            (dwVersion < 0x80000000) ? (TTM_ADDTOOLW) : (TTM_ADDTOOLA),
            0,
            (LPARAM)(LPTOOLINFO)&tbToolInfo);
#endif
}

#endif

//+-------------------------------------------------------------------
//
//  Callback:   FillFontProc
//
//  This procedure is called by the EnumFontFamilies call.
//  It fills the combobox with the font facename.
//
//--------------------------------------------------------------------

int CALLBACK
FillFontProc(LOGFONT FAR *    lplf,
             TEXTMETRIC FAR * lptm,
             int              iFontType,
             LPARAM           lParam)
{
    int  fontStyle[3];
    char szFontName[128];

    // We don't want to list the vertical fonts.
    // These by convention start with an @ symbol.
    if (lplf->lfFaceName[0] == L'@')
        return TRUE;

    fontStyle[0] = (lplf->lfWeight == FW_BOLD) ? (1) : (0);
    fontStyle[1] = (lplf->lfItalic == TRUE)    ? (1) : (0);
    fontStyle[2] = (lplf->lfUnderline == TRUE) ? (1) : (0);
    WideCharToMultiByte(
            CP_ACP,
            0,
            (const WCHAR *) lplf->lfFaceName,
            -1,
            szFontName,
            ARRAY_SIZE(szFontName),
            NULL,
            NULL);
    if (CB_ERR == (WPARAM) SendMessage((HWND) lParam,CB_FINDSTRING,
                  (WPARAM) -1,(LPARAM)(lplf->lfFaceName)))
    {
        SendMessage((HWND)lParam,CB_ADDSTRING,
                    (WPARAM) 0,(LPARAM)(lplf->lfFaceName));
    }
    return TRUE;
}

//+-------------------------------------------------------------------
//
// Local Helper Functions: AddComboboxItems, ConvColorrefToString
//
//--------------------------------------------------------------------

struct ComboItem {
        INT     iIdm;
        LONG    lData;
};

static const ComboItem ComboColorItems[] =
{
    {IDS_COLOR_BLACK,      RGB(0, 0, 0)},
    {IDS_COLOR_NAVY,       RGB(0, 0, 128)},
    {IDS_COLOR_BLUE,       RGB(0, 0, 255)},
    {IDS_COLOR_CYAN,       RGB(0, 255, 255)},
    {IDS_COLOR_RED,        RGB(255, 0, 0)},
    {IDS_COLOR_LIME,       RGB(0, 255, 0)},
    {IDS_COLOR_GRAY,       RGB(128, 128, 128)},
    {IDS_COLOR_GREEN,      RGB(0, 128, 0)},
    {IDS_COLOR_YELLOW,     RGB(255, 255, 0)},
    {IDS_COLOR_PINK,       RGB(255, 192, 203)},
    {IDS_COLOR_VIOLET,     RGB(238, 130, 238)},
    {IDS_COLOR_WHITE,      RGB(255, 255, 255)},
    {0, 0L}
};


void ConvColorrefToString(COLORREF crColor, LPTSTR szName, int cchName )
{
    int     i;
    BOOL fFound = FALSE;

    if(crColor == (COLORREF)-1)
    {
        szName[0] = 0;
        return;
    }

    // Reset the upper 8 bits because palettergb type color values have them
    // set to 0x20 and the compare will fail
    crColor &= 0xFFFFFF;

    for(i = 0; ComboColorItems[i].iIdm != 0; i++)
    {
        if(ComboColorItems[i].lData == (LONG)crColor)  {
            fFound = TRUE;
            break;
        }
    }

    if(fFound)
        Format(0, szName, cchName, MAKEINTRESOURCE(ComboColorItems[i].iIdm));
    else
        szName[0] = 0;
}


DWORD AddComboboxItems(HWND hwndCombo,
                       BOOL fItemData,
                       const ComboItem * pComboItems)
{
    DWORD   dwIndex = 0;
    TCHAR   achColor[128];

    while(pComboItems->iIdm)
    {
        Format(0, achColor, ARRAY_SIZE(achColor),
                  MAKEINTRESOURCE(pComboItems->iIdm));

        dwIndex = SendMessage(
                hwndCombo,
                CB_ADDSTRING,
                0,
                (LPARAM) achColor);
        if (fItemData)
        {
            SendMessage(
                    hwndCombo,
                    CB_SETITEMDATA,
                    dwIndex,
                    (LPARAM) pComboItems->lData);
        }
        pComboItems ++;
    }
    return dwIndex;
}
#endif // DBG == 1

//+---------------------------------------------------------------
//
//  Member:     CDoc::OnFrameWindowActivate, IOleInPlaceActiveObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//---------------------------------------------------------------

HRESULT
CDoc::OnFrameWindowActivate(BOOL fActivate)
{  
    if (_pHostUIHandler)
    {
        _pHostUIHandler->OnFrameWindowActivate(fActivate);
    }

    if (_fIsPrintWithNoUI)
        return S_OK;

    return super::OnFrameWindowActivate(fActivate);
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::OnDocWindowActivate, IOleInPlaceActiveObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method will install or remove the frame
//              U.I. elements using the InstallFrameUI or RemoveFrameUI
//              methods.  This is to properly handle the MDI application
//              case.  It also updates our shading color.
//
//---------------------------------------------------------------

HRESULT
CDoc::OnDocWindowActivate(BOOL fActivate)
{
    if (_pHostUIHandler)
    {
        _pHostUIHandler->OnDocWindowActivate(fActivate);
    }

    return super::OnDocWindowActivate(fActivate);

}


//+---------------------------------------------------------------
//
//  Member:     CDoc::ResizeBorder, IOleInPlaceActiveObject
//
//  Synopsis:   Handle border space change.
//
//---------------------------------------------------------------

HRESULT
CDoc::ResizeBorder(
        LPCOLERECT prc,
        LPOLEINPLACEUIWINDOW pUIWindow,
        BOOL fFrameWindow)
{
    HRESULT hr = S_OK;

    if (!_pInPlace)
        return S_OK;

    if(InPlace()->_fHostShowUI)
    {
        Assert(_pHostUIHandler);
        _pHostUIHandler->ResizeBorder((RECT *)prc, pUIWindow, fFrameWindow); //RECT * is for win16. doesn't affect 32bit.
        return S_OK;
    }

    RRETURN_NOTRACE(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::EnableModeless, IOleInPlaceActiveObject
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//---------------------------------------------------------------
HRESULT
CDoc::EnableModeless(BOOL fEnable)
{
    return EnableModelessImpl(fEnable, FALSE, FALSE);
}

HRESULT
CDoc::EnableModelessImpl(BOOL fEnable, BOOL fLocalDisable, BOOL fBottomUp)
{
    // NOTE: (jbeda)
    // When hosted in shdocvw in the IE5.0 scenario, 
    // all navigation is prevented when the host does 
    // an EnableModeless(FALSE).  We do the same
    // thing by using a CDoc flag instead of
    // broadcasting down to each individual window

    // We don't need to set/rest the CDoc block if our call originate from Trident
    // However, if Trident does not have a context fInside is false, so we know we
    // are from Trident if we are bottom up.

    if (!fBottomUp)
    {
        if (fEnable)
        {
            _fDisableModeless = FALSE;
        }
        else
        {
            _fDisableModeless = TRUE;
        }
    }

    // Despite being from Trident we may not have a context
    if (!fLocalDisable && fBottomUp)
    { 
        if (fEnable)
            _ulDisableModeless--;
        else
            _ulDisableModeless++;
    }


    if(_pHostUIHandler)
    {
        _pHostUIHandler->EnableModeless(fEnable);
    }

    if (_pIHTMLEditor)
    {
        _pIHTMLEditor->EnableModeless(fEnable);
    }
    
    // This is just a hack for PumpMessageHelper(0 to know
    // if a modal dialog has been brought in an event handler.
    // The flag is cleared by PumpMessageHelper().
    if (!fEnable)
        _fModalDialogInScript = TRUE;

    if (!fLocalDisable && !_fDisableModeless && _ulDisableModeless == 0)
    {
        NotifyMarkupsModelessEnable();
    }

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CDoEnableModeless::CDoEnableModeless
//
//  Synopsis:   ctor of object which wraps enable modeless 
//              functionality.
//
//---------------------------------------------------------------

CDoEnableModeless::CDoEnableModeless(CDoc * pDoc, CWindow * pWindow, BOOL fAuto)
{
    _pWindow = pWindow;
    _pDoc = pDoc;
    _fCallEnableModeless = FALSE;
    _fAuto = FALSE;

    if (!_pDoc)
        return;

    if (fAuto)
    {
        if ((pWindow && pWindow->CanNavigate()) || 
            (!pDoc->_fDisableModeless && (pDoc->_ulDisableModeless == 0)))
        {
            _fAuto = TRUE;
            DisableModeless();
        }
        else
        {
            _hwnd = _pDoc->GetHWND();
            if (!_hwnd)
            {
                IOleWindow *pOleWindow = NULL;

                if (_pDoc->_pClientSite && !_pDoc->_pClientSite->QueryInterface(
                        IID_IOleWindow, (void **)&pOleWindow))
                {
                    IGNORE_HR(pOleWindow->GetWindow(&_hwnd));
                }

                ReleaseInterface(pOleWindow);
            }
        }
    }
}


//+---------------------------------------------------------------
//
//  Member:     CDoEnableModeless::~CDoEnableModeless
//
//  Synopsis:   dtor
//
//---------------------------------------------------------------

CDoEnableModeless::~CDoEnableModeless()
{
    if (_fAuto)
    {
        EnableModeless();
    }
}


//+---------------------------------------------------------------
//
//  Member:     CDoEnableModeless::DisableModeless
//
//  Synopsis:   Worker which goes about disabling modeless.
//              Sets state on whether or not EnableModeless does
//              any work.
//
//---------------------------------------------------------------

void
CDoEnableModeless::DisableModeless()
{
    IOleWindow *    pOleWindow = NULL;

    if (_pDoc->_state >= OS_INPLACE)
    {
        // If we're not interactive yet, we should be.
        _pDoc->PrimaryMarkup()->OnLoadStatus(LOADSTATUS_INTERACTIVE);
    }

    // if we have a _pWindow, then do that window and up
    // othwerwise disable the entire doc
    _pDoc->EnableModelessImpl(FALSE, !!_pWindow, TRUE);
    if (_pWindow)
        _pWindow->EnableModelessUp(FALSE);

    if (_pDoc->_pInPlace && _pDoc->_pInPlace->_pFrame)
    {
        _fCallEnableModeless = TRUE;
        _pDoc->_pInPlace->_pFrame->EnableModeless(FALSE);
    }

    _hwnd = _pDoc->GetHWND();
    if (!_hwnd)
    {
        if (_pDoc->_pClientSite && !_pDoc->_pClientSite->QueryInterface(
                IID_IOleWindow, (void **)&pOleWindow))
        {
            IGNORE_HR(pOleWindow->GetWindow(&_hwnd));
        }
    }

    _pDoc->SetCapture(FALSE);

    ReleaseInterface(pOleWindow);
}


//+---------------------------------------------------------------
//
//  Member:     CDoEnableModeless::EnableModeless
//
//  Synopsis:   Worker which does opposite of DisableModeless
//
//---------------------------------------------------------------

void
CDoEnableModeless::EnableModeless(BOOL fForce)
{
    _pDoc->EnableModelessImpl(TRUE, !!_pWindow, TRUE);
    if (_pWindow)
        _pWindow->EnableModelessUp(TRUE);
    if (_fCallEnableModeless || fForce)
    {
        if (_pDoc->_pInPlace && _pDoc->_pInPlace->_pFrame)
        {
            _pDoc->_pInPlace->_pFrame->EnableModeless(TRUE);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CDoc::ShowMessage/ShowMessageV
//
//  Synopsis:   Show display a message box to the user.
//
//  Arguments:  pnResult      Return result per Windows MessageBox. Can be null.
//              dwFlags       Flags taken from the Windows MB_ enumeration.
//              dwHelpContext Help context in Forms^3 help file
//              idsMessage    String id of message. Use null terminator in
//                            message to separate message parts (bold/norma).
//
//--------------------------------------------------------------------------

HRESULT __cdecl
CDoc::ShowMessage(        
        int * pnResult,
        DWORD dwFlags,
        DWORD dwHelpContext,
        UINT  idsMessage, ...) 
{
    HRESULT hr;
    va_list arg;

    va_start(arg, idsMessage);
    hr = THR(ShowMessageV(pnResult, dwFlags, dwHelpContext, idsMessage, &arg));
    va_end(arg);
    RRETURN(hr);
}

HRESULT
CDoc::ShowMessageV(      
        int *pnResult,
        DWORD dwFlags,
        DWORD dwHelpContext,
        UINT idsMessage,
        void *pvArgs)    
{
    HRESULT hr = S_OK;
    TCHAR * pch = NULL;

    if (THR(VFormat(FMT_OUT_ALLOC,
            &pch,
            0,
            MAKEINTRESOURCE(idsMessage),
            pvArgs)))                
        goto Cleanup;

    hr = THR(ShowMessageEx(            
            pnResult,
            dwFlags,
            GetFormsHelpFile(),
            dwHelpContext,
            pch));          

Cleanup:
    delete [] pch;
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::ShowMessageEx
//
//  Synopsis:   Show a message to the user. This is a helper function
//              for ShowMessage, ShowMessageV, and DisplayLastError.
//              We first query the IDocHostUIHandler, if that fails,
//              we make an Exec call on the host, if that fails,
//              we make an Exec call on the backup shdocvw.              
//             
//--------------------------------------------------------------------------

HRESULT
CDoc::ShowMessageEx(       
        int   *     pnResult,
        DWORD       dwStyle,
        TCHAR *     pchHelpFile,
        DWORD       dwHelpContext,
        TCHAR *     pchText)       
{       
    int                 nResult = 0;
    HWND                hwnd = NULL;          
    IOleCommandTarget * pBackupUICommandHandler = NULL;           
    TCHAR             * pchCaption = NULL;
    EVENTPARAM          param(this, NULL, NULL, TRUE);
    VARIANT             varIn, varOut;
    
    // TODO: (jbeda) window context would be good here
    CDoEnableModeless   dem(this, NULL);
    
    //
    // TODO: allowing alert in popup might cause hang
    // however, since some stability work has been done
    // in the popup, this is allowed again
    //
#ifdef  NEVER

    if (_fPopupDoc)
    {
        //
        // dismiss popup if this is a popup doc
        //
        IGNORE_HR(DoVerb(OLEIVERB_HIDE,
                                    NULL,
                                    _pClientSite,
                                    0,
                                    NULL,
                                    NULL));
    }
#endif

    hwnd = dem._hwnd;
    if (hwnd)                   
        MakeThisTopBrowserInProcess(hwnd);
    
    if (Format(FMT_OUT_ALLOC, &pchCaption, 0, MAKEINTRESOURCE(IDS_MESSAGE_BOX_TITLE)))
        goto Cleanup;             

    // See if the IDocHostShowUI interface is implemented
    if (InPlace() && InPlace()->_pHostShowUI)
    {         
        if (!InPlace()->_pHostShowUI->ShowMessage(
                _pInPlace->_hwnd,
                pchText,
                pchCaption,
                dwStyle,
                pchHelpFile,
                dwHelpContext,
                (LRESULT *)&nResult))             
            goto Cleanup;
    }

    // Fill out expandos
    param.SetType(_T("message"));
    param.messageParams.pchMessageText          = pchText;
    param.messageParams.pchMessageCaption       = pchCaption;
    param.messageParams.dwMessageStyle          = dwStyle;
    param.messageParams.pchMessageHelpFile      = pchHelpFile;   
    param.messageParams.dwMessageHelpContext    = dwHelpContext;                            

    V_VT(&varIn) = VT_UNKNOWN;
    V_UNKNOWN(&varIn) = (IUnknown*)(IPrivateUnknown *)this;

    // Query the host to handle showing the message
    if (_pHostUICommandHandler && !_fOutlook98)
    {        
         // If host displayed message box, Forms3 will not display its own.
        if (!_pHostUICommandHandler->Exec(
                &CGID_DocHostCommandHandler, 
                OLECMDID_SHOWMESSAGE, 
                0, 
                &varIn,
                &varOut))
        {
            nResult = V_I4(&varOut);
            goto Cleanup;        
        }
    }
              
    // Let backup show the message          
    EnsureBackupUIHandler();
    if (!_pBackupHostUIHandler)                            
        goto Cleanup;       
                        
    if (_pBackupHostUIHandler->QueryInterface(IID_IOleCommandTarget,
            (void **) &pBackupUICommandHandler))  
        goto Cleanup;                               
    
    if (!THR(pBackupUICommandHandler->Exec(
            &CGID_DocHostCommandHandler,         
            OLECMDID_SHOWMESSAGE,         
            0,         
            &varIn,        
            &varOut)))
        nResult = V_I4(&varOut);
                                                                                           
Cleanup:
    if (pnResult)            
        *pnResult = nResult;
    
    ReleaseInterface(pBackupUICommandHandler);  

    MemFreeString(pchCaption);

    RRETURN (S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::ShowLastErrorInfo
//
//  Synopsis:   Show the current error object.
//
//--------------------------------------------------------------------------

HRESULT
CDoc::ShowLastErrorInfo(HRESULT hrError, int idsDefault)
{
    if (OK(hrError))
        return S_OK;

    HRESULT      hr;
    IErrorInfo * pErrorInfo = NULL;
    CErrorInfo * pEI;
    BSTR         bstrDescription = NULL;
    BSTR         bstrSolution = NULL;
    BSTR         bstrHelpFile = NULL;
    BSTR         bstrSource = NULL;
    TCHAR *      pchSolution = NULL;
    TCHAR *      pchDescription = NULL;
    DWORD        dwHelpContext = 0;
    TCHAR *      pch = NULL;
    TCHAR *      pchText = NULL;   

    hr = THR(::GetErrorInfo(0, &pErrorInfo));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(pErrorInfo->QueryInterface(
            CLSID_CErrorInfo,
            (void **)&pEI));
    if (OK(hr))
    {
        hr = THR(pEI->GetDescriptionEx(
                &bstrDescription,
                &bstrSolution));
        if (hr)
            goto Cleanup;

        if (bstrSolution)
        {
            hr = THR(Format(FMT_OUT_ALLOC, &pchSolution, 0,
                    MAKEINTRESOURCE(IDS_ERROR_SOLUTION), bstrSolution));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        hr = THR(pErrorInfo->GetDescription(&bstrDescription));
        if (hr)
            goto Cleanup;
    }

    if (!bstrDescription)
    {
        // we got no default text, therefore we will use
        // a standard error text, passed in iIDSDefault
        // that fixes the allpage
        // propertysettings (bug6525).
        Assert(idsDefault);

        hr = THR(Format(FMT_OUT_ALLOC, &pchDescription, 0,
                    MAKEINTRESOURCE(idsDefault), bstrSolution));

        if (hr)
            goto Cleanup;
    }


    THR_NOTRACE(pErrorInfo->GetHelpFile(&bstrHelpFile));
    THR_NOTRACE(pErrorInfo->GetHelpContext(&dwHelpContext));
    THR_NOTRACE(pErrorInfo->GetSource(&bstrSource));

    // Glue header and body together for message box.

    pchText = bstrDescription? bstrDescription : pchDescription;

    if (pchSolution)
    {
        hr = THR(Format(FMT_OUT_ALLOC,
                &pch,
                0,
                TEXT("<0s>\n\n<1s>"), pchText, pchSolution));
        if (hr)
            goto Cleanup;
        pchText = pch;
    }

    hr = THR(ShowMessageEx(NULL,
            MB_ICONEXCLAMATION | MB_OK,
            bstrHelpFile,
            dwHelpContext,
            pchText));            

Cleanup:

    delete pchSolution;
    delete pchDescription;
    delete pch;

    FormsFreeString(bstrSolution);
    FormsFreeString(bstrDescription);
    FormsFreeString(bstrHelpFile);
    FormsFreeString(bstrSource);

    ReleaseInterface(pErrorInfo);

    RRETURN1(hr, S_FALSE);   
}

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::ShowHelp
//
//  Synopsis:   Show help to the user.
//
//--------------------------------------------------------------------------

HRESULT
CDoc::ShowHelp(TCHAR * szHelpFile, DWORD dwData, UINT uCmd, POINT pt)
{
    HRESULT             hr;
    IDispatch *         pDispatch = NULL;

    if (InPlace() && InPlace()->_pHostShowUI)
    {
        hr = QueryInterface(
                IID_IDispatch,
                (void **) &pDispatch);
        if (hr)
            goto Cleanup;

        hr = InPlace()->_pHostShowUI->ShowHelp(
                _pInPlace->_hwnd,
                szHelpFile,
                uCmd,
                dwData,
                pt,
                pDispatch);

        // If host displayed help, we will not display our own.
        if (!hr)
            goto Cleanup;
    }

    if (szHelpFile)
    {
        // TODO: Temporary fix for beta1 to append window style.
        // Append ">LangRef"
        _tcscat(szHelpFile, _T(">LangRef"));
        if (WinHelp(TLS(gwnd.hwndGlobalWindow), szHelpFile, uCmd, dwData))
            hr = S_OK;                        
        else
            hr = E_FAIL;               
    }
    else
        hr = E_NOTIMPL;

Cleanup:
    ReleaseInterface(pDispatch);
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Function:   InvalidateBorder
//
//  Synopsis:   Invalidates the 1 pixel border which is drawn
//              around frames
//
//---------------------------------------------------------------

static void
InvalidateBorder(CDoc *pDoc)
{
    if ((pDoc->PrimaryMarkup()->GetFrameOptions() & FRAMEOPTIONS_NO3DBORDER) == 0 &&
        (pDoc->_dwFlagsHostInfo  & DOCHOSTUIFLAG_NO3DBORDER) == 0)
    {
        // invalidate a 4 pixel-wide area at the perimeter
        // of the rect

        long    cBorder =   CFrameSetSite::iPixelFrameHighlightWidth  +
                            CFrameSetSite::iPixelFrameHighlightBuffer + 1;

        if (cBorder > 1)
        {
            pDoc->GetView()->InvalidateBorder(cBorder);
        }
    }
}


//+---------------------------------------------------------------
//
//  Member:     CDoc::InstallFrameUI, CServer
//
//  Synopsis:   Installs the U.I. elements on the frame window.
//              This function assumes the server has does not
//              have any UI.  Derived classes should override
//              to provide their own UI.
//
//---------------------------------------------------------------

#ifndef NO_OLEUI
HRESULT
CDoc::InstallFrameUI()
{
    HRESULT hr = S_OK;
    IOleCommandTarget * pCommandTarget = NULL;
    IOleInPlaceActiveObject * pInPlaceActiveObject = NULL;

    Assert(InPlace());
    if(_pHostUIHandler)
    {
        hr = THR(PrivateQueryInterface(IID_IOleCommandTarget, (void **) &pCommandTarget));
        if (hr)
            goto Cleanup;

        hr = THR(PrivateQueryInterface(IID_IOleInPlaceActiveObject, (void **)&pInPlaceActiveObject));
        if (hr)
            goto Cleanup;

        hr = _pHostUIHandler->ShowUI(
                DesignMode() ? DOCHOSTUITYPE_AUTHOR : DOCHOSTUITYPE_BROWSE,
                pInPlaceActiveObject,
                pCommandTarget,
                InPlace()->_pFrame,
                InPlace()->_pDoc);

        InPlace()->_fHostShowUI = hr != S_FALSE;
        if (hr == S_FALSE)
            hr = S_OK;
    }
    else
    {
        InPlace()->_fHostShowUI = FALSE;
    }

#if DBG == 1
    if (DbgExIsFullDebug())
    {
        if (!InPlace()->_fHostShowUI)
        {
            hr = THR(InstallMenuUI());
            if (hr)
                goto Cleanup;

            DeferUpdateUI();
            InvalidateBorder(this);
        }
    }
#endif // DBG == 1

Cleanup:
    ReleaseInterface(pCommandTarget);
    ReleaseInterface(pInPlaceActiveObject);
    RRETURN(hr);
}
#endif // NO_OLEUI

//+---------------------------------------------------------------
//
//  Member:     CDoc::RemoveFrameUI, CServer
//
//  Synopsis:   Removes the U.I. elements on the frame window
//
//  Notes:      This method "undoes" everything that was done in
//              InstallFrameUI -- it removes the shared menu from
//              the frame.
//
//---------------------------------------------------------------

#ifndef NO_OLEUI
void
CDoc::RemoveFrameUI()
{
    if (!InPlace()->_fHostShowUI)
    {
#if DBG == 1
        if (DbgExIsFullDebug())
        {
            super::RemoveFrameUI();

            InPlace()->_fMenusMerged = 0;

            DestroyMenuUI();    // Must clear menus cached in the doc's inplace
                                // object.
        }
#endif // DBG == 1
    }
    else
    {
        Assert(_pHostUIHandler);
        _pHostUIHandler->HideUI();
        InPlace()->_fHostShowUI = FALSE;
    }

    InvalidateBorder(this);
}
#endif // NO_OLEUI

//+-------------------------------------------------------------------
//
//  Member:     CDoc::DetachWin
//
//  Synopsis:   Our window is going down. Cleanup our UI.
//
//--------------------------------------------------------------------

void
CDoc::DetachWin()
{
    THREADSTATE *   pts;

#if DBG == 1
    if (DbgExIsFullDebug())
    {
        DestroyMenuUI();
    }
#endif // DBG == 1

#ifndef NO_IME
    // if a DIMM is installed, shut down it's ui
    DeactivateDIMM();
#endif // ndef NO_IME

    pts = GetThreadState();

    if (_pInPlace->_hwnd)
    {
        LRESULT lResult;
        
        // A bug in Win9x sometimes causes a stack overflow fault if our inplace window has
        // the focus and set attempt to hide the window (or SetParent).  By throwing the
        // focus away from our window, we work around the bug in the OS.

        if (_fInHTMLPropPage && ::GetFocus() == _pInPlace->_hwnd)
            ::SetFocus(NULL);

        ShowWindow (_pInPlace->_hwnd, SW_HIDE);
        OnWindowMessage (WM_KILLFOCUS, 0, 0, &lResult);
        if (!_fPopupDoc && SetParent (_pInPlace->_hwnd, pts->gwnd.hwndGlobalWindow))
        {
            // TODO: can killing of all timers be done better?
            KillTimer (_pInPlace->_hwnd, 1);                    // mouse move timer
            KillTimer (_pInPlace->_hwnd, TIMER_DEFERUPDATEUI);  // defer update UI timer
            _fUpdateUIPending = FALSE;                          // clear update UI pending flag
            _fNeedUpdateUI = FALSE;
            _fNeedUpdateTitle = FALSE;
            SetWindowLongPtr(_pInPlace->_hwnd, GWLP_USERDATA, 0);  // disconnect the window from this CDoc
            OnDestroy();    // this call is necessary to balance all ref-counting and init-/deinitialization;
                            // normally in CServer this happens upon WM_DESTROY message; however, as we reuse
                            // the window, we don't get WM_DESTROY in this codepath so we explicitly call OnDestroy

            PrivateRelease();
            _hwndCached = _pInPlace->_hwnd;
            _pInPlace->_hwnd = NULL;
        }
        else // SetParent failed
        {
            super::DetachWin();
        }
    }
}


HRESULT
CDoc::HostTranslateAccelerator ( LPMSG lpmsg )
{
    HRESULT     hr = S_FALSE;

    // Give host a change to handle first
    if(_pHostUIHandler)
    {
        DWORD cmdID;
        const GUID *pcmdSetGuid = &CGID_MSHTML;

        Assert(_pElemCurrent);

        if (lpmsg->message < WM_KEYFIRST || lpmsg->message > WM_KEYLAST)
        {
            cmdID = 0;
            pcmdSetGuid = NULL;
        }
        else
            cmdID = _pElemCurrent->GetCommandID(lpmsg);

        hr = THR(_pHostUIHandler->TranslateAccelerator(
                    lpmsg,
                    pcmdSetGuid,
                    cmdID));
    }
    RRETURN1(hr, S_FALSE);
}


HRESULT
CDoc::TranslateAccelerator ( LPMSG lpmsg )
{
    HRESULT hr = S_FALSE;    
    
    //  Give tooltips a chance to dismiss.
    {
        // Ignore spurious WM_ERASEBACKGROUNDs generated by tooltips
        CServer::CLock Lock(this, SERVERLOCK_IGNOREERASEBKGND);

        FormsTooltipMessage(lpmsg->message, lpmsg->wParam, lpmsg->lParam);
    }

    // No_File_Menu restriction enabled   
    if (g_fNoFileMenu)
    {             
        DWORD nCmdID;

        Assert(_pElemCurrent);
        nCmdID = _pElemCurrent->GetCommandID(lpmsg);
        if (nCmdID==IDM_OPEN || nCmdID==IDM_SAVE || nCmdID==IDM_PRINT)
        {
            hr = S_OK;
            goto Cleanup;
        }
    }

    hr = THR(HostTranslateAccelerator(lpmsg));
    if (hr == S_OK)
        goto Cleanup;

    if (lpmsg->message < WM_KEYFIRST || lpmsg->message > WM_KEYLAST)
        return S_FALSE;

    hr = THR(super::TranslateAccelerator (lpmsg));

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
// Member:   CWindow::SetDataObjectSecurity
//
// Synopsis: Set Security Domain
//
//----------------------------------------------------------------------------
HRESULT
CWindow::SetDataObjectSecurity(IDataObject * pDataObj)
{
    HRESULT      hr;
    CVariant     var(VT_BSTR);
    BYTE         abSID[MAX_SIZE_SECURITY_ID];
    DWORD        cbSID = ARRAY_SIZE(abSID);

    memset(abSID, 0, cbSID);
    hr = THR(Markup()->GetSecurityID(abSID, &cbSID));
    if (hr)
        goto Cleanup;

    hr = FormsAllocStringLen(NULL, MAX_SIZE_SECURITY_ID, &V_BSTR(&var));
    if (hr)
        goto Cleanup;

    memcpy(V_BSTR(&var), abSID, MAX_SIZE_SECURITY_ID);
    IGNORE_HR(CTExec(
            pDataObj,
            &CGID_DATAOBJECTEXEC,
            IDM_SETSECURITYDOMAIN,
            0,
            &var,
            NULL));

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// Member:   CWindow::CheckDataObjectSecurity
//
// Synopsis: Check Security Domain
//
//----------------------------------------------------------------------------
HRESULT
CWindow::CheckDataObjectSecurity(IDataObject * pDataObj)
{
    HRESULT     hr;
    CVariant    var(VT_BSTR);
    BYTE        abSID[MAX_SIZE_SECURITY_ID];
    DWORD       cbSID = ARRAY_SIZE(abSID);

    memset(abSID, 0, cbSID);

    hr = THR(Markup()->GetSecurityID(abSID, &cbSID));
    if (hr)
        goto Cleanup;

    hr = FormsAllocStringLen(NULL, MAX_SIZE_SECURITY_ID, &V_BSTR(&var));
    if (hr)
        goto Cleanup;

    memcpy(V_BSTR(&var), abSID, MAX_SIZE_SECURITY_ID);
    hr = THR_NOTRACE(CTExec(
            pDataObj,
            &CGID_DATAOBJECTEXEC,
            IDM_CHECKSECURITYDOMAIN,
            0,
            &var,
            NULL));

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// Member:   CWindow::SetClipboard
//
// Synopsis: Set Security Domain before actual FormSetClipboard
//
//----------------------------------------------------------------------------
HRESULT
CWindow::SetClipboard(IDataObject * pDO)
{
    IGNORE_HR(SetDataObjectSecurity(pDO));

    RRETURN(FormSetClipboard(pDO));
}

//+---------------------------------------------------------------------------
//
// Member:   CDoc::AllowPaste
//
// Synopsis: Check if Paste is allowed to be executed.
//           Trident allows Paste execution if Paste is from
//           1) UI (menu command, toolbar, ...)
//           2) Script, after user confirms
//
//-----------------------------------------------------------------------------
HRESULT
CMarkup::AllowPaste(IDataObject * pDO)
{
    HRESULT hr = S_OK;

    CWindow * pWindow;

    Assert(GetWindowedMarkupContext()->GetWindowPending());

    pWindow = GetWindowedMarkupContext()->GetWindowPending()->Window();

    if (pWindow->IsInScript())
    {
        hr = pWindow->CheckDataObjectSecurity(pDO);

        if (hr)
            goto Cleanup;
#if 0
        int fYesNo;

        hr = Doc()->ShowMessageEx(
                        &fYesNo,
                        MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2,
                        NULL,
                        0,
                        _T("Scripting code is trying to PASTE data from clipboard to one of the controls, the data is from the same security domain (that is, from the same server).\n\n Do you allow this to happen?"));
        hr = (fYesNo == IDYES) ? (S_OK) : (OLECMDERR_E_DISABLED);
#endif
    }

Cleanup:
    if (hr)
    {
        // cannot programatic paste accross application or security
        // domain.
        //
        hr = OLECMDERR_E_DISABLED;
    }
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
// Member: CheckDoc3DBorder
//
// Synopsis: Based on which 3D border edges are needed for this CDoc,
//           determine which extra 3D border edges are needed for pDoc, which
//           should be a child CDoc for this CDoc.
//           the function is called in CBodyElement::GetBorderInfo() as
//               Doc()->_pDocParent->CheckDoc3DBorder(Doc());
//----------------------------------------------------------------------------
void
CWindow::CheckDoc3DBorder(CWindow * pWindow)
{
    CElement * pElement = CMarkup::GetElementClientHelper(_pMarkup);
    Assert(pWindow->_pWindowParent == this);

    if (!pElement)
        return;
    
    if (pElement->Tag() == ETAG_BODY)
    {
        // If _pElemClient is a CBodyElement, pDoc is a CDoc defined inside
        // one <iframe> tag, need all 3D borders.
        //
        pWindow->_b3DBorder = NEED3DBORDER_TOP | NEED3DBORDER_LEFT
                         | NEED3DBORDER_BOTTOM | NEED3DBORDER_RIGHT;
    }
    else
    {
        // Since the request is from inner CDoc, _pElemClient must be frameset.
        //
        Assert(pElement->Tag() == ETAG_FRAMESET);
        CFrameSetSite * pFrameSet =
            DYNCAST( CFrameSetSite, pElement );

        // determine which 3D border edges are needed for this CDoc.
        // If this is the root CDoc (_pDocParent == NULL), we begin with that
        // we do not need to draw any 3D border edges for potential
        // CBodyElement in pDoc, since _pElemClient (top level CFrameSetSite)
        // will draw the 3D border for us.
        // Otherwise, let _pDocParent decide which 3D border edges this CDoc
        // need to draw (assume that there is a CBodyElement inside this).
        //
        if (_pWindowParent)
        {
            _pWindowParent->CheckDoc3DBorder(this);
        }
        else
        {
            // This must be the top-level frameset case, assume no 3D border at
            // first since top-level frameset (_pElemClient) already draw the
            // outmost 3D borders.
            //
            _b3DBorder = NEED3DBORDER_NO;
        }

        // calculate which extra 3D border edges are needed for pDoc
        //
        if (_b3DBorder == (NEED3DBORDER_TOP | NEED3DBORDER_LEFT
                                | NEED3DBORDER_BOTTOM | NEED3DBORDER_RIGHT))
        {
            // If this CWindow already needs all 3D border edges, child CWindow
            // should need also.
            //
            pWindow->_b3DBorder = NEED3DBORDER_TOP | NEED3DBORDER_LEFT
                             | NEED3DBORDER_BOTTOM | NEED3DBORDER_RIGHT;
        }
        else
        {
            // let CFrameSetSite decides whether more 3D border edges are
            // needed.
            //
            // Recall that framesets are never contained within more than
            // one context, so passing GUL_USEFIRSTLAYOUT is always the right
            // thing to do.
            AssertSz( pFrameSet->CurrentlyHasAnyLayout(), "Frameset should have layout by now -- don't want the following call to force creation" );
            pFrameSet->Layout( GUL_USEFIRSTLAYOUT )->CheckFrame3DBorder(pWindow, _b3DBorder);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\sholder.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       sholder.cxx
//
//  Contents:   Implementation of CScriptHolder class
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_SHOLDER_HXX_
#define X_SHOLDER_HXX_
#include "sholder.hxx"
#endif

#ifndef X_DEBUGGER_HXX_
#define X_DEBUGGER_HXX_
#include "debugger.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef X_CLIENT_HXX_
#define X_CLIENT_HXX_
#include "client.hxx"
#endif

const CLSID CLSID_JScript  = {0xF414C260, 0x6AC0, 0x11CF, 0xB6, 0xD1, 0x00, 0xAA, 0x00, 0xBB, 0xBB, 0x58};

EXTERN_C const IID IID_IHTMLDialog;

BOOL IsSpecialUrl(LPCTSTR pszURL);

#ifndef NO_SCRIPT_DEBUGGER
extern interface IProcessDebugManager * g_pPDM;
extern interface IDebugApplication *g_pDebugApp;
#endif // ndef NO_SCRIPT_DEBUGGER

MtDefine(CScriptHolder, ObjectModel, "CScriptHolder")
MtDefine(CScriptHolder_pclsid, CScriptHolder, "CScriptHolder::_pclsid")
DeclareTag(tagScriptSite, "Script Holder", "Script Holder methods")
ExternTag(tagDisableLockAR);
ExternTag(tagSecureScriptWindow);


CScriptHolder::CLock::CLock(CScriptHolder *pHolder, WORD wLockFlags)
{
    _pHolder = pHolder;
    _wLock = pHolder->_wLockFlags;
#if DBG==1
    if (!IsTagEnabled(tagDisableLockAR))
#endif
    {
        _pHolder->AddRef();
    }
    
    pHolder->_wLockFlags |= wLockFlags;
}


CScriptHolder::CLock::~CLock()
{
    _pHolder->_wLockFlags = _wLock;
#if DBG==1
    if (!IsTagEnabled(tagDisableLockAR))
#endif
    {
        _pHolder->Release();
    }
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::CScriptHolder
//
//  Synopsis:   ctor
//
//---------------------------------------------------------------------------

CScriptHolder::CScriptHolder(CScriptCollection *pCollection)
{
    _ulRefs = 1;
    _pCollection = pCollection;
    _pScript = NULL;
    _pScriptParse = NULL;
    _pParseProcedure = NULL;
    _pclsid = NULL;
    _pUnkItem = NULL;
    _fCaseSensitive = FALSE;
    _fErrorHandlerSet = FALSE;
    _fOriginal = FALSE;
    _fClone = FALSE;
    _wLockFlags = 0;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::~CScriptHolder
//
//  Synopsis:   dtor
//
//---------------------------------------------------------------------------

CScriptHolder::~CScriptHolder()
{
    IGNORE_HR(Close());
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::Close
//
//  Synopsis:   Close the script and clear interfaces to it.
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::Close()
{
    TraceTag((tagScriptSite, "Close"));

    HRESULT hr = S_OK;

    ClearInterface(&_pParseProcedure);
    ClearInterface(&_pScriptParse);
    ClearInterface(&_pUnkItem);
    
    delete _pclsid;
    _pclsid = NULL;

    if (_pScript)
    {
        hr = THR(_pScript->Close());
    }

    ClearInterface(&_pScript);
    _pCollection = NULL;
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::IllegalCall
//
//  Synopsis:   Return TRUE/FALSE if this method call is legal.
//
//---------------------------------------------------------------------------

BOOL
CScriptHolder::IllegalCall()
{
    if (!_pCollection || !_pCollection->Doc())
        return TRUE;
        
    if (_pCollection->Doc()->_dwTID != GetCurrentThreadId())
    {
        Assert(0 && "Script site called across apartment thread boundary (not an MSHTML bug)");
        return TRUE;
    }

    return FALSE;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::QueryInterface
//
//  Synopsis:   per IUnknown
//
//---------------------------------------------------------------------------

STDMETHODIMP
CScriptHolder::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (IllegalCall())
        RRETURN(E_NOINTERFACE);
        
    if (iid == IID_IActiveScriptSite ||
        iid == IID_IUnknown)
    {
        *ppv = (IActiveScriptSite *) this;
    }
    else if (iid == IID_IActiveScriptSiteWindow)
    {
        *ppv = (IActiveScriptSiteWindow *) this;
    }
    else if (iid == IID_IServiceProvider)
    {
        *ppv = (IServiceProvider *)this;
    }
#ifndef NO_SCRIPT_DEBUGGER
    else if (iid == IID_IActiveScriptSiteDebug)
    {
        *ppv = (IActiveScriptSiteDebug *)this;
    }
#endif
    else if (iid == IID_IOleCommandTarget)
    {
        *ppv = (IOleCommandTarget *)this;
    }
    else if (iid == IID_IActiveScriptSiteInterruptPoll)
    {
        *ppv = (IActiveScriptSiteInterruptPoll *)this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::AddRef
//
//  Synopsis:   per IUnknown
//
//---------------------------------------------------------------------------

ULONG
CScriptHolder::AddRef()
{
    _ulRefs += 1;
    return _ulRefs;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::Release
//
//  Synopsis:   per IUnknown
//
//---------------------------------------------------------------------------

ULONG
CScriptHolder::Release()
{
    if (--_ulRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        delete this;
        return 0;
    }

    return _ulRefs;
}

// TODO: ***TLL*** #define needs to go when new script engine and activscp.idl.
#define SCRIPTPROP_CONVERSIONLCID        0x00001002

void CScriptHolder::TurnOnFastSinking ()
{
    IActiveScriptProperty *pprop;

    Assert(_pScript);

    if (SUCCEEDED(_pScript->QueryInterface(IID_IActiveScriptProperty, (void **)&pprop)))
    {
        CVariant varValue(VT_BOOL);

        V_BOOL(&varValue) = VARIANT_TRUE;

        pprop->SetProperty(SCRIPTPROP_HACK_TRIDENTEVENTSINK, NULL, &varValue);

        pprop->Release();
    }
}


void CScriptHolder::SetConvertionLocaleToENU()
{
    IActiveScriptProperty *pprop;

    Assert(_pScript);

    if (SUCCEEDED(_pScript->QueryInterface(IID_IActiveScriptProperty, (void **)&pprop)))
    {
        CVariant varLocale(VT_I4);

        V_I4(&varLocale) = 0x409;       // English ENU

        // Turn on ENU for script locale.
        pprop->SetProperty(SCRIPTPROP_CONVERSIONLCID, NULL, &varLocale);

        pprop->Release();
    }
}

HRESULT
CScriptHolder::Clone(CLSID *pclsid, CScriptHolder *pHolderTarget)
{
    HRESULT hr;
    Assert(pHolderTarget && _pScript && _pScriptParse && _fOriginal);
    Assert(!pHolderTarget->_pScript && !pHolderTarget->_pScriptParse && !pHolderTarget->_pParseProcedure);
    Assert(!pHolderTarget->_fOriginal && !pHolderTarget->_fClone);

    hr = THR(_pScript->Clone(&pHolderTarget->_pScript));
    if (hr)
        goto Cleanup;

    hr = THR(pHolderTarget->_pScript->QueryInterface(IID_IActiveScriptParse, (void **)&pHolderTarget->_pScriptParse));
    if (hr)
        goto Cleanup;

    Assert(_pCollection);
    // (sramani) Need to explicity call SE to fill security info as it is not automatically cloned. This is
    // a workaround (albeit costly) until the SE is fixed.
    if (!_pCollection->IsSafeToRunScripts(pclsid, pHolderTarget->_pScript, FALSE))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // If cloned script engine supports fast sinking (uses ITridentEventSink) then tell
    // the cloned script engine we support it.
    pHolderTarget->TurnOnFastSinking();

    // if the QI fails that means that the script engine does not support the new IASPP code construction
    if (THR_NOTRACE(pHolderTarget->_pScript->QueryInterface(IID_IActiveScriptParseProcedure2, (void**)&pHolderTarget->_pParseProcedure)))
    {
        // Try the old IASPP IID for old engines that haven't been re-compiled.
        hr = THR(pHolderTarget->_pScript->QueryInterface(IID_IActiveScriptParseProcedure, (void**)&pHolderTarget->_pParseProcedure));
        if (hr)
            goto Cleanup;
    }

    pHolderTarget->_fCaseSensitive = _fCaseSensitive;
    pHolderTarget->_fClone = TRUE;

    hr = THR(pHolderTarget->_pScript->SetScriptSite(pHolderTarget));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::Init
//
//  Synopsis:   Second phase of construction.
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::Init(
        BOOL fCaseSensitive,
        IActiveScript *pScript,
        IActiveScriptParse *pScriptParse,
        CLSID *pclsid,
        LPTSTR pchNameSpace)
{
    TraceTag((tagScriptSite, "Init"));

    HRESULT                         hr;
    long                            c;
    CNamedItem **                   ppNamedItem;
    SCRIPTSTATE                     ss = SCRIPTSTATE_STARTED;

    ReplaceInterface(&_pScript, pScript);
    ReplaceInterface(&_pScriptParse, pScriptParse);

    if (pclsid)
    {
        _pclsid = new(Mt(CScriptHolder_pclsid)) CLSID;
        *_pclsid = *pclsid;
    }

    // NOTE (alexz) - we need some generic protocol allowing us to ask script engine
    // about it's case-sensitivity.
    _fCaseSensitive = fCaseSensitive;

    // If script engine supports fast sinking (uses ITridentEventSink) then tell
    // the script engine we support it.
    TurnOnFastSinking();

    if (_pScriptParse)
    {
        hr = THR(_pScriptParse->InitNew());
        if (hr)
            goto Cleanup;
    }
    
    hr = THR(_pScript->SetScriptSite(this));
    if (hr)
        goto Cleanup;

    // Need to set conversion locale after call to SetScriptSite, as LCID is over-written
    // in a callback to GetLCID. (IE5 Bug# 83217)
    // 
    // Removing call to SetConvertionLocaleToENU()  (IE5 Bug 86509)
    //
    // SetConvertionLocaleToENU();

    // we check the state of the scriptengine first, there are objects out there
    // who connect during their download time (HTMLLAYOUT)
    hr = THR(_pScript->GetScriptState(&ss));
    if (hr)
    {
        if (E_NOTIMPL != hr)
            goto Cleanup;

        ss = SCRIPTSTATE_UNINITIALIZED;
        hr = S_OK;
    }

    if (ss == SCRIPTSTATE_INITIALIZED || ss == SCRIPTSTATE_UNINITIALIZED)
    {
        // This is a requirement for gets VBScript/JScript into a runnable state.

#ifdef NEVER
        //
        // Not used anymore because we won't treat solstice as a 
        // script engine due to security problems.
        //
        
        // BAD BETA 1 Bugfix for 24019
        // GaryBu and frankman decided to use the same for BETA2 due to simplicity reasons
        // we should change this to compat flags in case we have to do anything else
        // for the layoutcontrol
        if (!IsEqualCLSID(*pclsid, CLSID_IISForm))
#endif
        {
            // we ignore the error because some script engines might not support this operation
            // (e.g. java vm 2057.1+), yet we still want to finish creating script holder for them
            IGNORE_HR(_pScript->SetScriptState(SCRIPTSTATE_STARTED));
        }
    }

    //
    // Add the window as a global named item.
    //
    
    hr = THR(_pScript->AddNamedItem(
        DEFAULT_OM_SCOPE,
        SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE | SCRIPTITEM_GLOBALMEMBERS | (_fOriginal ? SCRIPTITEM_ISPERSISTENT : 0)));
    if (S_OK == hr)
    {
        //
        // So the script engine supports operation AddNamedItem.
        //
        // Now add any existing forms also as named items.
        //

        if (!pchNameSpace)
        {
            for (c = _pCollection->_NamedItemsTable.Size(), 
                    ppNamedItem = _pCollection->_NamedItemsTable;
                 c > 0; 
                 c--, ppNamedItem++)
            {
                // Fixing bug 37010
                // fScriptItemVisible is FALSE only for "MCSE Readiness Review Exam xx-xxx" hta applications
                BOOL fScriptItemVisible = TRUE;
                if (_pCollection->Doc()->_fHostedInHTA && (*ppNamedItem)->_pUnkItem)
                {
                    CElement* pElem = NULL;
                    HRESULT hr2 = THR((*ppNamedItem)->_pUnkItem->QueryInterface(CLSID_CElement, (void**)&pElem));
                    if (hr2 == S_OK && pElem && pElem->Tag() == ETAG_FORM)
                    {
                        if (_pCollection->Doc()->_pClientSite)
                        {
                            char szModule[MAX_PATH];
                            GetModuleFileNameA(NULL, szModule, MAX_PATH);
                            if (StrStrIA(szModule, "mshta.exe"))
                            {
                                CClient* pClient = (CClient*)(_pCollection->Doc()->_pClientSite);
                                LPCTSTR pchAppName = pClient->GetAppName();
                                if (pchAppName && !StrCmpN(pchAppName, _T("MCSE"), 4))
                                    fScriptItemVisible = FALSE;
                            }
                        }
                    }
                }
                    
                hr = THR(_pScript->AddNamedItem(
                        (*ppNamedItem)->_cstrName,
                        SCRIPTITEM_ISSOURCE | (fScriptItemVisible ? SCRIPTITEM_ISVISIBLE : 0)));
                if (hr)
                    goto Cleanup;
            }
        }
        else
        {
            Assert(_fOriginal);
            hr = THR(_pScript->AddNamedItem(pchNameSpace, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE | SCRIPTITEM_ISPERSISTENT));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        Assert (hr);
        if (E_NOTIMPL == hr)
        {
            // we ignore the error because some script engines might not support this operation
            // (e.g. java vm 2057.1+), yet we still want to finish creating script holder for them
            hr = S_OK;
        }
        else
            goto Cleanup;
    }


    //
    // cache _pParseProcedure
    //

    Assert (!_pParseProcedure);

    // if the QI fails that means that the script engine does not support the new IASPP code construction
    if (THR_NOTRACE(_pScript->QueryInterface(
        IID_IActiveScriptParseProcedure2, 
        (void**)&_pParseProcedure)))
    {
        // Try the old IASPP IID for old engines that haven't been re-compiled.
        THR_NOTRACE(_pScript->QueryInterface(
            IID_IActiveScriptParseProcedure, 
            (void**)&_pParseProcedure));
    }

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::SetScriptState
//
//  Synopsis:   Set the script to some state using enum SCRIPTSTATE
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::SetScriptState(SCRIPTSTATE ss)
{
    TraceTag((tagScriptSite, "SetScriptState"));

    HRESULT hr = S_OK;
    
    if (!_pScript)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    hr = THR(_pScript->SetScriptState(ss));
    if (E_NOTIMPL == hr)
    {
        hr = S_OK;
    }

    // script engines which do not support IActiveScriptParseProcedure (as indicated by
    // condition (!_pParseProcedure)) might rely on actions (AddScriptlet calls) done in 
    // BuildObjectTypeInfo, so for them we ensure ObjectTypeInfo
    if (!_pParseProcedure && SCRIPTSTATE_CONNECTED == ss)
    {
        hr = THR(_pCollection->Doc()->EnsureObjectTypeInfo());
    }

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::GetLCID
//
//  Synopsis:   per IActiveScriptSite
//
//  Arguments:  plcid       Returned locale info
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::GetLCID(LCID *plcid)
{
    TraceTag((tagScriptSite, "GetLCID"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    // Return the user locale ID, this make VBS locale sensitive and means
    // that VBS pages can not be written to be locale neutral (a page cannot
    // be written to run on different locales).  Only JScript can do this. 
    // However, VBS can be written for Intra-net style apps where functions
    // like string comparisons, UCase, LCase, etc. are used.  Also, some
    // pages could be written in both VBS and JS.  Where JS has the locale 
    // neutral things like floating point numbers, etc.
    *plcid = g_lcidLocalUserDefault;

    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::GetItemInfo
//
//  Synopsis:   per IActiveScriptSite
//
//  Arguments:  pstrName        Name to get info of
//              dwReturnMask    Mask for which item are needed
//              ppunkItemOut    IUnknown for item returned
//              pptinfoOut      ITypeInfo for item returned
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::GetItemInfo(
      LPCOLESTR   pchName,
      DWORD       dwReturnMask,
      IUnknown**  ppunkItemOut,
      ITypeInfo** pptinfoOut)
{
    TraceTag((tagScriptSite, "GetItemInfo"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    HRESULT         hr = S_OK;
    IUnknown *      pUnkItem = NULL;
    IDispatch *     pDispItem = NULL;

    //
    // validation
    //

    if (!_pCollection)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
    {
        if (!pptinfoOut)
        {
            hr = E_POINTER;
            goto Cleanup;
        }
        *pptinfoOut = NULL;
    }

    if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
    {
        if (!ppunkItemOut)
        {
            hr = E_POINTER;
            goto Cleanup;
        }
        *ppunkItemOut = NULL;
    }


    //
    // find the item
    //

    if (StrCmpIC(DEFAULT_OM_SCOPE, pchName) == 0)
    {
        //
        // If we have a pending markup and we will need to change the security thunk later for that
        // markup during the SwitchMarkup, create and hold on to the new thunk here. 
        //
        CWindow * pWindow  = _pCollection->_pOmWindowProxy->Window();

        if (pWindow->_pMarkupPending && 
            !pWindow->_pMarkupPending->AccessAllowed(pWindow->Markup()))
        {

            hr = _pCollection->_pOmWindowProxy->GetSecurityThunk((LPVOID *)&pDispItem, TRUE);
            if (hr)
                goto Cleanup;

            // complete the QI call functionality by addrefing the pointer.
            pDispItem->AddRef();
        }
        else
        {
            // just use the existing window proxy's IDispatch tearoff thunk.
            hr = THR(_pCollection->_pOmWindowProxy->QueryInterface(IID_IDispatch, (void **) &pDispItem));
            if (hr)
                goto Cleanup;
        }

#if DBG==1
    if (IsTagEnabled(tagSecureScriptWindow) && _pCollection->_pOmWindowProxy->_fTrusted)
    {
        // use secure proxy instead
        pDispItem->Release();
        hr = THR(_pCollection->_pSecureWindowProxy->QueryInterface(IID_IDispatch, (void **) &pDispItem));
        if (hr)
            goto Cleanup;
    }
#endif

        pUnkItem = pDispItem;
        pUnkItem->AddRef();
    }
    else if (_fClone || _fOriginal)
    {
        Assert(_pUnkItem);
        pUnkItem = _pUnkItem;
        pUnkItem->AddRef();

        if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
        {
            hr = THR(pUnkItem->QueryInterface(IID_IDispatch, (void**)&pDispItem));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        Assert(!_pUnkItem);
        hr = THR(_pCollection->_NamedItemsTable.GetItem((LPTSTR)pchName, &pUnkItem));
        if (hr)
            goto Cleanup;

        if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
        {
            hr = THR(pUnkItem->QueryInterface(IID_IDispatch, (void**)&pDispItem));
            if (hr)
                goto Cleanup;
        }
    }

    //
    // get the info
    //

    if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
    {
        *ppunkItemOut = pUnkItem;
        (*ppunkItemOut)->AddRef();
    }

    if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
    {
        hr = THR(pDispItem->GetTypeInfo(
            0,
            LOCALE_SYSTEM_DEFAULT,
            pptinfoOut));
        if (hr)
            goto Cleanup;
    }
    
Cleanup:
    ReleaseInterface(pUnkItem);
    ReleaseInterface(pDispItem);
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::GetDocVersionString
//
//  Synopsis:   per IActiveScriptSite
//
//  Arguments:  pbstrVersion    Returned version string
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::GetDocVersionString(BSTR *pbstrVersion)
{
    TraceTag((tagScriptSite, "GetDocVersionString"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    // TODO need to return empty stirng?
    return E_NOTIMPL;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::RequestItems
//
//  Synopsis:   per IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::RequestItems()
{
    TraceTag((tagScriptSite, "RequestItems"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    if (!_pCollection)
        RRETURN(E_UNEXPECTED);

    // TODO add named items
    return E_NOTIMPL;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::RequestTypeLibs
//
//  Synopsis:   per IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::RequestTypeLibs()
{
    TraceTag((tagScriptSite, "RequestTypeLibs"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    if (!_pCollection)
        RRETURN(E_UNEXPECTED);

    // TODO add type library
    return E_NOTIMPL;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::OnScriptTerminate
//
//  Synopsis:   per IActiveScriptSite
//
//  Arguments:  pvarResult      Resultant variant
//              pexcepinfo      Exception info for errors
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::OnScriptTerminate(
    const VARIANT *pvarResult,
    const EXCEPINFO *pexcepinfo)
{
    TraceTag((tagScriptSite, "OnScriptTerminate"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    if (!_pCollection)
        RRETURN(E_UNEXPECTED);

    // TODO what should we do?
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::OnStateChange
//
//  Synopsis:   per IActiveScriptSite
//
//  Arguments:  ssScriptState   New state of script
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::OnStateChange(SCRIPTSTATE ssScriptState)
{
    TraceTag((tagScriptSite, "OnStateChange"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    if (!_pCollection)
        RRETURN(E_UNEXPECTED);

    // TODO what should we do?
    return S_OK;
}

BOOL OutLook98HackReqd(CMarkup * pMarkup, ULONG uLine, ULONG uCol)
{
    if (((36 == uLine) && (35 == uCol) || 
         (51 == uLine) && (28 == uCol)) && 
        !_tcsicmp( (TCHAR *)CMarkup::GetUrl(pMarkup), _T("outday://")))
        return TRUE;

    return FALSE;
}

//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::OnScriptError
//
//  Synopsis:   per IActiveScriptSite
//
//  Arguments:  pScriptError    Error info interface
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::OnScriptError(IActiveScriptError *pScriptError)
{
    TraceTag((tagScriptSite, "OnScriptError"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    HRESULT          hr = S_OK;
    ErrorRecord      errRecord;

    if (!_pCollection || (g_pHtmPerfCtl && (g_pHtmPerfCtl->dwFlags & HTMPF_DISABLE_ALERTS)))
        RRETURN(E_UNEXPECTED);

    if (TestLock(SCRIPTLOCK_SCRIPTERROR))
        goto Cleanup;

    {
        CLock   Lock(this, SCRIPTLOCK_SCRIPTERROR);

        COmWindowProxy *    pWndProxy = _pCollection->_pOmWindowProxy;
        CMarkup *           pMarkup = pWndProxy->Markup();

        Assert(!!CMarkup::GetUrl(pMarkup));

        hr = errRecord.Init(pScriptError, pWndProxy);
        if (hr)
            goto Cleanup;

        // HACK fix for IE5 bug# 58568
        if (OutLook98HackReqd(pMarkup, errRecord._uLine, errRecord._uColumn))
            goto Cleanup;

#ifndef NO_SCRIPT_DEBUGGER
        if (!_fErrorHandlerSet && errRecord._pScriptDebugDocument)
        {
            BOOL        fEnterDebugger;

            hr = THR(DoYouWishToDebug(pScriptError, &fEnterDebugger));
            if (hr)
                goto Cleanup;

            if (fEnterDebugger)
            {
                hr = THR(errRecord._pScriptDebugDocument->ViewSourceInDebugger(
                    errRecord._uLine - 1, errRecord._uColumn));
            }

            goto Cleanup; // done
        }
#endif // NO_SCRIPT_DEBUGGER

        if (!TestLock(SCRIPTLOCK_FIREONERROR))
        {
            CLock   Lock(this, SCRIPTLOCK_FIREONERROR);

            hr = pMarkup->ReportScriptError(errRecord);
        }
    }
    
Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::OnEnterScript
//
//  Synopsis:   per IActiveScriptSite
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::OnEnterScript()
{
    HRESULT hr;

    TraceTag((tagScriptSite, "OnEnterScript"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    if (!_pCollection)
        RRETURN(E_UNEXPECTED);

#ifndef NO_SCRIPT_DEBUGGER
    if (_pCollection->_pCurrentDebugDocument)
    {
        IGNORE_HR(_pCollection->_pCurrentDebugDocument->UpdateDocumentSize());
    }
#endif

    Assert(_pCollection->_pOmWindowProxy);
    Assert(_pCollection->_pOmWindowProxy->Window());
    hr = THR(_pCollection->_pOmWindowProxy->Window()->EnterScript());

    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::OnLeaveScript
//
//  Synopsis:   per IActiveScriptSite
//
//  Arguments:  plcid       Returned locale info
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::OnLeaveScript()
{
    TraceTag((tagScriptSite, "OnLeaveScript"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    if (!_pCollection)
        RRETURN(E_UNEXPECTED);

    Assert(_pCollection->_pOmWindowProxy);
    Assert(_pCollection->_pOmWindowProxy->Window());
    _pCollection->_pOmWindowProxy->Window()->LeaveScript();

    return(S_OK);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::DoYouWishToDebug
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::DoYouWishToDebug(IActiveScriptError * pScriptError, BOOL * pfEnterDebugger)
{
    int                   iRes = IDYES;
    CDoc                 *pDoc;
    HRESULT               hr = S_OK;
    BOOL                  fExcepInfo = TRUE;
    CExcepInfo            ExcepInfo;
    ULONG                 ulLine = 0;
    LONG                  ichError;
    DWORD                 dwSrcContext;
    TCHAR                *pchDescription = NULL;
    TCHAR                 achError[256];
    TCHAR                 achDescription[512];
    AAINDEX               aaidx;
    CWindow              *pWindow;

    *pfEnterDebugger = FALSE; 

    pDoc = _pCollection->Doc();
    Assert(pDoc);

    Assert(_pCollection->_pOmWindowProxy);
    pWindow = _pCollection->_pOmWindowProxy->Window();
    Assert(pWindow);

    // Stack overflow
    if (pWindow->_fStackOverflow || pWindow->_fOutOfMemory)
    {
        // If we are in last script, stack has been unwound, so prevent 2nd dialog in OnLeaveScript
        if (pWindow->_cScriptNesting == 1)
        {
            pWindow->_fStackOverflow = FALSE;
            pWindow->_fOutOfMemory = FALSE;
        }

        goto Cleanup;
    }

    aaidx = _pCollection->_pOmWindowProxy->FindAAIndex(DISPID_EVPROP_ONERROR, CAttrValue::AA_Internal);

    // Do not dispay error dialog if error handler is hooked up.
    if (aaidx == AA_IDX_UNKNOWN)
    {
        _fErrorHandlerSet = FALSE;

        // Get the ExcepInfo
        if (!(pDoc->_dwLoadf & DLCTL_SILENT))
        {
            // TODO (alexz) this should use ErrorRecord - otherwise this is largely duplicated code

            hr = THR(pScriptError->GetExceptionInfo(&ExcepInfo));
            if (!hr)
            {
                // If the script was aborted (through the script debugger),
                // don't put up any UI.
                if (ExcepInfo.scode == E_ABORT)
                    goto Cleanup;

                pScriptError->GetSourcePosition(&dwSrcContext, &ulLine, &ichError);

                // HACK fix for IE5 bug# 58568
                if (OutLook98HackReqd(_pCollection->_pOmWindowProxy->Markup(), ulLine, ichError))
                    goto Cleanup;

                // vbscript passes empty strings and jscript passes NULL, so check for both
                if (ExcepInfo.bstrDescription && *ExcepInfo.bstrDescription)
                {
                    pchDescription = ExcepInfo.bstrDescription;
                }
                else
                {
                    GetErrorText(ExcepInfo.scode, achError, ARRAY_SIZE(achError));
                    pchDescription = achError;
                }
            }
            else
            {
                fExcepInfo = FALSE;
            }

            if (!hr)
            {
                // Note that ulLine MUST have been set if HR == S_OK (0).
                hr = Format(0, achDescription, ARRAY_SIZE(achDescription), MAKEINTRESOURCE(IDS_FMTDEBUGCONTINUE),
                            GetResourceHInst(), MAKEINTRESOURCE(IDS_DEBUGCONTINUE), ulLine, pchDescription);
            }
            else
            {
                hr = Format(0, achDescription, ARRAY_SIZE(achDescription), _T("<0i>"),
                            GetResourceHInst(), MAKEINTRESOURCE(IDS_DEBUGCONTINUE));
            }

            // Display "Do you wish to debug?" dialog
            if (!hr && !pDoc->_fPopupDoc)
            {
                CDoEnableModeless   dem(pDoc, pWindow);
                iRes = ::MessageBox(
                    dem._hwnd, achDescription, NULL, MB_YESNO | MB_ICONERROR);
            }

            iRes = pDoc->_fPopupDoc ? IDNO : iRes;
        }

        // If out of memory, iRes == 0, enter debugger
        if (iRes == IDYES || iRes == 0)
        { 
            hr = S_OK;
            *pfEnterDebugger = TRUE; 
            goto Cleanup;
        }
    }
    else
        _fErrorHandlerSet = TRUE;

    // Unwind the stack on stack overflow, if user decided to continue
    // Also unwind while calls are nested on the stack and if no excepinfo is available or if
    // the error is VBSERR_OutOfMemory. (It is possible to get out of memory before out of stack!
    if (!fExcepInfo || ExcepInfo.scode == VBSERR_OutOfStack)
    {
        if (pWindow->_cScriptNesting > 1)
            pWindow->_fStackOverflow = TRUE;
    }
    else if (ExcepInfo.scode == VBSERR_OutOfMemory)
    {
        if (pWindow->_cScriptNesting > 1)
            pWindow->_fOutOfMemory = TRUE;
    }

Cleanup:
    RRETURN (hr);
}

//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::OnScriptErrorDebug
//
//  Synopsis:   per IActiveScriptSite
//
//  Arguments:  pErrorDebug:       Error info
//              pfEnterDebugger:   Whether to pass the error to the debugger
//                                 to do JIT debugging
//              pfCallOnScriptErrorWhenContinuing:
//                                 Whether to call IActiveScriptSite::OnScriptError()
//                                 when the user decides to continue by returning
//                                 the error
//                                       
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::OnScriptErrorDebug(IActiveScriptErrorDebug* pErrorDebug, BOOL *pfEnterDebugger,
                                  BOOL *pfCallOnScriptErrorWhenContinuing)
{
    TraceTag((tagScriptSite, "OnScriptErrorDebug"));

    HRESULT                 hr;
    IActiveScriptError *    pScriptError = NULL;

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);

    hr = THR(pErrorDebug->QueryInterface(IID_IActiveScriptError, (void**)&pScriptError));
    if (hr)
        goto Cleanup;

    hr = THR(DoYouWishToDebug(pScriptError, pfEnterDebugger));

Cleanup:
    if (pfCallOnScriptErrorWhenContinuing)
    {
        *pfCallOnScriptErrorWhenContinuing = _fErrorHandlerSet; 
    }

    ReleaseInterface(pScriptError);

    RRETURN (hr);
}



//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::GetWindow
//
//  Synopsis:   per IActiveScriptWindow
//
//  Arguments:  phwnd       Resultant hwnd
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::GetWindow(HWND *phwnd)
{
    TraceTag((tagScriptSite, "GetWindow"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    if (!_pCollection)
        RRETURN(E_UNEXPECTED);

    *phwnd = _pCollection->Doc()->_state >= OS_INPLACE ?
            _pCollection->Doc()->_pInPlace->_hwnd :
            NULL;

    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::EnableModeless
//
//  Synopsis:   per IActiveScriptWindow
//
//  Arguments:  fEnable         TRUE to enable, FALSE to disable
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::EnableModeless(BOOL fEnable)
{
    TraceTag((tagScriptSite, "EnableModeless"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    if (!_pCollection || (g_pHtmPerfCtl && (g_pHtmPerfCtl->dwFlags & HTMPF_DISABLE_ALERTS)))
        RRETURN(E_UNEXPECTED);

    CDoEnableModeless   dem(_pCollection->Doc(), _pCollection->_pOmWindowProxy->Window(), FALSE);

    if (fEnable)
    {
        dem.EnableModeless(TRUE);
    }
    else
    {
        dem.DisableModeless();

        // Return an explicit failure here if we couldn't do it.
        // This is needed to ensure that the count does not go
        // out of sync.
        if (!dem._fCallEnableModeless)
            return E_FAIL;
    }
    
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::QueryContinue
//
//  Synopsis:   per IActiveScriptSiteInterruptPoll
//
//---------------------------------------------------------------------------
HRESULT
CScriptHolder::QueryContinue(void)
{
    HRESULT hr;
    IActiveScriptStats *pScriptStats=NULL;
    ULONG ulLow,ulHigh = 0;

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    TraceTag((tagScriptSite, "QueryContinue"));

    if (!_pCollection||!_pScript)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // Find out how many statements have executed. This is an optional interface
    // so allow QI to fail
    hr = THR(_pScript->QueryInterface(IID_IActiveScriptStats,
        (void**)&pScriptStats ));
    if ( !hr )
    {
        hr = THR(pScriptStats->GetStat ( SCRIPTSTAT_STATEMENT_COUNT,
            &ulLow, &ulHigh ));
        if ( hr )
            goto Cleanup;

        hr = THR(pScriptStats->ResetStats());
        if ( hr )
            goto Cleanup;
    }
    else if ( hr != E_NOINTERFACE )
    {
        goto Cleanup;
    }

    Assert(_pCollection->_pOmWindowProxy);
    Assert(_pCollection->_pOmWindowProxy->Window());
    hr = THR(_pCollection->_pOmWindowProxy->Window()->QueryContinueScript(ulHigh));

Cleanup:
    ReleaseInterface(pScriptStats);
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::QueryService
//
//  Synopsis:   per IServiceProvider
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::QueryService(REFGUID sid, REFIID iid, LPVOID *ppv)
{
    TraceTag((tagScriptSite, "QueryService"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    RRETURN(_pCollection->_pOmWindowProxy->Document()->QueryService(sid, iid, ppv));
}



#ifndef NO_SCRIPT_DEBUGGER

//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::GetDocumentContextFromPosition
//
//  Synopsis:   per IActiveScriptSiteDebug
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::GetDocumentContextFromPosition(
    DWORD_PTR                   dwCookie,
    ULONG                       uCharacterOffset,
    ULONG                       uNumChars,
    IDebugDocumentContext **    ppDebugDocumentContext)
{
    HRESULT                 hr;
    CScriptCookieTable *    pScriptCookieTable;

#ifndef NO_SCRIPT_DEBUGGER
    Assert(g_pPDM && g_pDebugApp);
#endif

    hr = THR(_pCollection->Doc()->EnsureScriptCookieTable(&pScriptCookieTable));
    if (hr)
        goto Cleanup;

    hr = THR(pScriptCookieTable->GetScriptDebugDocumentContext(
        dwCookie, uCharacterOffset, uNumChars, ppDebugDocumentContext));

Cleanup:
    RRETURN (hr);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::GetRootApplicationNode
//
//  Note:       This method can be called on a non-apartment thread
//              because the debugger may need access to this method
//              when the ui thread is hung inside a breakpoint.
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::GetRootApplicationNode (IDebugApplicationNode ** ppDebugApplicationNode)
{
    TraceTag((tagScriptSite, "GetRootApplicationNode"));

    HRESULT                 hr = E_UNEXPECTED;
    CScriptDebugDocument *  pDebugDocument = NULL;
    CMarkupScriptContext *  pMarkupScriptContext = _pCollection->Doc()->PrimaryMarkup()->ScriptContext();
    IDebugDocumentHelper *  pDebugHelper = NULL;

    if (!ppDebugApplicationNode)
        RRETURN(E_POINTER);

    *ppDebugApplicationNode = NULL;

    pDebugDocument = pMarkupScriptContext ? pMarkupScriptContext->_pScriptDebugDocument : NULL;

    if (pDebugDocument)
    {
        pDebugDocument->GetDebugHelper(&pDebugHelper);
        if (!pDebugHelper)
        {
            goto Cleanup;
        }
    
        hr = THR(pDebugHelper->GetDebugApplicationNode(ppDebugApplicationNode));
        if (hr)
        {
            goto Cleanup;
        }
    }

Cleanup:
    if (pDebugDocument)
        pDebugDocument->ReleaseDebugHelper(pDebugHelper);

    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::GetApplication
//
//  Synopsis:   per IActiveScriptSiteDebug
//
//  Note:       This method can be called on a non-apartment thread
//              because the debugger may need access to this method
//              when the ui thread is hung inside a breakpoint.
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::GetApplication( IDebugApplication **ppApp )
{
    TraceTag((tagScriptSite, "GetApplication"));
    Assert( ppApp );
    
    if( !ppApp )
        RRETURN(E_POINTER);
    if (!g_pDebugApp )
        RRETURN(E_UNEXPECTED);
    *ppApp = g_pDebugApp;
    (*ppApp)->AddRef( );

    RRETURN(S_OK);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::EnterBreakPoint
//
//  Synopsis:   per IActiveScriptSiteDebug
//
//  NOTE:       No longer used.  Replaced by IRemoteDebugApplicationEvents::OnEnterBreakPoint
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::EnterBreakPoint( void )
{
   TraceTag((tagScriptSite, "EnterBreakPoint"));
   Assert (!"CScriptHolder::EnterBreakPoint: obsolete member called");
   RRETURN(E_UNEXPECTED);
}


//---------------------------------------------------------------------------
//
//  Method:     CScriptHolder::LeaveBreakPoint
//
//  Synopsis:   per IActiveScriptSiteDebug
//
//  NOTE:       No longer used.  Replaced by IRemoteDebugApplicationEvents::OnLeaveBreakPoint
//
//---------------------------------------------------------------------------

HRESULT
CScriptHolder::LeaveBreakPoint( void )
{
    TraceTag((tagScriptSite, "LeaveBreakPoint"));
    Assert (!"CScriptHolder::EnterBreakPoint: obsolete member called");
    RRETURN(E_UNEXPECTED);
}

#endif // NO_SCRIPT_DEBUGGER

HRESULT 
CScriptHolder::QueryStatus (
        const GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    TraceTag((tagScriptSite, "QueryStatus"));
    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    return S_OK;
}

HRESULT 
CScriptHolder::Exec (
        const GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    TraceTag((tagScriptSite, "Exec"));

    if (IllegalCall())
        RRETURN(E_UNEXPECTED);
        
    HRESULT hr = S_OK;
    CDoc *  pDoc = _pCollection->Doc();

    if (!pguidCmdGroup || *pguidCmdGroup != CGID_ScriptSite)
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
        goto Cleanup;
    }

    switch (nCmdID)
    {
    case CMDID_SCRIPTSITE_URL:
    case CMDID_SCRIPTSITE_SID:

        if (!pvarargOut)
        {
            hr = E_POINTER;
            goto Cleanup;
        }
        
        V_VT(pvarargOut) = VT_BSTR;

        //
        // For security reasons, we use the actual URL of the calling doc
        // as opposed to the base URL. (We used the base URL in beta 2.)
        // Also this behavior is compat with Nav - dbau.
        //

        if (nCmdID == CMDID_SCRIPTSITE_URL)
        {
            CMarkup *pMarkup = _pCollection->_pOmWindowProxy->Markup();
            LPCTSTR pchUrl = CMarkup::GetUrl(pMarkup);

            if (IsSpecialUrl(pchUrl))
            {
                LPCTSTR pchCreatorUrl = pMarkup->GetAAcreatorUrl();
                Assert(pchCreatorUrl && *pchCreatorUrl);
                // Just to be on the safe side, as we it in other places!
                if (pchCreatorUrl && *pchCreatorUrl)
                    pchUrl = pchCreatorUrl;
            }

            hr = THR(FormsAllocString(pchUrl, &V_BSTR(pvarargOut)));
            if (hr)
                goto Cleanup;
        }
        else    // nCmdID == CMDID_SCRIPTSITE_SID
        {
            BYTE    abSID[MAX_SIZE_SECURITY_ID];
            DWORD   cbSID = ARRAY_SIZE(abSID);

            memset(abSID, 0, cbSID);

            hr = THR(_pCollection->_pOmWindowProxy->Markup()->GetSecurityID(abSID, &cbSID));
            if (hr)
                goto Cleanup;

            hr = FormsAllocStringLen(NULL, MAX_SIZE_SECURITY_ID, &V_BSTR(pvarargOut));
            if (hr)
                goto Cleanup;

            memcpy(V_BSTR(pvarargOut), abSID, MAX_SIZE_SECURITY_ID);
        }

        break;

    case CMDID_SCRIPTSITE_SECURITY_WINDOW:
        V_VT(pvarargOut) = VT_DISPATCH;
        V_DISPATCH(pvarargOut) = (IHTMLWindow2 *)_pCollection->_pOmWindowProxy;

        _pCollection->_pOmWindowProxy->AddRef();

#if DBG==1
        if (IsTagEnabled(tagSecureScriptWindow))
        {
            V_DISPATCH(pvarargOut) = (IHTMLWindow2 *)_pCollection->_pSecureWindowProxy;
            _pCollection->_pSecureWindowProxy->AddRef();
            _pCollection->_pOmWindowProxy->Release();
        }
#endif

        break;

    case CMDID_SCRIPTSITE_TRUSTEDDOC:
        if (!pvarargOut)
        {
            hr = E_POINTER;
            goto Cleanup;
        }

        V_VT(pvarargOut) = VT_BOOL;
        V_BOOL(pvarargOut) = (_pCollection->_pOmWindowProxy->Markup()->IsMarkupTrusted()) ? VARIANT_TRUE : VARIANT_FALSE;
        hr = S_OK;
        break;
        
    case CMDID_SCRIPTSITE_HTMLDLGTRUST:

        {
            if (!pvarargOut)
            {
                hr = E_POINTER;
                goto Cleanup;
            }
        
            V_VT(pvarargOut) = VT_EMPTY;

            if (pDoc->_fInHTMLDlg)
            {
                hr = THR(CTExec(
                    pDoc->_pClientSite,
                    &CGID_ScriptSite,
                    CMDID_SCRIPTSITE_HTMLDLGTRUST,
                    0,
                    NULL,
                    pvarargOut));

                if (hr)
                    goto Cleanup;
            }
            else
            {
                hr = OLECMDERR_E_NOTSUPPORTED;
            }

            break;
        }

    case CMDID_SCRIPTSITE_SECSTATE:
        {
            SSL_SECURITY_STATE sss;
            SSL_PROMPT_STATE   sps;
            BOOL               fPendingRoot;
            
            if (!pvarargOut)
            {
                hr = E_POINTER;
                goto Cleanup;
            }

            V_VT(pvarargOut) = VT_I4;

            fPendingRoot = _pCollection->_pOmWindowProxy->Markup()->IsPendingRoot();

            pDoc->GetRootSslState(fPendingRoot, &sss, &sps);

            V_I4(pvarargOut) = (long)sss;
            
            break;
        }

    default:
        hr = OLECMDERR_E_NOTSUPPORTED;
        break;

    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CScriptHolder::GetDebug(IActiveScriptDebug **ppDebug)
{
    HRESULT hr = S_OK;

    hr = THR(_pScript->QueryInterface(IID_IActiveScriptDebug, (LPVOID *)ppDebug));

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\stdform.cxx ===
//+--------------------------------------------------------------------------
//
//  File:       stdform.cxx
//
//  Contents:   IDoc methods of CDoc
//
//  Classes:    (part of) CDoc
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_SELECOBJ_HXX_
#define X_SELECOBJ_HXX_
#include "selecobj.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#ifndef X_PROGSINK_HXX_
#define X_PROGSINK_HXX_
#include "progsink.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_JSPROT_HXX_
#define X_JSPROT_HXX_
#include "jsprot.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_OBJSAFE_H_
#define X_OBJSAFE_H_
#include "objsafe.h"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_ACTIVSCP_H_
#define X_ACTIVSCP_H_
#include <activscp.h>
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifdef WIN16
#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include "shlguid.h"
#endif
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_DEBUGGER_HXX_
#define X_DEBUGGER_HXX_
#include "debugger.hxx"
#endif

#define _hxx_
#include "body.hdl"

#ifdef WIN16
UINT CTimeoutEventList::_uNextTimerID = 0xC000;

ExternTag(tagShDocMetaRefresh);
#endif

DeclareTag(tagTimerProblems, "Timer", "Timer problems");
DeclareTag( tagFormsTimerStarvation, "timer", "Trace windows Timer starvation problems" );

MtDefine(CDocGetFile, Utilities, "CDoc::GetFile")
MtDefine(TIMEOUTEVENTINFO, CTimeoutEventList, "TIMEOUTEVENTINFO")
MtDefine(CDocPersistLoad_aryElements_pv, Locals, "Persistence stuff")


extern HRESULT CreateStreamOnFile(
        LPCTSTR lpstrFile,
        DWORD dwSTGM,
        LPSTREAM * ppstrm);

HRESULT GetFullyExpandedUrl(CBase *pBase, BSTR bstrUrl, BSTR *pbstrFullUrl, BSTR * pbstrBaseUrl = NULL, IServiceProvider *pSP = NULL);

//+---------------------------------------------------------------------------
//
//  Helper:     GetScriptSite
//
//----------------------------------------------------------------------------

HRESULT
GetScriptSiteCommandTarget (IServiceProvider * pSP, IOleCommandTarget ** ppCommandTarget)
{
    RRETURN(THR_NOTRACE(pSP->QueryService(SID_GetScriptSite,
                                          IID_IOleCommandTarget,
                                          (void**) ppCommandTarget)));
}

//+---------------------------------------------------------------------------
//
//  Member:     GetCallerCommandTarget
//
//  Synopsis:   walks up caller chain getting either first or last caller
//              and then gets it's command target
//
//----------------------------------------------------------------------------

HRESULT
GetCallerCommandTarget (
    CBase *              pBase,
    IServiceProvider *   pBaseSP,
    BOOL                 fFirstScriptSite,
    IOleCommandTarget ** ppCommandTarget)
{
    HRESULT                 hr = S_OK;
    IUnknown *              pUnkCaller = NULL;
    IServiceProvider    *   pCallerSP = NULL;
    IServiceProvider    *   pSP = NULL;
    IOleCommandTarget   *   pCmdTarget = NULL;
    BOOL                    fGoneUp = FALSE;


    Assert (ppCommandTarget);
    *ppCommandTarget = NULL;

    if (pBaseSP)
    {
        ReplaceInterface (&pSP, pBaseSP);
    }
    else if (pBase)
    {
        pBase->GetUnknownObjectAt(
            pBase->FindAAIndex (DISPID_INTERNAL_INVOKECONTEXT,CAttrValue::AA_Internal),
            &pUnkCaller);
        if (!pUnkCaller)
            goto Cleanup;

        hr = THR(pUnkCaller->QueryInterface(
                IID_IServiceProvider,
                (void**) &pSP));
        if (hr || !pSP)
            goto Cleanup;
    }
    else
    {
        // We have neither a CBase object nor a service provider. Impossible to 
        // determine the command target.
        goto Cleanup;
    }

    Assert(pSP);

    // Crawl up the caller chain to find the first script engine in the Invoke chain.
    // Always hold onto the last valid command target you got
    for(;;)
    {
        hr = THR_NOTRACE(GetScriptSiteCommandTarget(pSP, &pCmdTarget));

        if ( !hr && pCmdTarget )
        {
            ReplaceInterface(ppCommandTarget, pCmdTarget ); // pCmdTarget now has 2 Addrefs
            ClearInterface (&pCmdTarget); // pCmdTarget now has 1 addref
        }
        if ( fFirstScriptSite && fGoneUp )
            break;

        // Skip up to the previous caller in the Invoke chain
        hr = THR_NOTRACE(pSP->QueryService(SID_GetCaller, IID_IServiceProvider, (void**)&pCallerSP));
        if (hr || !pCallerSP)
            break;

        fGoneUp = TRUE;

        ReplaceInterface(&pSP, pCallerSP);
        ClearInterface(&pCallerSP);
    }

Cleanup:
    ReleaseInterface(pUnkCaller);
    ReleaseInterface(pCallerSP);
    ReleaseInterface(pSP);

    hr = *ppCommandTarget ? S_OK : S_FALSE;
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Helper:     GetCallerURL
//
//  Synopsis:   Helper method,
//              gets the base url from the calling document.
//----------------------------------------------------------------------------


HRESULT
GetCallerURL(CStr &cstr, CBase *pBase, IServiceProvider * pSP)
{
    HRESULT             hr = S_OK;
    IOleCommandTarget * pCommandTarget;
    CVariant            Var;

    hr = THR(GetCallerCommandTarget(pBase, pSP, FALSE, &pCommandTarget));
    if (hr)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR(pCommandTarget->Exec(
            &CGID_ScriptSite,
            CMDID_SCRIPTSITE_URL,
            0,
            NULL,
            &Var));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&Var) == VT_BSTR);
    hr = THR(cstr.Set(V_BSTR(&Var)));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pCommandTarget);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Helper:     GetCallerSecurityStateAndURL
//
//  Synopsis:   Helper method,
//              gets the security state from the calling document
//              and URL.  
//
//----------------------------------------------------------------------------


HRESULT
GetCallerSecurityStateAndURL(SSL_SECURITY_STATE *pSecState, 
                             CStr &cstr, 
                             CBase *pBase, 
                             IServiceProvider * pSP)
{
    HRESULT             hr;
    IOleCommandTarget * pCommandTarget = NULL;
    CVariant            Var;

    *pSecState = SSL_SECURITY_UNSECURE;

    hr = THR(GetCallerCommandTarget(pBase, pSP, FALSE, &pCommandTarget));
    if (hr)
    {
        hr = S_OK;
        goto Cleanup;
    }


    // Get the security state
    hr = THR(pCommandTarget->Exec(
            &CGID_ScriptSite,
            CMDID_SCRIPTSITE_SECSTATE,
            0,
            NULL,
            &Var));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&Var) == VT_I4);
    *pSecState = (SSL_SECURITY_STATE)(V_I4(&Var));

    // Get the caller URL
    hr = THR(pCommandTarget->Exec(
            &CGID_ScriptSite,
            CMDID_SCRIPTSITE_URL,
            0,
            NULL,
            &Var));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&Var) == VT_BSTR);
    hr = THR(cstr.Set(V_BSTR(&Var)));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pCommandTarget);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     GetCallerHTMLDlgTrust
//
//----------------------------------------------------------------------------

BOOL
GetCallerHTMLDlgTrust(CBase *pBase)
{
    HRESULT             hr = S_OK;
    IOleCommandTarget * pCommandTarget = NULL;
    CVariant            var;
    BOOL                fTrusted = FALSE;

    hr = THR(GetCallerCommandTarget(pBase, NULL, TRUE, &pCommandTarget));
    if (hr)
    {
        goto Cleanup;
    }

    if (pCommandTarget)
    {
        hr = THR_NOTRACE(pCommandTarget->Exec(
                &CGID_ScriptSite,
                CMDID_SCRIPTSITE_HTMLDLGTRUST,
                0,
                NULL,
                &var));
        if (hr)
            goto Cleanup;

        Assert (VT_BOOL == V_VT(&var));
        fTrusted = V_BOOL(&var);
    }
    else
    {
        fTrusted = FALSE;
    }

Cleanup:
    ReleaseInterface(pCommandTarget);

    return fTrusted;
}

#ifdef WIN16

// The meta refresh callback is distinguished from real
// scripts by the fact that the 'language' and 'script'
// strings are identical, and begin with refresh:

HRESULT MetaRefreshCallback(CDoc * pDoc, BSTR lang, BSTR script)
{
    LPCSTR pszUrl;
    HRESULT hr = S_OK;

    if (!lang || !script
        || _tcscmp(lang, script)
        || _tcsnicmp(lang, 8, "refresh:", 8))
    {
        // they don't match, so we don't want to handle this.
        TraceTag((tagShDocMetaRefresh, "MetaRefreshCallback not useable--is real script.", pszUrl));
        return S_FALSE;
    }

    // everything should already be parsed, so we shouldn't have
    // to go through the complex parser again. Just find the first , or ;
    // (Note that this also skips over the http-equiv:).
    pszUrl = script;
    while (*pszUrl && *pszUrl != '=')
    {
        pszUrl++;
    }

    if (*pszUrl)
    {
        // found a URL
        pszUrl++;
        TraceTag((tagShDocMetaRefresh, "Want to jump to %s.", pszUrl));
        // BUGWIN16? Should this be made asynchronous?
        pDoc->FollowHyperlink(pszUrl);
    }
    else
    {
        // BUGWIN16: what flags should we use? This looks like what win32 uses 18jun97.
        DWORD dwBindf = BINDF_GETNEWESTVERSION|BINDF_PRAGMA_NO_CACHE;

        TraceTag((tagShDocMetaRefresh, "Want to refresh, time=%d", pszUrl, GetTickCount()));

        if (pDoc->_pPrimaryMarkup)
        {
            hr = GWPostMethodCall(pDoc,
                        ONCALL_METHOD(CDoc, ExecRefreshCallback, execrefreshcallback), dwBindf, FALSE, "CDoc::ExecRefreshCallback");
        }
    }


    return hr;
}
#endif // win16

//+------------------------------------------------------------------------
//
//  Function:   GetLastModDate
//
//  Synopsis:   Sets the mod date used by the OM and the History code
//
//-------------------------------------------------------------------------

FILETIME
CMarkup::GetLastModDate()
{
    if (HtmCtx())
    {
        return(HtmCtx()->GetLastMod());
    }
    else
    {
        FILETIME ft = {0};
        return ft;
    }
}


//+------------------------------------------------------------------------
//
//  IDoc implementation
//
//-------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Method:     CDoc::GetcanPaste
//
//  Synopsis:   Returns whether the clipboard has readable data.
//
//--------------------------------------------------------------------------

HRESULT
CDoc::canPaste(VARIANT_BOOL * pfCanPaste)
{
    HRESULT         hr;
    IDataObject *   pDataObj = NULL;

    if (!pfCanPaste)
        RRETURN(SetErrorInfoInvalidArg());

    hr = THR(OleGetClipboard(&pDataObj));
    if (hr)
        goto Cleanup;

    hr = THR(FindLegalCF(pDataObj));

Cleanup:
    ReleaseInterface(pDataObj);
    *pfCanPaste = (hr == S_OK) ? VB_TRUE : VB_FALSE;
    return S_OK;
}




struct CTRLPOS
{
    IHTMLControlElement *  pCtrl;
    long        x;
    long        y;
};

int __cdecl
CompareCPTop(const void * pv1, const void * pv2)
{
    return (**(CTRLPOS **)pv1).y - (**(CTRLPOS **)pv2).y;
}

//---------------------------------------------------------------------------
//
//  Modes
//
//---------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Mode update functions.  They update the state of the mode and perform
//      any required side-effect.
//
//----------------------------------------------------------------------------


HRESULT
CDoc::UpdateDesignMode(CDocument * pContextDoc, BOOL fMode)
{        
    CMarkup           * pMarkup     = pContextDoc->Markup();
    
    Assert(pMarkup);

    COmWindowProxy    * pWindow     = pMarkup->Window();   
    BOOL                fOrgMode    = pMarkup->_fDesignMode;
    HRESULT             hr;
  
    // Cannot edit image files or when we have no window.
    if (!pWindow || pMarkup->IsImageFile() && fMode)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(pMarkup->ExecStop(FALSE, FALSE));
    if (hr)
        goto Cleanup;

    hr = THR(pMarkup->EnsureDirtyStream());
    if (hr)
        goto Cleanup;

    // we should set this before we do anything with refreshing the page,
    // This way, the document flags will be set to disable the scripts, if 
    // we are in design mode.
    pMarkup->_fDesignMode = fMode;


    {
        //
        // IEV6 4726
        // We cannot release editor since it is
        // shared across markups. 
        //    
        if (!pMarkup->GetParentMarkup()) // this is the topmost markup
        {
            IGNORE_HR( NotifySelection(EDITOR_NOTIFY_DOC_ENDED, NULL) );
            ReleaseEditor();
        }
        else
        {
            IUnknown* pUnknown = NULL;
            IGNORE_HR( pMarkup->QueryInterface( IID_IUnknown, ( void**) & pUnknown ));
            IGNORE_HR( NotifySelection(EDITOR_NOTIFY_CONTAINER_ENDED, pUnknown) );
            ReleaseInterface( pUnknown );
        }
    }

    if (!pMarkup->_fInheritDesignMode)
        IGNORE_HR(pContextDoc->SetAAdesignMode(fMode ? htmlDesignModeOn : htmlDesignModeOff));      
    
    // TODO: This switch is bad.  What if we are not ready to switch (PICS? EnableModeless?)
    if (pWindow->Window()->_pMarkupPending)
            IGNORE_HR(pWindow->SwitchMarkup(pWindow->Window()->_pMarkupPending));

    hr = THR(pWindow->ExecRefresh());
    if (FAILED(hr))
        goto Error;

    if (hr==S_FALSE)
    {
        // onbeforeunload was canceled, so restore
        // and get out of here.
        pWindow->Markup()->_fDesignMode = fOrgMode;
        hr = S_OK;
        goto Cleanup;
    }   

    if (_state == OS_UIACTIVE)
    {
#ifndef NO_OLEUI
        RemoveUI();
        hr = THR(InstallUI(FALSE));
        if (hr)
            goto Error;
#endif // NO_OLEUI

        // force to rebuild all collections
        //

// TODO - This invalidates too much.  Need to clear the caches,
// not dirty the document.  Unless this operation does dirty the
// document implicitly.
        pWindow->Markup()->UpdateMarkupTreeVersion();
        
        Invalidate();
    }   

Cleanup:
    RRETURN(hr);

Error:
    pWindow->Markup()->_fDesignMode = fOrgMode;
    THR_NOTRACE(pWindow->ExecRefresh());
    goto Cleanup;
}

HRESULT
CDoc::SetDesignMode ( CDocument * pContextDoc, htmlDesignMode mode )
{    
    HRESULT            hr = S_OK;
    CMarkup            *pMarkup = pContextDoc->Markup();
    IHTMLDocument4     *pIDocument4 = NULL;
    CWindow            *pWindow; 
/*
    if (mode == htmlDesignModeOn && _fFrameSet )
    {
        // Do nothing for frameset
        hr = MSOCMDERR_E_DISABLED;
        goto Cleanup;
    }
*/
    Assert(pContextDoc->GetWindowedMarkupContext()->GetWindowPending());
    pWindow = pContextDoc->GetWindowedMarkupContext()->GetWindowPending()->Window();
    if (pWindow->IsInScript())
    {
        // Cannot set mode while script is executing.

        hr = MSOCMDERR_E_DISABLED;

        // Make sure the design mode attribute returns the true state of design mode when
        // we fail to change it.

        IGNORE_HR(pContextDoc->SetAAdesignMode(pWindow->Markup()->_fDesignMode ? htmlDesignModeOn : htmlDesignModeOff));      

        goto Cleanup;
    }

    if (mode != htmlDesignModeOn && mode != htmlDesignModeOff && mode != htmlDesignModeInherit)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }    

    if (mode == htmlDesignModeInherit)
    {
        pMarkup->_fInheritDesignMode = TRUE;
        hr = THR(OnAmbientPropertyChange(DISPID_AMBIENT_USERMODE));
    }
    else
    {
        // update is needed if design inheritance is being disabled 
        // or the current designMode is different from the desired designMode
        BOOL fNeedToUpdate = (pMarkup->_fInheritDesignMode) ||
                             (!!pMarkup->_fDesignMode != (mode==htmlDesignModeOn));
        
        pMarkup->_fInheritDesignMode = FALSE;
        if (fNeedToUpdate)
        {
            hr = THR(UpdateDesignMode(pContextDoc, mode==htmlDesignModeOn));
        }
    }    

    if (mode == htmlDesignModeOn)
    {
       VARIANT_BOOL fRet = VB_TRUE;

       IGNORE_HR(this->QueryInterface(IID_IHTMLDocument4, (void **)&pIDocument4));
       if (pIDocument4)
            IGNORE_HR(pIDocument4->fireEvent(_T("onselectionchange"), NULL, &fRet));
    }

Cleanup:
    ReleaseInterface(pIDocument4);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  member: GetBodyElement
//
//  synopsis : helper for the get_/put_ functions that need the body
//
//-----------------------------------------------------------------------------

HRESULT
CMarkup::GetBodyElement(IHTMLBodyElement ** ppBody)
{
    HRESULT hr = S_OK;
    CElement * pElement = GetElementClient();

    if (!ppBody)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppBody = NULL;

    if (!pElement)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR_NOTRACE(pElement->QueryInterface(
        IID_IHTMLBodyElement, (void **) ppBody));

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  member: GetBodyElement
//
//  synopsis : helper for the get_/put_ functions that need the CBodyElement
//             returns S_FALSE if body element is not found
//
//-----------------------------------------------------------------------------
HRESULT
CMarkup::GetBodyElement(CBodyElement **ppBody)
{
    HRESULT hr = S_OK;
    CElement * pElementClient = GetElementClient();

    if (ppBody == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppBody = NULL;

    if (!pElementClient)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    if (pElementClient->Tag() == ETAG_BODY)
        *ppBody = DYNCAST(CBodyElement, pElementClient);
    else
        hr = S_FALSE;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------
//
//  member:   GetMyDomain
//
//  Synopsis ;  The domain of the current doc :
//                 GetUrlComponenetHelper properly handles Http://
//              however, "file://..." either returns ""  for a local file
//              or returns the (?) share name for intranet files
//
//      since setting domains is irrelevant for files, this will
//      return the proper "doamin" for files, but an HR of S_FALSE.
//      the Get_ code ignores this, the put_code uses it to determine
//      wether to bother checking or not.
//
//-------------------------------------------------------------------

HRESULT
CDoc::GetMyDomain(const TCHAR * pchUrl, CStr * pcstrOut)
{
    HRESULT  hr = E_INVALIDARG;
    TCHAR    ach[pdlUrlLen];
    DWORD    dwSize;

    if (!pchUrl || !pcstrOut)
        goto Cleanup;

    memset(ach, 0,sizeof(ach));

    // Clear the Output parameter
    pcstrOut->Set(_T("\0"));

    if (!*pchUrl)
        goto Cleanup;

    hr = THR(CoInternetParseUrl( pchUrl,
                             PARSE_DOMAIN,
                             0,
                             ach,
                             ARRAY_SIZE(ach),
                             &dwSize,
                             0));

    if (hr)
        goto Cleanup;

    // set the return value
    pcstrOut->Set(ach);

Cleanup:
    RRETURN(hr);
}

void
CDoc::ReleaseOMCapture()
{
    SetMouseCapture(NULL, NULL);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::FireTimeout
//
//  Synopsis:   save the code associated with a TimerID
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CWindow::FireTimeOut(UINT uTimerID)
{
    TIMEOUTEVENTINFO * pTimeout = NULL;
    LONG               id;
    HRESULT            hr = S_OK;
    thisclass::CLock   Lock(this);

    // CanNavigate relfects the EnableModeless state -- don't
    // do this if we are modeless disabled
    if (!CanNavigate())
        goto Cleanup;


    // Check the list and if ther are timers with target time less then current
    //      execute them and remove from the list. Only events occured earlier then
    //      timer uTimerID will be retrieved
    // TODO: check with Nav compat to see if Nav wraps to prevent clears during script exec.
    _cProcessingTimeout++;
    TraceTag((tagTimerProblems, "Got a timeout. Looking for a match to id %d",
                  uTimerID));


    while(_TimeoutEvents.GetFirstTimeoutEvent(uTimerID, &pTimeout) == S_OK)
    {
        // Now execute the given script
        hr = ExecuteTimeoutScript(pTimeout);
        if ( 0 == pTimeout->_dwInterval || hr )
            // setTimeout (or something wrong with script): delete the timer
            delete pTimeout;
        else
        {
            // setInterval: put timeout back in queue with next time to fire
            _TimeoutEvents.AddPendingTimeout( pTimeout );
        }
    }
    _cProcessingTimeout--;

    // deal with any clearTimeouts (clearIntervals) that may have occurred as
    // a result of processing the scripts.  Only clear pending timeouts when
    // we have finished processing all other timeouts.
    while ( _TimeoutEvents.GetPendingClear(&id) && !_cProcessingTimeout )
    {
        if ( !_TimeoutEvents.ClearPendingTimeout((UINT)id) )
            ClearTimeout( id );
    }

    // we cleanup here because clearTimeout might have been called from setTimeout code
    // before an error occurred which we want to get rid of above (nav compat)
    if (hr)
        goto Cleanup;

    // Requeue pending timeouts (from setInterval)
    while ( _TimeoutEvents.GetPendingTimeout(&pTimeout) )
    {
        pTimeout->_dwTargetTime = (DWORD)GetTargetTime(pTimeout->_dwInterval);
        hr = THR(_TimeoutEvents.InsertIntoTimeoutList(pTimeout, NULL, FALSE));
        if (hr)
        {
            ClearTimeout( pTimeout->_uTimerID );
            goto Cleanup;
        }

        hr = THR(FormsSetTimer( this, ONTICK_METHOD(thisclass, FireTimeOut, firetimeout),
                                pTimeout->_uTimerID, pTimeout->_dwInterval ));
        if (hr)
        {
            ClearTimeout( pTimeout->_uTimerID );
            goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}


// This function executes given timeout script and kills the associated timer

HRESULT
CWindow::ExecuteTimeoutScript(TIMEOUTEVENTINFO * pTimeout)
{
    HRESULT     hr = S_OK;
    CScriptCollection * pScriptCollection = _pMarkup->GetScriptCollection();

    if (pScriptCollection)
        pScriptCollection->AddRef();

    Assert(pTimeout != NULL);

    Verify(FormsKillTimer(this, pTimeout->_uTimerID) == S_OK);

    if (pTimeout->_pCode)
    {
        if (pScriptCollection)
        {
            DISPPARAMS  dp = g_Zero.dispparams;
            CVariant    varResult;
            EXCEPINFO   excepinfo;

            // Can't disconnect script engine while we're executing script.
            thisclass::CLock Lock(this);

            hr = THR(pTimeout->_pCode->Invoke(DISPID_VALUE,
                                              IID_NULL,
                                              0,
                                              DISPATCH_METHOD,
                                              &dp,
                                              &varResult,
                                              &excepinfo,
                                              NULL));
        }
    }
    else if (pTimeout->_code.Length() != 0)
    {
        CExcepInfo       ExcepInfo;
        CVariant         Var;

        if (pScriptCollection)
        {
            hr = THR(pScriptCollection->ParseScriptText(
                pTimeout->_lang,            // pchLanguage
                NULL,                       // pMarkup
                NULL,                       // pchType
                pTimeout->_code,            // pchCode
                NULL,                       // pchItemName
                _T("\""),                   // pchDelimiter
                0,                          // ulOffset
                0,                          // ulStartingLine
                NULL,                       // pSourceObject
                SCRIPTTEXT_ISVISIBLE,       // dwFlags
                &Var,                       // pvarResult
                &ExcepInfo));               // pExcepInfo
        }

    }

    if (pScriptCollection)
        pScriptCollection->Release();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::AddTimeoutCode
//
//  Synopsis:   save the code associated with a TimerID
//
//----------------------------------------------------------------------------

HRESULT
CWindow::AddTimeoutCode(VARIANT *theCode, BSTR strLanguage, LONG lDelay, LONG lInterval,
                     UINT * uTimerID)
{
    HRESULT             hr;
    TIMEOUTEVENTINFO  * pTimeout;

    pTimeout = new(Mt(TIMEOUTEVENTINFO)) TIMEOUTEVENTINFO;
    if(pTimeout == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    if (V_VT(theCode) == VT_BSTR)
    {
        // Call the code associated with the timer.
        CScriptCollection *pScriptCollection = _pMarkup->GetScriptCollection();

        if (pScriptCollection)
        {
            hr = THR_NOTRACE(pScriptCollection->ConstructCode(
                                NULL,                   // pchScope
                                V_BSTR(theCode),        // pchCode
                                NULL,                   // pchFormalParams
                                strLanguage,            // pchLanguage
                                NULL,                   // pMarkup
                                NULL,                   // pchType
                                0,                      // ulOffset
                                0,                      // ulStartingLine
                                NULL,                   // pSourceObject
                                0,                      // dwFlags
                                &(pTimeout->_pCode),    // ppDispCode result
                                TRUE));                 // fSingleLine
        }
        else
            hr = E_FAIL;

        // Script engine can't produce PCODE so we'll do it the old way compiling on
        // each timer event.
        if (hr)
        {
            Assert(pTimeout->_pCode == NULL);

            // Set various data
            hr = THR(pTimeout->_code.SetBSTR(V_BSTR(theCode)));
            if (hr)
                goto Error;

            hr = THR(pTimeout->_lang.SetBSTR(strLanguage));
            if (hr)
                goto Error;
        }
    }
    else if (V_VT(theCode) == VT_DISPATCH)
    {
        pTimeout->_pCode = V_DISPATCH(theCode);
        if (pTimeout->_pCode)
        {
            pTimeout->_pCode->AddRef();
        }
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    // Save the time when the timeout happens
    pTimeout->_dwTargetTime = (DWORD)GetTargetTime(lDelay);

    // If lInterval=0, then called by setTimeout, otherwise called by setInterval
    pTimeout->_dwInterval = (DWORD)lInterval;

    // add the new element to the right position of the list
    // fills the timer id filed into the struct and returns
    // the value
    hr = THR(_TimeoutEvents.InsertIntoTimeoutList(pTimeout, uTimerID));
    if (hr)
        goto Error;

Cleanup:
    RRETURN(hr);

Error:
    delete pTimeout;
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Member:     CDoc::ClearTimeout
//
//  Synopsis:   Clears a previously setTimeout and setInterval
//
//----------------------------------------------------------------------------

HRESULT
CWindow::ClearTimeout(LONG lTimerID)
{
    HRESULT hr = S_OK;
    TIMEOUTEVENTINFO * pCurTimeout;

    if ( _cProcessingTimeout )
    {
        _TimeoutEvents.AddPendingClear( lTimerID );
    }
    else
    {
        // Get the timeout struct with given ID and remove it from the list
        hr = _TimeoutEvents.GetTimeout((DWORD)lTimerID, &pCurTimeout);
        if(hr == S_FALSE)
        {
            // Netscape just ignores the invalid arg silently - so do we.
            hr = S_OK;
            goto Cleanup;
        }

        if(pCurTimeout != NULL)
        {
            Verify(FormsKillTimer(this, pCurTimeout->_uTimerID) == S_OK);
            delete pCurTimeout;
        }
    }
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::SetTimeout
//
//  Synopsis:   Runs <Code> after <msec> milliseconds and returns a
//              timeout ID to be used by clearTimeout or clearInterval.
//              Also used for SetInterval.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::SetTimeout(
    VARIANT *pCode,
    LONG lMSec,
    BOOL fInterval,     // periodic, repeating
    VARIANT *pvarLang,
    LONG * plTimerID)
{
    HRESULT   hr = E_INVALIDARG;
    UINT      uTimerID;
    CVariant  varLanguage;

    if (!plTimerID )
        goto Cleanup;

    *plTimerID = -1;

    hr = THR(varLanguage.CoerceVariantArg(pvarLang, VT_BSTR));
    if (hr == S_FALSE)
    {
        // language not supplied
        V_BSTR(&varLanguage) = NULL;
        hr = S_OK;
    }
    if (!OK(hr))
        goto Cleanup;

    // Perform indirection if it is appropriate:
    if (V_VT(pCode) == (VT_BYREF | VT_VARIANT))
        pCode = V_VARIANTREF(pCode);

     // Do we have code.
    if ((V_VT(pCode) == VT_DISPATCH && V_DISPATCH(pCode)) || (V_VT(pCode) == VT_BSTR))
    {
        // Accept empty strings, just don't do anything with an empty string.
        if ((V_VT(pCode) == VT_BSTR) && SysStringLen(V_BSTR(pCode)) == 0)
            goto Cleanup;

        // Register the Code.  If no language send NULL.
        hr = THR(AddTimeoutCode(pCode,
                                V_BSTR(&varLanguage),
                                lMSec,
                                (fInterval? lMSec : 0),    // Nav 4 treats setInterval w/ 0 as a setTimeout
                                &uTimerID));
        if (hr)
            goto Cleanup;

        // Register the Timeout,

        hr = THR(FormsSetTimer(
                this,
                ONTICK_METHOD(thisclass, FireTimeOut, firetimeout),
                uTimerID,
                lMSec));
        if (hr)
            goto Error;

        // Return value
        *plTimerID = (LONG)uTimerID;
    }
    else
        hr = E_INVALIDARG;

Cleanup:
    RRETURN(hr);

Error:
    // clear out registered code
    ClearTimeout((LONG)uTimerID);
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::CleanupScriptTimers
//
//----------------------------------------------------------------------------

void
CWindow::CleanupScriptTimers()
{
    _TimeoutEvents.KillAllTimers(this);
}

//+----------------------------------------------------------------------
//
//
//-----------------------------------------------------------------------

static void
ChopToPath(TCHAR *szURL)
{
    TCHAR *szPathEnd;

    // Start scanning at terminating null the end of the string
    // Go back until we hit the last '/'  or the beginning of the string
    for ( szPathEnd = szURL + _tcslen(szURL);
        szPathEnd>szURL && *szPathEnd != _T('/');
        szPathEnd-- );

    // If we found the slash (and we're not looking at '//')
    // then terminate the string at the character following the slash
    // (If we didn't find the slash, then something is weird and we don't do anything)
    if (*szPathEnd == _T('/') && szPathEnd>szURL && szPathEnd[-1] != _T('/'))
    {
            // we are at the slash so set the character after the slash to NULL
        szPathEnd[1] = _T('\0');
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CDocument::GetDocDirection(pfRTL)
//
//  Synopsis:   Gets the document reading order. This is just a
//              reflection of the direction of the HTML element.
//
//  Returns:    S_OK if the direction was successfully set/retrieved.
//
//--------------------------------------------------------------------
HRESULT
CDocument::GetDocDirection(BOOL * pfRTL)
{
    long eHTMLDir = htmlDirNotSet;
    BSTR bstrDir = NULL;
    HRESULT hr;
    
    if (!pfRTL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pfRTL = FALSE;

    hr = THR(get_dir(&bstrDir));
    if (hr)
        goto Cleanup;

    hr = THR(s_enumdeschtmlDir.EnumFromString(bstrDir, &eHTMLDir));
    if (hr)
        goto Cleanup;

    if (eHTMLDir == htmlDirNotSet && _eHTMLDocDirection != htmlDirNotSet)
        *pfRTL = (_eHTMLDocDirection == htmlDirRightToLeft);
    else
        *pfRTL = (eHTMLDir == htmlDirRightToLeft);

Cleanup:
    FormsFreeString(bstrDir);
    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDocument::SetDocDirection(eHTMLDir)
//
//  Synopsis:   Sets the document reading order. This is just a
//              reflection of the direction of the HTML element.
//
//  Returns:    S_OK if the direction was successfully set/retrieved.
//
//--------------------------------------------------------------------
HRESULT
CDocument::SetDocDirection(LONG eHTMLDir)
{
    BSTR bstrDir = NULL;
    HRESULT hr;

    hr = THR(s_enumdeschtmlDir.StringFromEnum(eHTMLDir, &bstrDir));
    if (hr)
        goto Cleanup;
        
    hr = THR(put_dir(bstrDir));
    if (hr)
        goto Cleanup;
        
Cleanup:
    FormsFreeString(bstrDir);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// Member: GetUrlCachedFileName gets the filename of the cached file
//         in Wininet's cache
//
//----------------------------------------------------------------------------
HRESULT
CMarkup::GetFile(TCHAR ** ppchFile)
{
    const TCHAR * pchUrl = CMarkup::GetUrl(this);
    HRESULT hr = S_OK;

    Assert(!!pchUrl);
    Assert(ppchFile);

    *ppchFile = NULL;

    if (!pchUrl)
        goto Cleanup;

    if (GetUrlScheme(pchUrl) == URL_SCHEME_FILE)
    {
        TCHAR achPath[MAX_PATH];
        DWORD cchPath;

        hr = THR(CoInternetParseUrl(pchUrl, PARSE_PATH_FROM_URL, 0, achPath, ARRAY_SIZE(achPath), &cchPath, 0));
        if (hr)
            goto Cleanup;
        hr = THR(MemAllocString(Mt(CDocGetFile), achPath, ppchFile));
    }
    else
    {
        BYTE                        buf[MAX_CACHE_ENTRY_INFO_SIZE];
        INTERNET_CACHE_ENTRY_INFO * pInfo = (INTERNET_CACHE_ENTRY_INFO *) buf;
        DWORD                       cInfo = sizeof(buf);

        if (RetrieveUrlCacheEntryFile(pchUrl, pInfo, &cInfo, 0))
        {
            DoUnlockUrlCacheEntryFile(pchUrl, 0);
            hr = THR(MemAllocString(Mt(CDocGetFile), pInfo->lpszLocalFileName, ppchFile));
        }
        else
            hr = E_FAIL;
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
// Protocol Identifier and Protocol Friendly Name
// Adapted from wc_html.h and wc_html.c of classic MSHTML
//
//-----------------------------------------------------------------------------
typedef struct {
        TCHAR * szName;
        TCHAR * szRegKey;
} ProtocolRec;

static ProtocolRec ProtocolTable[] = {
        _T("file:"),     _T("file"),
        _T("mailto:"),   _T("mailto"),
        _T("gopher://"), _T("gopher"),
        _T("ftp://"),    _T("ftp"),
        _T("http://"),   _T("http"),
        _T("https://"),  _T("https"),
        _T("news:"),     _T("news"),
        NULL, NULL
};

TCHAR * ProtocolFriendlyName(TCHAR * szURL)
{
    TCHAR szBuf[MAX_PATH];
    int   i;

    if (!szURL)
        return NULL;

    LoadString(GetResourceHInst(), IDS_UNKNOWNPROTOCOL, szBuf,
        ARRAY_SIZE(szBuf));
    for (i = 0; ProtocolTable[i].szName; i ++)
    {
        if (_tcsnipre(ProtocolTable[i].szName, -1, szURL, -1))
            break;
    }
    if (ProtocolTable[i].szName)
    {
        DWORD dwLen = sizeof(szBuf);
        //DWORD dwValueType;
        HKEY  hkeyProtocol;

        LONG lResult = RegOpenKeyEx(
                HKEY_CLASSES_ROOT,
                ProtocolTable[i].szRegKey,
                0,
                KEY_QUERY_VALUE,
                &hkeyProtocol);
        if (lResult != ERROR_SUCCESS)
            goto Cleanup;

        lResult = RegQueryValue(
                hkeyProtocol,
                NULL,
                szBuf,
                (long *) &dwLen);
        RegCloseKey(hkeyProtocol);
    }

Cleanup:
    return SysAllocString(szBuf);
}

//+----------------------------------------------------------------------------
//
// Member:      CDoc::GetInterfaceSafetyOptions
//
// Synopsis:    per IObjectSafety
//
//-----------------------------------------------------------------------------

HRESULT
CDoc::GetInterfaceSafetyOptions(
    REFIID riid,
    DWORD *pdwSupportedOptions,
    DWORD *pdwEnabledOptions)
{
    *pdwSupportedOptions = *pdwEnabledOptions =
        INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;
    return S_OK;
}


//+----------------------------------------------------------------------------
//
// Member:      CDoc::SetInterfaceSafetyOptions
//
// Synopsis:    per IObjectSafety
//
//-----------------------------------------------------------------------------

HRESULT
CDoc::SetInterfaceSafetyOptions(
    REFIID riid,
    DWORD dwOptionSetMask,
    DWORD dwEnabledOptions)
{
    // This needs to hook into the IObjectSafety calls we make on objects.
    // (anandra)
    return S_OK;
}


//+----------------------------------------------------------------------------
//
// Member:      CDoc::SetUIHandler
//
// Synopsis:    per ICustomDoc
//
//-----------------------------------------------------------------------------

HRESULT
CDoc::SetUIHandler(IDocHostUIHandler *pUIHandler)
{
    IOleCommandTarget * pHostUICommandHandler = NULL;

    ReplaceInterface(&_pHostUIHandler, pUIHandler);
    if (pUIHandler && _pHostUIHandler == pUIHandler)
        _fUIHandlerSet = TRUE;

    if (_pHostUIHandler)
    {
        // We don't care if this succeeds (for now), we init pHostUICommandHandler to NULL.
        //
        IGNORE_HR(_pHostUIHandler->QueryInterface(IID_IOleCommandTarget,
                                            (void**)&pHostUICommandHandler));
    }
    ReplaceInterface(&_pHostUICommandHandler, pHostUICommandHandler);
    ReleaseInterface(pHostUICommandHandler);
    
    return S_OK;
}


//+------------------------------------------------------------------------------
//
//      Member : FirePersistOnloads ()
//
//      Synopsis : temporary helper function to fire the history and shortcut onload
//          events.
//
//+------------------------------------------------------------------------------
void
CMarkup::FirePersistOnloads()
{
    CNotification   nf;
    long            i;
    CStackPtrAry<CElement *, 64>  aryElements(Mt(CDocPersistLoad_aryElements_pv));
    CMarkupBehaviorContext * pContext = NULL;

    if (S_OK != EnsureBehaviorContext(&pContext))
        return;
                
    if (pContext->_cstrHistoryUserData)
    {
        nf.XtagHistoryLoad(Root(), &aryElements);
        Notify(&nf);

        for (i = 0; i < aryElements.Size(); i++)
        {
            aryElements[i]->TryPeerPersist(XTAG_HISTORY_LOAD, 0);
        }
    }
    else if (Doc()->_pShortcutUserData)
    {
        FAVORITES_NOTIFY_INFO   sni;

        // load the favorites
        sni.pINPB = Doc()->_pShortcutUserData;
        sni.bstrNameDomain = SysAllocString(_T("DOC"));
        if (sni.bstrNameDomain != NULL)
        {
            nf.FavoritesLoad(Root(), &aryElements);
            Notify(&nf);

            for (i = 0; i < aryElements.Size(); i++)
            {
                aryElements[i]->TryPeerPersist(FAVORITES_LOAD, &sni);
            }

            SysFreeString(sni.bstrNameDomain);
        }
    }
}


HRESULT
CDoc::PersistFavoritesData(CMarkup *pMarkup,
                           INamedPropertyBag * pINPB,
                           LPCWSTR strDomain)
{
    HRESULT      hr = S_OK;
    PROPVARIANT  varValue;

    Assert (pINPB);

    // now load the variant, and save each property we are
    // interested in
    V_VT(&varValue) = VT_BSTR;
    V_BSTR(&varValue) = (TCHAR *) CMarkup::GetUrl(pMarkup);

    // for the document.. ALWAYS save the baseurl. this
    //  is used later for the security checkes fo the subframes.
    hr = THR(pINPB->WritePropertyNPB(strDomain,
                                     _T("BASEURL"),
                                     &varValue));

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CTimeoutEventList::GetFirstTimeoutEvent
//
//  Synopsis:   Returns the first timeout event if given event is found in the
//                 list. Im most cases the returned event will be the one
//                 with given id, but if WM_TIMER messages came out of order
//                 it can be another one with smaller target time.
//              Removes the event from the list before returning.
//
//              Return value is S_FALSE if given event is not in the list
//--------------------------------------------------------------------------

HRESULT
CTimeoutEventList::GetFirstTimeoutEvent(UINT uTimerID, TIMEOUTEVENTINFO **ppTimeout)
{
    HRESULT           hr = S_OK;
    int  nNumEvents = _aryTimeouts.Size();
    int               i;

    Assert(ppTimeout != NULL);

    // Find the event first
    for(i = nNumEvents - 1; i >= 0  ; i--)
    {
        if(_aryTimeouts[i]->_uTimerID == uTimerID)
            break;
    }

    if(i < 0)
    {
        // The event is no longer active, or there is an error
        *ppTimeout = NULL;
        hr = S_FALSE;
        goto Cleanup;
    }

    // Elements are sorted and given event is in the list.
    // As long as given element is in the list we can return the
    //      last element without further checks
    *ppTimeout = _aryTimeouts[nNumEvents - 1];

#ifndef WIN16
    // Win16: Use GetTimeout(pTimeout->_uTimerID, dummy pTimeout) to delete this.

    // Remove it from the array
    _aryTimeouts.Delete(nNumEvents - 1);
#endif


Cleanup:
    RRETURN1(hr, S_FALSE);
}



//+-------------------------------------------------------------------------
//
//  Method:     CTimeoutEventList::GetTimeout
//
//  Synopsis:   Gets timeout event with given timer id and removes it from the list
//
//              Return value is S_FALSE if given event is not in the list
//--------------------------------------------------------------------------

HRESULT
CTimeoutEventList::GetTimeout(UINT uTimerID, TIMEOUTEVENTINFO **ppTimeout)
{
    int                   i;
    HRESULT               hr;

    for(i = _aryTimeouts.Size() - 1; i >= 0  ; i--)
    {
        if(_aryTimeouts[i]->_uTimerID == uTimerID)
            break;
    }

    if(i >= 0)
    {
        *ppTimeout = _aryTimeouts[i];
        // Remove the pointer
        _aryTimeouts.Delete(i);
        hr = S_OK;
    }
    else
    {
        *ppTimeout = NULL;
        hr = S_FALSE;
    }

    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CTimeoutEventList::InsertIntoTimeoutList
//
//  Synopsis:   Saves given timeout info pointer in the list
//
//              Returns the ID associated with timeout entry
//--------------------------------------------------------------------------

HRESULT
CTimeoutEventList::InsertIntoTimeoutList(TIMEOUTEVENTINFO *pTimeoutToInsert, UINT *puTimerID, BOOL fNewID)
{
    HRESULT hr = S_OK;
    int  i;
    int  nNumEvents = _aryTimeouts.Size();

    Assert(pTimeoutToInsert != NULL);

    // Fill the timer ID field with the next unused timer ID
    // We add this to make its appearance random
    if ( fNewID )
    {
#ifdef WIN16
        pTimeoutToInsert->_uTimerID = _uNextTimerID;
        _uNextTimerID = (_uNextTimerID < (UINT)0xFFFF) ? (_uNextTimerID+1) : 0xC000;
#else
        pTimeoutToInsert->_uTimerID = _uNextTimerID++ + (DWORD)(DWORD_PTR)this;
#endif
    }

    // Find the appropriate position. Current implementation keeps the elements
    // sorted by target time, with the one having min target time near the top
    for(i = 0; i < nNumEvents  ; i++)
    {
        if(pTimeoutToInsert->_dwTargetTime >= _aryTimeouts[i]->_dwTargetTime)
        {
            // Insert before current element
            hr = THR(_aryTimeouts.Insert(i, pTimeoutToInsert));
            if (hr)
                goto Cleanup;

            break;
        }
    }

    if(i == nNumEvents)
    {
        /// Append at the end
        hr = THR(_aryTimeouts.Append(pTimeoutToInsert));
        if (hr)
            goto Cleanup;
    }

    if (puTimerID)
        *puTimerID = pTimeoutToInsert->_uTimerID;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CTimeoutEventList::KillAllTimers
//
//  Synopsis:   Stops all the timers in the list and removes events from the list
//
//--------------------------------------------------------------------------

void
CTimeoutEventList::KillAllTimers(void * pvObject)
{
    int i;

    for(i = _aryTimeouts.Size() - 1; i >= 0; i--)
    {
        if (!FormsKillTimer(pvObject, _aryTimeouts[i]->_uTimerID))
        {
            delete _aryTimeouts[i];
            _aryTimeouts.Delete(i);
        }
    }

    for(i = _aryPendingTimeouts.Size() - 1; i >= 0; i--)
    {
        delete _aryPendingTimeouts[i];
    }
    _aryPendingTimeouts.DeleteAll();
    _aryPendingClears.DeleteAll();
}

//+-------------------------------------------------------------------------
//
//  Method:     CTimeoutEventList::GetPendingTimeout
//
//  Synopsis:   Gets a pending Timeout, and removes it from the list
//
//--------------------------------------------------------------------------
BOOL
CTimeoutEventList::GetPendingTimeout( TIMEOUTEVENTINFO **ppTimeout )
{
    int i;
    Assert( ppTimeout );
    if ( (i=_aryPendingTimeouts.Size()-1) < 0 )
    {
        *ppTimeout = NULL;
        return FALSE;
    }

    *ppTimeout = _aryPendingTimeouts[i];
    _aryPendingTimeouts.Delete(i);
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CTimeoutEventList::ClearPendingTimeout
//
//  Synopsis:   Removes a timer from the pending list and returns TRUE.
//              If timer with ID not found, returns FALSE
//
//--------------------------------------------------------------------------
BOOL
CTimeoutEventList::ClearPendingTimeout( UINT uTimerID )
{
    BOOL fFound = FALSE;

    for ( int i=_aryPendingTimeouts.Size() - 1; i >= 0; i-- )
    {
        if ( _aryPendingTimeouts[i]->_uTimerID == uTimerID )
        {
            delete _aryPendingTimeouts[i];
            _aryPendingTimeouts.Delete(i);
            fFound = TRUE;
            break;
        }
    }
    return fFound;
}

//+-------------------------------------------------------------------------
//
//  Method:     CTimeoutEventList::GetPendingClear
//
//  Synopsis:   Returns TRUE and an ID of a timer that was cleared during
//              timer processing. If there are none left, it returns FALSE.
//
//--------------------------------------------------------------------------
BOOL
CTimeoutEventList::GetPendingClear( LONG *plTimerID )
{
    int i;
    if ( (i=_aryPendingClears.Size()-1) < 0 )
    {
        *plTimerID = 0;
        return FALSE;
    }

    *plTimerID = (LONG)_aryPendingClears[i];
    _aryPendingClears.Delete(i);
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     ReportScriptletError
//
//  Synopsis:   Displays the scriptlet error that occurred.  The pContext
//              is either CPeerSite or CPeerFactoryUrl.  Depending
//              on that context we'll either return compile time or runtime
//              errors.
//
//--------------------------------------------------------------------------

HRESULT
ErrorRecord::Init(IScriptletError *pSErr, LPTSTR pchDocURL)
{
    HRESULT     hr;

    Assert(pSErr);

    hr = THR(pSErr->GetExceptionInfo(&_ExcepInfo));
    if (hr)
        goto Cleanup;

    hr = THR(pSErr->GetSourcePosition(&_uLine, &_uColumn));
    if (hr)
        goto Cleanup;

    _pchURL = pchDocURL;

Cleanup:
    RRETURN(hr);
}

HRESULT
ErrorRecord::Init(IActiveScriptError *pASErr, COmWindowProxy * pWndProxy)
{
    HRESULT     hr;
    long        uColumn;
    LPTSTR      pchMarkupURL = NULL;
    CDoc *      pDoc = pWndProxy->Markup()->Doc();
    Assert(pASErr);

    hr = THR(pASErr->GetExceptionInfo(&_ExcepInfo));
    if (hr)
        goto Cleanup;

#if defined(_WIN64)
    IActiveScriptError64 *pASErr64 = NULL;

    hr = THR(pASErr->QueryInterface(IID_IActiveScriptError64, (void **)&pASErr64));
    if (hr)
        goto Cleanup;

    hr = THR(pASErr64->GetSourcePosition64(&_dwSrcContext, &_uLine, &uColumn));
    ReleaseInterface(pASErr64);
#else
    hr = THR(pASErr->GetSourcePosition(&_dwSrcContext, &_uLine, &uColumn));
#endif
    if (hr)
        goto Cleanup;

    if (NO_SOURCE_CONTEXT != _dwSrcContext)
    {
        CMarkup *pMarkup = NULL;

        if (pDoc->_pScriptCookieTable)
        {
            HRESULT hr2 = THR(pDoc->_pScriptCookieTable->GetSourceObjects(_dwSrcContext, &pMarkup, NULL, &_pScriptDebugDocument));
            if (hr2 != S_OK)
                pMarkup = NULL;
        }
        else
        {
            pMarkup = (CMarkup *)_dwSrcContext;
            WHEN_DBG(CMarkup *pDbgMarkup=NULL;)
            Assert(pMarkup && (S_OK == pMarkup->QueryInterface(CLSID_CMarkup, (void **)&pDbgMarkup)) && (pMarkup == pDbgMarkup));
            Assert(!_pScriptDebugDocument);
        }

        if (pMarkup)
        {
            // There is a markup script context. We use its relative markup's Url.
            pchMarkupURL = (LPTSTR)CMarkup::GetUrl(pMarkup);
        }
    }

    _uColumn = uColumn;
    // IActiveScriptError assumes line #s/column #s are zero based.
    _uLine++;
    _uColumn++;

    // If the markup found from the cookie table has a script context, then use its URL, 
    // otherwise use the URL from the markup that is related to the window proxy we received.
    _pchURL = pchMarkupURL ? pchMarkupURL : (TCHAR *)CMarkup::GetUrl(pWndProxy->Markup());

Cleanup:
    RRETURN(hr);
}

HRESULT
ErrorRecord::Init(HRESULT hrError, LPTSTR pchErrorMessage, LPTSTR pchDocURL)
{
    HRESULT     hr;

    _pchURL = pchDocURL;
    _ExcepInfo.scode = hrError;

    hr = THR(FormsAllocString(pchErrorMessage, &_ExcepInfo.bstrDescription));

    RRETURN (hr);
}

HRESULT
CMarkup::ReportScriptError(ErrorRecord &errRecord)
{
    HRESULT     hr = S_OK;
    TCHAR      *pchDescription;
    TCHAR       achDescription[256];
    BSTR        bstrURL = NULL;
    BSTR        bstrDescr = NULL;
    BOOL        fContinueScript = FALSE;
    BOOL        fErrorHandled;
    COmWindowProxy *    pWindow = Window(); 
    CWindow     *pCWindow;
    CScriptCollection * pScriptCollection = GetScriptCollection();
    CMarkup::CLock      markupLock(this);

#ifdef UNIX // support scripting error dialog option.
    HKEY        key;
    TCHAR       ach[10];
    DWORD       dwType, dwLength = 10 * sizeof(TCHAR);
    BOOL        fShowDialog = TRUE;
#endif

    // No more messages to return or if the script was aborted (through the
    // script debugger) then don't put up any UI.
    Assert(this == GetWindowedMarkupContext());
    Assert(pWindow);
    pCWindow = pWindow->Window();
    Assert(pCWindow);

    if (pCWindow->_fEngineSuspended || errRecord._ExcepInfo.scode == E_ABORT)
        goto Cleanup;

    // These errors are reported on LeaveScript where we're guaranteed to have
    // enough memory and stack space for the error message.
    if (pCWindow->_fStackOverflow || pCWindow->_fOutOfMemory)
    {
        if (!pCWindow->_fEngineSuspended)
        {
            pCWindow->_badStateErrLine = errRecord._uLine;
            goto StopAllScripts;
        }
        else
            goto Cleanup;
    }

    //
    // Get a description of the error.
    //

    // vbscript passes empty strings and jscript passes NULL, so check for both

    if (errRecord._ExcepInfo.bstrDescription && *errRecord._ExcepInfo.bstrDescription)
    {
        pchDescription = errRecord._ExcepInfo.bstrDescription;
    }
    else
    {
        GetErrorText(errRecord._ExcepInfo.scode, achDescription, ARRAY_SIZE(achDescription));
        pchDescription = achDescription;
    }

    if (pWindow)
    {
        if (errRecord._pchURL)
        {
            hr = THR(FormsAllocString(errRecord._pchURL, &bstrURL));
            if (hr)
                goto Cleanup;
        }

        // Allocate a BSTR for the description string
        hr = THR(FormsAllocString(pchDescription, &bstrDescr));
        if (hr)
            goto Cleanup;

        fErrorHandled = pWindow->Fire_onerror(bstrDescr,
                                                 bstrURL,
                                                 errRecord._uLine,
                                                 errRecord._uColumn,
                                                 errRecord._ExcepInfo.wCode,
                                                 FALSE);

        if (!fErrorHandled)
        {
    #ifdef UNIX // Popup error-dialog? No script error dialog = No script debugger ?
            if (ERROR_SUCCESS == RegOpenKey( HKEY_CURRENT_USER,
                                             _T("Software\\MICROSOFT\\Internet Explorer\\Main"),
                                             &key))
            {
                if (ERROR_SUCCESS == RegQueryValueEx( key, _T("Disable Scripting Error Dialog"),
                                                      0, &dwType, (LPBYTE)ach, &dwLength))
                {
                    fShowDialog = (_tcscmp(ach, _T("no")) == 0);
                }
                RegCloseKey(key);
            }

            if ( !fShowDialog )
            {
                fContinueScript = TRUE; //Keep script running.
                hr = S_OK;
                goto StopAllScripts;
            }
    #endif

            if (errRecord._ExcepInfo.scode == VBSERR_OutOfStack)
            {
                if (!pCWindow->_fStackOverflow)
                {
                    pCWindow->_badStateErrLine = errRecord._uLine;
                    pCWindow->_fStackOverflow = TRUE;
                }
            }
            else if (errRecord._ExcepInfo.scode == VBSERR_OutOfMemory)
            {
                if (!pCWindow->_fOutOfMemory)
                {
                    pCWindow->_badStateErrLine = errRecord._uLine;
                    pCWindow->_fOutOfMemory = TRUE;
                }
            }

            // Stack overflow or out of memory error?
            if (pCWindow->_fStackOverflow || pCWindow->_fOutOfMemory)
            {
                // If pending stack overflow/out of memory have we
                // unwound the stack enough before displaying the
                // message.  These CDoc::LeaveScript function will
                // actually display the message when we leave the
                // last script.
                if (!pCWindow->_fEngineSuspended)
                    goto StopAllScripts;
                else
                    goto Cleanup;
            }

            fContinueScript = pWindow->Fire_onerror(bstrDescr,
                                                       bstrURL,
                                                       errRecord._uLine,
                                                       errRecord._uColumn,
                                                       errRecord._ExcepInfo.wCode,
                                                       TRUE);


StopAllScripts:
            //
            // If our container has asked us to refrain from using dialogs, we
            // should abort the script.  Otherwise we could end up in a loop
            // where we just sit and spin.
            //
            if ((_pDoc->_dwLoadf & DLCTL_SILENT) || !fContinueScript)
            {
                // Shutoff non-function object based script engines (VBSCRIPT)
                if (pScriptCollection && (pScriptCollection == GetScriptCollection(FALSE)))
                    IGNORE_HR(pScriptCollection->SetState(SCRIPTSTATE_DISCONNECTED));

                // Shutoff function object based script engines (JSCRIPT)
                _pDoc->_dwLoadf |= DLCTL_NO_SCRIPTS;

                pCWindow->_fEngineSuspended = TRUE;

                // Need to set this on the Doc as well so that the recalc engine can
                // use this, as it has no context markup.
                _pDoc->_fEngineSuspended = TRUE;
 
                hr = S_OK;
            }
        }
    }

Cleanup:
    FormsFreeString(bstrDescr);
    FormsFreeString(bstrURL);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\treeiter.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_ELEMENT_HXX
#include "element.hxx"
#endif

#include "markup.hxx"

#include "treepos.hxx"

#include "treeiter.hxx"

#ifndef _X_GENERIC_H_
#define _X_GENERIC_H_
#include "generic.hxx"
#endif

#ifdef V4FRAMEWORK


MtDefine(CTreeIterator, ObjectModel, "CTreeIterator")

#include "treeiter.h"

#define _cxx_
#include "treeiter.hdl"



HRESULT
CExternalFrameworkSite::GetNewTreeIterator ( long lRefElement, IDispatch **pTreeIterator )
{
    CElement *pElem = (CElement *)lRefElement;
    HRESULT hr = S_OK;
    CTreeIterator *pIterator = NULL;
    CTreeNode *pChildNode,*pParentNode;

    // If pElem NULL, iterator for root of tree ??

    Assert(pElem);
    Assert(pElem->Tag()==ETAG_GENERIC);

    if ( !pTreeIterator )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pTreeIterator = NULL;

    pChildNode = pElem->GetFirstBranch(); // Ignore overlapping for now
    if (!pChildNode)
        goto Cleanup;

    pParentNode = pChildNode->Parent();
    if(!pParentNode)
        goto Cleanup;

    pIterator = new CTreeIterator(pParentNode, pChildNode);
    if ( !pIterator )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pIterator->QueryInterface(IID_IDispatch, (void**)pTreeIterator));
    if ( hr )
        goto Cleanup;

    // Refcount of 2 at this point

Cleanup:
    if ( pIterator ) 
        pIterator->Release();
    RRETURN(hr);
}



    //+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------
const CBase::CLASSDESC CTreeIterator::s_classdesc =
{
    &CLSID_TreeIterator,   // _pclsid
    0,                                      // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                                   // _pcpi
    0,                                      // _dwFlags
    &IID_ITreeIterator,    // _piidDispinterface
    &s_apHdlDescs                           // _apHdlDesc
};

//+---------------------------------------------------------------
//
//  Member  : CTreeIterator::PrivateQueryInterface
//
//  Sysnopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------
HRESULT
CTreeIterator::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
    default:
        if (iid == IID_ITreeIterator)               
        {                                   
        HRESULT hr = CreateTearOffThunk(    
            this,                           
            (void *)this->s_apfnITreeIterator,      
            NULL, //pUnkOuter                     
            ppv);                           
        if (hr)                             
            RRETURN(hr);                    
        }
        break;
    }

    if (*ppv)
    {
        (*(IUnknown**)ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

HRESULT CTreeIterator::MoveToElement ( long lRefElement )
{
    CElement *pElement = (CElement *)lRefElement;

    Assert(pElement);
    Assert(pElement->Tag()==ETAG_GENERIC);



    return S_OK;
}

HRESULT CTreeIterator::Ascend(long *prefScopeElement)
{
    HRESULT hr = S_OK;
    if ( !prefScopeElement )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *prefScopeElement = 0;


Cleanup:
    RRETURN(hr);
}

HRESULT CTreeIterator::Next(long *prefScopeElement)
{
    HRESULT hr = S_OK;
    CTreeNode *pNode;
    CGenericElement::COMPLUSREF cpRef;

    if (prefScopeElement)
    {
        *prefScopeElement = 0;
    }

    pNode = _iterator.NextChild(); 
    if (!pNode)
        goto Cleanup;

    if (prefScopeElement)
    {
        CElement *pElem = pNode->Element();
        if (pElem->Tag() != ETAG_GENERIC) // TODO
        {
            hr = THR(Next(prefScopeElement)); // Skip it for now
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = ((CGenericElement*)pElem)->GetComPlusReference ( &cpRef );
            if (hr)
                goto Cleanup;
            *prefScopeElement = (long)cpRef;
        }
    }
Cleanup:
    RRETURN(hr);
}


HRESULT CTreeIterator::Previous(long *prefScopeElement)
{
    HRESULT hr = S_OK;
    CTreeNode *pNode;
    CGenericElement::COMPLUSREF cpRef;

    if (prefScopeElement)
    {
        *prefScopeElement = 0;
    }

    pNode = _iterator.PreviousChild(); 
    if (!pNode)
        goto Cleanup;

    if (prefScopeElement)
    {
        CElement *pElem = pNode->Element();
        if (pElem->Tag() != ETAG_GENERIC) // TODO
        {
            hr = THR(Next(prefScopeElement)); // Skip it for now
            if (hr)
                goto Cleanup;
        }
        else
        {
            hr = ((CGenericElement*)pElem)->GetComPlusReference ( &cpRef );
            if (hr)
                goto Cleanup;
            *prefScopeElement = (long)cpRef;
        }
    }
Cleanup:
    RRETURN(hr);
}

HRESULT CTreeIterator::Descend(long *prefScopeElement)
{
    // Move to the first Child of the current iterator
    HRESULT hr = S_OK;
    CTreeNode *pNode;
    CGenericElement::COMPLUSREF cpRef;

    if (prefScopeElement)
    {
        *prefScopeElement = 0;
    }

    if (!_iterator.ReInitWithCurrentChild())
        goto Cleanup;

    // Semantics of ReInitWithCurrentChild position me before the begin of the first child
    
    pNode = _iterator.NextChild();
    if ( !pNode )
    {
        // No first child, position me back where I was!
        _iterator.ReInitWithParent();
        goto Cleanup;
    }

    if (prefScopeElement)
    {
        CElement *pElem = pNode->Element();
        if (pElem->Tag() != ETAG_GENERIC) // TODO
        {
            //hr = THR(Next(prefScopeElement)); // Skip it for now
            //if (hr)
            //    goto Cleanup;
            goto Cleanup; // ???
        }
        else
        {
            hr = ((CGenericElement*)pElem)->GetComPlusReference ( &cpRef );
            if (hr)
                goto Cleanup;
            *prefScopeElement = (long)cpRef;
        }
    }
Cleanup:
    RRETURN(hr);
}


#endif V4FRAMEWORK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\stable.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft IE4/Trident
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       stable.cxx
//
//  Contents:   Implementation of validity/stablity of the tree
//
//  Classes:    CMarkup
//
//  Author:     alexa
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

// Right now we don't use the stability code.  I'm sure we will need
// this eventually.
#ifdef MARKUP_STABLE

#ifndef X_ELEMENT_HXX
#define X_ELEMENT_HXX
#include "element.hxx"
#endif

#ifndef X_TREEPOS_HXX
#define X_TREEPOS_HXX
#include "treepos.hxx"
#endif

#if DBG == 1
    char * gs_unstable[] = 
        {
            "No violation - tree/html is stable",
            "Violation of NESTED containers rule",
            "Violation of TEXTSCOPE rule",
            "Violation of OVERLAPING tags rule",
            "Violation of MASKING container rule",
            "Violation of PROHIBITED container rule",
            "Violation of REQUIRED container rule",
            "Violation of IMPLICITCHILD rule",
            "Violation of LITERALTAG rule",
            "Violation of TREE rules",
            "Vialotion of EMPTY TAG rule",
            "Vialotion of the tree pointer rule",
            "Can not determine if stable or not due to the other probelms (OUT_OF_MEMEORY)"
        };
#endif

MtDefine(Stability_aryScopeNodes_pv, Locals, "CRootSite::ValidateParserRules aryScopeNodes::_pv")

//+---------------------------------------------------------------------------
//
//  Member:     CRootSite::IsStable
//
//  Synopsis:   returns TRUE if tree is stable.
//
//----------------------------------------------------------------------------

BOOL CMarkup::IsStable()
{
    if (_fUnstable || Doc()->_lTreeVersion != _lStableTreeVersion)
    {
        // 1. do we have a dirty range/for now do the whole tree
        // 2. Walk the subtree of the dirty range and determine if the tree is stable
        _fUnstable = ValidateParserRules() != UNSTABLE_NOT;
    }
    if (!_fUnstable)
    {
        UpdateStableTreeVersionNumber();
    }
    return !_fUnstable;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRootSite::IsStable
//
//  Synopsis:   Returns TRUE if tree is stable.
//
//----------------------------------------------------------------------------

HRESULT CMarkup::MakeItStable()
{
    HRESULT hr = S_OK;

    if (_fUnstable)
    {
    }

    _fUnstable = FALSE;
    UpdateStableTreeVersionNumber();

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRootSite::UpdateStableTreeVersionNumber
//
//  Synopsis:   Update stable tree version number with the new tree version number
//
//+---------------------------------------------------------------------------
void    
CMarkup::UpdateStableTreeVersionNumber()
{
    _lStableTreeVersion = Doc()? Doc()->_lTreeVersion : 1; 
    return; 
}


//+---------------------------------------------------------------------------
//
//  Member:     CRootSite::ValidateParserRules
//
//  Synopsis:   Validate html and tree rules for each element of the tree.
//
//+---------------------------------------------------------------------------

UNSTABLE_CODE 
CMarkup::ValidateParserRules()
{
    CStackPtrAry < CTreeNode *, 8 > aryScopeNodes(Mt(Stability_aryScopeNodes_pv));
    UNSTABLE_CODE   iReturnCode = UNSTABLE_NOT;
    HRESULT         hr = S_OK;
    long            iRun = 0;
    long            cpTotal = 0;
    long            cch = 0;
    CTreeNode     * pNode = NULL;
    CTreeNode     * pNodei;
    CTreeNode     * pNodeConflict = NULL;
    CTreeNode     * pNodeOverlap = NULL;// overlaping node (the first of the 2 overlaping nodes)
    CHtmlParseClass * phpc;
    CHtmlParseClass * phpcOverlap=NULL; // phpc of the overlaping node
    const CTagDesc  * ptd;
    int             i;
    int             cInclusion = 0;     // depth of inclusion (overalping case)
    BOOL            fLiteralTag = FALSE;
    BOOL            fEmptyTag = FALSE;
    ELEMENT_TAG     etagImplicitChild = ETAG_NULL;
    ELEMENT_TAG     etagCurNode;        // tag of the current node
    BOOL            fNeedToValidateTextScope;
    BOOL            fNeedToValidateMasking;
    BOOL            fNeedToValidateProhibited;
    BOOL            fNeedToValidateRequired;
    BOOL            fNeedToCheckBeginContainer;

    // We need to perform the following checking of each element of the tree
    //+---------------------------------------------------------------------------
    // 0. Tree should be stable
    //+---------------------------------------------------------------------------
    // 1. Check if the NESTED RULE is preserved.
    // IF   X is a NESTED element (_scope field of the parseclass is == SCOPE_NESTED)
    //      and Y is NESTED element
    // THEN if there is a position P, where P->X->Y, then for all the other positions
    //      if P'->X it should be also P'->X->Y
    //+---------------------------------------------------------------------------
    // 2. Check if TEXTSCOPE RULE is preserved
    // IF   T is a text (_textScope) or T is textLike (_fTextLike is TRUE)
    // THEN there should be a parent  element X with TEXTSCOPE_INCLUDE
    //      AND all the Y elements between the T and X should be TEXTSCOPE_NEUTRAL
    // ex: T->N->N->I is legal; T->N->E->I is illegal
    //+---------------------------------------------------------------------------
    // 3. Check the ENDCONTAINER RULE is preserved (NO OVERLAPPING relationship between 2 tags)
    // IF   Y is an endcontainer of X
    // THEN if X is inside Y then Y should enclose X completely
    //      else if Y is inside X then X should enclose Y completely
    // ex: <TD><B>...</B></TD> - legal; <TD><B>....</TD></B> - is illegal
    // ex: <B><TD>...</TD></B> - legal; <B><TD>....</B></TD> - is illegal
    //+---------------------------------------------------------------------------
    // 4. Check for MASKING rule.
    // IF   X is masked by Y
    // THEN if X->Y then it should be a B in between X->B->Y , 
    //      where B is a BEGIN container of X (X has to be protected by B)
    // EX: X->(NOT B)->Y is illegal (Y shouldn't be a masking container)
    //+---------------------------------------------------------------------------
    // 5: Check for PROHIBITED containers RULE
    // IF   X has a prohibited container Y
    // THEN X->Y means that there is another container in between X->B->Y
    // EX: <P><P> - is illegal because X->NOT B->Y is illegal , <P><TD><P> - ???
    //+---------------------------------------------------------------------------
    // 6. Check for REQUIRED container
    // IF X has a begin container B (so X->...->B
    // THEN should exists Y (required container of X) in between
    // X->Y->B(or ROOT)
    // EX: TR->TBODY(THEAD,TFOOT)->TABLE
    //+---------------------------------------------------------------------------
    // 7. Check for IMPLICIT CHILD rule.
    // IF   X has implicit child Y
    // THEN the first immediate child of X should be Y
    // ex: HTML-(has IC)->HEAD-(has IC)->TITLE
    //+---------------------------------------------------------------------------
    // 8. Check for LITERALTAG rule
    // IF   X is a literal tag
    // THEN only a TEXT should be it's child
    // ex: <IMG>-><LITERALTAG> - is illegal
    //+---------------------------------------------------------------------------

  if (GetElementClient()->Tag() != ETAG_BODY)   // TODO: remove this when ericvas to checkin.
  {
    goto Conflict;
  }
  else
  {
    CTreePosGap     tpgWalker (FirstTreePos(), TPG_RIGHT, TPG_LEFT);

    tpgWalker.SetMoveDirection(TPG_RIGHT);
    do 
    {
        CTreePos *ptp = tpgWalker.AdjacentTreePos(TPG_LEFT);
        switch( ptp->Type() )
        {
        case CTreePos::NodeBeg:
        case CTreePos::NodeEnd:
            pNode = ptp->Branch();
            if(ptp->IsBeginNode())
            {
                // this is begin node

                // VALIDATE RULE #0: Tree should be stable
                if (!(aryScopeNodes.Size() == 0 || pNode->Parent() == aryScopeNodes[aryScopeNodes.Size() - 1]))
                {
                    Assert (FALSE && "The tree is totaly not safe");
                    iReturnCode = UNSTABLE_TREE;
                    goto Conflict;
                }

                etagCurNode = pNode->Tag();
                phpc = HpcFromEtag(etagCurNode);   // get a parser descriptor of the TAG

                fNeedToValidateTextScope  = (phpc->_texttype == TEXTTYPE_ALWAYS);
                fNeedToValidateMasking = phpc->_atagMaskingContainers != NULL;
                fNeedToValidateProhibited = phpc->_atagProhibitedContainers != NULL;
                fNeedToValidateRequired = phpc->_atagRequiredContainers != NULL;

                for ( pNodei = pNode->Parent();
                      (fNeedToValidateTextScope || fNeedToValidateMasking || fNeedToValidateProhibited || fNeedToValidateRequired) && pNodei;
                      pNodei = pNodei->Parent())                      
                {
                    fNeedToCheckBeginContainer = FALSE;
                    if (fNeedToValidateTextScope)
                    {
                        // VALIDATE RULE #2. Check if TEXTSCOPE RULE is preserved
                        CHtmlParseClass *phpci = HpcFromEtag(pNodei->Tag());
                        if (phpci->_textscope == TEXTSCOPE_INCLUDE)
                        {
                            fNeedToValidateTextScope = FALSE;   // means TEXTSCOPE is valid, there is an TEXTSCOPE_INCLUDE tag above
                        }
                        if (phpci->_textscope == TEXTSCOPE_EXCLUDE)
                        {
                            iReturnCode = UNSTABLE_TEXTSCOPE;
                            goto Conflict;
                        }
                    }
                    if (fNeedToValidateMasking)
                    {
                        // VALIDATE RULE #4: MASKING CONTAINERS RULE
                        if (IsEtagInSet(pNodei->Tag(), phpc->_atagMaskingContainers))
                        {
                            iReturnCode = UNSTABLE_MASKING;
                            pNodeConflict = pNodei;
                            goto Conflict;
                        }
                        fNeedToCheckBeginContainer = TRUE;
                    }
                    if (fNeedToValidateProhibited)
                    {
                        // VALIDATE RULE #5: PROHIBITED CONTAINERS RULE
                        if (IsEtagInSet(pNodei->Tag(), phpc->_atagProhibitedContainers))
                        {
                            iReturnCode = UNSTABLE_PROHIBITED;
                            pNodeConflict = pNodei;
                            goto Conflict;
                        }
                        fNeedToCheckBeginContainer = TRUE;
                    }
                    if (fNeedToValidateRequired)
                    {
                        // VALIDATE RULE #6: REQUIRED CONTAINERS RULE
                        if (IsEtagInSet(pNodei->Tag(), phpc->_atagRequiredContainers))
                        {
                            fNeedToValidateRequired = FALSE;// means REQUIRED rule is validated, there is a required container above
                        }
                        else
                        {
                            fNeedToCheckBeginContainer = TRUE;
                        }
                    }

                    if (fNeedToCheckBeginContainer && IsEtagInSet(pNodei->Tag(), phpc->_atagBeginContainers))
                    {
                        fNeedToValidateMasking = FALSE;     // means MASKING rule is valid, there is a BEGIN container in between
                        fNeedToValidateProhibited = FALSE;  // means PROHIBITED rule is valid, there is a BEGIN container in between
                        if (fNeedToValidateRequired)
                        {
                            iReturnCode = UNSTABLE_REQUIRED;
                            goto Conflict;
                        }
                    }
                }
                if (fNeedToValidateRequired)    // if still we need the required container after searching all the parenets, then
                {
                    iReturnCode = UNSTABLE_REQUIRED;
                    goto Conflict;
                }

                // VALIDATE RULE #7. IMPLICIT CHILD rule.
                if (etagImplicitChild && etagImplicitChild != etagCurNode)
                {
                    iReturnCode = UNSTABLE_IMPLICITCHILD;
                    goto Conflict;
                }

                etagImplicitChild = phpc->_etagImplicitChild;

                // VALIDATE RULE #8. Check for LITERALTAG rule
                if (fLiteralTag)
                {
                    iReturnCode = UNSTABLE_LITERALTAG;
                    goto Conflict;
                }
                ptd = TagDescFromEtag(pNode->Tag());
                fLiteralTag = ptd->HasFlag(TAGDESC_LITERALTAG) && 
                              etagCurNode != ETAG_GENERIC;  // generic tag can be both literal and not (alexz);

                // VALIDATE RULE #9: Empty tags
				if (fEmptyTag)
				{
					iReturnCode = UNSTABLE_EMPTYTAG;
					goto Conflict;
				}

                fEmptyTag = phpc->_scope == SCOPE_EMPTY;

                // this is a new element coming into scope. PUSH it to the aryScopeNodes (stack)
                hr = THR( aryScopeNodes.Append( pNode ) );
                if (hr)
                {
                    iReturnCode = UNSTABLE_CANTDETERMINE;
                    goto Conflict;
                }
                if (!ptp->IsEdgeScope())
                {
                    // this is the proxied branch (overlapping case)
                    Assert (cInclusion);
                    Assert (pNodeOverlap);

                    // VALIDATE RULE #3. (ILLEGAL OVERLAPPING relationship between 2 tags)
                    if (IsEtagInSet(etagCurNode, phpcOverlap->_atagEndContainers) ||
                        IsEtagInSet(pNodeOverlap->Tag(), phpc->_atagEndContainers))
                    {
                        iReturnCode = UNSTABLE_OVERLAPING;
                        goto Conflict;
                    }

                    // VALIDATE RULE #1. Check if the NESTED RULE is preserved.
                    if (phpcOverlap->_scope == SCOPE_NESTED && phpc->_scope == SCOPE_NESTED)
                    {
                        iReturnCode = UNSTABLE_NESTED;
						goto Conflict;
                    }

                    cInclusion--;
                    if (!cInclusion)
                    {
                        pNodeOverlap = NULL;
                        phpcOverlap = NULL;
                    }
                }
            }
            else
            {
                // this is the end node

				if (pNode != aryScopeNodes[aryScopeNodes.Size() - 1])
				{
					iReturnCode = UNSTABLE_TREE;
					goto Conflict;
				}


                if (ptp->IsEdgeScope())
                {
                    // this is the real end of the scope
                    if (cInclusion)
                    {
						Assert (pNodeOverlap == NULL);
                        pNodeOverlap = aryScopeNodes[aryScopeNodes.Size() - 1];
                        phpcOverlap = HpcFromEtag(pNodeOverlap->Tag());
                    }
                }
                else
                {
                    // this is temproary end of the scope (overlapping case)
					if (fLiteralTag)
					{
						iReturnCode = UNSTABLE_LITERALTAG;
						goto Conflict;
					}
					if (fEmptyTag)
					{
						iReturnCode = UNSTABLE_EMPTYTAG;
						goto Conflict;
					}

                    cInclusion++;
					Assert (pNodeOverlap == NULL);
                }

                fLiteralTag = FALSE;
				fEmptyTag = FALSE;

                // this element going out of scope. POP it from the aryScopeNodes (stack)
                aryScopeNodes.Delete(aryScopeNodes.Size() - 1);
            }
            break;
        case CTreePos::Text:
            cch = ptp->Cch();

            // VALIDATE RULE #2. Check if TEXTSCOPE RULE is preserved
            for ( i = aryScopeNodes.Size() - 1 ; cch && i >= 0 ; i-- )
            {
                pNode = aryScopeNodes[ i ];
                phpc = HpcFromEtag(pNode->Tag());
                if (phpc->_textscope == TEXTSCOPE_INCLUDE)
                    break;
                if (phpc->_textscope == TEXTSCOPE_EXCLUDE)
                {
                    iReturnCode = UNSTABLE_TEXTSCOPE;
                    goto Conflict;
                }
            }

            cpTotal += cch;
            iRun++;
            break;
        case CTreePos::Pointer:
            // make sure the tree pointer is not inside inclusion
			if (cInclusion)
			{
				Assert (0 && "We have an illegal tree pointer");
				iReturnCode = UNSTABLE_MARKUPPOINTER;
				goto Conflict;
			}
            break;
        }

        hr = THR_NOTRACE( tpgWalker.Move() );
    }
    while (!hr);

    if (cInclusion)
    {
        Assert (FALSE && "The tree is totaly not safe");
        iReturnCode = UNSTABLE_TREE;
        goto Conflict;
    }

    // TODO: we don't walk past the last element for now, it will change with ericvas checkin
    Assert (aryScopeNodes.Size() == 1 && aryScopeNodes[0]->Tag() == ETAG_BODY);

  }

Conflict:
#ifdef NEVER
#if DBG == 1
    if (iReturnCode)
    {
        AssertSz(0, gs_unstable[iReturnCode]);
    }
#endif
#endif
    return iReturnCode;

}

#endif //MARKUP_STABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\treenode.cxx ===
//+---------------------------------------------------------------------
//
//  File:       brptr.cxx
//
//  Contents:   CTreeNode class implementation
//
//  Classes:    CTreeNode
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

MtDefine(CTreeNode, Tree, "CTreeNode")
MtDefine(CTreeNodeCLock, Locals, "CTreeNode::CLock")

#if DBG == 1 || defined(DUMPTREE)
int CTreeNode::s_NextSerialNumber = 0;
int s_nSNTrace = -1;
#endif

extern BOOL IsPreLikeTag(ELEMENT_TAG eTag);


CTreeNode::CTreeNode ( CTreeNode * pParent, CElement * pElement /* = NULL */ )
#if DBG == 1 || defined(DUMPTREE)
            : _nSerialNumber( s_NextSerialNumber++ )
#endif
{
    Assert( _pNodeParent == NULL);
    Assert( _pElement == NULL);

    _iFF = _iCF = _iPF = -1;

    SetElement( pElement );
    SetParent( pParent );

    Assert( pElement && pElement->Doc() && pElement->Doc()->AreLookasidesClear( this, LOOKASIDE_NODE_NUMBER ) );

    SetPre(pElement ? IsPreLikeTag(Tag()) : FALSE);
    
}

#if DBG == 1
CTreeNode::~CTreeNode()
{
    Assert( _fInDestructor );
    Assert( IsDead() );
    Assert( _iCF == -1 && _iPF == -1 && _iFF == -1 );
    Assert( !_pNodeParent );
    Assert( _iCF == -1 && _iPF == -1 && _iFF == -1 );
    Assert( !HasPrimaryTearoff() );
    Assert( !HasCurrentStyle() );
}
#endif

CTreeNode *
CTreeNode::NextBranch()
{
    Assert( IsInMarkup() );

    CTreePos * ptpCurr = GetEndPos();

    if( ptpCurr->IsEdgeScope() )
        return NULL;
    else
    {
        CElement *  pElement = Element();
        CTreeNode * pNodeCurr;

        do
        {
            ptpCurr = ptpCurr->NextTreePos();

            Assert( ptpCurr->IsNode() );

            pNodeCurr = ptpCurr->Branch();
        }
        while( pNodeCurr->Element() != pElement );

        return pNodeCurr;
    }
}

CTreeNode *
CTreeNode::ParanoidNextBranch()
{
    Assert( IsInMarkup() );

    CTreePos * ptpCurr = GetEndPos();

    if( ptpCurr->IsEdgeScope() )
        return NULL;
    else
    {
        CElement *  pElement = Element();
        CTreeNode * pNodeCurr;

        if (!pElement)
            return NULL;

        do
        {
            ptpCurr = ptpCurr->NextTreePos();

            Assert( ptpCurr && ptpCurr->IsNode() );

            if (!ptpCurr || !ptpCurr->IsNode())
                return NULL;

            pNodeCurr = ptpCurr->Branch();

            if (!pNodeCurr)
                return NULL;
        }
        while( pNodeCurr->Element() != pElement );

        return pNodeCurr;
    }
}

CTreeNode *
CTreeNode::PreviousBranch()
{
    Assert( IsInMarkup() );

    CTreePos * ptpCurr = GetBeginPos();

    if( ptpCurr->IsEdgeScope() )
        return NULL;
    else
    {
        CElement *  pElement = Element();
        CTreeNode * pNodeCurr;

        do
        {
            ptpCurr = ptpCurr->PreviousTreePos();

            Assert( ptpCurr->IsNode() );

            pNodeCurr = ptpCurr->Branch();
        }
        while( pNodeCurr->Element() != pElement );

        return pNodeCurr;
    }
}

CTreeNode *
CTreeNode::Ancestor (const ELEMENT_TAG *arytag)
{
    CTreeNode * context = this;
    ELEMENT_TAG etag;
    const ELEMENT_TAG *petag;

    while (context)
    {
        etag = context->Tag();

        for (petag = arytag; *petag; petag++)
        {
            if (etag == *petag)
                return context;
        }

        context = context->Parent();
    }

    return context; // NULL context
}

CTreeNode *
CTreeNode::GetContainerBranch()
{
    CTreeNode *pNode = this;

    for (   ; 
            pNode;
            pNode = pNode->Element()->HasMasterPtr() ?
                pNode->Element()->GetMasterPtr()->GetFirstBranch() :
                pNode->Parent() )
    {
        if (pNode->IsContainer())
            break;
    }

    return pNode;
}

BOOL
CTreeNode::SupportsHtml()
{
    // see if behaviour set default canHaveHTML
    CDefaults *pDefaults = Element()->GetDefaults();
    VARIANT_BOOL fSupportsHTML;
    if (pDefaults && pDefaults->GetAAcanHaveHTML(&fSupportsHTML))
        return !!fSupportsHTML;
    else
    {
        CElement * pContainer = GetContainer();
        return ( pContainer && pContainer->HasFlag( TAGDESC_ACCEPTHTML ) );
    }
}

//+---------------------------------------------------------------------------
//
// CTreeNode::RenderParent()
// CTreeNode::ZParent()
// CTreeNode::ClipParent()
//
// Parent accessor methods used for positioning support.
//
// The following chart defines the different parents that are used for
// positioning.  Each parent determines different parameters for any
// relatively positioned or absolutely positioned element.
//
//     PARENT        RELATIVE            ABSOLUTE               PARENT TYPE       USED IN
//     ------        --------            --------               -----------       -------
//
//  "ElementParent"  Coordinates       Not meaningful             Element         GetRenderPosition/PositionObjects (implicit)
//
//  "ParentSite"           Percent/Auto/CalcSize (both)             Site          Measuring (implicit)
//
//  "RenderParent"                Painting (both)                   Site          GetSiteDrawList/HitTestPoint
//
//  "ZParent"        Z-Order            Z-Order/Coordinates    Element or Site    GetElementsInZOrder/GetRenderPosition
//
//  "Clip Parent"  Clip Rect/Auto/SetPos   Clip Rect/SetPos     Absolute Site     SetPosition/PositionObjects
//
//
//  If the ZParent is a site, then it is the same as the RenderParent.
//
//----------------------------------------------------------------------------

CTreeNode *
CTreeNode::ZParentBranch()
{
    CTreeNode * pNode;

    Assert(this);

    if (Element()->IsPositionStatic() && !GetCharFormat()->_fRelative)
    {
        return GetUpdatedParentLayoutNode();
    }
   
    // start with the master if one exists
    if (Element()->HasMasterPtr())
    {
        pNode = Element()->GetMasterPtr()->GetFirstBranch();
    }
    else
    {
        pNode = this;
    }
          
    // walk up the tree until we find a ZParent
    while ( (pNode = pNode->Parent()) != NULL)
    {
        if (pNode->Element()->HasMasterPtr())
        {
            pNode = pNode->Element()->GetMasterPtr()->GetFirstBranch();          
        }
        
        if (!pNode || pNode->Element()->IsZParent())
            break;               
    }
                
    //
    // If pNode is NULL then 'this' is the BODY or this node is not parented
    //   into the main document tree.  Return the body branch for the first
    //   case and NULL for the second.
    //
    return pNode
             ? pNode
    //  We always return the BODY as its own ZParent... but we don't do this for the frameset.
    //  In HTML Layout, this is even more suspect...
    //  It looks as if commenting out the special case for the BODY is safe.
    //  9/15/00 (greglett) (dmitryt)
    //         : ((Tag() == ETAG_BODY)
    //              ? this
                  : NULL;
}

CTreeNode *
CTreeNode::RenderParentBranch()
{
    CTreeNode * pNode;

    if (Element()->IsPositionStatic())
    {
        return GetUpdatedParentLayoutNode();
    }


    pNode = this;
    if (pNode)
    {
        pNode = pNode->Parent();
    }
    for (;
         pNode;
         pNode = pNode->Parent())
    {
        if (pNode->ShouldHaveLayout() && pNode->Element()->IsZParent())
        {
            break;
        }
    }

    return pNode
             ? pNode
             : ((Tag() == ETAG_BODY)
                  ? this
                  : NULL);
}

CTreeNode *
CTreeNode::ClipParentBranch()
{
    CTreeNode * pNode;

    if (Element()->IsPositionStatic())
    {
        return GetUpdatedParentLayoutNode();
    }

    pNode = this;
    if (pNode)
    {
        pNode = pNode->Parent();
    }
    for (;
         pNode;
         pNode = pNode->Parent())
    {
        if (pNode->ShouldHaveLayout() && pNode->Element()->IsClipParent())
        {
            break;
        }
    }

    Assert(pNode);

    return pNode;
}

CTreeNode *
CTreeNode::ScrollingParentBranch()
{
    CTreeNode * pNode = NULL;

    if (Parent())
    {
        pNode = GetUpdatedParentLayoutNode();

        for (;
             pNode;
             pNode = pNode->GetUpdatedParentLayoutNode())
        {
            if (pNode->Element()->IsScrollingParent())
                break;
        }
    }

    return pNode;
}


//+----------------------------------------------------------------------------
//
// Member:      GetCascadedbackgroundColor
//
// Synopsis:    Return the background color of the element
//
//-----------------------------------------------------------------------------

CColorValue
CTreeNode::GetCascadedbackgroundColor(FORMAT_CONTEXT FCPARAM)
{
    return (CColorValue) CTreeNode::GetFancyFormat(FCPARAM)->_ccvBackColor;
}


// The following function is used by CTxtRange::GetExtendedSelectionInfo

CTreeNode *
CTreeNode::SearchBranchForPureBlockElement ( CFlowLayout * pFlowLayout )
{
    return pFlowLayout->GetContentMarkup()->SearchBranchForBlockElement( this, pFlowLayout );
}

//+----------------------------------------------------------------------------
//
//  Member:     CTreeNode::SearchBranchToFlowLayoutForTag
//
//  Synopsis:   Looks up the parent chain for the first element which
//              matches the tag.  No stopper element here, but stops
//              at the first text site it encounters.
//
//-----------------------------------------------------------------------------

CTreeNode *
CTreeNode::SearchBranchToFlowLayoutForTag ( ELEMENT_TAG etag )
{
    CTreeNode * pNode = this;

    do
    {
        if (pNode->Tag() == etag)
            return pNode;

        pNode = pNode->Parent();
    }
    while (pNode && !pNode->HasFlowLayout(GUL_USEFIRSTLAYOUT));

    return NULL;
}

//+-----------------------------------------------------
//
//  Member  : GetFontHeightInTwips
//
//  Sysnopsis : helper function that returns the base font
//          height in twips. by default this will return 1
//
//          for now only EMs are wired up to the point that
//          it makes sense to pass through fontsize.
//--------------------------------------------------------

long
CTreeNode::GetFontHeightInTwips(const CUnitValue * pCuv)
{
    long lFontHeight = 1;

    if (  pCuv->GetUnitType() == CUnitValue::UNIT_EM 
       || pCuv->GetUnitType() == CUnitValue::UNIT_EX)
    {
        const CCharFormat * pCF = GetCharFormat();
        if (pCF)
        {
            lFontHeight = pCF->GetHeightInTwips(Doc());
        }
    }

    return lFontHeight;
}

//+----------------------------------------------------------------------------
//
//  Member:     CTreeNode::SearchBranchToRootForScope
//
//  Synopsis:   Looks up the parent chain for the first element which
//              has the same scope as the given element.  Will not stop
//              until there is no parent.
//
//-----------------------------------------------------------------------------

CTreeNode *
CTreeNode::SearchBranchToRootForScope( CElement * pElementFindMe )
{
    CTreeNode * pNode = this;

    do
    {
        if (pNode->Element() == pElementFindMe)
            return pNode;
    }
    while ( (pNode = pNode->Parent()) != NULL );

    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CTreeNode::SearchBranchToRootForNode
//
//  Synopsis:   Looks up the parent chain for the given element. Will not stop
//              until there is no parent.
//
//-----------------------------------------------------------------------------

BOOL
CTreeNode::SearchBranchToRootForNode( CTreeNode * pNodeFindMe )
{
    CTreeNode * pNode = this;

    do
    {
        if (pNode == pNodeFindMe)
            return TRUE;
    }
    while ( (pNode = pNode->Parent()) != NULL );

    return FALSE;
}
//+----------------------------------------------------------------------------
//
//  Member:     CElement::SearchBranchToRootForTag
//
//  Synopsis:   Looks up the parent chain for the first element which
//              matches the tag.  No stopper element here, goes all the
//              way up to the <HTML> tag.
//
//-----------------------------------------------------------------------------

CTreeNode *
CTreeNode::SearchBranchToRootForTag ( ELEMENT_TAG etag )
{
    CTreeNode * pNode = this;

    do
    {
        if (pNode->Tag() == etag)
            return pNode;
    }
    while ( (pNode = pNode->Parent()) != NULL );

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTreeNode::GetFirstCommonAncestor, public
//
//  Synopsis:   Returns the first branch whose element is common to
//              both of the branches specified.
//
//  Arguments:  [pNode] -- branch to find common parent of with [this]
//              [pEltStop]  -- Stop walking tree if you hit this element.
//                             If NULL then search to root.
//
//  Returns:    Branch with common element from first starting point.
//
//----------------------------------------------------------------------------

CTreeNode *
CTreeNode::GetFirstCommonAncestor(CTreeNode * pNodeTwo, CElement* pEltStop)
{
    CTreeNode * pNode;
    CElement * pElement;

    if( pNodeTwo->Element() == Element() )
        return this;

    for ( pNode = this; pNode; pNode = pNode->Parent() )
    {
        pElement = pNode->Element();

        pElement->_fFirstCommonAncestor = 0;

        if (pElement == pEltStop)
            break;
    }

    for ( pNode = pNodeTwo; pNode; pNode = pNode->Parent() )
    {
        pElement = pNode->Element();

        pElement->_fFirstCommonAncestor = 1;

        if (pElement == pEltStop)
            break;
    }

    for ( pNode = this; pNode; pNode = pNode->Parent() )
    {
        pElement = pNode->Element();

        if (pElement->_fFirstCommonAncestor)
            return pNode;

        Assert( pElement != pEltStop );
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTreeNode::GetFirstCommonBlockOrLayoutAncestor, public
//
//  Synopsis:   Returns the first branch whose element is common to
//              both of the branches specified and is a block or layout element
//
//  Arguments:  [pNode] -- branch to find common parent of with [this]
//              [pEltStop]  -- Stop walking tree if you hit this element.
//                             If NULL then search to root.
//
//  Returns:    Branch with common element from first starting point.
//
//----------------------------------------------------------------------------

CTreeNode *
CTreeNode::GetFirstCommonBlockOrLayoutAncestor(CTreeNode * pNodeTwo, CElement* pEltStop)
{
    CTreeNode * pNode;
    CElement * pElement;

    if( pNodeTwo->Element() == Element() )
        return this;

    for ( pNode = this; pNode; pNode = pNode->Parent() )
    {
        pElement = pNode->Element();

        pElement->_fFirstCommonAncestor = 0;

        if (pElement == pEltStop)
            break;
    }

    for ( pNode = pNodeTwo; pNode; pNode = pNode->Parent() )
    {
        pElement = pNode->Element();

        pElement->_fFirstCommonAncestor = 1;

        if (pElement == pEltStop)
            break;
    }

    for ( pNode = this; pNode; pNode = pNode->Parent() )
    {
        pElement = pNode->Element();

        if ((pElement->ShouldHaveLayout() || pElement->IsBlockElement())
            && pElement->_fFirstCommonAncestor)
        {
            return pNode;
        }

        Assert( pElement != pEltStop );
    }

    return NULL;
}
//+---------------------------------------------------------------------------
//
//  Member:     CTreeNode::GetFirstCommonAncestorNode, public
//
//  Synopsis:   Returns the first node that is common to
//              both of the branches specified.
//
//  Arguments:  [pNode] -- branch to find common parent of with [this]
//              [pEltStop]  -- Stop walking tree if you hit this element.
//                             If NULL then search to root.
//
//  Returns:    Branch with common node from first starting point.
//
//----------------------------------------------------------------------------

CTreeNode *
CTreeNode::GetFirstCommonAncestorNode(CTreeNode * pNodeTwo, CElement* pEltStop)
{
    CTreeNode * pNode;

    if( this == pNodeTwo )
        return this;

    for ( pNode = this; pNode; pNode = pNode->Parent() )
    {
        pNode->_fFirstCommonAncestorNode = 0;

        if (pNode->Element() == pEltStop)
            break;
    }

    for ( pNode = pNodeTwo; pNode; pNode = pNode->Parent() )
    {
        pNode->_fFirstCommonAncestorNode = 1;

        if (pNode->Element() == pEltStop)
            break;
    }

    for ( pNode = this; pNode; pNode = pNode->Parent() )
    {
        if (pNode->_fFirstCommonAncestorNode)
            return pNode;

        Assert( pNode->Element() != pEltStop );
    }

    return NULL;
}


//+------------------------------------------------------------------------
//
//  Member:     CTreeNode::Depth
//
//  Synopsis:   Finds the depth of the node in the html tree
//
//  Returns:    int
//
//-------------------------------------------------------------------------

int
CTreeNode::Depth() const
{
    CTreeNode * pNode = const_cast<CTreeNode *>(this);
    int nDepth = 0;

    while ( pNode)
        nDepth++, pNode = pNode->Parent();

    Assert( nDepth > 0);

    return nDepth;
}


BEGIN_TEAROFF_TABLE_NAMED(CTreeNode, s_apfnNodeVTable)
    TEAROFF_METHOD(CTreeNode, GetInterface, getinterface, (REFIID riid, void **ppv))
    TEAROFF_METHOD_(CTreeNode, PutRef, putref, ULONG, ())
    TEAROFF_METHOD_(CTreeNode, RemoveRef, removeref, ULONG, ())
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
    TEAROFF_METHOD_NULL
END_TEAROFF_TABLE()

//+---------------------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
CTreeNode::GetInterface(REFIID iid, void **ppv)
{
    void *  pv = NULL;
    void *  pvWhack;
    void *  apfnWhack;
    HRESULT hr = E_NOINTERFACE;
    BOOL    fReuseTearoff = FALSE;
    const IID * piidDisp;

    *ppv = NULL;

    AssertSz( _pElement, "_pElement is NULL in CTreeNode::GetInterface -- VERY BAD!!!" );

    // handle IUnknown when tearoff is already created
    if (iid == IID_IUnknown && HasPrimaryTearoff())
    {
        IUnknown * pTearoff;

        pTearoff = GetPrimaryTearoff();

        Assert( pTearoff );

        pTearoff->AddRef();

        *ppv = pTearoff;

        return S_OK;
    }

    if (iid == CLSID_CTreeNode)
    {
        *ppv = this;
        return S_OK;
    }
    else if (iid == CLSID_CElement  ||
             iid == CLSID_CTextSite )
    {
        return _pElement->QueryInterface( iid, ppv );
    }

    // Create a tearoff to return

    // Get the interface from the element
    hr = THR_NOTRACE(_pElement->PrivateQueryInterface(iid, &pv));
    if(hr)
    {
        pv = NULL;
        goto Cleanup;
    }

    //
    // Whack in our node information, or the primary tearoff
    //
    if( HasPrimaryTearoff() )
    {
        pvWhack = (void*)GetPrimaryTearoff();
        Assert( pvWhack );
        apfnWhack = *(void**)pvWhack;
    }
    else
    {
        pvWhack = this;
        apfnWhack = (void*)s_apfnNodeVTable;
    }

#if DBG==1
    if( !HasPrimaryTearoff() )
        _fSettingTearoff = TRUE;
#endif

    Assert( apfnWhack );

    // InstallTearOffObject puts a pointer to an object
    // into pvObject2 of the tearoff.  This means that we
    // are assuming that when an element is QI'd, the interfaces
    // listed below will be returned as tearoffs.  Also, every
    // interface that uses the eax trick for passing context
    // through must be in this list.  Otherwise we will
    // create another tearoff pointing to the tearoff.
    //

    piidDisp = _pElement->BaseDesc()->_piidDispinterface;
    piidDisp = piidDisp ? piidDisp : &IID_NULL;

    if(iid == *piidDisp                 ||
       iid == IID_IHTMLElement          ||
       iid == IID_IDispatch             ||
       iid == IID_IDispatchEx           ||
       iid == IID_IHTMLControlElement)
    {
        hr = THR(InstallTearOffObject(pv, pvWhack,
                    apfnWhack, QI_MASK));
        if(hr)
            goto Cleanup;

        *ppv = pv;

        fReuseTearoff = TRUE;
    }
    else
    {
        hr = THR(
            CreateTearOffThunk(
                pv, * (void **) pv, NULL, ppv, pvWhack,
                apfnWhack, QI_MASK, NULL ));
        ((IUnknown *)pv)->Release();
        pv = NULL;
        if(hr)
            goto Cleanup;
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    if( ! HasPrimaryTearoff() )
    {
        // This tearoff that we just created is now the primary tearoff
        SetPrimaryTearoff( (IUnknown *)*ppv );
        WHEN_DBG( _fSettingTearoff = FALSE );
    }

    if(!fReuseTearoff)
        ((IUnknown *)*ppv)->AddRef();

    hr = S_OK;

Cleanup:
    if(hr && pv)
        ((IUnknown *)pv)->Release();

    RRETURN( hr );
}


ULONG
CTreeNode::PutRef(void)
{
#if DBG==1
    if (s_nSNTrace == _nSerialNumber)
    {
        TraceTag((0, "treenode %d PutRef", _nSerialNumber));
        TraceCallers(0, 0, 12);
    }
#endif

    Assert( ! _fInDestructor );
    Assert( _fSettingTearoff );
    Assert( ! HasPrimaryTearoff() );

    // We do this so that we know that the node will
    // die before the element.  If it was the other way
    // around, we wouldn't be able to get to the doc to
    // del our primary tearoff lookaside pointer
    Element()->AddRef();

    return 1;
}

ULONG
CTreeNode::RemoveRef(void)
{
    CElement * pElement = Element();

#if DBG==1
    if (s_nSNTrace == _nSerialNumber)
    {
        TraceTag((0, "treenode %d RemoveRef", _nSerialNumber));
        TraceCallers(0, 0, 12);
    }
#endif

    Assert( !_fInDestructor );
    Assert( HasPrimaryTearoff() );

    DelPrimaryTearoff();

    if (!_fInMarkup)
    {
        WHEN_DBG( _fInDestructor = TRUE );
        delete this;
    }

    // Release the ref that we put on the element above.
    pElement->Release();

    return 1;
}

HRESULT
CTreeNode::NodeAddRef(void)
{
    HRESULT hr = S_OK;
    IUnknown *pTearoff = NULL;

#if DBG==1
    if (s_nSNTrace == _nSerialNumber)
    {
        TraceTag((0, "treenode %d NodeAddRef", _nSerialNumber));
        TraceCallers(0, 0, 12);
    }
#endif

    Assert( ! _fInDestructor );

    if( ! HasPrimaryTearoff() )
    {
        // Use GetInterface to create the primary interface
        hr = THR( GetInterface( IID_IUnknown, (void**)&pTearoff ) );

        return hr;
    }
    else
    {
        pTearoff = GetPrimaryTearoff();

        Assert( pTearoff );
        pTearoff->AddRef();

        return S_OK;
    }
}

ULONG
CTreeNode::NodeRelease(void)
{
    IUnknown *pTearoff;

#if DBG==1
    if (s_nSNTrace == _nSerialNumber)
    {
        TraceTag((0, "treenode %d ReleaseRef", _nSerialNumber));
        TraceCallers(0, 0, 12);
    }
#endif

    Assert( !_fInDestructor );
    Assert( HasPrimaryTearoff() );

    pTearoff = GetPrimaryTearoff();

    Assert( pTearoff );

    return pTearoff->Release();

}

//
// Ref counting helpers
//

HRESULT
CTreeNode::ReplacePtr      ( CTreeNode * * ppNodelhs, CTreeNode * pNoderhs )
{
    HRESULT hr = S_OK;

    if (ppNodelhs)
    {
        CTreeNode * pNodelhsLocal = *ppNodelhs;
        if (pNoderhs)
        {
            hr = THR( pNoderhs->NodeAddRef() );
            if( hr )
                goto Cleanup;
        }
        *ppNodelhs = pNoderhs;
        if (pNodelhsLocal)
        {
            pNodelhsLocal->NodeRelease();
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CTreeNode::SetPtr          ( CTreeNode * * pbrlhs, CTreeNode * brrhs )
{
    HRESULT hr = S_OK;

    if (pbrlhs)
    {
        if (brrhs)
        {
            hr = THR( brrhs->NodeAddRef() );
            if( hr )
                goto Cleanup;
        }
        *pbrlhs = brrhs;
    }

Cleanup:
    RRETURN( hr );
}

void
CTreeNode::ClearPtr        ( CTreeNode * * pbrlhs )
{
    if (pbrlhs && * pbrlhs)
    {
        CTreeNode * pNode = *pbrlhs;
        *pbrlhs = NULL;
        pNode->NodeRelease();
    }
}

void
CTreeNode::ReleasePtr        ( CTreeNode * pNode )
{
    if (pNode)
    {
        pNode->NodeRelease();
    }
}

void
CTreeNode::StealPtrSet     ( CTreeNode * * pbrlhs, CTreeNode * brrhs )
{
    SetPtr( pbrlhs, brrhs );

    if (pbrlhs && *pbrlhs)
        (*pbrlhs)->NodeRelease();
}

HRESULT
CTreeNode::StealPtrReplace ( CTreeNode * * pbrlhs, CTreeNode * brrhs )
{
    HRESULT hr;

    hr = THR( ReplacePtr( pbrlhs, brrhs ) );
    if( hr )
        goto Cleanup;

    if (pbrlhs && *pbrlhs)
        (*pbrlhs)->NodeRelease();

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Lookaside storage
//
//----------------------------------------------------------------------------

void *
CTreeNode::GetLookasidePtr(int iPtr)
{
#if DBG == 1
    Assert( Doc() );
    if(HasLookasidePtr(iPtr))
    {
        void * pLookasidePtr =  Doc()->GetLookasidePtr((DWORD *)this + iPtr);

        Assert(pLookasidePtr == _apLookAside[iPtr]);

        return pLookasidePtr;
    }
    else
        return NULL;
#else
    return(HasLookasidePtr(iPtr) ? Doc()->GetLookasidePtr((DWORD *)this + iPtr) : NULL);
#endif
}

HRESULT
CTreeNode::SetLookasidePtr(int iPtr, void * pvVal)
{
    Assert( Doc() );
    Assert (!HasLookasidePtr(iPtr) && "Can't set lookaside ptr when the previous ptr is not cleared");

    HRESULT hr = THR(Doc()->SetLookasidePtr((DWORD *)this + iPtr, pvVal));

    if (hr == S_OK)
    {
        _fHasLookasidePtr |= 1 << iPtr;

#if DBG == 1
        _apLookAside[iPtr] = pvVal;
#endif
    }

    RRETURN(hr);
}

void *
CTreeNode::DelLookasidePtr(int iPtr)
{
    Assert( Doc() );
    if (HasLookasidePtr(iPtr))
    {
        void * pvVal = Doc()->DelLookasidePtr((DWORD *)this + iPtr);
        _fHasLookasidePtr &= ~(1 << iPtr);
#if DBG == 1
        _apLookAside[iPtr] = NULL;
#endif
        return(pvVal);
    }

    return(NULL);
}


//+----------------------------------------------------------------------------
//
// Member:      ConvertFmToCSSBorderStyle
//
// Synopsis:    Converts the border style from the internal type to the type
//                  used to set it.
//-----------------------------------------------------------------------------

styleBorderStyle
ConvertFmToCSSBorderStyle(BYTE bFmBorderStyle)
{
    switch ( bFmBorderStyle )
    {
    case fmBorderStyleDotted:
        return styleBorderStyleDotted;
    case fmBorderStyleDashed:
        return styleBorderStyleDashed;
    case fmBorderStyleDouble:
        return styleBorderStyleDouble;
    case fmBorderStyleSingle:
        return styleBorderStyleSolid;
    case fmBorderStyleEtched:
        return styleBorderStyleGroove;
    case fmBorderStyleBump:
        return styleBorderStyleRidge;

    case fmBorderStyleSunkenMono:
    case fmBorderStyleSunken:
        return styleBorderStyleInset;

    case fmBorderStyleRaisedMono:
    case fmBorderStyleRaised:
        return styleBorderStyleOutset;

    case fmBorderStyleWindowInset:
        return styleBorderStyleWindowInset;
    case fmBorderStyleNone:
        return styleBorderStyleNone;
    case 0xff:
        return styleBorderStyleNotSet;
    }

    Assert( FALSE && "Unknown Border Style!" );
    return styleBorderStyleNotSet;
}


//+----------------------------------------------------------------------------
//
// Member:      GetCascadedborderTopStyle
//
// Synopsis:    Return the top border style value for the node
//
//-----------------------------------------------------------------------------

styleBorderStyle
CTreeNode::GetCascadedborderTopStyle(FORMAT_CONTEXT FCPARAM)
{
    const CFancyFormat *pFF = GetFancyFormat(FCPARAM);
    Assert(pFF);
    return ConvertFmToCSSBorderStyle(pFF->_bd.GetBorderStyle(SIDE_TOP));
}


//+----------------------------------------------------------------------------
//
// Member:      GetCascadedborderRightStyle
//
// Synopsis:    Return the right border style value for the node
//
//-----------------------------------------------------------------------------

styleBorderStyle
CTreeNode::GetCascadedborderRightStyle(FORMAT_CONTEXT FCPARAM)
{
    const CFancyFormat *pFF = GetFancyFormat(FCPARAM);
    Assert(pFF);
    return ConvertFmToCSSBorderStyle(pFF->_bd.GetBorderStyle(SIDE_RIGHT));
}


//+----------------------------------------------------------------------------
//
// Member:      GetCascadedborderBottomStyle
//
// Synopsis:    Return the bottom border style value for the node
//
//-----------------------------------------------------------------------------

styleBorderStyle
CTreeNode::GetCascadedborderBottomStyle(FORMAT_CONTEXT FCPARAM)
{
    const CFancyFormat *pFF = GetFancyFormat(FCPARAM);
    Assert(pFF);
    return ConvertFmToCSSBorderStyle(pFF->_bd.GetBorderStyle(SIDE_BOTTOM));
}


//+----------------------------------------------------------------------------
//
// Member:      GetCascadedborderLeftStyle
//
// Synopsis:    Return the left border style value for the node
//
//-----------------------------------------------------------------------------

styleBorderStyle
CTreeNode::GetCascadedborderLeftStyle(FORMAT_CONTEXT FCPARAM)
{
    const CFancyFormat *pFF = GetFancyFormat(FCPARAM);
    Assert(pFF);
    return ConvertFmToCSSBorderStyle(pFF->_bd.GetBorderStyle(SIDE_LEFT));
}



//+----------------------------------------------------------------------------
//
// Member:      GetCascadedclearLeft
//
// Synopsis:
//
//-----------------------------------------------------------------------------

BOOL
CTreeNode::GetCascadedclearLeft(FORMAT_CONTEXT FCPARAM)
{
    return !!GetFancyFormat(FCPARAM)->_fClearLeft;
}


//+----------------------------------------------------------------------------
//
// Member:      GetCascadedclearRight
//
// Synopsis:
//
//-----------------------------------------------------------------------------

BOOL
CTreeNode::GetCascadedclearRight(FORMAT_CONTEXT FCPARAM)
{
    return !!GetFancyFormat(FCPARAM)->_fClearRight;
}



//+------------------------------------------------------------------------
//
//  Member:     CTreeNode::IsInlinedElement
//
//  Synopsis:   Determines if the element is rendered inflow or not, If the
//              element is not absolutely positioned and is left or right
//              aligned with hr and legend an exception (they can only be
//              aligned but nothing should wrap around them).
//              For non-sites we return TRUE.
//
//  Returns:    BOOL indicating whether or not the site is inlined
//
//-------------------------------------------------------------------------

BOOL
CTreeNode::IsInlinedElement ( FORMAT_CONTEXT FCPARAM )
{
    if (ShouldHaveLayout(FCPARAM))
    {
        const CFancyFormat * pFF = GetFancyFormat(FCPARAM);

        return      pFF->_bPositionType != stylePositionabsolute
                &&  !pFF->_fAlignedLayout;
    }

    return TRUE;
}

void
CTreeNode::GetRelTopLeft(
    CElement    * pElementFL,
    CParentInfo * ppi,
    long * pxRelLeft,
    long * pyRelTop)
{
    CTreeNode * pNode = this;
    CDoc      * pDoc = pElementFL->Doc();
    long        lFontHeight;
    const CCharFormat  * pCF;
    const CFancyFormat * pFF;
    const CCharFormat *pCFFL = pElementFL->GetFirstBranch()->GetCharFormat(); 
    BOOL fElementFLVertical = pCFFL->HasVerticalLayoutFlow();

    Assert(pyRelTop && pxRelLeft);

    *pyRelTop = 0;
    *pxRelLeft = 0;

    while(pNode && pNode->Element() != pElementFL)
    {
        pCF = pNode->GetCharFormat();

        if(!pCF->_fRelative)
            break;

        lFontHeight = pCF->GetHeightInTwips(pDoc);
        pFF = pNode->GetFancyFormat();

        if(pFF->_fRelative)
        {
            *pyRelTop  += pFF->GetLogicalPosition(SIDE_TOP, fElementFLVertical, pCF->_fWritingModeUsed).YGetPixelValue(ppi, ppi->_sizeParent.cy, lFontHeight);
            *pxRelLeft += pFF->GetLogicalPosition(SIDE_LEFT, fElementFLVertical, pCF->_fWritingModeUsed).XGetPixelValue(ppi, ppi->_sizeParent.cx, lFontHeight);
        }

        pNode = pNode->Parent();
    }
}

//+----------------------------------------------------------------------------
//
// Member:      GetCurrentRelativeNode
//
// Synopsis:    Get the node that is relative, which causes the current
//              chunk to be relative.
//
//-----------------------------------------------------------------------------
CTreeNode *
CTreeNode::GetCurrentRelativeNode(CElement * pElementFL)
{
    const CFancyFormat * pFF;
    CTreeNode * pNodeStart = this;

    while(pNodeStart && DifferentScope(pElementFL, pNodeStart))
    {
        pFF = pNodeStart->GetFancyFormat();

        // TODO (jbeda): I'm pretty sure this is wrong for some
        // overlapped cases

        // relatively positioned layout elements are to be ignored
        if(!pNodeStart->Element()->ShouldHaveLayout() && pFF->_fRelative)
            return pNodeStart;

        pNodeStart = pNodeStart->Parent();
    }
    return NULL;
}

//+----------------------------------------------------------------------------
//
// Member:      EnsureFormats
//
// Synopsis:    Compute the formats if dirty
//
//-----------------------------------------------------------------------------
void
CTreeNode::EnsureFormats( FORMAT_CONTEXT FCPARAM )
{
    
    if (_iCF < 0)
    {
        GetCharFormatHelper( FCPARAM );
    }
    if (_iPF < 0)
    {
        GetParaFormatHelper( FCPARAM );
    }
    if (_iFF < 0)
    {
        GetFancyFormatHelper( FCPARAM );
    }

    if (Element()->HasSlavePtr())
    {
        Element()->GetSlavePtr()->GetMarkup()->EnsureFormats( FCPARAM );
    }

}

//----------------------------------------------------------------------------
//  Walks the parent markup chain for a tree node, until it finds the ancestor
//  tree node that lives in the markup that is passed.
//
//  This is needed for multiframe hittesting scenarios and alike, where you have
//  a node in a sub markup, and you want to find the element/node that actually
//  is the parent of that tree in a given markup.
// 
//  May return NULL if the markup given is not in the parent chain of the node given
//---------------------------------------------------------------------------- 
CTreeNode*
CTreeNode::GetNodeInMarkup(CMarkup * pMarkup)
{
    CTreeNode * pNode = this;
    CElement *  pElemRoot;

    while (pNode)
    {
        // if we have reached a node without a markup, return NULL.
        if (!pNode->IsInMarkup())
            return NULL;

        // The node is in a markup. Check if it is the markup
        // we are looking for. If not, continue climbing.
        if (pNode->GetMarkup() == pMarkup)
            break;
        else
        {
            pElemRoot = pNode->GetMarkup()->Root();

            if (!pElemRoot->HasMasterPtr())
                return NULL;

            // Get the node for the master element.
            pNode = pElemRoot->GetMasterPtr()->GetFirstBranch();
        }
    }

    return pNode;
}

BOOL
CTreeNode::IsConnectedToPrimaryMarkup()
{
    return IsConnectedToThisMarkup(Doc()->PrimaryMarkup());
}

//----------------------------------------------------------------------------
//  Walks the parent/master chain for a tree node to determine if the node
//  is in the view. 
//---------------------------------------------------------------------------- 
BOOL
CTreeNode::IsInViewTree()
{
    CTreeNode * pNode = this;
    CTreeNode * pNodePrimaryRoot    = Doc()->PrimaryMarkup()->RootNode();

    Assert(pNode);
    Assert(pNodePrimaryRoot);

    //Fix for IE6 33880. If this markup is going out of viewlink relationship
    //(we are sending ExitView notification SetViewSlave) -- it's not
    // considered to be in view tree.
    if(!IsInMarkup() || GetMarkup()->_fSlaveInExitView)
        return FALSE;

    while (pNode != pNodePrimaryRoot)
    {
        CTreeNode * pNodeParent = pNode->Parent();

        if (pNodeParent)
        {
            // I am not in view, if my parent has a slave
            if (pNodeParent->Element()->HasSlavePtr())
                return FALSE;
            pNode = pNodeParent;
        }
        else
        {
            CElement *  pElem   = pNode->Element();

            Assert(pElem->Tag() == ETAG_ROOT);
            if (!pElem->HasMasterPtr())
                return FALSE;
            pNode = pElem->GetMasterPtr()->GetFirstBranch();
            if (!pNode)
                return FALSE;
        }
    }
    return TRUE;
}

BOOL
CTreeNode::IsEditable(BOOL fCheckContainerOnly /*=FALSE*/ FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    return (fCheckContainerOnly ? IsParentEditable(FCPARAM) : GetEditable(FCPARAM));
}

BOOL
CTreeNode::IsParentEditable(FORMAT_CONTEXT FCPARAM)
{
    CTreeNode* pParent = Parent() ;
    return (pParent && pParent->GetEditable(FCPARAM));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\tempfile.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#include "tempfile.hxx"
#include <wincrypt.h>       // Used to generate random filename

//+====================================================================================
//
// Method: GetTempFilename
//
// Synopsis: Makes up a (path + 8.3) unique filename for use in directory pchPathName.
//           Uses specified prefix and extension for filename.
//           Ensures that file with generated filename doesn't yet exist. 
//           Does not actually create the file, does not test for permissions,
//           Does not verify presence of temp directory itself
//           Does not check for sufficient space on the disk.
//           Returns FALSE if unable to generate unique filename.
// Sideeffect:
//           If _pTempFileList has a reference to active file list object,
//           registers the new name with it for later deletion (for
//           temp files used when print or printpreview)
//------------------------------------------------------------------------------------
BOOL CDoc::GetTempFilename(
        const TCHAR *pchPrefixString,       //needed prefix (4 chars max)
        const TCHAR *pchExtensionString,    //needed extension (3 chars max)
              TCHAR *pchTempFileName)       //should point to TCHAR[MAX_PATH], allocated by caller
{
    BOOL  fRet = FALSE;
    const DWORD nTempPathLength = MAX_PATH - 13;  // temp path size == (MAX_PATH - ([8].[3] + '\0'))
    TCHAR szTempPath[nTempPathLength];
    TCHAR szFullName[MAX_PATH];
    HCRYPTPROV hProv = NULL;

    //verify that combined name will not be too long
    Assert(pchPrefixString && pchExtensionString);
    //verify that we are able to produce 8.3 filename
    Assert((_tcslen(pchPrefixString) <= 4) && (_tcslen(pchExtensionString) <= 3));

    // Verify input args to avoid buffer overrun.
    if (    !pchTempFileName
        ||  _tcslen(pchPrefixString) > 4
        ||  _tcslen(pchExtensionString) > 3)
        goto Cleanup;

    //set the return string to be empty
    *pchTempFileName = 0;

    // Get temp directory path
    {
        DWORD nTempPathLengthWritten = GetTempPath(nTempPathLength, szTempPath);

        // GetTempPath has two error conditions:
        // 1) If it fails (for some reason):    nTempPathLengthWritten is zero;
        // 2) If provided buffer is too small:  nTempPathLengthWritten > nTempPathLength;
        if (    nTempPathLengthWritten == 0
            ||  nTempPathLengthWritten > nTempPathLength) 
            goto Cleanup;
    }

    //verify that directory name ends with slash
    Assert(szTempPath[_tcslen(szTempPath)-1] == '\\');

    if (!CryptAcquireContextA(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
#ifdef DEBUG    
        DWORD dwErr;
        dwErr = GetLastError();
#endif
        hProv = NULL;
        goto Cleanup;
    }

    // Attempt to find an unused random file name 100 times.
    for(int nAttempts = 100; nAttempts; nAttempts--)
    {
        // Need 8 alphanumeric characters.
        BYTE abRand[8];
        if (!CryptGenRandom(hProv, sizeof(abRand), abRand))
            goto Cleanup;

        //generate 'random' part of filename
        TCHAR   szRnd[9];
        int     iLen = 8 - _tcslen(pchPrefixString); //the rest of filename except prefix

        for(int i=0;i<iLen;i++)
        {
            BYTE bTemp = abRand[i] % 36;

            if (bTemp < 26)
                szRnd[i] = 'A' + bTemp;
            else
                szRnd[i] = '0' + bTemp - 26;
        }
        szRnd[iLen] = 0;

        _tcscpy(szFullName, szTempPath);
        _tcscat(szFullName, pchPrefixString);
        _tcscat(szFullName, szRnd);
        _tcscat(szFullName, _T("."));
        _tcscat(szFullName, pchExtensionString);

        //check if file doesn't exist.
        if(0xFFFFFFFF == GetFileAttributes(szFullName))
        {

            //good, it doesn't exist. Copy result.
            _tcscpy(pchTempFileName, szFullName);

            //if we are tracking, add the filename into the list
            if (    TLS(pTempFileList)
                &&  TLS(pTempFileList)->IsTracking())
            {
                TLS(pTempFileList)->AddFilename(pchTempFileName);
            }

            fRet = TRUE;
            break;
        }

    }

Cleanup:
    if (hProv)
        CryptReleaseContext(hProv, 0);

    return fRet;
}

//+====================================================================================
//
// Method: SetTempFileTracking
//
// Synopsis: Turns on/off tempfile tracking. When Tracking is on, all filenames
//           generated by CDoc::GetTempFilename will be stored in a list 
//           and files will be deleted when CDoc is passivated or 
//           CDoc::DeleteTempFiles() will be called.
//------------------------------------------------------------------------------------
BOOL CDoc::SetTempFileTracking(BOOL fTrack)
{
    if(fTrack)
    {
        if (!TLS(pTempFileList))
            TLS(pTempFileList) = new CTempFileList;

        if (!TLS(pTempFileList))
            return FALSE;

        TLS(pTempFileList)->SetTracking(fTrack);
        return TLS(pTempFileList)->IsTracking();
    }
    else
    {
        if TLS(pTempFileList)
        {
            delete TLS(pTempFileList);
            TLS(pTempFileList) = NULL;
        }

        return FALSE;
    }
}

//+====================================================================================
//
// Method: TransferTempFileList
//
// Synopsis: Packages all accumulated filenames into SAFEARRAY and
//           removes them from the list.
//------------------------------------------------------------------------------------
BOOL CDoc::TransferTempFileList(VARIANT *pvarList)
{
    if(TLS(pTempFileList))
       return TLS(pTempFileList)->TransferTempFileList(pvarList);
    else
    {
        VariantInit(pvarList);
        return TRUE;
    }
}

//+====================================================================================
//
// Implementation of CTempFileName list.
//
//------------------------------------------------------------------------------------

struct CTempFileName
{   
    TCHAR _achFileName[MAX_PATH];
    CTempFileName *_pNext;
};

CTempFileList::CTempFileList()
{
    _pHead = NULL;
    _fRememberingFiles = FALSE;
}

CTempFileList::~CTempFileList()
{
    while(_pHead)
    {
        CTempFileName *pTemp = _pHead->_pNext;
        delete _pHead;
        _pHead = pTemp;
    }
}

void CTempFileList::SetTracking(BOOL doTrack)
{
    _fRememberingFiles = doTrack;
}


BOOL CTempFileList::IsTracking()
{
    return _fRememberingFiles;
}
    

BOOL CTempFileList::AddFilename(TCHAR *pchFilename)
{
    if(IsTracking())
    {
        CTempFileName *pTemp = new CTempFileName;

        if (!pTemp)
            return FALSE;

        _tcsncpy(pTemp->_achFileName, pchFilename, MAX_PATH);
        // Just in case. _tcsncpy doesn't add zero if destination is smaller then source
        pTemp->_achFileName[MAX_PATH-1] = 0;

        //put into the list
        pTemp->_pNext = _pHead;
        _pHead = pTemp;

        return TRUE;
    }

    return FALSE;
}

BOOL CTempFileList::TransferTempFileList(VARIANT *pvarList)
{
    SAFEARRAYBOUND sabound;
    SAFEARRAY *    psa = NULL;
    LONG           cnt;
    BSTR           bstrName;
    
    if(!pvarList) return FALSE;

    VariantInit(pvarList);

    //count the length
    cnt = 0;
    for(CTempFileName *pTemp = _pHead; pTemp; pTemp = pTemp->_pNext) 
        cnt++;

    //if we don't have files, leave retval in VT_EMPTY state
    if(cnt > 0)
    {
        //allocate SAFEARRAY
        sabound.cElements = cnt;
        sabound.lLbound = 0;
        psa = SafeArrayCreate(VT_BSTR, 1, &sabound);

        cnt = 0;
        while(_pHead)
        {
            CTempFileName *pTemp = _pHead->_pNext;

            bstrName = SysAllocString(_pHead->_achFileName);
            if( !bstrName ) goto Error;

            if(S_OK != SafeArrayPutElement(psa, &cnt, bstrName)) goto Error;
           
            cnt++;

            delete _pHead;
            _pHead = pTemp;
        }


        V_ARRAY(pvarList) = psa;
        V_VT(pvarList) = VT_ARRAY | VT_BSTR;
    }

    return TRUE;
    
Error:
    if(psa) SafeArrayDestroy(psa);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\treeserv.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif

#ifndef X_MARKUPUNDO_HXX_
#define X_MARKUPUNDO_HXX_
#include "markupundo.hxx"
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

#ifndef X_ROSTM_HXX_
#define X_ROSTM_HXX_
#include "rostm.hxx"
#endif

#if DBG==1
#ifndef X_CHNGLOG_HXX_
#define X_CHNGLOG_HXX_
#include "chnglog.hxx"
#endif // X_CHNGLOG_HXX_

#ifndef X_FRAME_H_
#define X_FRAME_H_
#include "iframe.h"
#endif // X_FRAME_H_
#endif // DBG==1

PerfDbgExtern(tagPerfWatch)

////////////////////////////////////////////////////////////////
//    IMarkupServices methods

HRESULT
CDoc::CreateMarkupPointer ( CMarkupPointer * * ppPointer )
{
    Assert( ppPointer );

    *ppPointer = new CMarkupPointer( this );

    if (!*ppPointer)
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT
CDoc::CreateMarkupPointer ( IMarkupPointer ** ppIPointer )
{
    HRESULT hr;
    CMarkupPointer * pPointer = NULL;

    hr = THR( CreateMarkupPointer( & pPointer ) );

    if (hr)
        goto Cleanup;

    hr = THR(
        pPointer->QueryInterface(
            IID_IMarkupPointer, (void **) ppIPointer ) );

    if (hr)
        goto Cleanup;

Cleanup:

    ReleaseInterface( pPointer );
    
    RRETURN( hr );
}


HRESULT
CDoc::MovePointersToRange (
    IHTMLTxtRange * pIRange,
    IMarkupPointer *  pIPointerStart,
    IMarkupPointer *  pIPointerFinish )
{
    HRESULT hr = S_OK;
    CAutoRange *pRange;
    CMarkupPointer *pPointerStart=NULL, *pPointerFinish=NULL;
    
    // check argument sanity
    if (pIRange==NULL          || !IsOwnerOf(pIRange) ||
        (pIPointerStart !=NULL && !IsOwnerOf(pIPointerStart))  ||
        (pIPointerFinish!=NULL && !IsOwnerOf(pIPointerFinish)) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // get the internal objects corresponding to the arguments
    hr = pIRange->QueryInterface(CLSID_CRange, (void**)&pRange);
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pIPointerStart)
    {
        hr = pIPointerStart->QueryInterface(CLSID_CMarkupPointer, (void**)&pPointerStart);
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    if (pIPointerFinish)
    {
        hr = pIPointerFinish->QueryInterface(CLSID_CMarkupPointer, (void**)&pPointerFinish);
        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    // move the pointers
    
    if (pPointerStart)
        hr = pRange->GetLeft( pPointerStart );
    
    if (!hr && pPointerFinish)
        hr = pRange->GetRight( pPointerFinish );
    
Cleanup:
    
    RRETURN( hr );
}


HRESULT
CDoc::MoveRangeToPointers (
    IMarkupPointer *  pIPointerStart,
    IMarkupPointer *  pIPointerFinish,
    IHTMLTxtRange * pIRange )
{
    HRESULT        hr = S_OK;
    CAutoRange *   pRange;
    BOOL           fPositioned;

    if (!pIPointerStart || !pIPointerFinish || !pIRange)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    if (!IsOwnerOf( pIRange ) ||
        !IsOwnerOf( pIPointerStart )  || !IsOwnerOf( pIPointerFinish ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pIPointerStart->IsPositioned( &fPositioned ) );
    if (hr)
        goto Cleanup;
    if (! fPositioned)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pIPointerFinish->IsPositioned( &fPositioned ) );
    if (hr)
        goto Cleanup;
    if (! fPositioned)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // get the internal objects corresponding to the arguments
    hr = THR( pIRange->QueryInterface( CLSID_CRange, (void**) & pRange ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pRange->SetLeftAndRight( pIPointerStart, pIPointerFinish, FALSE ));
    
Cleanup:
    
    RRETURN( hr );
}


HRESULT
CDoc::InsertElement (
    CElement *       pElementInsert,
    CMarkupPointer * pPointerStart,
    CMarkupPointer * pPointerFinish,
    DWORD            dwFlags )
{
    HRESULT     hr = S_OK;
    CTreePosGap tpgStart, tpgFinish;

    Assert( pElementInsert );
    Assert( pPointerStart );

    //
    // If the the finish is not specified, set it to the start to make the element span
    // nothing at the start.
    //
    
    if (!pPointerFinish)
        pPointerFinish = pPointerStart;

    Assert( ! pElementInsert->GetFirstBranch() );
    Assert( pElementInsert->Tag() != ETAG_ROOT );

    //
    // If the element is no scope, then we must ignore the finish
    //

    if (pElementInsert->IsNoScope())
        pPointerFinish = pPointerStart;

    //
    // Make sure the start if before the finish
    //

    Assert( pPointerStart->IsLeftOfOrEqualTo( pPointerFinish ) );

    //
    // Make sure both pointers are positioned, and in the same tree
    //

    Assert( pPointerStart->IsPositioned() );
    Assert( pPointerFinish->IsPositioned() );
    Assert( pPointerStart->Markup() == pPointerFinish->Markup() );

    //
    // Make sure unembedded markup pointers go in for the modification
    //

    hr = THR( pPointerStart->Markup()->EmbedPointers() );

    if (hr)
        goto Cleanup;

    //
    // Position the gaps and do the insert
    //

    // Note: We embed to make sure the pointers get updated, but we
    // also take advantage of it to get pointer pos's for the input
    // args.  It would be nice to treat the inputs specially in the
    // operation and not have to embed them......
    
    tpgStart.MoveTo( pPointerStart->GetEmbeddedTreePos(), TPG_LEFT );
    tpgFinish.MoveTo( pPointerFinish->GetEmbeddedTreePos(), TPG_LEFT );

    hr = THR(
        pPointerStart->Markup()->InsertElementInternal(
            pElementInsert, & tpgStart, & tpgFinish, dwFlags ) );

    if (hr)
        goto Cleanup;

Cleanup:
    
    RRETURN( hr );
}

HRESULT
CDoc::InsertElement(
    IHTMLElement *   pIElementInsert,
    IMarkupPointer * pIPointerStart,
    IMarkupPointer * pIPointerFinish)
{
    HRESULT          hr = S_OK;
    CElement *       pElementInsert;
    CMarkupPointer * pPointerStart, * pPointerFinish;

    //
    // If the the finish is not specified, set it to the start to make the element span
    // nothing at the start.
    //
    
    if (!pIPointerFinish)
        pIPointerFinish = pIPointerStart;

    //
    // Make sure all the arguments are specified and belong to this document
    //
    
    if (!pIElementInsert || !IsOwnerOf( pIElementInsert ) ||
        !pIPointerStart  || !IsOwnerOf( pIPointerStart  )  ||
        !pIPointerFinish || !IsOwnerOf( pIPointerFinish ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // get the internal objects corresponding to the arguments
    //
    
    hr = THR( pIElementInsert->QueryInterface( CLSID_CElement, (void **) & pElementInsert ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert( pElementInsert );

    //
    // The element must not already be in a tree
    //

    if ( pElementInsert->GetFirstBranch() )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Get the "real" objects associated with these pointer interfaces
    //
    
    hr = THR( pIPointerStart->QueryInterface( CLSID_CMarkupPointer, (void **) & pPointerStart ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hr = THR( pIPointerFinish->QueryInterface( CLSID_CMarkupPointer, (void **) & pPointerFinish ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Make sure both pointers are positioned, and in the same tree
    //

    if (!pPointerStart->IsPositioned() || !pPointerFinish->IsPositioned())
    {
        hr = CTL_E_UNPOSITIONEDPOINTER;
        goto Cleanup;
    }
    
    if (pPointerStart->Markup() != pPointerFinish->Markup())
    {
        hr = CTL_E_INCOMPATIBLEPOINTERS;
        goto Cleanup;
    }

    //
    // Make sure the start if before the finish
    //

    EnsureLogicalOrder( pPointerStart, pPointerFinish );
    
    hr = THR( InsertElement( pElementInsert, pPointerStart, pPointerFinish ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}


HRESULT
CDoc::RemoveElement ( 
    CElement *  pElementRemove,
    DWORD       dwFlags )
{
    HRESULT    hr = S_OK;

    //
    // Element to be removed must be specified and it must be associated
    // with this document.
    //

    Assert( pElementRemove );

    //
    //  Assert that the element is in the markup
    //
    
    Assert( pElementRemove->IsInMarkup() );
    Assert( pElementRemove->Tag() != ETAG_ROOT );

    //
    // Now, remove the element
    //

    hr = THR( pElementRemove->GetMarkup()->RemoveElementInternal( pElementRemove, dwFlags ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

HRESULT
CDoc::RemoveElement ( IHTMLElement * pIElementRemove )
{
    HRESULT    hr = S_OK;
    CElement * pElementRemove = NULL;

    //
    // Element to be removed must be specified and it must be associated
    // with this document.
    //
    
    if (!pIElementRemove || !IsOwnerOf( pIElementRemove ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // get the interneal objects corresponding to the arguments
    //
    
    hr = THR(
        pIElementRemove->QueryInterface(
            CLSID_CElement, (void **) & pElementRemove ) );
    
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Make sure element is in the tree
    //

    if (!pElementRemove->IsInMarkup())
    {
        hr = CTL_E_UNPOSITIONEDELEMENT;
        goto Cleanup;
    }

    //
    // The root element is off limits
    //

    if( pElementRemove->Tag() == ETAG_ROOT )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Do the remove
    //

    hr = THR( RemoveElement( pElementRemove ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

HRESULT
CDoc::Remove (
    CMarkupPointer * pPointerStart,
    CMarkupPointer * pPointerFinish,
    DWORD            dwFlags )
{
    return CutCopyMove( pPointerStart, pPointerFinish, NULL, TRUE, dwFlags );
}

HRESULT
CDoc::Copy (
    CMarkupPointer * pPointerSourceStart,
    CMarkupPointer * pPointerSourceFinish,
    CMarkupPointer * pPointerTarget,
    DWORD            dwFlags )
{
    return
        CutCopyMove(
            pPointerSourceStart, pPointerSourceFinish,
            pPointerTarget, FALSE, dwFlags );
}

HRESULT
CDoc::Move (
    CMarkupPointer * pPointerSourceStart,
    CMarkupPointer * pPointerSourceFinish,
    CMarkupPointer * pPointerTarget,
    DWORD            dwFlags )
{
    return
        CutCopyMove(
            pPointerSourceStart, pPointerSourceFinish,
            pPointerTarget, TRUE, dwFlags );
}

HRESULT
CDoc::Remove (
    IMarkupPointer * pIPointerStart,
    IMarkupPointer * pIPointerFinish )
{
    return CutCopyMove( pIPointerStart, pIPointerFinish, NULL, TRUE );
}

HRESULT
CDoc::Copy(
    IMarkupPointer * pIPointerStart,
    IMarkupPointer * pIPointerFinish,
    IMarkupPointer * pIPointerTarget )
{
    return CutCopyMove( pIPointerStart, pIPointerFinish, pIPointerTarget, FALSE );
}


HRESULT
CDoc::Move(
    IMarkupPointer * pIPointerStart,
    IMarkupPointer * pIPointerFinish,
    IMarkupPointer * pIPointerTarget )
{
    return CutCopyMove( pIPointerStart, pIPointerFinish, pIPointerTarget, TRUE );
}


HRESULT
CDoc::InsertText (
    CMarkupPointer * pPointerTarget,
    const OLECHAR *  pchText,
    long             cch,
    DWORD            dwFlags )
{
    HRESULT hr = S_OK;

    Assert( pPointerTarget );
    Assert( pPointerTarget->IsPositioned() );

    hr = THR( pPointerTarget->Markup()->EmbedPointers() );

    if (hr)
        goto Cleanup;

    if (cch < 0)
        cch = pchText ? _tcslen( pchText ) : 0;

    hr = THR(
        pPointerTarget->Markup()->InsertTextInternal(
            pPointerTarget->GetEmbeddedTreePos(), pchText, cch, dwFlags ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN(hr);
}

HRESULT
CDoc::InsertText ( OLECHAR * pchText, long cch, IMarkupPointer * pIPointerTarget )
{
    HRESULT          hr = S_OK;
    CMarkupPointer * pPointerTarget;

    if (!pIPointerTarget || !IsOwnerOf( pIPointerTarget ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Get the internal objects corresponding to the arguments
    //
    
    hr = THR(
        pIPointerTarget->QueryInterface(
            CLSID_CMarkupPointer, (void **) & pPointerTarget ) );
    
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // more sanity checks
    //
    
    if (!pPointerTarget->IsPositioned())
    {
        hr = CTL_E_UNPOSITIONEDPOINTER;
        goto Cleanup;
    }

    //
    // Do it
    //

    hr = THR( InsertText( pPointerTarget, pchText, cch ) );

    if (hr)
        goto Cleanup;

Cleanup:
    
    RRETURN( hr );
}

HRESULT 
CDoc::ParseString (
            OLECHAR *        pchHTML,
            DWORD            dwFlags,
            CMarkup * *      ppContainerResult,
            CMarkupPointer * pPointerStart,
            CMarkupPointer * pPointerFinish,
            CMarkup *        pMarkupContext)
{
    HRESULT hr;
    HGLOBAL hHtmlText = NULL;

    Assert(ppContainerResult);
    Assert(pchHTML);
    
    extern HRESULT HtmlStringToSignaturedHGlobal (
        HGLOBAL * phglobal, const TCHAR * pStr, long cch );

    hr = THR(
        HtmlStringToSignaturedHGlobal(
            & hHtmlText, pchHTML, _tcslen( pchHTML ) ) );

    if (hr)
        goto Cleanup;

    Assert( hHtmlText );

    hr = THR(
        ParseGlobal(
            hHtmlText, dwFlags, pMarkupContext, ppContainerResult,
            pPointerStart, pPointerFinish ) );

    if (hr)
        goto Cleanup;

Cleanup:

    if (hHtmlText)
        GlobalFree( hHtmlText );
    
    RRETURN( hr );
}



HRESULT
CDoc::ParseString (
    OLECHAR *            pchHTML,
    DWORD                dwFlags,
    IMarkupContainer * * ppIContainerResult,
    IMarkupPointer *     pIPointerStart,
    IMarkupPointer *     pIPointerFinish )
{
    HRESULT             hr = S_OK;
    CMarkupPointer *    pStart = NULL;
    CMarkupPointer *    pFinish = NULL;
    CMarkup *           pMarkup = NULL;

    if (!pchHTML || !ppIContainerResult)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppIContainerResult = NULL;

    if (pIPointerStart)
    {
        hr = THR(
            pIPointerStart->QueryInterface(
                CLSID_CMarkupPointer, (void **)&pStart ) );

        if (hr)
            goto Cleanup;
    }

    if (pIPointerFinish)
    {
        hr = THR(
             pIPointerFinish->QueryInterface(
                CLSID_CMarkupPointer, (void **)&pFinish ) );
        
        if (hr)
            goto Cleanup;
    }

    hr = THR(
        ParseString( pchHTML, dwFlags, & pMarkup, pStart, pFinish, /*pMarkupContext = */NULL) );

    if (hr)
        goto Cleanup;

    if (pMarkup)
    {
        hr = THR( pMarkup->SetOrphanedMarkup( TRUE ) );
        if( hr )
            goto Cleanup;

        hr = THR(
            pMarkup->QueryInterface(
                IID_IMarkupContainer, (void **)ppIContainerResult ) );

        if (hr)
            goto Cleanup;
    }
            
Cleanup:

    if (pMarkup)
        pMarkup->Release();


    RRETURN(hr);
}


static HRESULT
PrepareStream (
    HGLOBAL hGlobal,
    IStream * * ppIStream,
    BOOL fInsertFrags,
    HTMPASTEINFO * phtmpasteinfo)
{
    CStreamReadBuff * pstreamReader = NULL;
    LPSTR pszGlobal = NULL;
    long lSize;
    BOOL fIsEmpty, fHasSignature;
    TCHAR szVersion[ 24 ];
    TCHAR szSourceUrl [ pdlUrlLen ];
    long iStartHTML, iEndHTML;
    long iStartFragment, iEndFragment;
    long iStartSelection, iEndSelection;
    DWORD dwGlobalSize;
    ULARGE_INTEGER ul = { 0, 0 };
    HRESULT hr = S_OK;
    CROStmOnHGlobal * pStm = NULL;

    Assert( hGlobal );
    Assert( ppIStream );

    //
    // Get access to the bytes of the global
    //


    pszGlobal = LPSTR( GlobalLock( hGlobal ) );

    if (!pszGlobal)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // First, compute the size of the global
    //

    lSize = 0;
    dwGlobalSize = GlobalSize( hGlobal );
    if (dwGlobalSize == 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // TODO: Support nonnative signature and sizeof(wchar) == 4/2 (davidd)

    fHasSignature = * (WCHAR *) pszGlobal == NATIVE_UNICODE_SIGNATURE;

    // We're forcing a terminator at the end of the global in case any bad
    // clients <coughWord2000cough> don't give us a terminated string. 
    // If our terminator was the only thing ending the string, then we'll
    // count that last character as well (by setting the size of the stream)
    if (fHasSignature)
    {
        TCHAR *pchLast = (TCHAR *)( pszGlobal + dwGlobalSize - sizeof( TCHAR ) );
        TCHAR chTerm = *pchLast;

        *pchLast = _T('\0');
        lSize = _tcslen( (TCHAR *) pszGlobal ) * sizeof( TCHAR );
        *pchLast = chTerm;

        if( (DWORD)lSize == dwGlobalSize - sizeof( TCHAR ) && chTerm != _T('\0') )
            lSize += sizeof( TCHAR );

        fIsEmpty = (lSize - sizeof( TCHAR )) == 0;
    }
    else
    {
        char chTerm = pszGlobal[ dwGlobalSize - 1 ];

        pszGlobal[ dwGlobalSize - 1 ] = '\0';
        lSize = lstrlenA( pszGlobal );
        pszGlobal[ dwGlobalSize - 1 ] = chTerm;

        if( (DWORD)lSize == dwGlobalSize - 1 && chTerm != '\0' )
            ++lSize;

        fIsEmpty = lSize == 0;
    }

    //
    // If the HGLOBAL is effectively empty, do nothing, and return this
    // fact.
    //

    if (fIsEmpty)
    {
        *ppIStream = NULL;
        goto Cleanup;
    }

    //
    // Create if the stream got the load context
    //

    pStm = new CROStmOnHGlobal();
    if( !pStm )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR( pStm->Init( hGlobal, lSize ) );
    if( hr )
        goto Cleanup;

    *ppIStream = pStm;
    pStm = NULL;

    // N.B. (johnv) This is necessary for Win95 support.  Apparently
    // GlobalSize() may return different values at different times for the same
    // hGlobal.  This makes IStream's behavior unpredictable.  To get around
    // this, we set the size of the stream explicitly.

    // Make sure we don't have unicode in the hGlobal

#ifdef UNIX
    U_QUAD_PART(ul)= lSize;
    Assert( U_QUAD_PART(ul) <= GlobalSize( hGlobal ) );
#else
    ul.QuadPart = lSize;
    Assert( ul.QuadPart <= GlobalSize( hGlobal ) );
#endif

    iStartHTML      = -1;
    iEndHTML        = -1;
    iStartFragment  = -1;
    iEndFragment    = -1;
    iStartSelection = -1;
    iEndSelection   = -1;

    //
    // Locate the required contextual information in the stream
    //

    pstreamReader = new CStreamReadBuff ( * ppIStream, CP_UTF_8 );
    if (pstreamReader == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(
        pstreamReader->GetStringValue(
            _T("Version"), szVersion, ARRAY_SIZE( szVersion ) ) );

    if (hr == S_FALSE)
        goto PlainStream;

    if (hr)
        goto Cleanup;

    hr = THR(
        pstreamReader->GetLongValue(
            _T( "StartHTML" ), & iStartHTML ) );

    if (hr == S_FALSE)
        goto PlainStream;

    if (hr)
        goto Cleanup;

    hr = THR(
        pstreamReader->GetLongValue(
            _T( "EndHTML" ), & iEndHTML ) );

    if (hr == S_FALSE)
        goto PlainStream;

    if (hr)
        goto Cleanup;

    hr = THR(
        pstreamReader->GetLongValue(
            _T( "StartFragment" ), & iStartFragment ) );

    if (hr == S_FALSE)
        goto PlainStream;

    if (hr)
        goto Cleanup;

    hr = THR(
        pstreamReader->GetLongValue(
            _T( "EndFragment" ), & iEndFragment ) );

    //
    // Locate optional contextual information
    //

    hr = THR(
        pstreamReader->GetLongValue(
            _T( "StartSelection" ), & iStartSelection ) );

    if (hr && hr != S_FALSE)
        goto Cleanup;

    if (hr != S_FALSE)
    {
        hr = THR(
            pstreamReader->GetLongValue(
                _T( "EndSelection" ), & iEndSelection ) );

        if (hr && hr != S_FALSE)
            goto Cleanup;

        if (hr == S_FALSE)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else
    {
        iStartSelection = -1;
    }

    //
    // Get the source URL info
    //

    hr = THR(
        pstreamReader->GetStringValue(
            _T( "SourceURL" ), szSourceUrl, ARRAY_SIZE( szSourceUrl ) ) );

    if (hr && hr != S_FALSE)
        goto Cleanup;

    if (phtmpasteinfo && hr != S_FALSE)
    {
        hr = THR( phtmpasteinfo->cstrSourceUrl.Set( szSourceUrl ) );

        if (hr)
            goto Cleanup;
    }

    //
    // Make sure contextual info is sane
    //

    if (iStartHTML < 0 && iEndHTML < 0)
    {
        //
        // per cfhtml spec, start and end html can be -1 if there is no
        // context.  there must always be a fragment, however
        //
        iStartHTML = iStartFragment;
        iEndHTML   = iEndFragment;
    }

    if (iStartHTML     < 0 || iEndHTML     < 0 ||
        iStartFragment < 0 || iEndFragment < 0 ||
        iStartHTML     > iEndHTML     ||
        iStartFragment > iEndFragment ||
        iStartHTML > iStartFragment ||
        iEndHTML   < iEndFragment)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (iStartSelection != -1)
    {
        if (iEndSelection < 0 ||
            iStartSelection > iEndSelection ||
            iStartHTML > iStartSelection ||
            iEndHTML < iEndSelection ||
            iStartFragment > iStartSelection ||
            iEndFragment < iEndSelection)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    //
    // Rebase the fragment and selection off of the start html
    //

    iStartFragment -= iStartHTML;
    iEndFragment -= iStartHTML;

    if (iStartSelection != -1)
    {
        iStartSelection -= iStartHTML;
        iEndSelection -= iStartHTML;
    }
    else
    {
        iStartSelection = iStartFragment;
        iEndSelection = iEndFragment;
    }

    phtmpasteinfo->cbSelBegin  = iStartSelection;
    phtmpasteinfo->cbSelEnd    = iEndSelection;

    pstreamReader->SetPosition( iStartHTML );

    hr = S_OK;

Cleanup:

    if (pstreamReader)
        phtmpasteinfo->cp = pstreamReader->GetCodePage();

    delete pstreamReader;

    if( pStm )
        pStm->Release();

    if (pszGlobal)
        GlobalUnlock( hGlobal );

    RRETURN( hr );

PlainStream:

    pstreamReader->SetPosition( 0 );
    pstreamReader->SwitchCodePage(g_cpDefault);

    if (fInsertFrags)
    {
        phtmpasteinfo->cbSelBegin  = fHasSignature ? sizeof( TCHAR ) : 0;
        phtmpasteinfo->cbSelEnd    = lSize;
    }
    else
    {
        phtmpasteinfo->cbSelBegin  = -1;
        phtmpasteinfo->cbSelEnd    = -1;
    }

    hr = S_OK;

    goto Cleanup;
}

static HRESULT
MoveToPointer (
    CDoc *           pDoc,
    CMarkupPointer * pMarkupPointer,
    CTreePos *       ptp )
{
    HRESULT hr = S_OK;

    if (!pMarkupPointer)
    {
        if (ptp)
        {
            hr = THR( ptp->GetMarkup()->RemovePointerPos( ptp, NULL, NULL ) );

            if (hr)
                goto Cleanup;
        }
        
        goto Cleanup;
    }

    if (!ptp)
    {
        hr = THR( pMarkupPointer->Unposition() );

        if (hr)
            goto Cleanup;

        goto Cleanup;
    }

    hr = THR( pMarkupPointer->MoveToOrphan( ptp ) );

    if (hr)
        goto Cleanup;

    //
    // NOTE Parser can sometimes put the pointer pos in the
    // inside of a noscope (load <body onload="document.body.innerHTML='<body><script></body>'">)
    // Check forthis here
    //

    if (pMarkupPointer->Branch()->Element()->IsNoScope())
    {
        hr = THR(
            pMarkupPointer->MoveAdjacentToElement(
                pMarkupPointer->Branch()->Element(), ELEM_ADJ_AfterEnd ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}

HRESULT
CDoc::ParseGlobal (
    HGLOBAL          hGlobal,
    DWORD            dwFlags,
    CMarkup *        pContextMarkup,
    CMarkup * *      ppMarkupResult,
    CMarkupPointer * pPointerSelStart,
    CMarkupPointer * pPointerSelFinish,
    DWORD            dwInternalFlags /* = 0 */)
{
    PerfDbgLog(tagPerfWatch, this, "+CDoc::ParseGlobal");

    HRESULT hr = S_OK;
    IStream * pIStream = NULL;
    HTMPASTEINFO htmpasteinfo;
    CMarkup * pWindowedMarkupContext;

    Assert( pPointerSelStart );
    Assert( pPointerSelFinish );
    Assert( ppMarkupResult );

    //
    // Returning NULL suggests that there was absolutely nothing to parse.
    //
    
    *ppMarkupResult = NULL;
    
    if (!hGlobal)
        goto Cleanup;

    //
    // Prepare the stream ...
    //

    hr = THR( PrepareStream( hGlobal, & pIStream, TRUE, & htmpasteinfo ) );
    if (hr)
        goto Cleanup;

    //
    // If no stream was created, then there is nothing to parse
    //

    if (!pIStream)
        goto Cleanup;

    //
    // Create the new markup container which will receive the the bounty
    // of the parse
    //

    if (!pContextMarkup)
    {
        // WINDOWEDMARKUP - This is only available to binary code
        pContextMarkup = PrimaryMarkup();
        pWindowedMarkupContext = PrimaryMarkup();
    }
    else
    {
        pWindowedMarkupContext = pContextMarkup->GetWindowedMarkupContext();
    }

    hr = THR( CreateMarkup( ppMarkupResult, pWindowedMarkupContext ) );

    if (hr)
        goto Cleanup;

    Assert( *ppMarkupResult );

    (*ppMarkupResult)->_fInnerHTMLMarkup = !!(dwInternalFlags & INTERNAL_PARSE_INNERHTML);
    if (!!(dwInternalFlags & INTERNAL_PARSE_PRINTTEMPLATE))
        (*ppMarkupResult)->SetPrintTemplate(TRUE);
    
    //
    // Prepare the frag/sel begin/end for the return 
    //

    htmpasteinfo.ptpSelBegin = NULL;
    htmpasteinfo.ptpSelEnd = NULL;

    //
    // Parse this
    //

    _fPasteIE40Absolutify = dwFlags & PARSE_ABSOLUTIFYIE40URLS;

    (*ppMarkupResult)->_fMarkupServicesParsing = TRUE;

    hr = THR( (*ppMarkupResult)->Load( pIStream, pContextMarkup, /* fAdvanceLoadStatus = */ FALSE, & htmpasteinfo ) );
    
    (*ppMarkupResult)->_fMarkupServicesParsing = FALSE;

    if (hr)
        goto Cleanup;

    //
    // Move the pointers to the pointer pos' the parser left in
    //

    if( !htmpasteinfo.ptpSelBegin || !htmpasteinfo.ptpSelEnd )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(
        MoveToPointer(
            this, pPointerSelStart,  htmpasteinfo.ptpSelBegin ) );

    if (hr)
        goto Cleanup;
    
    hr = THR(
        MoveToPointer(
            this, pPointerSelFinish, htmpasteinfo.ptpSelEnd   ) );

    if (hr)
        goto Cleanup;

#if DBG == 1
    pPointerSelStart->SetDebugName( _T( "Selection Start" ) );
    pPointerSelFinish->SetDebugName( _T( "Selection Finish" ) );
#endif

    //
    // Make sure the finish is (totally) ordered properly with
    // respect to the begin
    //

    if (pPointerSelStart->IsPositioned() && pPointerSelFinish->IsPositioned())
        EnsureLogicalOrder( pPointerSelStart, pPointerSelFinish );

Cleanup:
    if (*ppMarkupResult && (*ppMarkupResult)->HasWindow())
        (*ppMarkupResult)->TearDownMarkup(FALSE);  // fStop = FALSE

    ReleaseInterface( pIStream );

    PerfDbgLog(tagPerfWatch, this, "-CDoc::ParseGlobal");

    RRETURN( hr );
}

HRESULT
CDoc::ParseGlobal (
    HGLOBAL              hGlobal,
    DWORD                dwFlags,
    IMarkupContainer * * ppIContainerResult,
    IMarkupPointer *     pIPointerSelStart,
    IMarkupPointer *     pIPointerSelFinish )
{
    HRESULT          hr = S_OK;
    CMarkup *        pMarkup = NULL;
    CMarkupPointer * pPointerSelStart = NULL;
    CMarkupPointer * pPointerSelFinish = NULL;

    if (!ppIContainerResult)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppIContainerResult = NULL;

    if (!hGlobal)
        goto Cleanup;

    if (pIPointerSelStart)
    {
        hr = THR(
            pIPointerSelStart->QueryInterface(
                CLSID_CMarkupPointer, (void **) & pPointerSelStart ) );

        if (hr)
            goto Cleanup;
    }

    if (pIPointerSelFinish)
    {
        hr = THR(
            pIPointerSelFinish->QueryInterface(
                CLSID_CMarkupPointer, (void **) & pPointerSelFinish ) );

        if (hr)
            goto Cleanup;
    }

    hr = THR(
        ParseGlobal(
            hGlobal, dwFlags, /* pContextMarkup = */ NULL, & pMarkup, pPointerSelStart, pPointerSelFinish ) );

    if (hr)
        goto Cleanup;

    if (pMarkup)
    {
        hr = THR( pMarkup->SetOrphanedMarkup( TRUE ) );
        if( hr )
            goto Cleanup;

        hr = THR(
            pMarkup->QueryInterface(
                IID_IMarkupContainer, (void **) ppIContainerResult ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    if (pMarkup)
        pMarkup->Release();

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Functions:  Equal & Compare
//
//  Synopsis:   Helpers for comparing IMarkupPointers
//
//-----------------------------------------------------------------------------

static inline BOOL
IsEqualTo ( IMarkupPointer * p1, IMarkupPointer * p2 )
{
    BOOL fEqual;
    IGNORE_HR( p1->IsEqualTo( p2, & fEqual ) );
    return fEqual;
}

static inline int
OldCompare ( IMarkupPointer * p1, IMarkupPointer * p2 )
{
    int result;
    IGNORE_HR( OldCompare( p1, p2, & result ) );
    return result;
}

//+----------------------------------------------------------------------------
//
//  Function:   ComputeTotalOverlappers
//
//  Synopsis:   This function retunrs a node which can be found above the
//              finish pointer.  All elements starting at this node and above
//              it are in the scope of both the start and finish pointers.
//              
//              If an element were to be inserted between the pointers, that
//              element would finish just above this node.  All elements above
//              the return node, including the return element, begin before
//              the start pointer and finish after the finish pointer.
//
//-----------------------------------------------------------------------------

typedef CStackPtrAry < CTreeNode *, 32 > NodeArray;

MtDefine( ComputeTotalOverlappers_aryNodes_pv, Locals, "ComputeTotalOverlappers aryNodes::_pv" );

static HRESULT
ComputeTotalOverlappers(
    CMarkupPointer * pPointerStart,
    CMarkupPointer * pPointerFinish,
    CTreeNode * *    ppNodeTarget )
{
    HRESULT     hr = S_OK;
    CTreeNode * pNode;
    NodeArray   aryNodesStart( Mt( ComputeTotalOverlappers_aryNodes_pv ) );
    NodeArray   aryNodesFinish( Mt( ComputeTotalOverlappers_aryNodes_pv ) );
    int         iStart, iFinish;

    Assert( ppNodeTarget );
    Assert( pPointerStart && pPointerFinish );
    Assert( pPointerStart->IsPositioned() );
    Assert( pPointerFinish->IsPositioned() );
    Assert( pPointerStart->Markup() == pPointerFinish->Markup() );
    Assert( OldCompare( pPointerStart, pPointerFinish ) <= 0 );

    *ppNodeTarget = NULL;

    for ( pNode = pPointerStart->Branch() ; pNode ; pNode = pNode->Parent() )
        IGNORE_HR( aryNodesStart.Append( pNode ) );

    for ( pNode = pPointerFinish->Branch() ; pNode ; pNode = pNode->Parent() )
        IGNORE_HR( aryNodesFinish.Append( pNode ) );

    iStart = aryNodesStart.Size() - 1;
    iFinish = aryNodesFinish.Size() - 1;

    for ( ; ; )
    {
        if (iStart < 0 || iFinish < 0)
        {
            if (iFinish + 1 < aryNodesFinish.Size())
                *ppNodeTarget = aryNodesFinish[ iFinish + 1 ];

            goto Cleanup;
        }

        if (aryNodesStart [ iStart ] == aryNodesFinish [ iFinish ])
            iFinish--;

        iStart--;
    }

Cleanup:

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   ValidateElements
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------

MtDefine( ValidateElements_aryNodes_pv, Locals, "ValidateElements aryNodes::_pv" );

//
// TODO
//
// This function is broken in the general case.  First, we need to add a flag
// to validate copies v.s. moves.  Also, it can only validate either inplace
// (pPointerTarget is NULL) or a tree-to-tree move.  Luckily, these are the
// only ways this function is used in IE5.
//

HRESULT
CDoc::ValidateElements (
    CMarkupPointer *   pPointerStart,
    CMarkupPointer *   pPointerFinish,
    CMarkupPointer *   pPointerTarget,
    DWORD              dwFlags,
    CMarkupPointer *   pPointerStatus,
    CTreeNode * *      ppNodeFailBottom,
    CTreeNode * *      ppNodeFailTop )
{  
    HRESULT     hr = S_OK;
    NodeArray   aryNodes ( Mt( ValidateElements_aryNodes_pv ) );
    long        nNodesOk;
    CTreeNode * pNodeCommon;
    CTreeNode * pNode;
    CTreePos *  ptpWalk;
    CTreePos *  ptpFinish;
    CTreePos *  ptpBeforeIncl = NULL;
    CMarkupPointer  pointerStatus(this);

    Assert( pPointerStart && pPointerFinish);
    Assert( pPointerStart->IsPositioned() );
    Assert( pPointerFinish->IsPositioned() );
    Assert( pPointerStart->Markup() ==pPointerFinish->Markup() );
    Assert( !pPointerTarget  || pPointerTarget->IsPositioned() );

    if (!pPointerStatus)
    {
        pPointerStatus = &pointerStatus;
    }

    //
    // TODO Should not have to embed pointers here!
    //

    hr = THR( pPointerStart->Markup()->EmbedPointers() );

    if (hr)
        goto Cleanup;

    if (pPointerTarget)
    {
        hr = THR( pPointerTarget->Markup()->EmbedPointers() );

        if (hr)
            goto Cleanup;
    }

    //
    // If the status pointer is NULL, then we are validating from the
    // beginning.  Otherwise, we are to continue validating from that
    // position.
    //

    if (!pPointerStatus->IsPositioned())
    {
        hr = THR( pPointerStatus->SetGravity( POINTER_GRAVITY_Left ) );
        if (hr)
            goto Cleanup;

        hr = THR( pPointerStatus->MoveToPointer( pPointerStart ) );
        if (hr)
            goto Cleanup;
    }

    WHEN_DBG( (pPointerStatus->SetDebugName( _T( "Validate Status" ) ) ) );

    //
    // If the status pointer is outside the range to validate, then
    // the validation is ended.  In this case, release the status pointer
    // and return.
    //

    if (OldCompare( pPointerStart, pPointerStatus ) > 0 ||
        OldCompare( pPointerFinish, pPointerStatus ) <= 0)
    {
        hr = THR( pPointerStatus->Unposition() );
        goto Cleanup;
    }

    //
    // Get the common node for the range to validate.  Anything above
    // and including the common node cannot be a candidate for source
    // validation because they must cover the entire range and will not
    // participate in a move.
    //

    {
        CTreeNode * pNodeStart  = pPointerStart->Branch();
        CTreeNode * pNodeFinish = pPointerFinish->Branch();

        pNodeCommon =
            (pNodeStart && pNodeFinish)
                ? pNodeStart->GetFirstCommonAncestorNode( pNodeFinish, NULL )
                : NULL;
    }
    
    //
    // Here we prime the tag array with target elements (if any).
    //

    {
        CTreeNode * pNodeTarget;
        int         nNodesTarget = 0, i;
        
        if (pPointerTarget && pPointerTarget->IsPositioned())
        {
            //
            // If the target is in the range of the source, then compute
            // the branch which consists of elements which totally overlap
            // the range to validate.  These are the elements which would
            // remain of the range were be removed.
            //
            // If the target is not in the validation range, then simply use
            // the base of the target.
            //

            if (pPointerTarget->Markup() == pPointerStart->Markup() &&
                OldCompare( pPointerStart,  pPointerTarget ) < 0 &&
                    OldCompare( pPointerFinish, pPointerTarget ) > 0)
            {
AssertSz( 0, "This path should never be used in IE5" );
                hr = THR(
                    ComputeTotalOverlappers(
                        pPointerStart, pPointerFinish, & pNodeTarget ) );

                if (hr)
                    goto Cleanup;
            }
            else
            {
                pNodeTarget = pPointerTarget->Branch();
            }
        }
        else
        {
            pNodeTarget = pNodeCommon;
        }

        //
        // Now, put tags in the tag array starting from the target
        //

        for ( pNode = pNodeTarget ;
              pNode && pNode->Tag() != ETAG_ROOT ;
              pNode = pNode->Parent() )
        {
            nNodesTarget++;
        }

        hr = THR( aryNodes.Grow( nNodesTarget ) );

        if (hr)
            goto Cleanup;
        
        for ( i = 1, pNode = pNodeTarget ;
              pNode && pNode->Tag() != ETAG_ROOT ;
              pNode = pNode->Parent(), i++ )
        {
            aryNodes [ nNodesTarget - i ] = pNode;
        }
    }
    
    //
    // During the validation walk, the mark bit on the element will
    // indicate whether or not the element will participate in a move
    // if the range to validate were moved to another location.  A mark
    // or 1 indicates that the element participates, 0 means it does not.
    //
    // By setting all the bits (up to the common node) on the left branch
    // to 1 and then clearing all the bits on the right branch, all elements
    // on the first branch which partially overlap the left side of the
    // range to validate.
    //
    // Note, this only applies if a target has been specified.  If we
    // are validating inplacem, then we simply validate all elements
    // in scope.
    //

    for ( pNode = pPointerStart->Branch() ;
          pNode != pNodeCommon ;
          pNode = pNode->Parent() )
    {
        pNode->Element()->_fMark1 = 1;
    }

    //
    // Only clear the bits if a tree-to-tree move validation is being
    // performed.  If not, then we leave all the marks up to the common
    // element on.  Thus, all elements in scope will be validated against.
    //

    if (pPointerTarget)
    {
        for ( pNode = pPointerFinish->Branch() ;
              pNode != pNodeCommon ;
              pNode = pNode->Parent() )
        {
            pNode->Element()->_fMark1 = 0;
        }
    }

    //
    // Now, walk from the start pointer to the status pointer, setting the
    // mark bit to true on any elements comming into scope.  This needs to
    // be done to make sure we include these elements in the validation
    // because they have come into scope.  We also do this as we walk the
    // main loop later, doing the actual validation.
    //
    // Note: We do a Compare here because the pointers may be at the same
    // place in the markup, but the start is after the status pointer.
    //

    ptpWalk = pPointerStart->GetEmbeddedTreePos();
    
    if (! IsEqualTo( pPointerStatus, pPointerStart ))
    {
        CTreePos * ptpStatus = pPointerStatus->GetEmbeddedTreePos();

        for ( ; ptpWalk != ptpStatus ; ptpWalk = ptpWalk->NextTreePos() )
        {
            if (ptpWalk->IsBeginElementScope())
                ptpWalk->Branch()->Element()->_fMark1 = TRUE;
        }
    }

    //
    // Now, prime the tag array with the current set of source elements.
    // As we walk the validation range, we will add or remove elements
    // as they enter and exit scope.
    //

    {
        int i;
        
        for ( pNode = ptpWalk->GetBranch(), i = 0 ;
              pNode != pNodeCommon ;
              pNode = pNode->Parent() )
        {
            if (pNode->Element()->_fMark1)
                i++;
        }

        hr = THR( aryNodes.Grow( aryNodes.Size() + i ) );

        if (hr)
            goto Cleanup;

        i = aryNodes.Size() - 1;
        
        for ( pNode = ptpWalk->GetBranch() ;
              pNode != pNodeCommon ;
              pNode = pNode->Parent() )
        {
            if (pNode->Element()->_fMark1)
                aryNodes[ i-- ] = pNode;
        }
    }

    //
    // This is the 'main' loop where validation actually takes place.
    //

    ptpFinish = pPointerFinish->GetEmbeddedTreePos();
    nNodesOk = 0;
    
    for ( ; ; )
    {
        BOOL fDone;
        long iConflictTop, iConflictBottom;
        
        //
        // Validate the current tag array
        //

        extern HRESULT
            ValidateNodeList (
                CTreeNode **, long, long, BOOL, long *, long *);

        hr = THR(
            ValidateNodeList(
                aryNodes, aryNodes.Size(), nNodesOk,
                dwFlags & VALIDATE_ELEMENTS_REQUIREDCONTAINERS,
                & iConflictTop, & iConflictBottom ) );

        //
        // Returning S_FALSE indicates a conflict
        //

        if (hr == S_FALSE)
        {
            CTreePos * ptpPtr;
            
            if( ptpWalk->IsBeginNode() && !ptpWalk->IsEdgeScope() )
            {
                Assert(     ptpBeforeIncl->IsEndNode()
                        &&  !ptpBeforeIncl->IsEdgeScope()
                        &&  ptpBeforeIncl->Branch()->Element() == ptpWalk->Branch()->Element() );

                ptpPtr = ptpBeforeIncl;
            }
            else
            {
                ptpPtr = ptpWalk;
            }

            CTreePosGap gap ( ptpPtr, TPG_LEFT );
            
            hr = THR( pPointerStatus->MoveToGap( & gap, pPointerStart->Markup() ) );

            if (hr)
                goto Cleanup;

            if (ppNodeFailBottom)
                *ppNodeFailBottom = aryNodes[ iConflictBottom ];
            
            if (ppNodeFailTop)
                *ppNodeFailTop = aryNodes[ iConflictTop ];

            hr = S_FALSE;

            goto Cleanup;
        }

        if (hr)
            goto Cleanup;

        //
        // Since we've just validated the entire array, don't do it again
        // next time 'round.
        //

        nNodesOk = aryNodes.Size();

        //
        // Now, scan forward looking for an interesting event.  If we get
        // to the finish before that, we are done.
        //

        for ( fDone = FALSE ; ; )
        {
            ptpWalk = ptpWalk->NextTreePos();

            if (ptpWalk == ptpFinish)
            {
                fDone = TRUE;
                break;
            }

            //
            // If we run accross an edge, either push that tag onto the
            // stack, or remove it.
            //

            if (ptpWalk->IsNode())
            {
                Assert( ptpWalk->IsBeginNode() || ptpWalk->IsEndNode() );
                
                if (ptpWalk->IsBeginNode())
                {
                    Assert( ptpWalk->IsEdgeScope() );
                    
                    pNode = ptpWalk->Branch();
                    pNode->Element()->_fMark1 = 1;

                    IGNORE_HR( aryNodes.Append( pNode ) );
                }
                else
                {
                    int cIncl, cPop;
                    //
                    // Walk the first half of the inclusion
                    //
                    
                    if( !ptpWalk->IsEdgeScope() )
                    {
                        ptpBeforeIncl = ptpWalk;
                    }

                    for ( cIncl = cPop = 0 ;
                          ! ptpWalk->IsEdgeScope() ;
                          cIncl++, ptpWalk = ptpWalk->NextTreePos() )
                    {
                        Assert( ptpWalk != ptpFinish && ptpWalk->IsEndNode() );
                        
                        Assert(
                            !ptpWalk->Branch()->Element()->_fMark1 ||
                            aryNodes [ aryNodes.Size() - cPop - 1 ] == ptpWalk->Branch() );

                        //
                        // We're counting the number of items to pop off the stack, not
                        // the number of non-edge nodes to the left of the inlcusion
                        //
                        
                        if (ptpWalk->Branch()->Element()->_fMark1)
                            cPop++;
                    }

                    //
                    // Mae sure we got to the kernel of the inclusion
                    //

                    Assert( ptpWalk->IsEndNode() );
                    Assert( aryNodes [ aryNodes.Size() - cPop - 1 ] == ptpWalk->Branch() );
                    
                    //
                    // Pop the number of elements before the one going out of scope plus
                    // the real one going out of scope;
                    //

                    aryNodes.SetSize( aryNodes.Size() - cPop - 1 );

                    //
                    // Reset the number of nodes which have already been verified to the current
                    // size of the stack.
                    //
                    
                    nNodesOk = aryNodes.Size();

                    //
                    // Walk the right hand side of the inclusion, putting the non
                    // kernel nodes back on.
                    //

                    while ( cIncl-- )
                    {
                        ptpWalk = ptpWalk->NextTreePos();

                        Assert( ptpWalk->IsBeginNode() && ! ptpWalk->IsEdgeScope() );

                        //
                        // Make sure we don't put an element on which does not participate
                        // in the "move".
                        //
                        
                        if (ptpWalk->Branch()->Element()->_fMark1)
                            aryNodes.Append( ptpWalk->Branch() );
                    }
                }

                break;
            }
        }

        if (fDone)
            break;
    }

    //
    // If we are here, then the validation got through with out
    // any conflicts.  In this case, clear the status pointer.
    //

    hr = THR( pPointerStatus->Unposition() );
    if (hr)
       goto Cleanup;
    
    Assert( hr == S_OK );

Cleanup:

    RRETURN1( hr, S_FALSE );
}

HRESULT 
CDoc::BeginUndoUnit( OLECHAR * pchDescription )
{
    HRESULT hr = S_OK;
    
    if (!pchDescription)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!_uOpenUnitsCounter)
    {
        _pMarkupServicesParentUndo = new CParentUndo( this );
        
        if (!_pMarkupServicesParentUndo)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR( _pMarkupServicesParentUndo->Start( pchDescription ) );
    }        

    _uOpenUnitsCounter++;

Cleanup:
    
    RRETURN( hr );
}

HRESULT 
CDoc::EndUndoUnit ( )
{
    HRESULT hr = S_OK;

    if (!_uOpenUnitsCounter)
        goto Cleanup;

    _uOpenUnitsCounter--;

    if (_uOpenUnitsCounter == 0)
    {
        Assert( _pMarkupServicesParentUndo );
        
        hr = _pMarkupServicesParentUndo->Finish( S_OK );
        
        delete _pMarkupServicesParentUndo;
    }

Cleanup:
    
    RRETURN( hr );
}

HRESULT
CDoc::IsScopedElement ( IHTMLElement * pIHTMLElement, BOOL * pfScoped )
{
    HRESULT hr = S_OK;
    CElement * pElement = NULL;

    if (!pIHTMLElement || !pfScoped || !IsOwnerOf( pIHTMLElement ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pIHTMLElement->QueryInterface( CLSID_CElement, (void **) & pElement ) );
    
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pfScoped = ! pElement->IsNoScope();
    
Cleanup:
    
    RRETURN( hr );
}


//
// TODO: These switchs are not the bast way to tdo this.  .asc perhaps ?
//

static ELEMENT_TAG_ID
TagIdFromETag ( ELEMENT_TAG etag )
{
    ELEMENT_TAG_ID tagID = TAGID_NULL;
    
    switch( etag )
    {
#define X(Y) case ETAG_##Y:tagID=TAGID_##Y;break;
    X(UNKNOWN) X(A) X(ACRONYM) X(ADDRESS) X(APPLET) X(AREA) X(B) X(BASE) X(BASEFONT)
    X(BDO) X(BGSOUND) X(BIG) X(BLINK) X(BLOCKQUOTE) X(BODY) X(BR) X(BUTTON) X(CAPTION)
    X(CENTER) X(CITE) X(CODE) X(COL) X(COLGROUP) X(COMMENT) X(DD) X(DEL) X(DFN) X(DIR)
    X(DIV) X(DL) X(DT) X(EM) X(EMBED) X(FIELDSET) X(FONT) X(FORM) X(FRAME)
    X(FRAMESET) X(H1) X(H2) X(H3) X(H4) X(H5) X(H6) X(HEAD) X(HR) X(HTML) X(I) X(IFRAME)
    X(IMG) X(INPUT) X(INS) X(KBD) X(LABEL) X(LEGEND) X(LI) X(LINK) X(LISTING)
    X(MAP) X(MARQUEE) X(MENU) X(META) X(NEXTID) X(NOBR) X(NOEMBED) X(NOFRAMES)
    X(NOSCRIPT) X(OBJECT) X(OL) X(OPTION) X(P) X(PARAM) X(PLAINTEXT) X(PRE) X(Q)
#ifdef  NEVER
    X(HTMLAREA)
#endif
    X(RP) X(RT) X(RUBY) X(S) X(SAMP) X(SCRIPT) X(SELECT) X(SMALL) X(SPAN) 
    X(STRIKE) X(STRONG) X(STYLE) X(SUB) X(SUP) X(TABLE) X(TBODY) X(TC) X(TD) X(TEXTAREA)
    X(TFOOT) X(TH) X(THEAD) X(TR) X(TT) X(U) X(UL) X(VAR) X(WBR) X(XMP) X(ROOT) X(OPTGROUP)
#undef X
        
    case ETAG_TITLE_ELEMENT :
    case ETAG_TITLE_TAG :
        tagID = TAGID_TITLE; break;
        
    case ETAG_GENERIC :
    case ETAG_GENERIC_BUILTIN :
    case ETAG_GENERIC_LITERAL :
        tagID = TAGID_GENERIC; break;
        
    case ETAG_RAW_COMMENT :
        tagID = TAGID_COMMENT_RAW; break;
    }

    AssertSz( tagID != TAGID_NULL, "Invalid ELEMENT_TAG" );

    return tagID;
}
    
ELEMENT_TAG
ETagFromTagId ( ELEMENT_TAG_ID tagID )
{
    ELEMENT_TAG etag = ETAG_NULL;
    
    switch( tagID )
    {
#define X(Y) case TAGID_##Y:etag=ETAG_##Y;break;
    X(UNKNOWN) X(A) X(ACRONYM) X(ADDRESS) X(APPLET) X(AREA) X(B) X(BASE) X(BASEFONT)
    X(BDO) X(BGSOUND) X(BIG) X(BLINK) X(BLOCKQUOTE) X(BODY) X(BR) X(BUTTON) X(CAPTION)
    X(CENTER) X(CITE) X(CODE) X(COL) X(COLGROUP) X(COMMENT) X(DD) X(DEL) X(DFN) X(DIR)
    X(DIV) X(DL) X(DT) X(EM) X(EMBED) X(FIELDSET) X(FONT) X(FORM) X(FRAME)
    X(FRAMESET) X(GENERIC) X(H1) X(H2) X(H3) X(H4) X(H5) X(H6) X(HEAD) X(HR) X(HTML) X(I) X(IFRAME)
    X(IMG) X(INPUT) X(INS) X(KBD) X(LABEL) X(LEGEND) X(LI) X(LINK) X(LISTING)
    X(MAP) X(MARQUEE) X(MENU) X(META) X(NEXTID) X(NOBR) X(NOEMBED) X(NOFRAMES)
    X(NOSCRIPT) X(OBJECT) X(OL) X(OPTION) X(P) X(PARAM) X(PLAINTEXT) X(PRE) X(Q)
#ifdef  NEVER
    X(HTMLAREA)
#endif
    X(RP) X(RT) X(RUBY) X(S) X(SAMP) X(SCRIPT) X(SELECT) X(SMALL) X(SPAN) 
    X(STRIKE) X(STRONG) X(STYLE) X(SUB) X(SUP) X(TABLE) X(TBODY) X(TC) X(TD) X(TEXTAREA) 
    X(TFOOT) X(TH) X(THEAD) X(TR) X(TT) X(U) X(UL) X(VAR) X(WBR) X(XMP) X(ROOT) X(OPTGROUP)
#undef X
            
    case TAGID_TITLE : etag = ETAG_TITLE_ELEMENT; break;
    case TAGID_COMMENT_RAW : etag = ETAG_RAW_COMMENT; break;
    }

    AssertSz( etag != ETAG_NULL, "Invalid ELEMENT_TAG_ID" );

    return etag;
}

HRESULT
CDoc::GetElementTagId ( IHTMLElement * pIHTMLElement, ELEMENT_TAG_ID * ptagId )
{
    HRESULT hr;
    CElement * pElement = NULL;

    if (!pIHTMLElement || !ptagId || !IsOwnerOf( pIHTMLElement ))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pIHTMLElement->QueryInterface( CLSID_CElement, (void **) & pElement ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pElement->HasMasterPtr())
    {
        pElement = pElement->GetMasterPtr();
    }
    *ptagId = TagIdFromETag( pElement->Tag() );
    
Cleanup:

    RRETURN( hr );
}

HRESULT
CDoc::GetTagIDForName ( BSTR bstrName, ELEMENT_TAG_ID * ptagId )
{
    HRESULT hr = S_OK;
    
    if (!bstrName || !ptagId)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ptagId = TagIdFromETag( EtagFromName( bstrName, SysStringLen( bstrName ) ) );

Cleanup:

    RRETURN( hr );
}

HRESULT
CDoc::GetNameForTagID ( ELEMENT_TAG_ID tagId, BSTR * pbstrName )
{
    HRESULT hr = S_OK;
    
    if (!pbstrName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( FormsAllocString( NameFromEtag( ETagFromTagId( tagId ) ), pbstrName ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

HRESULT
CDoc::CreateElement (
    ELEMENT_TAG_ID   tagID,
    OLECHAR *        pchAttributes,
    IHTMLElement * * ppIHTMLElement )
{
    HRESULT     hr = S_OK;
    ELEMENT_TAG etag;
    CElement *  pElement = NULL;

    if (!ppIHTMLElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    etag = ETagFromTagId( tagID );

    if (etag == ETAG_NULL || etag == ETAG_ROOT )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(
        CreateElement(
            etag, & pElement,
            pchAttributes, pchAttributes ? _tcslen( pchAttributes ) : 0 ) );

    if (hr)
        goto Cleanup;

    hr = THR( pElement->QueryInterface( IID_IHTMLElement, (void **) ppIHTMLElement ) );

    if (hr)
        goto Cleanup;

Cleanup:

    CElement::ReleasePtr( pElement );

    RRETURN( hr );
}


HRESULT
CDoc::CloneElement (
    IHTMLElement *  pElementCloneThis,
    IHTMLElement ** ppElementClone )
{
    HRESULT hr;
    IHTMLDOMNode *pThisDOMNode = NULL;
    IHTMLDOMNode *pDOMNode = NULL;

    if (!pElementCloneThis || !ppElementClone)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pElementCloneThis->QueryInterface( IID_IHTMLDOMNode, (void **) & pThisDOMNode ) );

    if (hr)
        goto Cleanup;

    // BUBUG rgardner - should this be Deep ?
    hr = THR( pThisDOMNode->cloneNode( FALSE /* Not Deep */, &pDOMNode ) );
    if (hr)
        goto Cleanup;

    hr = THR( pDOMNode->QueryInterface ( IID_IHTMLElement, (void**)ppElementClone ));
    if (hr)
        goto Cleanup;

Cleanup:

    ClearInterface( & pThisDOMNode );
    ClearInterface( & pDOMNode );
    
    RRETURN( hr );
}

HRESULT
CDoc::CreateMarkupContainer ( IMarkupContainer * * ppIMarkupContainer )
{
    HRESULT   hr;
    CMarkup * pMarkup = NULL;

    if (!ppIMarkupContainer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // WINDOWEDMARKUP - This is only available to binary code
    hr = THR( CreateMarkup( & pMarkup, PrimaryMarkup() ) );
    if (hr)
        goto Cleanup;

    hr = THR( pMarkup->SetOrphanedMarkup( TRUE ) );
    if( hr )
        goto Cleanup;

    hr = THR(
        pMarkup->QueryInterface(
            IID_IMarkupContainer, (void **) ppIMarkupContainer ) );
    if (hr)
        goto Cleanup;

Cleanup:

    if (pMarkup)
        pMarkup->Release();

    RRETURN( hr );
}


///////////////////////////////////////////////////////
//  tree service helper functions


BOOL
CDoc::IsOwnerOf ( IHTMLElement * pIElement )
{
    HRESULT    hr;
    BOOL       result = FALSE;
    CElement * pElement;

    hr = THR( pIElement->QueryInterface( CLSID_CElement, (void **) & pElement ) );
    
    if (hr)
        goto Cleanup;

    result = this == pElement->Doc();

Cleanup:
    return result;
}


BOOL
CDoc::IsOwnerOf ( IMarkupPointer * pIPointer )
{
    HRESULT         hr;
    BOOL            result = FALSE;
    CMarkupPointer  *pPointer;

    hr =  THR(pIPointer->QueryInterface( CLSID_CMarkupPointer, (void **) & pPointer ) );
    if (hr)
        goto Cleanup;

    result = (this == pPointer->Doc());

Cleanup:        
    return result;
}

BOOL
CDoc::IsOwnerOf ( IHTMLTxtRange * pIRange )
{
    HRESULT         hr;
    BOOL            result = FALSE;
    CAutoRange *    pRange;

    hr = THR( pIRange->QueryInterface( CLSID_CRange, (void **) & pRange ) );
    
    if (hr)
        goto Cleanup;

    result = this == pRange->GetMarkup()->Doc();

Cleanup:
    
    return result;
}

BOOL
CDoc::IsOwnerOf ( IMarkupContainer * pContainer )
{
    HRESULT          hr;
    BOOL             result = FALSE;
    CMarkup         *pMarkup;

    hr = THR(pContainer->QueryInterface(CLSID_CMarkup, (void **)&pMarkup));
    if (hr)
        goto Cleanup;

    result = (this == pMarkup->Doc());

Cleanup:
    return result;
}

HRESULT
CDoc::CutCopyMove (
    IMarkupPointer * pIPointerStart,
    IMarkupPointer * pIPointerFinish,
    IMarkupPointer * pIPointerTarget,
    BOOL             fRemove )
{
    HRESULT          hr = S_OK;
    CMarkupPointer * pPointerStart;
    CMarkupPointer * pPointerFinish;
    CMarkupPointer * pPointerTarget = NULL;

    //
    // Check argument sanity
    //
    
    if (pIPointerStart  == NULL  || !IsOwnerOf( pIPointerStart  ) ||
        pIPointerFinish == NULL  || !IsOwnerOf( pIPointerFinish ) ||
        (pIPointerTarget != NULL && !IsOwnerOf( pIPointerTarget )) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Get the internal objects
    //
    
    hr = THR(
        pIPointerStart->QueryInterface(
            CLSID_CMarkupPointer, (void **) & pPointerStart ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hr = THR(
        pIPointerFinish->QueryInterface(
            CLSID_CMarkupPointer, (void **) & pPointerFinish ) );

    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pIPointerTarget)
    {
        hr = THR(
            pIPointerTarget->QueryInterface(
                CLSID_CMarkupPointer, (void **) & pPointerTarget ) );

        if (hr)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    //
    // More sanity checks
    //

    if (!pPointerStart->IsPositioned() || !pPointerFinish->IsPositioned())
    {
        hr = CTL_E_UNPOSITIONEDPOINTER;
        goto Cleanup;
    }
    
    if (pPointerStart->Markup() != pPointerFinish->Markup())
    {
        hr = CTL_E_INCOMPATIBLEPOINTERS;
        goto Cleanup;
    }

    //
    // Make sure the start if before the finish
    //

    EnsureLogicalOrder( pPointerStart, pPointerFinish );

    //
    // More checks
    //

    if (pPointerTarget && !pPointerTarget->IsPositioned())
    {
        hr = CTL_E_UNPOSITIONEDPOINTER;
        goto Cleanup;
    }

    //
    // Do it
    //

    hr = THR(
        CutCopyMove(
            pPointerStart, pPointerFinish, pPointerTarget, fRemove, NULL ) );

Cleanup:

    RRETURN( hr );
}

HRESULT
CDoc::CutCopyMove (
    CMarkupPointer * pPointerStart,
    CMarkupPointer * pPointerFinish,
    CMarkupPointer * pPointerTarget,
    BOOL             fRemove,
    DWORD            dwFlags )
{
    HRESULT         hr = S_OK;
    CTreePosGap     tpgStart;
    CTreePosGap     tpgFinish;
    CTreePosGap     tpgTarget;
    CMarkup *       pMarkupSource = NULL;
    CMarkup *       pMarkupTarget = NULL;

    //
    // Sanity check the args
    //

    Assert( pPointerStart );
    Assert( pPointerFinish );
    Assert( OldCompare( pPointerStart, pPointerFinish ) <= 0 );
    Assert( pPointerStart->IsPositioned() );
    Assert( pPointerFinish->IsPositioned() );
    Assert( pPointerStart->Markup() == pPointerFinish->Markup() );
    Assert( ! pPointerTarget || pPointerTarget->IsPositioned() );

    //
    // Make sure unembedded pointers get in before the modification
    //

    hr = THR( pPointerStart->Markup()->EmbedPointers() );

    if (hr)
        goto Cleanup;

    if (pPointerTarget)
    {
        hr = THR( pPointerTarget->Markup()->EmbedPointers() );

        if (hr)
            goto Cleanup;
    }

    //
    // Set up the gaps
    //
    
    tpgStart.MoveTo( pPointerStart->GetEmbeddedTreePos(), TPG_LEFT );
    tpgFinish.MoveTo( pPointerFinish->GetEmbeddedTreePos(), TPG_RIGHT );
    
    if (pPointerTarget)
        tpgTarget.MoveTo( pPointerTarget->GetEmbeddedTreePos(), TPG_LEFT );

    pMarkupSource = pPointerStart->Markup();

    if (pPointerTarget)
        pMarkupTarget = pPointerTarget->Markup();

    //
    // Do it.
    //
    
    if (pPointerTarget)
    {
        hr = THR(
            pMarkupSource->SpliceTreeInternal(
                & tpgStart, & tpgFinish, pPointerTarget->Markup(),
                & tpgTarget, fRemove, dwFlags ) );

        if (hr)
            goto Cleanup;
    }
    else
    {
        Assert( fRemove );
        
        hr = THR(
            pMarkupSource->SpliceTreeInternal(
                & tpgStart, & tpgFinish, NULL, NULL, fRemove, dwFlags ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}



HRESULT         
CDoc::CreateMarkup(CMarkup ** ppMarkup,
                   CMarkup * pMarkupContext,
                   BOOL fIncrementalAlloc,
                   BOOL fPrimary,
                   COmWindowProxy * pWindowPending
                   DBG_COMMA WHEN_DBG(BOOL fWillHaveWindow))
{
    HRESULT         hr;
    CRootElement *  pRootElement = NULL;
    CMarkup *       pMarkup = NULL;

    Assert(ppMarkup);
    Assert( pMarkupContext || fPrimary || pWindowPending || fWillHaveWindow );

    if( _fClearingOrphanedMarkups )
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    pRootElement = new CRootElement(this);
    
    if (!pRootElement)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pMarkup = new CMarkup(this, fIncrementalAlloc);
    if (!pMarkup)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (fPrimary)
    {

        // Set the flag for trust under HTAs. Since this is the primary markup, 
        // we can use the HTA flag of the CDoc directly.
        // This flag is used within the EnsureWindow, so must set it here.
        pMarkup->SetMarkupTrusted(_fHostedInHTA || _fInTrustedHTMLDlg);

        hr = THR(pMarkup->CreateWindowHelper());
        if (hr)
            goto Cleanup;
            
        _pWindowPrimary = pMarkup->Window();
        Assert(_pWindowPrimary);
        _pWindowPrimary->AddRef();

        _pWindowPrimary->Window()->SetWindowIndex(WID_TOPWINDOW);
    }
    else if( pMarkupContext )
    {
        pMarkup->SetWindowedMarkupContextPtr( pMarkupContext );
        pMarkupContext->SubAddRef();
    }

    if (pWindowPending)
    {
        
        CWindow *   pWindow             = pWindowPending->Window();
        CMarkup *   pMarkupPendingOld   = pWindow->_pMarkupPending;
        DWORD       dwFrameOptionsOld   = pWindow->_pMarkup->GetFrameOptions();
        mediaType   mtOld               = pWindow->_pMarkup->GetMedia();
        
        Assert(pWindow->Doc() == this);
        if (pMarkupPendingOld)
            pWindow->ReleaseMarkupPending(pMarkupPendingOld);

        hr = pMarkup->SetWindow(pWindowPending);
        if (hr)
            goto Cleanup;

        pMarkup->_fWindowPending = TRUE;

        pWindow->_pMarkupPending = pMarkup;
        pMarkup->AddRef();  // The pending CWindow owns the markup

        // TODO (KTam): If we need to copy even more stuff from the
        // old markup, consider a helper fn.

        // Copy frame options from the old markup to the new one
        if (dwFrameOptionsOld)
        {
            hr = THR(pMarkup->SetFrameOptions(dwFrameOptionsOld));
            if (hr)
                goto Cleanup;
        }

        pMarkup->SetMarkupTrusted(pWindow->_pMarkup->IsMarkupTrusted());

        // Copy media from old markup to the new one
        if ( mtOld != mediaTypeNotSet )
        {
            hr = THR(pMarkup->SetMedia(mtOld));
            if (hr)
                goto Cleanup;
        }
    }

    hr = THR(pRootElement->Init());
    if (hr)
        goto Cleanup;

    {
        CElement::CInit2Context   context(NULL, pMarkup);

        hr = THR(pRootElement->Init2(&context));
        if (hr)
            goto Cleanup;
    }

    hr = THR(pMarkup->Init(pRootElement));
    if (hr)
        goto Cleanup;

    SetEditBitsForMarkup( pMarkup );
    
    *ppMarkup = pMarkup;
    pMarkup = NULL;

Cleanup:
    if (pMarkup)
        pMarkup->Release();

    CElement::ReleasePtr(pRootElement);
    RRETURN(hr);
}


HRESULT         
CDoc::CreateMarkupWithElement( 
    CMarkup ** ppMarkup, 
    CElement * pElement,
    BOOL       fIncrementalAlloc)
{
    HRESULT   hr = S_OK;
    CMarkup * pMarkup = NULL;

    Assert( pElement && !pElement->IsInMarkup() );

    hr = THR( CreateMarkup( &pMarkup, pElement->GetWindowedMarkupContext(), fIncrementalAlloc ) );
    if (hr)
        goto Cleanup;

    hr = THR( pMarkup->SetOrphanedMarkup( TRUE ) );
    if( hr )
        goto Cleanup;

    // Insert the element into the empty tree
    
    {
        CTreePos * ptpRootBegin = pMarkup->FirstTreePos();
        CTreePos * ptpNew;
        CTreeNode *pNodeNew;

        Assert( ptpRootBegin );
    
        // Assert that the only thing in this tree is two WCH_NODE characters
        Assert( pMarkup->Cch() == 2 );

        pNodeNew = new CTreeNode( pMarkup->Root()->GetFirstBranch(), pElement );
        if( !pNodeNew )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        Assert( pNodeNew->GetEndPos()->IsUninit() );
        ptpNew = pNodeNew->InitEndPos( TRUE );
        hr = THR( pMarkup->Insert( ptpNew, ptpRootBegin, FALSE ) );
        if(hr)
        {
            // The node never made it into the tree
            // so delete it
            delete pNodeNew;

            goto Cleanup;
        }

        Assert( pNodeNew->GetBeginPos()->IsUninit() );
        ptpNew = pNodeNew->InitBeginPos( TRUE );
        hr = THR( pMarkup->Insert( ptpNew, ptpRootBegin, FALSE ) );
        if(hr)
            goto Cleanup;

        pNodeNew->PrivateEnterTree();

        pElement->SetMarkupPtr( pMarkup );
        pElement->__pNodeFirstBranch = pNodeNew;
        pElement->PrivateEnterTree();

        {
            CNotification   nf;
            nf.ElementEntertree(pElement);
            pElement->Notify(&nf);
        }

        // Insert the WCH_NODE characters for the element
        // The 2 is hardcoded since we know that there are
        // only 2 WCH_NODE characters for the root
        Verify(
            ULONG(
                CTxtPtr( pMarkup, 2 ).
                    InsertRepeatingChar( 2, WCH_NODE ) ) == 2 );

        // Don't send a notification but do update the 
        // debug character count
        WHEN_DBG( pMarkup->_cchTotalDbg += 2 );
        WHEN_DBG( pMarkup->_cElementsTotalDbg += 1 );

        Assert( pMarkup->IsNodeValid() );

    }

    if (ppMarkup)
    {
        *ppMarkup = pMarkup;
        pMarkup->AddRef();
    }
    
Cleanup:
    if(pMarkup)
        pMarkup->Release();

    RRETURN(hr);
}


#if DBG==1

struct TagPos
{
    IHTMLElement * pel;
    BOOL           fEnd;
    TCHAR *        pText;
    long           cch;
};

void
Stuff ( CDoc * pDoc, IMarkupServices * pms, IHTMLElement * pIElement )
{
    HRESULT            hr = S_OK;
    IHTMLDocument2 *   pDoc2    = NULL;
    IMarkupServices *  pMS      = NULL;
    IMarkupContainer2* pMarkup  = NULL;
    IMarkupPointer *   pPtr1    = NULL, * pPtr2 = NULL;
    IMarkupPointer2 *  pmp2     = NULL;
    TCHAR          *   pstrFrom = _T( "XY" );
    TCHAR          *   pstrTo = _T( "AB" );
    
    pDoc->QueryInterface( IID_IHTMLDocument2, (void **) & pDoc2 );

    pDoc2->QueryInterface( IID_IMarkupContainer2, (void **) & pMarkup );
    pDoc2->QueryInterface( IID_IMarkupServices, (void **) & pMS );

    pMS->CreateMarkupPointer( & pPtr1 );
    pMS->CreateMarkupPointer( & pPtr2 );

    //
    // Set gravity of this pointer so that when the replacement text is inserted
    // it will float to be after it.
    //

    pPtr1->SetGravity( POINTER_GRAVITY_Right );

    //
    // Start the seach at the beginning of the primary container
    //

    pPtr1->MoveToContainer( pMarkup, TRUE );

    for ( ; ; )
    {
        long nFoo;

        hr = pPtr1->FindText( pstrFrom, 0, pPtr2, NULL );


        if (hr == S_FALSE)
            break;

        pMS->Remove( pPtr1, pPtr2 );
        
        pMS->InsertText( pstrTo, -1, pPtr1 );
        nFoo = pMarkup->GetVersionNumber();
    }

    pPtr1->QueryInterface( IID_IMarkupPointer2, (void **)&pmp2 );

    pmp2->MoveToContainer( pMarkup, TRUE );
    pPtr2->MoveToPointer( pmp2 );
    for( int i = 0; i < 5; i++ )
    {
        pPtr2->MoveUnit( MOVEUNIT_NEXTWORDBEGIN );
    }

    pmp2->MoveToContainer( pMarkup, TRUE );
    
    pmp2->MoveUnitBounded( MOVEUNIT_NEXTURLBEGIN, pPtr2 );

    ReleaseInterface( pPtr1 );
    ReleaseInterface( pPtr2 );
    ReleaseInterface( pmp2 );
    ReleaseInterface( pMS );
    ReleaseInterface( pMarkup );
    ReleaseInterface( pDoc2 );
}

void
TestTreeSync2( CDoc * pDoc, IMarkupServices *pms )
{
    IHTMLDocument2          *   pDoc2       = NULL;
    IMarkupContainer2       *   pMarkup2    = NULL;
    IMarkupServices         *   pMS         = NULL;
    IHTMLChangeLog          *   pChangeLog  = NULL;
    static CChangeSink      *   pChangeSink = NULL;
    IHTMLIFrameElement2     *   pFrameSrc   = NULL;
    IHTMLIFrameElement2     *   pFrameDest  = NULL;
    IHTMLFramesCollection2  *   pcolFrames  = NULL;
    IHTMLElement            *   pElemSrc    = NULL;
    IHTMLElement            *   pElemDest   = NULL;
    IDispatchEx             *   pDispSrc    = NULL;
    IDispatchEx             *   pDispDest   = NULL;
    IMarkupPointer2         *   pMP         = NULL;
    IHTMLDocument2          *   pDocSrc     = NULL;
    IHTMLDocument2          *   pDocDest    = NULL;
    IMarkupContainer2       *   pMarkupSrc  = NULL;
    IMarkupContainer2       *   pMarkupDest = NULL;
    BSTR                        bstr        = NULL;
    CMarkup                 *   pMarkup     = NULL;
    VARIANT                     vt;
    VARIANT                     vt2;
    DISPID                      dispid;
    HRESULT                     hr;
    long                        nFrames;

    VariantInit(&vt);
    VariantInit(&vt2);


    if( !pChangeSink )
    {
        hr = pDoc->QueryInterface( IID_IHTMLDocument2, (void **)&pDoc2 );
        hr = pDoc->QueryInterface( IID_IMarkupContainer2, (void **)&pMarkup2);
        hr = pDoc->QueryInterface( IID_IMarkupServices, (void **)&pMS);

#if 0
        // This don't work, because you can't edit a just-inserted IFRAME
        // Create a bunch of shit
        hr = pMS->CreateElement( TAGID_IFRAME, _T("id=srcFrame"), &pElemSrc );
        hr = pMS->CreateElement( TAGID_IFRAME, _T("id=destFrame"), &pElemDest );
        hr = pElemSrc->QueryInterface( IID_IHTMLIFrameElement2, (void **)&pFrameSrc );
        hr = pElemDest->QueryInterface( IID_IHTMLIFrameElement2, (void **)&pFrameDest );
        hr = pElemSrc->QueryInterface( IID_IDispatchEx, (void **)&pDispSrc);
        hr = pElemDest->QueryInterface( IID_IDispatchEx, (void **)&pDispDest );
        hr = pMS->CreateMarkupPointer( (IMarkupPointer **)&pMP );

        // Insert the IFRAMEs
        hr = pMP->MoveToMarkupPosition( pMarkup2, 9 );
        hr = pMP->SetGravity( POINTER_GRAVITY_Right );
        hr = pMS->InsertElement( pElemSrc, pMP, pMP );
        hr = pMS->InsertElement( pElemDest, pMP, pMP );

        // Make them pretty
        V_VT(&vt) = VT_I4;
        V_I4(&vt) = 100;
        hr = pFrameSrc->put_width( vt );
        hr = pFrameSrc->put_height( vt );
        hr = pFrameDest->put_width( vt );
        hr = pFrameDest->put_height( vt );
#endif // 0

        // Get the frame windows
        hr = pDoc2->get_frames( &pcolFrames );
        hr = pcolFrames->get_length( &nFrames );

        if( nFrames == 2 )
        {
            // If we have 2 frames, have the first one TreeSync into the second
            V_VT(&vt) = VT_I4;
            V_I4(&vt) = 0;
            hr = pcolFrames->item( &vt, &vt2 );
            V_DISPATCH(&vt2)->QueryInterface( IID_IDispatchEx, (void **)&pDispSrc );
            VariantClear(&vt2);
        
            V_I4(&vt) = 1;
            hr = pcolFrames->item( &vt, &vt2 );
            V_DISPATCH(&vt2)->QueryInterface( IID_IDispatchEx, (void **)&pDispDest );
            VariantClear(&vt2);

            // Get their documents
            bstr = SysAllocString( _T("document") );

            hr = pDispSrc->GetDispID( bstr, 0, &dispid );

            hr = GetDispProp( pDispSrc,
                              dispid,
                              g_lcidUserDefault,
                              &vt2,
                              NULL,
                              0);
            hr = V_DISPATCH(&vt2)->QueryInterface( IID_IHTMLDocument2, (void **)&pDocSrc );
            VariantClear(&vt2);

            hr = GetDispProp( pDispDest,
                             dispid,
                             g_lcidUserDefault,
                             &vt2,
                             NULL,
                             0);
            hr = V_DISPATCH(&vt2)->QueryInterface( IID_IHTMLDocument2, (void **)&pDocDest );
            VariantClear(&vt2);

            // Get their markup containers
            hr = pDocSrc->QueryInterface( IID_IMarkupContainer2, (void **)&pMarkupSrc );
            hr = pDocDest->QueryInterface( IID_IMarkupContainer2, (void **)&pMarkupDest );

            // And do this shit
            pChangeSink = new CChangeSink( NULL );

            hr = pMarkupSrc->CreateChangeLog( pChangeSink, &pChangeLog, TRUE, TRUE );
            hr = pMarkupSrc->QueryInterface( CLSID_CMarkup, (void **)&pMarkup );

            Verify( pChangeSink->_pLogMgr = pMarkup->GetLogManager() );
            Verify( pChangeSink->_pLog = pChangeLog );
            pChangeSink->_pMarkupSync = pMarkupDest;
            pChangeSink->_pMarkupSync->AddRef();
        }
        else
        {
            // Just set up TreeSync dumping on the primary markup
            pChangeSink = new CChangeSink( NULL );
            hr = pMarkup2->CreateChangeLog( pChangeSink, &pChangeLog, TRUE, TRUE );
            hr = pMarkup2->QueryInterface( CLSID_CMarkup, (void **)&pMarkup );
            Verify( pChangeSink->_pLogMgr = pMarkup->GetLogManager() );
            Verify( pChangeSink->_pLog = pChangeLog );
        }
    }
    else
    {
        ClearInterface( &pChangeSink->_pLog );
        pChangeSink->Release();
        pChangeSink = NULL;
    }

//Cleanup:
    ReleaseInterface( pDoc2 );
    ReleaseInterface( pMarkup2 );
    ReleaseInterface( pMS );
    ReleaseInterface( pFrameSrc );
    ReleaseInterface( pFrameDest );
    ReleaseInterface( pcolFrames );
    ReleaseInterface( pElemSrc );
    ReleaseInterface( pElemDest );
    ReleaseInterface( pDispSrc );
    ReleaseInterface( pDispDest );
    ReleaseInterface( pMP );
    ReleaseInterface( pDocSrc );
    ReleaseInterface( pDocDest );
    ReleaseInterface( pMarkupSrc );
    ReleaseInterface( pMarkupDest );
    SysFreeString( bstr );
//    ReleaseInterface();
}

void
TestTreeSync( CDoc * pDoc, IMarkupServices *pms )
{
    IHTMLDocument2      *   pDoc2       = NULL;
    IMarkupContainer2   *   pMarkup2    = NULL;
    IHTMLChangeLog      *   pChangeLog  = NULL;
    static CChangeSink  *   pChangeSink = NULL;
    CMarkup             *   pMarkup     = NULL;
    BOOL                    fCheat      = FALSE;
    HRESULT                 hr;

    pDoc->QueryInterface( IID_IHTMLDocument2, (void **)&pDoc2 );
    pDoc2->QueryInterface( IID_IMarkupContainer2, (void **)&pMarkup2 );
    pMarkup = pDoc->PrimaryMarkup();         // ptr to primary window

    if( !pChangeSink )
    {
        pChangeSink = new CChangeSink( pMarkup->GetLogManager() );

        if( FAILED( pMarkup2->CreateChangeLog( pChangeSink, &pChangeLog, TRUE, TRUE ) ) )
        {
            delete pChangeSink;
            goto Cleanup;
        }

        if( fCheat )
        {
            pChangeSink->_pMarkupSync = pMarkup2;
            pChangeSink->_pMarkupSync->AddRef();
        }
        pChangeSink->Release();
        pChangeSink->_pLog = pChangeLog;
        Verify( pChangeSink->_pLogMgr = pMarkup->GetLogManager() );
    }
    else
    {
        if( fCheat )
        {
            IStream         * pstm;
            IMarkupContainer * pMC;

            hr = pMarkup2->QueryInterface( IID_IMarkupContainer, (void **)&pMC );
            hr = CoMarshalInterThreadInterfaceInStream( IID_IMarkupContainer, pMarkup2, &pstm );
        }

        // Ditch the Log
        ClearInterface( &pChangeSink->_pLog );
        // We should really have held a sub ref on the sink, but it's debug code so I don't care.
        pChangeSink = NULL;
    }

Cleanup:
    ReleaseInterface( pDoc2 );
    ReleaseInterface( pMarkup2 );
}

void
TestMarkupServices ( CElement * pElement )
{
    IMarkupServices * pIMarkupServices = NULL;
    IMarkupContainer * pMarkupContainer = NULL;
    IHTMLElement *pIElement = NULL;
    CDoc *pDoc = pElement->Doc();
    IMarkupPointer * mp1 = NULL, * mp2 = NULL;
#ifdef TESTGLOBAL
    HGLOBAL hGlobal = NULL;
    TCHAR * pch = NULL;
#endif

    pElement->QueryInterface( IID_IHTMLElement, (void * *) & pIElement );
    pDoc->QueryInterface( IID_IMarkupServices, (void * *) & pIMarkupServices );
    pDoc->QueryInterface( IID_IMarkupContainer, (void **) & pMarkupContainer );

    pIMarkupServices->CreateMarkupPointer( & mp1 );
    pIMarkupServices->CreateMarkupPointer( & mp2 );

    mp1->MoveToContainer( pMarkupContainer, TRUE );
    
    mp1->Right( TRUE, NULL, NULL, NULL, NULL );
    mp1->Right( TRUE, NULL, NULL, NULL, NULL );
    mp1->Right( TRUE, NULL, NULL, NULL, NULL );
    mp1->Right( TRUE, NULL, NULL, NULL, NULL );
    mp1->Right( TRUE, NULL, NULL, NULL, NULL );
    mp1->Right( TRUE, NULL, NULL, NULL, NULL );
    mp1->Right( TRUE, NULL, NULL, NULL, NULL );

    mp2->MoveToPointer( mp1 );
    
    mp2->Right( TRUE, NULL, NULL, NULL, NULL );
    mp2->Right( TRUE, NULL, NULL, NULL, NULL );
    mp2->Right( TRUE, NULL, NULL, NULL, NULL );
    mp2->Right( TRUE, NULL, NULL, NULL, NULL );
    mp2->Right( TRUE, NULL, NULL, NULL, NULL );

    // pIMarkupServices->Remove( mp1, mp2 );

    Stuff( pDoc, pIMarkupServices, pIElement );

    // TestTreeSync( pDoc, pIMarkupServices );
    TestTreeSync2( pDoc, pIMarkupServices );

#ifdef TESTGLOBAL
    ReleaseInterface( pMarkupContainer );
    hGlobal = GlobalAlloc( GMEM_MOVEABLE, 4096 );
    pch = (TCHAR *)GlobalLock( hGlobal );
    _tcscpy( pch, _T("<HTML><BODY>Hi</BODY></HTML>") );
    GlobalUnlock( hGlobal );
    pIMarkupServices->ParseGlobal( hGlobal, 0, &pMarkupContainer, mp1, mp2 );
    GlobalFree( hGlobal );
#endif

    ReleaseInterface( pIMarkupServices );
    ReleaseInterface( pIElement );
    ReleaseInterface( pMarkupContainer );
    ReleaseInterface( mp1 );
    ReleaseInterface( mp2 );
}

#endif // DBG==1



HRESULT
CDoc::ValidateElements (
    IMarkupPointer  *pPointerStart,
    IMarkupPointer  *pPointerFinish,
    IMarkupPointer  *pPointerTarget,
    IMarkupPointer  *pPointerStatus,
    IHTMLElement    **ppElemFailBottom,
    IHTMLElement    **ppElemFailTop )
{
    HRESULT         hr;
    HRESULT         hrResult = S_OK;
    CMarkupPointer  *pPointerStartInternal = NULL;
    CMarkupPointer  *pPointerFinishInternal = NULL;
    CMarkupPointer  *pPointerTargetInternal = NULL;
    CMarkupPointer  *pPointerStatusInternal = NULL;
    CTreeNode       *pNodeFailBottom = NULL;
    CTreeNode       *pNodeFailTop = NULL;

    //
    // check argument sanity
    //
    if (!pPointerStart || !pPointerFinish)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (ppElemFailBottom)
        *ppElemFailBottom = NULL;

    if (ppElemFailTop)
        *ppElemFailTop = NULL;

    hr = THR( pPointerStart->QueryInterface(CLSID_CMarkupPointer, (LPVOID *)&pPointerStartInternal) );
    if (hr)
        goto Cleanup;

    hr = THR( pPointerFinish->QueryInterface(CLSID_CMarkupPointer, (LPVOID *)&pPointerFinishInternal) );
    if (hr)
        goto Cleanup;

    //
    // pPointerStart/pPointerEnd should be positioned and in the same markup
    //

    if (!pPointerStartInternal->IsPositioned()
        || !pPointerFinishInternal->IsPositioned()
        || pPointerStartInternal->Markup() != pPointerFinishInternal->Markup())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pPointerStatus)
    {
        hr = THR( pPointerStatus->QueryInterface(CLSID_CMarkupPointer, (LPVOID *)&pPointerStatusInternal) );
        if (hr)
            goto Cleanup;

        //
        // Validate pPointerStatus position
        //
        if (pPointerStatusInternal->IsPositioned())
        {
            if (pPointerStatusInternal->Markup() != pPointerStartInternal->Markup()
                || !pPointerStatusInternal->IsRightOfOrEqualTo(pPointerStartInternal)
                || !pPointerStatusInternal->IsLeftOfOrEqualTo(pPointerFinishInternal)
                )
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
        }
    }

    if (pPointerTarget)
    {
        hr = THR( pPointerTarget->QueryInterface(CLSID_CMarkupPointer, (LPVOID *)&pPointerTargetInternal) );
        if (hr)
            goto Cleanup;
    }

    if (pPointerTargetInternal && pPointerTargetInternal->Markup() == pPointerStartInternal->Markup())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Delegate and propagate the S_OK/S_FALSE distinction
    //
    hrResult = THR( ValidateElements(
                pPointerStartInternal, 
                pPointerFinishInternal, 
                pPointerTargetInternal, 
                0 /* dwFlags */,
                pPointerStatusInternal,
                &pNodeFailBottom,
                &pNodeFailTop) );

    if (FAILED(hrResult))
    {
        hr = hrResult;
        goto Cleanup;
    }

    if (ppElemFailBottom)
    {
        if (pNodeFailBottom)
        {
            hr = THR( pNodeFailBottom->GetElementInterface(IID_IHTMLElement, (LPVOID *)ppElemFailBottom) );
            if (hr)
                goto Cleanup;
        }
        else
        {
            *ppElemFailBottom = NULL;
        }
    }

    if (ppElemFailTop)
    {
        if (pNodeFailTop)
        {
            hr = THR( pNodeFailTop->GetElementInterface(IID_IHTMLElement, (LPVOID *)ppElemFailTop) );
            if (hr)
                goto Cleanup;
        }
        else
        {
            *ppElemFailTop = NULL;
        }
    }

Cleanup:
    if (SUCCEEDED(hr))
        hr = hrResult;

    RRETURN1(hr, S_FALSE);
}

HRESULT
CDoc::ParseGlobalEx (
    HGLOBAL              hGlobal,
    DWORD                dwFlags,
    IMarkupContainer     *pIContextMarkup,
    IMarkupContainer     **ppIContainerResult,
    IMarkupPointer       *pIPointerSelStart,
    IMarkupPointer       *pIPointerSelFinish )
{
    HRESULT          hr = S_OK;
    CMarkup *        pMarkup = NULL;
    CMarkupPointer * pPointerSelStart = NULL;
    CMarkupPointer * pPointerSelFinish = NULL;
    CMarkup *        pContextMarkup = NULL;

    if (!ppIContainerResult)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppIContainerResult = NULL;

    if (!hGlobal)
        goto Cleanup;

    if (pIPointerSelStart)
    {
        hr = THR(
            pIPointerSelStart->QueryInterface(
                CLSID_CMarkupPointer, (void **) & pPointerSelStart ) );

        if (hr)
            goto Cleanup;
    }

    if (pIPointerSelFinish)
    {
        hr = THR(
            pIPointerSelFinish->QueryInterface(
                CLSID_CMarkupPointer, (void **) & pPointerSelFinish ) );

        if (hr)
            goto Cleanup;
    }

    if (pIContextMarkup)
    {
        hr = THR(
            pIContextMarkup->QueryInterface(
                CLSID_CMarkup, (void **)&pContextMarkup) );

        if (hr)
            goto Cleanup;
    }

    hr = THR(
        ParseGlobal(
            hGlobal, dwFlags, pContextMarkup, & pMarkup, pPointerSelStart, pPointerSelFinish ) );

    if (hr)
        goto Cleanup;

    if (pMarkup)
    {
        hr = THR(
            pMarkup->QueryInterface(
                IID_IMarkupContainer, (void **) ppIContainerResult ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    if (pMarkup)
        pMarkup->Release();

    RRETURN( hr );
}


//+====================================================================================
//
// Method: SaveSegmentsToClipboard
//
// Synopsis: Saves a SegmentList to the clipboard
//
//------------------------------------------------------------------------------------

HRESULT
#ifndef UNIX
CDoc::SaveSegmentsToClipboard( ISegmentList * pSegmentList,
                               DWORD dwFlags )
#else
CDoc::SaveSegmentsToClipboard( ISegmentList * pSegmentList, 
                               DWORD dwFlags,
                               VARIANTARG *pvarargOut)
#endif
{
    CMarkup      *      pMarkup;
    BOOL                fEqual;
    CTextXBag    *      pBag = NULL;
    IDataObject  *      pDO = NULL;
    HRESULT             hr = S_OK;
    DWORD               dwFlagsInternal = dwFlags & CREATE_FLAGS_ExternalMask;
    IMarkupPointer *    pStart  = NULL;
    IMarkupPointer *    pEnd = NULL;
    CMarkupPointer *    pointerStart = NULL;
    CMarkupPointer *    pointerEnd = NULL;
    CTreeNode *         pNodeStart;
    CTreeNode *         pNodeEnd;
    CTreeNode *         pAncestor;
    CWindow *           pWindow = NULL;

    ISegmentListIterator *pIter = NULL;
    ISegment             *pSegment = NULL;
#if DBG==1
    BOOL                 fEmpty = FALSE;
#endif
    
    hr = THR( CreateMarkupPointer( & pStart ));
    if ( hr )
        goto Cleanup;

    hr = THR( CreateMarkupPointer( & pEnd ));
    if ( hr )
        goto Cleanup;

    hr = THR( pSegmentList->CreateIterator( &pIter ));
    if ( hr )
        goto Cleanup;

#if DBG
    hr = THR( pSegmentList->IsEmpty( &fEmpty ) );
    if ( hr )
        goto Cleanup;

    Assert(!fEmpty);
#endif

    hr = THR( pIter->Current(&pSegment) );
    if ( hr )
        goto Cleanup;

    hr = THR( pSegment->GetPointers( pStart, pEnd ));
    if ( hr )
        goto Cleanup;

    hr = THR( pStart->IsEqualTo ( pEnd, & fEqual ) );
    if (hr)
        goto Cleanup;

    if (fEqual)
    {
        // There is nothing to save
        hr = S_OK;
        goto Cleanup;
    }
    
    hr = THR( pStart->QueryInterface( CLSID_CMarkupPointer, ( void** ) & pointerStart));
    if ( hr )
        goto Cleanup;

    hr = THR( pEnd->QueryInterface( CLSID_CMarkupPointer, ( void** ) & pointerEnd));
    if ( hr )
        goto Cleanup;

    Assert( pointerStart->IsPositioned() && pointerEnd->IsPositioned() );

    pMarkup = pointerStart->Markup();
    if ( pMarkup != pointerEnd->Markup() )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pNodeStart = pointerStart->CurrentScope( MPTR_SHOWSLAVE );
    pNodeEnd   = pointerEnd->CurrentScope( MPTR_SHOWSLAVE );
    
    if ( !pNodeStart || !pNodeEnd )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    pAncestor = pNodeStart->GetFirstCommonAncestor( pNodeEnd, NULL );

    if( pAncestor && pAncestor->SupportsHtml() )
    {
        dwFlagsInternal |= CREATE_FLAGS_SupportsHtml;
    }

    hr = THR( CTextXBag::Create( 
            pMarkup, dwFlagsInternal, pSegmentList, FALSE, & pBag) );
                                                                  
    if (hr)
        goto Cleanup;

#ifdef UNIX // This is used for MMB-paste to save selected text to buffer.
    if (pvarargOut)
    {
        if (pBag->_hUnicodeText)
        {
            hr = THR(g_uxQuickCopyBuffer.GetTextSelection(pBag->_hUnicodeText,
                                                          TRUE,
                                                          pvarargOut));
        }
        else
        {
            hr = THR(g_uxQuickCopyBuffer.GetTextSelection(pBag->_hText,
                                                          FALSE,
                                                          pvarargOut));
        }
        goto Cleanup;
    }
#endif // UNIX

    hr = THR(pBag->QueryInterface(IID_IDataObject, (void **) & pDO ));
    if (hr)
        goto Cleanup;

    Assert(pMarkup->GetWindowedMarkupContext());

    pWindow = pMarkup->GetWindowedMarkupContext()->GetWindowPending()->Window();

    hr = THR( pWindow->SetClipboard( pDO ) );
    if (hr)
        goto Cleanup;

Cleanup:
    if( pBag )
    {
        pBag->Release();
    }
    ReleaseInterface( pDO );
    ReleaseInterface( pStart );
    ReleaseInterface( pEnd );
    ReleaseInterface( pIter );
    ReleaseInterface( pSegment );

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\unitmeas.cxx ===
//+---------------------------------------------------------------------
//
//   File:      uniutmeas.cxx
//
//  Contents:   Unit Measurement element class, etc..
//
//  Classes:    CUnitMeasurement, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_UNITMEAS_HXX_
#define X_UNITMEAS_HXX_
#include "unitmeas.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#define _cxx_
#include "unitmeas.hdl"

DEFINE_SUBOBJECT_CREATOR(CUnitMeasurement );

CBase::CLASSDESC CUnitMeasurement::s_classdesc =
{
    &CLSID_UnitMeasurement,         // _pclsid
    0,                              // _idrBase
    NULL,                           // property pages
    0,                              // _ccp
    0,                              // _pcpi
    0,                              // _dwFlags
    &IID_IUnitMeasurement,          // _piidDispinterface
    0,                              // _lAccRole
    0,                              // _pPropCats;
    0,                              // _appropdescs;
    s_apVTableInterf,               // _apvtableinterf
};

CUnitMeasurement::CUnitMeasurement ( CElement *pElemObj,
    PROPERTYDESC *pPropdesc,
    MEASURETYPE MeasureType )
{
    Assert ( pElemObj );
    Assert ( pPropdesc );
    _pElem = pElemObj;
    _pPropdesc = pPropdesc;
    _MeasureType = MeasureType;
    // Ref count the main object so it doesn't go away
    _pElem -> AddRef();
}

HRESULT CUnitMeasurement::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IDispatch)
    default:
        if (iid == IID_IUnitMeasurement)
        {
           *ppv = (IUnitMeasurement *) this;
        }
        else if ( iid == CLSID_UnitMeasurement )
        {
            // Internaly used QI to get the object ptr, just cast return type to class ptr
            *ppv = this;
            // Weak ref, don't AddRef() object
            return S_OK;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

HRESULT CUnitMeasurement::GetStoredUnitValue ( CUnitValue *puvValue )
{
    HRESULT hr = CallHandler ( HANDLEPROP_AUTOMATION, (void *)puvValue );
    RRETURN ( hr );
}

HRESULT CUnitMeasurement::CallHandler ( DWORD dwFlags, void *pvArg )
{
    BASICPROPPARAMS *pbpp = (BASICPROPPARAMS *)(_pPropdesc+1);
    HRESULT hr;
    CBase  *pBaseObject;
    void *pSubObject;

    if ( pbpp->dwPPFlags & PROPPARAM_ATTRARRAY )
    {
        pSubObject = (void *)&_pElem->_pAA;
    }
    else
    {
        pSubObject = (void *)_pElem;
    }
    pBaseObject = _pElem;

    hr = THR ( CALL_METHOD(_pPropdesc, _pPropdesc->pfnHandleProperty,
        ( dwFlags  , pvArg, pBaseObject, (CVoid *)pSubObject ) ));

    RRETURN ( hr );
}

HRESULT CUnitMeasurement::SetStoredUnitValue ( CUnitValue uvValue )
{
    HRESULT hr;

    hr = CallHandler ( HANDLEPROP_SET | HANDLEPROP_AUTOMATION, (void *)&uvValue );
    RRETURN ( hr );
}

long CUnitMeasurement::GetValueFromPixelRect ( void )
{
    POINT pos;
    SIZE  size;

    pos.x = pos.y = szie.cx size.cy = 0;

    if ( OTHERX != _MeasureType && OTHERY != _MeasureType &&
         STYLEOTHERX != _MeasureType && STYLEOTHERY != _MeasureType)
    {   // get's the layout position of site regardless if it is parked
        CLayout *pLayout = _pElem->GetUpdatedLayout();

        if(pLayout)
            pLayout->GetUnparkedPosition( &pos, &size );
    }

    switch ( _MeasureType )
    {
    case TOP:
    case STYLETOP:
        return pos.y;

    case LEFT:
    case STYLELEFT:
        return pos.x;

    case WIDTH:
    case STYLEWIDTH:
        return size.cx;

    case HEIGHT:
    case STYLEHEIGHT:
        return size.cy;

    default:
        return 0;
    }
}


HRESULT CUnitMeasurement::SetPixelValue ( long lValue )
{
    CUnitValue uvValue;
    HRESULT hr;

    // Set the value to the equivalent value of lValue pixels when expressed in
    // the current units of the unit value
    hr = GetStoredUnitValue ( &uvValue );
    if ( hr )
        goto Cleanup;

    if ( IsMeasureInXDirection() )
        hr = THR(uvValue.XSetFloatValueKeepUnits ( (float)lValue, CUnitValue::UNIT_PIXELS,
            GetValueFromPixelRect(), 1 ));
    else
        hr = THR(uvValue.YSetFloatValueKeepUnits ( (float)lValue, CUnitValue::UNIT_PIXELS,
            GetValueFromPixelRect(),1  ) );

    if ( hr )
        goto Cleanup;

    hr = THR(SetStoredUnitValue ( uvValue ));

Cleanup:
    RRETURN ( SetErrorInfo ( hr ) );
}

HRESULT CUnitMeasurement::put_value (float vValue)
{
    CUnitValue uvValue;
    CUnitValue::UNITVALUETYPE uvt;
    HRESULT hr;

#ifdef RGARDNER
    if ( !_pElem->ShouldHaveLayout() )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }
#endif

    // vValue represents the value of the property in the current
    // document units ( document.DefaultUnits ). Set the internal
    // value but keep the persisted unit the same.
    hr = THR ( GetStoredUnitValue ( &uvValue ) );
    if ( hr )
        goto Cleanup;

    uvt = uvValue.GetUnitType();

    // TODO rgardner. If we are put'ing an OTHERX/OTHERY, which has no
    // pixel value to get, we won't be able to convert if the unit is
    // currently in percent.
    if ( ( _MeasureType == OTHERX || _MeasureType == OTHERY || _MeasureType == STYLEOTHERX || _MeasureType == STYLEOTHERY ) &&
        ( uvt == CUnitValue::UNIT_PERCENT || uvt == CUnitValue::UNIT_TIMESRELATIVE ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ( IsMeasureInXDirection() )
    
        hr = THR(uvValue.XSetFloatValueKeepUnits ( vValue, GetDocUnits(),
            GetValueFromPixelRect(), 1 ));
    else
        hr = THR(uvValue.YSetFloatValueKeepUnits ( vValue, GetDocUnits(),
            GetValueFromPixelRect(), 1 ) );

    if ( hr )
        goto Cleanup;

    hr = SetStoredUnitValue ( uvValue );

Cleanup:
    RRETURN ( SetErrorInfo ( hr ) );
}



HRESULT CUnitMeasurement::get_value ( float *pvValue )
{
    // Get the current value into pvValue, expressed in the
    // default document units
    CUnitValue uvValue;
    HRESULT hr;

#ifdef RGARDNER
    if ( !_pElem->ShouldHaveLayout() )
    {
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }
#endif
	
    if ( !pvValue )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR ( GetStoredUnitValue ( &uvValue ) );
    if ( hr )
        goto Cleanup;

    if ( ! ( _MeasureType == OTHERX || _MeasureType == OTHERY || _MeasureType == STYLEOTHERX || _MeasureType == STYLEOTHERY ||
        CUnitValue::IsScalerUnit ( uvValue.GetUnitType() ) ) )
    {
        uvValue.SetValue ( GetValueFromPixelRect(), CUnitValue::UNIT_PIXELS );
    }

    if ( IsMeasureInXDirection() )
        *pvValue = uvValue.XGetFloatValueInUnits ( GetDocUnits()); 
    else
        *pvValue = uvValue.YGetFloatValueInUnits ( GetDocUnits());
Cleanup:
    RRETURN ( SetErrorInfo ( hr ) );

}

HRESULT CUnitMeasurement::put_unit ( BSTR bstrUnit )
{
    HRESULT hr;
    CUnitValue uvValue;
    DWORD dwPPFlags;
    CUnitValue::UNITVALUETYPE uvt;

    htmlUnits Unit;

    hr = ENUMFROMSTRING ( htmlUnits, bstrUnit, (long *)&Unit );
    if ( hr )
        goto Cleanup;

#ifdef RGARDNER
    if ( !_pElem->ShouldHaveLayout() )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }
#endif

    // Convert unit value into new units
    uvt =  (CUnitValue::UNITVALUETYPE) Unit;

    if ( uvt < 0 || uvt > CUnitValue::UNIT_TIMESRELATIVE )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    dwPPFlags = _pPropdesc -> GetPPFlags();

    // Is the unit valid as identified in the propdesc
    // but pixels are always valid
    if ( ( CUnitValue::IsScalerUnit ( uvt ) && 
                (uvt != CUnitValue::UNIT_PIXELS) && 
                !(dwPPFlags & PROPPARAM_LENGTH ) ) ||
         ( uvt == CUnitValue::UNIT_TIMESRELATIVE && !(dwPPFlags & PROPPARAM_TIMESRELATIVE) ) ||
         ( uvt == CUnitValue::UNIT_PERCENT && !(dwPPFlags & PROPPARAM_PERCENTAGE) ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Set the persisted HTML unit,
    // Convert value to new units
    hr = THR ( GetStoredUnitValue ( &uvValue ) );
    if ( hr )
        goto Cleanup;

    if ( IsMeasureInXDirection() )
        hr = uvValue.XConvertToUnitType ( uvt, GetValueFromPixelRect(), 1 );
    else
        hr = uvValue.YConvertToUnitType ( uvt, GetValueFromPixelRect(), 1 );

    if ( hr )
        goto Cleanup;


    // Store the new value away
    hr = SetStoredUnitValue ( uvValue );

Cleanup:
    RRETURN ( SetErrorInfo ( hr ) );
}

HRESULT CUnitMeasurement::get_unit (BSTR *pbstrUnit)
{
    HRESULT hr ;
    CUnitValue uvValue;
    htmlUnits Unit;

#ifdef RGARDNER
    if ( !_pElem->ShouldHaveLayout() )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }
#endif
    if ( !pbstrUnit )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Get the unit type from the persisted value
    hr = THR ( GetStoredUnitValue ( &uvValue ) );
    if ( hr )
        goto Cleanup;

    Unit = (htmlUnits) uvValue.GetUnitType() ;

    hr = STRINGFROMENUM ( htmlUnits, (long)Unit, pbstrUnit );

Cleanup:
    RRETURN ( SetErrorInfo ( hr ) );
}

HRESULT CUnitMeasurement::put_unitValue ( float fValue )
{
    CUnitValue uvValue;
    HRESULT hr;

#ifdef RGARDNER
    if ( !_pElem->ShouldHaveLayout() )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }
#endif

    // vValue represents the value of the property in the current
    // document units ( document.DefaultUnits ). Set the internal
    // value but keep the persisted unit the same.
    hr = THR ( GetStoredUnitValue ( &uvValue ) );
    if ( hr )
        goto Cleanup;

    hr = THR ( uvValue.SetFloatUnitValue ( fValue ) );

    if ( hr )
        goto Cleanup;

    // Store the new value away
    hr = SetStoredUnitValue ( uvValue );

Cleanup:
    RRETURN ( SetErrorInfo ( hr ) );
}

HRESULT CUnitMeasurement::get_unitValue (float * pfUnitValue)
{
    HRESULT hr ;
    CUnitValue uvValue;

    if ( !pfUnitValue )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = E_INVALIDARG;
        goto Cleanup;
    }    
#ifdef RGARDNER
    if ( !_pElem->ShouldHaveLayout() )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }
#endif

    hr = THR ( GetStoredUnitValue ( &uvValue ) );
    if ( hr )
        goto Cleanup;

    if ( uvValue.IsNull() )
    {
        *pfUnitValue = 0.0;
    }
    else
    {
        if ( IsMeasureInXDirection() )
            *pfUnitValue = uvValue.XGetFloatValueInUnits ( uvValue.GetUnitType() );
        else
            *pfUnitValue = uvValue.YGetFloatValueInUnits ( uvValue.GetUnitType() );
    }
Cleanup:
    RRETURN ( SetErrorInfo ( hr ) );
}

HRESULT CUnitMeasurement::put_htmlText ( BSTR bstrText )
{
    HRESULT hr;
    
#ifdef RGARDNER
    if ( !_pElem->ShouldHaveLayout() )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }
#endif
    
    hr = CallHandler ( HANDLEPROP_SET | HANDLEPROP_AUTOMATION |
        (PROPTYPE_LPWSTR << 16), (void *)bstrText );
#ifdef RGARDNER
Cleanup:
#endif
    RRETURN ( SetErrorInfo ( hr ) );
}

HRESULT CUnitMeasurement::get_htmlText (BSTR * pbstrText)
{
    VARIANT vt;
    HRESULT hr;

    if ( !pbstrText )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = E_INVALIDARG;
        goto Cleanup;
    }
#ifdef RGARDNER
    if ( !_pElem->ShouldHaveLayout() )
    {
        // Not Valid to set unit measurements on non-site objects
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }
#endif

    hr = CallHandler ( HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
        (void *)&vt );

    // I know the UnitValue handler will put a BSTR in the variant
    // for me
    *pbstrText = V_BSTR ( &vt );

Cleanup:
    RRETURN ( SetErrorInfo ( hr ) );
}



/*static*/
HRESULT CUnitMeasurement::CreateSubObject ( CElement *pElemObj,
    PROPERTYDESC *pPropdesc, MEASURETYPE MeasureType, IUnitMeasurement **ppObj )
{
    HRESULT hr = S_OK;

    Assert ( ppObj );

    *ppObj = (IUnitMeasurement *) new CUnitMeasurement ( pElemObj, pPropdesc, MeasureType );
    if ( !*ppObj )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    RRETURN ( hr );
}

CUnitMeasurement::~CUnitMeasurement()
{
    _pElem -> Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\unknown.cxx ===
//+---------------------------------------------------------------------
//
//   File:      unknown.cxx
//
//  Contents:   Element class
//
//  Classes:    CUnknownElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_CFPF_HXX_
#define X_CFPF_HXX_
#include "cfpf.hxx"
#endif

#ifndef X_HTMTAGS_HXX_
#define X_HTMTAGS_HXX_
#include "htmtags.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#define _cxx_
#include "unknown.hdl"

MtDefine(CUnknownElement, Elements, "CUnknownElement")

//+----------------------------------------------------------------------------
//
//  Class:      CUnknownElement
//
//-----------------------------------------------------------------------------
             
const CElement::CLASSDESC CUnknownElement::s_classdesc =
{
    {
        &CLSID_HTMLUnknownElement,          // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLUnknownElement,           // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnIHTMLUnknownElement,      //_apfnTearOff

    NULL                                    // _pAccelsRun
};


//+-----------------------------------------------------------
//
//  Class: CUnknownElement
//
//------------------------------------------------------------

CUnknownElement::CUnknownElement (CHtmTag *pht, CDoc *pDoc)
  : CElement(ETAG_UNKNOWN, pDoc)
{
    const TCHAR *pchTagName;
    HRESULT     hr;
    
    if (pht->GetTag() == ETAG_UNKNOWN)
        pchTagName = pht->GetPch();
    else
        pchTagName = NameFromEtag(pht->GetTag());

    if (pchTagName && pht->IsEnd() && *pchTagName != _T('/'))
    {
        // If this is an end tag and there is no slash in the tag name,
        // add one now.
        hr = THR(_cstrTagName.Set(_T("/")));
        if (hr)
            goto Error;
    }
    else
    {
        hr = THR(_cstrTagName.Set(_T("")));
        if (hr)
            goto Error;
    }
    
    if (pchTagName)
    {
        hr = THR(_cstrTagName.Append(pchTagName));
        if (hr)
            goto Error;
    }

    CharUpper(_cstrTagName);

    _fAttemptAtomicSave = pht->IsEmpty();

Error:
    return;
}

HRESULT CUnknownElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);
    *ppElement = new CUnknownElement(pht, pDoc);
    return *ppElement ? S_OK : E_OUTOFMEMORY;
}

//+------------------------------------------------------------------------
//
//  Method:     CUnknownElement::Init2
//
//-------------------------------------------------------------------------

HRESULT
CUnknownElement::Init2(CInit2Context * pContext)
{
    HRESULT     hr;

    hr = THR(super::Init2(pContext));

    RRETURN (hr);
}



//+----------------------------------------------------------------------------
//  
//  Method:     CUnknownElement::Save
//  
//  Synopsis:   Saves an uknown element
//  
//  Returns:    HRESULT
//  
//  Arguments:
//          CStreamWriteBuff * pStreamWriteBuff - stream to save to
//          BOOL fEnd - save begin vs. save end
//  
//+----------------------------------------------------------------------------

HRESULT
CUnknownElement::Save( CStreamWriteBuff * pStreamWriteBuff, BOOL fEnd )
{
    HRESULT hr = S_OK;

    // Unknown elements are no-scope, so we don't need to check for contents
    hr = THR( WriteTag(pStreamWriteBuff, fEnd, FALSE, _fAttemptAtomicSave) );
    if(hr)
        goto Cleanup;

Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\urlcomp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       urlcomp.cxx
//
//  Contents:   URL compatibility code
//
//              Provides compatibility bits for specific URLs
//
//  Classes:    CDoc (partial)
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_URLCOMP_HXX_
#define X_URLCOMP_HXX_
#include "urlcomp.hxx"
#endif

#ifndef X_ASSOC_HXX_
#define X_ASSOC_HXX_
#include "assoc.hxx"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

static TCHAR achUrlCompatRootKey[] = _T("Software\\Microsoft\\Internet Explorer\\URL Compatibility");
static TCHAR achCompatFlags[] =      _T("Compatibility Flags");
static TCHAR achIcwKey[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\ICWCONN1.EXE");
static TCHAR szIcwPath[MAX_PATH];
extern const TCHAR szOurVersion[];

static CPtrBagCi<DWORD> g_bCompatUrls(TRUE);

static DWORD g_dwDefaultUrlCompatFlags;

//+---------------------------------------------------------------------------
//
//  Function:   ShouldWeRegisterUrlCompatibilityTable
//
//  Synopsis:   Determine whether we should write our compatibility table,
//              as recorded in selfreg.inf, to the registry.
//  
//              We do if the table is not in the registry at all, or if
//              our version of the table is more recent than that in the
//              registry.
//
//              NOTE: szOurVersion comes from clstab.cxx
//
//  Returns:    TRUE - yes, write the table please.
//
//----------------------------------------------------------------------------

BOOL 
ShouldWeRegisterUrlCompatibilityTable()
{
    BOOL fOurRet = TRUE;
    LRESULT lr;
    HKEY hkeyRoot = NULL;
    DWORD dwSize, dwType;
    TCHAR szVersion[10];

    lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, achUrlCompatRootKey, 0, KEY_READ, &hkeyRoot);
    if (lr != ERROR_SUCCESS)
        return(TRUE);

    dwSize = sizeof(szVersion);
    lr = RegQueryValueEx(hkeyRoot, _T("Version"), NULL, &dwType, (BYTE*)szVersion, &dwSize);
    if (lr == ERROR_SUCCESS)
        fOurRet = (_tcscmp(szVersion, szOurVersion) < 0);

    RegCloseKey(hkeyRoot);

    return(fOurRet);
}

void AppendIcwPath(TCHAR * pch)
{
    TCHAR ach[MAX_PATH];

    _tcscpy(ach, szIcwPath);
    _tcscat(ach, pch + 1);  // ignoring the leading '~'
    _tcscpy(pch, ach);
}
//+---------------------------------------------------------------------------
//
//  Function:   LegalKeyCharFromChar
//
//  Synopsis:   Some chars are not legal in a registry key, so replace them
//              with legal chars.
//
//  Returns:    TCHAR
//
//----------------------------------------------------------------------------

inline TCHAR
LegalKeyCharFromChar(TCHAR ch)
{
    if (ch <= _T(' '))
        return _T('!');

    if (ch >= 127)
        return _T('~');

    if (ch == _T('\\'))
        return _T('/');
        
    if (ch == _T('?') || ch == _T('*'))
        return _T('_');

    return ch;
}

//+---------------------------------------------------------------------------
//
//  Function:   CleanupUrl
//
//  Synopsis:   Remove \'s etc from the URL (by converting to / etc)
//
//  Returns:    void
//
//----------------------------------------------------------------------------

void CleanupUrl(TCHAR * pchTo, TCHAR * pch, ULONG cch)
{
    cch--;
    while (*pch && cch)
    {
        *pchTo++ = LegalKeyCharFromChar(*pch++);
        cch--;
    }
    *pchTo = 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   InitUrlCompatTable
//
//  Synopsis:   Reads URL compat bits from the registry and puts them in
//              a hash table for fast lookup.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
InitUrlCompatTable()
{
    HKEY hkeyRoot = NULL;
    HKEY hkey = NULL;
    ULONG iKey;
    static TCHAR ach[pdlUrlLen];
    ULONG cch;
    ULONG cb;
    DWORD dwType;
    DWORD dwFlags;
    HRESULT hr = S_OK;
    LRESULT lr;
    static TCHAR achAppWiz[MAX_PATH] = _T("res://%SystemRoot%\\system32\\appwiz.cpl/default.hta");
    static TCHAR achExpandedAppWiz[MAX_PATH];

    
    lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, achIcwKey, 0, KEY_READ, &hkeyRoot);
    if (lr != ERROR_SUCCESS)
        return S_OK;

    cb = ARRAY_SIZE(szIcwPath);
    lr = RegQueryValueEx(hkeyRoot, _T("Path"), NULL, &dwType, (BYTE*) szIcwPath, &cb);
    if (lr != ERROR_SUCCESS)
        goto Win32Error;

    lr = RegCloseKey(hkeyRoot);
    if (lr != ERROR_SUCCESS)
        goto Win32Error;

    // replace drive letter with '_' and remove the trailing ';'
    if (*szIcwPath)
    {
        szIcwPath[_tcslen(szIcwPath) - 1] = 0;
        GetShortPathName(szIcwPath, szIcwPath, ARRAY_SIZE(szIcwPath));
        szIcwPath[0]=_T('_');
    }

    CleanupUrl(szIcwPath, szIcwPath, ARRAY_SIZE(szIcwPath));

    
    // Open root key
    lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, achUrlCompatRootKey, 0, KEY_READ, &hkeyRoot);
    if (lr != ERROR_SUCCESS)
        goto Win32Error;

    // Add Add/Remove programs to the url compat table.
    if (0 == ExpandEnvironmentStrings(achAppWiz, achExpandedAppWiz, ARRAY_SIZE(achExpandedAppWiz)))
        goto Win32Error;

    CleanupUrl(achExpandedAppWiz, achExpandedAppWiz, ARRAY_SIZE(achExpandedAppWiz));

    hr = THR(g_bCompatUrls.SetCi(achExpandedAppWiz, URLCOMPAT_ALLOWBIND));
    if (hr)
        goto Cleanup;
    
    // Read each table entry
    for (iKey = 0; ; iKey++)
    {
        cch = ARRAY_SIZE(ach);
        lr = RegEnumKeyEx(hkeyRoot, iKey, ach, &cch, NULL, NULL, NULL, NULL);
        if (lr != ERROR_SUCCESS )
            break;
            
        ach[cch] = _T('\0');

        lr = RegOpenKeyEx(hkeyRoot, ach, 0, KEY_READ, &hkey);
        if (lr != ERROR_SUCCESS)
            continue;

        cb = sizeof(dwFlags);
        lr = RegQueryValueEx(hkey, achCompatFlags, NULL, &dwType, (BYTE*)&dwFlags, &cb);
        
        if (lr == ERROR_SUCCESS && dwType == REG_DWORD && cb == sizeof(dwFlags))
        {
            if (ach[0] == _T('~'))
                AppendIcwPath(ach);

            hr = THR(g_bCompatUrls.SetCi(ach, dwFlags));
            if (hr)
                goto Cleanup;
        }

        lr = RegCloseKey(hkey);
        if (lr != ERROR_SUCCESS)
            goto Win32Error;
            
        hkey = NULL;
    }
    
    g_dwDefaultUrlCompatFlags = g_bCompatUrls.GetCi(_T("Default"));
    
Cleanup:
    if (hkey)
        RegCloseKey(hkey);
    if (hkeyRoot)
        RegCloseKey(hkeyRoot);

    RRETURN(hr);

Win32Error:
    hr = HRESULT_FROM_WIN32(lr);
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Function:   CompatBitsFromUrl
//
//  Synopsis:   Looks up URL in a case-insensitive hash table and returns
//              compat bits.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CompatBitsFromUrl(TCHAR *pchUrl, DWORD *dwUrlCompat)
{
    TCHAR *pch;
    TCHAR ach[pdlUrlLen];
    ULONG cch = ARRAY_SIZE(ach);
    DWORD dwFlags;
    HRESULT hr = S_OK;

    // File URLs become paths

    if (GetUrlScheme(pchUrl) == URL_SCHEME_FILE)
    {
        hr = THR(PathCreateFromUrl(pchUrl, ach, &cch, 0));
        if (hr)
            goto Cleanup;

        GetShortPathName(ach, ach, ARRAY_SIZE(ach));

        // replace drive letter with '_'
        if (*ach)
        {
            ach[0]=_T('_');
        }

        pch = ach;
        cch = ARRAY_SIZE(ach);
    }
    else
    {
        pch = pchUrl;
    }

    CleanupUrl(ach, pch, cch);

    dwFlags = g_bCompatUrls.GetCi(ach);

    *dwUrlCompat = dwFlags ? dwFlags : g_dwDefaultUrlCompatFlags;

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\unknownp.cxx ===
//+---------------------------------------------------------------------
//
//   File:      unknownp.cxx
//
//  Contents:   Unknown Pair class
//
//  Classes:    CUnknownPairList
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_UNKNOWNP_HXX_
#define X_UNKNOWNP_HXX_
#include "unknownp.hxx"
#endif

CUnknownPair* 
CUnknownPairList::Get(size_t i)
{
    Assert(i>=0&&i<Length());
    return ((CUnknownPair *)*_paryUnknown)+i;
}

size_t
CUnknownPairList::Length() const
{
    return _paryUnknown?_paryUnknown->Size():0;
}

HRESULT 
CUnknownPairList::Duplicate(CUnknownPairList &upl) const
{
    HRESULT hr = S_OK;
    CUnknownPair *pupThis, *pupThat;
    int cUPairs;

    CDataAry<CUnknownPair> *paryOtherUnknown;

    // Both attr bags must have unknowns, or neither
    if (!_paryUnknown)
        goto Cleanup;

    cUPairs = _paryUnknown->Size();

    upl._paryUnknown = new CDataAry<CUnknownPair>;
    if (!upl._paryUnknown)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    paryOtherUnknown = upl._paryUnknown;
    hr = paryOtherUnknown->EnsureSize(cUPairs);
    if (hr)
        goto Cleanup;

    paryOtherUnknown->SetSize(cUPairs);

    pupThis = (CUnknownPair *)*_paryUnknown;
    pupThat = (CUnknownPair *)*paryOtherUnknown;
    for ( ; --cUPairs >= 0; pupThis++, pupThat++)
    {
        UINT cchA = pupThis->_cstrA.Length();
        UINT cchB = pupThis->_cstrB.Length();

        new (&pupThat->_cstrA) CStr();
        new (&pupThat->_cstrB) CStr();

        hr = pupThat->_cstrA.Set((LPTSTR)pupThis->_cstrA, cchA);
        if (hr)
            goto Cleanup;

        if (cchB)
        {
            hr = pupThat->_cstrB.Set((LPTSTR)pupThis->_cstrB, cchB);
            if (hr)
                goto Cleanup;
        }
    }

// TODO: Should we free a partially copied array???
Cleanup:
    RRETURN(hr);
}

BOOL 
CUnknownPairList::Compare(const CUnknownPairList *pup) const
{
    CUnknownPair *pupThis, *pupThat;
    int cUPairs;
    CDataAry<CUnknownPair> *paryOtherUnknown = pup->_paryUnknown;

    // Both attr bags must have unknowns, or neither
    if (!_paryUnknown || !paryOtherUnknown)
    {
        return (!_paryUnknown && !paryOtherUnknown);
    }

    cUPairs = _paryUnknown->Size();
    if (cUPairs != paryOtherUnknown->Size())
        return FALSE;

    pupThis = (CUnknownPair *)*_paryUnknown;
    pupThat = (CUnknownPair *)*paryOtherUnknown;
    for ( ; --cUPairs >= 0; pupThis++, pupThat++)
    {
        UINT cchName = pupThis->_cstrA.Length();
        UINT cchValue = pupThis->_cstrB.Length();

        // Check lengths first
        if (   cchName != pupThat->_cstrA.Length()
            || cchValue != pupThat->_cstrB.Length())
            return FALSE;

        if (   _tcsicmp((LPTSTR)pupThis->_cstrA, (LPTSTR)pupThat->_cstrA)
            || (cchValue && StrCmpC((LPTSTR)pupThis->_cstrB, (LPTSTR)pupThat->_cstrB)))
            return FALSE;
    }
    return TRUE;
}

WORD 
CUnknownPairList::ComputeCrc() const
{
    WORD wHash = 0;

    if (_paryUnknown) {
        CUnknownPair *pUPair;
        int cUPairs;

        for (pUPair = (CUnknownPair *)*_paryUnknown, cUPairs = _paryUnknown->Size();
             cUPairs; cUPairs--, pUPair++)
        {
            wHash ^= pUPair->_cstrA.ComputeCrc();
            wHash ^= pUPair->_cstrB.ComputeCrc();
        }
    }
    return wHash;
}

HRESULT
CUnknownPairList::AddUnknownPair(const TCHAR *pchA, const size_t cchA,
                            const TCHAR *pchB, const size_t cchB)
{
    HRESULT hr = S_OK;
    CUnknownPair *pUPair;
    CUnknownPair upDummy;
    int iCount, iIndex, iDiff;


    Assert(pchA);

    if (!_paryUnknown)
    {
        _paryUnknown = new CDataAry<CUnknownPair>;
    }

    if (!_paryUnknown)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // TODO: should bsearch

    iCount = _paryUnknown->Size();

    for (iIndex = 0; iIndex < iCount; iIndex++)
    {
        pUPair = Get(iIndex);
        Assert(pUPair);

        // Compare names (case-insensitive)
        iDiff = _tcsnicmp(pchA, cchA, (LPTSTR)pUPair->_cstrA, -1);
        if (iDiff < 0)
            break;
        else if (!iDiff)
        {
            // Compare values
            if (!cchB || !pchB)      // If there's no value, insert here
                break;
            else if (!(LPTSTR)pUPair->_cstrB)   // If this slot has no value, keep looking
                continue;
            else
            {
                // Compare value strings (case-sensitive)
                iDiff = _tcsncmp(pchB, cchB, (LPTSTR)pUPair->_cstrB, -1);
                if (iDiff <= 0)
                    break;
            }
        }
    }

    // TODO: This is egregious. Should upDummy be initialized first?????
    hr = _paryUnknown->InsertIndirect(iIndex, &upDummy);
    if (hr)
        goto Cleanup;
    pUPair = Get(iIndex);
    Assert(pUPair);

    new (&pUPair->_cstrA) CStr();
    new (&pUPair->_cstrB) CStr();

    hr = pUPair->_cstrA.Set(pchA, cchA);
    if (hr)
        goto Cleanup;

    if (pchB && cchB)
    {
        hr = pUPair->_cstrB.Set(pchB, cchB);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);

}

void
CUnknownPairList::Free()
{
    CUnknownPair *pUPair;

    if (_paryUnknown)
    {
        int i = _paryUnknown->Size();
        for (pUPair = (CUnknownPair *)(*_paryUnknown); i; i--, pUPair++)
        {
            pUPair->_cstrA.Free();
            pUPair->_cstrB.Free();
        }

        delete _paryUnknown;
        _paryUnknown = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\viewserv.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_CARET_HXX_
#define X_CARET_HXX_
#include "caret.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_TEXTAREA_HXX_
#define X_TEXTAREA_HXX_
#include "textarea.hxx"
#endif


#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef _X_ADORNER_HXX_
#define _X_ADORNER_HXX_
#include "adorner.hxx"
#endif

#ifndef X_MISCPROT_H_
#define X_MISCPROT_H_
#include "miscprot.h"
#endif

#ifndef X_DIMM_H_
#define X_DIMM_H_
#include "dimm.h"
#endif

#ifndef X_BREAKER_HXX_
#define X_BREAKER_HXX_
#include "breaker.hxx"
#endif

#ifndef X_RTFTOHTM_HXX_
#define X_RTFTOHTM_HXX_
#include "rtftohtm.hxx"
#endif

#ifndef X__DISP_H_
#define X__DISP_H_
#include "_disp.h"
#endif

#ifdef UNIX
#include "quxcopy.hxx"
#endif

#ifndef I_CORERC_H_
#include "corerc.h"
#endif

#ifndef X_DISPSERV_HXX_
#define X_DISPSERV_HXX_
#include "dispserv.hxx"
#endif

static const LPTSTR astrCursor[] =
{
    IDC_SIZEALL,                    // HTC_TOPBORDER         = 21,
    IDC_SIZEALL,                    // HTC_LEFTBORDER        = 22,
    IDC_SIZEALL,                    // HTC_BOTTOMBORDER      = 23,
    IDC_SIZEALL,                    // HTC_RIGHTBORDER       = 24,
    IDC_SIZENWSE,                   // HTC_TOPLEFTHANDLE     = 25,
    IDC_SIZEWE,                     // HTC_LEFTHANDLE        = 26,
    IDC_SIZENS,                     // HTC_TOPHANDLE         = 27,
    IDC_SIZENESW,                   // HTC_BOTTOMLEFTHANDLE  = 28,
    IDC_SIZENESW,                   // HTC_TOPRIGHTHANDLE    = 29,
    IDC_SIZENS,                     // HTC_BOTTOMHANDLE      = 30,
    IDC_SIZEWE,                     // HTC_RIGHTHANDLE       = 31,
    IDC_SIZENWSE,                   // HTC_BOTTOMRIGHTHANDLE = 32
};


MtDefine(CDocRegionFromMarkupPointers_aryRects_pv, Locals, "CDoc::RegionFromMarkupPointers aryRects::_pv")


DeclareTag(tagSelectionTimer, "Selection", "Selection Timer Actions in CDoc")
DeclareTag(tagViewServicesErrors, "ViewServices", "Show Viewservices errors")
DeclareTag( tagViewServicesCpHit, "ViewServices", "Show Cp hit from CpFromPoint")
DeclareTag( tagViewServicesShowEtag, "ViewServices", "Show _etag in MoveMarkupPointer")

DeclareTag( tagViewServicesShowScrollRect, "ViewServices", "Show Scroll Rect")
DeclareTag(tagEditDisableEditFocus, "Edit", "Disable On Edit Focus")

////////////////////////////////////////////////////////////////


HRESULT
CDoc::MoveMarkupPointerToPoint( 
    POINT               pt, 
    IMarkupPointer *    pPointer, 
    BOOL *              pfNotAtBOL, 
    BOOL *              pfAtLogicalBOL,
    BOOL *              pfRightOfCp, 
    BOOL                fScrollIntoView )
{
    RRETURN( THR( MoveMarkupPointerToPointEx( pt, pPointer, TRUE, pfNotAtBOL, pfAtLogicalBOL, pfRightOfCp, fScrollIntoView ))); // Default to global coordinates
}

HRESULT 
CDoc::MoveMarkupPointerToPointEx(
    POINT               pt,
    IMarkupPointer *    pPointer,
    BOOL                fGlobalCoordinates,
    BOOL *              pfNotAtBOL,
    BOOL *              pfAtLogicalBOL,
    BOOL *              pfRightOfCp,
    BOOL                fScrollIntoView )
{
    HRESULT hr = E_FAIL;
    CMarkupPointer * pPointerInternal = NULL;
    POINT ptContent;
    CLayoutContext *pLayoutContext = NULL;
    
    CTreeNode * pTreeNode = GetNodeFromPoint( pt, &pLayoutContext, fGlobalCoordinates, &ptContent, NULL, NULL, NULL );
    
    if( pTreeNode == NULL )
        goto Cleanup;

    // TODO: the following block seem to be extra, together with "if".
    //       It can lie in case of relatively positioned nodes.
    //       I think that following changes shouldd be done:
    //       1) add new variable, CDispNode *pDispnode;
    //       2) pass &pDispnode as 8th argument GetNodeFromPoint();
    //       3) supply MovePointerToPointInternal() with this pDispNode as 13th arg,
    //       4) and remove the whole <if (..) { ... }>
    //       See accutil.cxx for example, and bugs 105942, 106131, 109587 fixes.
    //       Not fixed because of improper project stage (mikhaill 5/9/00).
    if ( ( ptContent.x == 0 ) && ( ptContent.y == 0 ) )
    {
        //
        // NOTE Sometimes - HitTestPoint returns ptContent of 0 We take over ourselves.
        //
        CFlowLayout * pLayout = NULL;
        
        pLayout = pTreeNode->GetFlowLayout( pLayoutContext );
        if( pLayout == NULL )
            goto Cleanup;

        CPoint myPt( pt );
        pLayout->TransformPoint( &myPt, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT, NULL );

        ptContent.x = myPt.x;
        ptContent.y = myPt.y;
    }
    
    hr = THR( pPointer->QueryInterface( CLSID_CMarkupPointer, (void **) &pPointerInternal ));
    if( FAILED( hr ))
        goto Cleanup;

    //
    // Accessing line information, ensure a recalc has been done
    //
    hr = THR(pTreeNode->Element()->EnsureRecalcNotify(FALSE));
    if (hr)
        goto Cleanup;
    

    hr = THR( MovePointerToPointInternal( ptContent, pTreeNode, pLayoutContext, pPointerInternal, pfNotAtBOL, pfAtLogicalBOL, pfRightOfCp, fScrollIntoView, pTreeNode->GetFlowLayout( pLayoutContext ), NULL, TRUE ));

Cleanup:
    RRETURN( hr );
}

//*********************************************************************************
//
// TODO - this routine returns values in the Local coords of the layout the pointer is in !
// We should either make this more explicit via a name change - or better allow specification
// of the cood-sys you are using.
//
//*********************************************************************************


HRESULT
CDoc::GetLineInfo(IMarkupPointer *pPointer, BOOL fAtEndOfLine, HTMLPtrDispInfoRec *pInfo)
{
    HRESULT             hr = S_OK;
    CMarkupPointer *    pPointerInternal;
    CFlowLayout *       pFlowLayout;
    CTreeNode *         pNode = NULL;
    CCharFormat const * pCharFormat = NULL;

    hr = THR( pPointer->QueryInterface(CLSID_CMarkupPointer, (void **)&pPointerInternal ));
    if (hr)
        goto Cleanup;

    Assert( pPointerInternal->IsPositioned() );
    pNode = pPointerInternal->CurrentScope(MPTR_SHOWSLAVE);   
    if(pNode == NULL)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    pCharFormat = pNode->GetCharFormat();
    pFlowLayout = pNode->GetFlowLayout();

    if(!pFlowLayout)
    {
        hr = OLE_E_BLANK;
        goto Cleanup;
    }

    hr = pFlowLayout->GetLineInfo( pPointerInternal, fAtEndOfLine, pInfo, pCharFormat );

Cleanup:
    RRETURN(hr);    
}

HRESULT
CDoc::RegionFromMarkupPointers( IMarkupPointer *pPointerStart, 
                                IMarkupPointer *pPointerEnd, 
                                HRGN *phrgn)
{
    HRESULT                 hr;
    CMarkupPointer *        pStart  = NULL;
    CMarkupPointer *        pEnd    = NULL;
    RECT                    rcBounding = g_Zero.rc;
    CStackDataAry<RECT, 4>  aryRects(Mt(CDocRegionFromMarkupPointers_aryRects_pv));

    // check parameters
    if ( !pPointerStart || !pPointerEnd || !phrgn )
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    
    // clean the out parameter
    *phrgn = NULL;

    // Get the CMarkupPointer values for the IMarkupPointer 
    // parameters we received
    hr = pPointerStart->QueryInterface( CLSID_CMarkupPointer, (void **)&pStart );
    if ( hr ) 
        goto Cleanup;

    hr = pPointerEnd->QueryInterface( CLSID_CMarkupPointer, (void **)&pEnd );
    if ( hr ) 
        goto Cleanup;

    // We better have these pointers.
    Assert( pStart );
    Assert( pEnd );

    // Get rectangles
    hr = RegionFromMarkupPointers( pStart, pEnd, &aryRects, &rcBounding );
    if ( hr )
        goto Cleanup;


//TODO:   [FerhanE]
//          The code below has to change in order to return a region that contains
//          multiple rectangles. To do that, a region must be created for each 
//          member of the rect. array and combined with the complete region.
//
//          Current code only returns the region for the bounding rectangle.

    // Create and return BOUNDING region
    *phrgn = CreateRectRgn( rcBounding.left ,rcBounding.top,
                            rcBounding.right, rcBounding.bottom );

Cleanup:
    RRETURN( hr );
}


HRESULT
CDoc::RegionFromMarkupPointers( CMarkupPointer  *   pStart, 
                                CMarkupPointer  *   pEnd,
                                CDataAry<RECT>  *   paryRects, 
                                RECT            *   pBoundingRect = NULL, 
                                BOOL                fCallFromAccLocation)
{
    HRESULT         hr = S_OK;
    CTreeNode *     pTreeNode = NULL;
    CFlowLayout *   pFlowLayout = NULL;
    long            cpStart = 0;        // Starting cp.
    long            cpEnd = 0;          // Ending cp

    CElement *      pElem = NULL;

    if ( !pStart || !pEnd || !paryRects)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // Calculate the starting and ending cps
    cpStart = pStart->GetCp();
    cpEnd = pEnd->GetCp();

    //Get the flow layout that the markup pointer is placed in.
    pTreeNode = pStart->CurrentScope(MPTR_SHOWSLAVE);
    if ( !pTreeNode )
        goto Error;

    pFlowLayout = pTreeNode->GetFlowLayout();
    if ( !pFlowLayout )
        goto Error;

    // get the element we are in.
    pElem = pTreeNode->Element();
    
    // Get the rectangles.
    pFlowLayout->RegionFromElement( pElem, 
                                    paryRects,  
                                    NULL, NULL, 
                                    RFE_SELECTION|RFE_SCREENCOORD, 
                                    cpStart, cpEnd, 
                                    pBoundingRect );

    // BUT Wait NF ... in IE5.0 RFE_SCREENCORD for frames was wrt the frame's window
    // in IE5.5 there is not window for the frame, and so the RFE_SCREENCOORD is 
    // returning wrt the top window, and not accounting for the origin offest of the
    // frame.  Also, with Viewlinks, if they are a windowed markup, then this needs to
    // be wrt to that. so:
    if (   pBoundingRect
        && pElem->GetWindowedMarkupContext() 
        && !fCallFromAccLocation)
    {
        POINT ptOrg;
        CMarkup  *pwmc = pElem->GetWindowedMarkupContext();

        pwmc->GetElementClient()->GetClientOrigin(&ptOrg);

        pBoundingRect->left   -= ptOrg.x;
        pBoundingRect->right  -= ptOrg.x;
        pBoundingRect->top    -= ptOrg.y;
        pBoundingRect->bottom -= ptOrg.y;

        // and the Array Rects as well.
    }

    
Cleanup:
    RRETURN( hr );

Error:
    RRETURN( E_FAIL );
}


HRESULT 
CDoc::GetCurrentSelectionSegmentList( 
    ISegmentList ** ppSegment)
{
    HRESULT hr = S_OK;
    Assert( _pElemCurrent );

    ISelectionServices  *pSelSvc = NULL;

    hr = THR( GetSelectionServices( &pSelSvc ) );
    if( hr )
        goto Cleanup;

    hr = THR( pSelSvc->QueryInterface( IID_ISegmentList, ( void**) ppSegment ));

Cleanup:
    ReleaseInterface( pSelSvc );

    RRETURN ( hr ) ;
}


CMarkup * 
CDoc::GetCurrentMarkup()
{
    CMarkup * pMarkup = NULL;
    
    if (_pElemCurrent)
    {
        if (_pElemCurrent->HasSlavePtr())
        {
            pMarkup = _pElemCurrent->GetSlavePtr()->GetMarkup();
        }
        else
        {
            pMarkup = _pElemCurrent->GetMarkup();
        }
    }

    return pMarkup;
}        

//+====================================================================================
//
// Method: IsCaretVisible
//
// Synopsis: Checks for caret visibility - if there's no caret - return false.
//
//------------------------------------------------------------------------------------

BOOL
CDoc::IsCaretVisible( BOOL * pfPositioned )
{
    BOOL fVisible = FALSE;
    BOOL fPositioned = FALSE;
    
    if ( _pCaret )
    {
        _pCaret->IsVisible( & fVisible );
        fPositioned = _pCaret->IsPositioned();
    }
    
    if ( pfPositioned )
        *pfPositioned = fPositioned;
        
    return fVisible;        
}

HRESULT 
CDoc::GetCaret(
    IHTMLCaret ** ppCaret )
{
    HRESULT hr = S_OK;

    // NOTE (johnbed) : when CView comes into being, the caret will be
    // stored there and will require a view pointer as well.
    
    // lazily construct the caret...
    
    if( _pCaret == NULL )
    {
        _pCaret = new CCaret( this );
        
        if( _pCaret == NULL )
            goto Error;

        _pCaret->AddRef();      // Doc holds a ref to caret, released in passivate
        _pCaret->Init();        // Init the object
        _pCaret->Hide();        // Default to hidden - host or edit can show after move.
    }
    
    if (ppCaret)
    {
        hr = _pCaret->QueryInterface( IID_IHTMLCaret, (void **) ppCaret );
    }

    RRETURN( hr );

Error:
    return E_OUTOFMEMORY;
}

HRESULT 
CDoc::IsBlockElement ( IHTMLElement * pIElement,
                           BOOL  * fResult ) 
{
    HRESULT     hr;
    CElement  * pElement = NULL;

    if (! pIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR_NOTRACE( pIElement->QueryInterface( CLSID_CElement,
            (void **) & pElement ) );
    if (hr)
        goto Cleanup;

    *fResult = pElement->IsBlockElement();

Cleanup:
    RRETURN( hr );
}

HRESULT
CDoc::GetFlowElement ( IMarkupPointer * pIPointer,
                       IHTMLElement  ** ppIElement )
{
    HRESULT           hr;
    BOOL              fPositioned = FALSE;
    CFlowLayout     * pFlowLayout;
    CTreeNode       * pTreeNode = NULL;
    CMarkupPointer  * pMarkupPointer = NULL;
    CElement        * pElement = NULL;

    if (! pIPointer || !ppIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppIElement = NULL;

    hr = THR( pIPointer->IsPositioned( & fPositioned ) );
    if (hr)
        goto Cleanup;
    if (! fPositioned)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR_NOTRACE( pIPointer->QueryInterface(CLSID_CMarkupPointer, (void **) &pMarkupPointer) );    
    if (hr)
        goto Cleanup;

    pTreeNode = (pMarkupPointer->IsPositioned() ) ? pMarkupPointer->CurrentScope(MPTR_SHOWSLAVE) : NULL;
    
    if (! pTreeNode)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pFlowLayout = pTreeNode->GetFlowLayout();
    
    if (!pFlowLayout)
    {
        hr = S_OK ;
        goto Cleanup;
    }
    
    pElement = pFlowLayout->ElementOwner();

    Assert(pElement);

    if (! pElement)
        goto Cleanup;

    hr = THR_NOTRACE( pElement->QueryInterface( IID_IHTMLElement, (void **) ppIElement ) );
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN1( hr, S_FALSE );
}

//+------------------------------------------------------------------------------------
//
// Funcion:   MapToCoorinateEnum()
//
// Synopsis:  Helper function which maps a given COORD_SYSTEM to its corresponding
//            CLayout::COORDINATE_SYSTEM
//           
//-------------------------------------------------------------------------------------

COORDINATE_SYSTEM
MapToCoordinateEnum ( COORD_SYSTEM eCoordSystem )
{   
    COORDINATE_SYSTEM eCoordinate;

    switch( eCoordSystem )
    {
    case COORD_SYSTEM_GLOBAL:   
        eCoordinate = COORDSYS_GLOBAL;
        break;

    case COORD_SYSTEM_PARENT: 
        eCoordinate = COORDSYS_PARENT;
        break;

    case COORD_SYSTEM_CONTAINER:
        eCoordinate = COORDSYS_BOX;
        break;

    case COORD_SYSTEM_CONTENT:
        eCoordinate = COORDSYS_FLOWCONTENT;
        break;

    default:
        AssertSz( FALSE, "Invalid COORD_SYSTEM tag" );
        eCoordinate = COORDSYS_FLOWCONTENT;
    }


    return eCoordinate;
}

//+------------------------------------------------------------------------------------
//
// Method:    TransformPoint
//
// Synopsis:  Exposes CLayout::TransformPoint() to MshtmlEd via DisplayServices
//           
//-------------------------------------------------------------------------------------

HRESULT
CDoc::TransformPoint ( POINT        * pPoint,
                       COORD_SYSTEM eSource,
                       COORD_SYSTEM eDestination,
                       IHTMLElement * pIElement )                        
{
    HRESULT         hr;
    CElement    *   pElement;
    CTreeNode   *   pNode;
    CLayout *       pLayout;

    if (!pPoint || !pIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pIElement->QueryInterface( CLSID_CElement, (void** ) & pElement ));
    if ( hr )
        goto Cleanup;

    pNode = pElement->GetFirstBranch();
    if ( ! pNode )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    pLayout = pNode->GetUpdatedNearestLayout();
    if ( ! pLayout )
    {
        CheckSz(0, "Has no layout ");
        hr = E_FAIL;
        goto Cleanup;
    }

    if( eSource == COORD_SYSTEM_FRAME && eDestination != COORD_SYSTEM_GLOBAL )
    {
        AssertSz(0, "Invalid Transform");
        hr = E_FAIL;
        goto Cleanup;
    }

    g_uiDisplay.DeviceFromDocPixels(pPoint);

    {
        CPoint cpoint( pPoint->x, pPoint->y );
    
        if( eSource == COORD_SYSTEM_FRAME )
        {
            POINT ptOrigin;
        
            //
            // We are transforming from FRAME coordinate systems to GLOBAL coordinate
            // systems.  In this case, simply call GetClientOrigin in order to get the
            // coordinates of the parent frame (if there is one) in Global coords
            // 
            pElement->GetClientOrigin( &ptOrigin );

            pPoint->x += ptOrigin.x;
            pPoint->y += ptOrigin.y;
        }
        else
        {
            //
            // Perform the given transform
            //
            pLayout->TransformPoint( &cpoint, 
                                         MapToCoordinateEnum( eSource ), 
                                         MapToCoordinateEnum( eDestination ),
                                         NULL );
            pPoint->x = cpoint.x;
            pPoint->y = cpoint.y;
        }
    }


    g_uiDisplay.DocPixelsFromDevice(pPoint);

Cleanup:
    RRETURN( hr );

}

//+------------------------------------------------------------------------------------
//
// Method:    TransformRect
//
// Synopsis:  Exposes CLayout::TransformRect() to the editor via IDisplayServices
//           
//-------------------------------------------------------------------------------------

HRESULT
CDoc::TransformRect(RECT            *pRect,
                    COORD_SYSTEM    eSource,
                    COORD_SYSTEM    eDestination,
                    IHTMLElement    *pIElement )                        
{
    HRESULT             hr;
    CElement            *pElement;
    CTreeNode           *pNode;
    CLayout             *pLayout;
    CRect               rectInternal;

    if( !pIElement || !pRect )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    rectInternal.left = pRect->left;
    rectInternal.top = pRect->top;
    rectInternal.right = pRect->right;
    rectInternal.bottom = pRect->bottom;
    
    hr = THR( pIElement->QueryInterface( CLSID_CElement, (void **) &pElement ));
    if ( hr )
        goto Cleanup;

    pNode = pElement->GetFirstBranch();
    if( !pNode )
    {
        AssertSz(0, "No longer in Tree");
        hr = E_FAIL;
        goto Cleanup;
    }
    
    pLayout = pNode->GetUpdatedNearestLayout();
    if ( !pLayout )
    {
        AssertSz(0, "Has no layout ");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Actually perform the transform
    //


    g_uiDisplay.DeviceFromDocPixels(&rectInternal);

    pLayout->TransformRect( &rectInternal, 
                            MapToCoordinateEnum( eSource ), 
                            MapToCoordinateEnum( eDestination ) );

    g_uiDisplay.DocPixelsFromDevice(&rectInternal);

    pRect->left = rectInternal.left;
    pRect->bottom = rectInternal.bottom;
    pRect->top = rectInternal.top;
    pRect->right = rectInternal.right;


Cleanup:
    RRETURN( hr );

}


HRESULT 
CDoc::GetActiveIMM(
    IActiveIMMApp** ppActiveIMM)
{
#ifndef NO_IME
    Assert(ppActiveIMM);

    extern IActiveIMMApp * GetActiveIMM();

    *ppActiveIMM = GetActiveIMM();
    if (*ppActiveIMM)
        (*ppActiveIMM)->AddRef();

    return S_OK;
#else
    return E_FAIL;
#endif
}


// declared in formkrnl.hxx

// MSAA expects GetNodeFromPoint()'s to take pt as COORDSYS_POINT (IE 86011)

CTreeNode *
CDoc::GetNodeFromPoint(
    const POINT &   pt,                              // [in] pt must be in either COORDSYS_BOX or COORDSYS_GLOBAL
    CLayoutContext**ppLayoutContext,                 // [out] layout context the returned tree node was hit in
    BOOL            fGlobalCoordinates,
    POINT *         pptContent /* = NULL */,
    LONG *          plCpMaybe /* = NULL */ ,
    BOOL*           pfEmptySpace /* = NULL */ ,
    BOOL *          pfInScrollbar /* = NULL */,
    CDispNode **    ppDispNode /*= NULL */)
{   
    AssertSz( ppLayoutContext, "Must pass an out param for layout context" );

    CTreeNode *         pTreeNode = NULL;
    
    POINT               ptContent;
    CDispNode *         pDispNode = NULL;
    COORDINATE_SYSTEM   coordSys;
    HITTESTRESULTS      HTRslts;
    HTC                 htcResult = HTC_NO;
    DWORD               dwHTFlags = HT_VIRTUALHITTEST |       // Turn on virtual hit testing
                                    HT_NOGRABTEST |           // Ignore grab handles if they exist
                                    HT_IGNORESCROLL;          // Ignore testing scroll bars                                  

    ptContent = g_Zero.pt;
    *ppLayoutContext = NULL;   

    if( fGlobalCoordinates )
        coordSys = COORDSYS_GLOBAL;    
    else
        coordSys = COORDSYS_BOX;

    //
    //  Do a hit test to figure out what node would be hit by this point.
    //  I know this seems like a lot of work to just get the TreeNode,
    //  but we have to do this. Also, we can't trust the cp returned in
    //  HTRslts. Some day, perhaps we can.
    //

    if( !_view.IsActive() ) 
        goto Cleanup;

    htcResult = _view.HitTestPoint( pt, 
                                    &coordSys,
                                    NULL,
                                    dwHTFlags, 
                                    &HTRslts,
                                    &pTreeNode, 
                                    ptContent, 
                                    &pDispNode,
                                    ppLayoutContext);

Cleanup:
    if( pptContent != NULL )
    {
        pptContent->x = ptContent.x;
        pptContent->y = ptContent.y;
    }

    if( plCpMaybe != NULL )
    {
        *plCpMaybe = HTRslts._cpHit;
    }
    
    if ( pfEmptySpace )
    {
        *pfEmptySpace = HTRslts._fWantArrow;
    }

    if ( ppDispNode )
    {
        *ppDispNode = pDispNode;
    }
    
    return pTreeNode;
}



//+====================================================================================
//
// Method: ScrollPointersIntoView
//
// Synopsis: Given two pointers ( that denote a selection). Do the "right thing" to scroll
//           them into view.
//
//------------------------------------------------------------------------------------

HRESULT
CDoc::ScrollPointersIntoView(
    IMarkupPointer *    pStart,
    IMarkupPointer *    pEnd)
{
    HRESULT hr = S_OK;
    CTreeNode* pNode;
    CFlowLayout* pFlowLayout ;
    CMarkupPointer* pPointerInternal = NULL;
    CMarkupPointer* pPointerInternal2 = NULL;
    int cpStart, cpEnd, cpTemp;

    hr = THR( pStart->QueryInterface(CLSID_CMarkupPointer, (void **)&pPointerInternal ));
    if ( hr )
        goto Cleanup;

        
    hr = THR( pEnd->QueryInterface(CLSID_CMarkupPointer, (void **)&pPointerInternal2 ));
    if ( hr )
        goto Cleanup;
        
    pNode = pPointerInternal->CurrentScope(MPTR_SHOWSLAVE);
    pFlowLayout = pNode->GetFlowLayout();

    if (pFlowLayout)
    {
        cpStart = pPointerInternal->GetCp();
        cpEnd = pPointerInternal2->GetCp();
        if ( cpStart > cpEnd )
        {
            cpTemp = cpStart ;
            cpStart = cpEnd;
            cpEnd = cpTemp;
        }


        pFlowLayout->ScrollRangeIntoView( cpStart, cpEnd , SP_MINIMAL , SP_MINIMAL);
    }
    
Cleanup:
    RRETURN ( hr );
}

HRESULT
CDoc::ScrollPointerIntoView(
    IMarkupPointer *    pPointer,
    BOOL                fNotAtBOL,
    POINTER_SCROLLPIN   eScrollAmount )
{
    HRESULT hr = S_OK;
    CFlowLayout * pFlowLayout = NULL;
    SCROLLPIN ePin = SP_MINIMAL;
    HTMLPtrDispInfoRec LineInfo;
    CMarkupPointer* pPointerInternal = NULL ;
    CTreeNode* pNode;
    CFlowLayout* pNodeFlow = NULL;
    CSize viewSize;
    
    GetLineInfo( pPointer, fNotAtBOL, &LineInfo );
    

    LONG x, y, delta, height, clipX, clipY;
    x = LineInfo.lXPosition;
    y = LineInfo.lBaseline;
    delta = LineInfo.lLineHeight ;

    GetView()->GetViewSize( & viewSize);
    clipX = viewSize.cx / 4;
    clipY = viewSize.cy / 4;
    
    height = min( (int) LineInfo.lLineHeight , (int) clipY);
    CRect rc( x - min( delta , clipX  ) , y - height, x + min( delta, clipX )  , y + LineInfo.lDescent + 2  );

    hr = THR( pPointer->QueryInterface( CLSID_CMarkupPointer, (void**) & pPointerInternal ));
    if ( hr )
        goto Cleanup;
        
    pNode = pPointerInternal->CurrentScope(MPTR_SHOWSLAVE);
    if ( pNode )
        pNodeFlow = pNode->GetFlowLayout();
    else
    {
        hr = E_FAIL;
        goto Cleanup;
    }        

    switch( eScrollAmount )
    {
        case POINTER_SCROLLPIN_TopLeft:
            ePin = SP_TOPLEFT;
            break;
        case POINTER_SCROLLPIN_BottomRight:
            ePin = SP_BOTTOMRIGHT;
            break;        
        default:
            ePin = SP_MINIMAL;
            break;
    }

    //
    // We always scroll on the _pElemEditContext
    //
    if ( _pElemCurrent )
        pFlowLayout = _pElemCurrent->GetFirstBranch()->GetFlowLayout();

    if ( pFlowLayout && pNodeFlow )
    {            
        TraceTag(( tagViewServicesShowScrollRect, "ScrollRect: left:%ld top:%ld right:%ld bottom:%ld",
                                rc.left, rc.top, rc.right, rc.bottom ));
            
        pNodeFlow->ScrollRectIntoView( rc, ePin , ePin );
    }        
    else
        hr = E_FAIL;
        
Cleanup:        
    return hr;
}

//+====================================================================================
//
// Method: ScrollRectIntoView
//
// Synopsis: Scroll any arbitrary rect into view on a given elemnet.
//
//------------------------------------------------------------------------------------

HRESULT
CDoc::ScrollRectIntoView( IHTMLElement* pIElement, RECT rect)
{
    HRESULT hr = S_OK;
    CElement* pElement;

    g_uiDisplay.DeviceFromDocPixels(&rect);
    
    hr = THR( pIElement->QueryInterface( CLSID_CElement, (void**) & pElement ));
    if ( hr )
        goto Cleanup;
        
    
    if ( pElement && pElement->GetFirstBranch() )
    {
        CFlowLayout* pScrollLayout = NULL;        

        pScrollLayout = pElement->GetFirstBranch()->GetFlowLayout();
            
        Assert( pScrollLayout );
        if ( pScrollLayout )
        {   
            pScrollLayout->TransformRect(&rect, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT);
            {
                CRect r(rect);            
                pScrollLayout->ScrollRectIntoView( r, SP_MINIMAL, SP_MINIMAL );
            }
        }
        else
            hr = E_FAIL;
    }
    else
        hr = E_FAIL;
Cleanup:
    RRETURN( hr );
}



HRESULT 
CDoc::IsSite( 
    IHTMLElement *  pIElement, 
    BOOL*           pfSite, 
    BOOL*           pfText, 
    BOOL*           pfMultiLine, 
    BOOL*           pfScrollable )
{
    HRESULT hr = S_OK;
    CElement * pElement = NULL;
    CTreeNode * pNode = NULL;
    
    BOOL fSite = FALSE;
    BOOL fText = FALSE;
    BOOL fMultiLine = FALSE;
    BOOL fScrollable = FALSE;
    
    if (! pIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( pIElement->QueryInterface( CLSID_CElement, (void**) & pElement ));
    if ( hr )
        goto Cleanup;

    if (pElement->HasMasterPtr())
    {
        pElement = pElement->GetMasterPtr();
        if (!pElement)
        {
            goto Cleanup;
        }

    }

    pNode = pElement->GetFirstBranch();
    if( pNode == NULL )
        goto Cleanup;
        
    fSite = pNode->ShouldHaveLayout();

    if( pfText )
    {
        CFlowLayout * pLayout = NULL;
        pLayout = pNode->HasFlowLayout();

        if( pLayout != NULL )
        {
            fText = TRUE;
            fSite = TRUE;
        }

        if( fText && pfMultiLine )
        {
            fMultiLine = pLayout->GetMultiLine();
        }

        // TODO (johnbed) we may at some point want to break this apart from the flow layout check
        if( fText && pfScrollable )
        {
            CDispNode * pDispNode = pLayout->GetElementDispNode();
            fScrollable = pDispNode && pDispNode->IsScroller();
        }
    }
    
Cleanup:
    if( pfSite )
        *pfSite = fSite;

    if( pfText )
        *pfText = fText;

    if( pfMultiLine )
        *pfMultiLine = fMultiLine;

    if( pfScrollable )
        *pfScrollable = fScrollable;

    RRETURN( hr );
}


//+====================================================================================
//
// Method: QueryBreaks
//
// Synopsis: Returnline break information associated with a given pointer
//
//------------------------------------------------------------------------------------


HRESULT
CDoc::QueryBreaks ( IMarkupPointer * pPointer, DWORD * pdwBreaks, BOOL fWantPendingBreak )
{
    HRESULT             hr;
    CMarkupPointer *    pmpPointer = NULL;
    CLineBreakCompat    breaker;   

    hr = THR( pPointer->QueryInterface( CLSID_CMarkupPointer, (void **) & pmpPointer ) );
    if (hr)
        return hr;

    breaker.SetWantPendingBreak ( fWantPendingBreak );

    return breaker.QueryBreaks( pmpPointer, pdwBreaks );
}

//+====================================================================================
//
// Method: GetCursorForHTC
//
// Synopsis: Gets the Cursor for an HTC value 
//
//------------------------------------------------------------------------------------

LPCTSTR
CDoc::GetCursorForHTC( HTC inHTC )
{
    Assert( inHTC >= HTC_TOPBORDER );
    Assert( inHTC <= HTC_BOTTOMRIGHTHANDLE);

    return astrCursor[inHTC - HTC_TOPBORDER ];
}

//+====================================================================================
//
// Method: CurrentScopeOrSlave
//
// Synopsis: Returns the current scope for a pointer, like CurrentScope; but
//           can also return the slave element
//
//------------------------------------------------------------------------------------
HRESULT
CDoc::CurrentScopeOrSlave ( IMarkupPointer * pPointer, IHTMLElement **ppElemCurrent )
{
    HRESULT hr = S_OK;
    CMarkupPointer *    pmp = NULL;
    CTreeNode * pNode;

    if (!ppElemCurrent)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppElemCurrent = NULL;
    
    hr = THR( pPointer->QueryInterface( CLSID_CMarkupPointer, (void **) & pmp ) );
    if (hr)
        goto Cleanup;
        
    pNode = pmp->CurrentScope(MPTR_SHOWSLAVE);
    
    if (pNode)
    {
        hr = THR(
            pNode->GetElementInterface(
                IID_IHTMLElement, (void **) ppElemCurrent ) );

        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr );
}


//
// IEditDebugServices Methods.
//
#if DBG == 1

//+====================================================================================
//
// Method: GetCp
//
// Synopsis: Gets the CP of a pointer. -1 if it's unpositioned
//
//------------------------------------------------------------------------------------


HRESULT
CDoc::GetCp( IMarkupPointer* pIPointer, long* pcp)
{
    HRESULT hr = S_OK;
    CMarkupPointer* pPointer = NULL;
    long cp = 0;
    
    hr = THR( pIPointer->QueryInterface( CLSID_CMarkupPointer, (void**) & pPointer ));
    if ( hr ) 
        goto Cleanup;

    cp = pPointer->GetCp();
        
Cleanup:
    if ( pcp )
        *pcp = cp;
        
    RRETURN ( hr );
}


//+====================================================================================
//
// Method: SetDebugName
//
// Synopsis: Allows setting of Debug Name on an IMarkupPointer. This name then shows up
//           in DumpTree's.
//
//------------------------------------------------------------------------------------

HRESULT
CDoc::SetDebugName( IMarkupPointer* pIPointer, LPCTSTR strDebugName )
{
    HRESULT hr = S_OK;
    CMarkupPointer* pPointer = NULL;

    
    hr = THR( pIPointer->QueryInterface( CLSID_CMarkupPointer, (void**) & pPointer ));
    if ( hr ) 
        goto Cleanup;

    pPointer->SetDebugName( strDebugName);
    
Cleanup:

    RRETURN ( hr );

}

//+====================================================================================
//
// Method: SetDisplaypointerDebugName
//
// Synopsis: Allows setting of Debug Name on an IDisplayPointer. This name then shows up
//           in DumpTree's.
//
//------------------------------------------------------------------------------------

HRESULT
CDoc::SetDisplayPointerDebugName( IDisplayPointer* pDispPointer, LPCTSTR strDebugName )
{
    HRESULT hr = S_OK;
    CDisplayPointer* pDispPointerInternal = NULL;

    
    hr = THR( pDispPointer->QueryInterface( CLSID_CMarkupPointer, (void**) & pDispPointerInternal ));
    if ( hr ) 
        goto Cleanup;

    pDispPointerInternal->SetDebugName( strDebugName);
    
Cleanup:

    RRETURN ( hr );

}

//+====================================================================================
//
// Method: DumpTree
//
// Synopsis: Calls dumptree on an IMarkupPointer.
//
//------------------------------------------------------------------------------------
HRESULT
CDoc::DumpTree( IMarkupPointer* pIPointer)
{
    HRESULT hr = S_OK;
    CMarkupPointer* pPointer = NULL;
    CMarkup * pMarkup = NULL;

    if (pIPointer)
    {
        hr = THR( pIPointer->QueryInterface( CLSID_CMarkupPointer, (void**) & pPointer ));
        
        if ( hr ) 
            goto Cleanup;

        pMarkup = pPointer->Markup();
    }
    
    if (!pMarkup)
        pMarkup = PrimaryMarkup();

    if (pMarkup)
        pMarkup->DumpTree();
    
Cleanup:

    RRETURN ( hr );
}


//+====================================================================================
//
// Method: LinesInElement
//
// Synopsis: Calls LinesInElement on CElement.
//
//------------------------------------------------------------------------------------
HRESULT
CDoc::LinesInElement(IHTMLElement *pIHTMLElement, long *piLines)
{
    CElement *pElement;
    HRESULT hr = E_INVALIDARG;

    if (!piLines)
        goto Cleanup;
    if(pIHTMLElement)
    {
        hr = THR(pIHTMLElement->QueryInterface(CLSID_CElement, (void **)&pElement));
        if(hr)
            goto Cleanup;
        *piLines = pElement->GetLineCount();
    }

Cleanup:
    RRETURN(hr);
}

//+====================================================================================
//
// Method: FontsOnLine
//
// Synopsis: Calls FontsOnLine on the CElement.
//
//------------------------------------------------------------------------------------
HRESULT 
CDoc::FontsOnLine(IHTMLElement *pIHTMLElement, long iLine, BSTR *pbstrFonts)
{
    CElement *pElement;
    HRESULT hr = E_INVALIDARG;
    
    if(pIHTMLElement)
    {
        hr = THR(pIHTMLElement->QueryInterface(CLSID_CElement, (void **)&pElement));
        if (hr)
            goto Cleanup;
        hr = THR(pElement->GetFonts(iLine, pbstrFonts));
        if (hr)
            goto Cleanup;
    }
Cleanup:
    RRETURN(hr);
}


//+====================================================================================
//
// Method: GetPixel
//
// Synopsis: Gets the pixel value
//
//------------------------------------------------------------------------------------
HRESULT
CDoc::GetPixel(long X, long Y, long *piColor)
{
    HRESULT hr = E_INVALIDARG;

    if (!piColor)
        goto Cleanup;

    if (   _pInPlace
        && _pInPlace->_hwnd
       )
    {
        *piColor = (long)::GetPixel(::GetDC(_pInPlace->_hwnd), X, Y);
    }
    else
    {
        *piColor = long(CLR_INVALID);
    }

    hr = S_OK;

Cleanup:
    RRETURN(hr);
}

//+====================================================================================
//
// Method: IsUsingBckgrnRecalc
//
// Synopsis: Determines whether background recalc has been executed.
//
//------------------------------------------------------------------------------------
HRESULT 
CDoc::IsUsingBckgrnRecalc(BOOL *pfUsingBckgrnRecalc)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pfUsingBckgrnRecalc)
    {
        *pfUsingBckgrnRecalc = _fUsingBckgrnRecalc;
        hr = S_OK;
    }

    RRETURN(hr);
}

//+====================================================================================
//
// Method: IsUsingTableIncRecalc 
//
// Synopsis: Determines whether table incremental recalc has been executed.
//
//------------------------------------------------------------------------------------
HRESULT 
CDoc::IsUsingTableIncRecalc(BOOL *pfUsingTableIncRecalc)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pfUsingTableIncRecalc)
    {
        *pfUsingTableIncRecalc = _fUsingTableIncRecalc;
        hr = S_OK;
    }

    RRETURN(hr);
}

//+====================================================================================
//
// Method: IsEncodingAutoSelect
//
// Synopsis: Determines whether encoding Auto-Select is on or off.
//
//------------------------------------------------------------------------------------
HRESULT 
CDoc::IsEncodingAutoSelect(BOOL *pfEncodingAutoSelect)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pfEncodingAutoSelect)
    {
        *pfEncodingAutoSelect = IsCpAutoDetect();
        hr = S_OK;
    }

    RRETURN(hr);
}

//+====================================================================================
//
// Method: EnableEncodingAutoSelect
//
// Synopsis: Enables / disables encoding Auto-Select.
//
//------------------------------------------------------------------------------------
HRESULT 
CDoc::EnableEncodingAutoSelect(BOOL fEnable)
{
    HRESULT hr = S_OK;

    SetCpAutoDetect(fEnable);
    
    RRETURN(hr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\unixbase.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:       src\site\base\unixbase.cxx
//
//  Contents:   Implementation of Unix specific/different operations
//
//  Classes:    
//
//  Functions:
//
//  History:    03-Sep-97   davidd    Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "formkrnl.hxx"

EXTERN_C char *MwGetXDisplayString( void );

HRESULT CDoc::InvokeEditor( LPCSTR lpszPath )
{
    HKEY  hkeyUnix;
    CHAR  szCommand [2*MAX_PATH];
    CHAR  szCmdTempl[MAX_PATH+1];
    CHAR  szName    [MAX_PATH+1];
    CHAR  hKeyName  [MAX_PATH+1];

    STARTUPINFOA st;
    PROCESS_INFORMATION pi;

    BOOL  bIsKnownEdit  = FALSE;
    char  displayString [2*MAX_PATH];
    DWORD editors       = 0;
    DWORD type          = REG_SZ;
    DWORD dwLength      = sizeof(szCmdTempl);

    if( MwGetXDisplayString() )
        sprintf( displayString, "-display %s", MwGetXDisplayString() );
    else
        sprintf( displayString, " ");
        

    // Get user preferred editor.

    if( getenv("EDITOR" ) )
       strcpy(szName, getenv("EDITOR") );
    else
       strcpy(szName, "vi");

    // Check editor against the list of known editors in 
    // registry.

    sprintf( hKeyName, 
             "Software\\Microsoft\\Internet Explorer\\Unix\\Editors\\%s",
             szName );

    LONG lResult = RegOpenKeyExA(
       HKEY_CURRENT_USER,
       hKeyName,
       0,
       KEY_QUERY_VALUE,
       &hkeyUnix);

    if (lResult == ERROR_SUCCESS) 
    {
        // Read command template for the registered editor

        lResult = RegQueryValueExA(
           hkeyUnix,
           "command",
           NULL,
           (LPDWORD) &type,
           (LPBYTE)  &szCmdTempl,
           (LPDWORD) &dwLength);

        if( lResult == ERROR_SUCCESS )
            bIsKnownEdit = TRUE;
            
        RegCloseKey(hkeyUnix);

    }

    // Create proper command and append dissplay string to make the
    // editor appear on the same XServer as the Iexplorer.
    if( !bIsKnownEdit )
    {
        // Default use vi
        sprintf( szCommand, "xterm %s -e vi %s ", displayString, lpszPath  );
    }
    else
    {
        // Use template command from registry to create actual command.
        sprintf( szCommand, szCmdTempl, displayString, lpszPath );
    }

    // Initialize startup info struct.
    st.cb = sizeof(STARTUPINFO);
    st.lpReserved = NULL;
    st.lpDesktop  = NULL;
    st.lpTitle    = NULL;
    st.dwFlags    = 0;
    st.wShowWindow= SW_SHOWNORMAL;
    st.cbReserved2= 0;
    st.lpReserved2= NULL;

    // Launch the command
    if ( CreateProcessA( NULL, szCommand, NULL, NULL, TRUE, 
                         CREATE_NEW_CONSOLE, NULL, NULL, &st, &pi )) 
    {
        return S_OK;
    }

    RRETURN( GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\verifycallstack.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       window.cxx
//
//  Contents:   Implementation of CWindow, CScreen classes
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#if DBG==1

#ifndef X_VERIFYCALLSTACK_HXX_
#define X_VERIFYCALLSTACK_HXX_
#include "VerifyCallStack.hxx"
#endif

//
// Walk call stack to verify that the call is coming from the right caller
//
// PARAMS:
// pchOneModule - if specified, Assert if no good caller was found before a caller from a different module
// pCallers - array of VERIFYSTACK_CALLERINFO
// cCallers - size of the array
//
// RETURN: S_OK if a good caller is found, E_FAIL otherwise
//
HRESULT VerifyCallStack(const char *pchOneModule, 
                        const VERIFYSTACK_CALLERINFO *aCallers, 
                        int cCallers, 
                        VERIFYSTACK_SYMBOLINFO *pBuffer, 
                        int cbBuffer,
                        int *piBadCaller)   // index of problem caller in the buffer
{
    const int iFirstCaller = 1; // this is how far we are from the first caller or interest
    
    int cMaxStack = cbBuffer / sizeof(VERIFYSTACK_SYMBOLINFO);
    int iFirstFrame = cMaxStack;
    int iLastFrame = 0;
    int iCaller;
    int cStack;
    HRESULT hr = S_OK;

    if (piBadCaller)
        *piBadCaller = 0;

    // get the widest frame range
    for (iCaller = 0; iCaller < cCallers; iCaller++)
    {
        if (iFirstFrame > aCallers[iCaller].iFirstToCheck)
            iFirstFrame = aCallers[iCaller].iFirstToCheck;
        
        if (iLastFrame < aCallers[iCaller].iLastToCheck)
            iLastFrame = aCallers[iCaller].iLastToCheck;
    }

    // we handle at most cMaxStack frames
    if (iLastFrame - iFirstFrame + 1 > cMaxStack)
        iLastFrame = iFirstFrame - 1 + cMaxStack;

    // Get stack
    cStack = DbgExGetStackTrace(iFirstCaller + iFirstFrame, 
                                iLastFrame - iFirstFrame + 1, 
                                (BYTE *) pBuffer, 
                                cbBuffer, 
                                VERIFYSTACK_SYMBOLINFO::cchMaxModule, 
                                VERIFYSTACK_SYMBOLINFO::cchMaxSymbol); 
    
    if (!cStack)
    {
        AssertSz(FALSE, "VerifyCallStack: failed to get stack symbols");
        goto Cleanup;
    }

    // look for the modules/symbols
    int iFrame = iFirstCaller + iFirstFrame;
    BOOL fHaveGood = FALSE;
    for (int i = 0; i < cStack; i++, iFrame++)
    {
        // If must stay in one module, check that
        if (pchOneModule && *pchOneModule &&
            0 != strncmp(pBuffer[i].achModule, pchOneModule, VERIFYSTACK_SYMBOLINFO::cchMaxModule))
        {
            break;
        }

        // Check for callers of interest
        const VERIFYSTACK_CALLERINFO *pCaller = aCallers;
        for (iCaller = 0; iCaller < cCallers; iCaller++, pCaller++)
        {
            if ((pCaller->pchSymbol == NULL ||
                 !*pCaller->pchSymbol ||
                 0 == strncmp(pBuffer[i].achSymbol, pCaller->pchSymbol, VERIFYSTACK_SYMBOLINFO::cchMaxSymbol)
                )
                &&
                0 == strncmp(pBuffer[i].achModule, pCaller->pchModule, VERIFYSTACK_SYMBOLINFO::cchMaxModule))
            {
                // it's a match!
                switch (pCaller->kCaller)
                {
                case CALLER_GOOD:
                    fHaveGood = TRUE;
                    break;
                case CALLER_BAD:
                    goto BadCaller;
                case CALLER_BAD_IF_FIRST:
                    if (!fHaveGood)
                        goto BadCaller;
                    break;
                default:
                    AssertSz(FALSE, "Bad Caller Kind");
                }
            }
        }
    }

    // All checked. If there were no good callers, assert
    if (fHaveGood)
        goto Cleanup;
            
BadCaller:
    // too bad, something went wrong
    hr = E_FAIL;
    if (piBadCaller)
        *piBadCaller = max(i, cStack);

Cleanup:
    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\wsmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       wsmgr.cxx
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#ifndef X_WSMGR_HXX_
#define X_WSMGR_HXX_
#include "wsmgr.hxx"
#endif

#ifndef X_MARKUP_HXX_
#define X_MARKUP_HXX_
#include "markup.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_FILLCODE_HXX_
#define X_FILLCODE_HXX_
#include "fillcode.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#define IFC(expr) {hr = THR(expr); if (FAILED(hr)) goto Cleanup;}

// this class contains \r (for whitespace/nonspace breaking in OutputText)
#define ISSPACE(ch) (((ch) == _T(' ')) || ((unsigned)((ch) - 9)) <= 13 - 9)

MtDefine(CWhitespaceManager, Mem, "CWhitespaceManager");
MtDefine(CWhitespaceManager_aryNodesToUpdate_pv, CWhitespaceManager, "CWhitespaceManager::aryNodesToUpdate::pv")

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::CWhitespaceManager, public
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CWhitespaceManager::CWhitespaceManager()
    : _aryNodesToUpdate(Mt(CWhitespaceManager_aryNodesToUpdate_pv))

{
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::CWhitespaceManager, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CWhitespaceManager::~CWhitespaceManager()
{
    if (_aryNodesToUpdate.Size())
    {
        GWKillMethodCall(this, ONCALL_METHOD(CWhitespaceManager, DeferredApplyChanges, deferredapplychanges), 0);
    }

    ReleaseNodes(_aryNodesToUpdate);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::RegisterWhitespaceChange, public
//
//  Synopsis:   Posts a deferred method call to apply whitespace changes asynchronously.
//
//  Arguments:  [pNode] - Nodes with pending collapsed whitespace change.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
    
HRESULT 
CWhitespaceManager::RegisterWhitespaceChange(CTreeNode *pNode)
{
    Assert(pNode);
    Assert(!pNode->IsDead());
    Assert(pNode->GetMarkup()->SupportsCollapsedWhitespace());
        
    //
    // Defer document change
    //

    // NOTE: if we have pending requests, then we already have a pending DeferredApplyChanges so we don't
    // need to create another one
    
    if (_aryNodesToUpdate.Size() == 0)
    {
        IGNORE_HR(GWPostMethodCall(this,
                                   ONCALL_METHOD(CWhitespaceManager, DeferredApplyChanges, deferredapplychanges),
                                   0,
                                   FALSE, "CWhitespaceManager::DeferredApplyChanges")); // There can be only one caret per cdoc
    }
    
    //
    // Append node to request list
    //
    
    pNode->NodeAddRef();
    _aryNodesToUpdate.Append(pNode);    

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CompareNodes, private
//
//  Synopsis:   To avoid processing the same nodes multiple times, we
//             take all requests and sort by:
//                 1. markup
//                 2. pre state (are we turning it on or off)
//                 3. CP of BeginPos 
//
//             With this sort order, we can elimate any nodes that are contained within
//             a previously processed node.
//
//  Arguments:  [pv1, pv2] - Nodes to be compared
//
//  Returns:    -1, 0, or 1 based on the usual qsort order
//
//----------------------------------------------------------------------------    

int RTCCONV
CompareNodes( const void * pv1, const void * pv2 )
{
    CTreeNode   *pNode1 = * (CTreeNode **) pv1;
    CTreeNode   *pNode2 = * (CTreeNode **) pv2;
    ULONG       cpStart1, cpStart2;
    BOOL        fPre1, fPre2;

    //
    // Treat dead nodes as infinite cp (we'll discard later)
    //
    
    if (pNode1->IsDead())
        return 1;

    if (pNode2->IsDead())
        return -1;

    //
    // Order by markup
    //

    if (pNode1->GetMarkup() < pNode2->GetMarkup())
        return -1;

    if (pNode1->GetMarkup() > pNode2->GetMarkup())
        return 1;
    
    //
    // Order by pre state
    //

    fPre1 = pNode1->GetParaFormat()->_fPreInner;
    fPre2 = pNode2->GetParaFormat()->_fPreInner;

    if (fPre1 < fPre2)
        return -1;

    if (fPre1 > fPre2)
        return 1;
           
    //
    // Order by start cp
    //

    cpStart1 = pNode1->GetBeginPos()->GetCp();
    cpStart2 = pNode2->GetBeginPos()->GetCp();

    if (cpStart1 < cpStart2)
        return -1;

    if (cpStart1 > cpStart2)
        return 1;

    return 0;    
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::DeferredApplyChanges, private
//
//  Synopsis:   Applies deferred whitespace change.
//
//  Arguments:  [dwContext] - unused but required by deferred method invocation
//
//  Returns:    void
//
//----------------------------------------------------------------------------    

void 
CWhitespaceManager::DeferredApplyChanges(DWORD_PTR dwContext)
{
    HRESULT hr = S_OK;
    CTreeNode **ppTreeNode;
    CTreeNode *pTreeNode;
    int        i;
    long        cpLast = 0;
    long        cpCurrent;
    CMarkup     *pLastMarkup = NULL;
    CMarkup     *pCurrentMarkup;
    BOOL        fPreLast = FALSE;
    BOOL        fPreCurrent;
    CPtrAry<CTreeNode *> aryNodesToUpdate(Mt(CWhitespaceManager_aryNodesToUpdate_pv));
    
    IFC( aryNodesToUpdate.Copy(_aryNodesToUpdate, FALSE) ); // steal ref from _aryNodesToUpdate
    _aryNodesToUpdate.DeleteAll();

    //
    // Sort nodes by first cp so that we can discard nested nodes
    //

    qsort(aryNodesToUpdate,
      aryNodesToUpdate.Size(),
      sizeof(CTreeNode*),
      CompareNodes);                

    //
    // Apply changes to each node
    //

    for (i = aryNodesToUpdate.Size(), ppTreeNode = aryNodesToUpdate;
        i > 0;
        i--, ppTreeNode++)
    {
        pTreeNode = *ppTreeNode;

        if (pTreeNode->IsDead())
        {
#if DBG==1
            {
                int         iDbg = i;
                CTreeNode   **ppDbgTreeNode = ppTreeNode;
                
                // Since dead TreeNodes have infinite weight in the sort, 
                // everything after this node should also be dead

                for (; iDbg > 0; iDbg--, ppDbgTreeNode++)
                {
                    Assert((*ppDbgTreeNode)->IsDead());
                }
            }            
#endif
            break; // we're done
        }

        pCurrentMarkup = pTreeNode->GetMarkup();
        cpCurrent = pTreeNode->GetBeginPos()->GetCp();
        fPreCurrent = pTreeNode->GetParaFormat()->_fPreInner;

        //
        // Make sure we don't apply changes to the scope of a node more
        // than once.
        //

        if (pCurrentMarkup != pLastMarkup
            || fPreCurrent != fPreLast
            || cpCurrent >= cpLast)
        {       
            IFC( ApplyChangesToNode(pTreeNode) );

            pLastMarkup = pCurrentMarkup;
            fPreLast = fPreCurrent;
            cpLast = pTreeNode->GetEndPos()->GetCp();
        }

        pTreeNode->SetPre(fPreCurrent);            
    }

Cleanup:
    ReleaseNodes(aryNodesToUpdate);
    ReleaseNodes(_aryNodesToUpdate);        
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::RemovePre, private
//
//  Synopsis:   Recollapse whitespace we expanded earlier
//
//  Arguments:  [pNodeToUpdate] - Node to update
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------    

HRESULT 
CWhitespaceManager::RemovePre(CTreeNode *pNodeToUpdate)
{
    HRESULT hr = S_OK;
    CMarkup *pMarkup = pNodeToUpdate->GetMarkup();
    CDoc    *pDoc = pMarkup->Doc();
    long cch;
    TCHAR ch;           
    MARKUP_CONTEXT_TYPE context;
    CMarkupPointer mp(pDoc);
    CMarkupPointer mpPrev(pDoc);
    CMarkupPointer mpEnd(pDoc);
    CTreeNode *pNode, *pNodeScope;
    ULONG fillcode;
    BOOL fHasSpace = FALSE;
    BOOL fEatSpace = FALSE;
    BOOL fDone;
    BOOL fLeftIsPre, fRightIsPre;

    mp.SetAlwaysEmbed( TRUE );
    mpEnd.SetAlwaysEmbed( TRUE );
    IFC( mp.MoveToReference(pNodeToUpdate->GetBeginPos()->NextTreePos(), 0, pMarkup, -1) );
    IFC( mpEnd.MoveToReference(pNodeToUpdate->GetEndPos()->NextTreePos(), 0, pMarkup, -1) );    

    fillcode = FillCodeFromEtag(pNodeToUpdate->Tag());  
    IFC( RFill(&mp, FILL_RB(fillcode), &fHasSpace, &fEatSpace) );

    do
    {
        IFC( mpPrev.MoveToPointer(&mp) );        
        
        cch = -1;
        IFC( mp.Right(TRUE, &context, &pNode, &cch, &ch, NULL) );

        //
        // We only remove pre-ness if we are contained within !_fPre.  So,
        // keep track of the value of the format cache to the left and right
        // of our current position
        //
        
        pNodeScope = mpPrev.CurrentScope();
        fLeftIsPre = pNodeScope ? pNodeScope->GetParaFormat()->_fPreInner : FALSE;

        pNodeScope = mp.CurrentScope();
        fRightIsPre = pNodeScope ? pNodeScope->GetParaFormat()->_fPreInner : FALSE;

        switch (context)
        {
            case CONTEXT_TYPE_Text:     
                if (!fLeftIsPre)
                    IFC( CollapseWhitespace(&mpPrev, &mp, &fHasSpace, &fEatSpace) );
                break;

            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_NoScope:
                Assert(pNode);
                fillcode = FillCodeFromEtag(pNode->Tag());  

                if (!fLeftIsPre)
                    IFC( LFill(&mpPrev, FILL_LB(fillcode), &fHasSpace, &fEatSpace) );

                if (!fRightIsPre)
                {
                    IFC( RFill(&mp, FILL_RB(fillcode), &fHasSpace, &fEatSpace) );
                }
                else
                {
                    fHasSpace = FALSE;
                    fEatSpace = TRUE;                    
                }

                pNode->SetPre(FALSE);
                break;
                
            case CONTEXT_TYPE_ExitScope:
                Assert(pNode);
                fillcode = FillCodeFromEtag(pNode->Tag());  
                
                if (!fLeftIsPre)
                    IFC( LFill(&mpPrev, FILL_LE(fillcode), &fHasSpace, &fEatSpace) );
                
                if (!fRightIsPre)
                {
                    IFC( RFill(&mp, FILL_RE(fillcode), &fHasSpace, &fEatSpace) );
                }
                else
                {
                    fHasSpace = FALSE;
                    fEatSpace = TRUE;                                        
                }
                break;

        }        

        IFC( mp.IsRightOf(&mpEnd, &fDone) );            
    }
    while (!fDone);


Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::CollapseWhitespace, private
//
//  Synopsis:   Recollapse whitespace we expanded earlier
//
//  Arguments:  [pmpLeft] - Pointer positioned left of text to be collapsed
//              [pmpRight] - Pointer positioned right of text to be collapsed
//              [pfHasSpace] - state for whitespace collapsing (ported from parser)
//              [pfEatSpace] - state for whitespace collapsing (ported from parser)
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------    

HRESULT 
CWhitespaceManager::CollapseWhitespace(CMarkupPointer *pmpLeft, CMarkupPointer *pmpRight, BOOL *pfHasSpace, BOOL *pfEatSpace)
{
    HRESULT hr = S_OK;
    ULONG cpStart, cpEnd;
    CDoc *pDoc = pmpLeft->Doc();
    CMarkup *pMarkup = pmpLeft->Markup();
    CMarkupPointer mpInsert(pDoc);
    CMarkupPointer mpStart(pDoc);
    CMarkupPointer mp(pDoc);
    CTxtPtr tp(pMarkup);
    CTxtPtr tpNext(pMarkup);
    CTxtPtr tpStart(pMarkup);
    TCHAR ch;
    CTreePos *ptp = NULL;
    TCHAR *pchWhitespace = NULL;
    LONG cch;

    mpInsert.SetAlwaysEmbed(TRUE);
    
    IFC( mp.MoveToPointer(pmpLeft) );
        
    do
    {
        //
        // Add pending whitespace
        //
        
        if (*pfHasSpace)
        {
            if (!(*pfEatSpace))
                IFC( AddSpace(&mp) );

            *pfHasSpace = FALSE;
        }

            
        tp.SetCp(mp.GetCp());
        cpEnd = pmpRight->GetCp();

        //
        // Skip nonspaces
        //
        
        if (!ISSPACE(tp.GetChar()))
        {
            *pfEatSpace = FALSE;
            
            for (tp.SetCp(mp.GetCp()); tp.GetCp() < cpEnd; tp.AdvanceCp(1))
            {
                ch = tp.GetChar();

                if (ch == ' ' && (tp.GetCp() + 1 < cpEnd))
                {
                    tpNext.SetCp(tp.GetCp()+1);
                    if (!ISSPACE(tpNext.GetChar()))
                    {
                        tp.SetCp(tpNext.GetCp());
                        continue;
                    }
                }
                
                if (ISSPACE(ch))
                    break;
            }

            if (tp.GetCp() >= cpEnd)
                break;
        }
        
        //
        // Store whitespace range
        //

        cpStart = tp.GetCp();
        while (ISSPACE(tp.GetChar()) && tp.GetCp() < cpEnd)
            tp.AdvanceCp(1);
        
        cpEnd = tp.GetCp();
        
        IFC( mpStart.MoveToCp(cpStart, pMarkup) );
        IFC( mp.MoveToCp(cpEnd, pMarkup) );

        cch = cpEnd - cpStart;
        pchWhitespace = new TCHAR[cch + 1];
        if (!pchWhitespace)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        tpStart.SetCp(cpStart);
        tpStart.GetRawText(cch, pchWhitespace);
        pchWhitespace[cch] = '\0';

        //
        // Remove whitespace from text store
        //
        
        IFC( pDoc->Remove(&mpStart, &mp) );

        //
        // Insert whitespace pointer
        //

        IFC( mpInsert.MoveToPointer(&mp) );

        ptp = pMarkup->NewPointerPos(NULL, FALSE, TRUE, TRUE);
        if (!ptp)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        
        ptp->SetCollapsedWhitespace(pchWhitespace);
        pchWhitespace = NULL;

        IFC( pMarkup->EmbedPointers() );
        IFC( pMarkup->Insert(ptp, mpInsert.GetEmbeddedTreePos(), FALSE) );        
        ptp = NULL;        
        
        IFC( mpInsert.Unposition() );
        
        *pfHasSpace = TRUE;
    }
    while (mp.GetCp() < pmpRight->GetCp());
    
Cleanup:
    delete [] pchWhitespace;
    delete ptp;
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::ApplyPre, private
//
//  Synopsis:   Expand collapsed whitespace
//
//  Arguments:  [pNode] - Node that contains the whitespace to be expanded
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------    

HRESULT 
CWhitespaceManager::ApplyPre(CTreeNode *pNode)
{
    HRESULT hr = S_OK;
    CTreePos *ptp;
    CTreePos *ptpEnd = pNode->GetEndPos();
    TCHAR   *pchCollapsedWhitespace;
    CMarkup *pMarkup = pNode->GetMarkup();
    CDoc    *pDoc = pMarkup->Doc();
    CMarkupPointer mp(pDoc);
    CMarkupPointer mpRight(pDoc);
    BOOL fIgnoreFirstCR, fNextIgnoreFirstCR = FALSE;
    long cch;
    TCHAR ch;           
    MARKUP_CONTEXT_TYPE context;
    BOOL fApplyPre = TRUE;
    
    mp.SetAlwaysEmbed(TRUE);

    fIgnoreFirstCR = (pNode->GetFancyFormat()->IsWhitespaceSet() && pNode->GetParaFormat()->_fPreInner)
                     || pNode->Tag() == ETAG_PRE;

    for (ptp = pNode->GetBeginPos()->NextTreePos(); 
         ptp != ptpEnd; 
         ptp = ptp->NextTreePos())
    {
        if (ptp->IsPointer() && fApplyPre)
        {
            pchCollapsedWhitespace = ptp->GetCollapsedWhitespace();
            if (pchCollapsedWhitespace)
            {
                IFC( mp.MoveToReference(ptp, 0, pMarkup, -1) ); 
                ptp->SetCling(FALSE);

                //
                // Remove exisiting space if required
                //

                // NOTE: Gravity is set to right iff we attached to a whitespace character
                if (ptp->Gravity())
                {

                    IFC( mpRight.MoveToPointer(&mp) );
                    cch = 1;
                    IFC( mpRight.Right(TRUE, &context, NULL, &cch, &ch) );
                    
                    if (context == CONTEXT_TYPE_Text && cch && ch == ' ')
                        IFC( pDoc->Remove(&mp, &mpRight) )
                    else
                        AssertSz(0, "Can't find associated space for collapsed whitespace");

                    IFC( mpRight.Unposition() );
                }

                //
                // Expand collapsed whitespace
                //
                               
                if (fIgnoreFirstCR && *pchCollapsedWhitespace == '\r')
                    pchCollapsedWhitespace++;

                if (*pchCollapsedWhitespace != '\0')
                    IFC( pDoc->InsertText(pchCollapsedWhitespace, -1, &mp) );
                

                //
                // Remove tree pos and advance ptp
                //

                IFC( pMarkup->RemovePointerPos(ptp, NULL, NULL) );  
                ptp = mp.GetEmbeddedTreePos();

            }
        }
        else if (ptp->IsBeginNode())
        {
            fApplyPre = ptp->Branch()->GetParaFormat()->_fPreInner;                
            if (fApplyPre)
            {
                ptp->Branch()->SetPre(TRUE);
                fNextIgnoreFirstCR = ptp->Branch()->GetFancyFormat()->IsWhitespaceSet();
            }
        }
        else if (ptp->IsEndNode())
        {
            CTreeNode *pParentNode = ptp->Branch()->Parent();

            if (pParentNode)
            {
                fApplyPre = pParentNode->GetParaFormat()->_fPreInner;                
            }
        }
            
        fIgnoreFirstCR = fNextIgnoreFirstCR;
        fNextIgnoreFirstCR = FALSE;
    }    

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::ApplyChangesToNode, private
//
//  Synopsis:   Apply or remove collapsed whitespace
//
//  Arguments:  [pNode] - Node that contains pending changes
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------    

HRESULT
CWhitespaceManager::ApplyChangesToNode(CTreeNode *pNode)
{
    HRESULT      hr = S_OK;
    BOOL        fPre = pNode->GetParaFormat()->_fPreInner;

    if (fPre != pNode->IsPre())
    {
        if (fPre)
            hr = THR(ApplyPre(pNode));        
        else
            hr = THR(RemovePre(pNode));        
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::LFill, private
//
//  Synopsis:   LFill whitespace before node (ported from parser)
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------    

HRESULT 
CWhitespaceManager::LFill(CMarkupPointer *pmpPosition, UINT fillcode, BOOL *pfHasSpace, BOOL *pfEatSpace)
{
    HRESULT hr = S_OK;

    Assert(!(*pfEatSpace) || !(*pfHasSpace));

    //
    // Output, eat, or transfer space from the left
    //

    if (*pfHasSpace)
    {
        if (fillcode == FILL_PUT)
        {
            hr = THR( AddSpace(pmpPosition) );

            *pfEatSpace = TRUE;
        }        

        *pfHasSpace = FALSE;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::RFill, private
//
//  Synopsis:   RFill whitespace after node (ported from parser)
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------    

HRESULT 
CWhitespaceManager::RFill(CMarkupPointer *pmpPosition, UINT fillcode, BOOL *pfHasSpace, BOOL *pfEatSpace)
{
    Assert(!(*pfEatSpace) || !(*pfHasSpace));

    // 1. Reject space to the right if EAT

    if (fillcode == FILL_EAT)
    {
        *pfHasSpace = FALSE;
        *pfEatSpace = TRUE;
    }

    // 2. Accept space to the right if PUT

    if (fillcode == FILL_PUT)
    {
        *pfEatSpace = FALSE;
    }
    
    // 3. Transfer any existing space by not resetting fHasSpace

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::ReleaseNodes, private
//
//  Synopsis:   Release all nodes
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------    

void 
CWhitespaceManager::ReleaseNodes(CPtrAry<CTreeNode *> &aryNodes)
{
    if (aryNodes.Size())
    {
        CTreeNode **ppTreeNode;
        int        i;

        for (i = aryNodes.Size(), ppTreeNode = aryNodes;
            i > 0;
            i--, ppTreeNode++)
        {
            (*ppTreeNode)->NodeRelease();
        }

        aryNodes.DeleteAll();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::AddSpace, private
//
//  Synopsis:   Add a real space - used for recollapsing whitespace
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------    

HRESULT 
CWhitespaceManager::AddSpace(CMarkupPointer *pmp)
{
    HRESULT hr;
    CDoc    *pDoc = pmp->Doc();
    TCHAR   ch = ' ';
    POINTER_GRAVITY eGravity;
    CMarkupPointer mpLeft(pDoc);
    CTreePos *ptp;
    
    //
    // Insert space
    //

    mpLeft.SetAlwaysEmbed(TRUE);

    IFC( mpLeft.MoveToPointer(pmp) );

    IFC( pmp->Gravity(&eGravity) );
    IFC( pmp->SetGravity(POINTER_GRAVITY_Right) );

    IFC( pDoc->InsertText(pmp, &ch, 1, 0) );

    IFC( pmp->SetGravity(eGravity) );

    //
    // Cling to left space
    //

    ptp = mpLeft.GetEmbeddedTreePos();

    while (ptp->IsPointer())
    {
        if (ptp->GetCollapsedWhitespace())
        {
            ptp->SetGravity(TRUE);
            goto Cleanup;
        }

        ptp = ptp->PreviousTreePos();
    }

    ptp = mpLeft.GetEmbeddedTreePos();

    while (ptp->IsPointer())
    {
        if (ptp->GetCollapsedWhitespace())
        {
            ptp->SetGravity(TRUE);
            goto Cleanup;
        }

        ptp = ptp->NextTreePos();
    }
    
Cleanup:
    RRETURN(hr);
} 

//+---------------------------------------------------------------------------
//
//  Member:     CWhitespaceManager::FlushWhitespaceChanges, private
//
//  Synopsis:   Flushes pending whitespace changes
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------    
HRESULT 
CWhitespaceManager::FlushWhitespaceChanges()
{
    if (_aryNodesToUpdate.Size())
    {
        GWKillMethodCall(this, ONCALL_METHOD(CWhitespaceManager, DeferredApplyChanges, deferredapplychanges), 0);
        DeferredApplyChanges(0);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\xbag.cxx ===
//---------------------------------------------------------------------
//
//   File:      xbag.cxx
//
//  Contents:   Xfer objects for selection and generic use
//
//  Classes:    CDropSource, CDummyDropSource, CBaseBag, CGenDataObject,
//              CEnumFormatEtc:
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif

#ifndef X_DRAGDROP_HXX_
#define X_DRAGDROP_HXX_
#include "dragdrop.hxx"
#endif

#ifndef X_SHLOBJ_H_
#define X_SHLOBJ_H_
#include <shlobj.h>
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

DeclareTagOther(tagIgnorePrivateCF, "FormKrnl", "Disable private CF's")

MtDefine(CDummyDropSource, ObjectModel, "CDummyDropSource")
MtDefine(CGenDataObject, ObjectModel, "CGenDataObject")
MtDefine(CGenDataObject_rgfmtc_pv, CGenDataObject, "CGenDataObject::_rgfmtc::_pv")
MtDefine(CGenDataObject_rgstgmed_pv, CGenDataObject, "CGenDataObject::_rgstgmed::_pv")
MtDefine(CEnumFormatEtc, ObjectModel, "CEnumFormatEtc")
MtDefine(CEnumFormatEtc_prgFormats, ObjectModel, "CEnumFormatEtc::_prgFormats")

//  NOTE that IFMTETC_PRIVATEFMT should be the first of our formats.
//    Other code in this file relies on this

#define IFMTETC_PRIVATEFMT  2
#define IFMTETC_CLSIDFMT    2
#define IFMTETC_PRIVTEXTFMT 3

// List of formats offered by our data transfer object via EnumFormatEtc
// NOTE: g_acfOleClipFormat is a global array of stock formats defined in
//       cdutil\dvutils.cxx and initialized in the Form class factory

// NOTE that the first two formats have the index to their clipformat
// rather than the actual clip format.  This value will be replaced in
// the call to InitFormClipFormats

static FORMATETC g_aGetFmtEtcs[] =
{
    { CF_COMMON(ICF_EMBEDSOURCE), NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE },
    { CF_COMMON(ICF_OBJECTDESCRIPTOR), NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL },
    { CF_COMMON(ICF_FORMSCLSID), NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL},     //  IFMTETC_CLSIDFMT
    { CF_COMMON(ICF_FORMSTEXT), NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL},      //  IFMTETC_PRIVTEXTFMT
};


//+---------------------------------------------------------------------------
//
//  Function:   InitFormClipFormats
//
//  Synopsis:   Set registered clip formats into g_aGetFmtEtcs.
//
//----------------------------------------------------------------------------

void
InitFormClipFormats( )
{
    SetCommonClipFormats(g_aGetFmtEtcs, ARRAY_SIZE(g_aGetFmtEtcs));
}


//+-------------------------------------------------------------------------
//
//  Function:   GetcfCLSIDFmt
//
//  Synopsis:   Attempt to retrieve our private CLSID clipboard format
//              information from the given data object.  If it is not
//              available this function returns an error.
//
//--------------------------------------------------------------------------

HRESULT
GetcfCLSIDFmt(LPDATAOBJECT pDataObj, TCHAR * tszClsid)
{
    HRESULT     hr;
    STGMEDIUM   stgmedium;
    TCHAR *     pszText;

    stgmedium.tymed = TYMED_HGLOBAL;
    stgmedium.hGlobal = NULL;
    stgmedium.pUnkForRelease = NULL;

    hr = pDataObj->GetData(&g_aGetFmtEtcs[IFMTETC_CLSIDFMT], &stgmedium);
    if (hr)
        goto Cleanup;

    if (TYMED_NULL == stgmedium.tymed)
    {
        hr = DV_E_FORMATETC;
        goto Cleanup;
    }

    // STGFIX: t-gpease 8-13-97
    Assert(stgmedium.tymed == TYMED_HGLOBAL);

    pszText = (TCHAR *) GlobalLock(stgmedium.hGlobal);
    Assert(pszText != NULL);
    if (pszText == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    memcpy(tszClsid, pszText, CLSID_STRLEN*sizeof(TCHAR));
    tszClsid[CLSID_STRLEN] = 0;
    GlobalUnlock(stgmedium.hGlobal);

Cleanup:
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return hr;
}


//+------------------------------------------------------------------------
//
//  Function:   FindLegalCF
//
//  Synopsis:   Returns S_OK if the given data object contains a format
//              we can parse, or S_FALSE if it doesn't.  If the DO
//              returns an unexpected error, we return that instead.
//
//  Arguments:  [pDO]
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
FindLegalCF(IDataObject * pDO)
{
    HRESULT     hr;
    int         c;
    FORMATETC * pformatetc;

#if defined(_MAC)
    if (!pDO)
        return S_OK;
#endif

    Assert(pDO);

    for (c = ARRAY_SIZE(g_aGetFmtEtcs), pformatetc = g_aGetFmtEtcs;
         c > 0;
         c--, pformatetc++)
    {
#if DBG == 1
        if (IsTagEnabled(tagIgnorePrivateCF))
        {
            if (c <= ARRAY_SIZE(g_aGetFmtEtcs) - IFMTETC_PRIVATEFMT)
                continue;
        }
#endif

        hr = pDO->QueryGetData(pformatetc);
        switch (hr)
        {
        case DV_E_FORMATETC:
        case DV_E_TYMED:
        case DV_E_DVASPECT:
            break;

        case DV_E_CLIPFORMAT:   //  This isn't a specified return value,
                                //    but the standard handler seems to
                                //    return it anyhow
            break;

        default:
            RRETURN(hr);
        }
    }

    return S_FALSE;
}


//
// CDropSource
// Implements IDropSource interface.

STDMETHODIMP
CDropSource::QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState)
{
    HRESULT hr = S_OK;

   if (_pDoc->_pDragStartInfo && !_pDoc->_pDragStartInfo->_pElementDrag->Fire_ondrag())
   {
        hr = DRAGDROP_S_CANCEL;
        goto Cleanup;
   }

   if (fEscapePressed)
    {
        hr = DRAGDROP_S_CANCEL;
        goto Cleanup;
    }

    // initialize ourself with the drag begin button
    if (_dwButton == 0)
        _dwButton = (grfKeyState & (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON));

    // Assert(_dwButton); no need for this assert

    if (!(grfKeyState & _dwButton))
    {
        //
        // A button is released.
        //
        hr = DRAGDROP_S_DROP;
    }
    else if (_dwButton != (grfKeyState & (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON)))
    {
        //
        //  If the button state is changed (except the drop case, which we handle
        // above, cancel the drag&drop.
        //
        hr = DRAGDROP_S_CANCEL;
    }

Cleanup:
    if (hr != S_OK)
    {
        // reset cursor here ?
        // SetCursor(LoadCursor(NULL, IDC_ARROW));
    }

    return hr;
}


STDMETHODIMP
CDropSource::GiveFeedback(DWORD dwEffect)
{
    // let OLE put up the right cursor
    return DRAGDROP_S_USEDEFAULTCURSORS;
}

//
// CDummyDropSource
// Wraps a trivial instantiable class around CDropSource

STDMETHODIMP
CDummyDropSource::QueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IUnknown || riid == IID_IDropSource)
    {
        *ppv = this;
        ((IUnknown *)*ppv)->AddRef();
        return NOERROR;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


HRESULT
CDummyDropSource::Create(DWORD dwKeyState, CDoc * pDoc, IDropSource ** ppDropSrc)
{
    HRESULT         hr;

    *ppDropSrc = new CDummyDropSource;
    if (!*ppDropSrc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    ((CDummyDropSource *)(*ppDropSrc))->_dwButton =
        dwKeyState & (MK_LBUTTON | MK_MBUTTON | MK_RBUTTON);
    ((CDummyDropSource *)(*ppDropSrc))->_pDoc = pDoc;
    hr = S_OK;
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CBaseBag::QueryInterface, public
//
//  Synopsis:   Expose our IFaces
//
//---------------------------------------------------------------

STDMETHODIMP
CBaseBag::QueryInterface(REFIID riid, void ** ppv)
{
    if (IsEqualIID(riid,IID_IUnknown))
    {
        *ppv = (IUnknown *)(IDataObject *)this;
    }
    else if (IsEqualIID(riid,IID_IDataObject))
    {
        *ppv = (IDataObject *)this;
    }
    else if (IsEqualIID(riid,IID_IDropSource))
    {
        *ppv = (IDropSource *)this;
    }
    else if (IsEqualIID(riid,IID_IOleCommandTarget))
    {
        *ppv = (IOleCommandTarget *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    ((IUnknown FAR*) *ppv)->AddRef();
    return NOERROR;
}

//+----------------------------------------------------------------------------
//
// CBaseBag IOleCommandTarget support
//
//-----------------------------------------------------------------------------
HRESULT
CBaseBag::QueryStatus(
            const GUID * pguidCmdGroup,
            ULONG        cCmds,
            OLECMD       rgCmds[],
            OLECMDTEXT * pcmdtext)
{
    RRETURN(OLECMDERR_E_UNKNOWNGROUP);
}

HRESULT
CBaseBag::Exec(
            const GUID * pguidCmdGroup,
            DWORD        nCmdID,
            DWORD        nCmdexecopt,
            VARIANTARG * pvarargIn,
            VARIANTARG * pvarargOut)
{
    HRESULT  hr = OLECMDERR_E_UNKNOWNGROUP;

    if (* pguidCmdGroup == CGID_DATAOBJECTEXEC)
    {
        hr = OLECMDERR_E_NOTSUPPORTED;

        switch (nCmdID)
        {
        case IDM_SETSECURITYDOMAIN:
            if (pvarargIn && (V_VT(pvarargIn) == VT_BSTR))
            {
                Assert(FormsStringLen(V_BSTR(pvarargIn)) == MAX_SIZE_SECURITY_ID);
                memcpy(_abSID, V_BSTR(pvarargIn), MAX_SIZE_SECURITY_ID);
                hr = S_OK;
            }
            break;

        case IDM_CHECKSECURITYDOMAIN:
            if (pvarargIn && (V_VT(pvarargIn) == VT_BSTR))
            {
                Assert(FormsStringLen(V_BSTR(pvarargIn)) == MAX_SIZE_SECURITY_ID);
                hr = !memcmp(_abSID, V_BSTR(pvarargIn), MAX_SIZE_SECURITY_ID) ?
                        S_OK : OLECMDERR_E_DISABLED;
            }
            break;
        }
    }
    RRETURN (hr);
}

/*
 * CGenDataObject - Generic IDataObject implementation.
 */


/********************************** Methods **********************************/


CGenDataObject::CGenDataObject(CDoc * pDoc)
    : _rgfmtc(Mt(CGenDataObject_rgfmtc_pv)),
      _rgstgmed(Mt(CGenDataObject_rgstgmed_pv))
{
    _ulRefs = 1;

    _pDoc = pDoc;
    _pLinkDataObj = NULL;

    _dwPreferredEffect              = DROPEFFECT_NONE;

#ifndef WIN16
    _fmtcPreferredEffect.cfFormat   = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
#endif //!WIN16
    _fmtcPreferredEffect.ptd        = NULL;
    _fmtcPreferredEffect.dwAspect   = DVASPECT_CONTENT;
    _fmtcPreferredEffect.lindex     = -1;
    _fmtcPreferredEffect.tymed      = TYMED_HGLOBAL;
}


CGenDataObject::~CGenDataObject()
{
    int         i;
    STGMEDIUM * pstgmed;

    for (i = _rgstgmed.Size(), pstgmed = _rgstgmed; i > 0; i--, pstgmed++)
        ReleaseStgMedium(pstgmed);
}


HRESULT
CGenDataObject::DeleteFormatData(CLIPFORMAT cfFormat)
{
    FORMATETC * pfmtc;
    int i;

    for (i = _rgfmtc.Size() - 1, pfmtc = _rgfmtc + i; i >= 0; --i, --pfmtc)
    {
        if (pfmtc->cfFormat == cfFormat)
        {
            _rgfmtc.Delete(i);
            _rgstgmed.Delete(i);
        }
    }

    return S_OK;
}

HRESULT
CGenDataObject::AppendFormatData(CLIPFORMAT cfFormat, HGLOBAL hGlobal)
{
    HRESULT hr;
    FORMATETC fmtc;
    STGMEDIUM stgmed;

    fmtc.cfFormat = cfFormat;
    fmtc.ptd = NULL;
    fmtc.dwAspect = DVASPECT_CONTENT;
    fmtc.lindex = -1;
    fmtc.tymed = TYMED_HGLOBAL;

    stgmed.tymed = TYMED_HGLOBAL;
    stgmed.hGlobal = hGlobal;
    stgmed.pUnkForRelease = NULL;

    hr = _rgfmtc.AppendIndirect(&fmtc);
    if (!hr)
    {
        hr = _rgstgmed.AppendIndirect(&stgmed);
        if (hr)
            _rgfmtc.DeleteByValueIndirect(&fmtc);
    }

    RRETURN(hr);
}

HRESULT STDMETHODCALLTYPE
CGenDataObject::GetData(LPFORMATETC pfmtetc, LPSTGMEDIUM pstgmed)
{
    HRESULT     hr = S_OK;
    HGLOBAL hGlobal;
    DWORD *     pdw;
    int         i, c;
    FORMATETC * pfmtc;

    memset(pstgmed, 0, sizeof(*pstgmed));

    if (_dwPreferredEffect != DROPEFFECT_NONE &&
        FORMATETCMatchesRequest(pfmtetc, &_fmtcPreferredEffect))
    {
        hGlobal = GlobalAlloc(GPTR, sizeof(DWORD));
        if (!hGlobal)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        IF_WIN16(pdw = (DWORD *)GlobalLock(hGlobal));
        IF_WIN32(pdw = (DWORD *)hGlobal);
        *pdw = _dwPreferredEffect;
        IF_WIN16(GlobalUnlock(hGlobal));

        pstgmed->tymed          = TYMED_HGLOBAL;
        pstgmed->hGlobal        = hGlobal;
        pstgmed->pUnkForRelease = NULL;
        goto Cleanup;
    }

    c = _rgfmtc.Size();
    for (i = 0, pfmtc = _rgfmtc; i < c; i++, pfmtc++)
    {
        if (FORMATETCMatchesRequest(pfmtetc, pfmtc))
            break;
    }
    if (i == c)
    {
        hr = DV_E_FORMATETC;
        goto Cleanup;
    }
    hr = THR(CloneStgMedium(&_rgstgmed[i], pstgmed));

Cleanup:
    if (hr && _pLinkDataObj)
        hr = _pLinkDataObj->GetData(pfmtetc, pstgmed);

    RRETURN(hr);
}


HRESULT STDMETHODCALLTYPE CGenDataObject::QueryGetData(LPFORMATETC pfmtetc)
{
    HRESULT     hr = S_OK;
    int         i;
    FORMATETC * pfmtc;

    if (_dwPreferredEffect != DROPEFFECT_NONE &&
        FORMATETCMatchesRequest(pfmtetc, &_fmtcPreferredEffect))
    {
        goto Cleanup;
    }
    for (i = _rgfmtc.Size(), pfmtc = _rgfmtc; i > 0; i--, pfmtc++)
    {
        if (FORMATETCMatchesRequest(pfmtetc, pfmtc))
            goto Cleanup;
    }
    hr = DV_E_FORMATETC;

Cleanup:
    if (hr && _pLinkDataObj)
        hr = _pLinkDataObj->QueryGetData(pfmtetc);

    RRETURN(hr);
}

HRESULT STDMETHODCALLTYPE CGenDataObject::SetData(LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium, BOOL fRelease)
{
    HRESULT hr;

    hr = DeleteFormatData(pformatetc->cfFormat);
    if (hr)
        goto Cleanup;

    if (pmedium->hGlobal)
        hr = AppendFormatData(pformatetc->cfFormat, pmedium->hGlobal);

Cleanup:
    RRETURN(hr);
}

HRESULT STDMETHODCALLTYPE
CGenDataObject::EnumFormatEtc(DWORD                 dwDirection,
                              LPENUMFORMATETC FAR * ppenumFormatEtc)
{
    if (_pLinkDataObj)
    {
        AppendFormatData(cf_FILEDESCA, NULL);
        AppendFormatData(cf_FILEDESCW, NULL);
        AppendFormatData(cf_FILECONTENTS, NULL);
        AppendFormatData(cf_UNIFORMRESOURCELOCATOR, NULL);
    }

    *ppenumFormatEtc = NULL;
    RRETURN((dwDirection == DATADIR_GET) ?
        CEnumFormatEtc::Create(_rgfmtc, _rgfmtc.Size(), ppenumFormatEtc) :
        E_NOTIMPL);
}

void
CGenDataObject::SetBtnState(DWORD dwKeyState)
{
    _dwButton = dwKeyState & (MK_LBUTTON | MK_MBUTTON | MK_RBUTTON);
}

//
//  CEnumFormatEtc PUBLIC methods
//

/*
 *  CEnumFormatEtc::QueryInterface (riid, ppvObj)
 *
 *  @mfunc
 *      IUnknown method
 *
 *  @rdesc
 *      HRESULT
 */

STDMETHODIMP CEnumFormatEtc::QueryInterface(
    REFIID riid,            // @parm Reference to requested interface ID
    void ** ppv)            // @parm out parm for interface ptr
{
    HRESULT     hresult = E_NOINTERFACE;

    *ppv = NULL;

    if( IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEnumFORMATETC) )
    {
        *ppv = this;
        AddRef();
        hresult = NOERROR;
    }
    return hresult;
}

/*
 *  CEnumFormatEtc::AddRef()
 *
 *  @mfunc
 *      IUnknown method
 *
 *  @rdesc
 *      ULONG - incremented reference count
 */

STDMETHODIMP_(ULONG) CEnumFormatEtc::AddRef( )
{
    return ++_crefs;
}

/*
 *  CEnumFormatEtc::Release()
 *
 *  @mfunc
 *      IUnknown method
 *
 *  @rdesc
 *      ULONG - decremented reference count
 */

STDMETHODIMP_(ULONG) CEnumFormatEtc::Release( )
{
    _crefs--;

    if( _crefs == 0 )
    {
        delete this;
        return 0;
    }

    return _crefs;
}

/*
 *  CEnumFormatEtc::Next (celt, rgelt, pceltFetched)
 *
 *  @mfunc
 *      fetches the next [celt] elements in our formatetc collection
 *
 *  @rdesc
 *      HRESULT
 */

STDMETHODIMP CEnumFormatEtc::Next( ULONG celt, FORMATETC *rgelt,
        ULONG *pceltFetched)
{
    HRESULT     hresult = NOERROR;
    ULONG       cFetched;

    if( pceltFetched == NULL && celt != 1 )
    {
        // the spec says that if pceltFetched == NULL, then
        // the count of elements to fetch must be 1
        return E_INVALIDARG;
    }

    // we can only grab as many elements as there are left

    if( celt > _cTotal - _iCurrent )
    {
        cFetched = _cTotal - _iCurrent;
        hresult = S_FALSE;
    }
    else
    {
        cFetched = celt;
    }

    // Only copy if we have elements to copy

    if( cFetched > 0 )
    {
        memcpy( rgelt, _prgFormats + _iCurrent,
            cFetched * sizeof(FORMATETC) );
    }

    _iCurrent += cFetched;

    if( pceltFetched )
    {
        *pceltFetched = cFetched;
    }

    return hresult;
}

/*
 *  CEnumFormatEtc::Skip
 *
 *  @mfunc
 *      skips the next [celt] formats
 *
 *  @rdesc
 *      HRESULT
 */
STDMETHODIMP CEnumFormatEtc::Skip( ULONG celt )
{
    HRESULT     hresult = NOERROR;

    _iCurrent += celt;

    if( _iCurrent > _cTotal )
    {
        // whoops, skipped too far ahead.  Set us to the max limit.
        _iCurrent = _cTotal;
        hresult = S_FALSE;
    }

    return hresult;
}

/*
 *  CEnumFormatEtc::Reset
 *
 *  @mfunc
 *      resets the seek pointer to zero
 *
 *  @rdesc
 *      HRESULT
 */
STDMETHODIMP CEnumFormatEtc::Reset( void )
{
    _iCurrent = 0;

    return NOERROR;
}

/*
 *  CEnumFormatEtc::Clone
 *
 *  @mfunc
 *      clones the enumerator
 *
 *  @rdesc
 *      HRESULT
 */

STDMETHODIMP CEnumFormatEtc::Clone( IEnumFORMATETC **ppIEnum )
{
    return CEnumFormatEtc::Create(_prgFormats, _cTotal, ppIEnum);
}

/*
 *  CEnumFormatEtc::Create (prgFormats, cTotal, hr)
 *
 *  @mfunc
 *      creates a new format enumerator
 *
 *  @rdesc
 *      HRESULT
 *
 *  @devnote
 *      *copies* the formats passed in.  We do this as it simplifies
 *      memory management under OLE object liveness rules
 */

HRESULT CEnumFormatEtc::Create( FORMATETC *prgFormats, ULONG cTotal,
    IEnumFORMATETC **ppenum )
{
    CEnumFormatEtc *penum = new CEnumFormatEtc();

    if( penum != NULL )
    {
        // _iCurrent, _crefs are set in the constructor

        if( cTotal > 0 )
        {
            penum->_prgFormats = new(Mt(CEnumFormatEtc_prgFormats)) FORMATETC[cTotal];
            if( penum->_prgFormats )
            {
                penum->_cTotal = cTotal;
                memcpy(penum->_prgFormats, prgFormats,
                        cTotal * sizeof(FORMATETC));
                *ppenum = penum;
                return NOERROR;
            }
        }
    }

    return E_OUTOFMEMORY;
}

//
// CEnumFormatEtc PRIVATE methods
//

/*
 *  CEnumFormatEtc::CEnumFormatEtc()
 *
 *  @mfunc
 *      Private constructor
 */

CEnumFormatEtc::CEnumFormatEtc()
{
    _cTotal = 0;
    _crefs  = 1;
    _prgFormats = NULL;
    _iCurrent = 0;
}


/*
 *  CEnumFormatEtc::~CEnumFormatEtc()
 *
 *  @mfunc
 *      Private destructor
 */

CEnumFormatEtc::~CEnumFormatEtc( void )
{
    if( _prgFormats )
    {
        delete [] _prgFormats;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\btnhlper.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       btnhelp.cxx
//
//  Contents:   Button helper class implementation
//
//  Classes:    CButtonHelper
//
//  Functions:
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_BTNHLPER_HXX_
#define X_BTNHLPER_HXX_
#include "btnhlper.hxx"
#endif

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif


// Used by CInput on TYPE=file to differentiate clicks on the text and button portions.
const DWORD CLKDATA_BUTTON = 1;


//+------------------------------------------------------------------------
//
//  Member:     CBtnHelper::BtnTakeCapture
//
//  Synopsis:   take capture for the button helper and remember it
//
//-------------------------------------------------------------------------

void
CBtnHelper::BtnTakeCapture(BOOL fTake)
{
    CElement *pElem = GetElement();
    CDoc * pDoc = pElem->Doc();

    if (fTake)
    {
        pDoc->SetMouseCapture(
                MOUSECAPTURE_METHOD(CElement, HandleCaptureMessage, handlecapturemessage),
                pElem,
                TRUE,
                TRUE);
    }
    else
    {
        pDoc->ClearMouseCapture(pElem);
    }
    _fButtonHasCapture = fTake;
}


//+------------------------------------------------------------------------
//
//  Member:     CBtnHelper::BtnHasCapture
//
//  Synopsis:   check if the button helper really has capture
//
//-------------------------------------------------------------------------

BOOL
CBtnHelper::BtnHasCapture()
{
    return GetElement()->HasCapture() && _fButtonHasCapture;
}


//+---------------------------------------------------------------------------
//
// Member:      CBtnHelper::BtnHandleMessage
//
// Synopsis:    Handle window message
//
//----------------------------------------------------------------------------

HRESULT
CBtnHelper::BtnHandleMessage(CMessage * pMessage)
{
    HRESULT         hr      = S_FALSE;
    CElement *      pElem   = GetElement();
    BOOL            fCtrl   = pMessage->dwKeyState & FCONTROL;

    switch (pMessage->message)
    {
    case WM_KILLFOCUS:
        BTN_RESETSTATUS(_wBtnStatus);
        ChangePressedLook();
        hr = S_FALSE;
        break;
    case WM_SETFOCUS:
        _wBtnStatus = BTN_SETSTATUS(_wBtnStatus, FLAG_HASFOCUS);
        ChangePressedLook();
        hr = S_FALSE; //THR(SiteHandleMessage(pMessage, pChild));
        break;

    case WM_SETCURSOR:       
        if ( ! pMessage->pNodeHit->Element()->IsMasterParentEditable() )
        {
            pElem->SetCursorStyle(IDC_ARROW);
            hr = S_OK;
        }            
        break;
    case WM_KEYDOWN:
        switch (pMessage->wParam)
        {
        case 'M':
        case 'm':
            if (!fCtrl)
            {
                break;
            }
            // fall thru
        case VK_TAB:
            // change the look if this is not done yet.
            BTN_RESETSTATUS(_wBtnStatus);
            ChangePressedLook();
            hr = S_FALSE;
            break;

        case VK_BACK:
            // do not allow navigate back
            hr = S_OK;
            break;

        case VK_SPACE:
            // do not change look&feel if we already have the capture
            if (!BtnHasCapture())
            {
                PressButton(PRESSED_KEYBOARD);
                BtnTakeCapture(TRUE);
                hr = S_OK;
            }
             break;
        }
        break;

    case WM_CHAR:
        switch (pMessage->wParam)
        {
        case VK_SPACE:
            hr = S_OK;
        }
        break;

    case WM_KEYUP:
    {
        if (BtnHasCapture() && BTN_GETSTATUS(_wBtnStatus, PRESSED_KEYBOARD))
        {
            if (!BTN_GETSTATUS(_wBtnStatus, PRESSED_MOUSE))
            {
                WORD    wOld = _wBtnStatus;

                _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, PRESSED_KEYBOARD);  // reset PRESSED_KEY bit
                BtnTakeCapture(FALSE);
                _wBtnStatus = wOld;
            }
            else
            {
            // the user still presses on the mouse
            // we should change the press look
                // reverse the bit
                _wBtnStatus = BTN_REVSTATUS(_wBtnStatus, PRESSED_MOUSE);
                if (PressedLooksDifferent(PRESSED_MOUSE))
                {
                    ChangePressedLook();
                }
            }
            ReleaseButton(PRESSED_KEYBOARD, pMessage);
        }

        hr = S_OK;
        break;
    }
    case WM_MOUSEOVER:
        _wBtnStatus = BTN_SETSTATUS(_wBtnStatus, FLAG_MOUSEOVER);
    case WM_MOUSELEAVE:
        if (WM_MOUSELEAVE == pMessage->message)
        {
            _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, FLAG_MOUSEOVER);
        }
        if (!BtnHasCapture() && !Pressed())
        {
            //
            // inval button
            //

            Invalidate();
        }
        break;
    case WM_MOUSEMOVE:

        // If the mouse is captured, that means that the user clicked
        // over the control. Else, it is moving over us, but we were not pressed.

        if (BtnHasCapture() && !BTN_GETSTATUS(_wBtnStatus, PRESSED_KEYBOARD))
        {
            // See whether the mouse is still over us. If it goes from
            // being over to not, or visa versa, flip the _wBtnStatus flag
            // and, if that would affect visible image, redraw.

            if (((_wBtnStatus & PRESSED_MOUSE) != 0) !=
                  MouseIsOver(MAKEPOINTS(pMessage->lParam).x,
                              MAKEPOINTS(pMessage->lParam).y))
            {
                // reverse the bit
                _wBtnStatus = BTN_REVSTATUS(_wBtnStatus, PRESSED_MOUSE);
                if (PressedLooksDifferent(PRESSED_MOUSE))
                {
                    ChangePressedLook();
                }
            }
            if (!(pMessage->wParam & BTN_GETPRESSSTATUS(_wBtnStatus)))
            {
                BtnTakeCapture(FALSE);
            }
            hr = S_OK;
        }

        break;
    case WM_CAPTURECHANGED:
        // If the mouse is over the control at the time we lose capture,
        // then we need to remove the pressed state, just as though the
        // mouse had moved off the control.
#if DBG==1
        TLS(fHandleCaptureChanged) = TRUE;
#endif //DBG==1

        _fButtonHasCapture = FALSE;

        if (BTN_GETSTATUS(_wBtnStatus, PRESSED_MOUSE))
        {
            // if it is a mouse capture
            // reset the mouse pressed bit
            _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, PRESSED_MOUSE);

            // If the pressed state looks different from the unpressed
            // state, redraw.

            if (PressedLooksDifferent(PRESSED_MOUSE))
            {
                ChangePressedLook();
            }
            hr = S_OK;
        }
        else if (BTN_GETSTATUS(_wBtnStatus, PRESSED_KEYBOARD))
        {
            // if it is a keyboard capture
            // reset the space pressed bit
            _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, PRESSED_KEYBOARD);

            // If the pressed state looks different from the unpressed
            // state, redraw.

            if (PressedLooksDifferent(PRESSED_KEYBOARD))
            {
                ChangePressedLook();
            }
            hr = S_OK;
        }
#if DBG==1
        TLS(fHandleCaptureChanged) = FALSE;
#endif //DBG==1
        break;

    case WM_LBUTTONDBLCLK:
        _wBtnStatus = BTN_SETSTATUS(_wBtnStatus, FLAG_DOUBLECLICK);
        // fall through
    case WM_LBUTTONDOWN:

        if (pElem->HasCurrency() || pElem->IsUnselectable())
        {           
            BTN_PRESSLEFT(_wBtnStatus);
            PressButton(PRESSED_MOUSE);
            BtnTakeCapture(TRUE);
            hr = S_OK;
        }
        break;

    case WM_LBUTTONUP:
    {
        if (BtnHasCapture())
        {
            // if space key still down, we don't do anything
            if (!BTN_GETSTATUS(_wBtnStatus, PRESSED_KEYBOARD))
            {
                WORD    wOld = _wBtnStatus;

                // temporarily reset mouse pressed bit to clear the capture
                _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, PRESSED_MOUSE);
                BtnTakeCapture(FALSE);
                _wBtnStatus = wOld;
            }
            ReleaseButton(PRESSED_MOUSE, pMessage);
            hr = S_OK;
        }
        break;
    }
#ifdef NEVER
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
        if (HasCapture())
        {
            // clear bit
            _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, PRESSED_MOUSE);
            TakeCapture(FALSE);
        }
#endif

    case WM_CONTEXTMENU:
        hr = THR(pElem->OnContextMenu(
                (short)LOWORD(pMessage->lParam),
                (short)HIWORD(pMessage->lParam),
                CONTEXT_MENU_CONTROL));
        hr = S_OK;
        break;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CBtnHelper::PressButton
//
//  Synopsis:   Enter the pressed state.
//
//  Arguments:
//
//  Notes:      PressButton and ReleaseButton keep track of which device has
//              pressed and released, so that we only release the button when
//              all devices have released. This matches VB behavior.
//                We also avoid redundant presses in case of repeated key down
//              without intervening key up.
//
//----------------------------------------------------------------------------

void
CBtnHelper::PressButton(WORD wWhoPressed)
{
    if (!BTN_PRESSED(_wBtnStatus))
    {
        _wBtnStatus = BTN_SETSTATUS(_wBtnStatus, wWhoPressed);

        // A button that is already down does not change its image on being pressed, only on
        // being released. Other states do change on being pressed.

        if (PressedLooksDifferent(wWhoPressed))
        {
            ChangePressedLook();
        }
    }
    else
    {
        _wBtnStatus = BTN_SETSTATUS(_wBtnStatus, wWhoPressed);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBtnHelper::ReleaseButton
//
//  Synopsis:   Exit the pressed state.
//
//  Arguments:  fVisual TRUE if we should show visual effects.
//
//  Note:       Checks that the button was actually pressed by the same agency
//              as is trying to release it. This is to cover any possible
//              case in which we get a button or key up without a corresponding
//              down (or get two ups in a row).
//

//----------------------------------------------------------------------------

void
CBtnHelper::ReleaseButton(WORD wWhoPressed, CMessage * pMessage)
{
    if (BTN_GETSTATUS(_wBtnStatus, wWhoPressed))
    {
        // mouse/spcae key pressed and released, clear the bit
        _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, wWhoPressed);

        if (!BTN_PRESSED(_wBtnStatus))                          // If no remaining presses...
        {
            // If this was a command button, there is no value and therefore
            // the call before would not invalidate and Fire OnViewChange
            // Make sure we do it if the pressed state looked different than
            // the released stated.

            if (PressedLooksDifferent(wWhoPressed))
            {
                ChangePressedLook();
            }
            if (pMessage)
            {
                pMessage->SetNodeClk(GetElement()->GetFirstBranch());
                pMessage->dwClkData = CLKDATA_BUTTON;
            }
        }
    }
    else
    {
        if (!MouseIsOver(MAKEPOINTS(pMessage->lParam).x, MAKEPOINTS(pMessage->lParam).y))
        {
            _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, FLAG_MOUSEOVER);
        }

        Invalidate();
    }

    // reset double click flag
    _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, FLAG_DOUBLECLICK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CBtnHelper::MouseIsOver
//
//  Synopsis:   TRUE iff this point is over us.
//
//  Arguments:
//
//----------------------------------------------------------------------------

BOOL
CBtnHelper::MouseIsOver(LONG x, LONG y)
{
    CRect rc;
    POINT pt = { x, y };

    GetElement()->GetUpdatedLayout()->GetRect(&rc, COORDSYS_GLOBAL);
    return rc.Contains(pt);
}

//+---------------------------------------------------------------------------
//
//  Member:     PressedLooksDifferent
//
//  Synopsis:   Returns true if the pressed value looks different from the
//              unpressed.
//
//              An up (FALSE) button changes its appearance when pressed,
//              a down (TRUE) button changes when released.
//
//              Some causes of a button being momentarily depressed do not
//              have visual effect. See the notes on SimulateClick for a
//              discussion. If the button does not hold a value, then we check
//              to see whether the source of the button press causes a
//              redraw. After all, since the button does not hold a value,
//              any visual display on press will be reversed on release,
//              bringing us back where we started. So, for buttons that do not
//              hold a value, we permit optimizing by eliminating both draws.
//
//  Arguments:  [wWoPressed] -- bit flags of who has pressed the control.
//
//----------------------------------------------------------------------------

BOOL
CBtnHelper::PressedLooksDifferent(WORD wWho)
{
    // Verify that no extra bits are in the wWho.

    Assert((wWho & ~(PRESSED_ASSIGNVALUE | PRESSED_MNEMONIC | PRESSED_MOUSE | PRESSED_KEYBOARD)) == 0);

    // All sources of clicks cause visible change except PRESSED_ASSIGNVALUE and PRESSED_MNEMONIC
    // for which we don't show the "pressed" state

    return (wWho & (PRESSED_KEYBOARD | PRESSED_MOUSE));
}


#ifdef NEVER
//[TRISTATE]
OLE_TRISTATE
CBtnHelper::BtnValue(void)
{
    return TRISTATE_FALSE;
}

//[TRISTATE]
void
CBtnHelper::BtnSetValue(OLE_TRISTATE triValue)
{
    IGNORE_HR(FireStdControlEvent_Click());
    // Do nothing else.  we don't store a value
}

//[TRISTATE]
OLE_TRISTATE
CBtnHelper::NextValue(void)
{
    if (BtnStyle() == GLYPHSTYLE_OPTION)
    {
        // A click on an Option button always sets to true.
        return TRISTATE_TRUE;
    }
    else if (BtnIsTripleState())
    {
        switch (BtnValue())
        {
        case TRISTATE_MIXED:
            return TRISTATE_TRUE;

        case TRISTATE_TRUE:
            return TRISTATE_FALSE;

        case TRISTATE_FALSE:
            return TRISTATE_MIXED;

        default:
            Assert(0 && "Invalid button value");
            return TRISTATE_FALSE;      // to keep the compiler happy
        }
    }
    else
    {
        // NOTE: if the current value is TRISTATE_MIXED, this returns TRISTATE_TRUE,
        //       as per Word and other apps.  From then on it goes to TRISTATE_FALSE,
        //       to TRISTATE_TRUE and back.

        return (BtnValue() == TRISTATE_TRUE) ? TRISTATE_FALSE : TRISTATE_TRUE;
    }
}

//[TRISTATE]
HRESULT
CBtnHelper::BtnValueChanged(OLE_TRISTATE triValue)
{
    // In my testing, VB4 only fires a click event or otherwise responds to a
    // value assignment if it is in fact different from the current value. This
    // is true of both command and option buttons. Neither VB4 nor Access show
    // visual feedback on value assignment.

    if (triValue != TRISTATE_FALSE)
    {
        if (_pDoc->_fDesignMode)
        {
            SimulateClick(PRESSED_ASSIGNVALUE); // All effects except visual.
        }
        else
        {
            BtnSetValue(triValue);
        }
    }

    return S_OK;
}

//[TRISTATE]
BOOL
CBtnHelper::Pressed()
{
    return BtnValue() == TRISTATE_TRUE ? TRUE : (BTN_PRESSED(_wBtnStatus) ? TRUE : FALSE);
}
#endif

void
CBtnHelper::ChangePressedLook()
{
    const SIZE      s_sizeDepressed = { 1, 1 };
    CDispNode * pDispNode;

    Assert(GetElement());
    Assert(GetElement()->GetUpdatedLayout());

    CLayout *   pLayout   = GetElement()->GetUpdatedLayout();

    if (!pLayout)
        return;

    pDispNode = pLayout->GetElementDispNode();

    if (    pDispNode
        &&  pDispNode->HasInset())
    {

        if (!pLayout->TestLayoutDescFlag(LAYOUTDESC_NOTALTERINSET))
        {
            const CSize &   sizeOldInset = pDispNode->GetInset();
            CSize           sizeNewInset =  _sizeInset
                                        + (BTN_PRESSED(_wBtnStatus)
                                                ? (const CSize &)s_sizeDepressed
                                                : (const CSize &)g_Zero.size);

            if (sizeNewInset != sizeOldInset)
            {
                if (pLayout->OpenView())
                {
                    pDispNode->SetInset(sizeNewInset);
                }
            }
        }
        pLayout->Invalidate();
    }
}

void
CBtnHelper::Invalidate()
{
    Assert(GetElement());
    Assert(GetElement()->GetUpdatedLayout());

    CLayout *   pLayout   = GetElement()->GetUpdatedLayout();

    if (!pLayout)
        return;

    pLayout->Invalidate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\eoption.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eoption.cxx
//
//  Contents:   Option element class, etc..
//
//  Classes:    COptionElement, etc..
//
//------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_TEXTXFRM_HXX_
#define X_TEXTXFRM_HXX_
#include "textxfrm.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_ESELECT_HXX_
#define X_ESELECT_HXX_
#include "eselect.hxx"
#endif

#ifndef X_SELLYT_HXX_
#define X_SELLYT_HXX_
#include "sellyt.hxx"
#endif

#ifndef X_EOPTION_HXX_
#define X_EOPTION_HXX_
#include "eoption.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "option.hdl"

MtDefine(COptionElement, Elements, "COptionElement")
MtDefine(COptionElementFactory, Elements, "COptionElementFactory")

#if DBG == 1
static unsigned s_OptionSize = sizeof(COptionElement);
#endif

extern class CFontCache & fc();

const CElement::CLASSDESC COptionElement::s_classdesc =
{
    {
        &CLSID_HTMLOptionElement,           // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        0,                                  // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOANCESTORCLICK|
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLOptionElement,            // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLOptionElement,     // apfnTearOff
    NULL                                    // _pAccelsRun
};


HRESULT COptionElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(pht->Is(ETAG_OPTION) || pht->Is(ETAG_OPTGROUP));
    Assert(ppElementResult);
    *ppElementResult = new COptionElement(pht->GetTag(), pDoc);

    if (*ppElementResult)
    {
        if (pht->IsDynamic())
            DYNCAST(COptionElement, *ppElementResult)->_fIsDynamic = TRUE;
        if (pht->Is(ETAG_OPTGROUP))
            DYNCAST(COptionElement, *ppElementResult)->_fIsOptGroup = TRUE;

        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//+------------------------------------------------------------------------
//
//  Member:     COptionElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
COptionElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLOptionElement, NULL)
        QI_HTML_TEAROFF(this, IHTMLOptionElement3, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     COptionElement::GetParentSelect
//
//  Synopsis:   Parent SELECT
//
//-------------------------------------------------------------------------

CSelectElement * 
COptionElement::GetParentSelect(void)
{
    if(!GetFirstBranch())
        return NULL;

    CElement * pElementParent = GetFirstBranch()->Parent()->SafeElement();

    if ( pElementParent )
    {
        if ( pElementParent->Tag() == ETAG_OPTGROUP )
        {
            return ((COptionElement*)pElementParent)->GetParentSelect();
        }
        else if (pElementParent->Tag() != ETAG_SELECT )
        {
            pElementParent = NULL;
        }
    }

    return (CSelectElement*)pElementParent;
}

#if DBG == 1
void
COptionElement::Passivate(void)
{
    CSelectElement * pSelect = GetParentSelect();

    Assert(! pSelect || pSelect->_poptLongestText != this);

    super::Passivate();
}
#endif // DBG

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::Notify
//
//  Synopsis:   Placeholder for the notification stuff
//
//  Note:       The OPTION might need it for managing the SELECT's cache
//
//----------------------------------------------------------------------------

void
COptionElement::Notify(CNotification *pNF)
{
    DWORD           dw = pNF->DataAsDWORD();

    super::Notify(pNF);

    switch(pNF->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:
        {
            CSelectElement * pSelect = GetParentSelect();

            if ( pSelect )
            {
                pSelect->_fOptionsDirty = TRUE;
                pSelect->Layout()->InternalNotify();
            }
        }

        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        _fInCollection = FALSE;
        if (!(dw & EXITTREE_DESTROY))
        {
            CSelectElement * pSelect = GetParentSelect();

            if (pSelect)
            {
                pSelect->_fOptionsDirty = TRUE;
                pSelect->Layout()->InternalNotify();
            }
        }
        break;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     COptionElement::Save
//
//  Synopsis:   Save the element to the stream
//
//-------------------------------------------------------------------------

HRESULT
COptionElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{

    // NOTE - (68121 krisma) If we are printing, and the parent select of 
    // the option is a combobox, and there is no option currently selected,
    // we need to save an empty select so that we print without any options 
    // showing. (By default, a combo box shows the first option.)

    HRESULT hr = S_OK;

    if (pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC))
    {
        CSelectElement * pSelect = GetParentSelect();
        if (pSelect && !pSelect->_fListbox && pSelect->GetCurSel() == -1)
        {
            goto Cleanup;
        }
    }
    hr = super::Save(pStreamWrBuff, fEnd);

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     COptionElement::Init2
//
//  Synopsis:   Initialization phase after attributes were set.
//
//  Note:       Save the SELECTED flag into DefaultSelected
//
//-------------------------------------------------------------------------

HRESULT
COptionElement::Init2(CInit2Context * pContext)
{
    HRESULT hr;

    hr = THR(super::Init2(pContext));
    if (hr)
        goto Cleanup;

    _fDefaultSelected = _fSELECTED;

Cleanup:
    RRETURN1(hr, S_INCOMPLETE);
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::Getindex
//
//  Synopsis:   Gets the index of the option object
//
//----------------------------------------------------------------------------

HRESULT
COptionElement::get_index(long * plIndex)
{
    if (!plIndex)
        RRETURN(SetErrorInfoInvalidArg());

    if ( _fInCollection )
    {
        CSelectElement * pSelect  = GetParentSelect();
        long             absIndex = pSelect->_aryOptions.Find(this);

        *plIndex = pSelect->RelIdxFromAbs( absIndex );
    }
    else
    {
        Assert(0 && "We shouldn't get here: getIndex while not in Options collection");
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::put_index
//
//  Synopsis:   Pretends to set the index of the option object
//              This is a silent no-op.
//
//----------------------------------------------------------------------------

HRESULT
COptionElement::put_index(long lIndex)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::get_form
//
//  Synopsis:   Returns the form above the option, if there is one.
//
//----------------------------------------------------------------------------

HRESULT
COptionElement::get_form(IHTMLFormElement **ppDispForm)
{
    HRESULT          hr = S_OK;
    CFormElement   * pForm;
    CSelectElement * pSelect;

    if (!ppDispForm)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDispForm = NULL;

    pSelect = GetParentSelect();

    if (pSelect)
        pForm = pSelect->GetParentForm();
    else
        goto Cleanup; // return S_OK/NULL

    if (pForm)
    {
        hr = THR_NOTRACE(pForm->QueryInterface(IID_IHTMLFormElement,
                                              (void**)ppDispForm));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN( SetErrorInfoPGet( hr, DISPID_CSite_form));
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::get_text
//
//  Synopsis:   Gets the index of the option object
//
//----------------------------------------------------------------------------

HRESULT
COptionElement::get_text(BSTR * pbstrText)
{
    HRESULT hr = S_OK;

    if (!pbstrText)
        RRETURN(SetErrorInfoInvalidArg());

    *pbstrText = NULL;

    if (_fIsOptGroup)
        goto Cleanup;

#if (DBG == 1 && defined(WIN16))
    CSelectElement *pSelect;

    //  This code sanity-check the text in the listbox
    //  against the text in the OPTION element to make sure they
    //  are still in sync.

    if ( _fInCollection &&
         NULL != (pSelect = GetParentSelect()) &&
         pSelect->_hwnd
        )
    {
        CStr cstrText;
        long cchText;
        long lIndex;

        lIndex = pSelect->_aryOptions.Find(this);

        Assert(lIndex > -1 );

        cchText = pSelect->SendSelectMessage(CSelectElement::Select_GetTextLen, lIndex, 0);
        if ( cchText == LB_ERR )
            goto Win32Error;

        hr = cstrText.ReAlloc(cchText);
        if ( hr )
            goto Error;

        cchText = pSelect->SendSelectMessage(CSelectElement::Select_GetText,
                                             lIndex,
                                             (LPARAM)(LPTSTR)cstrText);
        if ( cchText == LB_ERR )
            goto Win32Error;

        cstrText.SetLengthNoAlloc(cchText);

        Assert(0 == StrCmpC(_cstrText, cstrText));
    }
#endif

    if ( ! _cstrText.IsNull() )
    {
        hr = _cstrText.AllocBSTR(pbstrText);
        if ( hr )
            goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));

#if (DBG == 1 && defined(WIN16))

    //  Error handling block for the sanity check above
Error:
    SysFreeString(*pbstrText);
    *pbstrText = NULL;
    goto Cleanup;

Win32Error:
    hr = GetLastWin32Error();
    goto Error;

#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::put_text
//
//  Synopsis:   Set the display text pf the OPTION element
//
//----------------------------------------------------------------------------

HRESULT
COptionElement::put_text(BSTR bstrText)
{
    HRESULT hr = S_OK;

    // Note that VID 6.0 constructed a bad BSTR, without a proper length,
    // but zero terminated. So, we're going to rely on zero termination
    // instead of the length.
    LPTSTR pchText=(LPTSTR)bstrText;

    CSelectElement * pSelect = NULL;
    BOOL fOldEnableLayoutRequests = TRUE;
    BOOL fOldFlagValid = FALSE;

    long lIndex;
    long lSelectedIndex = 0;
    LRESULT lr;

    if (_fIsOptGroup)
        goto Cleanup;

    hr = _cstrText.Set(pchText);
    if ( hr )
        goto Cleanup;

    // invalidate font linking test
    _fCheckedFontLinking = FALSE;

    if ( !IsInMarkup() )
        goto Cleanup;

    pSelect = GetParentSelect();
    if ( pSelect )
    {
        fOldFlagValid = TRUE;
        fOldEnableLayoutRequests = pSelect->_fEnableLayoutRequests;
        pSelect->_fEnableLayoutRequests = FALSE;
    }

    {
        CMarkupPointer p1( Doc() ), p2( Doc() );

        hr = THR( p1.MoveAdjacentToElement( this, ELEM_ADJ_AfterBegin ) );

        if (hr)
            goto Cleanup;
                  
        hr = THR( p2.MoveAdjacentToElement( this, ELEM_ADJ_BeforeEnd ) );

        if (hr)
            goto Cleanup;

        hr = THR( Doc()->Remove( & p1, & p2 ) );

        if (hr)
            goto Cleanup;

        hr = THR( Doc()->InsertText( & p1, pchText, -1 ) );

        if (hr)
            goto Cleanup;
    }

    //  Old code brought back for synchronous update
    if ( _fInCollection && (NULL != pSelect) && pSelect->_hwnd )
    {
        lIndex = pSelect->_aryOptions.Find(this);

        Assert(lIndex > -1 );

        if ( ! pSelect->IsMultiSelect() )
        {
            lSelectedIndex = pSelect->SendSelectMessage(CSelectElement::Select_GetCurSel, 0, 0);
        }

        lr = pSelect->SendSelectMessage(CSelectElement::Select_DeleteString, lIndex, 0);
        if ( lr == LB_ERR )
            goto Win32Error;

        lr = pSelect->SendSelectMessage(CSelectElement::Select_InsertString, lIndex, (LPARAM)(LPTSTR)pchText);
        if ( lr == LB_ERR )
            goto Win32Error;

        if ( ! pSelect->IsMultiSelect() && lSelectedIndex == lIndex )
        {
            pSelect->SetCurSel(lSelectedIndex);
        }

        pSelect->DeferUpdateWidth();
    }

Cleanup:
    if ( fOldFlagValid && pSelect)
    {
        pSelect->_fEnableLayoutRequests = fOldEnableLayoutRequests;
    }
    RRETURN(SetErrorInfo(hr));

Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::put_defaultSelected
//
//  Synopsis:   Gets the index of the option object
//
//----------------------------------------------------------------------------

HRESULT
COptionElement::put_defaultSelected(VARIANT_BOOL f)
{
    _fDefaultSelected = (f == VB_TRUE);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::get_defaultSelected
//
//  Synopsis:   Gets the index of the option object
//
//----------------------------------------------------------------------------

HRESULT
COptionElement::get_defaultSelected(VARIANT_BOOL * pf)
{
    if ( ! pf )
        RRETURN (SetErrorInfo(E_POINTER));

    *pf = _fDefaultSelected ? VB_TRUE : VB_FALSE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::GetSelectedHelper
//
//  Synopsis:   Gets the selected state of the option object
//
//----------------------------------------------------------------------------

HRESULT
COptionElement::GetSelectedHelper(long * pf)
{
    HRESULT hr = S_OK;

    if (!pf)
        RRETURN(SetErrorInfoInvalidArg());

#if DBG == 1
    CSelectElement *pSelect;
    long lIndex;

    if ( _fSELECTED && ( NULL != (pSelect = GetParentSelect()) ) 
        && !( pSelect->_fMultiple ) && ( pSelect->_aryOptions.Size() > 0 ))
    {
        lIndex = pSelect->_aryOptions.Find(this);
        Assert (lIndex == pSelect->_iCurSel);
    }

#endif // DBG == 1

    *pf = _fSELECTED;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::SetSelectedHelper
//
//  Synopsis:   Gets the selected state of the option object
//
//----------------------------------------------------------------------------

HRESULT
COptionElement::SetSelectedHelper(long f)
{
    HRESULT hr = S_OK;
    CSelectElement *pSelect;
    long lIndex;
    LRESULT lr;
    int iOldSel;

    if (_fIsOptGroup)
        goto Cleanup;

    _fSELECTED = f;

    if ( _fInCollection && NULL != (pSelect = GetParentSelect()) )
    {
        iOldSel = pSelect->_iCurSel;
        int iCurSel;
        lIndex = pSelect->_aryOptions.Find(this);

        Assert(lIndex > -1 );
        if ( pSelect->_fMultiple )
        {
            lr = pSelect->SetSel(lIndex, !!f);
            if ( lr == LB_ERR )
                goto Win32Error;
        }
        else
        {
            //  Force collection update
            lr = pSelect->SetCurSel(lIndex, SETCURSEL_UPDATECOLL);
            if ( lr == LB_ERR )
                goto Win32Error;
        }

        iCurSel = pSelect->GetCurSel();
        if (iCurSel != iOldSel)
        {
            hr = THR(pSelect->OnPropertyChange(DISPID_CSelectElement_selectedIndex, 
                                               0, 
                                               (PROPERTYDESC *)&s_propdescCSelectElementselectedIndex));
            if (hr)
                goto Cleanup;
            if (pSelect->HasValueChanged(iOldSel, iCurSel))
            {
                hr = THR(pSelect->OnPropertyChange(DISPID_CSelectElement_value, 
                                                   0,
                                                   (PROPERTYDESC *)&s_propdescCSelectElementvalue));
                if (hr)
                    goto Cleanup;
            }
        }
    }

Cleanup:
    RRETURN(hr);

Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::GetDisplayColors
//
//  Synopsis:   Computes the fore and background colors of the option element
//              based on selection state, styles and Windows color preferences.
//
//----------------------------------------------------------------------------

void
COptionElement::GetDisplayColors(COLORREF * pcrFore, COLORREF * pcrBack, BOOL fListbox)
{
    CColorValue ccv;
    CSelectElement * pSelect;

    Assert(pcrFore);
    Assert(pcrBack);


    //  Set up the textcolor
    if ( (NULL != (pSelect = GetParentSelect())) &&
          pSelect->GetAAdisabled() )
    {
        *pcrFore = GetSysColorQuick(COLOR_GRAYTEXT);
    }
    else if ( fListbox && _fSELECTED )
    {
        *pcrFore = GetSysColorQuick(COLOR_HIGHLIGHTTEXT);
    }
    else if ( (ccv = GetFirstBranch()->GetCascadedcolor()).IsDefined() )
    {
        *pcrFore = ccv.GetColorRef();
    }
    else
    {
        *pcrFore = GetSysColorQuick(COLOR_WINDOWTEXT);
    }

    //Set up the backcolor
    if ( fListbox && _fSELECTED )
    {
        *pcrBack = GetSysColorQuick(COLOR_HIGHLIGHT);
    }
    else if ( (ccv = GetFirstBranch()->GetCascadedbackgroundColor()).IsDefined() )
    {
        *pcrBack = ccv.GetColorRef();
    }
    else
    {
        *pcrBack = GetSysColorQuick(COLOR_WINDOW);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     COptionElement::GetDisplayText
//
//  Synopsis:   Returns the display text according to TEXT_TRANSFORM.
//
//----------------------------------------------------------------------------

CStr *
COptionElement::GetDisplayText(CStr * pcstrBuf, BOOL noIndent /* = FALSE */)
{
    BYTE bTextTransform = GetFirstBranch()->GetCascadedtextTransform();

    Assert(pcstrBuf);

    if ( ( bTextTransform == styleTextTransformNotSet ) ||
         ( bTextTransform == styleTextTransformNone ) )
    {
        if (_fIsGroupOption && !noIndent)
        {
            pcstrBuf->Set(_T("      "));
            pcstrBuf->Append(_cstrText);
            return pcstrBuf;
        }
        else
         return &_cstrText;
    }
    else
    {
        if (_fIsGroupOption && !noIndent)
        {
            CStr cstrTemp;
        
            cstrTemp.Set(_T("      "));
            cstrTemp.Append(_cstrText);

            TransformText( *pcstrBuf,
                           cstrTemp,
                           cstrTemp.Length(),
                           bTextTransform );
        }
        else
        {
            TransformText( *pcstrBuf,
                           _cstrText,
                           _cstrText.Length(),
                           bTextTransform );
        }

        return pcstrBuf;
    }
}

//+---------------------------------------------------------------
//
//  Member   : COptionElement::OnPropertyChange
//
//  Synopsis : Do any work that Options need when a property is
//             changed
//
//+---------------------------------------------------------------
HRESULT
COptionElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;
    CSelectElement *pSelect;

    if ( NULL != (pSelect = GetParentSelect()) )
    {
            // some changes invalidate collections
        if (dwFlags & ELEMCHNG_UPDATECOLLECTION)
        {
            pSelect->InvalidateCollection();

            // Clear this flag: exclusive or
            dwFlags ^= ELEMCHNG_UPDATECOLLECTION;
        }

        if ( dispid == DISPID_COptionElement_text ||
             dispid == DISPID_UNKNOWN )
        {
            pSelect->DeferUpdateWidth();
        }

        if ( _fIsOptGroup && (dispid == DISPID_COptionElement_label) )
        {
            Assert( Tag() == ETAG_OPTGROUP );
            hr = _cstrText.Set(GetAAlabel());
            if ( hr )
                goto Cleanup;

            if ( _fInCollection && pSelect->_hwnd )
            {
                LRESULT lr;
                long lIndex = pSelect->_aryOptions.Find(this);
                Assert(lIndex > -1 );

                lr = pSelect->SendSelectMessage(CSelectElement::Select_DeleteString, lIndex, 0);
                if ( lr == LB_ERR )
                    goto Win32Error;

                lr = pSelect->SendSelectMessage(CSelectElement::Select_InsertString, lIndex, (LPARAM)(LPTSTR)_cstrText);
                if ( lr == LB_ERR )
                    goto Win32Error;

                pSelect->DeferUpdateWidth();
            }
        }

        hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    }

Cleanup:
    RRETURN(hr);

Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;
}

HRESULT
COptionElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr;

    if (_fIsGroupOption)
    {
        Assert(GetFirstBranch());
        CTreeNode *pNodeParent = GetFirstBranch()->Parent();
        Assert(pNodeParent && (pNodeParent->Tag() == ETAG_OPTGROUP));

        Assert(pNodeParent->GetIFF() != -1);
        const CFancyFormat *pff = pNodeParent->GetFancyFormat();

        Assert(!pCFI->_pff->_ccvBackColor.IsDefined());
        if (pff->_ccvBackColor.IsDefined())
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._ccvBackColor = pff->_ccvBackColor;
            pCFI->UnprepareForDebug();
        }
    }

    hr = THR(super::ApplyDefaultFormat(pCFI));
    if (hr)
        goto Cleanup;

    if (_fIsOptGroup)
    {
#if DBG == 1
        Assert(GetFirstBranch());
        CTreeNode *pNodeParent = GetFirstBranch()->Parent();
        Assert(pNodeParent && (pNodeParent->Tag() == ETAG_SELECT));

        long icf = pNodeParent->GetICF();
        Assert(icf != -1);
        const CCharFormat *pcf = GetCharFormatEx(icf);
        Assert(pcf == pCFI->_pcfSrc);
#endif

        pCFI->PrepareCharFormat();

        if (pCFI->_pcfSrc->_fItalic && pCFI->_pcfSrc->_fBold && (pCFI->_pcfSrc->_wWeight == FW_BOLD))
        {
            pCFI->_cf()._fUnderline = TRUE;
            pCFI->_cf()._fBold      = pCFI->_pcfSrc->_fBold;
            pCFI->_cf()._fItalic    = pCFI->_pcfSrc->_fItalic;
            pCFI->_cf()._wWeight    = pCFI->_pcfSrc->_wWeight;
        }
        else
        {
            pCFI->_cf()._fBold      = TRUE;
            pCFI->_cf()._fItalic    = TRUE;
            pCFI->_cf()._wWeight    = FW_BOLD;
            pCFI->_cf()._fUnderline = pCFI->_pcfSrc->_fUnderline;
        }

        pCFI->_cf()._latmFaceName    = pCFI->_pcfSrc->_latmFaceName;
        pCFI->_cf()._bCharSet        = pCFI->_pcfSrc->_bCharSet;
        pCFI->_cf()._bPitchAndFamily = pCFI->_pcfSrc->_bPitchAndFamily;
        pCFI->_cf()._lcid            = pCFI->_pcfSrc->_lcid;
        pCFI->_cf()._yHeight         = pCFI->_pcfSrc->_yHeight;
        pCFI->_cf()._wKerning        = pCFI->_pcfSrc->_wKerning;

        pCFI->_cf()._fExplicitFace   = pCFI->_pcfSrc->_fExplicitFace;
        pCFI->_cf()._fExplicitAtFont = pCFI->_pcfSrc->_fExplicitAtFont;
        pCFI->_cf()._fNarrow         = pCFI->_pcfSrc->_fNarrow;
        pCFI->_cf()._fOverline       = pCFI->_pcfSrc->_fOverline;
        pCFI->_cf()._fStrikeOut      = pCFI->_pcfSrc->_fStrikeOut;
        pCFI->_cf()._fSmallCaps      = pCFI->_pcfSrc->_fSmallCaps;

        pCFI->_cf()._fSuperscript    = pCFI->_pcfSrc->_fSuperscript;
        pCFI->_cf()._fSubscript      = pCFI->_pcfSrc->_fSubscript;
        pCFI->_cf()._fBumpSizeDown   = pCFI->_pcfSrc->_fBumpSizeDown;
        pCFI->_cf()._fPassword       = pCFI->_pcfSrc->_fPassword;
        pCFI->_cf()._fProtected      = pCFI->_pcfSrc->_fProtected;
        pCFI->_cf()._fSizeDontScale  = pCFI->_pcfSrc->_fSizeDontScale;
        pCFI->_cf()._fDownloadedFont = pCFI->_pcfSrc->_fDownloadedFont;
        pCFI->_cf()._fSubSuperSized  = pCFI->_pcfSrc->_fSubSuperSized;
        pCFI->_cf()._fOutPrecision   = pCFI->_pcfSrc->_fOutPrecision;

        pCFI->_cf()._bCrcFont = pCFI->_pcf->ComputeFontCrc();
        pCFI->UnprepareForDebug();
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member   : COptionElement::MeasureLine
//
//  Synopsis : Measure the length of a single line
//
//+---------------------------------------------------------------
long
COptionElement::MeasureLine(CCalcInfo * pci)
{
    CStr cstrBuffer;
    CStr * pcstrDisplayText;
    long lWidth;
    long cch;
    long lCharWidth = -1;
    CSelectElement * pSelect;
    int i;
    TCHAR * pch;
    const CCharFormat *pcf;
    const CParaFormat *pPF;
    BOOL fRTL;
    UINT taOld = 0;
    CCcs ccs;
    CCalcInfo   CI;

    pSelect = GetParentSelect();

    if ( ! pSelect )
        return -1;

    if ( ! pci )
    {
        CI.Init(pSelect->GetUpdatedLayout());
        pci = &CI;
    }

    pcstrDisplayText = GetDisplayText(&cstrBuffer);

    cch = pcstrDisplayText->Length();

    //  We don't support letterspacing in the listbox for v1.0
    //lWidth = (cch - 1) * GetCascadedletterSpacing().GetPixelValue(pci, CUnitValue::DIRECTION_CX, 0);
    lWidth = 0;

    if (_fIsOptGroup)
        pcf = GetFirstBranch()->GetCharFormat();
    else
        pcf = pSelect->GetFirstBranch()->GetCharFormat();

    pPF = pSelect->GetFirstBranch()->GetParaFormat();
    
    fRTL = pPF->HasRTL(TRUE);
    // ComplexText
    if(fRTL)
    {
        taOld = GetTextAlign(pci->_hdc);
        SetTextAlign(pci->_hdc, TA_RTLREADING | TA_RIGHT);
    }

    if ( ! pcf )
        return -1;  //  <<<< inline return

    if (!fc().GetCcs(&ccs, pci->_hdc, pci, pcf))
        return -1;

    if (CheckFontLinking(pci->_hdc, &ccs) && pcf != NULL)
    {
        // TODO: (benwest) this code won't be necessary after after bug 28568 is resolved...
        // the listbox charformat should be non-scaling but currently isn't.
        CCharFormat cf = *pcf;
        cf.SetHeightInNonscalingTwips(cf._yHeight);
        cf._bCrcFont = cf.ComputeFontCrc();
        // end

        lCharWidth = FontLinkTextOut(pci->_hdc, 0, 0, 0, NULL, *pcstrDisplayText, cch, pci, &cf, FLTO_TEXTEXTONLY);
        if (lCharWidth > 0)
        {
            lWidth += lCharWidth; // width of entire string
        }
    }

    if (lCharWidth < 0)
    {
        for ( i = cch, pch = *pcstrDisplayText;
              i > 0;
              i--, pch++ )
        {
            if ( ! ccs.Include(*pch, lCharWidth) )
            {
                Assert(0 && "Char not in font!");
            }
            lWidth += lCharWidth;
        }
    }

    SetTextAlign(pci->_hdc, taOld);

    ccs.Release();

    return lWidth;
}

//+---------------------------------------------------------------
//
//  Member   : COptionElement::CheckFontLinking
//
//  Synopsis : Returns TRUE iff this option needs font linking.
//
//+---------------------------------------------------------------
BOOL COptionElement::CheckFontLinking(XHDC hdc, CCcs *pccs)
{
    CStr cstrTransformed;
    CStr *pcstrDisplayText;
    LPCTSTR pString;

    if (_fCheckedFontLinking) // assuming only one thread will run this per element
    {
        return _fNeedsFontLinking;
    }

    _fCheckedFontLinking = TRUE;
    _fNeedsFontLinking = FALSE; // init for failure

    pcstrDisplayText = GetDisplayText(&cstrTransformed);
    pString = *pcstrDisplayText;

    if (pString == NULL)
    {
        return FALSE;
    }

    return (_fNeedsFontLinking = NeedsFontLinking(hdc, pccs, pString, _tcslen(pString), Doc()));
}


HRESULT
COptionElement::CacheText(void)
{
    HRESULT hr;

    CTreePos * ptpStart;
    CTreePos * ptpEnd;

    if (Tag() == ETAG_OPTION)
    {
        GetTreeExtent(&ptpStart, &ptpEnd);

        if( !ptpStart || !ptpEnd)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        {
            long    cp = ptpStart->GetCp() + 1;
            long    cch = ptpEnd->GetCp() - cp;

            CTxtPtr tp( GetMarkup(), cp );

            cch = tp.GetPlainTextLength( cch );

            _cstrText.Free();

            hr = _cstrText.ReAlloc(cch);
            if ( hr )
                goto Cleanup;

            Verify( cch == tp.GetPlainText( cch, _cstrText ) );
            _cstrText.SetLengthNoAlloc(cch);
        }
    }
    else
    {
        Assert(Tag() == ETAG_OPTGROUP);

        hr = _cstrText.Set(GetAAlabel());
        if ( hr )
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Class:      COptionElementFactory
//
//----------------------------------------------------------------------------

const COptionElementFactory::CLASSDESC COptionElementFactory::s_classdesc =
{
    {
        &CLSID_HTMLOptionElementFactory,     // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        NULL,                                // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                                // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLOptionElementFactory,      // _piidDispinterface
        &s_apHdlDescs,                       // _apHdlDesc
    },
    (void *)s_apfnIHTMLOptionElementFactory,         // _apfnTearOff
};

// Get this into CVariant next full build I do

//+---------------------------------------------------------------------------
//
//  Member:     COptionElementFactory::create
//
//  Synopsis:   Manufactures a new COptionElement/
//
//  Note:       Supports the "new Option(...)" JavaScript syntax
//
//----------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
COptionElementFactory::create(VARIANT varText,
    VARIANT varvalue,
    VARIANT varDefaultSelected,
    VARIANT varSelected,
    IHTMLOptionElement**ppnewElem )
{
    HRESULT hr;
    COptionElement *pOptionElem;
    CElement *pNewElem = NULL;
    CVariant varBSTRText;
    CVariant varBSTRvalue;
    CVariant varBOOLDefaultSelected;
    CVariant varBOOLSelected;

    if ( !ppnewElem )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppnewElem = NULL;

    // actualy ( [ BSTR text, [ BSTR value, [ BOOL defaultselected, [ BOOL selected] ] ] )
    // Create an Option element 
    hr = THR(_pMarkup->CreateElement(ETAG_OPTION, &pNewElem ));
    if ( hr )
        goto Cleanup;

    pOptionElem = DYNCAST(COptionElement, pNewElem);

    hr = THR(pOptionElem->QueryInterface ( IID_IHTMLOptionElement, (void **)ppnewElem ));

    // Now set up the properties specified ( if present )

    // Text
    hr = THR(varBSTRText.CoerceVariantArg(&varText, VT_BSTR) );
    if ( hr == S_OK )
    {
        hr = THR(pOptionElem->_cstrText.Set ( V_BSTR(&varBSTRText) ));
    }
    if ( !OK(hr) )
        goto Cleanup;

    // Value
    hr = THR(varBSTRvalue.CoerceVariantArg(&varvalue,VT_BSTR) );
    if ( hr == S_OK )
    {
        hr = THR(pOptionElem->SetAAvalue ( V_BSTR(&varBSTRvalue) ));
    }
    if ( !OK(hr) )
        goto Cleanup;

    // defaultSelected
    hr = THR(varBOOLDefaultSelected.CoerceVariantArg(&varDefaultSelected, VT_BOOL));
    if ( hr == S_OK )
    {
        pOptionElem->_fDefaultSelected = V_BOOL(&varBOOLDefaultSelected);
    }
    if ( !OK(hr) )
        goto Cleanup;

    // selected
    hr = THR(varBOOLSelected.CoerceVariantArg(&varSelected, VT_BOOL) );
    if ( hr == S_OK )
    {
        pOptionElem -> _fSELECTED = V_BOOL(&varBOOLSelected) == VB_TRUE ? TRUE : FALSE;
    }
    if ( !OK(hr) )
        goto Cleanup;


Cleanup:
    if (OK(hr))
    {
        hr = S_OK; // not to propagate possible S_FALSE
    }
    else
    {
        ReleaseInterface(*(IUnknown**)ppnewElem);
    }

    CElement::ClearPtr(&pNewElem);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\window.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       window.cxx
//
//  Contents:   Implementation of CWindow, CScreen classes
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_DOM_HXX_
#define X_DOM_HXX_
#include "dom.hxx"
#endif



#ifndef X_CONNECT_HXX_
#define X_CONNECT_HXX_
#include "connect.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"   // for a brief reference to cframesite.
#endif

#ifndef X_EXDISP_H_
#define X_EXDISP_H_
#include "exdisp.h"
#endif

#ifndef X_DISPEX_H_
#define X_DISPEX_H_
#include "dispex.h" // idispatchex
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_EOPTION_HXX_
#define X_EOPTION_HXX_
#include "eoption.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_HTMLHELP_H_
#define X_HTMLHELP_H_
#include "htmlhelp.h"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_CBUFSTR_HXX_
#define X_CBUFSTR_HXX_
#include "cbufstr.hxx"
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_TXTDEFS_H_
#define X_TXTDEFS_H_
#include "txtdefs.h"
#endif

#ifndef X_HTMLPOP_HXX_
#define X_HTMLPOP_HXX_
#include "htmlpop.hxx"
#endif

#ifndef X_HTMLDLG_HXX_
#define X_HTMLDLG_HXX_
#include "htmldlg.hxx"
#endif

#ifndef X_HTIFRAME_H_
#define X_HTIFRAME_H_
#include "htiframe.h"
#endif

#ifndef X_HTIFACE_H_
#define X_HTIFACE_H_
#include "htiface.h"
#endif

#ifndef X_HLINK_H_
#define X_HLINK_H_
#include "hlink.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_ESTYLE_HXX_
#define X_ESTYLE_HXX_
#include "estyle.hxx"
#endif

#ifndef X_ELINK_HXX_
#define X_ELINK_HXX_
#include "elink.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_PROGSINK_HXX_
#define X_PROGSINK_HXX_
#include "progsink.hxx"
#endif

#ifndef X_SELECOBJ_HXX_
#define X_SELECOBJ_HXX_
#include "selecobj.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_PERHIST_H_
#define X_PERHIST_H_
#include "perhist.h"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_FRAMET_H_
#define X_FRAMET_H_
#include "framet.h"
#endif

#ifndef X_ACCWIND_HXX_
#define X_ACCWIND_HXX_
#include "accwind.hxx"
#endif

#ifndef X_WEBOCUTIL_H_
#define X_WEBOCUTIL_H_
#include "webocutil.h"
#endif

#ifndef X_FRAMEWEBOC_HXX_
#define X_FRAMEWEBOC_HXX_
#include "frameweboc.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif


#ifndef X_OBJSAFE_H_
#define X_OBJSAFE_H_
#include "objsafe.h"
#endif

#ifndef X_THEMEHLP_HXX_
#define X_THEMEHLP_HXX_
#include "themehlp.hxx"
#endif

#if DBG==1
#ifndef X_VERIFYCALLSTACK_HXX_
#define X_VERIFYCALLSTACK_HXX_
#include "VerifyCallStack.hxx"
#endif
#ifndef X_DEBUGWINDOW_HXX_
#define X_DEBUGWINDOW_HXX_
#include "DebugWindow.h"
#endif
#endif


// external reference.
HRESULT WrapSpecialUrl(TCHAR *pchURL, CStr *pcstr, const TCHAR *pchBaseURL, BOOL fNotPrivate, BOOL fIgnoreUrlScheme);
extern BOOL IsSpecialUrl(LPCTSTR pszUrl);

extern BOOL g_fInPip;

EXTERN_C const GUID CLSID_CDocument;
extern BOOL IsScriptUrl(LPCTSTR pszURL);

BOOL GetCallerHTMLDlgTrust(CBase *pBase);

#define _cxx_
#include "window.hdl"

#define _cxx_
#include "document.hdl"

extern BOOL g_fInVizAct2000;
extern BOOL g_fInPhotoSuiteIII;

DeclareTag(tagOmWindow, "OmWindow", "OmWindow methods");
DeclareTag(tagSecurityContext, "Security", "Security Context Information Traces");
ExternTag(tagSecurityProxyCheck);
ExternTag(tagSecurityProxyCheckMore);
ExternTag(tagSecureScriptWindow);

MtDefine(CTimeoutEventList, CDoc, "CDoc::_TimeoutEvents");
MtDefine(CTimeoutEventList_aryTimeouts_pv, CTimeoutEventList, "CDoc::_TimeoutEvents::_aryTimeouts::_pv");
MtDefine(CTimeoutEventList_aryPendingTimeouts_pv, CTimeoutEventList, "CDoc::_TimeoutEvents::_aryPendingTimeouts::_pv");
MtDefine(CTimeoutEventList_aryPendingClears_pv, CTimeoutEventList, "CDoc::_TimeoutEvents::_aryPendingClears::_pv");
DeclareTag(tagReadystateAssert, "IgnoreRS", "ReadyState Assert");
HRESULT GetFullyExpandedUrl(CBase *pBase, BSTR bstrUrl, BSTR *pbstrFullUrl, BSTR * pbstrBaseUrl = NULL, IServiceProvider *pSP = NULL);
HRESULT GetCallerURL(CStr &cstr, CBase *pBase, IServiceProvider * pSP);
HRESULT GetCallerSecurityStateAndURL(SSL_SECURITY_STATE *pSecState, CStr &cstr, CBase *pBase, IServiceProvider * pSP);
TCHAR * ProtocolFriendlyName(TCHAR * szUrl);
#define ISVARIANTEMPTY(var) (V_VT(var) == VT_ERROR  || V_VT(var) == VT_EMPTY)
MtDefine(CWindow, ObjectModel, "CWindow");
MtDefine(CDocument, ObjectModel, "CDocument");
MtDefine(CWindowFindNamesFromOtherScripts_aryScript_pv, Locals, "CWindow::FindNamesFromOtherScripts aryScript::_pv");
MtDefine(CWindowFindNamesFromOtherScripts_pdispid, Locals, "CWindow::FindNamesFromOtherScripts pdispid");
MtDefine(EVENTPARAM, Locals, "EVENTPARAM");
MtDefine(CDataTransfer, ObjectModel, "CDataTransfer");
MtDefine(CFramesCollection, ObjectModel, "CFramesCollection");
MtDefine(CWindow_aryActiveModelessDlgs, CWindow, "CWindow::ClearCachedDialogs");
MtDefine(CWindow_aryPendingScriptErr, CWindow, "CWindow::ReportPendingScriptErrors");

BEGIN_TEAROFF_TABLE(CWindow, IProvideMultipleClassInfo)
    TEAROFF_METHOD(CWindow, GetClassInfo, getclassinfo, (ITypeInfo ** ppTI))
    TEAROFF_METHOD(CWindow, GetGUID, getguid, (DWORD dwGuidKind, GUID * pGUID))
    TEAROFF_METHOD(CWindow, GetMultiTypeInfoCount, getmultitypeinfocount, (ULONG *pcti))
    TEAROFF_METHOD(CWindow, GetInfoOfIndex, getinfoofindex, (
            ULONG iti,
            DWORD dwFlags,
            ITypeInfo** pptiCoClass,
            DWORD* pdwTIFlags,
            ULONG* pcdispidReserved,
            IID* piidPrimary,
            IID* piidSource))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_(CWindow, IServiceProvider)
        TEAROFF_METHOD(CWindow, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDocument, IServiceProvider)
        TEAROFF_METHOD(CDocument, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDataTransfer, IServiceProvider)
        TEAROFF_METHOD(CDataTransfer, QueryService, queryservice, (REFGUID guidService, REFIID riid, void **ppvObject))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CWindow, ITravelLogClient)
    TEAROFF_METHOD (CWindow, FindWindowByIndex, findwindowbyindex, (DWORD dwID, IUnknown ** ppunk))
    TEAROFF_METHOD (CWindow, GetWindowData, getwindowdata, (LPWINDOWDATA pWinData))
    TEAROFF_METHOD (CWindow, LoadHistoryPosition, loadhistoryposition, (LPOLESTR pszUrlLocation, DWORD dwCookie))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CWindow, IPersistHistory)
    // IPersist methods
    TEAROFF_METHOD(CWindow, GetClassID, getclassid, (LPCLSID lpClassID))
    // IPersistHistory methods
    TEAROFF_METHOD(CWindow, LoadHistory, loadhistory, (IStream *pStream, IBindCtx *pbc))
    TEAROFF_METHOD(CWindow, SaveHistory, savehistory, (IStream *pStream))
    TEAROFF_METHOD(CWindow, SetPositionCookie, setpositioncookie, (DWORD dwCookie))
    TEAROFF_METHOD(CWindow, GetPositionCookie, getpositioncookie, (DWORD *pdwCookie))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDocument, IPersistFile)
    // IPersist methods
    TEAROFF_METHOD(CDocument, GetClassID, getclassid, (CLSID *))
    // IPersistFile methods
    TEAROFF_METHOD(CDocument, IsDirty, isdirty, ())
    TEAROFF_METHOD(CDocument, Load, load, (LPCOLESTR pszFileName, DWORD dwMode))
    TEAROFF_METHOD(CDocument, Save, save, (LPCOLESTR pszFileName, BOOL fRemember))
    TEAROFF_METHOD(CDocument, SaveCompleted, savecompleted, (LPCOLESTR pszFileName))
    TEAROFF_METHOD(CDocument, GetCurFile, getcurfile, (LPOLESTR *ppszFileName))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDocument, IPersistMoniker)
    TEAROFF_METHOD(CDocument, GetClassID, getclassid, (LPCLSID lpClassID))
    TEAROFF_METHOD(CDocument, IsDirty, isdirty, ())
    TEAROFF_METHOD(CDocument, Load, load, (BOOL fFullyAvailable, IMoniker *pmkName, LPBC pbc, DWORD grfMode))
    TEAROFF_METHOD(CDocument, Save, save, (IMoniker *pmkName, LPBC pbc, BOOL fRemember))
    TEAROFF_METHOD(CDocument, SaveCompleted, savecompleted, (IMoniker *pmkName, LPBC pibc))
    TEAROFF_METHOD(CDocument, GetCurMoniker, getcurmoniker, (IMoniker  **ppimkName))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDocument, IPersistStreamInit)  // also IPersistStream
    // IPersist methods
    TEAROFF_METHOD(CDocument, GetClassID, getclassid, (CLSID * pclsid ))
    // IPersistStream and IPersistStreamInit methods
    TEAROFF_METHOD(CDocument, IsDirty, isdirty, ())
    TEAROFF_METHOD(CDocument, Load, load, (LPSTREAM pStream ))
    TEAROFF_METHOD(CDocument, Save, save, (LPSTREAM pStream, BOOL fClearDirty ))
    TEAROFF_METHOD(CDocument, GetSizeMax, getsizemax, (ULARGE_INTEGER FAR * pcbSize ))
    //IPersistStreamInit only methods
    TEAROFF_METHOD(CDocument, InitNew, initnew, ())
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDocument, IPersistHistory)
    // IPersist methods
    TEAROFF_METHOD(CDocument, GetClassID, getclassid, (LPCLSID lpClassID))
    // IPersistHistory methods
    TEAROFF_METHOD(CDocument, LoadHistory, loadhistory, (IStream *pStream, IBindCtx *pbc))
    TEAROFF_METHOD(CDocument, SaveHistory, savehistory, (IStream *pStream))
    TEAROFF_METHOD(CDocument, SetPositionCookie, setpositioncookie, (DWORD dwCookie))
    TEAROFF_METHOD(CDocument, GetPositionCookie, getpositioncookie, (DWORD *pdwCookie))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDocument, IObjectSafety)
    TEAROFF_METHOD(CDocument, GetInterfaceSafetyOptions, getinterfacesafetyoptions, (REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions))
    TEAROFF_METHOD(CDocument, SetInterfaceSafetyOptions, setinterfacesafetyoptions, (REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CWindow, ITargetNotify2)
    // ITargetNotify methods
    TEAROFF_METHOD(CWindow, OnCreate, oncreate, (IUnknown * pUnkDestination, ULONG cbCookie))
    TEAROFF_METHOD(CWindow, OnReuse, onreuse, (IUnknown * pUnkDestination))

    // ITargetNotify2 methods
    TEAROFF_METHOD(CWindow, GetOptionString, getoptionstring, (BSTR * pbstrOptions))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CWindow, IHTMLPrivateWindow)
    TEAROFF_METHOD(CWindow, SuperNavigate, supernavigate, (BSTR      bstrURL,
                                                           BSTR      bstrLocation,
                                                           BSTR      bstrShortcut,
                                                           BSTR      bstrFrameName,
                                                           VARIANT * pvarPostData,
                                                           VARIANT * pvarHeaders,
                                                           DWORD     dwFlags))
    TEAROFF_METHOD(CWindow, GetPendingUrl, getpendingurl, (LPOLESTR* pstrURL))
    TEAROFF_METHOD(CWindow, SetPICSTarget, setpicstarget, (IOleCommandTarget* pctPICS))
    TEAROFF_METHOD(CWindow, PICSComplete, picscomplete,   (BOOL fApproved))
    TEAROFF_METHOD(CWindow, FindWindowByName, findwindowbyname, (LPCOLESTR pstrTargetName, IHTMLWindow2 ** ppWindow))
    TEAROFF_METHOD(CWindow, GetAddressBarUrl, getaddressbarurl, (BSTR * pbstrURL))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CWindow, IHTMLPrivateWindow3)
    // IHTMLPrivateWindow2 methods
    TEAROFF_METHOD(CWindow, NavigateEx, navigateex, (BSTR bstrURL, BSTR bstrOriginal, BSTR bstrLocation, BSTR bstrContext, IBindCtx* pBindCtx, DWORD dwNavOptions, DWORD dwFHLFlags))
    TEAROFF_METHOD(CWindow, GetInnerWindowUnknown, getinnerwindowunknown, (IUnknown** ppUnknown))

    // IHTMLPrivateWindow3 methods
    TEAROFF_METHOD(CWindow, OpenEx, openex, (BSTR url, BSTR urlContext, BSTR name, BSTR features, VARIANT_BOOL replace, IHTMLWindow2 **pomWindowResult))
END_TEAROFF_TABLE()

#if DBG==1
BEGIN_TEAROFF_TABLE(CWindow, IDebugWindow)
    TEAROFF_METHOD(CWindow, SetProxyCaller, setproxycaller, (IUnknown *pProxy))
END_TEAROFF_TABLE()
#endif

const CONNECTION_POINT_INFO CWindow::s_acpi[] =
{
    CPI_ENTRY(IID_IDispatch, DISPID_A_EVENTSINK)
    CPI_ENTRY(DIID_HTMLWindowEvents, DISPID_A_EVENTSINK)
    CPI_ENTRY(IID_ITridentEventSink, DISPID_A_EVENTSINK)
    CPI_ENTRY(DIID_HTMLWindowEvents2, DISPID_A_EVENTSINK)
    CPI_ENTRY_NULL
};

const CBase::CLASSDESC CWindow::s_classdesc =
{
    &CLSID_HTMLWindow2,             // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    s_acpi,                         // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLWindow2,              // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

CDummySecurityDispatchEx g_DummySecurityDispatchEx;

class COptionsHolder;


HRESULT InternalShowModalDialog( HTMLDLGINFO * pdlgInfo );
HRESULT InternalModelessDialog( HTMLDLGINFO * pdlgInfo );
HRESULT EnsureAccWindow( CWindow * pWindow );

//+----------------------------------------------------------------------------------
//
//  Helper:     VariantToPrintableString
//
//  Synopsis:   helper for alert and confirm methods of window, etc.
//
//              Converts VARIANT to strings that conform with the JavaScript model.
//
//-----------------------------------------------------------------------------------

HRESULT
VariantToPrintableString (VARIANT * pvar, CStr * pstr)
{
    HRESULT     hr = S_OK;
    TCHAR       szBuf[64];

    Assert (pstr);

    switch (V_VT(pvar))
    {
        case VT_EMPTY :
        case VT_ERROR :
            LoadString(GetResourceHInst(), IDS_VAR2STR_VTERROR, szBuf, ARRAY_SIZE(szBuf));
            hr =THR(pstr->Set(szBuf));
            break;
        case VT_NULL :
            LoadString(GetResourceHInst(), IDS_VAR2STR_VTNULL, szBuf, ARRAY_SIZE(szBuf));
            hr = THR(pstr->Set(szBuf));
            break;
        case VT_BOOL :
            if (VARIANT_TRUE == V_BOOL(pvar))
            {
                LoadString(GetResourceHInst(), IDS_VAR2STR_VTBOOL_TRUE, szBuf, ARRAY_SIZE(szBuf));
                hr = THR(pstr->Set(szBuf));
            }
            else
            {
                LoadString(GetResourceHInst(), IDS_VAR2STR_VTBOOL_FALSE, szBuf, ARRAY_SIZE(szBuf));
                hr = THR(pstr->Set(szBuf));
            }
            break;
        case VT_BYREF:
        case VT_VARIANT:
            pvar = V_VARIANTREF(pvar);
            // fall thru
        default:
        {
            VARIANT varNew;
            VariantInit(&varNew);
            hr = THR(VariantChangeTypeSpecial(&varNew, pvar,VT_BSTR));
            if (!hr)
            {
                hr = THR(pstr->Set(V_BSTR(&varNew)));
                VariantClear(&varNew);
            }
        }

    }

    RRETURN (hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::CWindow
//
//  Synopsis:   ctor
//
//--------------------------------------------------------------------------

CWindow::CWindow(CMarkup *pMarkup)
{
    _pMarkup = pMarkup;
    pMarkup->SubAddRef();

    _dwPositionCookie  = NO_POSITION_COOKIE;

    IncrementObjectCount(&_dwObjCnt);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::CWindow
//
//  Synopsis:   dtor
//
//--------------------------------------------------------------------------
CWindow::~CWindow()
{
    Assert( !_pMarkup );
    Assert( !_pMarkupPending );

    if (_pAccWindow)
        delete _pAccWindow;

    // It is safe to delete here as we will get here only when
    // all refs to these subobjects are gone.
    delete _pHistory;
    delete _pLocation;
    delete _pNavigator;
}

CDoc *CWindow::Doc()
{
    if(_pMarkup && (_pMarkup->Doc())!= NULL)
    {
        return _pMarkup->Doc();
    }
    else
    {
        return NULL;
    }
}

CMarkup *
CWindow::Markup()
{
    // assert integrity of the links
    Assert (_pDocument);
    Assert (!_pDocument->_pMarkup && this == _pDocument->_pWindow);
    Assert ( _pMarkupPending || !_pMarkup->HasDocumentPtr());
    Assert ( _pMarkup || _pMarkupPending );

    // return the markup
    return _pMarkup;
};

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::Passivate
//
//  Synopsis:   1st phase destructor
//
//--------------------------------------------------------------------------
void
CWindow::Passivate()
{
    // Work around for to asyncronous issues of IWebBrowser2
    if (_pFrameWebOC)
    {
        _pFrameWebOC->DetachFromWindow();
    }
        
    DetachOnloadEvent();
    
    // Free the name string
    _cstrName.Free();
    VariantClear(&_varOpener);

    if (_pMarkupPending)
        ReleaseMarkupPending( _pMarkupPending );

    Assert( !_pMarkupPending );

    if (_pDocument)
        GWKillMethodCall(Document(), ONCALL_METHOD(CDocument, FirePostedOnPropertyChange, firepostedonpropertychange), 0);

    ClearMetaRefresh();

    Assert( !_pMarkup );

    ClearWindowData();

    if (_pWindowParent)
    {
        _pWindowParent->SubRelease();
        _pWindowParent = NULL;

        // If we go away without reenable modeless on
        // our parent markup, the parent will never
        // be able to navigate again.
        Assert( !_ulDisableModeless );
    }

    // In an error/out of memory condition, we may not have ever hooked up the document
    if (_pDocument)
    {
        Document()->PrivateRelease();
    }

    // Note: If there is no ViewLinked WebOC this is still okay.
    // This call is now being used with the changes in ViewLinkedWebOC.
    // We no longer disconnect on DocumentComplete

    ReleaseViewLinkedWebOC();

    if (_pFrameWebOC)
    {
        _pFrameWebOC->Release();
        _pFrameWebOC = NULL;
    }

    if ( _pLicenseMgr )
    {
        ((IUnknown*)_pLicenseMgr)->Release();
        _pLicenseMgr = NULL;
    }

    Assert(!_pOpenedWindow);
    Assert(!_pMarkupProgress);
    Assert(_dwProgCookie == 0);

    // passivate embedded objects
    _Screen.Passivate();

    super::Passivate();

    DecrementObjectCount(&_dwObjCnt);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::ReleaseViewLinkedWebOC
//
//  Synopsis:   helper to let go of WebOC correctly
//
//--------------------------------------------------------------------------
void
CWindow::ReleaseViewLinkedWebOC()
{
    Assert(!_dwWebBrowserEventCookie || _punkViewLinkedWebOC);

    if (_dwWebBrowserEventCookie && _punkViewLinkedWebOC)
    {
        DisconnectSink(_punkViewLinkedWebOC,
                       DIID_DWebBrowserEvents2,
                       &_dwWebBrowserEventCookie);
    }

    ClearInterface(&_punkViewLinkedWebOC);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::PrivateQueryInterface
//
//  Synopsis:   Per IPrivateUnknown
//
//--------------------------------------------------------------------------

HRESULT
CWindow::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
    // The IOmWindow * cast is required to distinguish between CBase vs/
    // IOmWindow IDispatch methods.
    QI_TEAROFF(this, IProvideMultipleClassInfo, NULL)
    QI_TEAROFF2(this, IProvideClassInfo, IProvideMultipleClassInfo, NULL)
    QI_TEAROFF2(this, IProvideClassInfo2, IProvideMultipleClassInfo, NULL)
    QI_INHERITS(this, IHTMLWindow2)
    QI_INHERITS(this, IHTMLWindow3)
    QI_INHERITS(this, IHTMLWindow4)
    QI_INHERITS(this, IDispatchEx)
    QI_INHERITS2(this, IDispatch, IHTMLWindow2)
    QI_INHERITS2(this, IUnknown, IHTMLWindow2)
    QI_INHERITS2(this, IHTMLFramesCollection2, IHTMLWindow2)
    QI_TEAROFF(this,  IServiceProvider, NULL)
    QI_TEAROFF(this,  ITravelLogClient, NULL)
    QI_TEAROFF(this,  IPersistHistory, NULL)
    QI_TEAROFF2(this, IPersist, IPersistHistory, NULL)
    QI_TEAROFF(this,  ITargetNotify2, NULL)
    QI_TEAROFF2(this, ITargetNotify, ITargetNotify2, NULL)
    QI_TEAROFF(this,  IHTMLPrivateWindow, NULL)
    QI_TEAROFF(this,  IHTMLPrivateWindow3, NULL)
    QI_TEAROFF2(this,  IHTMLPrivateWindow2, IHTMLPrivateWindow3, NULL)

#if DBG==1
    QI_TEAROFF(this,  IDebugWindow, NULL)
#endif

    QI_CASE(IConnectionPointContainer)
    {
        *((IConnectionPointContainer **)ppv) =
                new CConnectionPointContainer(this, NULL);

        if (!*ppv)
            RRETURN(E_OUTOFMEMORY);
        break;
    }

    default:
        if (iid == CLSID_HTMLWindow2)
        {
            *ppv = this;
            // do not do AddRef()
            return S_OK;
        }
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    DbgTrackItf(iid, "CWindow", FALSE, ppv);

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CWindow::PrivateAddRef, IUnknown
//
//  Synopsis:   Private unknown AddRef.
//
//-------------------------------------------------------------------------
ULONG
CWindow::PrivateAddRef()
{
    if( _ulRefs == 1 && _pWindowProxy )
    {
        _pWindowProxy->AddRef();
    }

    return super::PrivateAddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CWindow::PrivateRelease, IUnknown
//
//  Synopsis:   Private unknown Release.
//
//-------------------------------------------------------------------------
ULONG
CWindow::PrivateRelease()
{
    COmWindowProxy * pProxyRelease = NULL;

    if( _ulRefs == 2 )
        pProxyRelease = _pWindowProxy;

    ULONG ret =  super::PrivateRelease();

    if( pProxyRelease )
    {
        pProxyRelease->Release();
    }

    return ret;
}

//+------------------------------------------------------------------------
//
//  Member:     CWindow::SetProxy
//
//  Synopsis:   Play ref counting games when the proxy is set
//
//-------------------------------------------------------------------------
void
CWindow::SetProxy( COmWindowProxy * pProxyTrusted )
{
    Assert( pProxyTrusted );

    // The stack is holding on to us and the
    // proxy is already holding on to us
    Assert( _ulRefs >= 2 );
    _pWindowProxy = pProxyTrusted;
    _pWindowProxy->AddRef();
}

//+-------------------------------------------------------------------------
//
//  Method : COmWindow::QueryService
//
//  Synopsis : IServiceProvider methoid Implementaion.
//
//--------------------------------------------------------------------------

HRESULT
CWindow::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    HRESULT hr = E_POINTER;

    if (!ppvObject)
        goto Cleanup;

    *ppvObject = NULL;

    if (   _punkViewLinkedWebOC
        && !Doc()->_fActiveDesktop
        && IsEqualIID(guidService, IID_ITargetFrame2)
        && GetInnerWindow()
        && GetInnerWindow()->Markup()->IsXML()       )
    {
        hr = IUnknown_QueryService(_punkViewLinkedWebOC, guidService, riid, ppvObject);
        goto Cleanup;
    }
    else if (  _punkViewLinkedWebOC
            && IsEqualIID(guidService, SID_STopFrameBrowser)
            && IsEqualIID(riid, IID_IBrowserService))
    {
        hr = EnsureFrameWebOC();
        if (hr)
            goto Cleanup;

        hr = _pFrameWebOC->QueryService(guidService, riid, ppvObject);
        goto Cleanup;
    }
    else if (!_pMarkup->IsPrimaryMarkup() && IsEqualIID(riid, IID_IBrowserService))
    {
        goto Cleanup;
    }
    else if (   _pMarkup
             && !_pMarkup->IsPrimaryMarkup()
             && (   IsEqualIID(guidService, IID_IWebBrowserApp)
                 || IsEqualIID(guidService, SID_SHlinkFrame)
                 || IsEqualIID(guidService, IID_ITargetFrame)))
    {
        hr = EnsureFrameWebOC();
        if (hr)
            goto Cleanup;

        hr = _pFrameWebOC->PrivateQueryInterface(riid, ppvObject);
        goto Cleanup;
    }
    else if (IsEqualIID(guidService, SID_SHTMLWindow2))
    {
        hr = PrivateQueryInterface(riid, ppvObject);
        goto Cleanup;
    }
    else if (IsEqualIID(guidService, CLSID_HTMLWindow2))
    {
        hr = S_OK;

        // return a weak reference to ourselves.
        *ppvObject = this;

        goto Cleanup;
    }

    hr = THR_NOTRACE(Doc()->QueryService(guidService,
                                         riid,
                                         ppvObject));

Cleanup:
    RRETURN1(hr, E_NOINTERFACE);
}

CDocument *
CWindow::Document()
{
    Assert (_pDocument);
    Assert (!_pMarkup || !_pMarkup->HasDocumentPtr());

    return _pDocument;
}

HRESULT
CWindow::AttachOnloadEvent(CMarkup * pMarkup)
{
    Assert(pMarkup);

    if (_pMarkupProgress == pMarkup)
    {
        return S_OK;
    }

    IProgSink * pProgSink = CMarkup::GetProgSinkHelper(pMarkup);

    if (pProgSink)
    {
        _pMarkupProgress = pMarkup;
        _pMarkupProgress->SubAddRef();

        RRETURN(pProgSink->AddProgress(PROGSINK_CLASS_FRAME, &_dwProgCookie));
    }

    return S_OK;
}

void
CWindow::DetachOnloadEvent()
{
    if (_pMarkupProgress && _dwProgCookie)
    {
        IProgSink * pProgSink = CMarkup::GetProgSinkHelper(_pMarkupProgress);

        if (pProgSink)
        {
            IGNORE_HR(pProgSink->DelProgress(_dwProgCookie));
        }

        _dwProgCookie = 0;
        _pMarkupProgress->SubRelease();
        _pMarkupProgress = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::FindWindowByIndex
//
//  Interface : ITravelLogClient
//
//  Synopsis  : Returns the window with the given index. This method
//              recursively searches the frames collection for the window
//              with the given ID. If there are no frames contained in
//              the current window, this method only checks the ID of the
//              current window.
//
//--------------------------------------------------------------------------
HRESULT
CWindow::FindWindowByIndex(DWORD dwID, IUnknown ** ppunk)
{
    HRESULT      hr = E_FAIL;
    long         cFrames;
    CElement   * pElement;
    CFrameSite * pFrameSite;

    Assert(ppunk);

    *ppunk = NULL;

    // dwID = 0 in some cases when this method
    // is called by shdocvw. Return immediately,
    // if that is the case.
    //
    if (!dwID)
        goto Cleanup;

    if (dwID == _dwWindowID)
    {
        *ppunk = DYNCAST(IHTMLWindow2, this);
        AddRef();

        return S_OK;
    }
    else
    {
        // Do not set hr to the return value of any of these method
        // calls except FindWindowByIndex. The return value from
        // this method must only reflect whether or not the window was found.
        //
        cFrames = GetFramesCollectionLength();

        for (long i = 0; i < cFrames; i++)
        {
            if (THR(_pMarkup->CollectionCache()->GetIntoAry(CMarkup::FRAMES_COLLECTION, i, &pElement)))
                goto Cleanup;

            Assert(pElement);

            pFrameSite = DYNCAST(CFrameSite, pElement);

            if (pFrameSite->_pWindow)
            {
                hr = THR(pFrameSite->_pWindow->Window()->FindWindowByIndex(dwID, ppunk));
            }

            // Found it!!
            if (S_OK == hr)
                goto Cleanup;
        }
    }

Cleanup:
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::GetWindowData
//
//  Interface : ITravelLogClient
//
//  Synopsis  : Returns a WINDOWDATA structure containing pertinent
//              window information needed for the travel log..
//
//--------------------------------------------------------------------------

HRESULT
CWindow::GetWindowData(LPWINDOWDATA pWinData)
{
    HRESULT hr = S_OK;
    ULARGE_INTEGER cb;
    LARGE_INTEGER  liZero = {0, 0};

    Assert(_windowData.lpszUrl);
    Assert(_windowData.lpszTitle);
    Assert(_windowData.pStream);

    if (   !_windowData.lpszUrl
        || !_windowData.lpszTitle
        || !_windowData.pStream)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    pWinData->dwWindowID = _windowData.dwWindowID;
    pWinData->uiCP       = _windowData.uiCP;
    pWinData->pidl       = NULL;

    TaskReplaceString(_windowData.lpszUrl,   &pWinData->lpszUrl);
    TaskReplaceString(_windowData.lpszTitle, &pWinData->lpszTitle);

    TaskReplaceString(_windowData.lpszUrlLocation, &pWinData->lpszUrlLocation);

    if (!pWinData->pStream)
    {
        hr = CreateStreamOnHGlobal(NULL, FALSE, &pWinData->pStream);
        if (hr)
            goto Cleanup;
    }

    cb.LowPart = cb.HighPart = ULONG_MAX;

    Verify(!_windowData.pStream->Seek(liZero, STREAM_SEEK_SET, NULL));
    hr = _windowData.pStream->CopyTo(pWinData->pStream, cb, NULL, NULL);

Cleanup:
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::LoadHistoryPosition
//
//  Interface : ITravelLogClient
//
//  Synopsis  : Sets the Url location and position cookie. This is used
//              during a history navigation in a frame that involves a
//              local anchor.
//
//--------------------------------------------------------------------------

HRESULT
CWindow::LoadHistoryPosition(LPOLESTR pszUrlLocation, DWORD dwCookie)
{
    Assert(_pMarkup);

    HRESULT hr      = E_FAIL;
    CDoc  * pDoc    = Doc();
    BOOL    fCancel = FALSE;
    LPCTSTR pszUrl  = CMarkup::GetUrl(_pMarkup);
    DWORD   dwPositionCookie = 0;
    COmWindowProxy * pWindowPrxy = _pMarkup->Window();

    // The window data must be updated before navigating
    // because the window can actually change and the
    // window stream will be incorrect. The travel log
    // is only updated if the navigation is successful.
    // Note that this window data is the current window
    // because the travel entry will contain the stream
    // for this window.
    //
    Markup()->GetPositionCookie(&dwPositionCookie);
    UpdateWindowData(dwPositionCookie);

    if (pWindowPrxy && !IsPrimaryWindow())
    {
        pWindowPrxy->Window()->_fNavFrameCreation = FALSE;

        pDoc->_webOCEvents.BeforeNavigate2(pWindowPrxy,
                                           &fCancel,
                                           pszUrl,
                                           pszUrlLocation,
                                           _cstrName,
                                           NULL,
                                           0,
                                           NULL,
                                           TRUE);

        if (!fCancel)
        {
            hr = SetPositionCookie(dwCookie);
            if (hr)
                goto Cleanup;
        }

        Doc()->UpdateTravelLog(this,
                               TRUE, /* fIsLocalAnchor */
                               FALSE /* fAddEntry */);

        CMarkup::SetUrlLocation(_pMarkup, pszUrlLocation);

        pDoc->_webOCEvents.NavigateComplete2(pWindowPrxy);
        pDoc->_webOCEvents.DocumentComplete(pWindowPrxy, pszUrl, pszUrlLocation);
    }

Cleanup:
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::UpdateWindowData
//
//  Synopsis  : Updates the data associated with the current data.
//
//--------------------------------------------------------------------------

void
CWindow::UpdateWindowData(DWORD dwPositionCookie)
{
    HRESULT hr;

    ClearWindowData();

    hr = GetUrl(&_windowData.lpszUrl);
    if (hr)
    {
        goto Cleanup;
    }

    GetUrlLocation(&_windowData.lpszUrlLocation);

    Assert(_windowData.lpszUrl);
    Assert(*_windowData.lpszUrl);

    _windowData.dwWindowID = GetWindowIndex();
    _windowData.uiCP       = _pMarkup->GetURLCodePage();

    GetTitle(&_windowData.lpszTitle);

    Assert(_windowData.lpszTitle);

    _dwPositionCookie = dwPositionCookie;

    hr = CreateStreamOnHGlobal(NULL, TRUE, &_windowData.pStream);
    
    if (FAILED(hr))
        _windowData.pStream = NULL;

    Assert(S_OK == hr || E_OUTOFMEMORY == hr);

    if (!hr)
    {
        //
        // Only save user data in history if this is not a Https and the advanced option
        // settings allows it
        //

        DWORD   dwOptions =     GetUrlScheme(_windowData.lpszUrl) != URL_SCHEME_HTTPS
                            || !Doc()->_pOptionSettings->fDisableCachingOfSSLPages
                            ?   SAVEHIST_INPUT : 0;

        IGNORE_HR(_pMarkup->SaveHistoryInternal(_windowData.pStream, dwOptions));
    }

Cleanup:
    return;
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::ClearWindowData
//
//  Synopsis  : Clears the window data.
//
//--------------------------------------------------------------------------

void
CWindow::ClearWindowData()
{
    Assert(_windowData.lpszUrl || (!_windowData.lpszTitle && !_windowData.pStream));

    if (!_windowData.lpszUrl)  // Already cleared
        return;

    _windowData.dwWindowID = _windowData.uiCP = 0;
    _windowData.pidl = NULL;

    CoTaskMemFree(_windowData.lpszUrl);
    _windowData.lpszUrl = NULL;

    CoTaskMemFree(_windowData.lpszUrlLocation);
    _windowData.lpszUrlLocation = NULL;

    CoTaskMemFree(_windowData.lpszTitle);
    _windowData.lpszTitle = NULL;

    ClearInterface(&_windowData.pStream);
}

//+---------------------------------------------------------------
//
//  Member:     CWindow::ClearCachedDialogs
//
//  Synopsis:
//
//---------------------------------------------------------------
void
CWindow::ClearCachedDialogs()
{
    HWND hwndDlg = NULL;
    int i = 0;

    for (i=0; i < _aryActiveModeless.Size(); i++ )
    {
        hwndDlg = _aryActiveModeless[i];
        if (hwndDlg && !!IsWindow(hwndDlg))
        {
            PostMessage(hwndDlg, WM_CLOSE, 0, 0);
        }
    }
    _aryActiveModeless.DeleteAll();
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::GetWindowIndex
//
//  Synopsis  : Returns the index of the current window.
//
//--------------------------------------------------------------------------
DWORD
CWindow::GetWindowIndex()
{
    //  the first time we request the index, we init it.
    if (!_dwWindowID)
    {
        Assert(_pMarkup);

        if (_pMarkup->IsPrimaryMarkup())
        {
            _dwWindowID = WID_TOPWINDOW;
        }
        else do
        {
            _dwWindowID = CreateRandomNum();

        } while (!_dwWindowID || _dwWindowID == WID_TOPWINDOW || WID_TOPBROWSER == _dwWindowID);
    }

    TraceTag((tagOmWindow, "CWindow::GetWindowIndex - ID: 0x%x", _dwWindowID));

    return _dwWindowID;
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::GetUrl
//
//  Synopsis  : Returns the URL of the current window.
//
//--------------------------------------------------------------------------

HRESULT
CWindow::GetUrl(LPOLESTR * lpszUrl) const
{
    Assert(lpszUrl);
    Assert(_pMarkup);

    if (_pMarkup->HasUrl())
    {
        TaskReplaceString(CMarkup::GetUrl(_pMarkup), lpszUrl);

        Assert(*lpszUrl);
        TraceTag((tagOmWindow, "CWindow::GetUrl - URL: %ws", *lpszUrl));
    }

    return *lpszUrl ? S_OK : E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::GetUrlLocation
//
//  Synopsis  : Returns Url location associated with the current window.
//
//--------------------------------------------------------------------------

void
CWindow::GetUrlLocation(LPOLESTR * lpszUrlLocation) const
{
    Assert(lpszUrlLocation);
    Assert(_pMarkup);
    Assert(_pMarkup->HasWindowPending());

    LPCTSTR pszUrlLoc = CMarkup::GetUrlLocation(_pMarkup->GetWindowPending()->Markup());

    if (pszUrlLoc && *pszUrlLoc)
    {
        TaskReplaceString(pszUrlLoc, lpszUrlLocation);

        Assert(*lpszUrlLocation);
        TraceTag((tagOmWindow, "CWindow::GetUrlLocation - UrlLocation: %ws", *lpszUrlLocation));
    }
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::GetTitle
//
//  Synopsis  : Returns the title of the current window.
//
//--------------------------------------------------------------------------
HRESULT
CWindow::GetTitle(LPOLESTR * lpszTitle)
{
    Assert(_pMarkup);
    Assert(lpszTitle);

    HRESULT hr;
    CTitleElement * pTitleElement = _pMarkup->GetTitleElement();
    TCHAR         * pchTitle      = pTitleElement ? pTitleElement->GetTitle() : NULL;

    *lpszTitle = NULL;

    if (pTitleElement && pchTitle)
        TaskAllocString(pchTitle, lpszTitle);

    // No title was specified in the document
    if (!*lpszTitle)
    {
        const TCHAR * pchUrl = CMarkup::GetUrl(_pMarkup);

        if (pchUrl && GetUrlScheme(pchUrl) == URL_SCHEME_FILE)
        {
            TCHAR achFile[pdlUrlLen];
            ULONG cchFile = ARRAY_SIZE(achFile);

            hr = THR(PathCreateFromUrl(pchUrl, achFile, &cchFile, 0));
            if (hr)
                goto Cleanup;

            PathStripPath(achFile);

            TaskAllocString(achFile, lpszTitle);
        }
        else if (pchUrl && !(_pMarkup && _pMarkup->_fDesignMode))
        {
            TCHAR achUrl[pdlUrlLen + sizeof(DWORD)/sizeof(TCHAR)];
            DWORD cchUrl;

            // need to unescape the url when setting title

            if (S_OK == CoInternetParseUrl(pchUrl, PARSE_ENCODE, 0,
                                           achUrl + sizeof(DWORD) / sizeof(TCHAR),
                                           ARRAY_SIZE(achUrl) - sizeof(DWORD) / sizeof(TCHAR),
                                           &cchUrl, 0))
            {
                TaskAllocString(achUrl + sizeof(DWORD) / sizeof(TCHAR), lpszTitle);
            }
            else
            {
                TaskAllocString(pchUrl, lpszTitle);
            }
        }
        else
        {
            TCHAR szBuf[1024];

            *((DWORD *)szBuf) = LoadString(GetResourceHInst(),
                                           IDS_NULL_TITLE,
                                           szBuf + sizeof(DWORD) / sizeof(TCHAR),
                                           ARRAY_SIZE(szBuf) - sizeof(DWORD) / sizeof(TCHAR));
            Assert(*((DWORD *)szBuf) != 0);
            TaskAllocString(szBuf + sizeof(DWORD) / sizeof(TCHAR), lpszTitle);
        }
    }

    TraceTag((tagOmWindow, "CWindow::GetTitle - Title: %ws", *lpszTitle));

Cleanup:
    Assert(*lpszTitle);
    return *lpszTitle ? S_OK : E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::FindWindowByName
//
//  Synopsis  : Returns the window with the given name. This method calls
//              GetTargetWindow to find the window with the name
//              specified in pszTargetName. If the window is found,
//              this method attempts to retrieve the COmWindowProxy of
//              the window so that better performance may be achieved.
//
//  Input     : pszTargetName      - the name of the window to locate.
//  Output    : ppTargOmWindowPrxy - the COmWindowProxy of the window
//              ppTargHTMLWindow   - the IHTMLWindow2 of the window.
//                                   If the COmWindowProxy could be
//                                   retrieved, this parameter will
//                                   be null upon return.
//
//  Returns   : S_OK if found, OLE error code otherwise.
//
//--------------------------------------------------------------------------

HRESULT
CWindow::FindWindowByName(LPCOLESTR         pszTargetName,
                          COmWindowProxy ** ppTargOmWindowPrxy,
                          IHTMLWindow2   ** ppTargHTMLWindow,
                          IWebBrowser2   ** ppTopWebOC /* = NULL */)
{
    HRESULT        hr = E_FAIL;
    BOOL           fIsCurProcess;
    TARGET_TYPE    eTargetType;
    IHTMLWindow2 * pHTMLWindow = NULL;
    CWindow      * pTargetWindow;

    Assert(pszTargetName);
    Assert(*pszTargetName);
    Assert(ppTargHTMLWindow);

    *ppTargHTMLWindow = NULL;

    if (ppTargOmWindowPrxy)
        *ppTargOmWindowPrxy = NULL;

    eTargetType = GetTargetType(pszTargetName);

    if (eTargetType != TARGET_FRAMENAME)
    {
        hr = GetWindowByType(eTargetType, this, &pHTMLWindow, ppTopWebOC);

        // If *ppTopWebOC is set, there was a
        // problem retrieving the target window.
        //
        if (ppTopWebOC && *ppTopWebOC)
        {
            goto Cleanup;
        }
    }

    if (pHTMLWindow)
    {
        hr = pHTMLWindow->QueryInterface(CLSID_HTMLWindow2, (void**)&pTargetWindow);

        // If the QI fails, pHTMLWindow is a COmWindowProxy, which
        // means the target window was on another thread. Therefore,
        // we must use the proxy window itself. If the QI
        // succeeds, the target window is on the current thread so
        // we can safely use the CWindow object of the target window.
        //
        if (hr)
        {
            *ppTargHTMLWindow = pHTMLWindow;
            pHTMLWindow = NULL; // Don't release.
        }
        else if (ppTargOmWindowPrxy)
        {
            *ppTargOmWindowPrxy = pTargetWindow->_pMarkup->Window();
        }

        goto Cleanup;
    }

    hr = GetTargetWindow(this, pszTargetName, &fIsCurProcess, ppTargHTMLWindow);

    if (!hr)
    {
        Assert(*ppTargHTMLWindow);

        // If the window was found in the current process, get a ptr
        // to the window proxy. That way DoNavigate can
        // be called in FollowHyperlink instead of window.navigate.
        // If the window proxy is retrieved, release ppTargHTMLWindow
        // so that it won't be used.
        //
        if (fIsCurProcess && ppTargOmWindowPrxy)
        {
            if (S_OK == (*ppTargHTMLWindow)->QueryInterface(CLSID_HTMLWindowProxy,
                                                            (void**)ppTargOmWindowPrxy))
            {
                ClearInterface(ppTargHTMLWindow);
            }
            else
            {
                CWindow * pWindow;

                if (S_OK == (*ppTargHTMLWindow)->QueryInterface(CLSID_HTMLWindow2, (void **) &pWindow))
                {
                    *ppTargOmWindowPrxy = pWindow->_pMarkup->Window();
                    ClearInterface(ppTargHTMLWindow);
                }
            }
        }
    }

Cleanup:
    ReleaseInterface(pHTMLWindow);

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method    : CWindow::GetFramesCollectionLength
//
//  Synopsis  : Ensures that the collection cache exists and returns the
//              length of the frames collection.
//
//  Returns   : The length of the collection cache.
//
//--------------------------------------------------------------------------

long
CWindow::GetFramesCollectionLength() const
{
    long cFrames = 0;

    Assert(_pMarkup);

    if (THR(_pMarkup->EnsureCollectionCache(CMarkup::FRAMES_COLLECTION)))
        goto Cleanup;

    Assert(_pMarkup->CollectionCache());

    _pMarkup->CollectionCache()->GetLength(CMarkup::FRAMES_COLLECTION, &cFrames);

Cleanup:
    return cFrames;
}

//+------------------------------------------------------------------------
//
//  Member   : CWindow::GetClassID
//
//  Synopsis : Per IPersist
//
//-------------------------------------------------------------------------

STDMETHODIMP
CWindow::GetClassID(CLSID * pclsid)
{
    if (!pclsid)
    {
        RRETURN(E_INVALIDARG);
    }

    *pclsid = CLSID_HTMLWindow2;
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member   : CWindow::GetPositionCookie
//
//  Synopsis : Per IPersistHistory
//
//-------------------------------------------------------------------------

HRESULT
CWindow::GetPositionCookie(DWORD * pdwCookie)
{
    if (_pMarkup)
    {
        if (NO_POSITION_COOKIE != _dwPositionCookie)
        {
            *pdwCookie = _dwPositionCookie;
            _dwPositionCookie = NO_POSITION_COOKIE;

            return S_OK;
        }

        RRETURN (_pMarkup->GetPositionCookie(pdwCookie));
    }
    else
    {
        *pdwCookie = 0;
        return S_OK;
    }
}

//+------------------------------------------------------------------------
//
//  Member   : CWindow::SetPositionCookie
//
//  Synopsis : Per IPersistHistory
//
//-------------------------------------------------------------------------

HRESULT
CWindow::SetPositionCookie(DWORD dwCookie)
{
    if (_pMarkup)
    {
        IGNORE_HR(_pMarkup->SetPositionCookie(dwCookie));
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member   : CWindow::SaveHistory
//
//  Synopsis : Recursively saves the history on all frame windows.
//
//-------------------------------------------------------------------------

HRESULT
CWindow::SaveHistory(IStream * pStream)
{
    Assert(_pMarkup);
    Assert(pStream);

    ULARGE_INTEGER cb;
    LARGE_INTEGER  liZero = {0, 0};

    if (_windowData.pStream)
    {
        cb.LowPart = cb.HighPart = ULONG_MAX;

        Verify(!_windowData.pStream->Seek(liZero, STREAM_SEEK_SET, NULL));
        THR(_windowData.pStream->CopyTo(pStream, cb, NULL, NULL));

        return S_OK;
    }

    RRETURN(_pMarkup->SaveHistoryInternal(pStream, SAVEHIST_INPUT));
}

//+---------------------------------------------------------------------------
//
//  Member:     GetURLFromIStreamHelper
//
//  Synopsis: Read through the history stream - to find the URL
//            all other history codes are skipped over.
//
//
//            Note that changes to history in CMarkup::LoadHistoryHelper must be
//            propagated here.
//
//----------------------------------------------------------------------------


HRESULT
CWindow::GetURLFromIStreamHelper(IStream  * pStream,
                                 TCHAR   ** ppURL)
{
    HRESULT         hr = S_OK;
    DWORD historyCode;

    CDataStream ds(pStream);

    for (;;)
    {
        hr = THR(ds.LoadDword((DWORD*)&historyCode));
        if (hr)
            goto Cleanup;

        switch (historyCode)
        {
        case HISTORY_PCHURL:
            hr = THR(ds.LoadString( ppURL ));

            goto Cleanup; // we've got the string - so bail.
            break;

        //
        // Streams
        //
        case HISTORY_STMDIRTY:
        case HISTORY_STMREFRESH:
        case HISTORY_POSTDATA:
        case HISTORY_STMHISTORY:

            hr = THR(ds.SeekSubstream());
            if (hr)
                goto Cleanup;

            break;

        //
        // Strings
        //
        case HISTORY_PCHFILENAME:
        case HISTORY_PCHURLORIGINAL:
        case HISTORY_PCHURLLOCATION:
        case HISTORY_PCHDOCREFERER:
        case HISTORY_PCHSUBREFERER:
        case HISTORY_BOOKMARKNAME:
        case HISTORY_USERDATA:
        case HISTORY_CREATORURL:

            hr = THR(ds.SeekString());
            if (hr)
                goto Cleanup;
            break;

        //
        // Dwords
        //
        case HISTORY_NAVIGATED:
        case HISTORY_SCROLLPOS:
        case HISTORY_HREFCODEPAGE:
        case HISTORY_CODEPAGE:
        case HISTORY_FONTVERSION:
        case HISTORY_WINDOWID:

            hr = THR(ds.SeekDword());
            if (hr)
                goto Cleanup;
            break;

        //
        // No data
        //
        case HISTORY_BINDONAPT:
        case HISTORY_NONHTMLMIMETYPE:

            break;

        //
        // Specials
        //
        case HISTORY_PMKNAME:
            hr = THR(ds.SeekDword());
            if (hr)
                goto Cleanup;

            hr = THR(ds.SeekData( sizeof(CLSID)));
            if (hr)
                goto Cleanup;

            hr = THR(ds.SeekSubstream());
            if (hr)
                goto Cleanup;

            break;

        case HISTORY_FTLASTMOD:
            hr = THR(ds.SeekData( sizeof(FILETIME)));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_CURRENTSITE:
            {
                hr = THR(ds.SeekDword());
                if (hr)
                    goto Cleanup;
                hr = THR(ds.SeekDword());
                if (hr)
                    goto Cleanup;
                hr = THR(ds.SeekDword());
                if (hr)
                    goto Cleanup;
            }
            break;

        case HISTORY_REQUESTHEADERS:
        {
            DWORD dwSize;

            hr = THR(ds.LoadDword(& dwSize ));
            if (hr)
                goto Cleanup;

            hr = THR(ds.SeekData( dwSize ));
            if (hr)
                goto Cleanup;
            break;
        }


        case HISTORY_DOCDIRECTION:
            hr = THR(ds.SeekData(sizeof(WORD)));
            if (hr)
                goto Cleanup;
            break;

        case HISTORY_END:
            goto Cleanup;
#if DBG==1
        default:
            AssertSz( FALSE, "Unknown code found in history!" );
            break;
#endif // DBG
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CheckIfOffline
//
//  Synopsis: Check if the URL in a given Stream is offline. We do this by
//            getting the URL for a stream, and then
//            execing a command into shdocvw.
//
//----------------------------------------------------------------------------


HRESULT
CWindow::CheckIfOffline( IStream* pIStream )
{
    HRESULT hr;
    TCHAR*  pchURL = NULL ;
    CVariant varURL ;
    IStream*         pIStreamClone = NULL;
    CVariant          varContinue;

    if (!Doc())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        RRETURN(E_FAIL);
    }

    hr = THR( pIStream->Clone( & pIStreamClone ));
    if ( FAILED( hr ))
        goto Cleanup;

    hr = THR( GetURLFromIStreamHelper( pIStreamClone, & pchURL ));
    if ( FAILED(hr))
        goto Cleanup;

    V_VT( & varContinue ) = VT_BOOL;
    V_VT( &varURL ) = VT_BSTR;
    V_BSTR( &varURL ) = ::SysAllocString( pchURL );

    // Check if the browser is offline. If so, only
    // navigate if the page is in the cache or if
    // the user has chosen to connect to the Web.
    //

    V_BOOL(&varContinue) = VARIANT_TRUE; // init to variant true - incase we aren't hosted by shdocvw.
    
    Assert(Doc()->_pClientSite);
    IGNORE_HR(CTExec(Doc()->_pClientSite, &CGID_ShellDocView,
                     SHDVID_CHECKINCACHEIFOFFLINE, 0, &varURL, & varContinue));

    if (VARIANT_FALSE == V_BOOL(&varContinue))  // Stay Offline
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    MemFree( pchURL );
    ReleaseInterface( pIStreamClone );

    RRETURN1( hr , S_FALSE );
}

HRESULT
CDocument::GetXMLExpando(IDispatch** ppIDispXML, IDispatch** ppIDispXSL)
{
    CAttrValue* pAV;
    DISPID dispid;

    if ( ppIDispXML &&
         SUCCEEDED( GetExpandoDISPID(_T("XMLDocument"), & dispid , fdexNameCaseSensitive)))
    {
        AAINDEX aaIdx = AA_IDX_UNKNOWN;
    
        pAV = (*this->GetAttrArray())->Find( dispid, 
                                    CAttrValue::AA_Expando,
                                    & aaIdx);
        if (pAV)
        {
            *ppIDispXML = pAV->GetDispatch();
            if (*ppIDispXML)
                (*ppIDispXML)->AddRef();
        }
    }  

    if ( ppIDispXSL &&
         SUCCEEDED( GetExpandoDISPID(_T("XSLDocument"), & dispid , fdexNameCaseSensitive)))
    {
        AAINDEX aaIdx = AA_IDX_UNKNOWN;
    
        pAV = (*this->GetAttrArray())->Find( dispid, 
                                    CAttrValue::AA_Expando,
                                    & aaIdx);
        if (pAV)
        {
            *ppIDispXSL = pAV->GetDispatch();
            if (*ppIDispXSL)
                (*ppIDispXSL)->AddRef();
        }
    } 

    return S_OK;
}

HRESULT
CDocument::SetXMLExpando(IDispatch* pIDispXML, IDispatch* pIDispXSL)
{
    HRESULT hr = S_OK ;
    DISPID dispid, putid;
    DISPPARAMS dispparams = {NULL, NULL, 0, 0};
    VARIANT var;
    
    putid = DISPID_PROPERTYPUT;
    var.vt = VT_DISPATCH;

    dispparams.rgvarg = &var;
    dispparams.rgdispidNamedArgs = &putid;
    dispparams.cArgs = 1;
    dispparams.cNamedArgs = 1;

    if ( pIDispXML )
    {
        var.pdispVal = pIDispXML;
        GetExpandoDISPID(_T("XMLDocument"), & dispid , fdexNameEnsure);

        hr = THR( InvokeEx(dispid, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUT, &dispparams, NULL, NULL, NULL));
        if ( FAILED(hr) )
            goto Cleanup;
    }

    if ( pIDispXSL )
    {
        var.pdispVal = pIDispXSL;
        GetExpandoDISPID(_T("XSLDocument"), & dispid , fdexNameEnsure);

        hr = THR( InvokeEx(dispid, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUT, &dispparams, NULL, NULL, NULL));
        if ( FAILED(hr) )
            goto Cleanup;
    }

Cleanup:

    RRETURN( hr) ;
}

//+------------------------------------------------------------------------
//
//  Member   : CWindow::LoadHistory
//
//  Synopsis : Per IPersistHistory.
//
//-------------------------------------------------------------------------

HRESULT
CWindow::LoadHistory(IStream * pStream, IBindCtx * pbc)
{
    Assert(pStream);
    Assert(_pMarkup);

    HRESULT hr;
    CMarkup * pMarkupNew = NULL;
    CDoc    * pDoc = Doc();
    COmWindowProxy * pOmWindow = _pMarkup->Window();

    Assert(pOmWindow);

    if (!pOmWindow->Fire_onbeforeunload())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Check to see if this stream is offline. If it is then we don't load
    //
    hr = THR(CheckIfOffline(pStream));
    if (FAILED(hr))
        goto Cleanup;

    // freeze the old markup and nuke any pending readystate changes
    _pMarkup->ExecStop(FALSE, FALSE);

    ClearMetaRefresh();

    hr = pDoc->CreateMarkup(&pMarkupNew, NULL, NULL, FALSE, pOmWindow);
    if (hr)
        goto Cleanup;

    // Privacy list handling for history navigations
    // If this is a top level navigation, then 
    // 1. If it is user initiated, reset the list ELSE
    // 2. Add a blank record to demarcate the set of urls pertaining to this new top level url
    if (_pMarkup->IsPrimaryMarkup() && !pDoc->_fViewLinkedInWebOC)
    {
        if (pDoc->_cScriptNestingTotal)
            THR(pDoc->AddToPrivacyList(_T(""), NULL, PRIVACY_URLISTOPLEVEL));
        else
            THR(pDoc->ResetPrivacyList());
    }

    hr = THR(pMarkupNew->LoadHistoryInternal(pStream, pbc, BINDF_FWD_BACK, NULL, NULL, NULL, 0));
    if (hr)
        goto Cleanup;

    UpdateWindowData(NO_POSITION_COOKIE);

    // The setting of this flag MUST be after LoadHistoryInternal.
    // This is basically so that navigation clicks won't occur
    // when they shouldn't. If this flag needs to be moved
    // before LoadHistoryInternal, you must create a new flag on
    // the markup and set it to TRUE before calling
    // LoadHistoryInternal in DoNavigate.
    //
    if (_pMarkupPending)
    {
        _pMarkupPending->_fLoadingHistory = TRUE;
    }

Cleanup:
    if (pMarkupNew)
    {
        pMarkupNew->Release();
    }

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::GetTypeInfoCount
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

STDMETHODIMP
CWindow::GetTypeInfoCount(UINT FAR* pctinfo)
{
    TraceTag((tagOmWindow, "GetTypeInfoCount"));

    RRETURN(super::GetTypeInfoCount(pctinfo));
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::GetTypeInfo
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

STDMETHODIMP
CWindow::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo)
{
    TraceTag((tagOmWindow, "GetTypeInfo"));

    RRETURN(super::GetTypeInfo(itinfo, lcid, pptinfo));
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::GetIDsOfNames
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

STDMETHODIMP
CWindow::GetIDsOfNames(
    REFIID                riid,
    LPOLESTR *            rgszNames,
    UINT                  cNames,
    LCID                  lcid,
    DISPID FAR*           rgdispid)
{
    HRESULT     hr;

    hr = THR_NOTRACE(GetDispID(rgszNames[0], fdexFromGetIdsOfNames, rgdispid));

    // If we get no error but a DISPID_UNKNOWN then we'll want to return error
    // this mechanism is used for JScript to return a null for undefine name
    // sort of a passive expando.
    if (!hr && rgdispid[0] == DISPID_UNKNOWN)
    {
        hr = DISP_E_UNKNOWNNAME;
    }

    RRETURN(hr);
}


HRESULT
CWindow::Invoke(DISPID dispid,
                   REFIID riid,
                   LCID lcid,
                   WORD wFlags,
                   DISPPARAMS *pdispparams,
                   VARIANT *pvarResult,
                   EXCEPINFO *pexcepinfo,
                   UINT *puArgErr)
{
    return InvokeEx(dispid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    NULL);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::InvokeEx
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------
STDMETHODIMP
CWindow::InvokeEx(DISPID       dispidMember,
                  LCID         lcid,
                  WORD         wFlags,
                  DISPPARAMS * pdispparams,
                  VARIANT    * pvarResult,
                  EXCEPINFO  * pexcepinfo,
                  IServiceProvider * pSrvProvider)
{
    TraceTag((tagOmWindow, "Invoke dispid=0x%x", dispidMember));

    HRESULT                 hr;
    RETCOLLECT_KIND         collectionCreation;
    IDispatch *             pDisp = NULL;
    IDispatchEx *           pDispEx = NULL;
    CCollectionCache *      pCollectionCache;
    CScriptCollection *     pScriptCollection;
    CMarkupScriptContext *  pMarkupScriptContext;


    CDoc               *pDoc = Doc();
    CStr                cstrSecurityCtx;
    LPCTSTR             pchCreatorUrl = NULL;

    // TODO:  ***TLL*** Should be removed when IActiveScript is fixed to
    //        refcount the script site so we don't have the addref the
    //        _pScriptCollection.
    CDoc::CLock Lock(pDoc);

#if DBG == 1
    // Debug verification of caller security
    // TAG DISABLED BY DEFAULT (1) for perf reasons (2) to pass BVT on initial checkin
    if (IsTagEnabled(tagSecurityProxyCheck))
    {
        // Assert the call is coming from COmWindowProxy or other secure caller (e.g. AccessAllowed)
        // No one should have IDispatch to CWindow - that would be a major security hole!
        static const VERIFYSTACK_CALLERINFO aCallers[] =
        {
            { "mshtml",     "COmWindowProxy::InvokeEx", 1, 4,   CALLER_GOOD },
            { "mshtml",     "COmWindowProxy::Invoke",   1, 4,   CALLER_GOOD },
            { "mshtml",     "GetSIDOfDispatch",         1, 10,  CALLER_GOOD },
            { "jscript",    "",                         1, 10,  CALLER_BAD_IF_FIRST },
            { "vbscript",   "",                         1, 10,  CALLER_BAD_IF_FIRST },
        };
        
        static const int cMaxStack = 32; // max stack depth to analyze
        VERIFYSTACK_SYMBOLINFO asi[cMaxStack];
        int iBadCaller;
        
        static const int cMaxIgnore = 32; // max cases to ignore
        static VERIFYSTACK_SYMBOLINFO asiIgnore[cMaxIgnore];
        static int cIgnored = 0; 

        // DEBUG FEATURE: deny access if verification failed and SHIFT pressed - shows the problem in script debugger
        if (S_OK != VerifyCallStack("mshtml", aCallers, ARRAY_SIZE(aCallers), asi, sizeof(asi), &iBadCaller))
        {
            Assert(0 <= iBadCaller && iBadCaller < cMaxStack);

            // Somebody calls DISPID_SECURITYCTX directly on CWindow (from oleaut32)
            if (!IsTagEnabled(tagSecurityProxyCheckMore) 
                && (
                        dispidMember ==  DISPID_SECURITYCTX     // security context 
                    ||  dispidMember ==  DISPID_SECURITYDOMAIN  // security domain 
                   )   
               )
            {
                goto IgnoreThisCaller;
            }
            
             
            // look in ignore list - no assert if it is there
            for (int iIgnore = 0; iIgnore < cIgnored; iIgnore++)
            {
                if (0 == memcmp(&asiIgnore[iIgnore], &asi[iBadCaller], sizeof(VERIFYSTACK_SYMBOLINFO)))
                    goto IgnoreThisCaller;
            }
            
            AssertSz(FALSE, "CWindow: Wrong call stack (shift+Ignore to debug script, alt+click to ignore this caller)");

            if (GetAsyncKeyState(VK_SHIFT) & 0x8000)
            {
                // deny access to see the caller in script debugger
                hr = E_ACCESSDENIED;
                goto Cleanup;
            }

            if (GetAsyncKeyState(VK_MENU) & 0x8000)
            {
                // ignore this occurance
                // TRICKY - since we haven't found a good caller, which of unknown callers to ignore?
                //          the stack verifier has returned a "bad" index, which is 
                //          usually the first caller outside mshtml - we'll remember that one.
                if (cIgnored < cMaxIgnore)
                {
                    memcpy(&asiIgnore[cIgnored], &asi[iBadCaller], sizeof(VERIFYSTACK_SYMBOLINFO));
                    cIgnored++;
                }
            }
            
IgnoreThisCaller:
            ;
        }

        // If we are actually called from a proxy, assert it is not trusted
        if (_pProxyCaller)
        {
            IDebugWindowProxy *pIDebugProxy = NULL;
            if (S_OK == _pProxyCaller->QueryInterface(IID_IDebugWindowProxy, (void**)&pIDebugProxy))
            {
                BOOL fDenyAccess = FALSE;
                VARIANT_BOOL vbSecure = VB_FALSE;
                
                // check if we are called from secure proxy
                if (S_OK != pIDebugProxy->get_isSecureProxy(&vbSecure) || vbSecure != VB_TRUE)
                {
                    // oh no!!! It is not a secure proxy! 
                    // Look for known exceptions
                    if (
                            dispidMember >=  DISPID_OMWINDOWMETHODS // call from script engine
                        ||  dispidMember ==  DISPID_SECURITYCTX     // security context - called from AccessAllowed
                        ||  dispidMember ==  DISPID_SECURITYDOMAIN  // security domain - called from AccessAllowed
                       )
                    {
                        Assert(TRUE);   // benign call
                    }
                    else
                    {
                        AssertSz(FALSE, "CWindow::InvokeEx called from trusted proxy (shift+Ingore to debug script)");

                        // DEBUG FEATURE: deny access if verification failed and SHIFT pressed - shows the problem in script debugger
                        if (GetAsyncKeyState(VK_SHIFT) & 0x8000)
                        {
                            fDenyAccess = TRUE;
                        }
                    }
                }
                pIDebugProxy->Release();

                // Deny access when shift pressed
                if (fDenyAccess)
                {
                    hr = E_ACCESSDENIED;
                    goto Cleanup;
                }
            }
            else
                AssertSz(FALSE, "Failed to QI(IDebugWindowProxy) from proxy caller");
        }
    }
#endif

    //
    // Handle magic dispids which are used to serve up certain objects to the
    // browser:
    //

    switch(dispidMember)
    {
    case DISPID_BEFORENAVIGATE2:
    case DISPID_NAVIGATECOMPLETE2:
    case DISPID_DOWNLOADBEGIN:
    case DISPID_DOWNLOADCOMPLETE:
    case DISPID_TITLECHANGE:
    case DISPID_PROGRESSCHANGE:
    case DISPID_STATUSTEXTCHANGE:
        {
            // Fire ViewLinkedWebOC events at the frame level
            if (_punkViewLinkedWebOC)
            {
                _pFrameWebOC->InvokeEvent(dispidMember, DISPID_UNKNOWN, NULL, NULL, pdispparams);
            }

            break;
        }

    case DISPID_FILEDOWNLOAD:
        {
            Assert(pdispparams);
            Assert(pdispparams->cArgs == 2);

            // the second parameter is an indicator of a doc object being loaded
            Assert(V_VT(&(pdispparams->rgvarg[1])) == VT_BOOL);

            if (V_BOOL(&(pdispparams->rgvarg[1])) == VARIANT_TRUE)
            {
                _fFileDownload = FALSE;
            }
            else
            {
                _fFileDownload = TRUE;
            }

            // Fire DISPID_FILEDOWNLOAD events at the frame level
            if (_punkViewLinkedWebOC)
            {
                _pFrameWebOC->InvokeEvent(dispidMember, DISPID_UNKNOWN, NULL, NULL, pdispparams);
            }

            hr = S_OK;
            goto Cleanup;
        }

    case DISPID_DOCUMENTCOMPLETE:
        {
            if (_pMarkupPending)
            {
                if (_fFileDownload)
                {
                    // For file download, we must fire a DocumentComplete
                    // to match our BeforeNavigate2. Note: NavigateComplete2
                    // is not fired in this case for IE 5.0 compatibility.
                    //
                    pDoc->_webOCEvents.DocumentComplete(_pMarkupPending->GetWindowPending(),
                                                        CMarkup::GetUrl(_pMarkupPending),
                                                        CMarkup::GetUrlLocation(_pMarkupPending));

                    ReleaseMarkupPending(_pMarkupPending);
                }
                else
                {
                    _pMarkup->Window()->SwitchMarkup(_pMarkupPending,
                                                     TRUE,
                                                     COmWindowProxy::TLF_UPDATETRAVELLOG);
                }

            }

            _pMarkup->_fLoadingHistory = FALSE;

            _pMarkup->OnLoadStatus(LOADSTATUS_DONE);

            _fFileDownload = FALSE;

            // Fire DISPID_DOCUMENTCOMPLETE events at the frame level

            if (_punkViewLinkedWebOC)
            {
                _pFrameWebOC->InvokeEvent(dispidMember, DISPID_UNKNOWN, NULL, NULL, pdispparams);
            }

            hr = S_OK;
            goto Cleanup;
        }

    case DISPID_WINDOWOBJECT:
        //
        // Return a ptr to the real window object.
        //

        IHTMLWindow2 * pWindow;
        hr = THR(QueryInterface(IID_IHTMLWindow2, (void **) &pWindow));
        if (hr)
            goto Cleanup;

        V_VT(pvarResult) = VT_DISPATCH;
        V_DISPATCH(pvarResult) = pWindow;
        hr = S_OK;
        goto Cleanup;

    case DISPID_SECURITYCTX:
        TCHAR * pchBuf;
        TCHAR   achURL[pdlUrlLen];
        DWORD   dwSize;

        //
        // Return the url of the document and it's domain (if set)
        // in an array.
        //

        if (!pvarResult)
        {
            hr = E_POINTER;
            goto Cleanup;
        }

        V_VT(pvarResult) = VT_BSTR;

        pchCreatorUrl = _pMarkup->GetAAcreatorUrl();

        Assert(!!CMarkup::GetUrl(_pMarkup));

        // Do we have a File: protocol URL?
        hr = THR(CoInternetParseUrl(CMarkup::GetUrl(_pMarkup),
                                    PARSE_PATH_FROM_URL,
                                    0,
                                    achURL,
                                    ARRAY_SIZE(achURL),
                                    &dwSize,
                                    0));

        // hr == S_OK indicates that we do have a file: URL.
        if (!hr)
        {
            pchBuf = achURL;
        }
        else
        {
            pchBuf = (TCHAR *)CMarkup::GetUrl(_pMarkup);
        }

        //
        // If there is a creator window, then use its url as the domain url
        // If there is a creator it means that this is a special URL frame
        // or a window opened by a window.open call.
        //
        if (pchCreatorUrl && *pchCreatorUrl)
        {
            // Prepare a URL to give to the URLMON.
            hr = THR(WrapSpecialUrl(pchBuf,
                                    &cstrSecurityCtx,
                                    pchCreatorUrl,
                                    FALSE,
                                    FALSE));
        }
        else
        {
            cstrSecurityCtx.Set(pchBuf);
        }

        hr = THR(FormsAllocString(cstrSecurityCtx, &V_BSTR(pvarResult)));

        goto Cleanup;

    case DISPID_SECURITYDOMAIN:
        //
        // If set, return the domain property of the document.
        // Fail otherwise.
        //

        if (_pMarkup->Domain() && *(_pMarkup->Domain()))
        {
            if (!pvarResult)
            {
                hr = E_POINTER;
                goto Cleanup;
            }

            V_VT(pvarResult) = VT_BSTR;
            hr = THR(FormsAllocString(_pMarkup->Domain(), &V_BSTR(pvarResult)));
        }
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
        }
        goto Cleanup;

    case DISPID_HISTORYOBJECT:
        if (!_pHistory)
        {
            _pHistory = new COmHistory(this);
            if (!_pHistory)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
        hr = THR(_pHistory->QueryInterface(IID_IDispatch, (void**)&pvarResult->punkVal));
        goto FinishVTAndReturn;

    case DISPID_LOCATIONOBJECT:
        if(!_pLocation)
        {
            _pLocation = new COmLocation(this);
            if (!_pLocation)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
        hr = THR(_pLocation->QueryInterface(IID_IDispatch, (void**)&pvarResult->punkVal));
        goto FinishVTAndReturn;

    case DISPID_NAVIGATOROBJECT:
        if(!_pNavigator)
        {
            _pNavigator = new COmNavigator(this);
            if (!_pNavigator)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }

        hr = THR(_pNavigator->QueryInterface(IID_IDispatch, (void**)&pvarResult->punkVal));
        goto FinishVTAndReturn;

    default:
        break;

FinishVTAndReturn:
        if (hr)
            goto Cleanup;
        pvarResult->vt = VT_DISPATCH;
        goto Cleanup;   // successful termination.
    }

    hr = THR(_pMarkup->EnsureCollectionCache(CMarkup::FRAMES_COLLECTION));
    if (hr)
        goto Cleanup;

    pCollectionCache = _pMarkup->CollectionCache();
    if ( pCollectionCache->IsDISPIDInCollection ( CMarkup::FRAMES_COLLECTION, dispidMember ) )
    {
        if ( pCollectionCache->IsOrdinalCollectionMember (
            CMarkup::FRAMES_COLLECTION, dispidMember ) )
        {
            // Resolve ordinal access to Frames
            //
            // If this dispid is one that maps to the numerically indexed
            // items, then simply use the index value with our Item() mehtod.
            // This handles the frames[3] case.
            //

            hr = THR(_pMarkup->GetCWindow(dispidMember -
                pCollectionCache->GetOrdinalMemberMin ( CMarkup::FRAMES_COLLECTION ),
                (IHTMLWindow2**)&V_DISPATCH(pvarResult) ));

            if (!hr) // if successfull, nothing to do more
            {
                V_VT(pvarResult) = VT_DISPATCH;
                goto Cleanup;
            }
        }
        else
        {
            // Resolve named frame

            // dispid from FRAMES_COLLECTION GIN/GINEX
            CAtomTable *pAtomTable;
            LPCTSTR     pch = NULL;
            long        lOffset;
            BOOL        fCaseSensitive;

            lOffset = pCollectionCache->GetNamedMemberOffset(CMarkup::FRAMES_COLLECTION,
                                        dispidMember, &fCaseSensitive);

            pAtomTable = pCollectionCache->GetAtomTable(FALSE);
            if( !pAtomTable )
                goto Cleanup;

            hr = THR(pAtomTable->GetNameFromAtom(dispidMember - lOffset, &pch));

            if (!hr)
            {
                CElement *      pElem;
                IHTMLWindow2 *  pCWindow;
                CFrameSite *    pFrameSite;

                hr = pCollectionCache->GetIntoAry( CMarkup::FRAMES_COLLECTION,
                                            pch, FALSE, &pElem, 0, fCaseSensitive);

                // The FRAMES_COLLECTION is marked to always return the last matching name in
                // the returned pElement - rather than the default first match - For Nav compat.
                // GetIntoAry return S_FALSE if more than one item found - like Nav
                // though we ignore this
                if ( hr && hr != S_FALSE )
                    goto Cleanup;

                pFrameSite = DYNCAST (CFrameSite, pElem );

                hr = pFrameSite->GetCWindow( &pCWindow );
                if (!hr)
                {
                    V_VT(pvarResult) = VT_DISPATCH;
                    V_DISPATCH(pvarResult) = pCWindow;
                }
                goto Cleanup;
            }
            // else name not found in atom table, try the other routes
            // to resolve the Dispid.
        }
    }

    // If the DISPID came from the dynamic typelib collection, adjust the DISPID into
    // the WINDOW_COLLECTION, and record that the Invoke should only return a single item
    // Not a collection

    if ( dispidMember >= DISPID_COLLECTION_MIN &&
        dispidMember < pCollectionCache->GetMinDISPID( CMarkup::WINDOW_COLLECTION ) )
    {
        // DISPID Invoke from the dynamic typelib collection
        // Adjust it into the WINDOW collection
        dispidMember = dispidMember - DISPID_COLLECTION_MIN +
            pCollectionCache->GetMinDISPID( CMarkup::WINDOW_COLLECTION );
        // VBScript only wants a dipatch ptr to the first element that matches the name
        collectionCreation = RETCOLLECT_FIRSTITEM;
    }
    else if (dispidMember >= DISPID_EVENTHOOK_SENSITIVE_BASE &&
             dispidMember <= DISPID_EVENTHOOK_INSENSITIVE_MAX)
    {
        // Quick VBS event hookup always hooks to the last item in the collection.  This is for
        // IE4 VBS compatibility when foo_onclick is used if foo returns a collection of elements
        // with the name foo.  The only element to hookup for the onclick event would be the last
        // item in the collection of foo's.
        if (dispidMember <= DISPID_EVENTHOOK_SENSITIVE_MAX)
        {
            dispidMember -= DISPID_EVENTHOOK_SENSITIVE_BASE;
            dispidMember += pCollectionCache->GetSensitiveNamedMemberMin(CMarkup::WINDOW_COLLECTION);
        }
        else
        {
            dispidMember -= DISPID_EVENTHOOK_INSENSITIVE_BASE;
            dispidMember += pCollectionCache->GetNotSensitiveNamedMemberMin(CMarkup::WINDOW_COLLECTION);
        }

        collectionCreation = RETCOLLECT_LASTITEM;
    }
    else
    {
        collectionCreation = RETCOLLECT_ALL;
    }

    // If we Invoke on the dynamic collection, only return 1 item
    hr = THR_NOTRACE(DispatchInvokeCollection(this,
                                              &super::InvokeEx,
                                              pCollectionCache,
                                              CMarkup::WINDOW_COLLECTION,
                                              dispidMember,
                                              IID_NULL,
                                              lcid,
                                              wFlags,
                                              pdispparams,
                                              pvarResult,
                                              pexcepinfo,
                                              NULL,
                                              pSrvProvider,
                                              collectionCreation ));
    if (!hr) // if successfull, nothing more to do.
        goto Cleanup;

    if ( dispidMember >= DISPID_OMWINDOWMETHODS)
    {
        pScriptCollection = _pMarkup->GetScriptCollection();

        if (pScriptCollection)
        {
            hr = THR(_pMarkup->EnsureScriptContext(&pMarkupScriptContext));
            if (hr)
                goto Cleanup;

            hr = THR(pScriptCollection->InvokeEx(
                pMarkupScriptContext, dispidMember, lcid, wFlags, pdispparams,
                pvarResult, pexcepinfo, pSrvProvider));
        }
        else
        {   // Handle this on retail builds - don't crash:
            hr = DISP_E_MEMBERNOTFOUND;
        }
    }

    // Finally try the external object iff we're in a dialog.  Reason for
    // this is compat with existing pages from beta1/2 which are already
    // using old syntax.

    if (hr && pDoc->_fInHTMLDlg)
    {
        if (OK(get_external(&pDisp)) &&
            OK(pDisp->QueryInterface(IID_IDispatchEx, (void **)&pDispEx)))
        {
            hr = THR_NOTRACE(pDispEx->InvokeEx(
                    dispidMember,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    pSrvProvider));
        }
    }

Cleanup:
    ReleaseInterface(pDisp);
    ReleaseInterface(pDispEx);
    RRETURN_NOTRACE(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::GetDispid
//
//  Synopsis:   Per IDispatchEx.  This is called by script engines to lookup
//              dispids of expando properties and of named elements such as
//              <FRAME NAME="AFrameName">
//
//--------------------------------------------------------------------------

STDMETHODIMP
CWindow::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT                 hr = DISP_E_UNKNOWNNAME;
    IDispatchEx *           pDispEx = NULL;
    IDispatch *             pDisp = NULL;
    CMarkup *               pMarkup;
    BOOL                    fNoDynamicProperties = !!(grfdex & fdexNameNoDynamicProperties);
    CScriptCollection *     pScriptCollection;
    CMarkupScriptContext *  pMarkupScriptContext;

    // don't bother doing anything if we don't have a markup since we will crash shortly
    if (!_pMarkup)
        goto Cleanup;

    pMarkup = _pMarkup;
    pScriptCollection = pMarkup->GetScriptCollection();

    if (pScriptCollection && pScriptCollection->_fInEnginesGetDispID)
        goto Cleanup;

    // Quick event hookup for VBS.
    if (fNoDynamicProperties)
    {
        // Yes, if the name is window then let the script engine resolve everything
        // else better be a real object (frame, or all collection).
        STRINGCOMPAREFN pfnCompareString = (grfdex & fdexNameCaseSensitive)
                                                   ? StrCmpC : StrCmpIC;

        // If "window" or "document" is found then we'll turn fNoDynamicProperties off so that
        // the script engine is searched for "window" which is the global object
        // for the script engine.
        fNoDynamicProperties = !(pfnCompareString(s_propdescCWindowwindow.a.pstrName, bstrName)   == 0 ||
                                 pfnCompareString(s_propdescCWindowdocument.a.pstrName, bstrName) == 0);
    }

    // Does the script engine want names of object only (window, element ID).
    // If so then no functions or names in the script engine and no expandos.
    // This is for quick event hookup in VBS.
    if (!fNoDynamicProperties)
    {
        //
        // Try script collection namespace first.
        //

        if (pScriptCollection)
        {
            hr = THR(pMarkup->EnsureScriptContext(&pMarkupScriptContext));
            if (hr)
                goto Cleanup;

            hr = THR_NOTRACE(pScriptCollection->GetDispID(pMarkupScriptContext, bstrName, grfdex, pid));
            if (S_OK == hr)
                goto Cleanup;   // done;
        }

        // Next, try the external object iff we're in a dialog.  Reason for
        // this is compat with existing pages from beta1/2 which are already
        // using old syntax.

        if (hr && Doc()->_fInHTMLDlg)
        {
            if (OK(get_external(&pDisp)) &&
                OK(pDisp->QueryInterface(IID_IDispatchEx, (void **)&pDispEx)))
            {
                hr = THR_NOTRACE(pDispEx->GetDispID(bstrName, grfdex, pid));
            }
        }

        // Try property and expandos on the object.
        if (hr)
        {
            // Pass the special name on to CBase::GINEx.
            hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));
        }

        // Next try named frames in the FRAMES_COLLECTION
        if (hr)
        {
            hr = THR(pMarkup->EnsureCollectionCache(CMarkup::FRAMES_COLLECTION));
            if (hr)
                goto Cleanup;

            hr = THR_NOTRACE(pMarkup->CollectionCache()->GetDispID(CMarkup::FRAMES_COLLECTION,
                                                                 bstrName,
                                                                 grfdex,
                                                                 pid));

            // The collectionCache GetDispid will return S_OK w/ DISPID_UNKNOWN
            // if the name isn't found, catastrophic errors are of course returned.
            if (!hr && *pid == DISPID_UNKNOWN)
            {
                hr = DISP_E_UNKNOWNNAME;
            }
        }
    }

    // Next try WINDOW collection name space.
    if (hr)
    {
        CCollectionCache   *pCollectionCache;

        hr = THR(pMarkup->EnsureCollectionCache(CMarkup::WINDOW_COLLECTION));
        if (hr)
            goto Cleanup;

        pCollectionCache = pMarkup->CollectionCache();

        hr = THR_NOTRACE(pCollectionCache->GetDispID(CMarkup::WINDOW_COLLECTION,
                                                     bstrName,
                                                     grfdex,
                                                     pid));
        // The collectionCache GetDispid will return S_OK w/ DISPID_UNKNOWN
        // if the name isn't found, catastrophic errors are of course returned.
        if (!hr && *pid == DISPID_UNKNOWN)
        {
            hr = DISP_E_UNKNOWNNAME;
        }
        else if (fNoDynamicProperties && pCollectionCache->IsNamedCollectionMember(CMarkup::WINDOW_COLLECTION, *pid))
        {
            DISPID dBase;
            DISPID dMax;

            if (grfdex & fdexNameCaseSensitive)
            {
                *pid -= pCollectionCache->GetSensitiveNamedMemberMin(CMarkup::WINDOW_COLLECTION);
                dBase = DISPID_EVENTHOOK_SENSITIVE_BASE;
                dMax =  DISPID_EVENTHOOK_SENSITIVE_MAX;
            }
            else
            {
                *pid -= pCollectionCache->GetNotSensitiveNamedMemberMin(CMarkup::WINDOW_COLLECTION);
                dBase = DISPID_EVENTHOOK_INSENSITIVE_BASE;
                dMax =  DISPID_EVENTHOOK_INSENSITIVE_MAX;
            }

            *pid += dBase;
            if (*pid > dMax)
            {
                hr = DISP_E_UNKNOWNNAME;
                *pid = DISPID_UNKNOWN;
            }
        }
    }

Cleanup:

    ReleaseInterface(pDisp);
    ReleaseInterface(pDispEx);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::DeleteMember, IDispatchEx
//
//--------------------------------------------------------------------------


STDMETHODIMP
CWindow::DeleteMemberByName(BSTR bstr,DWORD grfdex)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CWindow::DeleteMemberByDispID(DISPID id)
{
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::GetMemberProperties, IDispatchEx
//
//--------------------------------------------------------------------------

STDMETHODIMP
CWindow::GetMemberProperties(
                DISPID id,
                DWORD grfdexFetch,
                DWORD *pgrfdex)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CWindow::GetNextDispID(DWORD grfdex,
                          DISPID id,
                          DISPID *prgid)
{
    HRESULT     hr;
    CMarkup *   pMarkup = _pMarkup;

    hr = THR(pMarkup->EnsureCollectionCache(CMarkup::FRAMES_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = DispatchGetNextDispIDCollection(this,
                                         &super::GetNextDispID,
                                         pMarkup->CollectionCache(),
                                         CMarkup::FRAMES_COLLECTION,
                                         grfdex,
                                         id,
                                         prgid);

Cleanup:
    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
CWindow::GetMemberName(DISPID id,
                          BSTR *pbstrName)
{
    HRESULT     hr;
    CMarkup *   pMarkup = _pMarkup;

    hr = THR(pMarkup->EnsureCollectionCache(CMarkup::FRAMES_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = DispatchGetMemberNameCollection(this,
                                         super::GetMemberName,
                                         pMarkup->CollectionCache(),
                                         CMarkup::FRAMES_COLLECTION,
                                         id,
                                         pbstrName);

Cleanup:
    RRETURN(hr);
}

STDMETHODIMP
CWindow::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT     hr;

    if (!ppunk)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppunk = NULL;

    hr = S_OK;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::get_frameElement
//
//--------------------------------------------------------------------------

STDMETHODIMP
CWindow::get_frameElement(IHTMLFrameBase** p)
{
    HRESULT hr;
    CFrameSite * pFrameSite;

    if (!p)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    *p = NULL;
    hr = S_OK;
    if (!_pMarkup)
        goto Cleanup;

    pFrameSite = GetFrameSite();

    if (pFrameSite)
        hr = pFrameSite->QueryInterface(IID_IHTMLFrameBase, (void **) p);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::get_document
//
//  Synopsis:   Per IOmWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CWindow::get_document(IHTMLDocument2 **p)
{
    TraceTag((tagOmWindow, "get_Document"));

    HRESULT hr = S_OK;
    IDispatch * pDispatch = NULL;

    *p = NULL;

    if (_punkViewLinkedWebOC)
    {
        hr = GetWebOCDocument(_punkViewLinkedWebOC, &pDispatch);
        if (hr)
            goto Cleanup;

        hr = pDispatch->QueryInterface(IID_IHTMLDocument2, (void **) p);
    }
    else
    {
        if (!Document())
        {
            AssertSz(0,"Possible Async Problem Causing Watson Crashes");
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = Document()->QueryInterface(IID_IHTMLDocument2, (void **) p);
    }

Cleanup:
    ReleaseInterface(pDispatch);

    RRETURN(SetErrorInfo(hr));
}

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::get_frames
//
//  Synopsis:   Per IOmWindow
//
//--------------------------------------------------------------------------

STDMETHODIMP
CWindow::get_frames(IHTMLFramesCollection2 ** ppOmWindow)
{
    HRESULT hr = E_INVALIDARG;

    if (!ppOmWindow)
        goto Cleanup;

    hr = THR_NOTRACE(QueryInterface(IID_IHTMLWindow2, (void**) ppOmWindow));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------------
//
//  Member:     item
//
//  Synopsis:   object model implementation
//
//              we handle the following parameter cases:
//                  0 params:               returns IDispatch of this
//                  1 param as number N:    returns IDispatch of om window of
//                                          frame # N, or fails if doc is not with
//                                          frameset
//                  1 param as string "foo" returns the om window of the frame
//                                          element that has NAME="foo"
//
//-----------------------------------------------------------------------------------

STDMETHODIMP
CWindow::item(VARIANTARG *pvarArg1, VARIANTARG * pvarRes)
{
    Assert(Document());

    if (!Document())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        RRETURN(E_FAIL);
    }
    
    RRETURN(SetErrorInfo(Document()->item(pvarArg1, pvarRes)));
}


HRESULT
CDocument::item(VARIANTARG *pvarArg1, VARIANTARG * pvarRes)
{
    HRESULT             hr = S_OK;
    IHTMLWindow2 *      pCWindow;
    CMarkup *           pMarkup = Markup();

    Assert(pMarkup);

    if (!pvarRes)
        RRETURN (E_POINTER);

    // Perform indirection if it is appropriate:
    if( V_VT(pvarArg1) == (VT_BYREF | VT_VARIANT) )
        pvarArg1 = V_VARIANTREF(pvarArg1);

    VariantInit (pvarRes);

    if (VT_EMPTY == V_VT(pvarArg1))
    {
        // this is one of the following cases if the call is from a script engine:
        //      window
        //      window.value
        //      window.frames
        //      window.frames.value

        V_VT(pvarRes) = VT_DISPATCH;
        hr = THR(QueryInterface(IID_IHTMLWindow2, (void**)&V_DISPATCH(pvarRes)));
    }
    else if( VT_BSTR == V_VT(pvarArg1) )
    {
        CElement *pElem;

        hr = THR(pMarkup->EnsureCollectionCache(CMarkup::WINDOW_COLLECTION));
        if (hr)
            goto Cleanup;

        hr = pMarkup->CollectionCache()->GetIntoAry( CMarkup::WINDOW_COLLECTION,
                                    V_BSTR(pvarArg1), FALSE, &pElem );
        if (hr || (pElem->Tag() != ETAG_FRAME && pElem->Tag() != ETAG_IFRAME))
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        CFrameSite *pFrameSite = DYNCAST (CFrameSite, pElem);
        hr = pFrameSite->GetCWindow(&pCWindow);
        if (hr)
            goto Cleanup;

        V_VT(pvarRes) = VT_DISPATCH;
        V_DISPATCH(pvarRes) = pCWindow;
    }
    else
    {
        // this is one of the following cases if the call is from a script engine:
        //      window(<index>)
        //      window.frames(<index>)

        hr = THR(VariantChangeTypeSpecial(pvarArg1, pvarArg1, VT_I4));
        if (hr)
            goto Cleanup;

        hr = THR(pMarkup->GetCWindow(V_I4(pvarArg1), &pCWindow));
        if (hr)
            goto Cleanup;

        V_VT(pvarRes) = VT_DISPATCH;
        V_DISPATCH(pvarRes) = pCWindow;
    }

Cleanup:
    // don't release pOmWindow as it is copied to pvarRes without AddRef-ing
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     Get_newEnum
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

STDMETHODIMP
CWindow::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = E_NOTIMPL;

    RRETURN(SetErrorInfo( hr));
}

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::get_event
//
//  Synopsis:   Per IOmWindow. but if we are not in an event handler (there is
//              nothing on the "EVENTPARAM" stack) then just return NULL.
//
//--------------------------------------------------------------------------

STDMETHODIMP
CWindow::get_event(IHTMLEventObj ** ppEventObj)
{
    HRESULT hr = S_OK;
    CDoc * pDoc;
    EVENTPARAM * pparam;

    if (!ppEventObj)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEventObj = NULL;
    // are we in an event?

    pDoc = Doc();
    pparam = pDoc->_pparam;

    if (pparam)
    {
        Assert(_pMarkup && _pMarkup == _pMarkup->GetWindowedMarkupContext());
        CMarkup *pMarkup = Markup();

        if (pparam->_pMarkup)
        {
            pMarkup = pparam->_pMarkup->GetWindowedMarkupContext();
        }
        else if (pparam->_pElement && pparam->_pElement->IsInMarkup())
        {
            pMarkup = pparam->_pElement->GetWindowedMarkupContext();
        }

        if (pMarkup != _pMarkup)
            goto Cleanup;

        hr = THR(CEventObj::Create(ppEventObj, Doc(), NULL, pMarkup));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     CWindow::setTimeout
//
//  Synopsis:  Runs <Code> after <msec> milliseconds and returns a bstr <TimeoutID>
//      in case ClearTimeout is called.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWindow::setTimeout(
    BSTR strCode,
    LONG lMSec,
    VARIANT *language,
    LONG * pTimerID)
{
    VARIANT v;

    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = strCode;

    RRETURN(SetErrorInfo(SetTimeout(&v, lMSec, FALSE, language, pTimerID)));
}


//+---------------------------------------------------------------------------
//
//  Member:     CWindow::setTimeout (can accept IDispatch *)
//
//  Synopsis:  Runs <Code> after <msec> milliseconds and returns a bstr <TimeoutID>
//      in case ClearTimeout is called.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWindow::setTimeout(
    VARIANT *pCode,
    LONG lMSec,
    VARIANT *language,
    LONG * pTimerID)
{
    RRETURN(SetErrorInfo(SetTimeout(pCode, lMSec, FALSE, language, pTimerID)));
}


//+---------------------------------------------------------------------------
//
//  Member:     CWindow::clearTimeout
//
//  Synopsis:
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWindow::clearTimeout(LONG timerID)
{
    RRETURN(SetErrorInfo(ClearTimeout(timerID)));
}


//+---------------------------------------------------------------------------
//
//  Member:     CWindow::setInterval
//
//  Synopsis:  Runs <Code> every <msec> milliseconds
//             Note: Nav 4 behavior of msec=0 is like setTimeout msec=0
//
//----------------------------------------------------------------------------

HRESULT
CWindow::setInterval(
    BSTR strCode,
    LONG lMSec,
    VARIANT *language,
    LONG * pTimerID)
{
    VARIANT v;

    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = strCode;

    RRETURN(SetErrorInfo(SetTimeout(&v, lMSec, TRUE, language, pTimerID)));
}


//+---------------------------------------------------------------------------
//
//  Member:     CWindow::setInterval (can accept IDispatch *)
//
//  Synopsis:  Runs <Code> after <msec> milliseconds and returns a bstr <TimeoutID>
//      in case ClearTimeout is called.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWindow::setInterval(
    VARIANT *pCode,
    LONG lMSec,
    VARIANT *language,
    LONG * pTimerID)
{
    RRETURN(SetErrorInfo(SetTimeout(pCode, lMSec, TRUE, language, pTimerID)));
}


//+---------------------------------------------------------------------------
//
//  Member:     CWindow::clearInterval
//
//  Synopsis:   deletes the period timer set by setInterval
//
//----------------------------------------------------------------------------

HRESULT
CWindow::clearInterval(LONG timerID)
{
    RRETURN(SetErrorInfo(ClearTimeout(timerID)));
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::get_screen
//
//--------------------------------------------------------------------------

HRESULT
CWindow::get_screen(IHTMLScreen**p)
{
    HRESULT     hr;

    hr = THR(_Screen.QueryInterface(
            IID_IHTMLScreen,
            (void **)p));
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     CWindow::showModelessDialog
//
//  Synopsis - helper function for the modal/modeless dialogs
//
//----------------------------------------------------------------------------
HRESULT
CWindow::ShowHTMLDialogHelper( HTMLDLGINFO * pdlgInfo )
{
    HRESULT hr = S_OK;
    TCHAR   achBuf[pdlUrlLen];
    DWORD   cchBuf;
    BOOL    fBlockArguments;
    BOOL    fWrappedUrl = FALSE;
    BSTR    bstrTempUrl = NULL;
    CStr    cstrSpecialURL;

    DWORD      dwTrustMe = ((_pMarkup->IsMarkupTrusted()) ||
                            GetCallerHTMLDlgTrust(this)) ? 0 : HTMLDLG_DONTTRUST;

    TCHAR *    pchUrl = (TCHAR *) CMarkup::GetUrl(_pMarkup);

    Assert(pdlgInfo);

    // Remember if this is a trusted dialog
    pdlgInfo->dwFlags |= dwTrustMe;

    //
    // is this a valid call to make at this time?
    if (!(Doc() && Doc()->_pInPlace))
    {
        hr = E_PENDING;
        goto Cleanup;
    }

    //
    // First do some in-parameter checking
    if (pdlgInfo->pvarOptions &&
        VT_ERROR == V_VT(pdlgInfo->pvarOptions) &&
        DISP_E_PARAMNOTFOUND == V_ERROR(pdlgInfo->pvarOptions))
    {
        pdlgInfo->pvarOptions = NULL;
    }

    //
    // Can't load a blank page, or none bstr VarOptions
    if (!pdlgInfo->bstrUrl || !*pdlgInfo->bstrUrl)
    {
        if (pdlgInfo->fModeless)
        {
            // use about:blank for the name and continue
            bstrTempUrl = SysAllocString(_T("about:blank"));
        }
        else
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }
    else if (IsSpecialUrl(pdlgInfo->bstrUrl))
    {
        if (WrapSpecialUrl(pdlgInfo->bstrUrl, &cstrSpecialURL, pchUrl, FALSE, FALSE) != S_OK)
            goto Cleanup;

        hr = cstrSpecialURL.AllocBSTR(&bstrTempUrl);
        if (hr)
            goto Cleanup;

        fWrappedUrl = TRUE;
    }

    if (pdlgInfo->pvarOptions &&
        VT_ERROR != V_VT(pdlgInfo->pvarOptions) &&
        VT_BSTR != V_VT(pdlgInfo->pvarOptions))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // dereference if needed
    if (pdlgInfo->pvarOptions && V_VT(pdlgInfo->pvarOptions) == (VT_BYREF | VT_VARIANT))
        pdlgInfo->pvarOptions = V_VARIANTREF(pdlgInfo->pvarOptions);

    if (pdlgInfo->pvarArgIn && V_VT(pdlgInfo->pvarArgIn)== (VT_BYREF | VT_VARIANT))
        pdlgInfo->pvarArgIn = V_VARIANTREF(pdlgInfo->pvarArgIn);

    //
    // Create a moniker from the combined url handed in and our own url
    // (to resolve relative paths).
    hr = CoInternetCombineUrl(pchUrl,
                              bstrTempUrl ? bstrTempUrl : pdlgInfo->bstrUrl,
                              URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE,
                              achBuf,
                              ARRAY_SIZE(achBuf),
                              &cchBuf,
                              0);
    if (hr)
        goto Cleanup;


    // SECURITY ALERT - now that we have a combined url we can do some security
    // work.  see bug ie11361 - the retval args and the ArgsIn can contain
    // scriptable objects.  Because they pass through directly from one doc to
    // another it is possible to send something across domains and thus avoid the
    // security tests.  To stop this what we do is check for accessAllowed between
    // this parent doc, and the dialog url.  If access is allowed, we continue on
    // without pause.  If, however, it is cross domain then we still allow the dialog
    // to come up, but we block the passing of arguments back and forth.

    // we don't need to protect HTA, about:blank, or res: url
    fBlockArguments = (_pMarkup->IsMarkupTrusted() || Doc()->_fInTrustedHTMLDlg) ? FALSE : ( !_pMarkup->AccessAllowed(achBuf) );

    //
    // Create a moniker from the combined url handed in and our own url
    // (to resolve relative paths).
    if (fWrappedUrl)
    {
        hr = CoInternetCombineUrl(pchUrl,
                                  pdlgInfo->bstrUrl,
                                  URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE,
                                  achBuf,
                                  ARRAY_SIZE(achBuf),
                                  &cchBuf,
                                  0);
        if (hr)
            goto Cleanup;
    }

    hr = THR(CreateURLMoniker(NULL, achBuf, &(pdlgInfo->pmk)));
    if (hr)
        goto Cleanup;

    // Do a local machine check.
    if (!COmWindowProxy::CanNavigateToUrlWithLocalMachineCheck(_pMarkup, NULL, achBuf))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    // Prepare remaining parameters for dialog creation
    pdlgInfo->hwndParent = Doc()->_pInPlace->_hwnd;

    pdlgInfo->pMarkup = _pMarkup;

    //
    // bring up the dialog
    //--------------------------------------------------------------------
    if (pdlgInfo->fModeless)
    {
        if (fBlockArguments)
            pdlgInfo->pvarArgIn = NULL;

        hr = THR(InternalModelessDialog(pdlgInfo));
    }
    else
    {
        CDoEnableModeless   dem(Doc(), this);

        if (dem._hwnd)
        {
            if (fBlockArguments)
            {
                pdlgInfo->pvarArgIn = NULL;
                pdlgInfo->pvarArgOut = NULL;
            }

            hr = THR(InternalShowModalDialog(pdlgInfo));
        }
    }

    if (hr)
        goto Cleanup;

Cleanup:
    SysFreeString(bstrTempUrl);
    ReleaseInterface(pdlgInfo->pmk);
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member:     CWindow::showModelessDialog
//
//  Synopsis:   Interface method to bring up a modeless HTMLdialog given a url
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWindow::showModelessDialog(/* in */ BSTR      bstrUrl,
                               /* in */ VARIANT * pvarArgIn,
                               /* in */ VARIANT * pvarOptions,
                               /* ret */IHTMLWindow2** ppDialog)
{
    HTMLDLGINFO dlginfo;

    dlginfo.bstrUrl = bstrUrl;
    dlginfo.pvarArgIn = pvarArgIn;
    dlginfo.pvarOptions = pvarOptions;
    dlginfo.fModeless = TRUE;
    dlginfo.ppDialog = ppDialog;
    dlginfo.pMarkup = _pMarkup;

    RRETURN(SetErrorInfo(ShowHTMLDialogHelper( &dlginfo )));
}


//+---------------------------------------------------------------------------
//
//  Member:     CWindow::showModalDialog
//
//  Synopsis:   Interface method to bring up a HTMLdialog given a url
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWindow::showModalDialog(BSTR       bstrUrl,
                            VARIANT *  pvarArgIn,
                            VARIANT *  pvarOptions,
                            VARIANT *  pvarArgOut)
{
    HTMLDLGINFO dlginfo;

    dlginfo.bstrUrl = bstrUrl;
    dlginfo.pvarArgIn = pvarArgIn;
    dlginfo.pvarOptions = pvarOptions;
    dlginfo.pvarArgOut = pvarArgOut;
    dlginfo.fModeless = FALSE;
    dlginfo.pMarkup = _pMarkup;

    RRETURN(SetErrorInfo(ShowHTMLDialogHelper( &dlginfo )));
}

//---------------------------------------------------------------------------
//
//  Member:     CWindow::createPopup
//
//  Synopsis:   load about:blank for now
//
//---------------------------------------------------------------------------

HRESULT
CWindow::createPopup(VARIANT *pVarInArg, IDispatch** ppPopup)
{
    HRESULT hr = E_INVALIDARG;
    IHTMLPopup      *pIPopup    = NULL;
    CHTMLPopup      *pPopup     = NULL;

    if (    V_VT(pVarInArg) == VT_EMPTY
        ||  V_VT(pVarInArg) == VT_ERROR
        ||  V_VT(pVarInArg) == VT_NULL
        ||  (   V_VT(pVarInArg) == VT_BSTR
            &&  (   V_BSTR(pVarInArg) == NULL
                ||  V_BSTR(pVarInArg)[0] == 0)
            )
        )
    {
        hr = CoCreateInstance(CLSID_HTMLPopup,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IHTMLPopup,
                                  (void **) &pIPopup);

        if (FAILED(hr))
            return hr;

        hr = pIPopup->QueryInterface(CLSID_HTMLPopup, (void **)&pPopup);
        if (FAILED(hr))
            return hr;

        pPopup->_pWindowParent = this;
        AddRef();

        hr = THR(pPopup->CreatePopupDoc());
        if (hr)
            goto Cleanup;

        hr = pIPopup->QueryInterface(IID_IDispatch, (void **)ppPopup);
        pIPopup->Release();

        // We don't want to show tooltips on the document when popups are around, so kill
        // any that might be there.
        // (See TODO in CElement::ShowTooltipInternal for why we don't show the tooltips)

        FormsHideTooltip();
    }

Cleanup:
    RRETURN( hr );
}

//---------------------------------------------------------------------------
//
//  Member:     CWindow::GetMultiTypeInfoCount
//
//  Synopsis:   per IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------

STDMETHODIMP
CWindow::GetMultiTypeInfoCount(ULONG *pc)
{
    TraceTag((tagOmWindow, "GetMultiTypeInfoCount"));

    *pc = (_pMarkup->IsPrimaryMarkup() && _pMarkup->LoadStatus() >= LOADSTATUS_QUICK_DONE) ? 2 : 1;
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member:     CWindow::GetInfoOfIndex
//
//  Synopsis:   per IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------

STDMETHODIMP
CWindow::GetInfoOfIndex(
    ULONG       iTI,
    DWORD       dwFlags,
    ITypeInfo** ppTICoClass,
    DWORD*      pdwTIFlags,
    ULONG*      pcdispidReserved,
    IID*        piidPrimary,
    IID*        piidSource)
{
    TraceTag((tagOmWindow, "GetInfoOfIndex"));

    HRESULT hr      = S_OK;
    CDoc *  pDoc    = Doc();

    if (_pMarkup->IsPrimaryMarkup())
    {
        //
        // First try the main typeinfo
        //

        if (1 == iTI &&
            _pMarkup->LoadStatus() >= LOADSTATUS_QUICK_DONE &&
            dwFlags & MULTICLASSINFO_GETTYPEINFO)
        {
            //
            // Caller wanted info on the dynamic part of the window.
            //

            hr = THR(pDoc->EnsureObjectTypeInfo());
            if (hr)
                goto Cleanup;

            *ppTICoClass = pDoc->_pTypInfoCoClass;
            (*ppTICoClass)->AddRef();

            //
            // Clear out these values so that we can use the base impl.
            //

            dwFlags &= ~MULTICLASSINFO_GETTYPEINFO;
            iTI = 0;
            ppTICoClass = NULL;
        }
    }
    hr = THR(super::GetInfoOfIndex(
        iTI,
        dwFlags,
        ppTICoClass,
        pdwTIFlags,
        pcdispidReserved,
        piidPrimary,
        piidSource));

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CWindow::Fire_onscroll
//
//  Synopsis:   Fires the onscroll events of the window
//
//--------------------------------------------------------------------------
void CWindow::Fire_onscroll()
{
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONSCROLL, 0, _T("scroll"));
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::Fire_onload, Fire_onunload, Fire_onbeforeunload
//
//  Synopsis:   Fires the onload/onunload events of the window
//
//--------------------------------------------------------------------------

void CWindow::Fire_onload()
{
    // note that property should not fire from here; this firing is
    // only for non-function-pointers-style firing
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONLOAD, 0, _T("load"));
}

void CWindow::Fire_onunload()
{
    // note that property should not fire from here; this firing is
    // only for non-function-pointers-style firing
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONUNLOAD, 0, _T("unload"));
}

BOOL CWindow::Fire_onbeforeunload()
{
    // note that property should not fire from here; this firing is
    // only for non-function-pointers-style firing
    BOOL fRet = TRUE;
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONBEFOREUNLOAD, 0, _T("beforeunload"), &fRet);
    return fRet;
}

BOOL
CWindow::Fire_onhelp()
{
    BOOL fRet = TRUE;
    // note that property should not fire from here; this firing is
    // only for non-function-pointers-style firing
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONHELP, 0, _T("help"), &fRet);
    return fRet;
}

void
CWindow::Fire_onresize()
{
    // note that property should not fire from here; this firing is
    // only for non-function-pointers-style firing
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONRESIZE, 0, _T("resize"));

    // If we are running a page transition, we need to stop it
    CDocument *pDocument = Document();
    if(pDocument && pDocument->HasPageTransitions())
    {
        pDocument->PostCleanupPageTansitions();
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CWindow::Fire_onfocus, Fire_onblur
//
//  Synopsis:   Fires the onfocus/onblur events of the window
//
//--------------------------------------------------------------------------

void CWindow::Fire_onfocus()
{
    // note that property should not fire from here; this firing is
    // only for non-function-pointers-style firing
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONFOCUS, 0, _T("focus"));
}

void CWindow::Fire_onblur()
{
    // note that property should not fire from here; this firing is
    // only for non-function-pointers-style firing
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONBLUR, 0, _T("blur"));
}

void CWindow::Fire_onbeforeprint()
{
    // note that property should not fire from here; this firing is
    // only for non-function-pointers-style firing
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONBEFOREPRINT, 0, _T("beforeprint"));
}

void CWindow::Fire_onafterprint()
{
    // note that property should not fire from here; this firing is
    // only for non-function-pointers-style firing
    FireEvent(Doc(), NULL, Markup(), DISPID_EVMETH_ONAFTERPRINT, 0, _T("afterprint"));
}

//+----------------------------------------------------------------------------------
//
//  Member:     alert
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

STDMETHODIMP
CWindow::alert(BSTR message)
{
    BOOL fRightToLeft;

    if (!Document())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        RRETURN(E_FAIL);
    }
    
    THR(Document()->GetDocDirection(&fRightToLeft));

    if (g_pHtmPerfCtl && (g_pHtmPerfCtl->dwFlags & HTMPF_DISABLE_ALERTS))
        RRETURN(S_OK);
    else
        RRETURN(SetErrorInfo(
            THR(Doc()->ShowMessageEx(
                NULL,
                fRightToLeft ? MB_OK | MB_ICONEXCLAMATION | MB_RTLREADING | MB_RIGHT : MB_OK | MB_ICONEXCLAMATION,
                NULL,
                0,
                (TCHAR*)STRVAL(message)))));
}

//+----------------------------------------------------------------------------------
//
//  Member:     confirm
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

STDMETHODIMP
CWindow::confirm(BSTR message, VARIANT_BOOL *pConfirmed)
{
    HRESULT     hr;
    int         nRes;

    if (!pConfirmed)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pConfirmed = VB_FALSE;

    if (g_pHtmPerfCtl && (g_pHtmPerfCtl->dwFlags & HTMPF_DISABLE_ALERTS))
    {
        hr = S_OK;
        nRes = IDOK;
    }
    else
    {
        hr = THR(Doc()->ShowMessageEx(
                &nRes,
                MB_OKCANCEL | MB_ICONQUESTION,
                NULL,
                0,
                (TCHAR*)STRVAL(message)));
        if (hr)
            goto Cleanup;
    }

    *pConfirmed = (IDOK == nRes) ? VB_TRUE : VB_FALSE;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------------
//
//  Member:     get_length
//
//  Synopsis:   object model implementation
//
//              returns number of frames in frameset of document;
//              fails if the doc does not contain frameset
//
//-----------------------------------------------------------------------------------

STDMETHODIMP
CWindow::get_length(long * pcFrames)
{
    if (!Document())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        RRETURN(E_FAIL);
    }
        
    RRETURN (SetErrorInfo(Document()->get_length(pcFrames)));
}


HRESULT
CDocument::get_length(long * pcFrames)
{
    HRESULT hr;
    CMarkup *   pMarkup = Markup();

    Assert(pMarkup);

    if (!pcFrames)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *pcFrames = 0;

    hr = THR(pMarkup->EnsureCollectionCache(CMarkup::FRAMES_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(pMarkup->CollectionCache()->GetLength(CMarkup::FRAMES_COLLECTION, pcFrames));

Cleanup:
    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member: CWindow::showHelp
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWindow::showHelp(BSTR helpURL, VARIANT helpArg, BSTR features)
{
    HRESULT   hr = E_FAIL;
    VARIANT * pHelpArg;
    long      lHelpId = 0;
    TCHAR   * pchExt;
    CVariant  cvArg;
    TCHAR   cBuf[pdlUrlLen];
    TCHAR   * pchHelpFile = cBuf;
    BOOL    fPath;

    if (!helpURL)
        goto Cleanup;

    // we need a HelpId for WinHelp Files:
    // dereference if variable passed in
    pHelpArg = (V_VT(&helpArg) == (VT_BYREF | VT_VARIANT)) ?
            V_VARIANTREF(&helpArg) : &helpArg;

    // if the extention is .hlp it is WinHelp, otherwise assume html/text
    pchExt = _tcsrchr(helpURL, _T('.'));
    if (pchExt && !FormsStringICmp(pchExt, _T(".hlp")) && Doc()->_fInTrustedHTMLDlg)
    {
        UINT      uCommand = HELP_CONTEXT;
        if(V_VT(pHelpArg) == VT_BSTR)
        {
            hr = THR(ttol_with_error(V_BSTR(pHelpArg), &lHelpId));
            if (hr)
            {
                // TODO (carled) if it is not an ID it might be a bookmark
                //  or empty, or just text, extra processing necessary here.
                goto Cleanup;
            }
        }
        else
        {
            // make sure the second argument is a I4
            hr = cvArg.CoerceVariantArg(pHelpArg, VT_I4);
            if(FAILED(hr))
                goto Cleanup;

            if(hr == S_OK)
            {
                lHelpId = V_I4(&cvArg);
            }
        }

        //  If features == "popup", we need to open the
        //  hwlp window as a popup.
        if (features && !FormsStringICmp(features, _T("popup")))
        {
            uCommand = HELP_CONTEXTPOPUP;
        }

        // if the path is absent try to use the ML stuff
        fPath =  (_tcsrchr(helpURL, _T('\\')) != NULL) || (_tcsrchr(helpURL, _T('/')) != NULL);

        if(!fPath)
        {
            hr =  THR(MLWinHelp(TLS(gwnd.hwndGlobalWindow),
                           helpURL,
                           uCommand,
                           lHelpId)) ? S_OK : E_FAIL;
        }
        // If the call failed try again without using theML stuff. It could be that the
        // help file was not found in the language directory, but it sits somewhere under
        // the path.
        if(fPath || hr == E_FAIL)
        {
            hr =  THR(WinHelp(TLS(gwnd.hwndGlobalWindow),
                           helpURL,
                           uCommand,
                           lHelpId)) ? S_OK : E_FAIL;
        }

    }
    else
    {
        // HTML help case
        HWND hwndCaller;
        TCHAR achFile[pdlUrlLen];
        ULONG cchFile = ARRAY_SIZE(achFile);

        Doc()->GetWindowForBinding(&hwndCaller);

        hr = CMarkup::ExpandUrl(_pMarkup, helpURL, ARRAY_SIZE(cBuf), pchHelpFile, NULL);
        if (hr || !*pchHelpFile)
            goto Cleanup;

        if (GetUrlScheme(pchHelpFile) == URL_SCHEME_FILE)
        {
            hr = THR(PathCreateFromUrl(pchHelpFile, achFile, &cchFile, 0));
            if (hr)
                goto Cleanup;

            pchHelpFile = achFile;
        }

        // Show the help file
        hr = THR(CallHtmlHelp(hwndCaller, pchHelpFile, HH_DISPLAY_TOPIC, 0));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}



//+---------------------------------------------------------------------------
//
//  Member: CWindow::CallHtmlHelp
//
//  Wrapper that dynamically loads, translates to ASCII and calls HtmlHelpA
//----------------------------------------------------------------------------

HRESULT
CWindow::CallHtmlHelp(HWND hwnd, BSTR pszFile, UINT uCommand, DWORD_PTR dwData, HWND *pRetVal /*=NULL*/)
{
    HRESULT     hr = S_OK;
    HWND        hwndRet = NULL;
    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);
    hwndRet = MLHtmlHelp(hwnd, pszFile, uCommand, dwData, ML_CROSSCODEPAGE);
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }

    if(pRetVal)
        *pRetVal = hwndRet;

    RRETURN(SetErrorInfo( hr));
}



HRESULT
CWindow::toString(BSTR* String)
{
    RRETURN(super::toString(String));
};

#define TITLEBAR_FEATURE_NAME   _T("titlebar")

//+---------------------------------------------------------------------------
//
//  Member: CWindow::FilterOutFeaturesString
//
//  Removes the unsafe features from the features string
//----------------------------------------------------------------------------
HRESULT
CWindow::FilterOutFeaturesString(BSTR bstrFeatures, CStr *pcstrOut)
{
    HRESULT         hr = S_OK;
    LPCTSTR         pchFound;
    LPCTSTR         pchInPtr = bstrFeatures;
    CBufferedStr    strOut;

    Assert(pcstrOut);

    if(!bstrFeatures)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    do
    {
        pchFound = _tcsistr(pchInPtr, TITLEBAR_FEATURE_NAME);
        if(!pchFound)
        {
            Assert( pchInPtr[0] != 0 ) ; // prefix happiness. 
            strOut.QuickAppend(pchInPtr);
            break;
        }

        strOut.QuickAppend(pchInPtr, pchFound - pchInPtr);

        //Make sure we are on the left side of the =
        if(pchFound > pchInPtr && *(pchFound - 1) != _T(',') && !isspace(*(pchFound - 1)))
        {
            LPTSTR pchComma, pchEqual;
            pchComma =  _tcschr(pchFound + (ARRAY_SIZE(TITLEBAR_FEATURE_NAME) - 1), _T(','));
            pchEqual =  _tcschr(pchFound + (ARRAY_SIZE(TITLEBAR_FEATURE_NAME) - 1), _T('='));
            // If there is no = or there is an = and there is a comma and comma is earlier we ignore
            if(!pchEqual || (pchComma && pchComma < pchEqual))
            {
                // This was a wrong titlebar setting, keep it
                strOut.QuickAppend(pchFound, (ARRAY_SIZE(TITLEBAR_FEATURE_NAME) - 1));
                pchInPtr = pchFound + (ARRAY_SIZE(TITLEBAR_FEATURE_NAME) - 1);
                continue;
            }
        }

        pchInPtr = pchFound + (ARRAY_SIZE(TITLEBAR_FEATURE_NAME) - 1);

        pchFound = _tcschr(pchInPtr, _T(','));
        if(!pchFound)
            break;

        pchInPtr = pchFound + 1;

    } while (*pchInPtr != 0);

    hr = THR(pcstrOut->Set(strOut));

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function: PromptDlgProc()
//
//----------------------------------------------------------------------------

struct SPromptDlgParams      // Communicates info the to dlg box routines.
{
    CStr    strUserMessage;     // Message to display.
    CStr    strEditFieldValue;  // IN has initial value, OUT has return value.
};

INT_PTR CALLBACK PromptDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    SPromptDlgParams *pdp = NULL;

    switch (message)
    {
        case WM_INITDIALOG:
            Assert(lParam);
            SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);
            {
                pdp = (SPromptDlgParams*)lParam;
                SetDlgItemText(hDlg,IDC_PROMPT_PROMPT,pdp->strUserMessage);
                SetDlgItemText(hDlg,IDC_PROMPT_EDIT,pdp->strEditFieldValue);
                // Select the entire default string value:
                SendDlgItemMessage(hDlg,IDC_PROMPT_EDIT,EM_SETSEL, 0, -1 );
            }
            return (TRUE);

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    {
                        HRESULT hr;
                        int linelength;
                        pdp = (SPromptDlgParams*)GetWindowLongPtr(hDlg, GWLP_USERDATA);
                        Assert( pdp );
                        linelength = SendDlgItemMessage(hDlg,IDC_PROMPT_EDIT,EM_LINELENGTH,(WPARAM)0,(LPARAM)0);
                        // FYI: this routine allocates linelength+1 TCHARS, +1 for the NULL.
                        hr = pdp->strEditFieldValue.Set( NULL, linelength );
                        if( FAILED( hr ) )
                            goto ErrorDispatch;
                        GetDlgItemText(hDlg,IDC_PROMPT_EDIT,pdp->strEditFieldValue,linelength+1);
                    }
                    EndDialog(hDlg, TRUE);
                    break;
                case IDCANCEL:
                ErrorDispatch:;
                    EndDialog(hDlg, FALSE);
                    break;
            }
            return TRUE;

        case WM_CLOSE:
            EndDialog(hDlg, FALSE);
            return TRUE;

    }
    return FALSE;
}


STDMETHODIMP
CWindow::prompt(BSTR message, BSTR defstr, VARIANT *retval)
{
    HRESULT             hr = S_OK;
    int                 result = 0;
    SPromptDlgParams    pdparams;

    pdparams.strUserMessage.SetBSTR(message);
    pdparams.strEditFieldValue.SetBSTR(defstr);

    {
        CDoEnableModeless   dem(Doc(), this);

        if (dem._hwnd)
        {
            result = DialogBoxParam(GetResourceHInst(),             // handle to application instance
                                    MAKEINTRESOURCE(IDD_PROMPT_MSHTML),    // identifies dialog box template name
                                    dem._hwnd,
                                    PromptDlgProc,                  // pointer to dialog box procedure
                                    (LPARAM)&pdparams);
        }
    }

    if (retval)
    {
        if (!result)  // If the user hit cancel then allways return the empty string
        {
            // Nav compatability - return null
            V_VT(retval) = VT_NULL;
        }
        else
        {
            // Allocate the returned bstr:
            V_VT(retval) = VT_BSTR;
            hr = THR((pdparams.strEditFieldValue.AllocBSTR( &V_BSTR(retval) )));
        }
    }

    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------------------------------
//
//  Member:     focus
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

STDMETHODIMP
CWindow::focus()
{
    HRESULT hr          = S_OK;
    CDoc *  pDoc        = Doc();
    HWND    hwndParent  = NULL;
    HWND    hwnd;

    if (!pDoc->_pInPlace || !pDoc->_pInPlace->_hwnd)
        goto Cleanup;

    hwnd = pDoc->_pInPlace->_hwnd;

    while (hwnd)
    {
        hwndParent = hwnd;
        hwnd = GetParent(hwnd);
    }

    Assert(hwndParent);

    // restore window first if minimized.
    if (IsIconic(hwndParent))
        ShowWindow(hwndParent, SW_RESTORE);
    else
    {
        ::SetWindowPos(hwndParent, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);

        // SetWindowPos does not seem to bring the window to top of the z-order
        // when window.focus() is called if the browser app is not in the foreground,
        // unless the z-order was changed with the window.blur() method in a prior call.
        ::SetForegroundWindow(hwndParent);
    }

    hr = THR(_pMarkup->GetElementTop()->BecomeCurrentAndActive(0, NULL, NULL, TRUE));
    if (hr)
        goto Cleanup;

    // Fire the window onfocus event here if it wasn't previously fired in
    // BecomeCurrent() due to our inplace window not previously having the focus
    _pMarkup->Window()->Post_onfocus();

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------------
//
//  Member:     blur
//
//  Synopsis:   object model implementation
//
//
//-----------------------------------------------------------------------------------

STDMETHODIMP
CWindow::blur()
{
    HRESULT hr          = S_OK;
    CDoc *  pDoc        = Doc();
    HWND    hwndParent  = NULL;
    HWND    hwnd;
    BOOL    fOldInhibitFocusFiring;

    if (!pDoc->_pInPlace)
        goto Cleanup;

    hwnd = pDoc->_pInPlace->_hwnd;

    while(hwnd)
    {
        hwndParent = hwnd;
        hwnd = GetParent(hwnd);
    }

    Assert(hwndParent);
    ::SetWindowPos(hwndParent, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);

    hr = THR(_pMarkup->Root()->BecomeCurrent(0));
    if (hr)
        goto Cleanup;

    // remove focus from current frame window with the focus
    fOldInhibitFocusFiring = pDoc->_fInhibitFocusFiring;
    pDoc->_fInhibitFocusFiring = TRUE;
    ::SetFocus(NULL);
    pDoc->_fInhibitFocusFiring = fOldInhibitFocusFiring;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


void
COmWindowProxy::Post_onfocus()
{
    // if onblur was last fired then fire onfocus
    if (!_fFiredWindowFocus && Markup()->LoadStatus() >= LOADSTATUS_DONE)
    {
        // Enable window onblur firing next
        _fFiredWindowFocus = TRUE;
        GWPostMethodCall(this, ONCALL_METHOD(COmWindowProxy, Fire_onfocus, fire_onfocus), 0, TRUE, "COmWindowProxy::Fire_onfocus");
    }
}

void
COmWindowProxy::Post_onblur(BOOL fOnblurFiredFromWM)
{
    // if onfocus was last fired then fire onblur
    if (_fFiredWindowFocus && Markup()->LoadStatus() >= LOADSTATUS_DONE)
    {
        // Enable window onfocus firing next
        _fFiredWindowFocus = FALSE;
        GWPostMethodCall(this, ONCALL_METHOD(COmWindowProxy, Fire_onblur, fire_onblur), fOnblurFiredFromWM, TRUE, "COmWindowProxy::Fire_onblur");
    }
}

//=============================================================================
//=============================================================================
//
//          EVENTPARAM CLASS:
//
//=============================================================================
//=============================================================================

//---------------------------------------------------------------------------
//
//  Member:     EVENTPARAM::EVENTPARAM
//
//  Synopsis:   constructor
//
//  Parameters: pDoc            Doc to bind to
//              fInitState      If true, then initialize state type
//                              members.  (E.g. x, y, keystate, etc).
//
//---------------------------------------------------------------------------

EVENTPARAM::EVENTPARAM(CDoc * pNewDoc,
                       CElement * pElement,
                       CMarkup * pMarkup,
                       BOOL fInitState,
                       BOOL fPush, /* = TRUE */
                       const EVENTPARAM* pParam /* = NULL */)
{
    if (pParam)
    {
        Assert(pNewDoc == pParam->pDoc);
        memcpy(this, pParam, sizeof(*this));
        pEventObj = NULL;
        if (psrcFilter)
            psrcFilter->AddRef();
    }
    else
    {
        memset(this, 0, sizeof(*this));
        _lSubDivisionSrc = -1;
        _lSubDivisionFrom = -1;
        _lSubDivisionTo = -1;
    }

    if (!pNewDoc)
    {
        pDoc = NULL;
        return;
    }

    pDoc = pNewDoc;
    if (pDoc)
        pDoc->SubAddRef(); // balanced in destructor

    _pElement = pElement;
    if (pElement)
        pElement->SubAddRef();

    _pMarkup = pMarkup;
    if (pMarkup)
        pMarkup->SubAddRef();

    _fOnStack = FALSE;

    if (fPush)
        Push();

    if (!pParam)
        _lKeyCode = 0;

    if (fInitState && pDoc)
    {
        POINT pt;

        ::GetCursorPos(&pt);
        _screenX= pt.x;
        _screenY= pt.y;

        if (pDoc->_pInPlace)
        {
            ::ScreenToClient(pDoc->_pInPlace->_hwnd, &pt);
        }

        SetClientOrigin(pElement ? pElement : pDoc->_pElemCurrent, &pt);
        _sKeyState = VBShiftState();

        _fShiftLeft = !!(GetKeyState(VK_LSHIFT) & 0x8000);
        _fCtrlLeft = !!(GetKeyState(VK_LCONTROL) & 0x8000);
        _fAltLeft = !!(GetKeyState(VK_LMENU) & 0x8000);

        _pLayoutContext = GUL_USEFIRSTLAYOUT;
    }
}

//---------------------------------------------------------------------------
//
//  Member:     EVENTPARAM::~EVENTPARAM
//
//  Synopsis:   copy ctor
//
//---------------------------------------------------------------------------

EVENTPARAM::EVENTPARAM( const EVENTPARAM* pParam )
{
    memcpy( this, pParam, sizeof( *this ));

    _fOnStack = FALSE; // by default we are not on the stack unless we are explicitly put there.

    Assert(pDoc);
    pDoc->SubAddRef();

    if (_pElement)
        _pElement->SubAddRef();

    if (_pMarkup)
        _pMarkup->SubAddRef();

    if ( psrcFilter )
        psrcFilter->AddRef();
}

//---------------------------------------------------------------------------
//
//  Member:     EVENTPARAM::~EVENTPARAM
//
//  Synopsis:   destructor
//
//---------------------------------------------------------------------------

EVENTPARAM::~EVENTPARAM()
{
    if (_pElement)
        _pElement->SubRelease();

    if (_pMarkup)
        _pMarkup->SubRelease();

    if (!pDoc)
        return;

    Pop();

    ReleaseInterface( (IUnknown *)psrcFilter );

    if (pDoc)
        pDoc->SubRelease(); // to balance SubAddRef in constructor
}

//---------------------------------------------------------------------------
//
//  Member:     EVENTPARAM::Push
//
//---------------------------------------------------------------------------

void
EVENTPARAM::Push()
{
    if (!_fOnStack && pDoc)
    {
        _fOnStack = TRUE;
        pparamPrev = pDoc->_pparam;
        pDoc->_pparam = this;
    }
}

//---------------------------------------------------------------------------
//
//  Member:     EVENTPARAM::Pop
//
//---------------------------------------------------------------------------

void
EVENTPARAM::Pop()
{
    if (_fOnStack && pDoc)
    {
        _fOnStack = FALSE;
        pDoc->_pparam = pparamPrev;
    }
}

//---------------------------------------------------------------------------
//
//  Member:     EVENTPARAM::IsCancelled
//
//---------------------------------------------------------------------------

BOOL
EVENTPARAM::IsCancelled()
{
    HRESULT     hr;

    if (VT_EMPTY != V_VT(&varReturnValue))
    {
        hr = THR(VariantChangeTypeSpecial (&varReturnValue, &varReturnValue,VT_BOOL));
        if (hr)
            return FALSE; // assume event was not cancelled if changing type to bool failed

        return (VT_BOOL == V_VT(&varReturnValue) && VB_FALSE == V_BOOL(&varReturnValue));
    }
    else
    {   // if the variant is empty, we consider it is not cancelled by default
        return FALSE;
    }
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_defaultStatus
//
//  Synopsis :  Return string of the default status.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_defaultStatus(BSTR *pbstr)
{
    HRESULT hr = S_OK;

    if (!pbstr)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(Doc()->_acstrStatus[STL_DEFSTATUS].AllocBSTR(pbstr));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_status
//
//  Synopsis :  Return string of the status.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_status(BSTR *pbstr)
{
    HRESULT hr = S_OK;

    if (!pbstr)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(Doc()->_acstrStatus[STL_TOPSTATUS].AllocBSTR(pbstr));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::put_defaultStatus
//
//  Synopsis :  Set the default status.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::put_defaultStatus(BSTR bstr)
{
    HRESULT hr = THR(Doc()->SetStatusText(bstr, STL_DEFSTATUS, Markup()));
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::put_status
//
//  Synopsis :  Set the status text.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::put_status(BSTR bstr)
{
    HRESULT hr = THR(Doc()->SetStatusText(bstr, STL_TOPSTATUS, Markup()));
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::scroll
//
//  Synopsis :  Scroll the document by this x & y.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::scroll(long x, long y)
{
    CLayout *   pLayout;
    CDispNode * pDispNode;
    CElement * pElement;

    pElement = _pMarkup->GetCanvasElement();

    if (!pElement)
    {
        return S_OK;
    }

    // make sure that we are calced before trying anything fancy
    if (S_OK != pElement->EnsureRecalcNotify())
        return E_FAIL;

    pLayout   = pElement->GetUpdatedLayout();
    if (!pLayout)
    {
        return S_OK;
    }

    pDispNode =  pLayout->GetElementDispNode();

    if (    pDispNode
        &&  pDispNode->IsScroller())
    {
        x = g_uiDisplay.DeviceFromDocPixelsX(x);
        y = g_uiDisplay.DeviceFromDocPixelsY(y);

        pLayout->ScrollTo(CSize(x, y));
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::scrollTo
//
//  Synopsis :  Scroll the document to this x & y.
//
//----------------------------------------------------------------------------
HRESULT
CWindow::scrollTo(long x, long y)
{
    RRETURN(scroll(x, y));
}

//+---------------------------------------------------------------------------
//
//  member :    CWindow::scrollBy
//
//  Synopsis :  Scroll the document by this x & y.
//
//----------------------------------------------------------------------------
HRESULT
CWindow::scrollBy(long x, long y)
{
    CLayout *   pLayout;
    CDispNode * pDispNode;
    CElement  * pElement;

    pElement = _pMarkup->GetCanvasElement();

    if (!pElement)
        return S_OK;

    // make sure that we are calced before trying anything fancy
    if (S_OK != pElement->EnsureRecalcNotify())
        return E_FAIL;

    pLayout   = pElement->GetUpdatedLayout();
    pDispNode = pLayout
                    ? pLayout->GetElementDispNode()
                    : NULL;

    if (    pDispNode
        &&  pDispNode->IsScroller())
    {
        x = g_uiDisplay.DeviceFromDocPixelsX(x);
        y = g_uiDisplay.DeviceFromDocPixelsY(y);

        pLayout->ScrollBy(CSize(x, y));
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_location
//
//  Synopsis :  Retrieve the location object.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_location(IHTMLLocation **ppLocation)
{
    HRESULT     hr;

    if (!_pLocation)
    {
        _pLocation = new COmLocation(this);
        if (!_pLocation)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    // will subaddref on us if QI succeeded
    hr = THR(_pLocation->QueryInterface(IID_IHTMLLocation, (VOID **)ppLocation));


Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_history
//
//  Synopsis :  Retrieve the history object.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_history(IOmHistory **ppHistory)
{
    HRESULT     hr;

    if (!_pHistory)
    {
        _pHistory = new COmHistory(this);
        if (!_pHistory)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    // will subaddref on us if QI succeeded
    hr = THR(_pHistory->QueryInterface(IID_IOmHistory, (VOID **)ppHistory));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::close
//
//  Synopsis :  Close this window.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::close()
{
    HRESULT hr       = S_OK;
    int     nResult;
    CDoc *  pDoc     = Doc();
    BOOL    fCancel  = FALSE;
    BOOL    fIsChild = (V_VT(&_varOpener) != VT_EMPTY);

    if (!_pWindowParent)
    {

        //
        // if there are print jobs spooling we do not want to close down at this
        // point in time.  but we will need to remember that this was called and
        // do it at another point in time.  Ugh, terrible hack. 110421.
        //
        // NOTE: (carled) This shouldn't be necessary, and once we properly
        // lock the process in the template management code.  The reason this doesn't work
        // right now is that the backup dochostUIhandler does not have a _pUnkSite, and we
        // can't call IOleObjectWithSite::SetSite in EnsureBackupUIHandler because that will
        // set up a refcount-cycle, and so the CDoc can passivate in the middle of printing.
        // one option is to turn each _cSpoolingPrintJobs into an addref on CDoc.
        //
        if (pDoc->PrintJobsPending())
        {
            pDoc->_fCloseOnPrintCompletion = TRUE;
            goto Cleanup;
        }


        // Fire the WebOC WindowClosing event and only close
        // the window if the host does not set Cancel to TRUE.
        //
        pDoc->_webOCEvents.WindowClosing(pDoc->_pTopWebOC, fIsChild, &fCancel);
        if (!fCancel)
        {
            // If this is a trusted document (HTA) or child window, close silently. Otherwise
            // ask the user if it is okay to close the window.

            if (_pMarkup->IsMarkupTrusted() || fIsChild)
                goto CloseWindow;
            else
            {
                hr = pDoc->ShowMessage(&nResult, MB_YESNO | MB_ICONQUESTION,
                                       0, IDS_CONFIRM_SCRIPT_CLOSE_TEXT);
                if (hr)
                    goto Cleanup;

                fCancel = (nResult != IDYES);
            }

CloseWindow:
            if (!fCancel)
            {
                // Try to Exec an OLECMDID_CLOSE command.
                //
                CTExec(Doc()->_pClientSite, NULL, OLECMDID_CLOSE, 0, NULL, NULL);
            }
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::put_opener
//
//  Synopsis :  Retrieve the opener property.
//
//----------------------------------------------------------------------------

HRESULT CWindow::put_opener(VARIANT varOpener)
{
    HRESULT             hr;
    hr = THR(VariantCopy(&_varOpener, &varOpener));
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_opener
//
//  Synopsis :  Retrieve the opener object.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_opener(VARIANT *pvarOpener)
{
    HRESULT             hr = S_OK;

    if (pvarOpener)
        hr = THR(VariantCopy(pvarOpener, &_varOpener));

    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_navigator
//
//  Synopsis :  Retrieve the navigator object.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_navigator(IOmNavigator **ppNavigator)
{
    HRESULT     hr = S_OK;
    IHTMLWindow2 *pShDocVwWindow = NULL;

    THR_NOTRACE(Doc()->QueryService(
            SID_SHTMLWindow2,
            IID_IHTMLWindow2,
            (void**)&pShDocVwWindow));


    if (pShDocVwWindow)
    {
        hr = THR(pShDocVwWindow->get_navigator(ppNavigator));
        goto Cleanup;
    }

    if (!_pNavigator)
    {
        _pNavigator = new COmNavigator(this);
        if (!_pNavigator)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    // will subaddref on us if QI succeeded
    hr = THR(_pNavigator->QueryInterface(IID_IOmNavigator, (VOID **)ppNavigator));

Cleanup:
    ReleaseInterface(pShDocVwWindow);
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_clientInformation
//
//  Synopsis :  Retrieve the navigator object though the client alias
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_clientInformation(IOmNavigator **ppNavigator)
{
    RRETURN(get_navigator(ppNavigator));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::put_name
//
//  Synopsis :  Set the name of this window.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::put_name(BSTR bstr)
{
    HRESULT hr;
    hr = THR(_cstrName.Set(bstr));
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_name
//
//  Synopsis :  Retrieve the name of this window.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_name(BSTR *pbstr)
{
    HRESULT hr;
    hr = THR(_cstrName.AllocBSTR(pbstr));
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------------------
//
//  Member:     CWindow::get_screenLeft
//
//  Synopsis:   Get the name property
//
//  mwatt: Changes because not all HTML frames have a CDOC only the primary Window.
//
//---------------------------------------------------------------------------

HRESULT
CWindow::get_screenLeft(long *pVal)
{
    HRESULT hr = S_OK;

    CTreeNode * pOffsetParent;
    CTreeNode * pTempElement;

    CRootElement* pMyRootElement;
    CElement*     pMasterElement;

    POINT ptDocLeftTop;
    POINT ptElementLeftTop;
    long  nTotalLeft;
    long  nParentLeftness;

    nTotalLeft = ptDocLeftTop.x = ptDocLeftTop.y = 0;

    ptElementLeftTop = ptDocLeftTop;

    //
    // mwatt: Are we the primary window?
    //

    if (IsPrimaryWindow())
    {
        if (Doc()->_pInPlace && !ClientToScreen(Doc()->_pInPlace->_hwnd, &ptDocLeftTop))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        *pVal = ptDocLeftTop.x;
        *pVal = g_uiDisplay.DocPixelsFromDeviceX(*pVal);
    }
    else
    {
        //
        // mwatt: not primary then add our position to our parents position
        //

        pMyRootElement = _pMarkup->Root();

        if (pMyRootElement->HasMasterPtr() && _pWindowParent)
        {
            pMasterElement = pMyRootElement->GetMasterPtr();
			
            Assert(pMasterElement);

            pMasterElement->GetElementTopLeft(ptElementLeftTop);

            nTotalLeft += ptElementLeftTop.x;

            pTempElement = pMasterElement->GetFirstBranch();

            if (pTempElement != NULL)
            {
               pOffsetParent = pTempElement->ZParentBranch();

 while (      pOffsetParent != NULL && (pOffsetParent->Tag() != ETAG_IFRAME)
                        &&  (pOffsetParent->Tag() != ETAG_FRAMESET  || _pWindowParent->IsPrimaryWindow()    )   )
               {
                   pOffsetParent->Element()->GetElementTopLeft(ptElementLeftTop);
                   nTotalLeft += ptElementLeftTop.x;
 
                   CMarkup* pMarkup = NULL;
 
                   if(pOffsetParent->Element()->HasMarkupPtr())
                   {
                       pMarkup = pOffsetParent->Element()->GetMarkup();
                   }
 
                   if(pOffsetParent->Tag() == ETAG_BODY && pMarkup && !pMarkup->IsPrimaryMarkup())
                   {
                       long nBorder = 0;
                       IHTMLControlElement* pControlElem = NULL;
 
                       if( SUCCEEDED(pOffsetParent->Element()->QueryInterface(IID_IHTMLControlElement, (void**)&pControlElem)) &&
                           SUCCEEDED(pControlElem->get_clientLeft(&nBorder)))
                       {
                           nTotalLeft += nBorder;
                           pControlElem->Release();
                       }
                   }

                   pTempElement = pOffsetParent->ZParentBranch();

                   if (pTempElement != pOffsetParent)
                   {
                      pOffsetParent = pTempElement;
                   }
                   else
                   {
                      pOffsetParent = NULL;
                   }
               }
            }

            nTotalLeft = g_uiDisplay.DocPixelsFromDeviceX(nTotalLeft);

            hr = _pWindowParent->get_screenLeft(&nParentLeftness);

            if (hr)
            {
                goto Cleanup;
            }

            *pVal = nParentLeftness + nTotalLeft;

            IHTMLDocument2* pDoc = NULL;
            IHTMLElement* pElem = NULL;
            IHTMLControlElement* pControlElem = NULL;
			IHTMLElement2 * pElem2 = NULL;
			
			long lValue = 0;

            if (SUCCEEDED(_pWindowParent->get_document(&pDoc)) && 
                SUCCEEDED(pDoc->get_body(&pElem)) && 
				SUCCEEDED(pElem->QueryInterface(IID_IHTMLElement2, (void**)&pElem2)) &&	
				SUCCEEDED(pElem2->get_scrollLeft(&lValue)))
            {
				if(_pWindowParent->IsPrimaryWindow()&& 
					SUCCEEDED(pElem->QueryInterface(IID_IHTMLControlElement, (void**)&pControlElem)) &&
					SUCCEEDED(pControlElem->get_clientLeft(&nTotalLeft)))   
				{	
					*pVal = *pVal + nTotalLeft;
					pControlElem->Release();
				}

				*pVal  -= lValue;
				pElem2->Release();
            }

        }
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

Cleanup:

    RRETURN(SetErrorInfo(hr));
}



//+--------------------------------------------------------------------------
//
//  Member:     CWindow::get_screenTop
//
//  Synopsis:   Get the name property
//
//---------------------------------------------------------------------------

HRESULT
CWindow::get_screenTop(long *pVal)
{
    HRESULT hr = S_OK;

    CTreeNode * pOffsetParent;
    CTreeNode * pTempElement;

    CRootElement* pMyRootElement;
    CElement*     pMasterElement;

    POINT ptDocLeftTop;
    POINT ptElementLeftTop;

    long  nTotalTop;
    long  nParentTopness;

    nTotalTop = ptDocLeftTop.x = ptDocLeftTop.y = 0;

    ptElementLeftTop = ptDocLeftTop;

    //
    // mwatt: Are we the primary window?
    //

    if (IsPrimaryWindow())
    {
        if (Doc()->_pInPlace && !ClientToScreen(Doc()->_pInPlace->_hwnd, &ptDocLeftTop))
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        *pVal = ptDocLeftTop.y;
        *pVal = g_uiDisplay.DocPixelsFromDeviceY(*pVal);        
    }
    else
    {
        //
        // mwatt: not primary then add our position to the primary window's position.
        //

        pMyRootElement = _pMarkup->Root();

        if (pMyRootElement->HasMasterPtr() && _pWindowParent)
        {
            pMasterElement = pMyRootElement->GetMasterPtr();

            Assert(pMasterElement);

            pMasterElement->GetElementTopLeft(ptElementLeftTop);

            nTotalTop += ptElementLeftTop.y;

            pTempElement = pMasterElement->GetFirstBranch();

            if (pTempElement != NULL)
            {
               pOffsetParent = pTempElement->ZParentBranch();

			while (  pOffsetParent != NULL && (pOffsetParent->Tag() != ETAG_IFRAME)
                       &&  (pOffsetParent->Tag() != ETAG_FRAMESET  || _pWindowParent->IsPrimaryWindow()    )   )
               {
                   pOffsetParent->Element()->GetElementTopLeft(ptElementLeftTop);
                   nTotalTop += ptElementLeftTop.y;
 
                   CMarkup* pMarkup = NULL;
 
                   if(pOffsetParent->Element()->HasMarkupPtr())
                   {
                       pMarkup = pOffsetParent->Element()->GetMarkup();
                   }
 
                   if(pOffsetParent->Tag() == ETAG_BODY && pMarkup && !pMarkup->IsPrimaryMarkup())
                   {
                       long nBorder = 0;
                       IHTMLControlElement* pControlElem = NULL;
 
                       if( SUCCEEDED(pOffsetParent->Element()->QueryInterface(IID_IHTMLControlElement, (void**)&pControlElem)) &&
                           SUCCEEDED(pControlElem->get_clientTop(&nBorder)))
                       {
                           nTotalTop += nBorder;
                           pControlElem->Release();
                       }
                   }


                   pTempElement = pOffsetParent->ZParentBranch();

                   if (pTempElement != pOffsetParent)
                   {
                      pOffsetParent = pTempElement;
                   }
                   else
                   {
                      pOffsetParent = NULL;
                   }
               }
            }

            nTotalTop = g_uiDisplay.DocPixelsFromDeviceY(nTotalTop);
            hr = _pWindowParent->get_screenTop(&nParentTopness);

            if (hr)
            {
                goto Cleanup;
            }

            *pVal = nParentTopness + nTotalTop;

            IHTMLDocument2* pDoc = NULL;
            IHTMLElement* pElem = NULL;
            IHTMLControlElement* pControlElem = NULL;
			IHTMLElement2 * pElem2 = NULL;
			
			long lValue = 0;

            if (SUCCEEDED(_pWindowParent->get_document(&pDoc)) && 
                SUCCEEDED(pDoc->get_body(&pElem)) && 
				SUCCEEDED(pElem->QueryInterface(IID_IHTMLElement2, (void**)&pElem2)) &&	
				SUCCEEDED(pElem2->get_scrollTop(&lValue)))
            {
				if(_pWindowParent->IsPrimaryWindow()&& 
					SUCCEEDED(pElem->QueryInterface(IID_IHTMLControlElement, (void**)&pControlElem)) &&
					SUCCEEDED(pControlElem->get_clientTop(&nTotalTop)))   
				{	
					*pVal = *pVal + nTotalTop;
					pControlElem->Release();
				}

				*pVal  -= lValue;
				pElem2->Release();
            }
        }
        else
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CWindow::attachEvent(BSTR event, IDispatch* pDisp, VARIANT_BOOL *pResult)
{
    RRETURN(CBase::attachEvent(event, pDisp, pResult));
}

HRESULT
CWindow::detachEvent(BSTR event, IDispatch* pDisp)
{
    RRETURN(CBase::detachEvent(event, pDisp));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::execScript
//
//  Synopsis :  interface method to immediately execute a piece of script passed
//      in. this is added to support the multimedia efforts that need to execute
//      a script immediatedly, based on a high resolution timer. rather than
//      our setTimeOut mechanism which has to post execute-messages
//
//----------------------------------------------------------------------------

HRESULT
CWindow::execScript(BSTR bstrCode, BSTR bstrLanguage, VARIANT * pvarRet)
{
    HRESULT hr = E_INVALIDARG;

    if (SysStringLen(bstrCode) && pvarRet)
    {
        CExcepInfo       ExcepInfo;
        CScriptCollection * pScriptCollection;

        hr = CTL_E_METHODNOTAPPLICABLE;

        pScriptCollection = _pMarkup->GetScriptCollection();
        if (pScriptCollection)
        {
            hr = THR(pScriptCollection->ParseScriptText(
                bstrLanguage,           // pchLanguage
                NULL,                   // pMarkup
                NULL,                   // pchType
                bstrCode,               // pchCode
                NULL,                   // pchItemName
                _T("\""),               // pchDelimiter
                0,                      // ulOffset
                0,                      // ulStartingLine
                NULL,                   // pSourceObject
                SCRIPTTEXT_ISVISIBLE,   // dwFlags
                pvarRet,                // pvarResult
                &ExcepInfo));           // pExcepInfo
        }
    }

    RRETURN(SetErrorInfo( hr ));
}


//+--------------------------------------------------------------------------
//
//  Member : print
//
//  Synopsis : implementation of the IOmWindow3 method to expose print behavior
//      through the OM. to get the proper UI all we need to do is send this
//      to the top level window.
//
//+--------------------------------------------------------------------------
HRESULT
CWindow::print()
{
    HRESULT  hr = S_OK;

    if (!Doc())
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        hr = E_FAIL;
        goto Cleanup;
    }

    if (   Doc()->IsPrintDialog()
        || Doc()->_fPrintEvent
        || Doc()->_fPrintJobPending)
        goto Cleanup;

    //
    // TODO - we need this mechanism more generally, but due to the
    // fact that Print calls that come through IOleCommandTarget::Exec may
    // have varargs that need to be maintained, we need to do this in the
    // next release. for now, we can mark a pending job for this call
    // (no args) and send the exec during onLoadStatusDone
    //
    // if we are not done being parsed we cannot print.
    //
    if (_pMarkup->LoadStatus() <= LOADSTATUS_PARSE_DONE)
    {
        Doc()->_fPrintJobPending = TRUE;
        goto Cleanup;
    }

    // turn this into the print ExecCommand -- note that we have to start at
    // the root level document, not at this document. This is per spec.
    hr = THR(Doc()->ExecHelper(Doc()->_pWindowPrimary->Document(),
                            const_cast < GUID * > ( & CGID_MSHTML ),
                            IDM_EXECPRINT,
                            0,
                            NULL,
                            NULL));

    // is the print canceled?
    if (hr == S_FALSE || hr == OLECMDERR_E_CANCELED)
        hr = S_OK;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  member :    CWindow::open
//
//  Synopsis :  Open a new window.
//
//----------------------------------------------------------------------------

#ifdef NO_MARSHALLING
extern "C" HRESULT CoCreateInternetExplorer(REFIID iid, DWORD dwClsContext, void **ppvunk);
#endif

HRESULT
CWindow::open(
    BSTR url,
    BSTR name,
    BSTR features,
    VARIANT_BOOL replace,
    IHTMLWindow2** ppWindow)
{
    RRETURN(OpenEx(url, NULL, name, features, replace, ppWindow));
}

//+---------------------------------------------------------------------------
//
//  member :    CWindow::navigate
//
//  Synopsis :  Navigate this window elsewhere.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::navigate(BSTR bstrUrl)
{
    HRESULT hr;

    hr = THR(FollowHyperlinkHelper( bstrUrl, 0, 0));

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_closed
//
//  Synopsis :  Retrieve the closed property.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_closed(VARIANT_BOOL *p)
{
    HRESULT             hr = S_OK;

    if (Doc()->GetHWND())
    {
        *p = VB_FALSE;
    }
    else
    {
        *p = VB_TRUE;
    }

    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_self
//
//  Synopsis :  Retrieve ourself.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_self(IHTMLWindow2 **ppSelf)
{
    HRESULT             hr = S_OK;

    *ppSelf = (IHTMLWindow2 *)this;
    AddRef();

    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_window
//
//  Synopsis :  Retrieve self.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_window(IHTMLWindow2 **ppWindow)
{
    CWindow * pWindow = this;

    if (_punkViewLinkedWebOC)
    {
        COmWindowProxy * pOmWindowProxy = GetInnerWindow();

        if (pOmWindowProxy)
            pWindow = pOmWindowProxy->Window();
    }

    RRETURN(THR(pWindow->get_self(ppWindow)));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_top
//
//  Synopsis :  Get the topmost window in this hierarchy.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_top(IHTMLWindow2 **ppTop)
{
    HRESULT hr = S_OK;
    IHTMLWindow2 *  pThis = this;
    IHTMLWindow2 *  pParent = NULL;

    AddRef();   // To compensate for pThis.

    for (pThis->get_parent(&pParent);
         pParent && !IsSameObject(pParent, pThis);
         pThis->get_parent(&pParent))
    {
        ReleaseInterface(pThis);
        pThis = pParent;
        pParent = NULL;
    }

    Assert(pThis);
    *ppTop = pThis;
    pThis->AddRef();
    ReleaseInterface(pParent);
    ReleaseInterface(pThis);

    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_parent
//
//  Synopsis :  Retrieve parent window in this hierarchy.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_parent(IHTMLWindow2 **ppParent)
{
    HRESULT  hr   = S_OK;
    CDoc   * pDoc = Doc();

    // If we have a parent window and the parent window
    // doesn't have a markup, a host app may be shutting
    // us downs in the middle of an event. In that
    // case, _pWindowParent->_pMarkup can be NULL. If
    // we are not shutting down and the markup is NULL,
    // we need to figure out why.
    //
    Assert(!_pWindowParent || _pWindowParent->_pMarkup || pDoc->_fIsClosingOrClosed);

    // Even if we have a window parent,
    // If we are a desktop item and our parent is the desktop or
    // If case we are in an HTA and we are not trusted while our parent is,
    // then return the self instead of the parent
    //
    if (   _pWindowParent
        && _pWindowParent->_pMarkup
        &&  !(!_pMarkup->IsMarkupTrusted()
            && _pWindowParent->_pMarkup->IsMarkupTrusted()))
    {
        Assert( !_pWindowParent->IsShuttingDown() );
        *ppParent = _pWindowParent;
        _pWindowParent->AddRef();
    }
    else if (pDoc->_fPopupDoc)
    {
        Assert(pDoc->_pPopupParentWindow);
        Assert( !pDoc->_pPopupParentWindow->IsShuttingDown() );
        *ppParent = pDoc->_pPopupParentWindow;
        pDoc->_pPopupParentWindow->AddRef();
    }
    else if (pDoc->_fViewLinkedInWebOC && !pDoc->_fIsActiveDesktopComponent)
    {
        COmWindowProxy * pOmWindowProxy = pDoc->GetOuterWindow();

        if (pOmWindowProxy)
            hr = THR(pOmWindowProxy->Window()->get_parent(ppParent));
    }
    else
    {
        hr = THR(get_self(ppParent));
    }

    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     CMarkup::GetSecurityID
//
//  Synopsis:   Retrieve a security ID from a url from the system sec mgr.
//
//-------------------------------------------------------------------------
HRESULT 
CMarkup::GetSecurityID(BYTE *pbSID, DWORD *pcb, LPCTSTR pchURL, LPCWSTR pchDomain, BOOL useDomain)
{
    HRESULT hr;
    DWORD   dwSize;
    TCHAR   achURL[pdlUrlLen];
    CStr    cstrSpecialUrl;
    LPCTSTR pchCreatorUrl;
    CDoc *  pDoc = Doc();

    hr = THR(pDoc->EnsureSecurityManager());
    if (hr)
        goto Cleanup;

    if (!pchURL)
    {
        pchURL = GetUrl(this);
    }

    // Do we have a file URL?
    hr = THR(CoInternetParseUrl(pchURL,
                                PARSE_PATH_FROM_URL,
                                0,
                                achURL,
                                ARRAY_SIZE(achURL),
                                &dwSize,
                                0));

    // hr == S_OK indicates that the URL is a file URL.
    if (!hr)
    {
        pchURL = achURL;
    }

    // Unescape the URL.
    hr = THR(CoInternetParseUrl(
            pchURL,
            PARSE_ENCODE,
            0,
            achURL,
            ARRAY_SIZE(achURL),
            &dwSize,
            0));
    if (hr)
        goto Cleanup;


    UnescapeAndTruncateUrl(achURL);

//TODO: FerhanE/Anandra:  Although we have removed the %01 hack from Trident and shdocvw,
//                        we need to provide this when getting the security ID from URLMON for now.
//                        We have to arrange it so that other customers of URLMON who use the
//                        GetSecurityID also update their code, before we can remove the dependency there.

    pchCreatorUrl = GetAAcreatorUrl();

    // If a creator URL is set, it means that either this markup's window was opened with window.open
    // or it is a frame with a special URL. Either case, we have to wrap the URL with the creator's to
    // reflect the creator's domain.

    if (pchCreatorUrl && *pchCreatorUrl)
    {
        hr = WrapSpecialUrl( achURL, &cstrSpecialUrl, pchCreatorUrl, FALSE, FALSE);
    }
    else
    {
        cstrSpecialUrl.Set(achURL);
    }

    hr = THR(pDoc->_pSecurityMgr->GetSecurityId(
                cstrSpecialUrl,
                pbSID,
                pcb,
                useDomain?(DWORD_PTR)pchDomain : (DWORD_PTR)Domain()));
    if (hr)
        goto Cleanup;

//  No counter action to the wrapping above, since the string is on stack

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  member :    CMarkup::IsUrlRecursive
//
//  Synopsis :  Check if url is recursive with parents by walking up the markup
//              tree.
//
//----------------------------------------------------------------------------

BOOL
CMarkup::IsUrlRecursive(LPCTSTR pchUrl)
{
    HRESULT             hr = S_OK;
    TCHAR               achUrlOnly[pdlUrlLen];
    LPTSTR              pchLocation;
    BOOL                fRes = FALSE;
    CMarkup *           pMarkup = this;

    //prepare a copy of the pchUrl, which can be manipulated and changed.
    StrCpy(achUrlOnly, pchUrl);

    // if there is a '#....' at the end of the url, we
    // don't want to have it there for the comparisons.
    pchLocation = (LPTSTR) UrlGetLocation(achUrlOnly);

    if (pchLocation)
        * pchLocation = _T('\0');

    // if we are pointing to any of the markups in the parent chain,
    // we would recurse forever.
    while (pMarkup)
    {
        DWORD   cchParentUrl = pdlUrlLen;
        TCHAR   achParentUrl[pdlUrlLen];

        // We were passing a NULL URL occasionally and tripping an assert,
        // so instead we continue with the return value that we would have gotten
        // had we made the call
        LPCTSTR pchTempUrl = CMarkup::GetUrl(pMarkup);
        if (pchTempUrl)
        {
            hr = THR(UrlCanonicalize(
                        pchTempUrl,
                        (LPTSTR) achParentUrl,
                        &cchParentUrl,
                        URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE));
        }
        else
        {
            hr = E_INVALIDARG;
        }

        // if the hr is wrong leave with a no-recursion return value,
        // this is by design (anandra-ferhane)
        if (hr)
            goto Cleanup;

        pchLocation = (LPTSTR) UrlGetLocation(achParentUrl);
        if (pchLocation)
            * pchLocation = _T('\0');

        // UrlCompare returns 0 if the urls are the same
        if ( !UrlCompare( achUrlOnly, achParentUrl, TRUE) )
        {
            // if two urls are the same, then the given url is recursive
            fRes = TRUE;
            goto Cleanup;
        }

        // walk up parent markup
        pMarkup = pMarkup->GetParentMarkup();
    }

Cleanup:
    return fRes;
}

//+------------------------------------------------------------------
//
//  Members: moveTo, moveBy, resizeTo, resizeBy
//
// TODO (carled) - eventually the then clause of the shdocvw if, should
// be removed and the else clause should become the body of
// this function.  To do this SHDOCVW will have to implement
// IHTMLOMWindowServices and this is part of the window split
// work.  This will have to happen for almost every function and
// method in this file that delegates explicitly to shdocvw.  i.e.
// trident should have NO explicit knowledge about its host.
//
//----------------------------------------------------------------------

HRESULT
CWindow::moveTo(long x, long y)
{
    HRESULT             hr = S_OK;
    IWebBrowser2 *      pWebBrowser = NULL;

    if (_pMarkup->IsPrimaryMarkup())
    {
        hr = Doc()->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void**) &pWebBrowser);
        if (!hr)
        {
            HWND hwnd;
            VARIANT_BOOL vbFullScreen;

            // disallow resize or move of window if fullscreen
            hr = pWebBrowser->get_FullScreen(&vbFullScreen);
            if (vbFullScreen == VARIANT_TRUE)
            {
                goto Cleanup;
            }

            hr = pWebBrowser->get_HWND((LONG_PTR *) &hwnd);
            ReleaseInterface(pWebBrowser);
            if (!hr)
            {
                x = g_uiDisplay.DeviceFromDocPixelsX(x);
                y = g_uiDisplay.DeviceFromDocPixelsY(y);

                ::SetWindowPos(hwnd, NULL, x, y, 0, 0, SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
                goto Cleanup;
            }
            else
            {
                IHTMLWindow2 * pWin = NULL;

                hr = THR(Doc()->QueryService(SID_SHTMLWindow2,IID_IHTMLWindow2,(void**)&pWin));

                if (hr)
                {
                    if (hr == E_NOINTERFACE)
                        hr = S_OK;   // fail silently
                }
                else
                {
                    pWin->moveTo(x,y);
                }

                ReleaseInterface(pWin);
            }
        }
        else    // If we came here that means that we are in WebOC or HTA
        {
            // don't do anything unless we are the top level document
            IHTMLOMWindowServices *pOMWinServices = NULL;

            // QueryService our container for IHTMLOMWindowServices
            hr = THR(Doc()->QueryService(IID_IHTMLOMWindowServices,
                                         IID_IHTMLOMWindowServices,
                                         (void**)&pOMWinServices));
            if (hr)
            {
                if (hr == E_NOINTERFACE)
                    hr = S_OK;   // fail silently
            }
            else
            {
                // delegate the call to our host.
                hr = THR(pOMWinServices->moveTo(x, y));
            }

            ReleaseInterface(pOMWinServices);
        }
    }
    else
    {
        // Frames and IFrames
        hr = THR(put_Left(x));
        if(hr)
            goto Cleanup;
        hr = THR(put_Top(y));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CWindow::moveBy(long x, long y)
{
    HRESULT             hr = S_OK;
    IWebBrowser2 *      pWebBrowser = NULL;

    if (_pMarkup->IsPrimaryMarkup())
    {
        hr = Doc()->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void**) &pWebBrowser);
        if (!hr)
        {
            HWND hwnd;
            VARIANT_BOOL vbFullScreen;

            // disallow resize or move of window if fullscreen
            hr = pWebBrowser->get_FullScreen(&vbFullScreen);
            if (vbFullScreen == VARIANT_TRUE)
            {
                goto Cleanup;
            }

            hr = pWebBrowser->get_HWND((LONG_PTR *) &hwnd);
            ReleaseInterface(pWebBrowser);
            if (!hr)
            {
                RECT rcWindow;

                x = g_uiDisplay.DeviceFromDocPixelsX(x);
                y = g_uiDisplay.DeviceFromDocPixelsY(y);

                ::GetWindowRect(hwnd, &rcWindow);

                ::SetWindowPos(hwnd, NULL, rcWindow.left + x, rcWindow.top + y, 0, 0,
                               SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
                goto Cleanup;
            }
            else
            {
                IHTMLWindow2 * pWin = NULL;

                hr = THR(Doc()->QueryService(SID_SHTMLWindow2,IID_IHTMLWindow2,(void**)&pWin));

                if (hr)
                {
                    if (hr == E_NOINTERFACE)
                        hr = S_OK;   // fail silently
                }
                else
                {
                    pWin->moveBy(x,y);
                }

                ReleaseInterface(pWin);
            }
        }
        else // If we came here that means that we are in WebOC or HTA
        {
            // don't do anything unless we are the top level document
            IHTMLOMWindowServices * pOMWinServices = NULL;

            // QueryService our container for IHTMLOMWindowServices
            hr = THR(Doc()->QueryService(IID_IHTMLOMWindowServices,
                                         IID_IHTMLOMWindowServices,
                                         (void**)&pOMWinServices));
            if (hr)
            {
                if (hr == E_NOINTERFACE)
                    hr = S_OK;   // fail silently
            }
            else
            {
                // delegate the call to our host.
                hr = THR(pOMWinServices->moveBy(x, y));
            }

            ReleaseInterface(pOMWinServices);
        }
    }
    else
    {
        // Frames and IFrames
        long xCur, yCur;

        hr = THR(get_Left(&xCur));
        if(hr)
            goto Cleanup;
        hr = THR(put_Left(x + xCur));
        if(hr)
            goto Cleanup;

        hr = THR(get_Top(&yCur));
        if(hr)
            goto Cleanup;
        hr = THR(put_Top(y + yCur));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CWindow::resizeTo(long x, long y)
{
    HRESULT             hr = S_OK;

    IWebBrowser2 *      pWebBrowser = NULL;

    if (_pMarkup->IsPrimaryMarkup())
    {
        hr = Doc()->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void**) &pWebBrowser);
        if (!hr)
        {
            HWND hwnd;
            VARIANT_BOOL vbFullScreen;

            // disallow resize or move of window if fullscreen
            hr = pWebBrowser->get_FullScreen(&vbFullScreen);
            if (vbFullScreen == VARIANT_TRUE)
            {
                goto Cleanup;
            }

            hr = pWebBrowser->get_HWND((LONG_PTR *) &hwnd);
            ReleaseInterface(pWebBrowser);
            if (!hr)
            {
                x = g_uiDisplay.DeviceFromDocPixelsX(x);
                y = g_uiDisplay.DeviceFromDocPixelsY(y);

                // We do not allow the size to be less then 100 for top level windows in browser
                if (x < 100)
                    x = 100;

                if (y < 100)
                    y = 100;

                ::SetWindowPos(hwnd, NULL, 0, 0, x, y, SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);
                goto Cleanup;
            }
            else
            {
                IHTMLWindow2 * pWin = NULL;

                hr = THR(Doc()->QueryService(SID_SHTMLWindow2,IID_IHTMLWindow2,(void**)&pWin));

                if (hr)
                {
                    if (hr == E_NOINTERFACE)
                        hr = S_OK;   // fail silently
                }
                else
                {
                    pWin->resizeTo(x,y);
                }

                ReleaseInterface(pWin);
            }
        }
        else // If we came here that means that we are in WebOC or HTA
        {
            // don't do anything unless we are the top level document
            IHTMLOMWindowServices *pOMWinServices = NULL;

            // QueryService our container for IHTMLOMWindowServices
            hr = THR(Doc()->QueryService(IID_IHTMLOMWindowServices,
                                         IID_IHTMLOMWindowServices,
                                         (void**)&pOMWinServices));
            if (hr)
            {
                if (hr == E_NOINTERFACE)
                    hr = S_OK;   // fail silently
            }
            else
            {
                // delegate the call to our host.
                hr = THR(pOMWinServices->resizeTo(x, y));
            }

            ReleaseInterface(pOMWinServices);
        }
    }
    else
    {
        // Frames and IFrames
        hr = THR(put_Width(x));
        if(hr)
            goto Cleanup;
        hr = THR(put_Height(y));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CWindow::resizeBy(long x, long y)
{
    HRESULT             hr = S_OK;
    IWebBrowser2 *      pWebBrowser = NULL;

    if (_pMarkup->IsPrimaryMarkup())
    {
        hr = Doc()->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void**) &pWebBrowser);
        if (!hr)
        {
            HWND hwnd;
            VARIANT_BOOL vbFullScreen;

            // disallow resize or move of window if fullscreen
            hr = pWebBrowser->get_FullScreen(&vbFullScreen);
            if (vbFullScreen == VARIANT_TRUE)
            {
                goto Cleanup;
            }

            hr = pWebBrowser->get_HWND((LONG_PTR *) &hwnd);
            ReleaseInterface(pWebBrowser);
            if (!hr)
            {
                RECT rcWindow;
                long w, h;

                ::GetWindowRect(hwnd, &rcWindow);

                x = g_uiDisplay.DeviceFromDocPixelsX(x);
                y = g_uiDisplay.DeviceFromDocPixelsY(y);

                w = rcWindow.right - rcWindow.left + x;
                h = rcWindow.bottom - rcWindow.top + y;

                if (w < 100)
                    w = 100;

                if (h < 100)
                    h = 100;

                ::SetWindowPos(hwnd, NULL, 0, 0, w, h, SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);
                goto Cleanup;
            }
            else
            {
                IHTMLWindow2 * pWin = NULL;

                hr = THR(Doc()->QueryService(SID_SHTMLWindow2,IID_IHTMLWindow2,(void**)&pWin));

                if (hr)
                {
                    if (hr == E_NOINTERFACE)
                        hr = S_OK;   // fail silently
                }
                else
                {
                    pWin->resizeBy(x,y);
                }

                ReleaseInterface(pWin);
            }
        }
        else // If we came here that means that we are in WebOC or HTA
        {
            // don't do anything unless we are the top level document
            IHTMLOMWindowServices *pOMWinServices = NULL;

            // QueryService our container for IHTMLOMWindowServices
            hr = THR(Doc()->QueryService(IID_IHTMLOMWindowServices,
                                         IID_IHTMLOMWindowServices,
                                         (void**)&pOMWinServices));
            if (hr)
            {
                if (hr == E_NOINTERFACE)
                    hr = S_OK;   // fail silently
            }
            else
            {
                // delegate the call to our host.
                hr = THR(pOMWinServices->resizeBy(x, y));
            }

            ReleaseInterface(pOMWinServices);
        }
    }
    else
    {
        // Frames and IFrames
        long xCur, yCur;

        hr = THR(get_Width(&xCur));
        if(hr)
            goto Cleanup;
        hr = THR(put_Width(x + xCur));
        if(hr)
            goto Cleanup;

        hr = THR(get_Height(&yCur));
        if(hr)
            goto Cleanup;
        hr = THR(put_Height(y + yCur));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_Option
//
//  Synopsis :  Retrieve Option element factory.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_Option(IHTMLOptionElementFactory **ppDisp)
{
    HRESULT                 hr = S_OK;
    COptionElementFactory * pFactory;

    if (ppDisp == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppDisp = NULL;

    pFactory = new COptionElementFactory;
    if ( !pFactory )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    pFactory->_pMarkup = _pMarkup;
    _pMarkup->SubAddRef();
    hr = pFactory->QueryInterface ( IID_IHTMLOptionElementFactory, (void **)ppDisp );
    pFactory->PrivateRelease();

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_Image
//
//  Synopsis :  Retrieve Image element factory.
//
//----------------------------------------------------------------------------

HRESULT
CWindow::get_Image(IHTMLImageElementFactory**ppDisp)
{
    HRESULT                 hr = S_OK;
    CImageElementFactory *  pFactory;

    if (ppDisp == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *ppDisp = NULL;

    pFactory = new CImageElementFactory;
    if ( !pFactory )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    pFactory->_pMarkup = _pMarkup;
    _pMarkup->SubAddRef();
    hr = pFactory->QueryInterface ( IID_IHTMLImageElementFactory, (void **)ppDisp );
    pFactory->PrivateRelease();

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//----------------------------------------------------------------------------
//
//
//----------------------------------------------------------------------------
HRESULT
CWindow::OnCreate(IUnknown * pUnkDestination, ULONG cbCookie)
{
    HRESULT             hr;
    IServiceProvider *  pSP = NULL;
    CVariant            varDummy;
    CVariant            var;

    // Assume that we will fail.
    if( !pUnkDestination )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Get the IHTMLWindow2 from the IUnknown pointer we have in hand, to prepare the
    // return value for the window.open call.

    // Get the IServiceProvider interface pointer
    hr = THR(pUnkDestination->QueryInterface(IID_IServiceProvider, (void **) &pSP));
    if (hr)
        goto Cleanup;

    // We should not have anything in the _pOpenedWindow. However, we should clean it if
    // there is one, to stop a leak.
    // Once we switch to native frame, this release will not be needed.
    Assert(_pOpenedWindow == NULL );
    ReleaseInterface(_pOpenedWindow);

    // Get the IHTMLWindow2 interface pointer for the new window
    // We will not release the pointer we get, it will be handed to the caller of window.open.
    hr = THR(pSP->QueryService(IID_IHTMLWindow2, IID_IHTMLWindow2, (void **) &_pOpenedWindow));
    if (hr)
        goto Cleanup;

    Assert(_pOpenedWindow);

    // set the opener property on the new window

    VariantInit(&var);
    VariantInit(&varDummy);

    V_VT(&var) = VT_DISPATCH;

    // If we are being hosted in SHDOCVW, then the opener should be its IHTMLWindow2 stub.
    // Otherwise, the opener is this window object.

    // No need to addref. put_opener takes care of the addref issue ...
    V_DISPATCH(&var) = DYNCAST(IHTMLWindow2, this);

    // call dummy put_opener in order to make use of its marshalling to set
    // child flag in opened window
    V_VT(&varDummy) = VT_BOOL;
    V_BOOL(&varDummy) = 666;
    hr = THR(_pOpenedWindow->put_opener(varDummy));

    // set actual opener
    hr = THR(_pOpenedWindow->put_opener(var));

    // clear the variant, without causing the reference to be released by accident
    V_VT(&var) = VT_EMPTY;

Cleanup:
    ReleaseInterface(pSP);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//
//----------------------------------------------------------------------------
HRESULT
CWindow::OnReuse(IUnknown * pUnkDestination)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//
//
//----------------------------------------------------------------------------
HRESULT
CWindow::GetOptionString(BSTR * pbstrOptions)
{
    HRESULT hr = S_OK;

    // if we are opening a window using the context menu etc. and not the window.open,
    // shdocvw will not reset the options it cached.
    // We return S_FALSE to indicate that the options should not be reset, and the
    // navigation request we made was not through a window.open call.
    if (!_fOpenInProgress)
    {
        return S_FALSE;
    }

    if (!pbstrOptions)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrOptions = NULL;

    // Allocate a new features string from the features string
    // we have received .
    if (_cstrFeatures)
    {
        // the caller will release the string, so we can NULL the pointer
        hr = THR(FormsAllocString(_cstrFeatures, pbstrOptions));

        // free the string, so we don't use the same set of options
        // for the next call.
        _cstrFeatures.Free();
    }

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  CDocument - implementation for the window.document object
//
//--------------------------------------------------------------------------

const CBase::CLASSDESC CDocument::s_classdesc =
{
    &CLSID_HTMLDocument,            // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    s_acpi,                         // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLDocument2,            // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

void
CDocument::Passivate()
{
    CFramesCollection * pFrames = NULL;

    if(_pPageTransitionInfo)
    {
        // Passing 1 will ensure we do not try to cleanup posted CleanupPageTransitions
        // requests from Passivate
        CleanupPageTransitions(TRUE);
        delete _pPageTransitionInfo;
    }

    GetPointerAt(FindAAIndex(DISPID_INTERNAL_FRAMESCOLLECTION, CAttrValue::AA_Internal),
        (void **) &pFrames);

    if (pFrames)
    {
        pFrames->Release();
    }


    super::Passivate();
}

CSecurityThunkSub::CSecurityThunkSub(CBase * pBase, DWORD dwThunkType)
{
    _pBase = pBase;
    _pvSecurityThunk = NULL;
    _dwThunkType = dwThunkType;
    _pBase->PrivateAddRef();
    _ulRefs = 0;
}

CSecurityThunkSub::~CSecurityThunkSub()
{
    Assert(_pBase);

    // If this thunk has already been reset, don't set it to NULL on the owner here
    // as this has already happened at the appropriate time on the reset.
    if (!_pvSecurityThunk)
    {
        switch(_dwThunkType)
        {
        case EnumSecThunkTypeDocument:
            DYNCAST(CDocument, _pBase)->_pvSecurityThunk = NULL;
            break;
        case EnumSecThunkTypeWindow:
            DYNCAST(COmWindowProxy, _pBase)->_pvSecurityThunk = NULL;
            break;
        case EnumSecThunkTypePendingWindow:
            DYNCAST(COmWindowProxy, _pBase)->_pvSecurityThunkPending = NULL;;
            break;
        default:
            AssertSz(0, "Invalid value for _dwThunkType");
        }
    }

    _pBase->PrivateRelease();
    _pvSecurityThunk = NULL;
}

extern BOOL g_fInIexplorer;
extern BOOL g_fInExplorer;

HRESULT
CSecurityThunkSub::QueryInterface(REFIID riid, void ** ppv)
{
    HRESULT     hr;

    if (!_pvSecurityThunk || (!g_fInExplorer && !g_fInIexplorer))
    {
        Assert(_pBase);
        hr = THR_NOTRACE(_pBase->PrivateQueryInterface(riid, ppv));
    }
    else 
    {
        // We are here because this sec. thunk has been reset in the browser
        if (_pvSecurityThunk &&
            (riid == IID_IUnknown || 
             riid == IID_IDispatch || 
             riid == IID_IDispatchEx))
        {
            if (ppv)
            {
                *ppv = _pvSecurityThunk;
                ((IUnknown *)*ppv)->AddRef();
                hr = S_OK;
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            AssertSz(FALSE, "This document has been navigated");
            if (ppv)
                *ppv = NULL;

            hr = E_NOINTERFACE;
        }
    }

    RRETURN1(hr, E_NOINTERFACE);
}

ULONG
CSecurityThunkSub::AddRef()
{
    _ulRefs++;
    return _ulRefs;

}

ULONG
CSecurityThunkSub::Release()
{
    _ulRefs--;
    if (0 == _ulRefs)
    {
        delete this;
        return 0;
    }
    return _ulRefs;
}

///////////////////////////////////////////////////////////////////////////////
//
// Class CDocument
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////////

BEGIN_TEAROFF_TABLE(CDocument, IOleItemContainer)
    // IParseDisplayName methods
    TEAROFF_METHOD(CDocument, ParseDisplayName, parsedisplayname, (IBindCtx *pbc, LPOLESTR pszDisplayName,ULONG *pchEaten, IMoniker **ppmkOut))
    // IOleContainer methods
    TEAROFF_METHOD(CDocument, EnumObjects, enumobjects, (DWORD grfFlags, IEnumUnknown **ppenum))
    TEAROFF_METHOD(CDocument, LockContainer, lockcontainer, (BOOL fLock))
    // IOleItemContainer methods
    TEAROFF_METHOD(CDocument, GetObject, getobject, (LPTSTR pszItem, DWORD dwSpeedNeeded, IBindCtx *pbc, REFIID riid, void **ppvObject))
    TEAROFF_METHOD(CDocument, GetObjectStorage, getobjectstorage, (LPOLESTR pszItem, IBindCtx *pbc, REFIID riid, void **ppvStorage))
    TEAROFF_METHOD(CDocument, IsRunning, isrunning, (LPOLESTR pszItem))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE(CDocument, IInternetHostSecurityManager)
    TEAROFF_METHOD(CDocument, HostGetSecurityId, hostgetsecurityid, (BYTE *pbSID, DWORD *pcb, LPCWSTR pwszDomain))
    TEAROFF_METHOD(CDocument, HostProcessUrlAction, hostprocessurlaction, (DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved))
    TEAROFF_METHOD(CDocument, HostQueryCustomPolicy, hostquerycustompolicy, (REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved))
END_TEAROFF_TABLE()

///////////////////////////////////////////////////////////////////////////////
//
// methods
//
///////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Method:     CDocument constructor
//
//--------------------------------------------------------------------------

CDocument::CDocument( CMarkup * pMarkupOwner )
{
#if 1 //..todo del
    Assert (!_pMarkup);
    Assert (!_pWindow);
    Assert (_eHTMLDocDirection == 0);
    Assert (!_pCSelectionObject);
    Assert (!_pvSecurityThunk);
#endif

    Assert( pMarkupOwner );
    _pMarkup = pMarkupOwner;

    _lnodeType = 9;     // Node type is set to DOCUMENT

    SetGalleryMeta(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDocument::SwitchOwnerToWindow
//
//--------------------------------------------------------------------------
void
CDocument::SwitchOwnerToWindow( CWindow  * pWindow )
{
    Assert( pWindow && _pMarkup && !_pWindow );

    CMarkup * pMarkupRelease = NULL;

    // Transfer our >1 ref to the Window
    if (_ulRefs > 1)
    {
        pMarkupRelease = _pMarkup;
        pWindow->AddRef();
    }

    pWindow->_pDocument = this;
    _pMarkup->DelDocumentPtr();

    _pMarkup = NULL;
    _pWindow = pWindow;

    if (pMarkupRelease)
        pMarkupRelease->Release();
}


//+-------------------------------------------------------------------------
//
//  Method:     CDocument::Window
//
//--------------------------------------------------------------------------

CWindow *
CDocument::Window()
{
    if (_pMarkup)
    {
        Assert (!_pWindow);

        COmWindowProxy * pWindowProxy = _pMarkup->Window();

        return pWindowProxy ? pWindowProxy->Window() : NULL;
    }
    else
    {
        Assert (_pWindow);
        return _pWindow;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CDocument::Markup
//
//--------------------------------------------------------------------------

CMarkup *
CDocument::Markup()
{
    if (_pWindow)
    {
        Assert (!_pMarkup);
        return _pWindow->Markup();
    }
    else
    {
        Assert (_pMarkup);
        return _pMarkup;
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CDocument::GetWindowedMarkupContext
//
//--------------------------------------------------------------------------

CMarkup *
CDocument::GetWindowedMarkupContext()
{
    if (_pWindow)
    {
        Assert(!_pMarkup);
        return _pWindow->Markup();
    }
    else
    {
        Assert(_pMarkup && _pMarkup->GetWindowedMarkupContext());
        return _pMarkup->GetWindowedMarkupContext();
    }
}

COmWindowProxy *
CBase::Proxy()
{
    COmWindowProxy *pWindow = NULL;
    void *pObj;

    if (SUCCEEDED(PrivateQueryInterface(CLSID_HTMLWindow2, (void **)&pObj)))
    {
        pWindow = ((CWindow *)this)->_pWindowProxy;
    }
    else if (SUCCEEDED(PrivateQueryInterface(CLSID_CDocument, (void **)&pObj)))
    {
        pWindow = ((CDocument *)this)->GetWindowedMarkupContext()->Window();
    }
    else if (SUCCEEDED(PrivateQueryInterface(CLSID_CElement, (void **)&pObj)))
    {
        pWindow = ((CElement *)this)->GetWindowedMarkupContext()->Window();
    }
    else if (SUCCEEDED(PrivateQueryInterface(CLSID_CStyle, (void**)&pObj)))
    {
        pWindow = ((CStyle*)this)->GetElementPtr()->GetWindowedMarkupContext()->Window();
    }
    else if (SUCCEEDED(PrivateQueryInterface(CLSID_HTMLLocation, (void**)&pObj)))
    {
        pWindow = ((COmLocation*)this)->Window()->_pWindowProxy;
    }    
    else if (SUCCEEDED(PrivateQueryInterface(CLSID_CAttribute, (void**)&pObj)))
    {
        pWindow = ((CAttribute*)this)->_pDocument->MyCWindow()->_pWindowProxy;
    }
    //CSelectionObject doesn't have a CLSID
    else if (SUCCEEDED(PrivateQueryInterface(IID_IHTMLSelectionObject, (void**)&pObj)))
    {
        pWindow = ((CSelectionObject*)this)->Document()->MyCWindow()->_pWindowProxy;
        ((IUnknown *)pObj)->Release();
    }    
    
    else if (SUCCEEDED(PrivateQueryInterface(CLSID_HTMLWindowProxy, (void **)&pWindow)))
    {
        AssertSz((COmWindowProxy *)this == pWindow, "Window Proxy Mismatch");
    }

    if (pWindow == NULL)
    {
        // If you hit this assert, it means that the class that's coming through this codepath 
        // is not special cased above. To get rid of this assert, figure out what the derived
        // class is and add a case above for whatever class it is that's asserting.

        AssertSz(false, "Couldn't find a WindowProxy for this CBase-derived class, add one to the code!");
    }
    return pWindow;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDocument::IsMyParentAlive
//
//--------------------------------------------------------------------------

inline BOOL
CDocument::IsMyParentAlive(void)
{
    return MyCWindow()->GetObjectRefs() != 0;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDocument::PrivateAddRef
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDocument::PrivateAddRef()
{
    if( _ulRefs == 1 )
    {
        if (_pMarkup )
            _pMarkup->AddRef();
        else
        {
            Assert( _pWindow );
            _pWindow->AddRef();
        }

    }

    return super::PrivateAddRef();
}

//+-------------------------------------------------------------------------
//
//  Method:     CDocument::PrivateRelease
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDocument::PrivateRelease()
{
    CMarkup * pMarkup = NULL;
    CWindow * pWindow = NULL;

    if( _ulRefs == 2 )
    {
        pMarkup = _pMarkup;
        pWindow = _pWindow;

        Assert( !!pMarkup ^ !!pWindow );
    }

    ULONG ret = super::PrivateRelease();

    if (pMarkup)
        pMarkup->Release();
    else if (pWindow)
        pWindow->Release();

    return ret;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDocument::GetSecurityThunk
//
//--------------------------------------------------------------------------

HRESULT
CDocument::GetSecurityThunk(LPVOID * ppv)
{
    HRESULT                 hr = S_OK;
    CSecurityThunkSub *     pThunkSub;

    if (!_pvSecurityThunk)
    {
        pThunkSub = new CSecurityThunkSub(this, CSecurityThunkSub::EnumSecThunkTypeDocument);
        if (!pThunkSub)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = CreateTearOffThunk(
            this,                                   // pvObject1
            (void*) s_apfnIDispatchEx,              // apfn1
            NULL,                                   // pUnkOuter
            &_pvSecurityThunk,                      // ppvThunk
            pThunkSub,                              // pvObject2
            *(void **)(IUnknown*)pThunkSub,         // apfn2
            QI_MASK | ADDREF_MASK | RELEASE_MASK,   // dwMask
            g_apIID_IDispatchEx);                   // appropdescsInVtblOrder

        if (hr)
            goto Cleanup;
    }

    *ppv = _pvSecurityThunk;

Cleanup:
    RRETURN (hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     ResetSecurityThunk
//
//--------------------------------------------------------------------------

void
ResetSecurityThunkHelper(LPVOID * ppvSecurityThunk)
{
    Assert(ppvSecurityThunk);

    if (*ppvSecurityThunk)
    {
        TEAROFF_THUNK * pThunk = (TEAROFF_THUNK*)(*ppvSecurityThunk);

        Assert (pThunk->pvObject1);

        pThunk->pvObject1       = (IDispatchEx*)&g_DummySecurityDispatchEx;
        pThunk->apfnVtblObject1 = *(void **)(IDispatchEx*)(&g_DummySecurityDispatchEx);

        Assert (pThunk->pvObject2);
        CSecurityThunkSub *thunkSub = (CSecurityThunkSub *)(pThunk->pvObject2);
        thunkSub->_pvSecurityThunk = *ppvSecurityThunk;

        *ppvSecurityThunk = NULL;
    }
}

void
CDocument::ResetSecurityThunk()
{
    ResetSecurityThunkHelper(&_pvSecurityThunk);
}

void
COmWindowProxy::ResetSecurityThunk()
{
    ResetSecurityThunkHelper(&_pvSecurityThunk);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDocument::QueryService
//
//--------------------------------------------------------------------------

HRESULT
CDocument::QueryService(REFGUID rguidService, REFIID riid, void ** ppvService)
{
    HRESULT     hr = S_OK;
    CDoc  *     pDoc = Doc();
    CWindow *   pWindow = Window();

//
//TODO: FerhanE: Anvui tool should be changed to get rid of this hack here.
//
    if (IsEqualGUID(rguidService, IID_IDispatchEx) &&
        IsEqualGUID(riid,         IID_IDispatchEx))
    {
        hr = THR(GetSecurityThunk(ppvService));
        if (hr)
            goto Cleanup;

        ((IUnknown *)(*ppvService))->AddRef();
    }
    else if (IsEqualGUID(rguidService, SID_SContainerDispatch) || 
        IsEqualGUID(rguidService, IID_IInternetHostSecurityManager) ||
        IsEqualGUID(rguidService, IID_IInternetSecurityManager))
    {
        hr = THR_NOTRACE(QueryInterface(riid, ppvService));
    }
    else if (IsEqualGUID(rguidService, IID_IAccessible))
    {
        // we have to return the IAccessible
        hr = EnsureAccWindow(pWindow);

        if (S_OK == hr)
        {
            hr = THR(pWindow->_pAccWindow->QueryInterface(riid,ppvService));
        }
        else
            hr = E_NOINTERFACE;
    }
    else if (IsEqualGUID(rguidService, CLSID_HTMLWindow2))
    {
        *ppvService = Markup()->GetNearestMarkupForScriptCollection()->Window()->Window();
    }
    else if (  pDoc->_fDefView
            && !Markup()->IsPrimaryMarkup()
            && IsEqualGUID(rguidService, SID_SShellBrowser)
            && IsEqualGUID(riid, IID_IBrowserService))
    {
        hr = THR_NOTRACE(QueryInterface(riid, ppvService));
    }
    else if (pWindow)
    {
        hr = THR_NOTRACE(pWindow->QueryService(rguidService, riid, ppvService));
    }
    else if (Markup())
    {
        hr = THR_NOTRACE(pDoc->QueryService(rguidService, riid, ppvService));
    }
    else
    {
        hr = E_NOINTERFACE;
    }

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CDocument::QueryInterface
//
//--------------------------------------------------------------------------

HRESULT
CDocument::QueryInterface(REFIID iid, LPVOID * ppv)
{
    void *          pv = NULL;
    const void *    apfn = NULL;
    HRESULT         hr;

    if (!ppv)
        RRETURN(E_INVALIDARG);

    CDoc *  pDoc = Doc();

    *ppv = NULL;

    if ( g_fInPip &&
        ( iid == IID_IPersistMoniker ||
          iid == IID_IPersistFile ))
    {
        RRETURN(E_NOINTERFACE);
    }

    switch (iid.Data1)
    {
        QI_TEAROFF(this, IOleCommandTarget, NULL)
        QI_TEAROFF(this, IInternetHostSecurityManager, NULL)
        QI_TEAROFF(this, IOleItemContainer, NULL)
        QI_TEAROFF(this, IPersistHistory, NULL)
        QI_TEAROFF(this, IPersistFile, NULL)
        QI_TEAROFF(this, IPersistStreamInit, NULL)
        QI_TEAROFF2(this, IPersist, IPersistFile, NULL)
        QI_TEAROFF(this, IPersistMoniker, NULL)
        QI_TEAROFF(this, IObjectSafety, NULL)
        QI_TEAROFF2(this, IOleContainer, IOleItemContainer, NULL)
        QI_TEAROFF2(this, IParseDisplayName, IOleItemContainer, NULL)
        QI_TEAROFF(this, IHTMLDOMNode, NULL)
        QI_TEAROFF(this, IHTMLDOMNode2, NULL)
        QI_HTML_TEAROFF(this, IHTMLDocument2, NULL)
        QI_HTML_TEAROFF(this, IHTMLDocument3, NULL)
        QI_HTML_TEAROFF(this, IHTMLDocument4, NULL)
        QI_HTML_TEAROFF(this, IHTMLDocument5, NULL)

        QI_FALLTHRU(IDispatch, IUnknown)
        QI_FALLTHRU(IDispatchEx, IUnknown)
        QI_CASE(IUnknown)
        {
            hr = THR(GetSecurityThunk(ppv));
            if (hr)
                RRETURN (hr);
            break;
        }

        QI_CASE(IHTMLDocument)
        {
            hr = THR(CreateTearOffThunk(this, s_apfnpdIHTMLDocument2, NULL, ppv));
            if (hr)
                RRETURN(hr);
            break;
        }
        QI_CASE(IConnectionPointContainer)
        {
            *((IConnectionPointContainer **)ppv) = new CConnectionPointContainer(this, NULL);
            if (!*ppv)
                RRETURN(E_OUTOFMEMORY);
            break;
        }
        QI_FALLTHRU(IMarkupServices, IMarkupServices2)
        QI_CASE(IMarkupServices2)
        {
            apfn = CDoc::s_apfnIMarkupServices2;
            break;
        }
        QI_CASE(IHighlightRenderingServices)
        {
            apfn = CDoc::s_apfnIHighlightRenderingServices;
            break;
        }
        QI_FALLTHRU(IMarkupContainer, IMarkupContainer2)
        QI_CASE(IMarkupContainer2)
        {
            pv = Markup();
            apfn = CMarkup::s_apfnIMarkupContainer2;
            break;
        }
        QI_CASE(IHTMLChangePlayback)
        {
            pv = Markup();
            apfn = CMarkup::s_apfnIHTMLChangePlayback;
            break;
        }
        QI_CASE(IPersistStream)
        {
            apfn = s_apfnIPersistStreamInit;       // IPersistStreamInit contains everything IPersistStream has.
            pv = this;
            break;
        }
        QI_CASE(IDisplayServices)
        {
            apfn = CDoc::s_apfnIDisplayServices;
            break;
        }
        QI_CASE(IServiceProvider)
        {
            apfn = s_apfnIServiceProvider;
            pv = this;
            break;
        }
        QI_FALLTHRU(IOleWindow, IOleInPlaceObjectWindowless)
        QI_FALLTHRU(IOleInPlaceObject, IOleInPlaceObjectWindowless)
        QI_CASE(IOleInPlaceObjectWindowless)
        {
            apfn = CDoc::s_apfnIOleInPlaceObjectWindowless;
            break;
        }
        QI_CASE(IOleObject)
        {
            apfn = CDoc::s_apfnIOleObject;
            break;
        }
        QI_FALLTHRU(IViewObjectEx, IViewObject2)
        QI_FALLTHRU(IViewObject, IViewObject2)
        QI_CASE(IViewObject2)
        {
            apfn = *(void **)(IViewObjectEx *)pDoc;
            break;
        }
        QI_CASE(IOleControl)
        {
            apfn = CDoc::s_apfnIOleControl;
            break;
        }
        QI_FALLTHRU(IProvideMultipleClassInfo, IProvideClassInfo2)
        QI_FALLTHRU(IProvideClassInfo, IProvideClassInfo2)
        QI_CASE(IProvideClassInfo2)
        {
            apfn = CDoc::s_apfnIProvideMultipleClassInfo;
            break;
        }
        QI_CASE(ISpecifyPropertyPages)
        {
            apfn = CDoc::s_apfnISpecifyPropertyPages;
            break;
        }
        QI_CASE(IInternetSecurityManager)
        {
            pDoc->EnsureSecurityManager();
            *((IInternetSecurityManager **) ppv) = pDoc->_pSecurityMgr;
            break;
        }
#ifdef FANCY_CONNECTION_STUFF
        QI_CASE(IRunnableObject)
        {
            apfn = CDoc::s_apfnIRunnableObject;
            break;
        }
        QI_CASE(IExternalConnection)
        {
            apfn = CDoc::s_apfnIExternalConnection;
            break;
        }
#endif
        QI_CASE(IDataObject)
        {
            apfn = CDoc::s_apfnIDataObject;
            break;
        }
        QI_CASE(IOleDocument)
        {
            apfn = CDoc::s_apfnIOleDocument;
            break;
        }
        QI_FALLTHRU(IOleCache2, IOleCache)
        QI_CASE(IOleCache)
        {
            apfn = CDoc::s_apfnIOleCache2;
            break;
        }
        QI_CASE(IPointerInactive)
        {
            apfn = CDoc::s_apfnIPointerInactive;
            break;
        }
        QI_CASE(ISupportErrorInfo)
        {
            apfn = CDoc::s_apfnISupportErrorInfo;
            break;
        }
        QI_CASE(IPerPropertyBrowsing)
        {
            apfn = CDoc::s_apfnIPerPropertyBrowsing;
            break;
        }
        QI_CASE(IOleInPlaceActiveObject)
        {
            apfn = CDoc::s_apfnIOleInPlaceActiveObject;
            break;
        }
        QI_CASE(IOleDocumentView)
        {
            apfn = CDoc::s_apfnIOleDocumentView;
            break;
        }
#if DBG==1
        QI_CASE(IEditDebugServices)
        {
            apfn = CDoc::s_apfnIEditDebugServices;
            break;
        }
#endif
        QI_CASE(IIMEServices)
        {
            apfn = CDoc::s_apfnIIMEServices;
            break;
        }

        QI_CASE(IBrowserService)
        {
            if (pDoc->_fDefView && !Markup()->IsPrimaryMarkup())
            {
                apfn = s_apfnIBrowserService;
                pv = this;
            }

            break;
        }

        default:
            if (DispNonDualDIID(iid))
            {
                hr = THR(CreateTearOffThunk(
                        this,
                        (void *)CDocument::s_apfnpdIHTMLDocument2,
                        NULL,
                        ppv,
                        (void *)CDocument::s_ppropdescsInVtblOrderIHTMLDocument2));

                if (hr)
                    RRETURN(hr);

                break;
            }
            else if (IsEqualIID(iid, CLSID_CMarkup))
            {
                *ppv = Markup();
                return S_OK;
            } else if (IsEqualIID(iid, CLSID_CDocument))
            {
                *ppv = this;
                return S_OK;
            }
    }

    if (apfn && pDoc)
    {
        hr = THR(CreateTearOffThunk(
                pv ? pv : pDoc,
                apfn,
                NULL,
                ppv,
                (IUnknown *)(IPrivateUnknown *)this,
                *(void **)(IUnknown *)(IPrivateUnknown *)this,
                QI_MASK | ADDREF_MASK | RELEASE_MASK,
                NULL,
                NULL));
        if (hr)
            RRETURN(hr);
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        RRETURN(E_NOINTERFACE);
    }
}


CDoc *
CDocument::Doc()
{
    if (_pMarkup)
    {
        Assert (!_pWindow);
        return _pMarkup->Doc();
    }
    else
    {
        Assert (_pWindow);
        return _pWindow->Doc();
    }
}

CAtomTable *
CDocument::GetAtomTable(BOOL * pfExpando)
{
    CDoc * pDoc = Doc();

    if (pfExpando)
    {
        *pfExpando = GetWindowedMarkupContext()->_fExpando;
    }

    return &pDoc->_AtomTable;
}

HRESULT
CDocument::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    return QueryInterface(iid, ppv);
}

HRESULT
CDocument::QueryStatus(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    HRESULT hr;

    hr = THR(Doc()->QueryStatusHelper(this, pguidCmdGroup, cCmds, rgCmds, pcmdtext));

    RRETURN(hr);
}

HRESULT
CDocument::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    HRESULT hr;

    hr = THR(Doc()->ExecHelper(this, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));

    SRETURN(hr);
}

long
CDocument::GetDocumentReadyState()
{
    CWindow * pWindow = Window();

    if ( pWindow &&
         pWindow->_pMarkupPending &&
         !IsScriptUrl (CMarkup::GetUrl(pWindow->_pMarkupPending) ))
    {
        return pWindow->_pMarkupPending->GetReadyState();
    }

    return Markup()->GetReadyState();
}


HRESULT
CDocument::InvokeEx(DISPID       dispid,
                    LCID         lcid,
                    WORD         wFlags,
                    DISPPARAMS * pdispparams,
                    VARIANT    * pvarResult,
                    EXCEPINFO  * pexcepinfo,
                    IServiceProvider * pSrvProvider)
{
    HRESULT     hr;
    CMarkup *   pMarkup;

    hr = THR(ValidateInvoke(pdispparams, pvarResult, pexcepinfo, NULL));
    if (hr)
        goto Cleanup;

    pMarkup = Markup();

    hr = THR_NOTRACE(ReadyStateInvoke(dispid, wFlags, GetDocumentReadyState(), pvarResult));
    if (hr != S_FALSE)
        goto Cleanup;

    if (DISPID_WINDOWOBJECT == dispid ||
        DISPID_SECURITYCTX == dispid ||
        DISPID_SECURITYDOMAIN == dispid)
    {
        if (!pMarkup->HasWindow())
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        else
        {
            hr = THR(pMarkup->Window()->InvokeEx(dispid,
                                      lcid,
                                      wFlags,
                                      pdispparams,
                                      pvarResult,
                                      pexcepinfo,
                                      pSrvProvider));
        }
    }
    else
    {
        hr = THR(pMarkup->EnsureCollectionCache(CMarkup::NAVDOCUMENT_COLLECTION));
        if (hr)
            goto Cleanup;

        // for IE3 backward compat, doc.Script has a diff dispid than in IE4, so
        // map it to new one.
        if (0x60020000 == dispid)
            dispid = DISPID_CDocument_Script;

        hr = THR_NOTRACE(DispatchInvokeCollection(this,
                                                  super::InvokeEx,
                                                  pMarkup->CollectionCache(),
                                                  CMarkup::NAVDOCUMENT_COLLECTION,
                                                  dispid,
                                                  IID_NULL,
                                                  lcid,
                                                  wFlags,
                                                  pdispparams,
                                                  pvarResult,
                                                  pexcepinfo,
                                                  NULL,
                                                  pSrvProvider));

    }

Cleanup:
    RRETURN_NOTRACE(hr);
}

HRESULT
CDocument::GetDispID(BSTR bstrName,
                   DWORD grfdex,
                   DISPID *pid)
{
    HRESULT hr;

    CMarkup * pMarkup = Markup();

    if (!pMarkup)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(pMarkup->EnsureCollectionCache(CMarkup::NAVDOCUMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(DispatchGetDispIDCollection(this,
                                                 super::GetDispID,
                                                 pMarkup->CollectionCache(),
                                                 CMarkup::NAVDOCUMENT_COLLECTION,
                                                 bstrName,
                                                 grfdex,
                                                 pid));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(THR_NOTRACE(hr));
}

HRESULT
CDocument::GetNextDispID(DWORD grfdex,
                       DISPID id,
                       DISPID *prgid)
{
    HRESULT     hr;

    hr = THR(Markup()->EnsureCollectionCache(CMarkup::NAVDOCUMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    // Notice here that we set the fIgnoreOrdinals to TRUE for Nav compatability
    // We don't want ordinals in the document name space
    hr = DispatchGetNextDispIDCollection(this,
                                         super::GetNextDispID,
                                         Markup()->CollectionCache(),
                                         CMarkup::NAVDOCUMENT_COLLECTION,
                                         grfdex,
                                         id,
                                         prgid);

Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CDocument::GetMemberName(DISPID id,
                       BSTR *pbstrName)
{
    HRESULT     hr;

    hr = THR(Markup()->EnsureCollectionCache(CMarkup::NAVDOCUMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = DispatchGetMemberNameCollection(this,
                                         super::GetMemberName,
                                         Markup()->CollectionCache(),
                                         CMarkup::NAVDOCUMENT_COLLECTION,
                                         id,
                                         pbstrName);

Cleanup:
    RRETURN(hr);
}

HRESULT
CDocument::GetNameSpaceParent(IUnknown **ppunk)
{
    CMarkup * pMarkup = Markup()->GetNearestMarkupForScriptCollection();
    
#if DBG==1
    // optionally secure the window proxy given to script engine
    if (IsTagEnabled(tagSecureScriptWindow))
    {
        CScriptCollection *pSC = pMarkup->GetScriptCollection();
        Assert(pSC);
        Assert(pSC->_pSecureWindowProxy);
        Assert(!pSC->_pSecureWindowProxy->_fTrusted);
        HRESULT hr = pSC->_pSecureWindowProxy->QueryInterface(IID_IDispatchEx, (void **)ppunk);
        RRETURN(hr);
    }
#endif

    if ( pMarkup->HasWindowPending() )
    {
        RRETURN(pMarkup->GetWindowPending()->QueryInterface(IID_IDispatchEx, (void **)ppunk));
    }
    else
    {
        AssertSz(0,"no window");
        return E_FAIL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocument::OnPropertyChange
//
//  Synopsis:   Invalidate, fire property change, and so on.
//
//  Arguments:  [dispidProperty] -- PROPID of property that changed
//              [dwFlags]        -- Flags to inhibit behavior
//
//----------------------------------------------------------------------------
HRESULT
CDocument::OnPropertyChange(DISPID dispidProp, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;
    CDoc * pDoc = Doc();

    Assert( !ppropdesc || ppropdesc->GetDispid() == dispidProp );
    //Assert( !ppropdesc || ppropdesc->GetdwFlags() == dwFlags );


    switch (dispidProp)
    {
        case DISPID_BACKCOLOR :
            pDoc->OnAmbientPropertyChange(DISPID_AMBIENT_BACKCOLOR);
            break;

        case DISPID_FORECOLOR :
            pDoc->OnAmbientPropertyChange(DISPID_AMBIENT_FORECOLOR);
            break;

        case DISPID_A_DIR :
            pDoc->OnAmbientPropertyChange(DISPID_AMBIENT_RIGHTTOLEFT);
            break;
        case DISPID_OMDOCUMENT+14:  // designMode
            pDoc->SetDesignMode(this, GetAAdesignMode());
            break;

    }

    if ((dwFlags & (SERVERCHNG_NOVIEWCHANGE|FORMCHNG_NOINVAL)) == 0)
    {
        pDoc->Invalidate();
    }

    if (dwFlags & ELEMCHNG_CLEARCACHES )
    {
        Markup()->Root()->GetFirstBranch()->VoidCachedInfo();
    }

    if (dwFlags & FORMCHNG_LAYOUT)
    {
        Markup()->Root()->ResizeElement(NFLAGS_FORCE);
    }

    // Don't fire OnPropertyChange for designmode - at least, we didn't before.
    if (Markup()->IsPrimaryMarkup() && dispidProp != DISPID_OMDOCUMENT+14)
    {
        Verify(!pDoc->CServer::OnPropertyChange(dispidProp, dwFlags, ppropdesc));
    }

    if (!(dwFlags & SERVERCHNG_NOPROPCHANGE))
    {
        IGNORE_HR(FireOnChanged(dispidProp));
    }

    // Let's special case something here.  If dispidProp == DISPID_IHTMLDOCUMENT2_ACTIVEELEMENT
    // then find the pTridentSvc and notify top-level browser (which should be listening for Intelliforms)
    //
    if (dispidProp == DISPID_CDocument_activeElement && pDoc->_pTridentSvc)
    {
        IHTMLElement *pEle=NULL;

        get_activeElement(&pEle);

        // Send it up even if NULL
        pDoc->_pTridentSvc->ActiveElementChanged(pEle);

        if (pEle)
            pEle->Release();
    }

    // see todo in CElement:OnPropertyChange
    // if ( fSomeoneIsListening )

    // Post the call to fire onpropertychange if dispid is that of activeElement, this
    // is so that the order of event firing is maintained in SetCurrentElem.
    if (dispidProp == DISPID_CDocument_activeElement)
        hr = THR(GWPostMethodCall(this, ONCALL_METHOD(CDocument, FirePostedOnPropertyChange, firepostedonpropertychange), 0, TRUE, "CDoc::FirePostedOnPropertyChange"));
    else
        hr = THR(Fire_PropertyChangeHelper(dispidProp, dwFlags, ppropdesc));

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocument::Fire_PropertyChangeHelper
//
//
//+---------------------------------------------------------------------------
HRESULT
CDocument::Fire_PropertyChangeHelper(DISPID dispidProperty, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;
    LPCTSTR pszName;
    PROPERTYDESC *pPropDesc = (PROPERTYDESC *)ppropdesc;

    if (pPropDesc)
    {
        Assert(dispidProperty == pPropDesc->GetDispid());
        //Assert(dwFlags == pPropDesc->GetdwFlags());
    }
    else
    {
        hr = THR(FindPropDescFromDispID(dispidProperty, &pPropDesc, NULL, NULL));
    }

    if (hr)
        goto Cleanup;

    Assert(pPropDesc);

    pszName = pPropDesc->pstrExposedName ? pPropDesc->pstrExposedName : pPropDesc->pstrName;

    if (pszName != NULL)
    {
        Fire_onpropertychange(pszName);
    }

Cleanup:
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDocument::Fire_onpropertychange
//
//  Synopsis:   Fires the onpropertychange event, sets up the event param
//
//+----------------------------------------------------------------------------

void
CDocument::Fire_onpropertychange(LPCTSTR strPropName)
{
    EVENTPARAM param(Doc(), NULL, Markup(), TRUE);

    param.SetType(s_propdescCDocumentonpropertychange.a.pstrName + 2);
    param.SetPropName(strPropName);

    FireEvent(Doc(), DISPID_EVMETH_ONPROPERTYCHANGE, DISPID_EVPROP_ONPROPERTYCHANGE);
}

//+----------------------------------------------------------------------------
//
//  Member:     open, IOmDocument
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::open(BSTR mimeType, VARIANT varName, VARIANT varFeatures, VARIANT varReplace,
                    /* retval */ IDispatch **ppDisp)
{
    CDoc::LOADINFO   LoadInfo = { 0 };
    HRESULT          hr = S_OK;
    CStr             cstrCallerURL;
    SSL_SECURITY_STATE sssCaller;
    VARIANT        * pvarName, * pvarFeatures, * pvarReplace;
    CVariant         vRep;
    BOOL             fReplace = FALSE;
    BSTR             bstrFullUrl = NULL;
    CMarkup        * pMarkup = Markup();
    CMarkup        * pMarkupNew = NULL;
    COmWindowProxy * pOmWindow;
    CDoc           * pDoc = Doc();
    DWORD            dwTLFlags = 0;

    if (ppDisp)
        *ppDisp = NULL;
    
    Assert(pMarkup);

    if (!pMarkup->HasWindow())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pvarName = (V_VT(&varName) == (VT_BYREF | VT_VARIANT)) ?
            V_VARIANTREF(&varName) : &varName;

    pvarFeatures = (V_VT(&varFeatures) == (VT_BYREF | VT_VARIANT)) ?
            V_VARIANTREF(&varFeatures) : &varFeatures;

    pvarReplace = (V_VT(&varReplace) == (VT_BYREF | VT_VARIANT)) ?
            V_VARIANTREF(&varReplace) : &varReplace;

    // If parameter 3 is specified consider the call window.open
    if (!ISVARIANTEMPTY(pvarFeatures))
    {
        BSTR            bstrName, bstrFeatures;
        VARIANT_BOOL    vbReplace;

        // Check the parameter types
        if (V_VT(pvarName) != VT_BSTR ||
            (!ISVARIANTEMPTY(pvarFeatures) &&  V_VT(pvarFeatures) != VT_BSTR))
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        bstrName = (ISVARIANTEMPTY(pvarName)) ? NULL : V_BSTR(pvarName);
        bstrFeatures = (ISVARIANTEMPTY(pvarFeatures)) ? NULL : V_BSTR(pvarFeatures);

        if (!ISVARIANTEMPTY(pvarReplace))
        {
            if (vRep.CoerceVariantArg(pvarReplace, VT_BOOL) != S_OK)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }

            vbReplace = V_BOOL(&vRep);
        }
        else
        {
            vbReplace = VB_FALSE;
        }

        hr = THR(GetFullyExpandedUrl(this, mimeType, &bstrFullUrl));
        if (hr)
            goto Cleanup;

        // In this case mimiType contains the URL
        // TODO (scotrobe): Bad - do not cast the ppDisp to an
        // IHTMLWindow2. It may not be a window. 
        //
        hr = THR(MyCWindow()->_pWindowProxy->open(bstrFullUrl, bstrName, bstrFeatures,
                                        vbReplace, (IHTMLWindow2 **) ppDisp));
        goto Cleanup;
    }



    // If we're running script then do nothing.
    if (pMarkup->HtmCtx())
    {
        if (pMarkup->IsInScriptExecution())
        {
            goto Cleanup;
        }

#if DBG==1
        // Any pending bindings then abort them.
        // Note that shdocvw forces READYSTATE_COMPLETE on subframes when we do this,
        // so don't assert when we notice that shdocvw's readystate is different from
        // the hosted doc (tagReadystateAssert is used in frmsite.cxx)
        BOOL fOldReadyStateAssert = IsTagEnabled(tagReadystateAssert);

        EnableTag(tagReadystateAssert, FALSE);
#endif

        if (pDoc->_pClientSite && pMarkup->IsPrimaryMarkup())
        {
            IGNORE_HR(CTExec(pDoc->_pClientSite,
                             &CGID_ShellDocView,
                             SHDVID_DOCWRITEABORT,
                             0,
                             NULL,
                             NULL));
        }

#if DBG==1
        EnableTag(tagReadystateAssert, fOldReadyStateAssert);
#endif
    }

    // If second argument is "replace", set replace
    if (V_VT(pvarName) == VT_BSTR)
    {
        if (V_BSTR(pvarName) && !StrCmpI(V_BSTR(pvarName),_T("replace")))
        {
            fReplace = TRUE;
        }
    }

    if (mimeType)
    {
        const MIMEINFO * pmi = GetMimeInfoFromMimeType(mimeType);

        // TODO: (TerryLu) If we can't find the known mimetype then to match
        //  Navigator we need to be able to open a plugin from a list of
        //  plugins.  Navigator will as well allow going to netscape page
        //  on plugins.  This is a task which needs to be done.

        if (pmi && pmi->pfnImg)
        {
            // TODO: (dinartem) We don't support opening image formats yet.
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        LoadInfo.pmi = pmi;
    }

    //
    // open implies close() if needed
    //

    if (pMarkup->HtmCtx() && pMarkup->HtmCtx()->IsOpened())
    {
        hr = THR(close());
        if (hr)
            goto Cleanup;
    }

    //
    // discover the calling doc's URL and security state
    // fire_onunload can stomp the DISPID_INTERNAL_INVOKECONTEXT,
    // so we need to get the security state/url out first
    //

    hr = THR(GetCallerSecurityStateAndURL(&sssCaller, cstrCallerURL, this, NULL));

    if (!SUCCEEDED(hr))
    {
        goto Cleanup;
    }

    //
    // Before starting the unload sequence, fire onbeforeunload and allow abort
    //

    pOmWindow = pMarkup->Window();
    Assert(pOmWindow);

    if (!pOmWindow->Fire_onbeforeunload())
    {
        goto Cleanup;
    }

    //
    // Right before clearing out the document, ask the shell to
    // create a history entry. (exception: replace history if
    // "replace" was specified or if opening over an about: page)
    //

    if (pDoc->_pInPlace && pDoc->_pInPlace->_pInPlaceSite)
    {
        CVariant var(VT_BSTR);
        const TCHAR * pchUrl = CMarkup::GetUrl(pMarkup);

        hr = cstrCallerURL.AllocBSTR(&V_BSTR(&var));
        if (hr)
            goto Cleanup;

        if (    pMarkup->IsPrimaryMarkup()
            &&  (fReplace || !pchUrl || !*pchUrl || GetUrlScheme(pchUrl) == URL_SCHEME_ABOUT))
        {
            IGNORE_HR(CTExec(pDoc->_pInPlace->_pInPlaceSite,
                             &CGID_Explorer,
                             SBCMDID_REPLACELOCATION,
                             0, &var, 0));

            LoadInfo.fDontUpdateTravelLog = TRUE;

        }
    } 

    if(fReplace)
    {
        LoadInfo.fDontUpdateTravelLog = TRUE;
    }

    LoadInfo.codepage        = CP_UCS_2;
    LoadInfo.fKeepOpen       = TRUE;
    LoadInfo.pchDisplayName  = cstrCallerURL;

    // TODO (MohanB) We should retain UrlOriginal if the caller is this document
    // LoadInfo.pchUrlOriginal  = const_cast<TCHAR*>(CMarkup::GetUrlOriginal(pMarkup));

    LoadInfo.fUnsecureSource = (sssCaller <= SSL_SECURITY_MIXED);

    hr = pDoc->CreateMarkup(&pMarkupNew, NULL, NULL, FALSE, pMarkup->Window());
    if (hr)
        goto Cleanup;

    LoadInfo.fDontFireWebOCEvents = TRUE;

    //
    // Since we are not loading this markup with a bind context, the LoadFromInfo
    // will not have a chance to call the SetAACreatorUrl.
    // In case this is a special URL, we set the creator URL here
    //
    if (IsSpecialUrl(cstrCallerURL))
    {
        TCHAR * pchCreatorUrl;

        pchCreatorUrl = (TCHAR *)pMarkup->GetAAcreatorUrl();

        TraceTag((tagSecurityContext,
                    "CDocument::open- Caller URL: %ws Existing Markup: 0x%x CreatorUrl: %ws",
                    (LPTSTR)cstrCallerURL, pMarkup, pchCreatorUrl));

        if (pchCreatorUrl && *pchCreatorUrl)
        {
            TraceTag((tagSecurityContext,
                        "CDocument::open- Set creator URL on new Markup:0x%x to URL:%ws",
                        pMarkupNew, pchCreatorUrl));

            pMarkupNew->SetAAcreatorUrl(pchCreatorUrl);
        }
        else
        {
            TraceTag((tagSecurityContext,
                        "CDocument::open- Set creator URL on new Markup:0x%x to URL:%ws",
                        pMarkupNew, (TCHAR *)CMarkup::GetUrl(pMarkup)));

            pMarkupNew->SetAAcreatorUrl((TCHAR *)CMarkup::GetUrl(pMarkup));
        }
    }

    hr = THR(pMarkupNew->LoadFromInfo(&LoadInfo));

    if (hr)
        goto Cleanup;

    pMarkup->Window()->Window()->UpdateWindowData(NO_POSITION_COOKIE);

    // If the document.open() happens during a history
    // navigation (i.e., back/forward), we don't want to
    // update the travel log because it has already been
    // updated. Doing so will cause extra travel log entries.
    //
    if (!pMarkup->_fLoadingHistory && !pMarkup->_fNewWindowLoading)
    {
        dwTLFlags |= COmWindowProxy::TLF_UPDATETRAVELLOG
                  |  COmWindowProxy::TLF_UPDATEIFSAMEURL;
    }

    pMarkup->Window()->SwitchMarkup(pMarkupNew, FALSE, dwTLFlags, TRUE);

    // Write a unicode signature in case we need to reload this document

    Assert(pMarkupNew->HtmCtx());

    pMarkupNew->HtmCtx()->WriteUnicodeSignature();

    hr = S_OK;

    if (ppDisp)
    {
        Assert(this == pMarkupNew->Document());
        hr = THR(pMarkupNew->Document()->QueryInterface(IID_IHTMLDocument2, (void**)ppDisp));
    }

Cleanup:
    if (pMarkupNew)
    {
        pMarkupNew->Release();
    }

    FormsFreeString(bstrFullUrl);

    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     write
//
//  Synopsis:   Automation method,
//              inserts the specified HTML into the preparser
//
//----------------------------------------------------------------------------
HRESULT
CDocument::write(SAFEARRAY * psarray)
{
    HRESULT             hr = S_OK;
    CVariant            varstr;
    long                iArg, cArg;
    IUnknown *          pUnkCaller = NULL;
    IServiceProvider *  pSrvProvider = NULL;
    CMarkup *           pMarkup = Markup();

    Assert(pMarkup);

    if (    !pMarkup->IsInScriptExecution()
        &&  (   pMarkup->LoadStatus() == LOADSTATUS_DONE
             || !pMarkup->HtmCtx()
             || !pMarkup->HtmCtx()->IsOpened()))
    {
        hr = THR(open(NULL, varstr, varstr, varstr, NULL));
        if (hr)
            goto Cleanup;
    }

    TraceTag((tagSecurityContext, "CDocument::write called"));

    pMarkup = Markup();    // CDocument::open creates a new markup

    Assert(pMarkup->HtmCtx());

    if (psarray == NULL || SafeArrayGetDim(psarray) != 1)
        goto Cleanup;

    cArg = psarray->rgsabound[0].cElements;

    // If we have a caller context (Established by IDispatchEx::InvokeEx,
    // use this to when converting the value in the safearray.
    GetUnknownObjectAt(FindAAIndex(DISPID_INTERNAL_INVOKECONTEXT,
                                   CAttrValue::AA_Internal),
                       &pUnkCaller);
    if (pUnkCaller)
    {
        IGNORE_HR(pUnkCaller->QueryInterface(IID_IServiceProvider,
                                             (void**)&pSrvProvider));

        CStr cstrCallerURL;
        SSL_SECURITY_STATE sssCaller;

        // Do mixed security check now: pick up URL
        hr = THR(GetCallerSecurityStateAndURL(&sssCaller, cstrCallerURL, this, NULL));
        if (!SUCCEEDED(hr))
            goto Cleanup;

        if (!pMarkup->ValidateSecureUrl(pMarkup->IsPendingRoot(), cstrCallerURL, FALSE, TRUE, sssCaller <= SSL_SECURITY_MIXED))
            goto Cleanup;
    }

    for (iArg = 0; iArg < cArg; ++iArg)
    {
        VariantInit(&varstr);

        hr = SafeArrayGetElement(psarray, &iArg, &varstr);

        if (hr == S_OK)
        {
            hr = VariantChangeTypeSpecial(&varstr, &varstr, VT_BSTR, pSrvProvider);
            if (hr == S_OK)
            {
                Doc()->_iDocDotWriteVersion++;
                hr = THR(pMarkup->HtmCtx()->Write(varstr.bstrVal, TRUE));
            }

            VariantClear(&varstr);
        }

        if (hr)
            break;
    }

    //  bump up the count, this reduces the overall number of
    //      iterations that can happen before we prompt for denial of service
    //      (see CWindow::QueryContinueScript
    Assert(GetWindowedMarkupContext()->GetWindowPending());
    GetWindowedMarkupContext()->GetWindowPending()->Window()->ScaleHeavyStatementCount();

Cleanup:
    ReleaseInterface(pSrvProvider);
    ReleaseInterface(pUnkCaller);

    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     writeln
//
//  Synopsis:   Automation method,
//              inserts the sepcified HTML into the preparser
//
//----------------------------------------------------------------------------
HRESULT
CDocument::writeln(SAFEARRAY * psarray)
{
    HRESULT hr;
    CMarkup * pMarkup;

    hr = THR(write(psarray));

    pMarkup = Markup();

    Assert(pMarkup);

    if ((hr == S_OK) && pMarkup->HtmCtx())
    {
        hr = THR(pMarkup->HtmCtx()->Write(_T("\r\n"), TRUE));
    }

    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     close, IOmDocument
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::close(void)
{
    CMarkup * pMarkup = Markup();

    Assert(pMarkup);

    // Don't allow a document.close if a document.open didn't happen

    if (    !pMarkup->HtmCtx()
        ||  !pMarkup->HtmCtx()->IsOpened()
        ||  !pMarkup->GetProgSinkC())
        goto Cleanup;

    pMarkup->HtmCtx()->Close();
    pMarkup->GetProgSinkC()->OnMethodCall((DWORD_PTR) pMarkup->GetProgSinkC());

    Assert(!pMarkup->HtmCtx()->IsOpened());

Cleanup:
    return(S_OK);
}

HRESULT
CDocument::clear(void)
{
    // This routine is a no-op under Navigator and IE.  Use document.close
    // followed by document.open to clear all elements in the document.

    return S_OK;
}



//+----------------------------------------------------------------------------
//
// Member:      CDocument::GetInterfaceSafetyOptions
//
// Synopsis:    per IObjectSafety
//
//-----------------------------------------------------------------------------

HRESULT
CDocument::GetInterfaceSafetyOptions(
    REFIID riid,
    DWORD *pdwSupportedOptions,
    DWORD *pdwEnabledOptions)
{
    // TODO CDoc doesn't do much, but is this the right thing for a markup?
    return Doc()->GetInterfaceSafetyOptions(riid, pdwSupportedOptions, pdwEnabledOptions);
}


//+----------------------------------------------------------------------------
//
// Member:      CDoc::SetInterfaceSafetyOptions
//
// Synopsis:    per IObjectSafety
//
//-----------------------------------------------------------------------------

HRESULT
CDocument::SetInterfaceSafetyOptions(
    REFIID riid,
    DWORD dwOptionSetMask,
    DWORD dwEnabledOptions)
{
    // TODO CDoc doesn't do much, but is this the right thing for a markup?
    return Doc()->SetInterfaceSafetyOptions(riid, dwOptionSetMask, dwEnabledOptions);
}


//+----------------------------------------------------------------------------
//
//  Member:     get_bgColor, IOmDocument
//
//  Synopsis: defers to body get_bgcolor
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_bgColor(VARIANT * p)
{
    CBodyElement      * pBody;
    HRESULT             hr;
    CColorValue         Val;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = Markup()->GetBodyElement(&pBody);
    if(FAILED(hr))
        goto Cleanup;
    Assert(hr == S_FALSE || pBody != NULL);

    if(hr != S_OK)
    {
        // assume its a frameset or we're before the body has been created
        //   get the doc's default
        Val = GetAAbgColor();
    }
    else
    {
        Val = pBody->GetFirstBranch()->GetCascadedbackgroundColor();
    }

    // Allocates and returns BSTR that represents the color as #RRGGBB
    V_VT(p) = VT_BSTR;
    hr = THR(CColorValue::FormatAsPound6Str(&(V_BSTR(p)), Val.IsDefined() ? Val.GetColorRef() : Doc()->_pOptionSettings->crBack()));

Cleanup:
    RRETURN( SetErrorInfo(hr) );
}

//+----------------------------------------------------------------------------
//
//  Member:     put_bgColor, IOmDocument
//
//  Synopsis: defers to body put_bgcolor
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::put_bgColor(VARIANT p)
{
    IHTMLBodyElement * pBody = NULL;
    HRESULT            hr;
    CMarkup *          pMarkup = Markup();

    Assert(pMarkup);

    IGNORE_HR(pMarkup->GetBodyElement(&pBody));

    // this only goes up
    pMarkup->OnLoadStatus(LOADSTATUS_INTERACTIVE);

    if (!pBody)
    {
        // its NOT a body element. assume Frameset.
        hr = THR(s_propdescCDocumentbgColor.b.SetColorProperty(p, this,
                    (CVoid *)(void *)(GetAttrArray())));
        if(hr)
            goto Cleanup;

        // Force a repaint and transition to a load-state where
        // we are allowed to redraw.
        Doc()->GetView()->Invalidate((CRect *)NULL, TRUE);
    }
    else
    {
        // we have a body tag
        hr = THR(pBody->put_bgColor(p));
        ReleaseInterface(pBody);

        Doc()->GetView()->EnsureView(LAYOUT_DEFEREVENTS | LAYOUT_SYNCHRONOUSPAINT);

        if (hr ==S_OK)
            Fire_PropertyChangeHelper(DISPID_CDocument_bgColor, 0, (PROPERTYDESC *)&s_propdescCDocumentbgColor);

    }

Cleanup:
    RRETURN( SetErrorInfo(hr) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_fgColor, IOmDocument
//
//  Synopsis: defers to body get_text
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_fgColor(VARIANT * p)
{
    CBodyElement      * pBody;
    HRESULT             hr;
    CColorValue         Val;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = Markup()->GetBodyElement(&pBody);
    if(FAILED(hr))
        goto Cleanup;
    Assert(hr == S_FALSE || pBody != NULL);

    if(hr != S_OK)
    {
        // assume its a frameset or we're before the body has been created
        //   get the doc's default
        Val = GetAAfgColor();
    }
    else
    {
        Val = pBody->GetFirstBranch()->GetCascadedcolor();
    }

    // Allocates and returns BSTR that represents the color as #RRGGBB
    V_VT(p) = VT_BSTR;
    hr = THR(CColorValue::FormatAsPound6Str(&(V_BSTR(p)), Val.IsDefined() ? Val.GetColorRef() : Doc()->_pOptionSettings->crText()));

Cleanup:
    RRETURN( SetErrorInfo(hr) );
}

//+----------------------------------------------------------------------------
//
//  Member:     put_fgColor, IOmDocument
//
//  Synopsis: defers to body put_text
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::put_fgColor(VARIANT p)
{
    IHTMLBodyElement * pBody = NULL;
    HRESULT        hr;

    IGNORE_HR(Markup()->GetBodyElement(&pBody));
    if (!pBody)
    {
        hr = THR(s_propdescCDocumentfgColor.b.SetColorProperty(p, this,
                    (CVoid *)(void *)(GetAttrArray())));
    }
    else
    {
        hr = THR(pBody->put_text(p));
        ReleaseInterface(pBody);
        if (hr == S_OK)
            Fire_PropertyChangeHelper(DISPID_CDocument_fgColor, 0, (PROPERTYDESC *)&s_propdescCDocumentfgColor);
    }

    RRETURN( SetErrorInfo(hr) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_linkColor, IOmDocument
//
//  Synopsis: defers to body get_link
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_linkColor(VARIANT * p)
{
    CBodyElement      * pBody;
    HRESULT             hr;
    CColorValue         Val;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = Markup()->GetBodyElement(&pBody);
    if(FAILED(hr))
        goto Cleanup;
    Assert(hr == S_FALSE || pBody != NULL);

    if(hr != S_OK)
    {
        // assume its a frameset or we're before the body has been created
        //   get the doc's default
        Val = GetAAlinkColor();
    }
    else
    {
        Val = pBody->GetAAlink();
    }

    // Allocates and returns BSTR that represents the color as #RRGGBB
    V_VT(p) = VT_BSTR;
    hr = THR(CColorValue::FormatAsPound6Str(&(V_BSTR(p)), Val.IsDefined() ? Val.GetColorRef() : Doc()->_pOptionSettings->crAnchor()));

Cleanup:
    RRETURN( SetErrorInfo(hr) );
}

//+----------------------------------------------------------------------------
//
//  Member:     put_linkColor, IOmDocument
//
//  Synopsis: defers to body put_link
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::put_linkColor(VARIANT p)
{
    IHTMLBodyElement * pBody = NULL;
    HRESULT        hr;

    IGNORE_HR(Markup()->GetBodyElement(&pBody));
    if (!pBody)
    {
        hr = THR(s_propdescCDocumentlinkColor.b.SetColorProperty(p, this,
                    (CVoid *)(void *)(GetAttrArray())));
    }
    else
    {
        hr = THR(pBody->put_link(p));
        ReleaseInterface(pBody);
        if (hr==S_OK)
            Fire_PropertyChangeHelper(DISPID_CDocument_linkColor, 0, (PROPERTYDESC *)&s_propdescCDocumentlinkColor);
    }

    RRETURN( SetErrorInfo(hr) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_alinkColor, IOmDocument
//
//  Synopsis: defers to body get_aLink
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_alinkColor(VARIANT * p)
{
    CBodyElement      * pBody;
    HRESULT             hr;
    CColorValue         Val;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = Markup()->GetBodyElement(&pBody);
    if(FAILED(hr))
        goto Cleanup;
    Assert(hr == S_FALSE || pBody != NULL);

    if(hr != S_OK)
    {
        // assume its a frameset or we're before the body has been created
        //   get the doc's default
        Val = GetAAalinkColor();
    }
    else
    {
        Val = pBody->GetAAaLink();
    }

    // Allocates and returns BSTR that represents the color as #RRGGBB
    V_VT(p) = VT_BSTR;
    hr = THR(CColorValue::FormatAsPound6Str(&(V_BSTR(p)), Val.IsDefined() ? Val.GetColorRef() : Doc()->_pOptionSettings->crAnchor()));

Cleanup:
    RRETURN( SetErrorInfo(hr) );
}

//+----------------------------------------------------------------------------
//
//  Member:     put_alinkColor, IOmDocument
//
//  Synopsis: defers to body put_aLink
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::put_alinkColor(VARIANT p)
{
    IHTMLBodyElement * pBody = NULL;
    HRESULT        hr;

    IGNORE_HR(Markup()->GetBodyElement(&pBody));
    if (!pBody)
    {
        hr = THR(s_propdescCDocumentalinkColor.b.SetColorProperty(p, this,
                    (CVoid *)(void *)(GetAttrArray())));
    }
    else
    {
        hr = THR(pBody->put_aLink(p));
        ReleaseInterface(pBody);
        if (hr==S_OK)
            Fire_PropertyChangeHelper(DISPID_CDocument_alinkColor, 0, (PROPERTYDESC *)&s_propdescCDocumentalinkColor);
    }

    RRETURN( SetErrorInfo(hr) );
}

//+----------------------------------------------------------------------------
//
//  Member:     get_vlinkColor, IOmDocument
//
//  Synopsis: defers to body get_vLink
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_vlinkColor(VARIANT * p)
{
    CBodyElement      * pBody;
    HRESULT             hr;
    CColorValue         Val;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = Markup()->GetBodyElement(&pBody);
    if(FAILED(hr))
        goto Cleanup;
    Assert(hr == S_FALSE || pBody != NULL);

    if(hr != S_OK)
    {
        // assume its a frameset or we're before the body has been created
        //   get the doc's default
        Val = GetAAvlinkColor();
    }
    else
    {
        Val = pBody->GetAAvLink();
    }

    // Allocates and returns BSTR that represents the color as #RRGGBB
    V_VT(p) = VT_BSTR;
    hr = THR(CColorValue::FormatAsPound6Str(&(V_BSTR(p)), Val.IsDefined() ? Val.GetColorRef() : Doc()->_pOptionSettings->crAnchorVisited()));

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     put_vlinkColor, IOmDocument
//
//  Synopsis: defers to body put_vLink
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::put_vlinkColor(VARIANT p)
{
    IHTMLBodyElement * pBody = NULL;
    HRESULT            hr;

    IGNORE_HR(Markup()->GetBodyElement(&pBody));
    if (!pBody)
    {
        // not a body, assume frameset
        hr = THR(s_propdescCDocumentvlinkColor.b.SetColorProperty(p, this,
                    (CVoid *)(void *)(GetAttrArray())));
    }
    else
    {
        hr = THR(pBody->put_vLink(p));
        ReleaseInterface(pBody);
        if (hr==S_OK)
            Fire_PropertyChangeHelper(DISPID_CDocument_vlinkColor, 0, (PROPERTYDESC *)&s_propdescCDocumentvlinkColor);
    }

    RRETURN( SetErrorInfo(hr) );
}

HRESULT
CDocument::get_parentWindow(IHTMLWindow2 **ppWindow)
{
    HRESULT             hr;
    CMarkup *           pMarkup = Markup();
    COmWindowProxy *    pWindow;
    CVariant            varWindow(VT_DISPATCH);
    CVariant            varRes(VT_DISPATCH);

    if ( ppWindow )
        *ppWindow = NULL;

    Assert(pMarkup);
    if (!pMarkup)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pWindow = pMarkup->GetFrameOrPrimaryMarkup()->Window();
    AssertSz (pWindow, "Frame or primary markup does not have window - this should be an impossible sitation");
    if (!pWindow)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    V_DISPATCH(&varWindow) = (IHTMLWindow2 *)pWindow;
    pWindow->AddRef();

    hr = pWindow->SecureObject( &varWindow, &varRes, NULL, this);

    if (!hr)
    {
        *ppWindow = ((IHTMLWindow2 *)V_DISPATCH(&varRes));
        (*ppWindow)->AddRef();
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     activeElement, IOmDocument
//
//  Synopsis: returns a pointer to the active element (the element with the focus)
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_activeElement(IHTMLElement ** ppElement)
{
    HRESULT     hr = S_OK;
    CDoc    *   pDoc = Doc();
    CMarkup *   pMarkup = Markup();

    if (!ppElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppElement = NULL;

    if (pDoc->_pElemCurrent && pDoc->_pElemCurrent != pDoc->PrimaryRoot())
    {
        CElement * pTarget = pDoc->_pElemCurrent;

        //
        // Marka - check that currency and context are in sync. It IS valid for them to be out
        // of sync ONLY if we have a selection in an HTMLArea or similar control and have clicked
        // away on a button (ie lost focus in the control that has selection).
        //
        // OR We're not in designmode
        //
        // We leave this assert here to assure that currency and context are in sync during the places
        // in the Drt that get_activeElement is called (eg. during siteselect.js).
        //
#ifdef SET_EDIT_CONTEXT
        AssertSz(( !pDoc->_pElemEditContext ||
                   ! pDoc->_fDesignMode ||
                  pDoc->_pElemEditContext == pDoc->_pElemCurrent ||
                 ( pDoc->_pElemEditContext->TestLock(CElement::ELEMENTLOCK_FOCUS ))||
                 ( pDoc->_pElemEditContext->GetMasterPtr()->TestLock(CElement::ELEMENTLOCK_FOCUS )) ||
                  (pDoc->_pElemEditContext && pDoc->_pElemEditContext->GetMasterPtr() == pDoc->_pElemCurrent)), "Currency and context do not match" );
#endif


        // if an area has focus, we have to report that
        if (pDoc->_pElemCurrent->Tag() == ETAG_IMG && pDoc->_lSubCurrent >= 0)
        {
            CAreaElement * pArea = NULL;
            CImgElement *pImg = DYNCAST(CImgElement, pDoc->_pElemCurrent);

            if (pImg->GetMap())
            {
                pImg->GetMap()->GetAreaContaining(pDoc->_lSubCurrent, &pArea);
                pTarget = pArea;
            }
        }

        // now that we have a target element, let's make sure that we return
        // something in the CDocument which received the call.
        if (pTarget->GetMarkup() != pMarkup)
        {
            // the element is not in the markup that this CDocument is attached to.

            // Is it in a markup that this one contains ?
            CTreeNode * pNode = pTarget->GetFirstBranch();
            Assert(pNode);
            pNode = pNode->GetNodeInMarkup(pMarkup);

            //
            // TODO: right fix is to cache elemActive per Markup
            //

            if (!pNode)
            {
                pTarget = NULL;
                if (    pMarkup->LoadStatus() >= LOADSTATUS_DONE
                    &&  pMarkup->Root()->HasMasterPtr())
                {
                    CElement * pElemMaster = pMarkup->Root()->GetMasterPtr();

                    if (    pElemMaster->Tag() == ETAG_FRAME
                        ||  pElemMaster->Tag() == ETAG_IFRAME)
                    {
                        pTarget = pMarkup->GetElementClient();
                    }
                }
                if (!pTarget)
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }
            }
            else
            {
                pTarget = pNode->Element();
            }

            Assert(pTarget);
        }

        // all other cases fall through
        IGNORE_HR(pTarget->QueryInterface(IID_IHTMLElement,
                                          (void**) ppElement));
    }

    if (*ppElement == NULL && pDoc->_fVID && !pDoc->_fVID7)
        hr = E_FAIL;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member  : GetMarkupUrl
//
//  Synopsis: returns the raw, uncanonicalized, url of this document. If
//            fOriginal is TRUE, then return the original URL, otherwise
//            the one obtained from the moniker after URLMON transformations.
//
//-----------------------------------------------------------------------------

HRESULT
CDocument::GetMarkupUrl(CStr * const pcstrRetString, BOOL fOriginal)
{
    HRESULT   hr;
    CMarkup * pMarkup       = Markup();
    LPCTSTR   pchUrl        = NULL;
    CDoc *pDoc = Doc();

    // HACKALERT (sramani) Photo Suite III calls get_URL before waiting for any
    // document complete events while navigating and it expects to get the URL
    // of the new page, but pMarkup is still pointing to the old page. Bug 93275.

    // DOUBLEHACKALERT (sramani) msxml needs the doc from the pending markup, apparently
    // for doing some security checks, which fails when using back\forward nav. Bug 109727

    if (g_fInPhotoSuiteIII || (pDoc->_fStartup && pDoc->IsAggregatedByXMLMime()))
    {
        CWindow * pWindow = Window();

        //
        // TODO (FerhanE) The solution explained above and implemented below is good
        // in general but not for JScript and VBScript URL href calls. These are creating pending
        // markups and then releasing them w/o switching them in. This causes the URL
        // that is returned to be the href of the link, not the containing markup's URL.
        // Working around it for now with the same reasoning above. Bug 94256.
        //
        if (pWindow && pWindow->_pMarkupPending)
        {
            CMarkup * pMarkupPending = pWindow->_pMarkupPending;
            UINT      uProt;

            uProt = GetUrlScheme(CMarkup::GetUrl(pMarkupPending));

            if (URL_SCHEME_JAVASCRIPT != uProt && URL_SCHEME_VBSCRIPT != uProt)
            {
                pMarkup = pMarkupPending;
            }
        }
    }

    if (fOriginal && pMarkup && pMarkup->HasLocationContext())
    {
        pchUrl = pMarkup->GetLocationContext()->_pchUrlOriginal;
    }

    if (!pchUrl)
    {
        fOriginal = FALSE;
        pchUrl = CMarkup::GetUrl(pMarkup);
    }

    hr = THR(pcstrRetString->Set(pchUrl));
    if (hr)
        goto Cleanup;

    if (!fOriginal)
    {
        CStr cstrLocation;

        cstrLocation.Set(CMarkup::GetUrlLocation(pMarkup));
        if (cstrLocation.Length())
        {
            hr = THR(pcstrRetString->Append(cstrLocation));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------------------------
//
//  Member:     get_URL, IOmDocument
//
//  Synopsis: returns the url of this document
//
//--------------------------------------------------------------------------------------------

HRESULT
CDocument::get_URL(BSTR * pbstrUrl)
{
    HRESULT hr = S_OK;
    CStr    cstrRetString;
    TCHAR   achUrl[pdlUrlLen];
    DWORD   dwLength = ARRAY_SIZE(achUrl);

    if (!pbstrUrl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrUrl = NULL;

    hr = GetMarkupUrl(&cstrRetString, FALSE);
    if (hr)
        goto Cleanup;

    if (!InternetCanonicalizeUrl(cstrRetString,
                                 achUrl,
                                 &dwLength,
                                 ICU_DECODE | URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE))
        goto Cleanup;

    *pbstrUrl = SysAllocString(achUrl);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------------------------
//
//  Member:     get_URLUnencoded, IHTMLDocument4
//
//  Synopsis: returns the unencoded url of this document
//
//--------------------------------------------------------------------------------------------

HRESULT
CDocument::get_URLUnencoded(BSTR * pbstrUrl)
{
    HRESULT hr = S_OK;
    CStr    cstrRetString;
    TCHAR   achUrl[pdlUrlLen];
    DWORD   dwLength = ARRAY_SIZE(achUrl);

    if (!pbstrUrl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrUrl = NULL;

    hr = GetMarkupUrl(&cstrRetString, FALSE);
    if (hr)
        goto Cleanup;

        if (!InternetCanonicalizeUrl(cstrRetString, achUrl, &dwLength,
                                 ICU_NO_ENCODE | ICU_DECODE | URL_BROWSER_MODE))
        {
            goto Cleanup;
        }

    // MHTML protocol URLs begin with mhtml:. We have to
    // strip off the mhtml protocol specifier in this case.
    //
    if (StrStr(achUrl, _T("mhtml:")))
    {
        *pbstrUrl = SysAllocString(StrChr(achUrl, _T(':'))+1);
    }
    else
    {
        *pbstrUrl = SysAllocString(achUrl);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------
//
//  Member:     put_URL, IOmDocument
//
//  Synopsis: set the url of this document by defering to put_ window.location.href
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::put_URL(BSTR b)
{
    IHTMLLocation * pLocation =NULL;
    HRESULT hr = S_OK;
    BSTR bstrNew = NULL;

    if (!Markup()->HasWindow())
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    hr =THR(Markup()->Window()->get_location(&pLocation));
    if (hr)
        goto Cleanup;

    hr = THR(GetFullyExpandedUrl(this, b, &bstrNew));
    if (hr)
        goto Cleanup;

    hr =THR(pLocation->put_href(bstrNew));
    if (hr)
        goto Cleanup;

    Fire_PropertyChangeHelper(DISPID_CDocument_URL, 0, (PROPERTYDESC *)&s_propdescCDocumentURL);

Cleanup:
    FormsFreeString(bstrNew);
    ReleaseInterface(pLocation);
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     get_location, IOmDocument
//
//  Synopsis : this defers to the window.location property
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_location(IHTMLLocation** ppLocation)
{
    HRESULT hr = S_OK;
    IHTMLWindow2 * pNewWindow = NULL;

    if (!Markup()->HasWindow())
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    COmWindowProxy * pProxy = Markup()->Window();    

    IGNORE_HR(pProxy->SecureObject(pProxy, (IHTMLWindow2**)&pNewWindow, TRUE));

    hr =THR(pNewWindow->get_location(ppLocation));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pNewWindow);
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     get_lastModified, IOmDocument
//
//  Synopsis: returns the date of the most recent change to the document
//              this comes from the http header.
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_lastModified(BSTR * p)
{
    HRESULT  hr = S_OK;
    FILETIME ftLastMod;

    if (!p)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *p = NULL;

    ftLastMod = Markup()->GetLastModDate();

    if (!ftLastMod.dwLowDateTime && !ftLastMod.dwHighDateTime)
    {
        // TODO  - If the last modified date is requested early enough on a slow (modem) link
        // then sometimes the GetCacheInfo call fails in this case the current date and time is
        // returned.  This is not the optimal solution but it allows the user to use the page without
        // a scriping error and since we are guarenteed to be currently downloading this page for this
        // to fail the date should not appear to unusual.
        SYSTEMTIME  currentSysTime;

        GetSystemTime(&currentSysTime);
        if (!SystemTimeToFileTime(&currentSysTime, &ftLastMod))
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    // We alway convert to fixed mm/dd/yyyy hh:mm:ss format TRUE means include the time
    hr = THR(ConvertDateTimeToString(ftLastMod, p, TRUE));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     get_referrer, IOmDocument
//
//  Synopsis: returns the url of the document that had the link to this one
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_referrer(BSTR * p)
{
    HRESULT hr = S_OK;
    CMarkup * pMarkup = Markup();

    if (!p)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *p = NULL;
    Assert( pMarkup );
    if (pMarkup->GetDwnDoc() && pMarkup->GetDwnDoc()->GetDocReferer())
    {
        CStr    cstrRefer;

        cstrRefer.Set(pMarkup->GetDwnDoc()->GetDocReferer());
        if (*cstrRefer == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        {
            UINT    uProtRefer = GetUrlScheme(cstrRefer);
            UINT    uProtUrl   = GetUrlScheme(CMarkup::GetUrl(pMarkup));

            //only report the referred if: (referrer_scheme/target_Scheme)
            // http/http   http/https     https/https
            // so the if statement is :
            // (http_r && ( http_t || https_t)) || (https_r && https_t)
            if ((URL_SCHEME_HTTP == uProtRefer &&
                      (URL_SCHEME_HTTP == uProtUrl ||
                       URL_SCHEME_HTTPS == uProtUrl))
                 || (URL_SCHEME_HTTPS == uProtRefer &&
                     URL_SCHEME_HTTPS == uProtUrl))
            {
                cstrRefer.AllocBSTR(p);
                if (*p == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
            }
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     get_domain, IOmDocument
//
//  Synopsis: returns the domain of the current document, initially the hostname
//      but once set, it is a sub-domain of the url hostname
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_domain(BSTR * p)
{
    HRESULT hr = S_OK;
    CMarkup *pMarkup = Markup();
    LPCTSTR pchUrl = CMarkup::GetUrl(pMarkup);
    LPCTSTR pchCreatorUrl;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!pchUrl || !*pchUrl)
    {
        *p = 0;
        goto Cleanup;
    }

    // This is for IE 5.01 compatibility bug 94729.
    if (IsSpecialUrl(pchUrl) && pMarkup)
    {
        pchCreatorUrl = pMarkup->GetAAcreatorUrl();
        if (pchCreatorUrl && *pchCreatorUrl)
            pchUrl = pchCreatorUrl;
    }

    Assert( pMarkup );
    if (pMarkup->Domain() && *(pMarkup->Domain()))
    {
        hr = THR(FormsAllocString(pMarkup->Domain(), p));
    }
    else
    {
        CStr    cstrComp;

        hr = THR_NOTRACE(Doc()->GetMyDomain(pchUrl, &cstrComp));   // TODO (lmollico): move to CMarkup
        if (hr == S_FALSE) hr = S_OK;
        if (hr)
            goto Cleanup;

        hr = THR(cstrComp.AllocBSTR(p));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     put_domain, IDocument
//
//  Synopsis: restricted to setting as a domain suffix of the hostname
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::put_domain (BSTR p)
{
    HRESULT hr = S_OK;
    CStr    cstrComp;
    TCHAR * pTempSet;
    TCHAR * pTempUrl;
    long    lSetSize;
    long    lUrlSize;
    long    lOffset;
    CMarkup * pMarkup = Markup();
    const TCHAR * pchUrl = CMarkup::GetUrl(pMarkup);

    if (!pchUrl || !*pchUrl)
    {
        hr = CTL_E_METHODNOTAPPLICABLE;
        goto Cleanup;
    }

    hr = THR(Doc()->GetMyDomain(pchUrl, &cstrComp)); // TODO (lmollico): move to CMarkup
    if (hr)
        goto Cleanup;

    // set up variable for loop
    lSetSize = SysStringLen(p);
    lUrlSize = cstrComp.Length();

    if ((lUrlSize == lSetSize) && !FormsStringNICmp(cstrComp, lUrlSize, p, lSetSize))
    {
        pMarkup->Window()->_fDomainChanged = 1;
        hr = THR(pMarkup->SetDomain(p));
        goto Cleanup;   // hr is S_OK
    }

    hr = E_INVALIDARG;

    if (lSetSize >lUrlSize)   // set is bigger than url
        goto Cleanup;

    lOffset = lUrlSize - lSetSize;
    pTempUrl = cstrComp + lOffset-1;

    //must be proper substring wrt the . in the url domain
    if (lOffset && *pTempUrl++ != _T('.'))
        goto Cleanup;

    if (!FormsStringNICmp(pTempUrl, lSetSize, p, lSetSize))
    {
        BYTE    abSID[MAX_SIZE_SECURITY_ID];
        DWORD   cbSID = ARRAY_SIZE(abSID);

        // match! now for one final check
        // there must be a '.' in the set string
        pTempSet = p+1;
        if (!_tcsstr(pTempSet, _T(".")))
            goto Cleanup;

        hr = THR(pMarkup->SetDomain(p));
        if (hr)
            goto Cleanup;

        //
        // If we successfully set the domain, reset the sid of
        // the security proxy based on the new information.
        //

        hr = THR(pMarkup->GetSecurityID(abSID, &cbSID));
        if (hr)
            goto Cleanup;

        hr = THR(pMarkup->Window()->Init(MyCWindow(), abSID, cbSID));
        if (hr)
            goto Cleanup;

        // Set the flag: domain is modified
        pMarkup->Window()->_fDomainChanged = 1;

        IGNORE_HR(OnPropertyChange(DISPID_CDocument_domain,
                                   0,
                                   (PROPERTYDESC *)&s_propdescCDocumentdomain));
    }

Cleanup:
    if (hr == S_FALSE)
        hr = CTL_E_METHODNOTAPPLICABLE;
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     CDocument:get_readyState
//
//  Synopsis:  first implementation, this is for the OM and uses the long _readyState
//      to determine the string returned.
//
//+------------------------------------------------------------------------------
HRESULT
CDocument::get_readyState(BSTR * p)
{
    HRESULT     hr      = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(s_enumdeschtmlReadyState.StringFromEnum(GetDocumentReadyState(), p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     CDoc::get_Script
//
//  Synopsis:   returns OmWindow.  This routine returns the browser's
//   implementation of IOmWindow object, not our own _pOmWindow object.  This
//   is because the browser's object is the one with the longest lifetime and
//   which is handed to external entities.  See window.cxx CWindow::XXXX
//   for crazy delegation code.
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_Script(IDispatch **ppWindow)
{
    HRESULT hr = S_OK;
    IHTMLWindow2 *pWindow = NULL;
    CVariant varWindow(VT_DISPATCH);
    CVariant varRes(VT_DISPATCH);
    COmWindowProxy *pProxy = Markup() ? Markup()->Window() : NULL;

    if (ppWindow)
        *ppWindow = NULL;

    if (pProxy)
    {
        hr = THR(pProxy->QueryInterface(IID_IHTMLWindow2, (void **)&pWindow));
        if (hr)
            goto Cleanup;

        V_DISPATCH(&varWindow) = pWindow;

        hr = pProxy->SecureObject(&varWindow, &varRes, NULL, this);
        if (!hr)
        {
            *ppWindow = ((IHTMLWindow2 *)V_DISPATCH(&varRes));
            (*ppWindow)->AddRef();
        }
    }
    else
    {
        hr = E_PENDING;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::releaseCapture()
{
    Doc()->ReleaseOMCapture();
    RRETURN(SetErrorInfo(S_OK));
}

HRESULT
CDocument::get_frames(IHTMLFramesCollection2 ** ppDisp)
{
    HRESULT hr                  = E_INVALIDARG;
    CMarkup           * pMarkup;

    if (!ppDisp)
        goto Cleanup;

    *ppDisp = NULL;
    pMarkup = Markup();

    Assert( pMarkup );
    
    // If there is a window, return it to be compatible with old behavior
    if (pMarkup->HasWindow())
    {
        hr = pMarkup->Window()->get_frames(ppDisp);
        goto Cleanup;
    }

    else
    {
        hr = E_NOTIMPL;
        goto Cleanup;
    }

#ifdef THIS_IS_INSECURE

    // Otherwise, construct (if necessary) and return a frames collection object

    GetPointerAt(FindAAIndex(DISPID_INTERNAL_FRAMESCOLLECTION, CAttrValue::AA_Internal),
        (void **) &pFrames);

    if (!pFrames)
    {
        pFrames = new CFramesCollection(this);
        if (!pFrames)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        AddPointer(DISPID_INTERNAL_FRAMESCOLLECTION, (void *) pFrames, CAttrValue::AA_Internal);
    }
    hr = THR_NOTRACE(pFrames->QueryInterface(IID_IHTMLFramesCollection2, (void**) ppDisp));
#endif

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_styleSheets(IHTMLStyleSheetsCollection** ppDisp)
{
    HRESULT hr = E_POINTER;

    if (!ppDisp)
        goto Cleanup;

    hr = THR(Markup()->EnsureStyleSheets());
    if (hr)
        goto Cleanup;

    hr = THR(Markup()->GetStyleSheetArray()->
            QueryInterface(IID_IHTMLStyleSheetsCollection, (void**)ppDisp));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_compatMode(BSTR *pbstr)
{
    HRESULT hr;

    if (pbstr == NULL)
    {
        hr = E_POINTER;
    }
    else
    {
        htmlCompatMode hcm =  Markup()->IsStrictCSS1Document() ? htmlCompatModeCSS1Compat : htmlCompatModeBackCompat;
        hr = THR(STRINGFROMENUM(htmlCompatMode, hcm, pbstr));
    }

    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     GetSelection
//
//  Synopsis:   for the Automation Object Model, this returns a pointer to
//                  the ISelectionObj interface. which fronts for the
//                  selection record exposed
//
//-------------------------------------------------------------------------
HRESULT
CDocument::get_selection(IHTMLSelectionObject ** ppDisp)
{
    HRESULT hr = S_OK;

    if (!ppDisp)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!_pCSelectionObject || _pCSelectionObject->GetSecurityMarkup() != Markup())
    {        
        _pCSelectionObject = new CSelectionObject(this);
        
        if (!_pCSelectionObject)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCSelectionObject->QueryInterface(IID_IHTMLSelectionObject,
                                                (void**) ppDisp ));

        _pCSelectionObject->Release();

        if (hr )
            goto Cleanup;
    }
    else
    {
        hr = THR(_pCSelectionObject->QueryInterface(IID_IHTMLSelectionObject,
                                                (void **) ppDisp));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    //
    // Fix for Vizactbug - 93247
    // We want the doc's DeferUpdateUI to get called for this method.
    // so we call the Doc's SetErrorInfo.
    //
    if ( g_fInVizAct2000 )
    {
        CDoc* pDoc = Doc();

        RRETURN( pDoc ? pDoc->SetErrorInfo(hr) : SetErrorInfo(hr) );
    }
    else
        RRETURN( SetErrorInfo(hr) );
}

//+----------------------------------------------------------------------------
//
//  Member:     put_title, IOmDocument
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::put_title(BSTR v)
{
    HRESULT hr;

    hr = THR(Markup()->EnsureTitle());
    if (hr)
        goto Cleanup;

    Assert(Markup()->GetTitleElement());

    hr = THR(Markup()->GetTitleElement()->SetTitle(v));

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     get_title, IOmDocument
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_title(BSTR *p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!Markup()->GetTitleElement() ||
        !Markup()->GetTitleElement()->_cstrTitle)
    {
        *p = SysAllocString(_T(""));
        if (!*p)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = THR(Markup()->GetTitleElement()->_cstrTitle.AllocBSTR(p));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+-------------------------------------------------------------------------
//
//  Method:     CDoc::Getbody
//
//  Synopsis:   Get the body interface for this form
//
//--------------------------------------------------------------------------
HRESULT
CDocument::get_body(IHTMLElement ** ppDisp)
{
    HRESULT         hr = S_OK;;
    CElement *      pElementClient;

    if (!ppDisp)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppDisp = NULL;

    pElementClient = Markup()->GetElementClient();

    if (pElementClient)
    {
        Assert(pElementClient->Tag() != ETAG_ROOT);

        hr = pElementClient->QueryInterface(IID_IHTMLElement, (void **) ppDisp);
        if (hr)
            goto Cleanup;
    }

Cleanup:

    RRETURN1(SetErrorInfo(hr), S_FALSE);
}

//+----------------------------------------------------------------------
//
//
//-----------------------------------------------------------------------
// Maximum length of a cookie string ( according to Netscape docs )
#define MAX_COOKIE_LENGTH 4096

HRESULT
CDocument::get_cookie(BSTR* retval)
{
    HRESULT  hr = S_OK;

    if (!retval)
    {
        hr = E_POINTER;
    }
    else
    {
        TCHAR achCookies[MAX_COOKIE_LENGTH + 1];
        DWORD dwCookieSize = ARRAY_SIZE(achCookies);

        memset(achCookies, 0,sizeof(achCookies));

        *retval = NULL;

        if (Markup()->GetCookie(CMarkup::GetUrl(Markup()), NULL, achCookies, &dwCookieSize))
        {
            if (dwCookieSize == 0) // We have no cookies
                achCookies[0] = _T('\0'); // So make the cookie string the empty str

            hr = FormsAllocString(achCookies, retval);
        }
        // else return S_OK and an empty string 
    }

    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------
//
//
//-----------------------------------------------------------------------
HRESULT CDocument::put_cookie(BSTR cookie)
{
    if (cookie)
    {
        CMarkup * pMarkup = Markup();
        pMarkup->SetCookie(CMarkup::GetUrl(pMarkup), NULL, cookie);

        IGNORE_HR(OnPropertyChange(DISPID_CDocument_cookie,
                                   0,
                                   (PROPERTYDESC *)&s_propdescCDocumentcookie));
    }
    return S_OK;
}

//+----------------------------------------------------------------------
//
//
//-----------------------------------------------------------------------
HRESULT CDocument::get_expando(VARIANT_BOOL *pfExpando)
{
    HRESULT hr = S_OK;

    if (pfExpando)
    {
        *pfExpando = GetWindowedMarkupContext()->_fExpando ? VB_TRUE : VB_FALSE;
    }
    else
    {
        hr = E_POINTER;
    }

    RRETURN(SetErrorInfo(hr));
}


HRESULT CDocument::put_expando(VARIANT_BOOL fExpando)
{
    CMarkup *pMarkup = GetWindowedMarkupContext();

    if ((pMarkup->_fExpando ? VB_TRUE : VB_FALSE) != fExpando)
    {
        pMarkup->_fExpando = fExpando;
        Fire_PropertyChangeHelper(DISPID_CDocument_expando, 0, (PROPERTYDESC *)&s_propdescCDocumentexpando);
    }
    return SetErrorInfo(S_OK);
}

//+-------------------------------------------------------------------------
//
// Members:     Get/SetCharset
//
// Synopsis:    Functions to get at the document's charset from the object
//              model.
//
//--------------------------------------------------------------------------
HRESULT CDocument::get_charset(BSTR* retval)
{
    TCHAR   achCharset[MAX_MIMECSET_NAME];
    HRESULT hr;

    hr = THR(GetMlangStringFromCodePage(Markup()->GetCodePage(), achCharset,
                                        ARRAY_SIZE(achCharset)));
    if (hr)
        goto Cleanup;

    hr = FormsAllocString(achCharset, retval);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//--------------------------------------------------------------------------
HRESULT
CDocument::put_charset(BSTR mlangIdStr)
{
    HRESULT hr;
    CODEPAGE cp;
    CDoc * pDoc = Doc();
    CMarkup *pMarkup = Markup();

    hr = THR(GetCodePageFromMlangString(mlangIdStr, &cp));
    if (hr)
        goto Cleanup;

    Assert(cp != CP_UNDEFINED);

    hr = THR(mlang().ValidateCodePage(g_cpDefault, cp, pDoc->_pInPlace ? pDoc->_pInPlace->_hwnd : NULL,
                                      FALSE, pDoc->_dwLoadf & DLCTL_SILENT));
    if (hr)
        goto Cleanup;

    // HACK: bug 110839: Outlook98 calls this method immediately after IPersist::Load.
    // They rely on the fact that we syncronously start load and the document
    // is the new one already (as in IE5.0)
    // So we emulate this behavior for them routing the call to pending markup.
    if (pDoc->_fOutlook98)
    {
        CWindow * pWindow = Window();

        if(pWindow && pWindow->_pMarkupPending)
            pMarkup = pWindow->_pMarkupPending;
    }

    hr = THR(pMarkup->SwitchCodePage(cp));
    if (hr)
        goto Cleanup;

    // Outlook98 calls put_charset and expects it not
    // to make us dirty.  They expect a switch from design
    // to browse mode to always reload from the original
    // source in this situation.  For them we make this routine
    // act just like IE4
    // Outlook2000 didn't fix this, so we have to hack around them still
    if (!pDoc->_fOutlook98 && !pDoc->_fOutlook2000)
    {
        //
        // Make sure we have a META tag that's in sync with the document codepage.
        //
        hr = THR(pMarkup->UpdateCodePageMetaTag(cp));
        if (hr)
            goto Cleanup;

        IGNORE_HR(OnPropertyChange(DISPID_CDocument_charset,
                                   0,
                                   (PROPERTYDESC *)&s_propdescCDocumentcharset));
    }

    //
    // Clear our caches and force a repaint since codepages can have
    // distinct fonts.
    //
    pMarkup->EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES|ELEMCHNG_REMEASUREALLCONTENTS);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+-------------------------------------------------------------------------
//
// Members:     Get/SetDefaultCharset
//
// Synopsis:    Functions to get at the thread's default charset from the
//              object model.
//
//--------------------------------------------------------------------------
HRESULT
CDocument::get_defaultCharset(BSTR* retval)
{
    TCHAR   achCharset[MAX_MIMECSET_NAME];
    HRESULT hr;

    hr = THR(GetMlangStringFromCodePage(Doc()->_pOptionSettings->codepageDefault,
                                        achCharset, ARRAY_SIZE(achCharset)));
    if (hr)
        goto Cleanup;

    hr = FormsAllocString(achCharset, retval);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::put_defaultCharset(BSTR mlangIdStr)
{
#if NOT_YET

    // N.B. (johnv) This method will be exposed through the object model
    // but not through IDispatch in Beta2.  Commenting out until we can
    // do this, since this function may pose a security risk (a script
    // can make it impossible to view any subsequently browsed pages).

    HRESULT hr;
    CODEPAGE cp;

    hr = THR(GetCodePageFromMlangString(mlangIdStr, &cp));
    if (hr)
        goto Cleanup;

    if (cp != CP_UNDEFINED)
    {
        _pOptionSettings->codepageDefault = cp;
    }
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));

#endif

    return S_OK;    // so enumerating through properties won't fail
}

//+---------------------------------------------------------------------------
//
//  Members:    Get/SetDir
//
//  Synopsis:   Functions to get at the document's direction from the object
//              model.
//
//----------------------------------------------------------------------------
HRESULT
CDocument::get_dir(BSTR * p)
{
    CElement * pHtmlElement;
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pHtmlElement = Markup()->GetHtmlElement();
    if (pHtmlElement != NULL)
    {
        hr = THR(pHtmlElement->get_dir(p));
    }
    else
    {
        hr = THR(s_propdescCDocumentdir.b.GetEnumStringProperty(p, this,
                    (CVoid *)(void *)(GetAttrArray())));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::put_dir(BSTR v)
{
    CElement * pHtmlElement;
    HRESULT hr = S_OK;
    long eHTMLDir = htmlDirNotSet;
    CMarkup * pMarkup = Markup();

    Assert(pMarkup);

    pHtmlElement = pMarkup->GetHtmlElement();

    if (pHtmlElement != NULL)
    {
        hr = THR(pHtmlElement->put_dir(v));
        if (hr == S_OK)
            Fire_PropertyChangeHelper(DISPID_CDocument_dir, 0, (PROPERTYDESC *)&s_propdescCDocumentdir);
    }
    else
    {
        hr = THR(s_propdescCDocumentdir.b.SetEnumStringProperty(v, this,
                    (CVoid *)(void *)(GetAttrArray())));
    }

    hr = THR(s_enumdeschtmlDir.EnumFromString(v, &eHTMLDir));
    if (!hr)
        _eHTMLDocDirection = eHTMLDir;

    // send the property change message to the body. These depend upon
    // being in edit mode or not.
    CBodyElement * pBody;

    pMarkup->GetBodyElement(&pBody);
    if (pBody)
        pBody->OnPropertyChange(DISPID_A_DIR,
                                ELEMCHNG_CLEARCACHES|ELEMCHNG_REMEASUREALLCONTENTS,
                                (PROPERTYDESC *)&s_propdescCElementdir);

    RRETURN( SetErrorInfo(hr) );
}

//+---------------------------------------------------------------------------
//
// Helper Function: GetFileTypeInfo, called by get_mimeType
//
//----------------------------------------------------------------------------

BSTR
GetFileTypeInfo(TCHAR * pchFileName)
{
#if !defined(WIN16) && !defined(WINCE)
    SHFILEINFO sfi;

    if (pchFileName &&
            pchFileName[0] &&
            SHGetFileInfo(
                pchFileName,
                FILE_ATTRIBUTE_NORMAL,
                &sfi,
                sizeof(sfi),
                SHGFI_TYPENAME | SHGFI_USEFILEATTRIBUTES))
    {
        return SysAllocString(sfi.szTypeName);
    }
    else
#endif //!WIN16 && !WINCE
    {
        return NULL;
    }
}

//+---------------------------------------------------------------------------
//
// Member: get_mimeType
//
//----------------------------------------------------------------------------
HRESULT
CDocument::get_mimeType(BSTR * pMimeType)
{
    HRESULT hr = S_OK;
    TCHAR * pchCachedFile = NULL;

    *pMimeType = NULL;

    hr = Markup()->GetFile(&pchCachedFile);
    if (!hr)
    {
        *pMimeType = GetFileTypeInfo(pchCachedFile);
    }

    MemFreeString(pchCachedFile);
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
// Member: get_fileSize
//
//----------------------------------------------------------------------------
HRESULT
CDocument::get_fileSize(BSTR * pFileSize)
{
    HRESULT hr = S_OK;
    TCHAR   szBuf[64];
    TCHAR * pchCachedFile = NULL;

    if (pFileSize == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pFileSize = NULL;

    hr = Markup()->GetFile(&pchCachedFile);
    if (!hr && pchCachedFile)
    {
        WIN32_FIND_DATA wfd;
        HANDLE hFind = FindFirstFile(pchCachedFile, &wfd);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);

            Format(0, szBuf, ARRAY_SIZE(szBuf), _T("<0d>"), (long)wfd.nFileSizeLow);
            *pFileSize = SysAllocString(szBuf);
        }
    }

Cleanup:
    MemFreeString(pchCachedFile);
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
// Member: get_fileCreatedDate
//
//----------------------------------------------------------------------------
HRESULT
CDocument::get_fileCreatedDate(BSTR * pFileCreatedDate)
{
    HRESULT hr = S_OK;
    TCHAR * pchCachedFile = NULL;

    if (pFileCreatedDate == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pFileCreatedDate = NULL;

    hr = Markup()->GetFile(&pchCachedFile);
    if (!hr && pchCachedFile)
    {
        WIN32_FIND_DATA wfd;
        HANDLE hFind = FindFirstFile(pchCachedFile, &wfd);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);
            // we always return the local time in a fixed format mm/dd/yyyy to make it possible to parse
            // FALSE means we do not want the time
            hr = THR(ConvertDateTimeToString(wfd.ftCreationTime, pFileCreatedDate, FALSE));
        }
    }

Cleanup:
    MemFreeString(pchCachedFile);
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
// Member: get_fileModifiedDate
//
//----------------------------------------------------------------------------
HRESULT
CDocument::get_fileModifiedDate(BSTR * pFileModifiedDate)
{
    HRESULT hr = S_OK;
    TCHAR * pchCachedFile = NULL;

    if (pFileModifiedDate == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pFileModifiedDate = NULL;

    hr = Markup()->GetFile(&pchCachedFile);
    if (!hr && pchCachedFile)
    {
        WIN32_FIND_DATA wfd;
        HANDLE hFind = FindFirstFile(pchCachedFile, &wfd);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);
            // we always return the local time in a fixed format mm/dd/yyyy to make it possible to parse
            // FALSE means we do not want the time
            hr = THR(ConvertDateTimeToString(wfd.ftLastWriteTime, pFileModifiedDate, FALSE));
        }
    }

Cleanup:
    MemFreeString(pchCachedFile);
    RRETURN(SetErrorInfo(hr));
}

// TODO (lmollico): get_fileUpdatedDate won't work if src=file://htm
//+---------------------------------------------------------------------------
//
// Member: get_fileUpdatedDate
//
//----------------------------------------------------------------------------
HRESULT
CDocument::get_fileUpdatedDate(BSTR * pFileUpdatedDate)
{
    HRESULT   hr = S_OK;
    const TCHAR * pchUrl = CMarkup::GetUrl(Markup());

    * pFileUpdatedDate = NULL;

    if (pchUrl)
    {
        BYTE                        buf[MAX_CACHE_ENTRY_INFO_SIZE];
        INTERNET_CACHE_ENTRY_INFO * pInfo = (INTERNET_CACHE_ENTRY_INFO *) buf;
        DWORD                       cInfo = sizeof(buf);

        if (RetrieveUrlCacheEntryFile(pchUrl, pInfo, &cInfo, 0))
        {
            // we always return the local time in a fixed format mm/dd/yyyy to make it possible to parse
            // FALSE means we do not want the time
            hr = THR(ConvertDateTimeToString(pInfo->LastModifiedTime, pFileUpdatedDate, FALSE));
            DoUnlockUrlCacheEntryFile(pchUrl, 0);
        }
    }

    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
// Member: get_security
//
//----------------------------------------------------------------------------
HRESULT
CDocument::get_security(BSTR * pSecurity)
{
    HRESULT hr = S_OK;
    TCHAR   szBuf[2048];
    BOOL    fSuccess = FALSE;
    const TCHAR * pchUrl = CMarkup::GetUrl(Markup());

    if (pchUrl && (GetUrlScheme(pchUrl) == URL_SCHEME_HTTPS))
    {
        fSuccess = InternetGetCertByURL(pchUrl, szBuf, ARRAY_SIZE(szBuf));
    }

    if (!fSuccess)
    {
        LoadString(
                GetResourceHInst(),
                IDS_DEFAULT_DOC_SECURITY_PROP,
                szBuf,
                ARRAY_SIZE(szBuf));
    }

    *pSecurity = SysAllocString(szBuf);

    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
// Member: get_protocol
//
//----------------------------------------------------------------------------
HRESULT
CDocument::get_protocol(BSTR * pProtocol)
{
    HRESULT   hr = S_OK;
    TCHAR   * pResult = NULL;

    pResult = ProtocolFriendlyName((TCHAR *) CMarkup::GetUrl(Markup()));

    if (pResult)
    {
        int z = (_tcsncmp(pResult, 4, _T("URL:"), -1) == 0) ? (4) : (0);
        *pProtocol = SysAllocString(pResult + z);
        SysFreeString(pResult);
    }
    else
    {
        *pProtocol = NULL;
    }
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
// Member: get_nameProp
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::get_nameProp(BSTR * pName)
{
    RRETURN(SetErrorInfo(get_title(pName)));
}

HRESULT
CDocument::toString(BSTR *pbstrString)
{
    RRETURN(super::toString(pbstrString));
}

HRESULT
CDocument::attachEvent(BSTR event, IDispatch* pDisp, VARIANT_BOOL *pResult)
{
    RRETURN(super::attachEvent(event, pDisp, pResult));
}

HRESULT
CDocument::detachEvent(BSTR event, IDispatch* pDisp)
{
    RRETURN(super::detachEvent(event, pDisp));
}

HRESULT
CDocument::recalc(VARIANT_BOOL fForce)
{
    // recalc across all markups for now
    RRETURN(SetErrorInfo(Doc()->_recalcHost.EngineRecalcAll(fForce)));
}

HRESULT CDocument::createTextNode(BSTR text, IHTMLDOMNode **ppTextNode)
{
    HRESULT             hr = S_OK;
    CMarkup *           pMarkup = NULL;
    CMarkupPointer *    pmkpPtr = NULL;
    long                lTextID;
    long                lLen = -1;
    CMarkupPointer      mkpEnd (Doc());

    if (!ppTextNode)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppTextNode = NULL;

    // Because Perf is not our primary concern right now, I'm going to create
    // a markup container to hold the text. If we had more time, I'd just store the string internaly
    // and special case access to the data in all the method calls
    hr = THR(Doc()->CreateMarkup(&pMarkup, Markup()->GetWindowedMarkupContext()));
    if (hr)
        goto Cleanup;

    hr = THR( pMarkup->SetOrphanedMarkup( TRUE ) );
    if( hr )
        goto Cleanup;

    pmkpPtr = new CMarkupPointer(Doc());
    if (!pmkpPtr)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pmkpPtr->MoveToContainer(pMarkup, TRUE));
    if (hr)
        goto Cleanup;

    pmkpPtr->SetGravity(POINTER_GRAVITY_Left);

    // Put the text in
    hr = THR(pmkpPtr->Doc()->InsertText(pmkpPtr, text, -1, MUS_DOMOPERATION));
    if (hr)
        goto Cleanup;

    // Position the end pointer to the extreme right of the text
    hr = THR(mkpEnd.MoveToPointer(pmkpPtr));
    if (hr)
        goto Cleanup;

    // Move right by the number of chars inserted
    hr = THR(mkpEnd.Right(TRUE, NULL, NULL, &lLen, NULL, &lTextID));
    if (hr)
        goto Cleanup;

    hr = THR(Doc()->CreateDOMTextNodeHelper(pmkpPtr, &mkpEnd, ppTextNode));
    if (hr)
        goto Cleanup;

    pmkpPtr = NULL; // Text Node now owns the pointer


Cleanup:
    ReleaseInterface((IUnknown*)(pMarkup)); // Text Node keeps the markup alive
    delete pmkpPtr;
    RRETURN(SetErrorInfo(hr));
}


HRESULT CDocument::get_documentElement(IHTMLElement **ppRootElem)
{
    HRESULT hr = S_OK;
    CElement *pRootElem = NULL;

    if (!ppRootElem)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppRootElem = NULL;

    pRootElem = Markup()->GetHtmlElement();
    if (pRootElem)
        hr = THR(pRootElem->QueryInterface(IID_IHTMLElement, (void **)ppRootElem));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CDocument::get_all(IHTMLElementCollection** ppDisp)
{
    RRETURN(SetErrorInfo(Markup()->GetCollection(CMarkup::ELEMENT_COLLECTION, ppDisp)));
}

HRESULT
CDocument::get_anchors(IHTMLElementCollection** ppDisp)
{
    RRETURN(SetErrorInfo(Markup()->GetCollection(CMarkup::ANCHORS_COLLECTION, ppDisp)));
}

HRESULT
CDocument::get_links(IHTMLElementCollection ** ppDisp)
{
    RRETURN(SetErrorInfo(Markup()->GetCollection(CMarkup::LINKS_COLLECTION, ppDisp)));
}

HRESULT
CDocument::get_forms(IHTMLElementCollection** ppDisp)
{
    RRETURN(SetErrorInfo(Markup()->GetCollection(CMarkup::FORMS_COLLECTION, ppDisp)));
}

HRESULT
CDocument::get_applets(IHTMLElementCollection** ppDisp)
{
    RRETURN(SetErrorInfo(Markup()->GetCollection(CMarkup::APPLETS_COLLECTION, ppDisp)));
}

HRESULT
CDocument::get_images(IHTMLElementCollection** ppDisp)
{
    RRETURN(SetErrorInfo(Markup()->GetCollection(CMarkup::IMAGES_COLLECTION, ppDisp)));
}

HRESULT
CDocument::get_scripts(IHTMLElementCollection** ppDisp)
{
    RRETURN(SetErrorInfo(Markup()->GetCollection(CMarkup::SCRIPTS_COLLECTION, ppDisp)));
}

HRESULT
CDocument::get_embeds( IHTMLElementCollection** ppDisp )
{
    RRETURN(SetErrorInfo(Markup()->GetCollection(CMarkup::EMBEDS_COLLECTION, ppDisp)));
}

HRESULT
CDocument::get_plugins(IHTMLElementCollection** ppDisp)
{
    // plugins is an alias for embeds
    RRETURN(get_embeds(ppDisp));
}


HRESULT
CDocument::get_uniqueID(BSTR *pID)
{
    HRESULT     hr;
    CStr        cstrUniqueID;

    hr = THR(Doc()->GetUniqueIdentifier(&cstrUniqueID));
    if (hr)
        goto Cleanup;

    hr = THR(cstrUniqueID.AllocBSTR(pID));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::createElement ( BSTR bstrTag, IHTMLElement ** pIElementNew )
{
    HRESULT hr = S_OK;
    CElement * pElement = NULL;

    if (!bstrTag || !pIElementNew)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(Markup()->CreateElement(
            ETAG_NULL, & pElement, bstrTag, SysStringLen(bstrTag)));
    if (hr)
        goto Cleanup;

    hr = THR(pElement->QueryInterface( IID_IHTMLElement, (void **) pIElementNew));
    if (hr)
        goto Cleanup;

Cleanup:
    if (pElement)
        pElement->Release();

    RRETURN( hr );
}


HRESULT
CDocument::createStyleSheet ( BSTR bstrHref /*=""*/, long lIndex/*=-1*/, IHTMLStyleSheet ** ppnewStyleSheet )
{
    HRESULT         hr = S_OK;
    CElement      * pElementNew = NULL;
    CStyleSheet   * pStyleSheet;
    BOOL            fIsLinkElement;
    CStyleSheetArray * pStyleSheets;
    CMarkup       * pMarkup = Markup();

    if (!ppnewStyleSheet)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert(pMarkup);

    if (!pMarkup->GetHeadElement())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    *ppnewStyleSheet = NULL;

    // If there's an HREF, we create a LINK element, otherwise it's a STYLE element.

    fIsLinkElement = (bstrHref && *bstrHref);

    hr = THR(pMarkup->CreateElement(
            (fIsLinkElement) ? ETAG_LINK : ETAG_STYLE, & pElementNew));

    if (hr)
        goto Cleanup;

    hr = pMarkup->EnsureStyleSheets();
    if (hr)
        goto Cleanup;

    Assert(pMarkup->HasStyleSheetArray());
    pStyleSheets = pMarkup->GetStyleSheetArray();

    if ( lIndex < -1 || lIndex >= pStyleSheets->Size() )
        lIndex = -1;    // Just append to the end if input is outside the bounds

    Assert( "Must have a root site!" && pMarkup->Root() );

    // Fix up the index - incoming index is index in stylesheets list, but param to
    // AddHeadElement is index in ALL head elements.  There may be META or TITLE, etc.
    // tags mixed in.
    if (lIndex > 0)
    {
        long nHeadNodes;
        long i;
        long nSSInHead;
        CTreeNode *pNode;
        CLinkElement *pLink;
        CStyleElement *pStyle;

        CChildIterator ci((CElement *)pMarkup->GetHeadElement(), NULL, CHILDITERATOR_DEEP);

        for ( nHeadNodes = 0 ; ci.NextChild() ; )
            nHeadNodes++;

        ci.SetBeforeBegin();

        nSSInHead = 0;

        for ( i = 0 ; (pNode = ci.NextChild()) != NULL ; i++ )
        {
            if ( pNode->Tag() == ETAG_LINK )
            {
                pLink = DYNCAST( CLinkElement, pNode->Element() );
                if ( pLink->_pStyleSheet ) // faster than IsLinkedStyleSheet() and adequate here
                    ++nSSInHead;
            }
            else if ( pNode->Tag() == ETAG_STYLE )
            {
                pStyle = DYNCAST( CStyleElement, pNode->Element() );
                if ( pStyle->_pStyleSheet ) // Not all STYLE elements create a SS.
                    ++nSSInHead;
            }
            if ( nSSInHead == lIndex )
            {           // We've found the stylesheet that should immediately precede us - we'll
                i++;    // add our new ss at the next head index.
                break;
            }
        }
        if ( i == nHeadNodes )   // We'll be at the end anyway.
            lIndex = -1;
        else
            lIndex = i;         // Here's the new index, adjusted for other HEAD elements.
    }

    // Go ahead and add it to the head.
    //--------------------------------
    //   For style elements we need to set _fParseFinished to FALSE so that the style sheet
    // is not automatically created when we insert the style element into the tree from here.
    // We will create and insert the styleSheet into the proper position of the collection later.
    //   When the element is inserted through DOM we want to have a stylesheet so we set
    // _fParseFinished to TRUE (we are not going to parse anything in that case)
    if(!fIsLinkElement)
    {
        DYNCAST( CStyleElement, pElementNew)->_fParseFinished = FALSE;
    }

    hr = THR(pMarkup->AddHeadElement( pElementNew, lIndex ));
    if (hr)
        goto Cleanup;

    // We MUST put the element in the HEAD (the AddHeadElement() above) before we do the element-specific
    // stuff below, because the element will try to find itself in the head in CLinkElement::OnPropertyChange()
    // or CStyleElement::EnsureStyleSheet().
    if ( fIsLinkElement )
    {   // It's a LINK element - DYNCAST it and grab the CStyleSheet.
        CLinkElement *pLink = DYNCAST( CLinkElement, pElementNew );
        pLink->put_StringHelper( _T("stylesheet"), (PROPERTYDESC *)&s_propdescCLinkElementrel );
        pLink->put_UrlHelper( bstrHref, (PROPERTYDESC *)&s_propdescCLinkElementhref );
        pStyleSheet = pLink->_pStyleSheet;
    }
    else
    {   // It's a STYLE element - this will make sure we create a stylesheet attached to the CStyleElement.
        CStyleElement *pStyle = DYNCAST( CStyleElement, pElementNew );
        hr = THR( pStyle->EnsureStyleSheet() );
        if (hr)
            goto Cleanup;
        pStyleSheet = pStyle->_pStyleSheet;
    }

    if ( !pStyleSheet )
        hr = E_OUTOFMEMORY;
    else
        hr = THR( pStyleSheet->QueryInterface ( IID_IHTMLStyleSheet, (void **)ppnewStyleSheet ) );

Cleanup:
    CElement::ClearPtr(&pElementNew);
    RRETURN(SetErrorInfo(hr));
}


HTC
CDocument::HitTestPoint(CMessage *pMsg, CTreeNode **ppNode, DWORD dwFlags)
{
    // NOTE:  This function assumes that the point is in COORDSYS_SCROLL coordinates when
    //        passed in.

    CLayout *   pLayout;
    CElement *  pRoot   = Markup()->Root();
    CElement *  pElemMaster;

    Assert(pRoot);

    if (!pRoot->IsInViewTree())
        return HTC_NO;

    // If this isn't the primary document, transform to the global coordinate system.
    if (pRoot->HasMasterPtr())
    {
        pElemMaster = pRoot->GetMasterPtr();

        if (S_OK != pElemMaster->EnsureRecalcNotify())
            return HTC_NO;

        pLayout = pElemMaster->GetUpdatedLayout();
        Assert(pLayout);

        pLayout->TransformPoint(&pMsg->pt, COORDSYS_SCROLL, COORDSYS_GLOBAL);
    }

    return Doc()->HitTestPoint(pMsg, ppNode, HT_VIRTUALHITTEST);
}

HRESULT
CDocument::elementFromPoint(long x, long y, IHTMLElement **ppElement)
{
    HRESULT    hr = S_OK;
    CTreeNode *pNode = NULL;
    HTC        htc;
    CMessage   msg;

    if (!ppElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    *ppElement = NULL;

    x = g_uiDisplay.DeviceFromDocPixelsX(x);
    y = g_uiDisplay.DeviceFromDocPixelsY(y);

    msg.pt = CPoint(x,y);
    htc = HitTestPoint(&msg, &pNode, HT_VIRTUALHITTEST);

    if (htc != HTC_NO)
    {
        if (pNode->Tag() == ETAG_IMG)
        {
            // did we hit an area?
            pNode->Element()->SubDivisionFromPt(msg.ptContent, &msg.lSubDivision);
            if (msg.lSubDivision >=0)
            {
                // hit was on an area in an img, return the area.
                CAreaElement * pArea = NULL;
                CImgElement  * pImg = DYNCAST(CImgElement, pNode->Element());

                Assert(pImg->GetMap());

                // if we can get a node for the area, then return it
                // otherwise default back to returning the element.
                pImg->GetMap()->GetAreaContaining(msg.lSubDivision, &pArea);
                if (pArea)
                {
                    pNode = pArea->GetFirstBranch();
                    Assert(pNode);
                }
            }
        }

        if (pNode->GetMarkup() != Markup())
        {
            // get a node that contains the hit node and lives in this markup
            pNode = pNode->GetNodeInMarkup(Markup());

            if (!pNode)
            {
                // No element at the given point in the given document
                hr = S_OK;
                goto Cleanup;
            }

            Assert(pNode->GetMarkup() == Markup());
        }

        hr = THR( pNode->GetElementInterface( IID_IHTMLElement, (void **) ppElement ) );
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     execCommand
//
//  Synopsis:   Executes given command
//
//  Returns:
//----------------------------------------------------------------------------
HRESULT
CDocument::execCommand(BSTR bstrCmdId, VARIANT_BOOL showUI, VARIANT value, VARIANT_BOOL *pfRet)
{
    HRESULT hr;
    CDoc * pDoc = Doc();
    CDoc::CLock Lock(pDoc, FORMLOCK_QSEXECCMD);
    BOOL fAllow;

    hr = THR(Markup()->AllowClipboardAccess(bstrCmdId, &fAllow));
    if (hr || !fAllow)
        goto Cleanup;           // Fail silently

    hr = THR(super::execCommand(bstrCmdId, showUI, value));

    if (pfRet)
    {
        // We return false when any error occures
        *pfRet = hr ? VB_FALSE : VB_TRUE;
        hr = S_OK;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     execCommandShowHelp
//
//  Synopsis:
//
//  Returns:
//----------------------------------------------------------------------------
HRESULT
CDocument::execCommandShowHelp(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    HRESULT hr;

    hr = THR(super::execCommandShowHelp(bstrCmdId));

    if (pfRet != NULL)
    {
        // We return false when any error occures
        *pfRet = hr ? VB_FALSE : VB_TRUE;
        hr = S_OK;
    }

    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     queryCommandSupported
//
//  Synopsis:
//
//  Returns: returns true if given command (like bold) is supported
//----------------------------------------------------------------------------
HRESULT
CDocument::queryCommandSupported(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(super::queryCommandSupported(bstrCmdId, pfRet));
}

//+---------------------------------------------------------------------------
//
//  Member:     queryCommandEnabled
//
//  Synopsis:
//
//  Returns: returns true if given command is currently enabled. For toolbar
//          buttons not being enabled means being grayed.
//----------------------------------------------------------------------------
HRESULT
CDocument::queryCommandEnabled(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(super::queryCommandEnabled(bstrCmdId, pfRet));
}

//+---------------------------------------------------------------------------
//
//  Member:     queryCommandState
//
//  Synopsis:
//
//  Returns: returns true if given command is on. For toolbar buttons this
//          means being down. Note that a command button can be disabled
//          and also be down.
//----------------------------------------------------------------------------
HRESULT
CDocument::queryCommandState(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(super::queryCommandState(bstrCmdId, pfRet));
}

//+---------------------------------------------------------------------------
//
//  Member:     queryCommandIndeterm
//
//  Synopsis:
//
//  Returns: returns true if given command is in indetermined state.
//          If this value is TRUE the value returnd by queryCommandState
//          should be ignored.
//----------------------------------------------------------------------------
HRESULT
CDocument::queryCommandIndeterm(BSTR bstrCmdId, VARIANT_BOOL *pfRet)
{
    RRETURN(super::queryCommandIndeterm(bstrCmdId, pfRet));
}

//+---------------------------------------------------------------------------
//
//  Member:     queryCommandText
//
//  Synopsis:
//
//  Returns: Returns the text that describes the command (eg bold)
//----------------------------------------------------------------------------
HRESULT
CDocument::queryCommandText(BSTR bstrCmdId, BSTR *pcmdText)
{
    RRETURN(super::queryCommandText(bstrCmdId, pcmdText));
}

//+---------------------------------------------------------------------------
//
//  Member:     queryCommandValue
//
//  Synopsis:
//
//  Returns: Returns the  command value like font name or size.
//----------------------------------------------------------------------------
HRESULT
CDocument::queryCommandValue(BSTR bstrCmdId, VARIANT *pvarRet)
{
    RRETURN(super::queryCommandValue(bstrCmdId, pvarRet));
}

HRESULT
CDocument::createDocumentFragment(IHTMLDocument2 **ppNewDoc)
{
    HRESULT hr = S_OK;
    CMarkup *pMarkupContext;
    CMarkup *pMarkup = NULL;
    CDocument *pDocument = NULL;
    CDoc *pDoc = Doc();

    if ( !ppNewDoc )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppNewDoc = NULL;
    pMarkupContext = GetWindowedMarkupContext();

    hr = THR(pDoc->CreateMarkup(&pMarkup, pMarkupContext));
    if (hr)
        goto Cleanup;

    hr = THR( pMarkup->SetOrphanedMarkup( TRUE ) );
    if( hr )
        goto Cleanup;

    hr = THR(pMarkup->EnsureDocument(&pDocument));
    if (hr)
        goto Cleanup;

    pDocument->_lnodeType = 11;

    hr = THR(pDocument->QueryInterface(IID_IHTMLDocument2, (void **)ppNewDoc));
    if (hr)
        goto Cleanup;

Cleanup:

    if(pMarkup)
        pMarkup->Release();
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::get_parentDocument(IHTMLDocument2 **ppParentDoc)
{
    // root doc!
    if (ppParentDoc)
        *ppParentDoc = NULL;

    return S_OK;
}

HRESULT
CDocument::get_enableDownload(VARIANT_BOOL *pfDownload)
{
/*
    // TODO: Revisit in IE6
    if (pfDownload)
        *pfDownload = _fEnableDownload ? VARIANT_TRUE : VARIANT_FALSE;
*/
    if (pfDownload)
        *pfDownload = VARIANT_FALSE;

    RRETURN(SetErrorInfo(E_NOTIMPL));
}

HRESULT
CDocument::put_enableDownload(VARIANT_BOOL fDownload)
{
/*
    // TODO: Revisit in IE6
    _fEnableDownload = !!fDownload;
*/
    RRETURN(SetErrorInfo(E_NOTIMPL));
}

HRESULT
CDocument::get_baseUrl(BSTR *p)
{
    if ( p )
        *p = NULL;

    RRETURN(SetErrorInfo(E_NOTIMPL));
}

HRESULT
CDocument::put_baseUrl(BSTR b)
{
    RRETURN(SetErrorInfo(E_NOTIMPL));
}

HRESULT
CDocument::get_inheritStyleSheets(VARIANT_BOOL *pfInherit)
{
    if ( pfInherit )
        *pfInherit = NULL;

    RRETURN(SetErrorInfo(E_NOTIMPL));
}

HRESULT
CDocument::put_inheritStyleSheets(VARIANT_BOOL fInherit)
{
    RRETURN(SetErrorInfo(E_NOTIMPL));
}

HRESULT
CDocument::getElementsByName(BSTR v, IHTMLElementCollection** ppDisp)
{
    HRESULT hr = E_INVALIDARG;

    if (!ppDisp || !v)
        goto Cleanup;

    *ppDisp = NULL;

    hr = THR(Markup()->GetDispByNameOrID(v, (IDispatch **)ppDisp, TRUE));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::getElementsByTagName(BSTR v, IHTMLElementCollection** ppDisp)
{
    HRESULT hr = E_INVALIDARG;
    if (!ppDisp || !v)
        goto Cleanup;

    *ppDisp = NULL;

    // Make sure our collection is up-to-date.
    hr = THR(Markup()->EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    // Check for '*' which means return the 'all' collection
    if ( !StrCmpIC(_T("*"), v) )
    {
        hr = THR(Markup()->CollectionCache()->GetDisp(
                    CMarkup::ELEMENT_COLLECTION,
                    (IDispatch**)ppDisp));
    }
    else
    {
        // Get a collection of the specified tags.
        hr = THR(Markup()->CollectionCache()->GetDisp(
                    CMarkup::ELEMENT_COLLECTION,
                    v,
                    CacheType_Tag,
                    (IDispatch**)ppDisp,
                    FALSE)); // Case sensitivity ignored for TagName
    }

    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDocument::getElementById(BSTR v, IHTMLElement** ppel)
{
    HRESULT hr = E_INVALIDARG;
    CElement *pel = NULL;

    if (!ppel || !v)
        goto Cleanup;

    *ppel = NULL;

    hr = THR(Markup()->GetElementByNameOrID(v, &pel));
    // Didn't find elem with id v, return null, if hr == S_FALSE, more than one elem, return first
    if (FAILED(hr))
    {
        hr = S_OK;
        goto Cleanup;
    }

    Assert(pel);
    hr = THR(pel->QueryInterface(IID_IHTMLElement, (void **)ppel));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

STDMETHODIMP
CDocument::hasFocus(VARIANT_BOOL * pfFocus)
{
    CDoc *  pDoc = Doc();
    HRESULT hr;

    if (!pfFocus)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    *pfFocus = VB_FALSE;
    Assert(pDoc);

    if (pDoc->HasFocus() && pDoc->State() >= OS_UIACTIVE)
    {
        // check if we are the foreground window
        HWND hwndFG = ::GetForegroundWindow();
        HWND hwndDoc = pDoc->_pInPlace->_hwnd;

        Assert(hwndDoc);
        if (hwndFG == hwndDoc || ::IsChild(hwndFG, hwndDoc))
        {
            *pfFocus = VB_TRUE;
        }
    }
    hr = S_OK;
Cleanup:
    RRETURN(SetErrorInfo(hr));
}


STDMETHODIMP
CDocument::focus()
{
    CDoc *  pDoc = Doc();

    Assert(pDoc && pDoc->_pElemCurrent);
    if (pDoc->State() >= OS_UIACTIVE)
    {
        if (!pDoc->HasFocus())
        {
            pDoc->TakeFocus();
        }
    }
    else
    {
        IGNORE_HR(pDoc->_pElemCurrent->BecomeUIActive());
    }
    if (pDoc->State() >= OS_UIACTIVE && pDoc->HasFocus())
    {
        // Make this the foreground window
        HWND hwndFG = ::GetForegroundWindow();
        HWND hwndDoc = pDoc->_pInPlace->_hwnd;
        HWND hwndTop = hwndDoc;

        if (hwndFG != hwndDoc && !::IsChild(hwndFG, hwndDoc))
        {

            // get top level window
            while ((hwndDoc = ::GetParent(hwndDoc)) != NULL)
            {
                hwndTop = hwndDoc;
            }
            ::SetForegroundWindow(hwndTop);
        }
    }

    // This assert could fail because script set focus elsewhere
    // explicitly during ui-activation. When I hit that failure, I will remove this
    // assert.
    Assert(!pDoc->_pInPlace || pDoc->_pInPlace->_fDeactivating || pDoc->HasFocus());
    RRETURN(S_OK);
}


STDMETHODIMP
CDocument::createDocumentFromUrl(BSTR bstrUrl, BSTR bstrOptions, IHTMLDocument2** ppDocumentNew)
{
    return createDocumentFromUrlInternal(bstrUrl, bstrOptions, ppDocumentNew, 0);
}

HRESULT
CDocument::createDocumentFromUrlInternal(BSTR bstrUrl, BSTR bstrOptions, IHTMLDocument2** ppDocumentNew, DWORD dwFlagsInternal /*=0*/)
{
    HRESULT             hr                  = S_OK;
    TCHAR *             pchUrl              = bstrUrl;
    DWORD               dwBindf             = 0;
    TCHAR               cBuf[pdlUrlLen];
    TCHAR *             pchExpandedUrl      = cBuf;
    COmWindowProxy *    pWindow             = NULL;
    CDoc *              pDoc                = Doc();
    CDwnDoc *           pDwnDoc;
    CMarkup *           pMarkup             = Markup();
    DWORD               dwFlags             = CDoc::FHL_CREATEDOCUMENTFROMURL;

    if (!ppDocumentNew)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppDocumentNew = NULL;

    cBuf[0] = _T('\0');

    if (!pchUrl || !*pchUrl)
        goto Cleanup;

    CMarkup::ExpandUrl(pMarkup, pchUrl, ARRAY_SIZE(cBuf), pchExpandedUrl, NULL);

    if (pMarkup->IsUrlRecursive(pchExpandedUrl))
        goto Cleanup;

    pDwnDoc = pMarkup->GetDwnDoc();
    if (pDwnDoc)
    {
        dwBindf = pDwnDoc->GetBindf();
    }

    // Parse the options to look for directives.
    if (bstrOptions)
    {
        CDataListEnumerator   dleOptions(bstrOptions, _T(' '));
        LPCTSTR pch = NULL; // keep compiler happy
        INT     cch = 0;    // keep compiler happy

        while (dleOptions.GetNext(&pch, &cch))
        {
            switch (cch)
            {
                case 5:
                    if ( !_tcsnicmp(pch, cch, L"print", cch) )  // 'Cuz there is no _wcsnicmp - and _tcsnicmp is hardwired wide.
                    {
                        if (    !!(dwFlagsInternal & CDFU_DONTVERIFYPRINT)
                            ||  pMarkup->IsPrintTemplate())
                        {
                            dwFlags |= CDoc::FHL_SETTARGETPRINTMEDIA;
                        }
                        else
                        {
                            hr = E_ACCESSDENIED;
                            goto Cleanup;
                        }
                    }
                    break;
            }
        }
    }

    hr = THR(pDoc->FollowHyperlink(
            pchExpandedUrl,
            NULL,               // pchTarget
            NULL,               // pElementContext
            NULL,               // pDwnPost
            FALSE,              // fSendAsPost
            NULL,               // pchExtraHeaders
            TRUE,               // fOpenInNewWindow
            pMarkup->GetFrameOrPrimaryMarkup()->Window(),  // pWindow - pass our OM window ("this" == the OM document)
            &pWindow,           // ppWindowOut
            dwBindf,            // dwBindf
            ERROR_SUCCESS,      // dwSecurityCode
            FALSE,              // fReplace
            NULL,               // ppHTMLWindow2
            FALSE,              // fOpenInNewBrowser
            dwFlags             // dwFlags
            ));

    if (pWindow)
    {
        Assert(pWindow->Document() && pWindow->Window()->_pMarkup);
        IGNORE_HR( pWindow->Window()->_pMarkup->SetOrphanedMarkup( TRUE ) );
        hr = pWindow->Document()->QueryInterface(IID_IHTMLDocument2, (void**)ppDocumentNew);
    }

Cleanup:
    if (pWindow)
    {
        pWindow->Release();
    }

    RRETURN(SetErrorInfo(hr));
}



STDMETHODIMP
CDocument::createEventObject(VARIANT *pvarEventObject, IHTMLEventObj** ppEventObj)
{
    CDoc *  pDoc = Doc();

    EVENTPARAM *pParam = NULL;
    HRESULT hr;

    if (!ppEventObj)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // if event object passed in, copy it, else create new one on heap and init it.
    if (pvarEventObject && V_VT(pvarEventObject) == VT_DISPATCH)
    {
        CEventObj *pSrcEventObj;

        hr = THR(V_DISPATCH(pvarEventObject)->QueryInterface(CLSID_CEventObj, (void **)&pSrcEventObj));
        if (hr)
            goto Cleanup;

        pSrcEventObj->GetParam(&pParam);
        if (!pParam)
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }
    }

    hr = THR(CEventObj::Create(ppEventObj, pDoc, NULL, Markup(), FALSE, NULL, pParam));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+-------------------------------------------------------------------------
//
//  CFramesCoolection
//
//--------------------------------------------------------------------------

const CBase::CLASSDESC CFramesCollection::s_classdesc =
{
    &CLSID_FramesCollection,        // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLFramesCollection2,    // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

CFramesCollection::CFramesCollection(CDocument * pDocument)
    : _pDocument(pDocument)
{
    Assert(_pDocument);
    _pDocument->SubAddRef();
}

void
CFramesCollection::Passivate()
{
    Assert(_pDocument);
    _pDocument->SubRelease();
    _pDocument = NULL;
    super::Passivate();
}

STDMETHODIMP
CFramesCollection::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_TEAROFF_DISPEX(this, NULL)
        QI_INHERITS(this, IHTMLFramesCollection2)
    }
    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
        RRETURN(E_NOINTERFACE);
}

STDMETHODIMP
CFramesCollection::item(VARIANTARG *pvarArg1, VARIANTARG * pvarRes)
{
    RRETURN (SetErrorInfo(_pDocument->item(pvarArg1, pvarRes)));
}

STDMETHODIMP
CFramesCollection::get_length(long * pcFrames)
{
    RRETURN (SetErrorInfo(_pDocument->get_length(pcFrames)));
}

//+-------------------------------------------------------------------------
//
//  CScreen - implementation for the window.screen object
//
//--------------------------------------------------------------------------

IMPLEMENT_FORMS_SUBOBJECT_IUNKNOWN(CScreen, CWindow, _Screen)

const CBase::CLASSDESC CScreen::s_classdesc =
{
    &CLSID_HTMLScreen,              // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLScreen,               // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

//+-------------------------------------------------------------------------
//
//  CScreen:: property members
//
//--------------------------------------------------------------------------

STDMETHODIMP CScreen::get_colorDepth(long*p)
{
    if (!p)
        RRETURN (E_POINTER);
    long d = MyCWindow()->Doc()->_bufferDepth;
    if (d > 0)
        *p = d;
    else
    {
        // TODO: If code can run during printing, we should figure out
        // how to get to the color depth of the printer.
        // If not, we could add BITSPIXEL as a TLS cached item.
        *p = GetDeviceCaps(TLS(hdcDesktop), BITSPIXEL);
    }
    return S_OK;
}

STDMETHODIMP CScreen::get_logicalXDPI(long *plXDPI)
{   
    const SIZE size = g_uiDisplay.GetDocPixelsPerInch();

    if (!plXDPI)
        return E_INVALIDARG;

    *plXDPI = size.cx;

    return S_OK;
}

STDMETHODIMP CScreen::get_logicalYDPI(long *plYDPI)
{
    const SIZE size = g_uiDisplay.GetDocPixelsPerInch();

    if (!plYDPI)
        return E_INVALIDARG;

    *plYDPI = size.cy;

    return S_OK;
}

STDMETHODIMP CScreen::get_deviceXDPI(long *plXDPI)
{
    const SIZE size = g_uiDisplay.GetResolution();

    if (!plXDPI)
        return E_INVALIDARG;

    *plXDPI = size.cx;

    return S_OK;
}

STDMETHODIMP CScreen::get_deviceYDPI(long *plYDPI)
{
    const SIZE size = g_uiDisplay.GetResolution();
    
    if (!plYDPI)
        return E_INVALIDARG;

    *plYDPI = size.cy;

    return S_OK;
}

STDMETHODIMP CScreen::put_bufferDepth(long v)
{
    switch (v)
    {
    case 0:                     // 0 means no explicit buffering requested
    case -1:                    // -1 means buffer at screen depth
    case 1:                     // other values are specific buffer depths...
    case 4:
    case 8:
    case 16:
    case 24:
    case 32:
        break;
    default:
        v = -1;                 // for unknown values, use screen depth
        break;
    }

    CDoc *pDoc = MyCWindow()->Doc();
    if (pDoc->_bufferDepth != v)
    {
        pDoc->_bufferDepth = v;
        pDoc->Invalidate();
    }
    return S_OK;
}

STDMETHODIMP CScreen::get_bufferDepth(long*p)
{
    if (!p)
        RRETURN (E_POINTER);
    *p = MyCWindow()->Doc()->_bufferDepth;
    return S_OK;
}

STDMETHODIMP CScreen::get_width(long*p)
{
    if (!p)
        RRETURN (E_POINTER);
    // TODO: Implement the printer case.
    *p = g_uiDisplay.DocPixelsFromDeviceX(GetDeviceCaps(TLS(hdcDesktop), HORZRES));
    return S_OK;
}

STDMETHODIMP CScreen::get_height(long*p)
{
    if (!p)
        RRETURN (E_POINTER);
    // TODO: Implement the printer case.
    *p = g_uiDisplay.DocPixelsFromDeviceY(GetDeviceCaps(TLS(hdcDesktop), VERTRES));
    return S_OK;
}

//----------------------------------------------------------------------------
//  Member: put_updateInterval
//
//  Synopsis:   updateInterval specifies the interval between painting invalid
//              regions. This is used for throttling mutliple objects randomly
//              invalidating regions to a specific update time.
//              interval specifies milliseconds.
//----------------------------------------------------------------------------
STDMETHODIMP CScreen::put_updateInterval(long interval)
{
    MyCWindow()->Doc()->UpdateInterval( interval );
    return S_OK;
}

STDMETHODIMP CScreen::get_updateInterval(long*p)
{
    if (!p)
        RRETURN (E_POINTER);
    *p = MyCWindow()->Doc()->GetUpdateInterval();
    return S_OK;
}

STDMETHODIMP CScreen::get_availHeight(long*p)
{
    HRESULT hr = S_OK;
    RECT    Rect;
    BOOL    fRes;

    if(p == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = 0;

    // BUGWIN16 replace with GetSystemMetrics on Win16
    fRes = ::SystemParametersInfo(SPI_GETWORKAREA, 0, &Rect, 0);
    if(!fRes)
    {
        hr = HRESULT_FROM_WIN32(GetLastWin32Error());
        goto Cleanup;
    }

    *p = Rect.bottom - Rect.top;
    *p = g_uiDisplay.DocPixelsFromDeviceY(*p);

Cleanup:
    RRETURN(hr);
}

STDMETHODIMP CScreen::get_availWidth(long*p)
{
    HRESULT hr = S_OK;
    RECT    Rect;
    BOOL    fRes;

    if(p == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = 0;

    // BUGWIN16 replace with GetSystemMetrics on Win16
    fRes = ::SystemParametersInfo(SPI_GETWORKAREA, 0, &Rect, 0);
    if(!fRes)
    {
        hr = HRESULT_FROM_WIN32(GetLastWin32Error());
        goto Cleanup;
    }

    *p = Rect.right - Rect.left;
    *p = g_uiDisplay.DocPixelsFromDeviceX(*p);

Cleanup:
    RRETURN(hr);
}

STDMETHODIMP CScreen::get_fontSmoothingEnabled(VARIANT_BOOL*p)
{
    HRESULT hr = S_OK;
    BOOL    fSmoothing;
    BOOL    fRes;

    if(p == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = VB_FALSE;

    // BUGWIN16 replace with GetSystemMetrics on Win16
    fRes = ::SystemParametersInfo(SPI_GETFONTSMOOTHING, 0, &fSmoothing, 0);
    if(!fRes)
    {
        hr = HRESULT_FROM_WIN32(GetLastWin32Error());
        goto Cleanup;
    }

    if(fSmoothing)
        *p = VB_TRUE;

Cleanup:
    RRETURN(hr);
}
//+-------------------------------------------------------------------------
//
//  Method:     CScreen::QueryInterface
//
//--------------------------------------------------------------------------

HRESULT
CScreen::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    *ppv = NULL;

    switch (iid.Data1)
    {
     QI_INHERITS(this, IUnknown)
     QI_TEAROFF2(this, IDispatch, IHTMLScreen, NULL)
     QI_TEAROFF(this, IHTMLScreen, NULL)
     QI_TEAROFF(this, IHTMLScreen2, NULL)
     QI_TEAROFF(this, IObjectIdentity, NULL)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }
    else
    {
        HRESULT hr;
        
        if (DispNonDualDIID(iid))
        {
            hr = THR( CreateTearOffThunk(this, (void *)s_apfnIHTMLScreen, NULL, ppv) );
        }
        else
        {
            hr = E_NOINTERFACE;
        }

        RRETURN(hr);
    }
}

HRESULT CScreen::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    return QueryInterface(iid, ppv);
}

//+---------------------------------------------------------------------------
//
//  member :    CWindow::put_offscreenBuffering
//
//  Synopsis :  Set whether we paint using offscreen buffering
//
//----------------------------------------------------------------------------
HRESULT
CWindow::put_offscreenBuffering(VARIANT var)
{
    HRESULT     hr;
    CVariant    varTemp;

    hr = varTemp.CoerceVariantArg( &var, VT_BOOL );
    if ( DISP_E_TYPEMISMATCH == hr )
    {
        // handle Nav 4 compat where "" is the same as FALSE
        // and anything in a string is considered TRUE
        if ( VT_BSTR == V_VT(&var) )
        {
            V_VT(&varTemp) = VT_BOOL;
            hr = S_OK;
            if ( 0 == SysStringByteLen(V_BSTR(&var)) )
                V_BOOL(&varTemp) = VB_FALSE;
            else
                V_BOOL(&varTemp) = VB_TRUE;
        }
    }
    if ( SUCCEEDED(hr) )
    {
        Doc()->SetOffscreenBuffering(BOOL_FROM_VARIANT_BOOL(V_BOOL(&varTemp)));
    }
    return SetErrorInfo(hr);
}


//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_offscreenBuffering
//
//  Synopsis :  Return string/bool of tristate: auto, true, or false
//
//----------------------------------------------------------------------------
HRESULT
CWindow::get_offscreenBuffering(VARIANT *pvar)
{
    HRESULT hr = S_OK;
    int buffering;      // -1 = auto, 0=false, 1=true

    if (!pvar)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    buffering = Doc()->GetOffscreenBuffering();
    if ( buffering < 0 )
    {
        V_VT(pvar) = VT_BSTR;
        hr = THR(FormsAllocString ( _T("auto"), &V_BSTR(pvar)));
    }
    else
    {
        V_VT(pvar) = VT_BOOL;
        V_BOOL(pvar) = VARIANT_BOOL_FROM_BOOL(!!buffering);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------------------
//
//  Member:     CWindow::get_external
//
//  Synopsis:   Get IDispatch object associated with the IDocHostUIHandler
//
//---------------------------------------------------------------------------
HRESULT
CWindow::get_external(IDispatch **ppDisp)
{
    HRESULT hr = S_OK;

    if (!ppDisp)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppDisp = NULL;

    if (Doc()->_pHostUIHandler)
    {
        hr = Doc()->_pHostUIHandler->GetExternal(ppDisp);
            if (hr == E_NOINTERFACE)
            {
                hr = S_OK;
                Assert(*ppDisp == NULL);
            }
            else if (hr)
                goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

CAtomTable *
CWindow::GetAtomTable (BOOL *pfExpando)
{
    if (pfExpando)
    {
        *pfExpando = Markup()->_fExpando;
    }

    return &(Doc()->_AtomTable);
}

//+---------------------------------------------------------------------------
//
//  member :    CWindow::get_clipboardData
//
//  Synopsis :  Return the data transfer object.
//
//----------------------------------------------------------------------------
HRESULT
CWindow::get_clipboardData(IHTMLDataTransfer **ppDataTransfer)
{
    HRESULT hr = S_OK;
    CDataTransfer * pDataTransfer;
    IDataObject * pDataObj = NULL;

    if (!ppDataTransfer)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppDataTransfer = NULL;

    hr = THR(OleGetClipboard(&pDataObj));
    if (hr)
        goto Cleanup;

    pDataTransfer = new CDataTransfer(this, pDataObj, FALSE);  // fDragDrop = FALSE

    pDataObj->Release();    // extra addref from OleGetClipboard

    if (!pDataTransfer)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = THR(pDataTransfer->QueryInterface(
                IID_IHTMLDataTransfer,
                (void **) ppDataTransfer));
        pDataTransfer->Release();
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//---------------------------------------------------------------------------
//
//  CDataTransfer ClassDesc
//
//---------------------------------------------------------------------------

const CBase::CLASSDESC CDataTransfer::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLDataTransfer,             // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};



//---------------------------------------------------------------------------
//
//  Member:     CDataTransfer::CDataTransfer
//
//  Synopsis:   ctor
//
//---------------------------------------------------------------------------

CDataTransfer::CDataTransfer(CWindow * pWindow, IDataObject * pDataObj, BOOL fDragDrop)
{
    _pWindow = pWindow;
    _pWindow->SubAddRef();
    _pDataObj = pDataObj;
    _pDataObj->AddRef();
    _fDragDrop = fDragDrop;
}


//---------------------------------------------------------------------------
//
//  Member:     CDataTransfer::~CDataTransfer
//
//  Synopsis:   dtor
//
//---------------------------------------------------------------------------

CDataTransfer::~CDataTransfer()
{
    _pWindow->SubRelease();
    _pDataObj->Release();
}

//+-------------------------------------------------------------------------
//
//  Method:     CDataTransfer::PrivateQueryInterface
//
//  Synopsis:   Per IPrivateUnknown
//
//--------------------------------------------------------------------------

HRESULT
CDataTransfer::PrivateQueryInterface(REFIID iid, LPVOID * ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
    QI_TEAROFF_DISPEX(this, NULL)
    QI_TEAROFF(this, IHTMLDataTransfer, NULL)
    QI_TEAROFF2(this, IUnknown, IHTMLDataTransfer, NULL)
    QI_TEAROFF(this, IServiceProvider, NULL)
    default:
        RRETURN(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CDataTransfer::QueryService
//
//  Synopsis:   Per IServiceProvider
//
//--------------------------------------------------------------------------

HRESULT
CDataTransfer::QueryService(REFGUID rguidService, REFIID riid, void ** ppvService)
{
    HRESULT hr;

    if (    IsEqualGUID(rguidService, IID_IDataObject)
        &&  IsEqualGUID(riid,         IID_IDataObject))
    {
        IDataObject * pDataObj = NULL;

        if (_fDragDrop)
        {
            *ppvService = _pDataObj;
        }
        else
        {
            IDataObject * pDataTLS = TLS(pDataClip);

            // TODO (jbeda) There are slight problems with keeping
            // this data on the TLS since the CGenDataObject holds
            // onto the doc. 1) Strangeness if more than one doc is in
            // play 2) The doc could go away but the CGenDataObject is
            // still on the clipboard.  This should really be on the doc
            // and flushed during the CDoc's passivate.

            if (pDataTLS)
            {
                *ppvService = pDataTLS;
            }
            else
            {
                pDataObj = new CGenDataObject(_pWindow->Doc());
                if (pDataObj == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                _pWindow->SetClipboard(pDataObj);

                *ppvService = pDataObj;
            }
        }

        ((IUnknown*)(*ppvService))->AddRef();
        if (pDataObj)
            pDataObj->Release();

        hr = S_OK;
    }
    else
    {
        *ppvService = NULL;
        hr = E_NOINTERFACE;
    }

Cleanup:
    RRETURN(hr);
}



static HRESULT copyBstrToHglobal(BOOL fAnsi, BSTR bstr, HGLOBAL *phglobal)
{
    HRESULT hr      = S_OK;
    void *  pvText;
    DWORD   cbSize;
    DWORD   cch     = FormsStringLen(bstr) + 1;

    Assert(phglobal);

    if (fAnsi)
    {
        cbSize = WideCharToMultiByte(CP_ACP, 0, bstr, cch, NULL, 0, NULL, NULL);
        if (!cbSize)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else // unicode
    {
        cbSize = cch * sizeof(TCHAR);
    }
    *phglobal = GlobalAlloc(GMEM_MOVEABLE, cbSize);
    if (!*phglobal)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    pvText = GlobalLock(*phglobal);
    if (!pvText)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    if (fAnsi)
    {
        if (!WideCharToMultiByte(CP_ACP, 0, bstr, cch, (char*)pvText, cbSize, NULL, NULL))
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else
    {
        memcpy((TCHAR *)pvText, bstr, cbSize);
    }
    GlobalUnlock(*phglobal);

Cleanup:
    RRETURN(hr);
Error:
    if (*phglobal)
        GlobalFree(*phglobal);
    *phglobal = NULL;
    goto Cleanup;
}

HRESULT
CDataTransfer::setData(BSTR format, VARIANT* data, VARIANT_BOOL* pret)
{
    HRESULT hr = S_OK;
    STGMEDIUM stgmed = {0, NULL};
    FORMATETC fmtc;
    TCHAR * pchData = NULL;
    VARIANT *pvarData;
    EVENTPARAM * pparam;
    IDataObject * pDataObj = NULL;
    BOOL fCutCopy = TRUE;
    BOOL fAddRef = TRUE;
    CDragStartInfo * pDragStartInfo = _pWindow->Doc()->_pDragStartInfo;
    IUniformResourceLocator * pUrlToDrag = NULL;

    if (!_fDragDrop)    // access to window.clipboardData.setData
    {
        BOOL fAllow;
        hr = THR(_pWindow->Markup()->ProcessURLAction(URLACTION_SCRIPT_PASTE, &fAllow));
        if (hr || !fAllow)
            goto Error;       // Fail silently
    }

    pparam = _pWindow->Doc()->_pparam;

    if (pparam)
    {
        LPCTSTR pchType = pparam->GetType();
        fCutCopy = pchType && (!StrCmpIC(_T("cut"), pchType) || !StrCmpIC(_T("copy"), pchType));
    }

    if (_fDragDrop && pDragStartInfo)
        pDataObj = _pDataObj;
    else
    {
        IDataObject * pDataTLS = TLS(pDataClip);

        // TODO (jbeda) There are slight problems with keeping
        // this data on the TLS since the CGenDataObject holds
        // onto the doc. 1) Strangeness if more than one doc is in
        // play 2) The doc could go away but the CGenDataObject is
        // still on the clipboard.  This should really be on the doc
        // and flushed during the CDoc's passivate.

        fCutCopy = TRUE;
        if (pDataTLS)
            pDataObj = pDataTLS;
        else
        {
            pDataObj = new CGenDataObject(_pWindow->Doc());
            if (pDataObj == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }
            fAddRef = FALSE;
        }
    }

    if (!pDataObj)
    {
        AssertSz(FALSE, "The pDataObj pointer is NULL. We need to understand this scenario. Contact:FerhanE");
        goto Error;
    }

    if (fAddRef)
        pDataObj->AddRef();

    if (!pret)
    {
        hr = E_POINTER;
        goto Error;
    }

    pvarData = (data && (V_VT(data) == (VT_BYREF | VT_VARIANT))) ?
        V_VARIANTREF(data) : data;

    if (pvarData)
    {
        if (V_VT(pvarData) == VT_BSTR)
            pchData = V_BSTR(pvarData);
        else
        {
            hr = E_INVALIDARG;
            goto Error;
        }
    }

    if (!StrCmpIC(format, _T("Text")))
    {
        // First. set as unicode text
        if (pchData)
        {
            hr = copyBstrToHglobal(FALSE, pchData, &(stgmed.hGlobal));
            if (hr)
                goto Error;
        }
        else
            stgmed.hGlobal = NULL;

        stgmed.tymed = TYMED_HGLOBAL;
        fmtc.cfFormat = CF_UNICODETEXT;
        fmtc.ptd = NULL;
        fmtc.dwAspect = DVASPECT_CONTENT;
        fmtc.lindex = -1;
        fmtc.tymed = TYMED_HGLOBAL;

        hr = pDataObj->SetData(&fmtc, &stgmed, TRUE);
        if (hr)
            goto Error;

        // Now, set as ansi text
        if (pchData)
        {
            hr = copyBstrToHglobal(TRUE, pchData, &(stgmed.hGlobal));
            if (hr)
                goto Error;
        }
        fmtc.cfFormat = CF_TEXT;

        hr = pDataObj->SetData(&fmtc, &stgmed, TRUE);
        if (hr)
            goto Error;
    }
    else if (!StrCmpIC(format, _T("Url")))
    {
        IDataObject * pLinkDataObj;

        if (pDragStartInfo && pDragStartInfo->_pUrlToDrag)
            hr = pDragStartInfo->_pUrlToDrag->SetURL(pchData, 0);
        else if (pchData && (pDragStartInfo || fCutCopy))
        {
            hr = THR(CreateLinkDataObject(pchData, NULL, &pUrlToDrag));
            if (hr)
                goto Cleanup;

            hr = THR(pUrlToDrag->QueryInterface(IID_IDataObject, (void **) &pLinkDataObj));
            if (hr)
                goto Cleanup;

            ReplaceInterface(&(DYNCAST(CBaseBag, pDataObj)->_pLinkDataObj), pLinkDataObj);
            pLinkDataObj->Release();
        }
    }
    else if (!data)
    {
        if (!StrCmpIC(format, _T("File")))
            fmtc.cfFormat = CF_HDROP;
        else if (!StrCmpIC(format, _T("Html")))
            fmtc.cfFormat = cf_HTML;
        else if (!StrCmpIC(format, _T("Image")))
            fmtc.cfFormat = CF_DIB;
        else
        {
            hr = E_UNEXPECTED;
            goto Error;
        }

        stgmed.hGlobal = NULL;
        stgmed.tymed = TYMED_HGLOBAL;
        fmtc.ptd = NULL;
        fmtc.dwAspect = DVASPECT_CONTENT;
        fmtc.lindex = -1;
        fmtc.tymed = TYMED_HGLOBAL;

        hr = pDataObj->SetData(&fmtc, &stgmed, TRUE);
        if (hr)
            goto Error;
    }
    else
    {
        hr = E_UNEXPECTED;
        goto Error;
    }

    if (fCutCopy)
        _pWindow->SetClipboard(pDataObj);

    *pret = VB_TRUE;
Cleanup:
    ReleaseInterface(pDataObj);
    ReleaseInterface(pUrlToDrag);
    RRETURN(SetErrorInfo(hr));
Error:
    if (stgmed.hGlobal)
        GlobalFree(stgmed.hGlobal);
    if (pret)
        *pret = VB_FALSE;
    goto Cleanup;
}

HRESULT
CDataTransfer::getData(BSTR format, VARIANT* pvarRet)
{
    HRESULT hr = S_OK;
    STGMEDIUM stgmed = {0, NULL};
    FORMATETC fmtc;
    HGLOBAL hGlobal = NULL;
    HGLOBAL hUnicode = NULL;
    TCHAR * pchText = NULL;
    IUniformResourceLocator * pUrlToDrag = NULL;

    if (!_fDragDrop)    // access to window.clipboardData.getData
    {
        BOOL fAllow;
        hr = THR(_pWindow->Markup()->ProcessURLAction(URLACTION_SCRIPT_PASTE, &fAllow));
        if (hr || !fAllow)
            goto Cleanup;       // Fail silently
    }

    if (!pvarRet)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!StrCmpIC(format, _T("Text")))
    {
        fmtc.cfFormat = CF_UNICODETEXT;
        fmtc.ptd = NULL;
        fmtc.dwAspect = DVASPECT_CONTENT;
        fmtc.lindex = -1;
        fmtc.tymed = TYMED_HGLOBAL;

        if (    (_pDataObj->QueryGetData(&fmtc) == NOERROR)
            &&  (_pDataObj->GetData(&fmtc, &stgmed) == S_OK))
        {
            hGlobal = stgmed.hGlobal;
            pchText = (TCHAR *) GlobalLock(hGlobal);
        }
        else
        {
            fmtc.cfFormat = CF_TEXT;
            if (    (_pDataObj->QueryGetData(&fmtc) == NOERROR)
                &&  (_pDataObj->GetData(&fmtc, &stgmed) == S_OK))
            {
                hGlobal = stgmed.hGlobal;
                hUnicode = TextHGlobalAtoW(hGlobal);
                pchText    = (TCHAR *) GlobalLock(hUnicode);
            }
            else
            {
                V_VT(pvarRet) = VT_NULL;
                hr = S_OK;
                goto Cleanup;
            }
        }

        if (!pchText)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        V_VT(pvarRet) = VT_BSTR;
        V_BSTR(pvarRet) = SysAllocString(pchText);
    }
    else if (!StrCmpIC(format, _T("Url")))
    {
        hr = _pDataObj->QueryInterface(IID_IUniformResourceLocator, (void**)&pUrlToDrag);
        if (hr && DYNCAST(CBaseBag, _pDataObj)->_pLinkDataObj)
            hr = DYNCAST(CBaseBag, _pDataObj)->_pLinkDataObj->QueryInterface(IID_IUniformResourceLocator, (void**)&pUrlToDrag);
        if (hr)
        {
            V_VT(pvarRet) = VT_NULL;
            hr = S_OK;
            goto Cleanup;
        }

        hr = pUrlToDrag->GetURL(&pchText);
        if (hr)
            goto Cleanup;

        V_VT(pvarRet) = VT_BSTR;
        V_BSTR(pvarRet) = SysAllocString(pchText);
        CoTaskMemFree(pchText);
    }
    else
        hr = E_UNEXPECTED;


Cleanup:
    if (hGlobal)
    {
        GlobalUnlock(hGlobal);
        ReleaseStgMedium(&stgmed);
    }
    if (hUnicode)
    {
        GlobalUnlock(hUnicode);
        GlobalFree(hUnicode);
    }
    ReleaseInterface(pUrlToDrag);

    RRETURN(_pWindow->Doc()->SetErrorInfo(hr));
}

HRESULT
CDataTransfer::clearData(BSTR format, VARIANT_BOOL* pret)
{
    HRESULT hr = S_OK;

    if (!StrCmpIC(format, _T("null")))
    {
        IGNORE_HR(setData(_T("Text"), NULL, pret));
        IGNORE_HR(setData(_T("Url"), NULL, pret));
        IGNORE_HR(setData(_T("File"), NULL, pret));
        IGNORE_HR(setData(_T("Html"), NULL, pret));
        IGNORE_HR(setData(_T("Image"), NULL, pret));
    }
    else
    {
        hr = setData(format, NULL, pret);
    }

    RRETURN(hr);
}

HRESULT
CDataTransfer::get_dropEffect(BSTR *pbstrDropEffect)
{
    HRESULT hr;
    htmlDropEffect dropEffect = htmlDropEffectNone;
    EVENTPARAM * pparam;

    if (!_fDragDrop)
    {
        *pbstrDropEffect = NULL;
        hr = S_OK;
        goto Cleanup;
    }

    if (pbstrDropEffect == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pparam = _pWindow->Doc()->_pparam;

    switch (pparam->dwDropEffect)
    {
    case DROPEFFECT_COPY:
        dropEffect = htmlDropEffectCopy;
        break;
    case DROPEFFECT_LINK:
        dropEffect = htmlDropEffectLink;
        break;
    case DROPEFFECT_MOVE:
        dropEffect = htmlDropEffectMove;
        break;
    case DROPEFFECT_NONE:
        dropEffect = htmlDropEffectNone;
        break;
    default:
        Assert(FALSE);
    }

    hr = THR(STRINGFROMENUM(htmlDropEffect, (long) dropEffect, pbstrDropEffect));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDataTransfer::put_dropEffect(BSTR bstrDropEffect)
{
    HRESULT hr;
    htmlDropEffect dropEffect;
    EVENTPARAM * pparam;

    if (!_fDragDrop)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR(ENUMFROMSTRING(htmlDropEffect, bstrDropEffect, (long *) &dropEffect));
    if (hr)
        goto Cleanup;

    pparam = _pWindow->Doc()->_pparam;

    switch (dropEffect)
    {
    case htmlDropEffectCopy:
        pparam->dwDropEffect = DROPEFFECT_COPY;
        break;
    case htmlDropEffectLink:
        pparam->dwDropEffect = DROPEFFECT_LINK;
        break;
    case htmlDropEffectMove:
        pparam->dwDropEffect = DROPEFFECT_MOVE;
        break;
    case htmlDropEffectNone:
        pparam->dwDropEffect = DROPEFFECT_NONE;
        break;
    default:
        Assert(FALSE);
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CDataTransfer::get_effectAllowed(BSTR *pbstrEffectAllowed)
{
    HRESULT hr;
    htmlEffectAllowed effectAllowed;
    CDragStartInfo * pDragStartInfo = _pWindow->Doc()->_pDragStartInfo;

    if (!_fDragDrop)
    {
        *pbstrEffectAllowed = NULL;
        hr = S_OK;
        goto Cleanup;
    }

    if (pbstrEffectAllowed == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!pDragStartInfo)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    switch (pDragStartInfo->_dwEffectAllowed)
    {
    case DROPEFFECT_COPY:
        effectAllowed = htmlEffectAllowedCopy;
        break;
    case DROPEFFECT_LINK:
        effectAllowed = htmlEffectAllowedLink;
        break;
    case DROPEFFECT_MOVE:
        effectAllowed = htmlEffectAllowedMove;
        break;
    case DROPEFFECT_COPY | DROPEFFECT_LINK:
        effectAllowed = htmlEffectAllowedCopyLink;
        break;
    case DROPEFFECT_COPY | DROPEFFECT_MOVE:
        effectAllowed = htmlEffectAllowedCopyMove;
        break;
    case DROPEFFECT_LINK | DROPEFFECT_MOVE:
        effectAllowed = htmlEffectAllowedLinkMove;
        break;
    case DROPEFFECT_COPY | DROPEFFECT_LINK | DROPEFFECT_MOVE:
        effectAllowed = htmlEffectAllowedAll;
        break;
    case DROPEFFECT_NONE:
        effectAllowed = htmlEffectAllowedNone;
        break;
    default:
        effectAllowed = htmlEffectAllowedUninitialized;
        break;
    }

    hr = THR(STRINGFROMENUM(htmlEffectAllowed, (long) effectAllowed, pbstrEffectAllowed));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CDataTransfer::put_effectAllowed(BSTR bstrEffectAllowed)
{
    HRESULT hr;
    htmlEffectAllowed effectAllowed;
    CDragStartInfo * pDragStartInfo = _pWindow->Doc()->_pDragStartInfo;

    if (!_fDragDrop)
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (!pDragStartInfo)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    hr = THR(ENUMFROMSTRING(htmlEffectAllowed, bstrEffectAllowed, (long *) &effectAllowed));
    if (hr)
        goto Cleanup;

    switch (effectAllowed)
    {
    case htmlEffectAllowedCopy:
        pDragStartInfo->_dwEffectAllowed = DROPEFFECT_COPY;
        break;
    case htmlEffectAllowedLink:
        pDragStartInfo->_dwEffectAllowed = DROPEFFECT_LINK;
        break;
    case htmlEffectAllowedMove:
        pDragStartInfo->_dwEffectAllowed = DROPEFFECT_MOVE;
        break;
    case htmlEffectAllowedCopyLink:
        pDragStartInfo->_dwEffectAllowed = DROPEFFECT_COPY | DROPEFFECT_LINK;
        break;
    case htmlEffectAllowedCopyMove:
        pDragStartInfo->_dwEffectAllowed = DROPEFFECT_COPY | DROPEFFECT_MOVE;
        break;
    case htmlEffectAllowedLinkMove:
        pDragStartInfo->_dwEffectAllowed = DROPEFFECT_LINK | DROPEFFECT_MOVE;
        break;
    case htmlEffectAllowedAll:
        pDragStartInfo->_dwEffectAllowed = DROPEFFECT_COPY | DROPEFFECT_LINK | DROPEFFECT_MOVE;
        break;
    case htmlEffectAllowedNone:
        pDragStartInfo->_dwEffectAllowed = DROPEFFECT_NONE;
        break;
    case htmlEffectAllowedUninitialized:
        pDragStartInfo->_dwEffectAllowed = DROPEFFECT_UNINITIALIZED;
        break;
    default:
        Assert(FALSE);
    }

Cleanup:
    RRETURN(hr);
}

extern  DYNLIB g_dynlibUSER32;
DYNPROC        g_dynprocIsWinEventHookInstalled = { NULL, &g_dynlibUSER32, "IsWinEventHookInstalled" };
BOOL           g_fIsWinEventHookInstalled       = TRUE; // TRUE if there is somebody listening to MSAA focus events,
                                                        // TRUE by default for Downlevel platform support.

#define DONOTHING_ISWINEVENTHOOKINSTALLED (BOOL (APIENTRY *)(DWORD))1

HRESULT
CWindow::FireAccessibilityEvents(DISPID dispidEvent)
{
    HRESULT hr   = S_OK;
    CDoc  * pDoc = Doc();
    Assert(pDoc);

    if (g_dynprocIsWinEventHookInstalled.pfn != DONOTHING_ISWINEVENTHOOKINSTALLED)
    {
        if (!g_dynprocIsWinEventHookInstalled.pfn)
        {
            IGNORE_HR(LoadProcedure(&g_dynprocIsWinEventHookInstalled));
            if (!g_dynprocIsWinEventHookInstalled.pfn)
            {
                //API not supported
                g_dynprocIsWinEventHookInstalled.pfn = DONOTHING_ISWINEVENTHOOKINSTALLED;
                goto CallFireAccessibilityEvents;
            }
        }

        Assert(g_dynprocIsWinEventHookInstalled.pfn);

        g_fIsWinEventHookInstalled = (*(BOOL (APIENTRY *)(DWORD)) g_dynprocIsWinEventHookInstalled.pfn)(EVENT_OBJECT_FOCUS);
    }

CallFireAccessibilityEvents:
    if (IsPrimaryWindow())
    {
        // top level window is the OBJID_WINDOW, which is 0
        hr = THR(pDoc->FireAccessibilityEvents(dispidEvent, OBJID_WINDOW, TRUE));
    }
    else
    {
        hr = THR(pDoc->FireAccessibilityEvents(dispidEvent, (CBase *)this, TRUE));
    }

    RRETURN(hr);
}

//
// get a window proxy that we can return to the script environment,
//
COmWindowProxy *
COmWindowProxy::GetSecureWindowProxy(BOOL fClearWindow /* = FALSE */)
{
    IHTMLWindow2 * pIHTMLWindow2 = NULL;

    IGNORE_HR(SecureObject( this, &pIHTMLWindow2));

    //
    // Make the script collection point to the secure object we created.
    // if it is not already doing so.
    // This is only done if we are not shutting down this markup.
    //
    if (!fClearWindow)
        Markup()->GetScriptCollection();

    // We know for sure that the pIHTMLWindow2 is a COmWindowProxy
    // in the same thread. Casting is OK.
    return ((COmWindowProxy *)pIHTMLWindow2);
}

//+------------------------------------------------------------------------
//
//  Member   : CDocument::GetClassID
//
//  Synopsis : Per IPersist
//
//-------------------------------------------------------------------------

STDMETHODIMP
CDocument::GetClassID(CLSID * pclsid)
{
    if (!pclsid)
    {
        RRETURN(E_INVALIDARG);
    }

    *pclsid = CLSID_HTMLDocument;
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member   : CDocument::IsDirty
//
//  Synopsis : Per IPersistFile
//
//-------------------------------------------------------------------------
//
//  TODO: FerhanE
//          The _lDirtyVersion flag is on the CDoc. It means that on a multiframe
//          document, if one of the frames has a dirty section, the whole document
//          will be marked as dirty. It is bad in a scenario where you are making
//          the call to frame2's document and the frame1 is dirty and frame2 is not.
//
//          The change requires touching all sorts of places including parser code. The
//          _lDirtyVersion on the CDoc has to die and CDocument has to have a counter.
//          I am delaying that change to finish fixing all IPersist interfaces first. We
//          can make that update after we provide basic functionality to load/save through
//          these interfaces.
//          Another part of that cleanup should be to port the _fHasOleSite flag to the document.
//          However, we should change its name to _fNotifyForDirty or something, since framesites
//          are no longer olesites and they can have dirtied documents inside. CDoc's optimization can
//          be mimicked then.
//
STDMETHODIMP
CDocument::IsDirty(void)
{
    CDoc * pDoc = Markup()->Doc();

    // never dirty in design mode
    if (!DesignMode())
        return S_FALSE;

    if (pDoc->_lDirtyVersion != 0)
        return S_OK;

    Assert(Markup()->Root());

    CNotification   nf;
    nf.UpdateDocDirty(Markup()->Root());
    Markup()->Notify(&nf);

    if (pDoc->_lDirtyVersion == 0)
        return S_FALSE;

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member   : CDocument::Load
//
//  Synopsis : Per IPersistFile
//
//-------------------------------------------------------------------------

STDMETHODIMP
CDocument::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    HRESULT hr;

    hr = THR(Window()->FollowHyperlinkHelper((TCHAR *)pszFileName, 0, 0));

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member   : CDocument::Save
//
//  Synopsis : Per IPersistFile
//
//-------------------------------------------------------------------------

STDMETHODIMP
CDocument::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    HRESULT hr = S_OK;

    hr = THR(Markup()->Doc()->SaveHelper(Markup(), pszFileName, fRemember));

    RRETURN( hr );
}

//+------------------------------------------------------------------------
//
//  Member   : CDocument::SaveCompleted
//
//  Synopsis : Per IPersistFile
//
//-------------------------------------------------------------------------

STDMETHODIMP
CDocument::SaveCompleted(LPCOLESTR pszFileName)
{
    HRESULT hr = S_OK;

    hr = THR(Markup()->Doc()->SaveCompletedHelper(Markup(), pszFileName));

    RRETURN( hr );
}


//+------------------------------------------------------------------------
//
//  Member   : CDocument::GetCurFile
//
//  Synopsis : Per IPersistFile
//
//-------------------------------------------------------------------------

HRESULT
CDocument::GetCurFile(LPOLESTR *ppszFileName)
{
    HRESULT         hr;
    TCHAR           achFile[MAX_PATH];
    ULONG           cchFile = ARRAY_SIZE(achFile);
    const TCHAR *   pchUrl  = CMarkup::GetUrl(Markup());

    if (!pchUrl || GetUrlScheme(pchUrl) != URL_SCHEME_FILE)
        return E_UNEXPECTED;

    hr = THR(PathCreateFromUrl(pchUrl, achFile, &cchFile, 0));
    if (hr)
        RRETURN(hr);

    RRETURN(THR(TaskAllocString(achFile, ppszFileName)));
}

//+------------------------------------------------------------------------
//
//  Class:      CDocument - IPersistHistory implementation
//
//-------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  Member:     CDocument::LoadHistory
//
//  Synopsis:   implementation of IPersistHistory::LoadHistory
//
//-------------------------------------------------------------------------
HRESULT
CDocument::LoadHistory(IStream * pStream, IBindCtx * pbc)
{
    RRETURN(_pWindow->LoadHistory(pStream, pbc));
}

//+------------------------------------------------------------------------
//
//  Member:     CDocument::SaveHistory
//
//  Synopsis:   implementation of IPersistHistory::SaveHistory
//
//-------------------------------------------------------------------------
HRESULT
CDocument::SaveHistory(IStream * pStream)
{
    RRETURN(_pWindow->SaveHistory(pStream));
}

//+------------------------------------------------------------------------
//
//  Member:     CDocument::GetPositionCookie
//
//  Synopsis:   implementation of IPersistHistory::GetPositionCookie
//
//-------------------------------------------------------------------------
HRESULT
CDocument::GetPositionCookie(DWORD * pdwCookie)
{
    RRETURN(_pWindow->GetPositionCookie(pdwCookie));
}

//+------------------------------------------------------------------------
//
//  Member:     CDocument::SetPositionCookie
//
//  Synopsis:   implementation of IPersistHistory::SetPositionCookie
//
//-------------------------------------------------------------------------
HRESULT
CDocument::SetPositionCookie(DWORD dwCookie)
{
    RRETURN(_pWindow->SetPositionCookie(dwCookie));
}

//+------------------------------------------------------------------------
//
//  Member:     CWindow::FollowHyperlinkHelper
//
//-------------------------------------------------------------------------
HRESULT
CWindow::FollowHyperlinkHelper(TCHAR * pchUrl,
                               DWORD dwBindf,
                               DWORD dwFlags,
                               TCHAR * pchUrlContext)
{
    HRESULT hr;
    CFrameSite * pFrameSite = GetFrameSite();

    if (pFrameSite)
    {
        CStr strUrlOrig;

        hr = strUrlOrig.Set(pFrameSite->GetAAsrc());
        if (hr)
            goto Cleanup;

        hr = THR(pFrameSite->SetAAsrc(pchUrl));
        if (hr)
            goto Cleanup;

        hr = THR(pFrameSite->OnPropertyChange_Src(dwBindf, dwFlags | CDoc::FHL_FOLLOWHYPERLINKHELPER));

        // regardless we navigated or not. Restore the original src
        hr = THR(pFrameSite->SetAAsrc(strUrlOrig));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(_pMarkup->Doc()->FollowHyperlink(pchUrl,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  FALSE,
                                                  NULL,
                                                  FALSE,
                                                  _pMarkup->Window(),
                                                  NULL,
                                                  dwBindf,
                                                  ERROR_SUCCESS,
                                                  FALSE,
                                                  NULL,
                                                  FALSE,
                                                  dwFlags,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  pchUrlContext));
    }

Cleanup:
    RRETURN(hr);
}

void
CDocument::Fire_onreadystatechange()
{
    CWindow * pWindow = Window();

    FireEvent(Doc(), DISPID_EVMETH_ONREADYSTATECHANGE, DISPID_EVPROP_ONREADYSTATECHANGE, _T("readystatechange"));

    if (pWindow)
    {
        CFrameSite * pFrameSite = pWindow->GetFrameSite();

        if (pFrameSite)
            pFrameSite->Fire_onreadystatechange();
    }
}

void
CWindow::HandlePendingScriptErrors( BOOL fShowError)
{
    CPendingScriptErr * pErrRec = NULL;

    for (int i=0; i < _aryPendingScriptErr.Size(); i++ )
    {
        pErrRec = &_aryPendingScriptErr[i];

        // being paranoid about reentrancy and checking the markup pointer too...
        if (pErrRec)
        {
            ErrorRecord errorRecord;

            Assert(pErrRec->_pMarkup);

            if (fShowError &&
                !pErrRec->_pMarkup->IsPassivated() &&
                !pErrRec->_pMarkup->IsPassivating())
            {
                HRESULT hr;

                errorRecord.Init(E_ACCESSDENIED, pErrRec->_cstrMessage, (LPTSTR) CMarkup::GetUrl(pErrRec->_pMarkup));

                hr = pErrRec->_pMarkup->GetNearestMarkupForScriptCollection()->ReportScriptError(errorRecord);
            }

            // cleanup as we go
            pErrRec->_cstrMessage.Free();
            pErrRec->_pMarkup->SubRelease();
            pErrRec->_pMarkup = NULL;
        }
    }

    _aryPendingScriptErr.DeleteAll();
}

//+------------------------------------------------------------------------
//
//  Member   : CWindow::SetBindCtx
//
//  Synopsis : Sets the bind ctx that will be used when delegating the
//             navigation to shdocvw for non-html mime types.
//
//-------------------------------------------------------------------------

void CWindow::SetBindCtx(IBindCtx * pBindCtx)
{
    Assert(pBindCtx);
    ReplaceInterface(&_pBindCtx, pBindCtx);
}


//+------------------------------------------------------------------------
//
//  Member   : CDocument::SetGalleryMeta
//
//  Synopsis : sets _bIsGalleryMeta var
//
//-------------------------------------------------------------------------

void CDocument::SetGalleryMeta(BOOL bValue)
{
    _bIsGalleryMeta = bValue;
}

//+------------------------------------------------------------------------
//
//  Member   : CDocument::GetGalleryMeta
//
//  Synopsis : returns _bIsGalleryMeta var
//
//-------------------------------------------------------------------------

BOOL CDocument::GetGalleryMeta()
{
    return(_bIsGalleryMeta);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocument::Load, IPersistMoniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDocument::Load(BOOL fFullyAvailable, IMoniker *pmkName, IBindCtx *pbctx,
    DWORD grfMode)
{
    HRESULT     hr = E_INVALIDARG;
    TCHAR       *pchURL = NULL;

    if( pmkName == NULL )
        goto Cleanup;

    AssertSz( pbctx, "This call carries a bind context. Find out for what purpose. (FerhanE/MarkA)");

    // Get the URL from the display name of the moniker:
    hr = pmkName->GetDisplayName(pbctx, NULL, &pchURL);
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(Window()->FollowHyperlinkHelper((TCHAR *)pchURL, 0, 0));

Cleanup:
    CoTaskMemFree(pchURL);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocument::Save, IPersistMoniker
//
//----------------------------------------------------------------------------

HRESULT
CDocument::Save(IMoniker *pmkName, LPBC pBCtx, BOOL fRemember)
{
    HRESULT     hr;
    IStream *   pStm = NULL;

    if (pmkName == NULL)
    {
        pmkName = Markup()->GetNonRefdMonikerPtr();
    }

    hr = THR(pmkName->BindToStorage(pBCtx, NULL, IID_IStream, (void **)&pStm));
    if (hr)
        goto Cleanup;

    hr = THR(Markup()->Save(pStm, TRUE));
    if (hr)
        goto Cleanup;

    if (fRemember)
    {
        hr = THR( Markup()->ReplaceMonikerPtr( pmkName ) );
        if( hr )
            goto Cleanup;

        Markup()->ClearDwnPost();
    }

Cleanup:
    ReleaseInterface(pStm);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocument::SaveCompleted, IPersistMoniker
//
//----------------------------------------------------------------------------

HRESULT
CDocument::SaveCompleted(IMoniker *pmkName, LPBC pBCtx)
{
    HRESULT hr = S_OK;
    if (pmkName && Markup()->Doc()->DesignMode())
    {
        hr = THR(Markup()->ReplaceMonikerPtr( pmkName ));
        if( hr )
            goto Cleanup;

        Markup()->ClearDwnPost();
    }

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDocument::GetCurMoniker, IPersistMoniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDocument::GetCurMoniker(IMoniker **ppmkName)
{
    IMoniker *pmk = Markup()->GetNonRefdMonikerPtr();

    if (!ppmkName)
        RRETURN(E_POINTER);

    if (!pmk)
        RRETURN(E_UNEXPECTED);

    *ppmkName = pmk;
    pmk->AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDocument::Load, IPersistStream and IPersistStreamInit
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::Load( LPSTREAM pStream )
{
    HRESULT hr;

    // if we are the top level document, then delegate to the doc.
    if (Markup()->IsPrimaryMarkup())
    {
        hr = THR(Markup()->Doc()->Load(pStream));
    }
    else
    {
        // we just can't load a frame from stream.
        hr = E_NOTIMPL;
    }

    RRETURN1(hr, E_NOTIMPL);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDocument::Load, IPersistStream and IPersistStreamInit
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::Save( LPSTREAM pStream, BOOL fClearDirty )
{
    HRESULT hr;

    hr = THR( Markup()->SaveToStream( pStream ) );
    if( hr )
        goto Cleanup;

    if( fClearDirty )
    {
        Markup()->ClearDirtyFlag();
    }

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     CDocument::GetSizeMax, IPersistStream and IPersistStreamInit
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::GetSizeMax(ULARGE_INTEGER FAR * pcbSize)
{
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDocument::InitNew, IPersistStreamInit
//
//-----------------------------------------------------------------------------
HRESULT
CDocument::InitNew()
{
    return E_NOTIMPL;
}

#if DBG==1 
//  
//  CWindow::SetProxyCaller -- IDebugWindow
//
HRESULT
CWindow::SetProxyCaller(IUnknown *pProxy)
{
    if (pProxy)
    {
        // If nested _different_ proxies, only the innermost counts. Don't have to be super robust here
        if (_pProxyCaller != NULL && _pProxyCaller != pProxy)
        {
            Assert(TRUE); // this happens in frames.js set breakpoint here if you want to see.
            _cNestedProxyCalls = 0;
        }

        _pProxyCaller = pProxy;
        _cNestedProxyCalls++;
    }
    else
    {
        if (0 >= --_cNestedProxyCalls)
        {
            _pProxyCaller = NULL;
        }
        // count will run negative here on nested proxies; 
        // we let it do so in case we want to learn more about it
    }

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\window2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       window2.cxx
//
//  Contents:   Further implementation of CWindow
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif


DeclareTag(tagPics, "dwn", "Trace PICS processing");
ExternTag(tagSecurityContext);

HRESULT
CWindow::SuperNavigate(BSTR      bstrURL,
                       BSTR      bstrLocation,
                       BSTR      bstrShortcut,
                       BSTR      bstrFrameName,
                       VARIANT * pvarPostData,
                       VARIANT * pvarHeaders,
                       DWORD     dwFlags)
{
    CDoc * pDoc = Doc();
    DWORD  dwFHLFlags = 0;
    SAFEARRAY * pPostDataArray = NULL;
    DWORD cbPostData = 0;
    BYTE * pPostData = NULL;
    TCHAR * pchExtraHeaders = NULL;
    CDwnPost * pDwnPost = NULL;
    HRESULT hr;

    // If we are shutting down or have shut down, don't start a new navigate
    if (pDoc->IsShut())
        return E_FAIL;

    // Lock the Doc!
    CDoc::CLock DocLock(pDoc);

    if (bstrShortcut && IsPrimaryWindow())
    {
        // TODO: (jbeda) this stuff should probably be put on the markup
        // as part of the CMarkupTransNavContext

        HRESULT        hr;
        IPersistFile * pISFile = NULL;

        // create the shortcut object for the provided cachefile
        hr = THR(CoCreateInstance(CLSID_InternetShortcut,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IPersistFile,
                                  (void **)&pISFile));
        if (SUCCEEDED(hr))
        {
            hr = THR(pISFile->Load(bstrShortcut, 0));

            if (SUCCEEDED(hr))
            {
                ClearInterface(&pDoc->_pShortcutUserData);

                hr = THR(pISFile->QueryInterface(IID_INamedPropertyBag,
                                                 (void **)&pDoc->_pShortcutUserData));
                if (!hr)
                {
                    IGNORE_HR(pDoc->_cstrShortcutProfile.Set(bstrShortcut));
                }
            }

            pISFile->Release();
        }
    }

    // We only want to set the _fShdocvwNavigate
    // flag to true if this navigation came from 
    // shdocvw. 
    //
    if (_pMarkup->IsPrimaryMarkup() && !(dwFlags & DOCNAVFLAG_DOCNAVIGATE))
    {
        dwFHLFlags |= CDoc::FHL_SHDOCVWNAVIGATE;
    }

    if ( dwFlags & DOCNAVFLAG_DONTUPDATETLOG )
    {
        dwFHLFlags |= CDoc::FHL_DONTUPDATETLOG; 
    }
    
    _fHttpErrorPage = !!(dwFlags & DOCNAVFLAG_HTTPERRORPAGE);

    if (  dwFlags & DOCNAVFLAG_REFRESH )
    {
        dwFHLFlags |= CDoc::FHL_REFRESH;
    }
    
    // If this is a frame, then indicate it in the call to followhyperlink below
    if (_pWindowParent)
    {
        dwFHLFlags |= CDoc::FHL_FRAMENAVIGATION;
    }

    if (dwFlags & DOCNAVFLAG_HTTPERRORPAGE)
    {
        dwFHLFlags |= CDoc::FHL_ERRORPAGE;
    }

    if (pvarHeaders)
    {
       if ((VT_BSTR | VT_BYREF) == pvarHeaders->vt)
       {
           pchExtraHeaders = *pvarHeaders->pbstrVal;
       }
       else if (VT_BSTR == pvarHeaders->vt)
       {
           pchExtraHeaders = pvarHeaders->bstrVal;
       }
    }

    if (pvarPostData && (VT_ARRAY & pvarPostData->vt))
    {
        if (VT_BYREF & pvarPostData->vt)
        {
            pPostDataArray = *pvarPostData->pparray;
        }
        else
        {
            pPostDataArray = pvarPostData->parray;
        }

        if (pPostDataArray)
        {
            // lock the array for reading, get pointer to data
            hr = SafeArrayAccessData(pPostDataArray, (void **) &pPostData);

            if (SUCCEEDED(hr)) 
            {
                long nElements = 0;
                DWORD dwElemSize;

                // get number of elements in array
                SafeArrayGetUBound(pPostDataArray, 1, (long *) &nElements);
                // SafeArrayGetUBound returns zero-based max index, add one to get element count

                nElements++;
                // get bytes per element
                dwElemSize = SafeArrayGetElemsize(pPostDataArray);

                // bytes per element should be one if we created this array
                Assert(dwElemSize == 1);

                // calculate total byte count anyway so that we can handle
                // safe arrays other people might create with different element sizes
                cbPostData = dwElemSize * nElements;

                if (0 == cbPostData)
                    pPostData = NULL;

                if (pPostData && cbPostData)
                {
                    IGNORE_HR(CDwnPost::Create(cbPostData, pPostData, TRUE, &pDwnPost));
                }
            }
        }
    }

    hr = THR(pDoc->FollowHyperlink(bstrURL,                                 /* pchURL              */
                                   bstrFrameName,                           /* pchTarget           */
                                   NULL,                                    /* pElementContext     */
                                   pDwnPost,                                /* pDwnPost            */
                                   !!pDwnPost,                              /* fSendAsPost         */
                                   pchExtraHeaders,                         /* pchExtraHeaders     */
                                   FALSE,                                   /* fOpenInNewWindow    */
                                   _pMarkup->Window(),                      /* pWindow             */
                                   NULL,                                    /* ppWindowOut         */
                                   0,                                       /* dwBindf             */
                                   ERROR_SUCCESS,                           /* dwSecurityCode      */
                                   FALSE,                                   /* fReplace            */
                                   NULL,                                    /* ppHTMLWindow2       */
                                   dwFlags & DOCNAVFLAG_OPENINNEWWINDOW,    /* fOpenInNewBrowser   */
                                   dwFHLFlags,                              /* dwFlags             */
                                   NULL,                                    /* pchName             */
                                   NULL,                                    /* pStmHistory         */
                                   NULL,                                    /* pElementMaster      */
                                   NULL,                                    /* pchUrlContext       */
                                   NULL,                                    /* pfLocalNavigation   */
                                   NULL,                                    /* pfProtocolNavigates */
                                   bstrLocation                             /* pchLocation         */
                                   ));

    if (pPostDataArray)
    {
        // done reading from array, unlock it
        SafeArrayUnaccessData(pPostDataArray);
    }

    ReleaseInterface(pDwnPost);

    RRETURN(hr);
}


//
//  CWindow::NavigateEx -- IHTMLPrivateWindow2
//
HRESULT
CWindow::NavigateEx(    BSTR        bstrURL, 
                        BSTR        bstrOriginal,
                        BSTR        bstrLocation, 
                        BSTR        bstrContext,
                        IBindCtx*   pBindCtx, 
                        DWORD       dwNavOptions,
                        DWORD       dwFHLFlags)
{
    HRESULT         hr;
    CStr            cstrExpandedUrl;
    CStr            cstrLocation;
    CDwnBindInfo *  pDwnBindInfo    = NULL;
    
    CDoc * pDoc = Doc();

    cstrExpandedUrl.Set(bstrURL);
    cstrLocation.Set(bstrLocation);

    if (pBindCtx)
    {
        TraceTag(( tagSecurityContext, 
                    "CWindow::NavigateEx - Bind context exists. URL: %ws, Context: %ws", 
                    bstrURL, 
                    bstrContext));

        // Retrieve DwnBindInfo from the BindCtx
        {
            IUnknown *pUnk = NULL;
            pBindCtx->GetObjectParam(SZ_DWNBINDINFO_OBJECTPARAM, &pUnk);
            if (pUnk)
            {
                pUnk->QueryInterface(IID_IDwnBindInfo, (void **)&pDwnBindInfo);
                ReleaseInterface(pUnk);
            }
        }


        hr =  THR(pDoc->DoNavigate(   &cstrExpandedUrl,
                                      &cstrLocation,
                                       pDwnBindInfo,
                                       pBindCtx,
                                       NULL,
                                       NULL,
                                       _pMarkup->Window(),      // Opener window
                                       NULL,
                                       FALSE,
                                       TRUE,
                                       FALSE,
                                       FALSE,
                                       NULL,
                                       TARGET_FRAMENAME,        // target type
                                       dwFHLFlags,              // FHL_* flags
                                       NULL,                    
                                       FALSE,
                                       NULL,
                                       NULL, 
                                       bstrOriginal));
        if (pDwnBindInfo)
        {
            pDwnBindInfo->Release();
        }
    }
    else
    {
        TraceTag(( tagSecurityContext, 
                    "CWindow::NavigateEx - Bind context does not exist. URL: %ws, Context: %ws", 
                    bstrURL, 
                    bstrContext));

        dwFHLFlags |= !!(dwNavOptions & NAVIGATEEX_DONTUPDATETRAVELLOG) ? CDoc::FHL_DONTUPDATETLOG : 0 ;
        
        hr = THR(FollowHyperlinkHelper( bstrURL, 0, dwFHLFlags, bstrContext));
    }

    RRETURN(hr);
}


//
//  CWindow::GetInnerWindowUnknown -- IHTMLPrivateWindow2
//
HRESULT
CWindow::GetInnerWindowUnknown(IUnknown** ppUnknown)
{
    HRESULT hr = E_FAIL;

    *ppUnknown = NULL;

    if (_punkViewLinkedWebOC)
    {
        COmWindowProxy * pOmWindowProxy = GetInnerWindow();

        if (pOmWindowProxy)
            hr = pOmWindowProxy->QueryInterface(IID_IUnknown, (void **) ppUnknown);
    }

    RRETURN1(hr, E_FAIL);
}

//  
//  CWindow::OpenEx -- IHTMLPrivateWindow3
//
HRESULT
CWindow::OpenEx(BSTR url, 
                BSTR urlContext, 
                BSTR name, 
                BSTR features, 
                VARIANT_BOOL replace, 
                IHTMLWindow2 ** ppWindow)
{
    HRESULT         hr;

    // copy the feature string, to be provided to shdocvw on demand.
    // FilterOutFeaturesString expects a non-null string.
    if( features && *features )
    {
        hr = THR(FilterOutFeaturesString(features, &_cstrFeatures));
        if (hr)
            goto Cleanup;
    }

    // Process name and return an error code if
    // the target name contains invalid characters.
    // This is for compatibility with IE5 and earlier.
    //
    if (name)
    {
        // Make sure we have a legal name
        for (int i = 0; i < lstrlenW(name); i++)
        {
            if (!(IsCharAlphaNumeric(name[i]) || _T('_') == name[i]))
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
        }
    }
    
    _fOpenInProgress = TRUE;

    TraceTag((tagSecurityContext, "CWindow::open - URL: %ws", url));
    
    hr = THR(SetErrorInfo(Doc()->FollowHyperlink(url,                                                       // pchURL
                                                 name,                                                      // pchTarget
                                                 NULL,                                                      // pElementContext
                                                 NULL,                                                      // pDwnPost
                                                 FALSE,                                                     // fSendAsPost
                                                 NULL,                                                      // pchExtraHeaders
                                                 FALSE,                                                     // fOpenInNewWindow
                                                 _pMarkup->Window(),                                        // pWindow
                                                 NULL,                                                      // ppWindowOut
                                                 0,                                                         // dwBindOptions
                                                 ERROR_SUCCESS,                                             // dwSecurityCode
                                                 replace != VARIANT_FALSE,                                  // fReplace
                                                 ppWindow,                                                  // ppHTMLWindow2
                                                 FALSE,                                                     // fOpenInNewBrowser
                                                 ( VARIANT_TRUE == replace ) ? CDoc::FHL_DONTUPDATETLOG : 0,// dwFlags
                                                 NULL,                                                      // pchName
                                                 NULL,                                                      // pStmHistory
                                                 NULL,                                                      // pElementMaster
                                                 urlContext                                                 // pchUrlContext
                                                 )));
                                                 
    _fOpenInProgress = FALSE;

Cleanup:
    // The features string must be cleared here in order to 
    // avoid using the wrong features if the user shift-clicks 
    // on a link to open a new window. Clearing of the features
    // string here is dependent on the fact that the opening of 
    // the new window via OpenInNewWindow() is synchronous.
    //
    _cstrFeatures.Free();

    RRETURN(hr);
}


HRESULT
CWindow::GetAddressBarUrl(BSTR * pbstrURL)
{
    HRESULT hr = S_OK;
    CStr    cstrRetString;
    TCHAR   achUrl[pdlUrlLen];
    DWORD   dwLength = ARRAY_SIZE(achUrl);
    TCHAR * pchUrl;    

    if (!pbstrURL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pbstrURL = NULL;

    hr = Document()->GetMarkupUrl(&cstrRetString, TRUE);
    if (hr)
        goto Cleanup;

    // In IE5, file protocols did not display %20 in the address bar.
    if (GetUrlScheme(cstrRetString) == URL_SCHEME_FILE)
    {
        if (!InternetCanonicalizeUrl(cstrRetString, achUrl, &dwLength,
                                     ICU_NO_ENCODE | ICU_DECODE | URL_BROWSER_MODE))
        {
            goto Cleanup;
        }
        pchUrl = achUrl;
    }
    else 
    {
        pchUrl = cstrRetString;
    }

    *pbstrURL = SysAllocString(pchUrl);

Cleanup:
    RRETURN(hr);
}


HRESULT
CWindow::GetPendingUrl(LPOLESTR* pstrURL)
{
    HRESULT hr = E_INVALIDARG;

    if (_pMarkupPending && _pMarkupPending->HasUrl())
    {
        TCHAR * pchUrl = _pMarkupPending->Url();

        hr = TaskAllocString( pchUrl, pstrURL );
        if (hr)
            goto Cleanup;

        TraceTag((tagPics, "CWindow::GetPendingUrl returning \"%S\"", *pstrURL));

        hr = S_OK;
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CWindow::SetPICSTarget(IOleCommandTarget* pctPICS)
{
    HRESULT hr = E_INVALIDARG;

    TraceTag((tagPics, "CWindow::SetPICSTarget(%x)", pctPICS));

    if( _pMarkupPending )
    {
        hr = THR(_pMarkupPending->SetPicsTarget(pctPICS));
    }

    RRETURN(hr);
}

HRESULT
CWindow::PICSComplete(BOOL fApproved)
{
    TraceTag((tagPics, "CWindow::PICSComplete(%x)", fApproved));

    Assert( _pMarkupPending && !_pMarkupPending->GetPicsTarget() );

    // We should have gotten quite a few asserts before this point
    // This isn't perforance critical so lets at least not crash.
    if (_pMarkupPending)
    {
        _pMarkupPending->_fPicsProcessPending = FALSE;

        if (fApproved)
        {
            _pMarkupPending->_pHtmCtx->ResumeAfterScan();
        }
        else
        {
            ReleaseMarkupPending(_pMarkupPending);

            // Reset the URL on the window so 
            // that refresh won't load the page!
            if (_pMarkup->_fPICSWindowOpenBlank)
            {
                CMarkup::SetUrl(_pMarkup, NULL);
            }
        }
    }

    return S_OK;
}

HRESULT
CWindow::FindWindowByName(LPCOLESTR       pstrTargetName,
                          IHTMLWindow2 ** ppWindow)
{
    Assert(pstrTargetName);
    Assert(ppWindow);

    return FindWindowByName(pstrTargetName, NULL, ppWindow);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\base\wscript.cxx ===
//+------------------------------------------------------------------------
//
//  File:       wscript.cxx
//
//  Contents:   CDoc deferred-script execution support.
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ESCRIPT_HXX_
#define X_ESCRIPT_HXX_
#include "escript.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include "shell.h"
#endif

#ifndef X_PRGSNK_H_
#define X_PRGSNK_H_
#include <prgsnk.h>
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#define SCRIPTSDEFERDELAY 113

//+-------------------------------------------------------------------
//
//  Member:     CDoc::IsInScript
//
//  Synopsis:   TRUE if we are in a script
//
//--------------------------------------------------------------------

BOOL 
CWindow::IsInScript()
{
    // If we are in a script - then IsInScript is true.  NOTE: we aggregate
    // our scriptnesting with those of our children
    return (_cScriptNesting > 0) ? TRUE : FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::EnterScript
//
//  Synopsis:   Note that we are inside a script
//
//--------------------------------------------------------------------

HRESULT 
CWindow::EnterScript()
{
    HRESULT hr = S_OK;

    _cScriptNesting++;

    CDoc* pDoc = Doc();
    Assert(pDoc);

    pDoc->_cScriptNestingTotal++;

    //  Fire off Exec (this will go up the frame hierarchy) to indicate that
    //  SHDOCVW should not retry deactivating any docobjects whose deactivation was
    //  deferred due to a child being in script code.
        //  Quickly forward this up to command target of our clientsite
        //  this is how we tell SHDOCVW to try to activate any view whose
        //  activation was deferred while some frame was in a script.  as
        //  a script that is executing blocks activation of any parent frame
        //  this has to (potentially) be forwarded all the way up to browser
        //  window

    if (_cScriptNesting > 15)
    {
        hr = VBSERR_OutOfStack;
        _fStackOverflow = TRUE;
        goto Cleanup;
    }

    if (_cScriptNesting == 1)
    {
        // Initialize error condition flags/counters.
        _fStackOverflow = FALSE;
        _fOutOfMemory = FALSE;
        _fEngineSuspended = FALSE;
        _badStateErrLine = 0;

        // Start tracking total number of script statements executed
        _dwTotalStatementCount = 0;

        pDoc->_fEngineSuspended = FALSE;
        pDoc->UpdateFromRegistry();

        // Initialize the max statement count from default
        _dwMaxStatements = pDoc->_pOptionSettings->dwMaxStatements;
        
        _fUserStopRunawayScript = FALSE;
    }

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::LeaveScript
//
//  Synopsis:   Note that we are leaving a script
//
//--------------------------------------------------------------------

HRESULT 
CWindow::LeaveScript()
{
    HRESULT hr = S_OK;

    Assert(_cScriptNesting > 0);

    if (_cScriptNesting == 0)
        return E_FAIL;

    _cScriptNesting--;

    CDoc* pDoc = Doc();
    if (pDoc)
        pDoc->_cScriptNestingTotal--;

    if (_cScriptNesting == 0)
    {
        // Clear accumulated count of statements
        _dwTotalStatementCount = 0;
        _dwMaxStatements = 0;

        // Reset the user's inputs so that other scripts may execute
        _fUserStopRunawayScript = FALSE;

        if (_fStackOverflow || _fOutOfMemory)
        {
            // Bring up a simple dialog box for stack overflow or
            // out of memory.  We don't have any room to start up
            // the parser and create an HTML dialog as OnScriptError
            // would do.
            TCHAR   achBuffer[256];

            Format(0,
                   achBuffer,
                   ARRAY_SIZE(achBuffer),
                   _T("<0s> at line: <1d>"),
                   _fStackOverflow ? _T("Stack overflow") : _T("Out of memory"),
                   _badStateErrLine);

            alert(achBuffer);
        }
    }

    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::QueryContinueScript
//
//  Synopsis:   See if the current script fragment has been executing
//              for too long.
//
//--------------------------------------------------------------------

HRESULT CWindow::QueryContinueScript( ULONG ulStatementCount )
{
    // If the user has already made a decision about aborting or
    // continuing the script, repeat that answer until all presently
    // running scripts are dead.
    if (_fUserStopRunawayScript)
        return E_ABORT;

    // it is possible that this call get's reentered while we are 
    // currently displaying the ContinueScript dialog
    // prevent popping up another dialog and continue to run the 
    // scripts until the user decided on the first one (frankman&GaryBu)
    if (_fQueryContinueDialogIsUp)
        return S_OK;
    
    // Accumulate the statement  since we were last called
    _dwTotalStatementCount += ulStatementCount;

    // rgardner, for now it seems sensible not to factor in time. Many OCXs
    // for instance will take ages to do their job, but only take one
    // statement to do so.

    if (_dwTotalStatementCount > _dwMaxStatements)
    {
        int iUserResponse;
        TCHAR achMsg[256];
        CDoc *pDoc = Doc();

        _fQueryContinueDialogIsUp = TRUE;
        
        IGNORE_HR(Format(0, achMsg, ARRAY_SIZE(achMsg), MAKEINTRESOURCE(IDS_RUNAWAYSCRIPT)));
        pDoc->ShowMessageEx( &iUserResponse, MB_ICONEXCLAMATION | MB_YESNO, NULL, 0, achMsg );

        _fQueryContinueDialogIsUp = FALSE;
            

        if (iUserResponse == IDYES)
        {
            _fUserStopRunawayScript = TRUE;
            return E_ABORT;
        }
        else
        {
            _dwTotalStatementCount = 0;
            // User has chosen to continue execution, increase the interval to the next
            // warning
            if (_dwMaxStatements < ((DWORD)-1)>>3)
                _dwMaxStatements <<= 3;
            else
                _dwMaxStatements = (DWORD)-1;
        }
    }
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     CMarkup::IsInScriptExecution
//
//  Synopsis:   TRUE if we are executing a script now
//
//--------------------------------------------------------------------

BOOL CMarkup::IsInScriptExecution()
{
    return HasScriptContext() ? (ScriptContext()->_cScriptExecution > 0) : FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::EnterScriptExecution
//
//--------------------------------------------------------------------

HRESULT 
CMarkup::EnterScriptExecution(CWindow **ppWindow)
{
    HRESULT                 hr;
    CMarkup *               pMarkup;
    CMarkupScriptContext *  pScriptContext;

    hr = THR(EnsureScriptContext(&pScriptContext));
    if (hr)
        goto Cleanup;

    // inline script contributes twice to _cScriptExecution
    pMarkup = GetWindowedMarkupContext();
    Assert(pMarkup);
    Assert(pMarkup->GetWindowPending());

    Assert(ppWindow);
    *ppWindow = pMarkup->HasWindowPending() ? pMarkup->GetWindowPending()->Window() : NULL;

    if (*ppWindow)
    {
        hr = THR((*ppWindow)->EnterScript());
        if (hr)
            goto Cleanup;
    }

    pScriptContext->_cScriptExecution++;
    
Cleanup:
    RRETURN(hr); 
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::LeaveScriptExecution
//
//  Synopsis:   Note that we are leaving an inline script
//
//--------------------------------------------------------------------

HRESULT 
CMarkup::LeaveScriptExecution(CWindow *pWindow)
{
    HRESULT                 hr = S_OK;
    CMarkupScriptContext *  pScriptContext = ScriptContext();
  
    Assert(pWindow);
    Assert(pScriptContext || !_fLoaded);
    
    if (pScriptContext && pScriptContext->_cScriptExecution == 1)
    {
        // Before leaving top-level execution, commit queued
        // scripts. (may block parser)
        hr = THR(CommitQueuedScripts());
        if (hr)
            goto Cleanup;
    }
        
    // inline script contributes twice to _cScriptNesting
    Assert(!GetWindowedMarkupContext()->HasWindowPending() || GetWindowedMarkupContext()->GetWindowPending()->Window() == pWindow);

    if (pWindow)
    {
        hr = THR(pWindow->LeaveScript());
        if (hr)
            goto Cleanup;
    }

    if( pScriptContext )
        pScriptContext->_cScriptExecution--;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CMarkup::AllowScriptExecution
//
//  Synopsis:   Return whether inline scripts are allowed to be
//              parsed.
//
//--------------------------------------------------------------------

BOOL
CMarkup::AllowScriptExecution()
{
    // script parsing contexts are always alowed to Execute if we are
    // already running inside an inline script (note: the script parsing
    // context knows to queue nested <SCRIPT SRC=*> tags for actual
    // execution after the outermost script is finished).
    if (IsInScriptExecution())
        return TRUE;

    // Otherwise, we're at the top level
    return AllowImmediateScriptExecution();
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::AllowImmediateScriptExecution
//
//  Synopsis:   Return whether scripts are allowed to be committed.
//
//--------------------------------------------------------------------
BOOL
CMarkup::AllowImmediateScriptExecution()
{
    // No Execute is allowed while we are not inplace
    if (_pDoc->_fNeedInPlaceActivation &&
        !IsPrintMedia() &&
        (_pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_DISABLE_SCRIPT_INACTIVE) &&
        _pDoc->State() < OS_INPLACE)
        return FALSE;
        
    // No Execute is allowed while we are downloading script
    if (HasScriptContext() && ScriptContext()->_cScriptDownload)
		return FALSE;

    // CONSIDER: (jbeda) this whole _fBindResultPending thing seems shady...

    // ... or we have a pending window
    // The BindResult is E_PENDING for unknown Mime types, in which case, this temporary markup
    // will be released, but we need to allow execution to get to OnParseStatusDone
    if (_fWindowPending && !_fBindResultPending) 
        return FALSE;

    // ... or if our windowed markup context is not ready
    CMarkup * pMarkupContext = GetWindowedMarkupContext();
    if (    pMarkupContext 
        &&  pMarkupContext != this
        &&  !pMarkupContext->AllowScriptExecution() )
    {
        return FALSE;
    }

    // Normally inline script can be run
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::BlockScriptExecutionHelper
//
//  Synopsis:   Sleeps the CHtmLoadCtx and sets things up to
//              wait until script execution is allowed again
//
//--------------------------------------------------------------------

HRESULT
CMarkup::BlockScriptExecutionHelper()
{
    HRESULT                 hr;
    BOOL                    fRequestInPlaceActivation = FALSE;
    BOOL                    fGoInteractive = FALSE;
    CMarkupScriptContext *  pScriptContext;

    hr = THR(EnsureScriptContext(&pScriptContext));
    if (hr)
        goto Cleanup;

    Assert(!pScriptContext->_fScriptExecutionBlocked);
    Assert(!AllowImmediateScriptExecution());

    // First make sure our windowed markup context is ready for us
    {
        CMarkup * pMarkupContext = GetWindowedMarkupContext();
        if (    pMarkupContext 
            &&  pMarkupContext != this
            &&  !pMarkupContext->AllowScriptExecution())
        {
            BOOL fParentBlocked = FALSE;

            CMarkupScriptContext *  pScriptContextParent;
            hr = THR( pMarkupContext->EnsureScriptContext(&pScriptContextParent) );
            if (hr)
                goto Cleanup;

            if (!pScriptContextParent->_fScriptExecutionBlocked)
            {
                // Block the parent
                pMarkupContext->BlockScriptExecutionHelper();

                if (!pMarkupContext->AllowScriptExecution())
                    fParentBlocked = TRUE;
            }
            else
            {
                fParentBlocked = TRUE;
            }

            if (fParentBlocked)
            {
                // Block ourselves
                pScriptContext->_fScriptExecutionBlocked = TRUE;
            
                // Make sure we get notified when the parent is unblocked
                pScriptContextParent->RegisterMarkupForScriptUnblock( this );
            }
        }
    }

    // If we're not inplace active or have a pending window, request inplace activation
    if (    _pDoc->_fNeedInPlaceActivation 
        &&  (_pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_DISABLE_SCRIPT_INACTIVE) 
        &&  _pDoc->State() < OS_INPLACE)
    {
        fRequestInPlaceActivation = TRUE;
        pScriptContext->_fScriptExecutionBlocked = TRUE;
    }
    
    // If we're waiting on script to download
    if (pScriptContext->_cScriptDownload)
    {
        pScriptContext->_fScriptExecutionBlocked = TRUE;
    }

    if (_fWindowPending && !_fBindResultPending)
    {
        fGoInteractive = TRUE;
        pScriptContext->_fScriptExecutionBlocked = TRUE;
    }

    // We might not be blocked at this point if we
    // tried our windowed markup context and it was
    // able to unblock immediately.
    if (!pScriptContext->_fScriptExecutionBlocked)
        goto Cleanup;

    SuspendDownload();

    if (fRequestInPlaceActivation)
    {
        hr = THR(_pDoc->RegisterMarkupForInPlace(this));
        if (hr)
            goto Cleanup;
    }

    if (fGoInteractive || fRequestInPlaceActivation)
    {
        // No more pics allowed.
        if (IsPrimaryMarkup() && _pDoc->_fStartup)
        {
            ProcessMetaPicsDone();
        }

        // Request in-place activation by going interactive
        RequestReadystateInteractive(TRUE);
    }

Cleanup:
    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::UnblockScriptExecutionHelper
//
//--------------------------------------------------------------------

HRESULT
CMarkup::UnblockScriptExecutionHelper()
{
    HRESULT                 hr = S_OK;
    CMarkupScriptContext *  pScriptContext = ScriptContext();

    // If we were blocking execution of inline script, unblock
    if (pScriptContext && pScriptContext->_fScriptExecutionBlocked && AllowScriptExecution())
    {
        pScriptContext->_fScriptExecutionBlocked = FALSE;
        ResumeDownload();
    }
    
    // If we are outside of inline script when we discover
    // we are in-place, ensure execution of any queued
    // scripts which may have been waiting
    // (may reblock parser)
    if (!pScriptContext || pScriptContext->_cScriptExecution == 0)
    {
        hr = THR(CommitQueuedScriptsInline());
        if (hr)
            goto Cleanup;
    }

    if (pScriptContext)
    {
        pScriptContext->NotifyMarkupsScriptUnblock();
    }

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::RegisterMarkupForInPlace
//
//--------------------------------------------------------------------

HRESULT
CDoc::RegisterMarkupForInPlace(CMarkup * pMarkup)
{
    HRESULT     hr;

    // assert that the markup is not registered already
    Assert (-1 == _aryMarkupNotifyInPlace.Find(pMarkup));

    hr = _aryMarkupNotifyInPlace.Append(pMarkup);

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::UnregisterMarkupForInPlace
//
//--------------------------------------------------------------------

HRESULT
CDoc::UnregisterMarkupForInPlace(CMarkup * pMarkup)
{
    HRESULT     hr = S_OK;

    _aryMarkupNotifyInPlace.DeleteByValue(pMarkup);

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::NotifyMarkupsInPlace
//
//--------------------------------------------------------------------

HRESULT
CDoc::NotifyMarkupsInPlace()
{
    HRESULT     hr = S_OK;
    int         c;
    CMarkup *   pMarkup;

    while (0 != (c = _aryMarkupNotifyInPlace.Size()))
    {
        pMarkup = _aryMarkupNotifyInPlace[c - 1];

        _aryMarkupNotifyInPlace.Delete(c - 1);

        hr = THR(pMarkup->UnblockScriptExecutionHelper());
        if (hr)
            break;

        // schedule flushing the peer tasks queue. Flushing should be posted, not synchronous,
        // so to allow shdocvw to connect to the doc fully before we start attaching peers
        // and possible firing events to shdocvw (e.g. errors)
        IGNORE_HR(GWPostMethodCall(
            pMarkup,
            ONCALL_METHOD(CMarkup, ProcessPeerTasks, processpeertasks),
            0, FALSE, "CMarkup::ProcessPeerTasks"));
    }
    Assert (0 == _aryMarkupNotifyInPlace.Size());

    RRETURN(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CDoc::RegisterMarkupForModelessEnable
//
//--------------------------------------------------------------------

HRESULT
CDoc::RegisterMarkupForModelessEnable(CMarkup * pMarkup)
{
    HRESULT     hr;

    // assert that the markup is not registered already
    Assert (-1 == _aryMarkupNotifyEnableModeless.Find(pMarkup));

    hr = _aryMarkupNotifyEnableModeless.Append(pMarkup);

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::UnregisterMarkupForModelessEnable
//
//--------------------------------------------------------------------

HRESULT
CDoc::UnregisterMarkupForModelessEnable(CMarkup * pMarkup)
{
    HRESULT     hr = S_OK;

    _aryMarkupNotifyEnableModeless.DeleteByValue(pMarkup);

    RRETURN (hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CDoc::NotifyMarkupsModelessEnable
//
//--------------------------------------------------------------------

MtDefine(NotifyMarkupsModelessEnable_aryMarkupNotifyEnableModelessLocal, Locals, "NotifyMarkupsModelessEnable aryMarkupNotifyEnableModelessLocal")
DECLARE_CStackPtrAry(CAryMarkupNotifyEnableModelessLocal, CMarkup*, 32, Mt(Mem), Mt(NotifyMarkupsModelessEnable_aryMarkupNotifyEnableModelessLocal))

HRESULT
CDoc::NotifyMarkupsModelessEnable()
{
    HRESULT     hr = S_OK;
    int         i, n;
    CMarkup *   pMarkup;
    CAryMarkupNotifyEnableModelessLocal aryMarkupNotifyEnableModelessLocal;

    // NOTE: (jbeda)
    // We want to kick all of the markups that are waiting for
    // modeless to be enabled.  We keep one master list for the CDoc
    // to make this as easy as possible.  We copy all eligibale markups
    // to a seperate array and remove them as we go.  We then kick each
    // of these markups.  We repeat until all markups on the master list
    // are not eligiable.

    do
    {
        // Phase 1: copy to the temp array and remove for master list if elegiable
        aryMarkupNotifyEnableModelessLocal.SetSize(0);

        for (i = _aryMarkupNotifyEnableModeless.Size() - 1; i >= 0; i--)
        {
            pMarkup = _aryMarkupNotifyEnableModeless[i];
            if (pMarkup->CanNavigate())
            {
                hr = aryMarkupNotifyEnableModelessLocal.Append(pMarkup);
                if (hr)
                    goto Error;

                pMarkup->PrivateAddRef();

                _aryMarkupNotifyEnableModeless.Delete(i);
            }
        }

        // Phase 2: call every markup on the list
        for (i = 0, n = aryMarkupNotifyEnableModelessLocal.Size(); i < n; i++)
        {
            pMarkup = aryMarkupNotifyEnableModelessLocal[i];

            if (pMarkup->_fInteractiveRequested)
            {
                pMarkup->_fInteractiveRequested = FALSE;
                pMarkup->RequestReadystateInteractive(FALSE);
            }

            pMarkup->PrivateRelease();
        }
    }
    while (n != 0);

Cleanup:
    RRETURN(hr);

Error:
    // Error during the populate phase has to cause us to
    // release all of the markups
    for (i = 0, n = aryMarkupNotifyEnableModelessLocal.Size(); i < n; i++)
    {
        pMarkup = aryMarkupNotifyEnableModelessLocal[i];
        pMarkup->PrivateRelease();
    }
    goto Cleanup;
}

//+-------------------------------------------------------------------
//
//  Member:     CMarkup::BlockScriptExecution
//
//--------------------------------------------------------------------

void
CMarkup::BlockScriptExecution(DWORD * pdwCookie)
{
    HRESULT                 hr;
    CMarkupScriptContext *  pScriptContext;

    hr = THR(EnsureScriptContext(&pScriptContext));
    if (hr)
        goto Cleanup;

    if (!pdwCookie || !(*pdwCookie))
    {
        if (pdwCookie)
        {
            *pdwCookie = TRUE;
        }

        pScriptContext->_cScriptDownload++;
    }

Cleanup:
    return;
}


//+-------------------------------------------------------------------
//
//  Member:     CMarkup::UnblockScriptExecution
//
//  Synopsis:   Unblock script if we were waiting for script
//              download to run script.
//
//--------------------------------------------------------------------

HRESULT
CMarkup::UnblockScriptExecution(DWORD * pdwCookie)
{
    HRESULT                 hr = S_OK;
    CMarkupScriptContext *  pScriptContext = HasScriptContext() ? ScriptContext() : NULL;
    
    if (pScriptContext && (!pdwCookie || *pdwCookie))
    {
        Assert (pScriptContext);

        if (pdwCookie)
        {
            *pdwCookie = FALSE;
        }

        pScriptContext->_cScriptDownload--;

        hr = THR(UnblockScriptExecutionHelper());
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CDoc::EnqueueScriptToCommit
//
//  Synopsis:   Remember an inline script (with SRC=*) which needs
//              to be committed before unblocking the parser.
//
//              This happens when a script with SRC=* is written
//              by an inline script.
//
//--------------------------------------------------------------------

HRESULT
CMarkup::EnqueueScriptToCommit(CScriptElement *pelScript)
{
    HRESULT                 hr;
    CMarkupScriptContext *  pScriptContext;

    hr = THR(EnsureScriptContext(&pScriptContext));
    if (hr)
        goto Cleanup;

    hr = THR(pScriptContext->_aryScriptEnqueued.Append(pelScript));
    if (hr)
        goto Cleanup;

    pelScript->AddRef();

Cleanup:
    RRETURN (hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CDoc::CommitQueuedScripts
//
//  Synopsis:   Execute saved up scripts
//
//              Must be called from within EnterScriptExecution/LeaveScriptExecution
//
//--------------------------------------------------------------------

HRESULT
CMarkup::CommitQueuedScripts()
{
    HRESULT                 hr = S_OK;
    CScriptElement *        pelScript = NULL;
    CMarkupScriptContext *  pScriptContext = ScriptContext();

    Assert(pScriptContext->_cScriptExecution == 1);

continue_label:

    while (pScriptContext->_aryScriptEnqueued.Size() && AllowImmediateScriptExecution())
    {
        pelScript = pScriptContext->_aryScriptEnqueued[0];
        
        pScriptContext->_aryScriptEnqueued.Delete(0);

        hr = THR(pelScript->CommitCode());
        if (hr)
            goto Cleanup;

        pelScript->Release();
        pelScript = NULL;
    }

    if (pScriptContext->_aryScriptEnqueued.Size() && !pScriptContext->_fScriptExecutionBlocked)
    {
        Assert(!AllowImmediateScriptExecution());
        hr = THR(BlockScriptExecutionHelper());
        if (hr)
            goto Cleanup;
        if (AllowImmediateScriptExecution())
            goto continue_label;
    }
        
Cleanup:
    if (pelScript)
        pelScript->Release();
    
    RRETURN(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CMarkup::CommitQueuedScriptsInline
//
//  Synopsis:   Execute saved up scripts
//
//              Does the EnterScriptExecution/LeaveScriptExecution so that inline
//              scripts can be executed from the outside
//              CHtmScriptParseCtx::Execute.
//
//--------------------------------------------------------------------

HRESULT
CMarkup::CommitQueuedScriptsInline()
{
    HRESULT                 hr = S_OK;
    HRESULT                 hr2;
    CWindow *               pWindow = NULL;
    CMarkupScriptContext *  pScriptContext = ScriptContext();
    
    // optimization: nothing to do if there are no queued scripts
    if (!pScriptContext || !pScriptContext->_aryScriptEnqueued.Size())
        goto Cleanup;

    hr = THR(EnterScriptExecution(&pWindow));
    if (hr)
        goto Cleanup;

    hr2 = THR(CommitQueuedScripts());

    hr = THR(LeaveScriptExecution(pWindow));
    if (hr2)
        hr = hr2;
        
Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDoc::DeferScript
//
//----------------------------------------------------------------------------

HRESULT
CDoc::DeferScript(CScriptElement * pScript)
{
    HRESULT     hr;
    BOOL        fAllow;
    CMarkup    *pMarkup = pScript->GetMarkupPtr();

    hr = THR(pMarkup->ProcessURLAction(URLACTION_SCRIPT_RUN, &fAllow));
    if (hr || !fAllow)
        goto Cleanup;

    pScript->AddRef();
    pScript->_fDeferredExecution = !pMarkup->_fMarkupServicesParsing;

    hr = THR(_aryElementDeferredScripts.Append(pScript));
    if (hr)
        goto Cleanup;

    if (!_fDeferredScripts)
    {
        _fDeferredScripts = TRUE;
    }

Cleanup:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::CommitDeferredScripts
//
//----------------------------------------------------------------------------

HRESULT
CDoc::CommitDeferredScripts(BOOL fEarly, CMarkup *pContextMarkup /* == NULL */)
{
    HRESULT             hr = S_OK;
    int                 i;
    BOOL                fLeftSome = FALSE;

    if (!_fDeferredScripts)
        return S_OK;

    Assert(pContextMarkup);

    // Loop is structured inefficiently on purpose: we need to withstand
    // _aryElementDefereedScripts growing/being deleted in place
    
    for (i = 0; i < _aryElementDeferredScripts.Size(); i++)
    {
        CScriptElement *pScript = _aryElementDeferredScripts[i];
        
        if (pScript)
        {
            BOOL fCommitCode = (pScript->GetMarkup() == pContextMarkup);

            if (fEarly && pScript->_fSrc)
            {
                fLeftSome = TRUE;
            }
            else if (fCommitCode || !pScript->_fDeferredExecution)
            {
                _aryElementDeferredScripts[i] = NULL;
                
                Assert(!pScript->_fDeferredExecution || fCommitCode);
                pScript->_fDeferredExecution = FALSE;
                if (fCommitCode)
                    IGNORE_HR(pScript->CommitCode());
                pScript->Release();
            }
            else
            {
                fLeftSome = TRUE;
            }
        }
    }

    if (!fLeftSome)
    {
        _fDeferredScripts = FALSE;
        _aryElementDeferredScripts.DeleteAll();
    }

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDoc::CommitScripts
//
//  Synopsis:   hooks up scripts 
//
//----------------------------------------------------------------------------

HRESULT
CDoc::CommitScripts(CMarkup *pMarkup, CBase *pelTarget, BOOL fHookup)
{
    HRESULT             hr = S_OK;
    CScriptElement *    pScript;
    int                 cScripts;
    int                 iScript;
    BOOL                fAllow;
    CCollectionCache *  pCollectionCache;
    CMarkup *           pMarkupTarget = pMarkup;

    // TODO (JHarding): Millenium system restore keeps pumping messages to us after they've closed
    // us.  This will prevent us from crashing.
    if( IsShut() )
        goto Cleanup;

    if (!pMarkupTarget || !pMarkupTarget->_fHasScriptForEvent)
        goto Cleanup;
        
    hr = THR(pMarkupTarget->EnsureCollectionCache(CMarkup::SCRIPTS_COLLECTION));
    if (hr)
        goto Cleanup;

    pCollectionCache = pMarkupTarget->CollectionCache();

    cScripts = pCollectionCache->SizeAry(CMarkup::SCRIPTS_COLLECTION);
    if (!cScripts)
        goto Cleanup;

    hr = THR(pMarkupTarget->ProcessURLAction(URLACTION_SCRIPT_RUN, &fAllow));
    if (hr || !fAllow)
        goto Cleanup;

    // iterate through all scripts in doc's script collection
    for (iScript = 0; iScript < cScripts; iScript++)
    {
        CElement *pElemTemp;

        hr = THR(pCollectionCache->GetIntoAry (CMarkup::SCRIPTS_COLLECTION, iScript, &pElemTemp));
        if (hr)
            goto Cleanup;

        pScript = DYNCAST(CScriptElement, pElemTemp);

        Assert (ETAG_SCRIPT == pElemTemp->Tag());

        if (!pScript->_fScriptCommitted || pelTarget)
            IGNORE_HR(pScript->CommitFunctionPointersCode(pelTarget, fHookup));
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\eselect.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eselect.cxx
//
//  Contents:   Select element class, etc..
//
//  Classes:    CSelectElement, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_ESELECT_HXX_
#define X_ESELECT_HXX_
#include "eselect.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_PUTIL_HXX_
#define X_PUTIL_HXX_
#include "putil.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_SELLYT_HXX_
#define X_SELLYT_HXX_
#include "sellyt.hxx"
#endif

#ifndef X_EOPTION_HXX_
#define X_EOPTION_HXX_
#include "eoption.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef _X_ACCBASE_HXX_
#define _X_ACCBASE_HXX_
#include "accbase.hxx"
#endif

#ifndef _X_ACCUTIL_HXX_
#define _X_ACCUTIL_HXX_
#include "accutil.hxx"
#endif

#ifndef _X_TPOINTER_HXX_
#define _X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

//
// we need this thing to compile
// this is defined in winuser.h
//

/*
 * Combobox information
 */
typedef struct tagCOMBOBOXINFO
{
    DWORD cbSize;
    RECT  rcItem;
    RECT  rcButton;
    DWORD stateButton;
    HWND  hwndCombo;
    HWND  hwndItem;
    HWND  hwndList;
} COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO;

#ifdef DLOAD1
extern "C"
#endif
BOOL
WINAPI
GetComboBoxInfo(
    HWND hwndCombo,
    PCOMBOBOXINFO pcbi
);

//
// end of winuser story
//

#ifdef _MAC
#ifdef SendMessageA
#undef SendMessageA

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

WINUSERAPI
LRESULT
WINAPI
SendMessageA(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  // SendMessageA
#endif  // _MAC

MtDefine(CSelectElement, Elements, "CSelectElement")
MtDefine(CSelectElement_aryOptions_pv, CSelectElement, "CSelectElement::_aryOptions::_pv")

MtDefine(BldOptionsCol, PerfPigs, "Build CSelectElement::SELECT_OPTION_COLLECTION")

DeclareTag(tagSelectWalk, "SelectWalk", "Trace the SELECT walking the OPTIONs");

DeclareTag(tagSelectState, "SelectState", "General SELECT state tracing");
DeclareTag(tagEraseBkgndStack, "EraseBkgndStack", "stack trace when processing EraseBackground");
DeclareTag(tagSelectInval, "Select", "invalidation");
DeclareTag(tagSelectWndProc, "Select", "WM messages");

ExternTag(tagViewHwndChange);

#define CX_BUTTON_DEFAULT_PX 73
#define CY_BUTTON_DEFAULT_PX 23

#define CX_SELECT_DEFAULT_PIXEL 24L

#define SELECT_OPTION_COLLECTION 0
#define NUMBER_OF_SELECT_COLLECTIONS 1

#define _cxx_
#include "select.hdl"

#if DBG == 1
static unsigned s_SelectSize = sizeof(CSelectElement);
#endif

extern DYNLIB g_dynlibOLEACC;       // Needed for WM_GETOBJECT support and accessibility

extern class CFontCache & fc();

extern BOOL  g_fThemedPlatform;

ATOM GetWndClassAtom(UINT uIndex);

//  !!!! WARNING !!!!
//  This array should ALWAYS be kept in sync with the corresponding enum
//  WindowMessages in eselect.hxx !
//
//  CSelectElement::CreateElement contains a check for this synchronization

UINT const CSelectElement::s_aMsgs[][2] =
{
    {CB_ADDSTRING,      LB_ADDSTRING    },
    {CB_GETCOUNT,       LB_GETCOUNT     },
    {CB_GETCURSEL,      LB_GETCURSEL    },
    {CB_SETCURSEL,      LB_SETCURSEL    },
    {CB_GETCURSEL,      LB_GETSEL       },
    {CB_SETCURSEL,      LB_SETSEL       },
    {CB_GETITEMDATA,    LB_GETITEMDATA  },
    {CB_SETITEMDATA,    LB_SETITEMDATA  },
    {CB_GETLBTEXT,      LB_GETTEXT      },
    {CB_GETLBTEXTLEN,   LB_GETTEXTLEN   },
    {CB_DELETESTRING,   LB_DELETESTRING },
    {CB_INSERTSTRING,   LB_INSERTSTRING },
#ifndef WIN16
    {CB_GETTOPINDEX,    LB_GETTOPINDEX  },
    {CB_SETTOPINDEX,    LB_SETTOPINDEX  },
#endif //!WIN16
    {CB_RESETCONTENT,   LB_RESETCONTENT },
    {CB_SETITEMHEIGHT,  LB_SETITEMHEIGHT },
    //  Insert new message pairs here
    {OCM__BASE, OCM__BASE}              //  Arbitrary nonzero value used as guardian element
                                        //  Keep this as the last pair!!
};


const CElement::CLASSDESC CSelectElement::s_classdesc =
{
    {
        &CLSID_HTMLSelectElement,       // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NOTIFYENDPARSE  |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_NEVERSCROLL     |
        ELEMENTDESC_HASDEFDESCENT,      // _dwFlags
        &IID_IHTMLSelectElement,        // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLSelectElement, // _pfnTearOff
    NULL                                // _pAccelsRun
};

//  Storage for the listbox and combobox subclassing
static WNDPROC s_alpfnSelectWndProc[2] = {NULL, NULL};
static long    s_lIDSelect = 1;


const CSelectElement::WIDEHOOKPROC CSelectElement::s_alpfnWideHookProc[2] =
{
// WINCE - cut some win95-only calls, so we can drop wselect.cxx from sources
#ifdef WINCE
    NULL, NULL
#else
    &CSelectElement::WComboboxHookProc,
    &CSelectElement::WListboxHookProc
#endif // GAL_VERSION
};

DWORD const CSelectElement::s_dwStyle[] =
{
    WS_BORDER | WS_CHILD | WS_CLIPSIBLINGS | WS_VSCROLL | CBS_HASSTRINGS | CBS_DROPDOWNLIST,
    WS_BORDER | WS_CHILD | WS_CLIPSIBLINGS | WS_VSCROLL | LBS_HASSTRINGS | LBS_NOTIFY
};

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::RelIdxFromAbs
//
//  Synopsis:   Maps the current selection from absolute to relative.
//
//-------------------------------------------------------------------------

LRESULT
CSelectElement::RelIdxFromAbs(long lIndex)
{
    if (lIndex < 0)
        return lIndex;

    if (lIndex >= _aryOptions.Size())
        return -1;
 
    LRESULT lr = lIndex;

    if (_fHasOptGroup)
    {
        Assert( !_aryOptions[lIndex]->_fIsOptGroup );
        lr = -1;
        for ( long i = 0; i <= lIndex; i++ )
        {
            if ( _aryOptions[i]->_fIsOptGroup )
            {
                continue;
            }
            else
            {
                lr++;
            }
        }        
    }

    return lr;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::AbsIdxFromRel
//
//  Synopsis:   Maps the current selection from relative to absolute.
//
//-------------------------------------------------------------------------

LRESULT
CSelectElement::AbsIdxFromRel(long lIndex)
{
    if (lIndex < 0)
        return lIndex;

    LRESULT lr = lIndex;

    if (_fHasOptGroup)
    {
        for ( long i = 0; i < _aryOptions.Size() && lr >= 0; i++ )
        {
            if ( _aryOptions[i]->_fIsOptGroup )
            {
                continue;
            }
            else
            {
                lr--;
            }
        }
        
        if (lr == lIndex)
        {
            Assert(i == _aryOptions.Size());
            lr = -1;
        }
        else
        {
            Assert(i <= _aryOptions.Size());
            lr = (lr >= 0) ? i : i - 1;
            Assert((lr == i) || !_aryOptions[lr]->_fIsOptGroup);
        }
    }

    return lr;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::SetCurSel
//
//  Synopsis:   Sets the newly selected item.
//
//  Arguments:  iNewSel            the new selected entry's index, 0-based
//                                 -1 means no selection
//              fUpdateCollection: TRUE if the Options collection should be traversed
//                                 and the individual _fSELECTED flags updated.
//
//  Note:       Sends the xB_SETCURSEL message to the control if it exists.
//              Stores the new index.
//
//-------------------------------------------------------------------------

LRESULT
CSelectElement::SetCurSel(int iNewSel, DWORD grfUpdate)
{
    LRESULT lr;

    Assert(!_fMultiple);

    if ( _hwnd && !(grfUpdate & SETCURSEL_DONTTOUCHHWND) )
    {
        lr = SendSelectMessage(Select_SetCurSel, (WPARAM)iNewSel, 0);
    }
    else
    {
        lr = iNewSel >= _aryOptions.Size() ? LB_ERR : iNewSel;
    }

    if (_fListbox && grfUpdate & SETCURSEL_SETTOPINDEX
        && iNewSel >= 0)
    {
        // HACK ALERT (krisma): we shouldn't have to do this
        // because the window's control should do it for us.
        // But for some reason it's not working (see bug 
        // 51945 and all it's dupes).
        SetTopIndex(iNewSel);
    }

    if ( lr != LB_ERR || iNewSel == LB_ERR )
    {
        _iCurSel = iNewSel;

        if ( grfUpdate & SETCURSEL_UPDATECOLL )
        {
            int i;

            for ( i = _aryOptions.Size() - 1; i >= 0; i-- )
            {
                _aryOptions[i]->_fSELECTED = _iCurSel == i;
#if DBG == 1                
                if ( _aryOptions[i]->_fSELECTED )
                    Assert( _aryOptions[i]->_fIsOptGroup == FALSE );
#endif
            }
        }
    }

#if DBG == 1

    // Let's make sure the options collection and _iCurSel are in sync
    if (lr != LB_ERR && _aryOptions.Size() > 0)
    {
        int i;

        for ( i = _aryOptions.Size() - 1; i >= 0; i-- )
        {
            if (_aryOptions[i]->_fSELECTED)
                break;
        }

        Assert (i == _iCurSel);
    }

#endif // DBG == 1

    return lr;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::GetCurSel
//
//  Synopsis:   retrieves the current selection's index.
//
//  Note:       Uses the control if it exists.
//
//-------------------------------------------------------------------------

LRESULT
CSelectElement::GetCurSel(void)
{
    LRESULT lr;

    if ( _hwnd && !_fMultiple)
    {
        lr = SendSelectMessage(Select_GetCurSel, 0, 0);
    }
    else if (!_fMultiple)
    {
        lr = _iCurSel;
    }
    else
    {
        long i;
        long cOptions = _aryOptions.Size();

        Assert(!_hwnd || SendSelectMessage(Select_GetCount, 0, 0) == cOptions);

        lr = -1;  // if no selection found, selectedIndex will be -1
        for ( i = 0; i < cOptions; i++ )
        {
            if ( _aryOptions[i]->_fSELECTED )
            {
                lr = i;
                Assert( _aryOptions[i]->_fIsOptGroup == FALSE );
                break;
            }
        }
    }

    return lr;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::SetSel
//
//  Synopsis:   Sets the selection state of a listbox line.
//
//  Arguments:  lIndex     the index of the line to be changed or -1 if all
//              fSelected  the new selection state
//
//  Note:       Sends the LB_SETSEL message to the control if it exists.
//
//-------------------------------------------------------------------------

LRESULT
CSelectElement::SetSel(long lIndex, BOOL fSelected, DWORD grfUpdate)
{
    LRESULT lr;

    Assert(_fMultiple);

    if ( _hwnd && !(grfUpdate & SETCURSEL_DONTTOUCHHWND))
    {
        lr = SendSelectMessage(Select_SetSel, (WPARAM)fSelected, (LPARAM)(UINT)lIndex);
    }
    else
    {
        lr = (lIndex >= _aryOptions.Size()) || (lIndex < -1) ? LB_ERR : LB_OKAY;
    }

    return lr;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::SetTopIndex
//
//  Synopsis:   Sets the first visible line.
//
//  Arguments:  iNewSel     the new topindex, 0-based
//
//  Note:       Sends the xB_SETTOPINDEX message to the control if it exists.
//              Stores the new index.
//
//-------------------------------------------------------------------------

LRESULT
CSelectElement::SetTopIndex(int iTopIndex)
{
    LRESULT lr;

#ifndef WIN16
    Assert(_fListbox);

    if ( _hwnd )
    {
        lr = SendSelectMessage(Select_SetTopIndex, (WPARAM)iTopIndex, 0);
    }
    else
#endif // ndef WIN16
    {
        lr = LB_OKAY;
    }

    if (lr != LB_ERR)
    {
        _lTopIndex = iTopIndex;
    }

    return lr;
}



//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::AddString
//
//  Synopsis:   Cover for the xB_ADDSTRING handler.
//
//  Arguments:  pstr    the text for the newly inserted line
//
//  Note:       Fakes the action if the control is not around.
//
//-------------------------------------------------------------------------

LRESULT
CSelectElement::AddString(LPCTSTR pstr)
{
    LRESULT lr;

    if ( _hwnd )
    {
        lr = SendSelectMessage(Select_AddString, 0, pstr ? (LPARAM)pstr : (LPARAM) g_Zero.ach);
    }
    else
    {
        lr = LB_OKAY;
    }

    return lr;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::Init
//
//  Synopsis:   Registers the subclassing windprocs
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::Init()
{
    HRESULT hr   = super::Init();
    ULONG_PTR dw     = 0;

    if (hr)
        goto Cleanup;

    if ( ! GetWndClassAtom(WNDCLASS_COMBOBOX) )
    {
        if (g_fThemedPlatform && IsThemeActive())
            SHActivateContext(&dw);

        hr = THR(RegisterWindowClass(
                WNDCLASS_COMBOBOX,
                SelectElementWndProc,
                0,
                _T("combobox"),
                &s_alpfnSelectWndProc[0]));        

        if (hr)
            goto Cleanup;

        hr = THR(RegisterWindowClass(
                WNDCLASS_LISTBOX,
                SelectElementWndProc,
                0,
                _T("listbox"),
                &s_alpfnSelectWndProc[1]));

        if (hr)
            goto Cleanup;
    }

    _iCurSel = -1;


Cleanup:
    if (dw != 0)
        SHDeactivateContext(dw);
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::Init2
//
//  Synopsis:   Initialization phase after attributes were set.
//
//  Note:       The control has to be initialized first, as the 2D Div
//              site recalcs from CSite::Init2, which action needs
//              an initialized SELECT.
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::Init2(CInit2Context * pContext)
{
    HRESULT hr;

    hr = THR(InitState());
    if ( hr )
        goto Cleanup;

    hr = THR(super::Init2(pContext));

Cleanup:
    RRETURN1(hr, S_INCOMPLETE);
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IHTMLSelectElement2, NULL)
        QI_TEAROFF(this, IHTMLSelectElement4, NULL)
    } // end switch

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        RRETURN(S_OK);
    }

    RRETURN(super::PrivateQueryInterface(iid, ppv));
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::CreateElement
//
//  Synopsis:
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    AssertSz(LB_ERR == CB_ERR, "LB_ERR, CB_ERR error codes changed, need to recode!");
    Assert(s_aMsgs[Select_LastMessage_Guard][0] == OCM__BASE && "Message translation array is BAD!");
    Assert(ARRAY_SIZE(s_aMsgs) == Select_LastMessage_Guard + 1 && "Message translation array size error!");
    Assert(ppElement);

    *ppElement = new CSelectElement(pDoc);

    // If the element is created through DOM enable layout requests
    if (*ppElement && pht->IsDynamic())
        DYNCAST(CSelectElement, *ppElement)->_fEnableLayoutRequests = TRUE;

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}


CSelectElement::~CSelectElement()
{
    delete _pCollectionCache;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::UpdateBackgroundBrush
//
//  Synopsis:   Updates the cached brush used to paint the CSS background color
//
//-------------------------------------------------------------------------

void
CSelectElement::UpdateBackgroundBrush(void)
{
    CColorValue ccvBackColor = GetFirstBranch()->GetCascadedbackgroundColor();

    ReleaseCachedBrush(_hBrush);

    if ( ccvBackColor.IsDefined() )
    {
        _hBrush = GetCachedBrush(ccvBackColor.GetColorRef());
    }
    else
    {
        _hBrush = GetCachedBrush(GetSysColorQuick(COLOR_WINDOW));
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::InvalidateBackgroundBrush
//
//  Synopsis:   Invalidates the cached brush used to paint the CSS background color
//              It will be re-computed when needed
//
//-------------------------------------------------------------------------

void
CSelectElement::InvalidateBackgroundBrush(void)
{
    ReleaseCachedBrush(_hBrush);
    _hBrush = NULL;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::InitState, protected
//
//  Synopsis:   Initializes the private state flags.
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::InitState(void)
{
    _fMultiple = GetAAmultiple();

    _fListbox = (_fMultiple || (GetAAsize() > 1));

    _fSendMouseMessagesToDocument = FALSE;

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement:NotifyWidthChange
//
//  Synopsis:   Called by the OPTION element whose Text was changed
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::NotifyWidthChange(COptionElement * pOptionChanged)
{
    long lLineLength;

    Assert(pOptionChanged);

    lLineLength = pOptionChanged->MeasureLine();

    if ( (lLineLength > _lMaxWidth ||
          pOptionChanged == _poptLongestText) )
    {
        _sizeDefault.cx = 0;
        ResizeElement();
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     DeferUpdateWidth
//
//  Synopsis:   Deferes the call to update the width
//
//  Returns:    None
//
//--------------------------------------------------------------------------

void
CSelectElement::DeferUpdateWidth()
{
    // Kill pending calls if any
    GWKillMethodCall(this, ONCALL_METHOD(CSelectElement, DeferredUpdateWidth, deferredupdatewidth), 0);
    // Defer the update width call
    IGNORE_HR(GWPostMethodCall(this,
                               ONCALL_METHOD(CSelectElement, DeferredUpdateWidth, deferredupdatewidth),
                               0, TRUE, "CSelectElement::DeferredUpdateWidth"));
}

void
CSelectElement::DeferredUpdateWidth(DWORD_PTR dwContext)
{
    _sizeDefault.cx = 0;
    ResizeElement();
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::OnPropertyChange
//
//  Synopsis:   Call notify on the site and all of its children
//
//  Note:       Here we provide for morphing between the list and the combo
//              shape of the control.
//              Due to the weirdness of the Windows listbox control we
//              need to morph (i.e. destroy and recreate the control
//              even when changing the multiselect state of the listbox as
//              simply changing the WS_EXTENDEDSEL bit has no effect.
//
//              The pragma is here because the optimizing compiler chokes
//              on the call to delete[] paryData in cleanup. It's a mystery.
//-------------------------------------------------------------------------

HRESULT
CSelectElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;

    BOOL fIsNewShapeListbox = _fListbox;
    BOOL fMorph = FALSE;
    BOOL fSizeChanged = FALSE;
    BOOL fMultiSelectChanged = FALSE;

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    if ( hr )
        goto Cleanup;

    if ( dispid == DISPID_UNKNOWN ||
         dispid == DISPID_CSelectElement_multiple )
    {
        //  Multiple
        //  Compute new shape
        fIsNewShapeListbox = GetAAmultiple() || GetAAsize() > 1;
        fMultiSelectChanged = TRUE;
        fMorph = TRUE;
    }

    if ( dispid == DISPID_UNKNOWN ||
         dispid == DISPID_CSelectElement_size )
    {
        //  Size
        //  Compute new shape
        fIsNewShapeListbox = GetAAmultiple() || GetAAsize() > 1;
        fSizeChanged = TRUE;
        _fRefreshFont = TRUE;
    }

    if ( dispid == DISPID_UNKNOWN ||
         dispid == DISPID_BACKCOLOR )
    {
        InvalidateBackgroundBrush();
        if (_hwnd)
        {
            TraceTag((tagSelectInval, "RedrawWindow SEL %d hwnd %x",
                                        SN(), _hwnd));
            ::RedrawWindow(_hwnd, (GDIRECT *)NULL, NULL, RDW_INVALIDATE | RDW_FRAME);
        }
    }

    if ( dispid == DISPID_UNKNOWN ||
         dispid == DISPID_A_COLOR )
    {
        if (_hwnd)
        {
            TraceTag((tagSelectInval, "RedrawWindow SEL %d hwnd %x",
                                        SN(), _hwnd));
            ::RedrawWindow(_hwnd, (GDIRECT *)NULL, NULL, RDW_INVALIDATE | RDW_FRAME);
        }
    }

    if ( dispid == STDPROPID_XOBJ_WIDTH ||
         dispid == STDPROPID_XOBJ_HEIGHT ||
         dispid == DISPID_UNKNOWN )
    {
        _sizeDefault.cx = _sizeDefault.cy = 0;
    }

    if ( dispid == DISPID_A_FONTFACE ||
         dispid == DISPID_A_FONTSIZE ||
         dispid == DISPID_A_TEXTDECORATIONLINETHROUGH ||
         dispid == DISPID_A_TEXTDECORATIONUNDERLINE ||
         dispid == DISPID_A_TEXTDECORATIONNONE ||
         dispid == DISPID_A_TEXTDECORATION ||
         dispid == DISPID_A_FONTSTYLE ||
         dispid == DISPID_A_FONTVARIANT ||
         dispid == DISPID_A_FONTWEIGHT ||
         dispid == DISPID_UNKNOWN)
    {
        _sizeDefault.cx = _sizeDefault.cy = 0;
        _fRefreshFont = TRUE;
        ResizeElement();
        if (_hwnd)
        {
            TraceTag((tagSelectInval, "RedrawWindow SEL %d hwnd %x",
                                        SN(), _hwnd));
            ::RedrawWindow(_hwnd, (GDIRECT *)NULL, NULL, RDW_INVALIDATE | RDW_FRAME);
        }
    }

    if ( dispid == DISPID_A_TEXTTRANSFORM ||
         //dispid == DISPID_A_LETTERSPACING ||
         dispid == DISPID_UNKNOWN)
    {
        _sizeDefault.cx = _sizeDefault.cy = 0;
        ResizeElement();
        if (_hwnd)
        {
            TraceTag((tagSelectInval, "RedrawWindow SEL %d hwnd %x",
                                        SN(), _hwnd));
            ::RedrawWindow(_hwnd, (GDIRECT *)NULL, NULL, RDW_INVALIDATE | RDW_FRAME);
        }
    }

    if ( dispid == DISPID_CElement_disabled ||
         dispid == DISPID_AMBIENT_USERMODE ||
         dispid == DISPID_UNKNOWN )
    {
        if (_hwnd)
        {
            TraceTag((tagSelectInval, "RedrawWindow SEL %d hwnd %x",
                                        SN(), _hwnd));
            ::EnableWindow(_hwnd, IsEditable(TRUE) || IsEnabled());
            ::RedrawWindow(_hwnd, (GDIRECT *)NULL, NULL, RDW_INVALIDATE | RDW_FRAME);
        }
    }

    // the direction was changed
    if ( dispid == DISPID_A_DIR || dispid == DISPID_A_DIRECTION )
    {
        _fNeedMorph = TRUE;
    }

    if ( fMorph ||
         _fListbox && ! fIsNewShapeListbox ||
         ! _fListbox && fIsNewShapeListbox )
    {
        _fNeedMorph = TRUE;
    }

    if ( fSizeChanged || fMorph )
    {
        //  Compute new size
        //  Request new layout from the doc.
        _sizeDefault.cx = _sizeDefault.cy = 0;
        ResizeElement();
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::Morph, protected
//
//  Synopsis:   Change the instantiaited Windows control, preserving data
//
//  Note:       The control needs to be reinstantiated to chenge between
//              combo, single-select list and mulstiselect list.
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::Morph(void)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();

    //  pull the data out into a list
    //  Get rid of the old window
    //  Create the new window
    //  Pump the data into the new window
    //  Compute the new extents
    //  Request new layout from the Doc

    hr = THR(PullStateFromControl());
    if ( hr )
        goto Cleanup;

    DestroyControlWindow();

    _fWindowDirty = TRUE;

    hr = InitState();    //  _fMultiple is set up here
    if ( hr )
        goto Cleanup;

    if ( pDoc && pDoc->_state >= OS_INPLACE )
    {
        hr = THR(EnsureControlWindow());
        if ( hr )
            goto Cleanup;
    }

    _fNeedMorph = FALSE;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::Notify
//
//  Synopsis:   Listen for tree notifications
//
//-------------------------------------------------------------------------

void
CSelectElement::Notify(CNotification *pNF)
{
    DWORD       dwData;
    HRESULT     hr = S_OK;
    IStream *   pStream = NULL;
    long        lTopIndex;
    long        lIndex;
    DWORD       dwIndex;

    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_QUERYFOCUSSABLE:
        if (_fSendMouseMessagesToDocument)
        {
            ((CQueryFocus *)pNF->DataAsPtr())->_fRetVal = TRUE;
        }
        break;
    case NTYPE_ELEMENT_SETFOCUS:
        if (    _hwnd
            &&  _hwnd != ::GetFocus()

            // Take focus only if _fTakeFocus is TRUE (user setting focus through click, TAB, etc.)
            // or if the browser already has focus
            &&  (   ((CSetFocus *)pNF->DataAsPtr())->_fTakeFocus
                 || Doc()->HasFocus()
                )
           )
        {
            //  Lock any focus firing. BecomeCurrent has already done all that.

            CLock Lock(this, ELEMENTLOCK_FOCUS);
            ::SetFocus(_hwnd);
        }
        break;
    case NTYPE_AMBIENT_PROP_CHANGE:
        pNF->Data(&dwData);
        if (dwData == DISPID_AMBIENT_USERMODE ||
            dwData == DISPID_UNKNOWN ||
            dwData == DISPID_AMBIENT_RIGHTTOLEFT)
        {
            if (dwData != DISPID_AMBIENT_RIGHTTOLEFT)
            {
                ::EnableWindow(_hwnd, IsEditable(TRUE) || IsEnabled());
            }
            else
            {
                //  Recreate the control to make sure it is going the
                //  correct direction. We do not have the CParaFormat change
                //  yet and cannot enqueue a layout request here. Therefore
                //  we will set a flag and call Morph() when laying out
                //  (CSelectLayout::CalcSize()).
                _fNeedMorph = TRUE;
            }
        }
        break;

    case NTYPE_DOC_STATE_CHANGE_1:
        if (    Doc()->State() < OS_INPLACE 
            &&  (OLE_SERVER_STATE)(pNF->DataAsDWORD()) >= OS_INPLACE)
        {
            pNF->SetSecondChanceRequested();
        }
        break;

    case NTYPE_DOC_STATE_CHANGE_2:
        Assert (    Doc()->State() < OS_INPLACE 
                &&  (OLE_SERVER_STATE)(pNF->DataAsDWORD()) >= OS_INPLACE );

        hr = THR(OnInPlaceDeactivate());
        if (hr)
            goto Cleanup;
        if (HasLayoutPtr())
        {
            DYNCAST(CSelectLayout, Layout())->_fWindowHidden = TRUE;
        }
        break;

    case NTYPE_SAVE_HISTORY_1:
        pNF->SetSecondChanceRequested();
        break;

    case NTYPE_SAVE_HISTORY_2:
        {
            CDataStream         ds;
            CHistorySaveCtx *   phsc;

            pNF->Data((void **)&phsc);
            hr = THR(phsc->BeginSaveStream((     0x80000000
                                            |   (DWORD)_iHistoryIndex
                                            &   0x0FFFF),
                                            HistoryCode(), &pStream));
            if (hr)
                goto Cleanup;

            ds.Init(pStream);

            // Save TopIndex (index of first visible item)
            if ( _fListbox )
            {
#ifndef WIN16
                // BUGWIN16: Win16 doesn't support Select_GetTopIndex,
                // so am turning this off. is this right ?? vreddy - 7/16/97
                if ( _hwnd )
                {
                    lTopIndex = SendSelectMessage(Select_GetTopIndex, 0, 0);
                }
                else
#endif // ndef WIN16
                {
                    lTopIndex = _lTopIndex;
                }
            }
            else
            {
                lTopIndex = LB_ERR;
            }
            hr = THR(ds.SaveDword(lTopIndex));
            if (hr)
                goto Cleanup;


            // Save the indices of the selected items
            if (_fMultiple)
            {
                for (lIndex = _aryOptions.Size() - 1; lIndex >= 0; lIndex--)
                {
                    if ( _aryOptions[lIndex]->_fSELECTED )
                    {
                        hr = THR(ds.SaveDword(lIndex));
                        if (hr)
                            goto Cleanup;
                    }
                }
            }
            else
            {
                if (_iCurSel != LB_ERR)
                {
                    Assert(GetCurSel() == _iCurSel);
                    hr = THR(ds.SaveDword(_iCurSel));
                    if (hr)
                        goto Cleanup;
                }
            }

            // Use LB_ERR as the terminator
            hr = THR(ds.SaveDword((DWORD)LB_ERR));
            if (hr)
                goto Cleanup;

            hr = THR(phsc->EndSaveStream());
            if (hr)
                goto Cleanup;
        }

        break;

    case NTYPE_END_PARSE:
        // TODO (jbeda) this should probably happen 
        // on NTYPE_DELAY_LOAD_HISTORY
        pStream = NULL;

        if(IsInMarkup())
        {
            IGNORE_HR(GetMarkup()->GetLoadHistoryStream((     0x80000000
                                                        |   (DWORD)_iHistoryIndex
                                                        &   0x0FFFF),
                                                      HistoryCode(),
                                                      &pStream));
        }

        //  The history load logic requires that _aryOptions is up to date.

        _fOptionsDirty = TRUE;

        if (_hwnd)
        {
            // HACKALERT!  (BUG 67310) We need to resync the hwnd to the OM here
            // and resize the control. We're not really morphing, 
            // but setting this flag does everything we need.
            _fNeedMorph = TRUE;
        }
        else
        {
            BuildOptionsCache();
        }

        if (pStream)
        {
            CDataStream ds(pStream);
            BOOL        fFirst = TRUE;

            // Load TopIndex (first visible item)
            hr = THR(ds.LoadDword(&dwIndex));
            if (hr)
                goto Cleanup;
            if (_fListbox && dwIndex != LB_ERR)
            {
                SetTopIndex(dwIndex);
            }

            // Set selection (reset the current selection first)
            if ( _fMultiple )
            {
                int i;

                SetSel(-1, FALSE);
                for ( i = _aryOptions.Size() - 1; i >= 0; i-- )
                {
                    _aryOptions[i]->_fSELECTED = FALSE;
                }
            }
            else
            {
                SetCurSel(-1, SETCURSEL_UPDATECOLL);
            }

            hr = THR(ds.LoadDword(&dwIndex));
            if (hr)
                goto Cleanup;
            while (dwIndex != LB_ERR)
            {
                if (!fFirst && !_fMultiple)
                {
                    // Cannot select more than one item !
                    Assert(FALSE);
                    break;
                }
                fFirst = FALSE;

                // select the item at dwIndex
                if ((long)dwIndex < _aryOptions.Size())
                {
                    LRESULT lr;

                    _aryOptions[dwIndex]->_fSELECTED = TRUE;
                    lr = (_fMultiple) ?
                        SetSel(dwIndex, TRUE) :
                        SetCurSel(dwIndex);

                    hr = (lr == LB_ERR) ? E_FAIL : S_OK;

                    if (hr)
                        goto Cleanup;
                }
                hr = THR(ds.LoadDword(&dwIndex));
                if (hr)
                    goto Cleanup;
           }

        }

        //  Unblock layout requests
        _fEnableLayoutRequests = TRUE;

        //  Kick off a request to ensure the UI
        Layout()->Dirty();
        ResizeElement();
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
    case NTYPE_ELEMENT_EXITVIEW_1:
        pNF->SetSecondChanceRequested();
        break;

    case NTYPE_ELEMENT_EXITTREE_2:
        ExitTree();
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        if (GetMarkup())
            _fUseThemes = !!(GetMarkup()->GetThemeUsage() == THEME_USAGE_ON);
        EnterTree();
        break;

    case NTYPE_ELEMENT_EXITVIEW_2:
        ExitView();
        break;
    }

Cleanup:
    ReleaseInterface(pStream);
    return;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::EnterTree
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::EnterTree()
{
    HRESULT                    hr = S_OK;
    CMarkup *             pMarkup = GetMarkup(); Assert(pMarkup);
    CMarkupTransNavContext * ptnc = pMarkup->EnsureTransNavContext();

    if (!ptnc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _fOptionsDirty  = TRUE;
    _sizeDefault.cx = _sizeDefault.cy = 0;
    _iHistoryIndex  = (unsigned short)ptnc->_dwHistoryIndex++;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::ExitTree
//
//  Synopsis:   Shuts down the SELECT
//
//              Frees private data,
//              destroys the control window,
//              releases the font
//
//-------------------------------------------------------------------------

void
CSelectElement::ExitTree()
{
    _poptLongestText = NULL;
    _lMaxWidth = 0;

    _aryOptions.DeleteAll();

    ExitView();
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::ExitView
//
//
//-------------------------------------------------------------------------

void
CSelectElement::ExitView()
{
    if ( _hFont )
    {
        Verify(DeleteObject(_hFont));
        _hFont = NULL;
    }

    if ( _hBrush )
    {
        ReleaseCachedBrush(_hBrush);
        _hBrush = NULL;
    }

    DestroyControlWindow();
}

//+---------------------------------------------------------------------------
//
//  Member: CSelectElement::GetInfo
//
//  Params: [gi]: The GETINFO enumeration.
//
//  Descr:  Returns the information requested in the enum
//
//----------------------------------------------------------------------------
DWORD
CSelectElement::GetInfo(GETINFO gi)
{
    switch (gi)
    {
    case GETINFO_HISTORYCODE:
        return MAKELONG(_fMultiple, Tag());
    }

    return super::GetInfo(gi);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::GetEnabled
//
//  Synopsis:   return not disabled
//
//----------------------------------------------------------------------------

STDMETHODIMP
CSelectElement::GetEnabled(VARIANT_BOOL * pfEnabled)
{
    if (!pfEnabled)
        RRETURN(E_INVALIDARG);

    *pfEnabled = GetAAdisabled() ? VB_FALSE : VB_TRUE;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::EnsureControlWindow, protected
//
//  Synopsis:   Ensure the control window and the correct contents.
//
//  Note:       The Doc must be inplace active here. The SELECT needs the
//              Doc's inplace window to be its parent, otherwise
//              WM_COMMAND based notifications from the SELECT will eventually
//              get lost.
//
//----------------------------------------------------------------------------

HRESULT
CSelectElement::EnsureControlWindow()
{
    HRESULT hr;

    hr = THR(CreateControlWindow());
    if ( hr )
        goto Cleanup;

    if ( _fWindowDirty )
    {
        hr = THR(PushStateToControl(TRUE));     //  Indicate being called from Create
        if ( hr )
            goto Cleanup;
    }


Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::CreateControlWindow, protected
//
//  Synopsis:   Create the child control window.
//
//  Note:       The Doc must be inplace active here. The SELECT needs the
//              Doc's inplace window to be its parent, otherwise
//              WM_COMMAND based notifications from the SELECT will eventually
//              get lost.
//
//----------------------------------------------------------------------------

HRESULT
CSelectElement::CreateControlWindow()
{
    HRESULT            hr                = S_OK;    
    CTreeNode         *pTNode            = GetFirstBranch();
    const CParaFormat *pPF               = NULL;     
    CMarkup           *pMarkup           = GetMarkup();
    ULONG_PTR          dwfTheme          = 0;
    DWORD              dwStyle;
    LPTSTR             lpszClassName;
    DWORD              dwExtStyle;
    UINT               uIndex;

    // $$ktam Used to be layout RTL flag setting here until we yanked RTL from display tree

    if ( _hwnd )
        goto Cleanup;

    TraceTag((tagSelectState, "SELECT %x creating window", this));

    //  Find the parent hwnd
    Assert(Doc() && Doc()->_pInPlace && Doc()->_pInPlace->_hwnd);

    dwStyle = s_dwStyle[_fListbox];

    if ( _fListbox && _fMultiple )
    {
        dwStyle |= LBS_EXTENDEDSEL;
    }

    if ( GetAAdisabled() && (!IsEditable(TRUE)) )
    {
        dwStyle |= WS_DISABLED;
    }

    //
    // some conditions the _fWin95Wide code depends on (benwest 11-13-96):
    // if the following asserts fail it will break code that is rarely run
    //

    // it would be bad if more than one person implements ownerdraw-ness...
    Assert(!(dwStyle & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE)));
    // we don't support ordered lists it would wreak havoc on the Optios collection)
    Assert(!(dwStyle & (_fListbox ? LBS_SORT : CBS_SORT)));

#ifndef WIN16
    // adjust the style bits
    dwStyle |= LBS_OWNERDRAWFIXED;
    dwStyle &= (_fListbox ? ~LBS_HASSTRINGS : ~CBS_HASSTRINGS);
#endif

    uIndex = _fListbox ? WNDCLASS_LISTBOX : WNDCLASS_COMBOBOX;
    lpszClassName = (TCHAR *)(DWORD_PTR)GetWndClassAtom(uIndex);

    dwExtStyle = WS_EX_CLIENTEDGE;
// WINCE - cut WS_EX_NOPARENTNOTIFY from CreateWindowEx
#ifndef WINCE
    dwExtStyle |= WS_EX_NOPARENTNOTIFY;
    
    if (pTNode)
        pPF = pTNode->GetParaFormat();

    if(pTNode && pPF && pPF->HasRTL(TRUE))
    {
        dwExtStyle |= WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT;
    }
#endif
    
    _fUseThemes = !!(pMarkup->GetThemeUsage() == THEME_USAGE_ON);

    if (g_fThemedPlatform && 
         (    ( _fListbox && pMarkup->GetThemeUsage() != THEME_USAGE_OFF)
           || (!_fListbox && pMarkup->GetThemeUsage() == THEME_USAGE_ON)))
    {    
        SHActivateContext(&dwfTheme);
    }

    
    _hwnd = ::CreateWindowEx(dwExtStyle,
                             lpszClassName,
                             NULL,
                             dwStyle,
                             0,0,0,0,                           //  Create invisible
                             Doc()->_pInPlace->_hwnd,
                             NULL,
                             g_hInstCore,
                             this);

    if ( ! _hwnd )
        goto Win32Error;

    if (g_fThemedPlatform && 
        (   ( _fListbox && pMarkup->GetThemeUsage() == THEME_USAGE_OFF)
         || (!_fListbox && pMarkup->GetThemeUsage() != THEME_USAGE_ON)))
    {
        COMBOBOXINFO cbi = {0};
        
        cbi.cbSize = sizeof(cbi);
        if ( GetComboBoxInfo(_hwnd, &cbi) )
        {
            SetWindowTheme(cbi.hwndItem, _T(""), _T(""));
            if (pMarkup->GetThemeUsage() == THEME_USAGE_OFF)
                SetWindowTheme(cbi.hwndList, _T(""), _T(""));
        }

        SetWindowTheme(_hwnd, _T(""), _T(""));
    }
    
    _fWindowDirty = TRUE;

Cleanup:
    if (dwfTheme != 0)
        SHDeactivateContext(dwfTheme);

    RRETURN(hr);


Error:
    if ( _hwnd )
    {
        DestroyWindow(_hwnd);
        _hwnd = 0;
    }
    goto Cleanup;

Win32Error:
    hr = GetLastWin32Error();
    goto Error;

}


//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::OnInPlaceDeactivate, protected
//
//  Synopsis:   Handle the doc leaving inplace.
//
//  Note:       Reparent the control window to the global window
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::OnInPlaceDeactivate(void)
{
    if ( _hwnd )
    {
        DestroyControlWindow();
    }
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::DestroyControlWindow, protected
//
//  Synopsis:   Get rid of the control child window.
//
//-------------------------------------------------------------------------

void
CSelectElement::DestroyControlWindow()
{
    if ( _hwnd )
    {
        //  The control has to be emptied before we destroy it
        //  otherwise Win95 sends WM_DELETEITEM messages
        //  after WM_NCDESTROY.

        TraceTag((tagSelectState, "SELECT %x destroying window", this));

        SendSelectMessage(Select_ResetContent, 0, 0);
        DestroyWindow(_hwnd);
        _hwnd = 0;
        _fWindowVisible = FALSE;
        _fSetComboVert = TRUE;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::PushStateToControl, protected
//
//  Synopsis:   Transfer the state stored in the Options array
//              to the child window control.
//
//  Note:       This include display text and selection state.
//
//-------------------------------------------------------------------------
HRESULT
CSelectElement::PushStateToControl(BOOL fFromCreate)
{
    HRESULT hr = S_OK;
    long cOptions;
    long i;
    LRESULT lr;
    BOOL fSelectedSet = FALSE;
    CDoc *  pDoc = Doc();
    int iLastSelected = -1;

    TraceTag((tagSelectState, "SELECT %x pushing state to window", this));
    if (!_hwnd)
        goto Cleanup;

    TraceTag((tagSelectInval, "SEL %d hwnd %x  - SetRedraw(FALSE)",
                    SN(), _hwnd));

    _fNoRedraw = 1;
    ::SendMessage(_hwnd, WM_SETREDRAW, (WPARAM) FALSE,0);

    SendSelectMessage(Select_ResetContent, 0, 0);

    ::SendMessage(_hwnd, WM_SETFONT, (WPARAM) _hFont, MAKELPARAM(FALSE,0));

    //  Restore the <OPTION>s

    hr = THR(BuildOptionsCache());
    if (hr) 
        goto Cleanup;

    cOptions = _aryOptions.Size();

    for ( i = 0; i < cOptions; i++ )
    {
        lr = SendSelectMessage(Select_AddString, 0,
                               _aryOptions[i]->_cstrText ?
                                (LPARAM)(LPTSTR)_aryOptions[i]->_cstrText :
                                (LPARAM)(LPCTSTR)g_Zero.ach);
        if ( lr == LB_ERR )
            goto Win32Error;

        if ( _aryOptions[i]->_fSELECTED )
        {
            Assert( _aryOptions[i]->_fIsOptGroup == FALSE );

            if ( _fMultiple )
            {
                lr = SetSel(i, TRUE);
                if ( lr == LB_ERR )
                    goto Win32Error;
            }
            else
            {
                fSelectedSet = TRUE;
                iLastSelected = i;
            }
        }
    }

#ifndef WIN16
    if ( _fListbox )
    {
        SendSelectMessage(Select_SetTopIndex, (WPARAM)_lTopIndex, 0);
    }
#endif // ndef WIN16

    if ( ! _fMultiple )
    {
        if ( !fSelectedSet )
        {
            SetCurSel(_iCurSel, SETCURSEL_UPDATECOLL);
        }
        else
        {
            SetCurSel(iLastSelected, SETCURSEL_UPDATECOLL | SETCURSEL_SETTOPINDEX);
        }
    }

    TraceTag((tagSelectInval, "SEL %d hwnd %x  - SetRedraw(TRUE)",
                    SN(), _hwnd));

    ::SendMessage(_hwnd, WM_SETREDRAW, (WPARAM) TRUE,0);

    _fNoRedraw = TRUE;
    if (_fMissedPaint)
    {
        ::InvalidateRect(_hwnd, 0, 0);
        _fMissedPaint = FALSE;
    }

    //  Set up visual state
    {
        CRect   rc;

        GetUpdatedLayout()->GetRect(&rc, COORDSYS_GLOBAL);

        if ( _fWindowVisible && fFromCreate)
        {
            // position the new window and show it
            MoveWindow(_hwnd,
                       rc.left,
                       rc.top,
                       rc.right - rc.left,
                       _fListbox ? rc.bottom - rc.top : _lComboHeight,
                       FALSE);

            Doc()->GetView()->SetWindowRgn(_hwnd, &rc, FALSE);
        }

        if ( ! fFromCreate  || _fWindowVisible )
            ShowWindow(_hwnd, (_fWindowVisible
                                    ? SW_SHOW
                                    : SW_HIDE));
    }

    if ( pDoc->_pElemCurrent == this )
    {
        BOOL fOldInhibit = pDoc->_fInhibitFocusFiring;
        pDoc->_fInhibitFocusFiring = TRUE;
        ::SetFocus(_hwnd);
        pDoc->_fInhibitFocusFiring = fOldInhibit;
    }

    _fWindowDirty = FALSE;

Cleanup:
    RRETURN(hr);

Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;

}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::PullStateFromControl, protected
//
//  Synopsis:   Store the child window control's state
//              in the Options array
//
//  Note:       This needs to pull only selection state, everything
//              else should already be in the Options.
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::PullStateFromControl()
{
    HRESULT hr = S_OK;
    long cOptions;
#if (DBG == 1 && defined(WIN16))
    long i;
    LRESULT lr;
#endif

    if ( ! _hwnd )
        goto Cleanup;


    Assert(_hFont == (HFONT)::SendMessage(_hwnd, WM_GETFONT, 0, 0));

    cOptions = _aryOptions.Size();
    Assert(SendSelectMessage(Select_GetCount, 0, 0) == cOptions);

    //  save the <OPTION>s
#if DBG == 1 && defined(WIN16)
    for ( i = 0; i < cOptions; i++ )
    {
        {
            TCHAR achBuf[FORMS_BUFLEN];

            lr = SendSelectMessage(Select_GetText, (WPARAM)i, (LPARAM)(LPTSTR)achBuf);
            if ( lr == LB_ERR )
                goto Win32Error;

            Assert(0 == _aryOptions[i]->_cstrText.Length() && TEXT('\0') == *achBuf ||
                   0 == StrCmpC(_aryOptions[i]->_cstrText, achBuf));  //  Hack: direct access!
        }
    }
#endif // DBG


Cleanup:
    RRETURN(hr);

#if (DBG == 1 && defined(WIN16)) // Perf
Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;
#endif

}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::ApplyDefaultFormat
//
//  Synopsis:   Applies default formatting properties for that element to
//              the char and para formats passed in
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CSelectElement::ApplyDefaultFormat ( CFormatInfo * pCFI )
{
    HRESULT hr = S_OK;

    LOGFONT    lf;
    CUnitValue uvBorder;
    DWORD      dwRawValue;
    BYTE       i;
    BOOL       fRelative         = pCFI->_pcf->_fRelative;
    BOOL       fVisibilityHidden = pCFI->_pcf->_fVisibilityHidden;
    BOOL       fDisplayNone      = pCFI->_pcf->_fDisplayNone;
    BOOL       fNoBreak          = pCFI->_pcf->_fNoBreak;
    BOOL       fRightToLeft      = pCFI->_pcf->_fRTL;
    BOOL       fEditable         = pCFI->_pcf->_fEditable;
    BOOL       fParentFrozen     = pCFI->_pcf->_fParentFrozen;
    WORD       wLayoutFlow       = pCFI->_pcf->_wLayoutFlow;
    BOOL       fWritingModeUsed  = pCFI->_pcf->_fWritingModeUsed;
    CDoc *     pDoc              = Doc();

    pCFI->PrepareCharFormat();
    pCFI->PrepareParaFormat();

    if (!!_fUseThemes != !!(GetMarkup()->GetThemeUsage() == THEME_USAGE_ON) )
        _fNeedMorph = TRUE;

    //  Block CF inheritance by reiniting to defaults
    pCFI->_cf().InitDefault(pDoc->_pOptionSettings, GetMarkup()->GetCodepageSettings(), FALSE);

    // The code used to rely on the fact that styleCursorAuto is 0. Lets be sure it is
    // (InitDefault does a memset to 0)
    Assert(pCFI->_cf()._bCursorIdx == styleCursorAuto);
    
    // Inherit no break behaviour.
    pCFI->_cf()._fNoBreak = fNoBreak;

    // We must inherit visibility.
    pCFI->_cf()._fVisibilityHidden = fVisibilityHidden;
    pCFI->_cf()._fDisplayNone      = fDisplayNone;

    // Inherit direction.
    pCFI->_cf()._fRTL = fRightToLeft;

    // inherit relative ness
    pCFI->_cf()._fRelative = !!fRelative;

    // inherit layout flow
    pCFI->_cf()._wLayoutFlow = wLayoutFlow;

    // inherit how we obtained out layout flow
    pCFI->_cf()._fWritingModeUsed = fWritingModeUsed;

    // inherit editable
    pCFI->_cf()._fEditable = fEditable;

    // inherit frozen
    pCFI->_cf()._fParentFrozen = fParentFrozen;

    DefaultFontInfoFromCodePage(GetMarkup()->GetCodePage(), &lf, pDoc);
    pCFI->_cf()._bCharSet = lf.lfCharSet;
    pCFI->_cf()._fNarrow = IsNarrowCharSet(lf.lfCharSet);
    pCFI->_cf().SetFaceName( lf.lfFaceName);

    pCFI->_cf().SetHeightInNonscalingTwips(10*20); //was abs(twips)

    // Default text color should be system color (davidd)
    pCFI->_cf()._ccvTextColor.SetSysColor(COLOR_WINDOWTEXT);

    pCFI->_pf()._cuvTextIndent.SetPoints(0);

    pCFI->UnprepareForDebug();

    // Border stuff
    uvBorder.SetValue( 2, CUnitValue::UNIT_PIXELS );
    dwRawValue = uvBorder.GetRawValue();

    pCFI->PrepareFancyFormat();
    CColorValue ccv; ccv.SetSysColor(COLOR_WINDOW);
    CUnitValue cuv; cuv.SetRawValue(dwRawValue);
    for (i = 0; i < SIDE_MAX; i++)
    {
        pCFI->_ff()._bd.SetBorderColor(i, ccv);
        pCFI->_ff()._bd.SetBorderWidth(i, cuv);
        pCFI->_ff()._bd.SetBorderStyle(i, fmBorderStyleSunken);
    }
    pCFI->_ff()._bd._ccvBorderColorLight.SetSysColor(COLOR_3DLIGHT);
    pCFI->_ff()._bd._ccvBorderColorDark.SetSysColor(COLOR_3DDKSHADOW);
    pCFI->_ff()._bd._ccvBorderColorHilight.SetSysColor(COLOR_3DHIGHLIGHT);
    pCFI->_ff()._bd._ccvBorderColorShadow.SetSysColor(COLOR_3DSHADOW);
    pCFI->UnprepareForDebug();

    hr = THR(super::ApplyDefaultFormat(pCFI));

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::GetNaturalExtent
//
//  Synopsis:   Negotiate proposed size with the container
//
//  Note:       This method interacts with the resize trackers.
//              It provides integral-height resize feedback for the SELECT.
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::GetNaturalExtent(DWORD dwExtentMode, SIZEL *psizel)
{
    SIZE size;
    CDoc *  pDoc = Doc();

    if ( ! psizel )
        return E_FAIL;

    if ( _lFontHeight == 0 )
        return E_FAIL;

    pDoc->DeviceFromHimetric(size, *psizel);
    size.cy -= 6;   //  Adjust for borders
    size.cy -= size.cy % _lFontHeight;   //  Compute integralheight
    size.cy = max(size.cy, _lFontHeight);
    size.cy += 6;
    size.cx = max(size.cx, CX_SELECT_DEFAULT_PIXEL);
    pDoc->HimetricFromDevice(*psizel, size);

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectElement::get_selectedIndex
//
//  Synopsis:   SelectedIndex property
//
//  Note:       Single-select:  the selected entry's index or -1
//              Multiselect:    the first selected entry's index or -1
//
//--------------------------------------------------------------------------

HRESULT
CSelectElement::get_selectedIndex(long * plSelectedIndex)
{
    HRESULT hr = S_OK;

    if ( ! plSelectedIndex )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    BuildOptionsCache();

    if ( ! _fMultiple )
    {
        *plSelectedIndex = RelIdxFromAbs( _iCurSel );
    }
    else
    {
        long i;
        long cOptions = _aryOptions.Size();

        Assert(!_hwnd || SendSelectMessage(Select_GetCount, 0, 0) == cOptions);

        *plSelectedIndex = -1;  // if no selection found, selectedIndex will be -1
        for ( i = 0; i < cOptions; i++ )
        {
            if ( _aryOptions[i]->_fSELECTED )
            {
                *plSelectedIndex = RelIdxFromAbs( i );
                break;
            }
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectElement::put_selectedIndex
//
//  Synopsis:   SelectedIndex property
//
//--------------------------------------------------------------------------

HRESULT
CSelectElement::put_selectedIndex(long lRelSelectedIndex)
{
    LRESULT lr;
    HRESULT hr = S_OK;
    int i;
    int iOldSel = -1;
    BOOL    fFirePropertyChange = FALSE;
    long lSelectedIndex;

    BuildOptionsCache();

    lSelectedIndex = AbsIdxFromRel( lRelSelectedIndex );

    // this value is used to revert if the database was unable
    // to store the value.
    long iPrevSel = GetCurSel();

    if ( lSelectedIndex >= _aryOptions.Size() ||
         lSelectedIndex < -1 )
    {
        lSelectedIndex = -1;
    }

    if ( ! _fMultiple )
    {
        if ( _iCurSel != lSelectedIndex )
        {
            iOldSel = _iCurSel;
            lr = SetCurSel(lSelectedIndex, SETCURSEL_UPDATECOLL);
            if ( lr == LB_ERR && lSelectedIndex != LB_ERR )
            {
                _iCurSel = lSelectedIndex;
                //
                // NOTE (yinxie): we shouldn't let the window error
                // returned, because it is meaningless for the users
                // goto Win32Error;
            }

            fFirePropertyChange = TRUE;
        }
    }
    else
    {
        iOldSel = GetCurSel();
        lr = SetSel(-1, FALSE);
        if ( lr == LB_ERR )
            goto Win32Error;

        // when lSelectedIndex = -1, we should not select any item
        lr = SetSel(lSelectedIndex, (lSelectedIndex != -1));
        if ( lr == LB_ERR )
            goto Win32Error;

        for ( i = _aryOptions.Size() - 1; i >= 0; i-- )
        {
            if (!fFirePropertyChange && (i == lSelectedIndex) != _aryOptions[i]->_fSELECTED)
            {
                fFirePropertyChange = TRUE;
            }
            _aryOptions[i]->_fSELECTED = i == lSelectedIndex;
        }
    }

#ifndef NO_DATABINDING
    if (!OK(SaveDataIfChanged(ID_DBIND_DEFAULT)))
    {
        SetCurSel(iPrevSel, SETCURSEL_UPDATECOLL);
        fFirePropertyChange = FALSE;
    }
#endif

    if (fFirePropertyChange)
    {
        hr = THR(OnPropertyChange(DISPID_CSelectElement_selectedIndex, 
                                  0,
                                  (PROPERTYDESC *)&s_propdescCSelectElementselectedIndex));
        if (hr)
            goto Cleanup;
        if (HasValueChanged(iOldSel, GetCurSel()))
        {
            hr = THR(OnPropertyChange(DISPID_CSelectElement_value, 
                                      0,
                                      (PROPERTYDESC *)&s_propdescCSelectElementvalue));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));

Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     get_value
//
//  Synopsis:   collection object model, defers to Cache helper
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::get_value(BSTR * pbstrValue)
{
    HRESULT hr = S_OK;
    long i;
    long cOptions;
    COptionElement * pOption;

    if ( ! pbstrValue )
        return E_POINTER;

    *pbstrValue = NULL;

    BuildOptionsCache();

    if ( _aryOptions.Size() < 1 )
        goto Cleanup;

    if ( _fMultiple )
    {
        cOptions = _aryOptions.Size();
        Assert(!_hwnd || SendSelectMessage(Select_GetCount, 0, 0) == cOptions);

        for ( i = 0; i < cOptions; i++ )
        {
            if ( _aryOptions[i]->_fSELECTED )
                break;
        }

        if ( i >= cOptions )
        {
            i = -1;
        }

    }
    else
    {
        i = _iCurSel;
    }
    if ( i < 0 )
        goto Cleanup;

    pOption = _aryOptions[i];
    if ( ! pOption )
        goto Cleanup;

    hr = THR(pOption->get_PropertyHelper(pbstrValue, (PROPERTYDESC *)&s_propdescCOptionElementvalue));

Cleanup:
    TraceTag((tagSelectState, "SELECT::getValue returning %ls", *pbstrValue));
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     put_value
//
//  Synopsis:   collection object model, defers to Cache helper
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::put_value(BSTR bstrValue)
{
    HRESULT hr = S_OK;
    LRESULT lr;
    long i;
    long cOptions;
    LPCTSTR pstrOptionValue;
    BOOL fFirePropertyChange = TRUE;

    BuildOptionsCache();

    // this value is used to revert if the database was unable
    // to store the value.
    long iPrevSel = GetCurSel();

    if ( ! bstrValue )
    {
        i = -1L;
    }
    else
    {
        cOptions = _aryOptions.Size();

        for ( i = 0; i < cOptions; i++ )
        {
            pstrOptionValue = _aryOptions[i]->GetAAvalue();

            if ( pstrOptionValue )
            {
                if ( 0 == StrCmpC(pstrOptionValue, bstrValue) )
                {
                    break;
                }
            }
        }

        if ( i >= cOptions )
        {
            i = -1;
        }
    }

    if ( _fMultiple )
    {
        lr = SetSel(-1, FALSE);
        if ( lr == LB_ERR )
            goto Win32Error;

        if ( i > -1 )
        {
            lr = SetSel(i, TRUE);
            if ( lr == LB_ERR )
                goto Win32Error;
        }
    }
    else
    {
        SetCurSel(i, SETCURSEL_UPDATECOLL);
    }

#ifndef NO_DATABINDING
    if (!OK(SaveDataIfChanged(ID_DBIND_DEFAULT)))
    {
        SetCurSel(iPrevSel, SETCURSEL_UPDATECOLL);
        fFirePropertyChange = FALSE;
    }
#endif

    TraceTag((tagSelectState, "SELECT::putValue setting %ls", bstrValue));

    if (i != iPrevSel && fFirePropertyChange)
    {
        hr = THR(OnPropertyChange(DISPID_CSelectElement_value, 
                                  0,
                                  (PROPERTYDESC *)&s_propdescCSelectElementvalue));
        if (hr)
            goto Cleanup;
        // if the value changed, then the selected element changed too.
        hr = THR(OnPropertyChange(DISPID_CSelectElement_selectedIndex, 
                                  0,
                                  (PROPERTYDESC *)&s_propdescCSelectElementselectedIndex));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));

Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     item
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::item(VARIANTARG var1, VARIANTARG var2, IDispatch** ppResult)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->Item(SELECT_OPTION_COLLECTION,
                        var1,
                        var2,
                        ppResult));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     namedItem
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::namedItem(BSTR bstrName, IDispatch** ppResult)
{
    HRESULT hr;

    if (!bstrName || !*bstrName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    VARIANT var1, var2;

    var1.vt = VT_BSTR;
    var1.bstrVal = bstrName;

    var2.vt = VT_EMPTY;

    hr = THR(_pCollectionCache->Item(SELECT_OPTION_COLLECTION,
                        var1,
                        var2,
                        ppResult));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     tags
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the tag, and searched based on tagname
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::tags(VARIANT var1, IDispatch ** ppdisp)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->Tags(SELECT_OPTION_COLLECTION, var1, ppdisp));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     urns
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the urn, and searched based on urn
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::urns(VARIANT var1, IDispatch ** ppdisp)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->Urns(SELECT_OPTION_COLLECTION, var1, ppdisp));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     Get_newEnum
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->GetNewEnum(SELECT_OPTION_COLLECTION, ppEnum));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     Add
//
//  Synopsis:   Add item to collection...
//
//-------------------------------------------------------------------------
HRESULT
CSelectElement::add(IHTMLElement * pIElement, VARIANT varIndex)
{
    HRESULT             hr;
    CElement *          pElement;
    COptionElement *    pOption;
    IUnknown *          pUnk;
    long                lItemIndex;

    if (!pIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Make sure this is an <OPTION> element
    hr = THR(pIElement->QueryInterface(IID_IHTMLOptionElement, (void**)&pUnk));
    ReleaseInterface(pUnk);
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // get index
    hr = THR(VARIANTARGToIndex(&varIndex, &lItemIndex));
    if (hr)
        goto Cleanup;

    if (lItemIndex < -1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Verify(S_OK == THR(pIElement->QueryInterface(CLSID_CElement, (void **)&pElement)));

    // Bail out if the element is already in the tree - #25130
    // Also bail out if the element wasn't created in this document
    if (pElement->IsInMarkup() || pElement->Doc() != Doc())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pOption = (COptionElement *)pElement;
    hr = THR(AddOptionHelper(pOption, lItemIndex, pOption->_cstrText, FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectElement::GetLength
//
//  Synopsis:   Helper for number of OPTIONS (deals with OPTGROUP)
//
//--------------------------------------------------------------------------

long
CSelectElement::GetLength()
{
    long length = _aryOptions.Size();

    if (_fHasOptGroup)
    {
        for ( long i = 0; i < _aryOptions.Size(); i++ )
        {
            if ( _aryOptions[i]->_fIsOptGroup )
            {
                length--;
            }
        }
    }

    return length;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectElement::get_length
//
//  Synopsis:   length property: the number of entries
//
//--------------------------------------------------------------------------

HRESULT
CSelectElement::get_length(long * plLength)
{
    if ( ! plLength )
        RRETURN (SetErrorInfo(E_POINTER));

    BuildOptionsCache();

    *plLength = GetLength();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectElement::put_length
//
//  Synopsis:   Sets length (i.e. the number of entries). Truncates or
//              expands (by padding with dummy elements) the array as needed.
//
//--------------------------------------------------------------------------

HRESULT
CSelectElement::put_length(long lLengthNew)
{
    HRESULT             hr = S_OK;
    long                l, lLengthOld;
    CElement *          pElement = NULL;

    if (lLengthNew < 0)
    {
        hr =E_INVALIDARG;
        goto Cleanup;
    }

    BuildOptionsCache();

    lLengthOld = GetLength();
    Assert(!_hwnd || SendSelectMessage(Select_GetCount, 0, 0) == _aryOptions.Size());

    if (lLengthNew == lLengthOld)
        goto Cleanup;

    if (lLengthNew < lLengthOld)
    {
        // truncate the array
        for (l = lLengthOld-1; l >= lLengthNew; l--)
        {
            hr = THR(RemoveOptionHelper(l));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        // pad the array
        for (l = lLengthOld; l < lLengthNew; l++)
        {
            hr = THR(Doc()->CreateElement(ETAG_OPTION, &pElement));
            if (hr)
                goto Cleanup;

            // insert the dummy element
            hr = THR(AddOptionHelper((COptionElement *)pElement, l, NULL, TRUE));
            if (hr)
                goto Cleanup;

            CElement::ClearPtr(&pElement);
        }
    }
Cleanup:
    CElement::ClearPtr(&pElement);
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     remove
//
//  Synopsis:   remove the item in the collection at the given index
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::remove(long lItemIndex)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    if (lItemIndex < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(RemoveOptionHelper(lItemIndex));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//-------------------------------------------------------------------------
//
//  member : RemoveFromColelction
//
//  synopsis : this helper function is the callback from the colelctions
//      called
//-------------------------------------------------------------------------

HRESULT BUGCALL
CSelectElement::RemoveFromCollection(long lCollection, long lIndex)
{
    HRESULT hr;

    if (lCollection != SELECT_OPTION_COLLECTION)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(remove(lIndex));

Cleanup:
    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectElement::get_type
//
//  Synopsis:   type property
//
//  Note:       NetScape compatibility, distinguishes between single and multiselect
//
//--------------------------------------------------------------------------

HRESULT
CSelectElement::get_type(BSTR * pbstreType)
{
    HRESULT hr;

    if ( ! pbstreType )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    htmlSelectType eType;

    if ( _fMultiple )
    {
        eType = htmlSelectTypeSelectMultiple;
    }
    else
    {
        eType = htmlSelectTypeSelectOne;
    }

    hr = THR(STRINGFROMENUM ( htmlSelectType, (long)eType, pbstreType ));

Cleanup:
    RRETURN ( SetErrorInfo(hr) );
}


MtDefine(BldOptCol, PerfPigs, "Build CSelectElement::OPTIONS_COLLECTION")

//+------------------------------------------------------------------------
//
//  Collection cache items implementation for options collection
//
//-------------------------------------------------------------------------

class COptionsCollectionCacheItem : public CElementAryCacheItem
{
    typedef CElementAryCacheItem super;

protected:
    LONG _lCurrentIndex;
    CPtrAry <COptionElement*>* _paryOptions;
public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(BldOptCol))
    COptionsCollectionCacheItem(CPtrAry <COptionElement*>* paryOptions)
    {
        _paryOptions = (CPtrAry <COptionElement*>*)paryOptions;
    }

    CElement *GetNext (void);
    CElement *GetAt ( long lIndex );
    CElement *MoveTo ( long lIndex );
    long Length ( void );
};

//+------------------------------------------------------------------------
//
//  Options collection
//
//-------------------------------------------------------------------------
CElement *
COptionsCollectionCacheItem::GetNext ( void )
{
    return GetAt ( _lCurrentIndex++ );
}

CElement *
COptionsCollectionCacheItem::MoveTo ( long lIndex )
{
    _lCurrentIndex = lIndex;
    return GetAt(lIndex);
}

CElement *
COptionsCollectionCacheItem::GetAt ( long lIndex )
{
    if (lIndex < Length() && lIndex >= 0)
    {
        CSelectElement * pSelect = (*_paryOptions)[0]->GetParentSelect();
        Assert(pSelect->AbsIdxFromRel(lIndex) != -1);
        Assert(pSelect->AbsIdxFromRel(lIndex) < _paryOptions->Size());
        return (*_paryOptions)[pSelect->AbsIdxFromRel( lIndex )];
    }
    return NULL;
}

long 
COptionsCollectionCacheItem::Length ( void )
{
    if ( _paryOptions->Size() > 0 )
    {
        CSelectElement * pSelect = (*_paryOptions)[0]->GetParentSelect();
        return pSelect->GetLength();
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::get_options
//
//  Synopsis:   Returns the IDispatch of the Options collection
//
//----------------------------------------------------------------------------

HRESULT
CSelectElement::get_options(IDispatch ** ppElemCol)
{
    HRESULT hr;

    if (!ppElemCol)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppElemCol = NULL;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(QueryInterface(IID_IDispatch, (void**)
                ppElemCol));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::EensureOptionCollection
//
//  Synopsis:   makes sure that _pCollectionCache has a cache
//
//----------------------------------------------------------------------------

HRESULT
CSelectElement::EnsureCollectionCache()
{
    HRESULT hr = S_OK;

    if (!_pCollectionCache)
    {
        _pCollectionCache =
            new CCollectionCache(
                this,
                GetWindowedMarkupContext(),
                ENSURE_METHOD(CSelectElement, EnsureOptionCollection, ensureoptioncollection),
                NULL,
                REMOVEOBJECT_METHOD(CSelectElement, RemoveFromCollection, removefromcollection),
                ADDNEWOBJECT_METHOD(CSelectElement, AddNewOption, addnewoption) );

        if (!_pCollectionCache)
            goto MemoryError;

        hr = THR(_pCollectionCache->InitReservedCacheItems(NUMBER_OF_SELECT_COLLECTIONS,
                                                           NUMBER_OF_SELECT_COLLECTIONS));
        if (hr)
        {
            delete _pCollectionCache;
            _pCollectionCache = NULL;
            goto Cleanup;
        }

        COptionsCollectionCacheItem *pOptionsCollection = new COptionsCollectionCacheItem(&_aryOptions);
        if ( !pOptionsCollection )
            goto MemoryError;

        hr = THR(_pCollectionCache->InitCacheItem ( 0, pOptionsCollection ));
        if (hr)
            goto Cleanup;

        // Turn off default name promotion on the SELECT -> Options collection
        // Nav doesn't support this.
        _pCollectionCache->DontPromoteNames(SELECT_OPTION_COLLECTION);

        // and turn on: options[n]=NULL
        _pCollectionCache->SetCollectionSetableNULL(SELECT_OPTION_COLLECTION,
                                                    TRUE);
    }
    hr = THR(_pCollectionCache->EnsureAry(SELECT_OPTION_COLLECTION));

Cleanup:
    RRETURN(SetErrorInfo(hr));

MemoryError:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::EnsureOptionCollection
//
//  Synopsis:   populates the Options collection with Option elements
//              when it is invoked for the first time.
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CSelectElement::EnsureOptionCollection(long lIndex, long * plCookie)
{
    HRESULT hr = S_OK;

    BuildOptionsCache();

    Assert(plCookie);

    if (*plCookie != _lCollectionLastValid)
    {
        long    cOptions;
        long    lIndex;

        MtAdd(Mt(BldOptionsCol), +1, 0);

        cOptions = _aryOptions.Size();

        _pCollectionCache->ResetAry(SELECT_OPTION_COLLECTION);

        for ( lIndex = 0; lIndex < cOptions; lIndex++ )
        {
            if ( ! _aryOptions[lIndex]->_fIsOptGroup )
            {
                hr = _pCollectionCache->SetIntoAry(SELECT_OPTION_COLLECTION, _aryOptions[lIndex] );
                if ( hr )
                    goto Cleanup;
            }
        }

        *plCookie = _lCollectionLastValid;
    }

Cleanup:
    RRETURN(hr);
}

#ifdef WIN16
#pragma code_seg( "ESELECT_2_TEXT" )
#endif // WIN16

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::RemoveOptionHelper
//
//  Synopsis:   Helper to remove <OPTION> element
//
//  Arguments:  lIndex:         the index of the element
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::RemoveOptionHelper(long lRelIndex)
{
    HRESULT             hr = S_OK;
    long                cOptions;
    long                lIndex;
    COptionElement *    pOption;
    BOOL                fOldLayoutRequestsEnabled = _fEnableLayoutRequests;
    BOOL                fFirePropertyChangeSelIndex = FALSE;
    BOOL                fFirePropertyChangeValue = FALSE;
    LPCTSTR             pstrOldOptionValue;
    BOOL                fDeferUpdateCurSel = FALSE;

    BuildOptionsCache();

    lIndex = AbsIdxFromRel( lRelIndex );
    
    if ( lIndex < 0 )
        goto Cleanup;
    
    cOptions = _aryOptions.Size();
    Assert( !_hwnd || (SendSelectMessage(Select_GetCount, 0, 0) == cOptions) );

    _fEnableLayoutRequests = FALSE;

    if ( lIndex >= cOptions )
        goto Cleanup;

    pOption = _aryOptions[lIndex];
    // We don't care what the value is, only if it exists.
    pstrOldOptionValue = pOption->GetAAvalue();

#if DBG == 1
    CElement *          pOptionCached;

    hr = THR(_pCollectionCache->GetIntoAry(0, lRelIndex, &pOptionCached));
    if (!hr)
    {
        Assert(pOption == pOptionCached);
    }
#endif

    if (GetCurSel() >= lIndex && !_fMultiple)
    {
        fFirePropertyChangeSelIndex = TRUE;

        if ( _iCurSel == lIndex )
        {
            // Here's where we see if the option had a value.
            fFirePropertyChangeValue = !(NULL == pstrOldOptionValue);
            fDeferUpdateCurSel = TRUE;
        }
        else
        {
            --_iCurSel;
            // We do not have to update any _fSELCTEDs here. The 
            // bit on the options does not change, just the options
            // index in the collection
        }
    }

    {
        CMarkupPointer p1( Doc() ), p2( Doc() );

        hr = THR( p1.MoveAdjacentToElement( pOption, ELEM_ADJ_BeforeBegin ) );

        if (hr)
            goto Cleanup;

        hr = THR( p2.MoveAdjacentToElement( pOption, ELEM_ADJ_AfterEnd ) );

        if (hr)
            goto Cleanup;

        hr = THR( pOption->Doc()->Remove( & p1, & p2 ) );

        if (hr)
            goto Cleanup;
    }

    InvalidateCollection();

    if ( _hwnd )
    {
        if (LB_ERR == SendSelectMessage(Select_DeleteString, lIndex, 0))
            goto Win32Error;
    }

    _aryOptions.Delete(lIndex);

    if ( pOption == _poptLongestText )
    {
        _poptLongestText = NULL;
        ResizeElement();
    }

    Assert(cOptions == _aryOptions.Size() + 1);

    if (fDeferUpdateCurSel)
    {
        SetCurSel(-1);
    }

    if (fFirePropertyChangeSelIndex)
    {
        hr = THR(OnPropertyChange(DISPID_CSelectElement_selectedIndex, 
                                  0,
                                  (PROPERTYDESC *)&s_propdescCSelectElementselectedIndex));
        if (hr)
            goto Cleanup;
        
        if (fFirePropertyChangeValue)
        {
            hr = THR(OnPropertyChange(DISPID_CSelectElement_value, 
                                      0,
                                      (PROPERTYDESC *)&s_propdescCSelectElementvalue));
            if (hr)
                goto Cleanup;
        }
   }

    Assert(_fMultiple || GetCurSel() == _iCurSel);

Cleanup:
    _fEnableLayoutRequests = fOldLayoutRequestsEnabled;
    RRETURN(hr);

Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::AddOptionHelper
//
//  Synopsis:   Adds an <OPTION> element
//
//  Arguments:  pOption:        the element to add
//              lIndex:         the index where the element should be added
//              pchText:        the text of the element
//              fDummy:         is this a dummy option use to pad out the list?
//
//  Note:       pchText is really redundant, since it can be obtained from
//              pOption. However, it lets us avoid the call to get_text()
//              if we alreday know the result as in the case of dummy
//              elements.
//-------------------------------------------------------------------------

HRESULT
CSelectElement::AddOptionHelper(COptionElement *    pOption,
                                long                lRelIndex,
                                const TCHAR *       pchText,
                                BOOL                fDummy)
{
    HRESULT         hr = S_OK;
    long            cOptions;
    long            lIndex;
    long            lControlIndex;
    CElement *      pPrevOption;
    CMarkupPointer  pointerInsert( Doc() );
    BOOL            fOldLayoutRequestsEnabled = _fEnableLayoutRequests;

    hr = THR(EnsureInMarkup());
    if (hr)
        goto Cleanup;

    // Make sure the OPTION being inserted is not already present in some tree (#41607)
    if (!pOption || pOption->IsInMarkup() || pOption->Doc() != Doc())
        return E_INVALIDARG;

    BuildOptionsCache();

    lIndex = AbsIdxFromRel( lRelIndex );

    cOptions = _aryOptions.Size();
    Assert( !_hwnd || (SendSelectMessage(Select_GetCount, 0, 0) == cOptions));

    if (!pchText)
        pchText = g_Zero.ach;

    _fEnableLayoutRequests = FALSE;

    if ( lIndex == -1 || lIndex >= cOptions) // append
    {
        lControlIndex = cOptions - 1;
    }
    else
    {
        lControlIndex = lIndex - 1;
    }

    if ( lControlIndex >= 0 )
    {
        Assert(lControlIndex < cOptions);
        Assert(cOptions > 0);

        pPrevOption = _aryOptions[lControlIndex];

        hr = THR( pointerInsert.MoveAdjacentToElement(pPrevOption, (ETAG_OPTGROUP == pPrevOption->Tag()) ? ELEM_ADJ_AfterBegin : ELEM_ADJ_AfterEnd));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR( pointerInsert.MoveAdjacentToElement( this, ELEM_ADJ_AfterBegin ) );
        if (hr)
            goto Cleanup;
    }

    //  Do the actual insertion here

        //  This will hopefully kick off the tree notification, which in turn
        //  will trigger the SELECT's new walking code to update the UI
        //  and the object model.

    hr = THR( Doc()->InsertElement( pOption, & pointerInsert, NULL ) );

    if (hr)
        goto Cleanup;

    hr = THR( pointerInsert.MoveAdjacentToElement( pOption, ELEM_ADJ_AfterBegin ) );

    if (hr)
        goto Cleanup;

    hr = THR( Doc()->InsertText( & pointerInsert, pchText, -1 ) );

    if (hr)
        goto Cleanup;
    
#ifndef NO_DATABINDING
    if (!fDummy && !_fMultiple && _iCurSel < 0)
    {
        DBMEMBERS *pdbm = GetDBMembers();

        // if we are bound and no option is currently selected, we check if
        //  the new option matches the bound value.
        if (pdbm && pdbm->FBoundID(this, ID_DBIND_DEFAULT))
        {
            BSTR bstrBound = NULL;

            if (!pdbm->ValueFromSrc(this, ID_DBIND_DEFAULT, &bstrBound))
            {
                BOOL fMatch = !FormsStringCmp(bstrBound, pOption->GetAAvalue());

                // instead of ourselves stuffing the value we just
                //  fetched, we call TransferFromSrc; this takes care
                //  of all the re-entrancy issues for us.
                SysFreeString(bstrBound);
                if (fMatch)
                {
                    IGNORE_HR(pdbm->TransferFromSrc(this, ID_DBIND_DEFAULT));
                }
            }
        }
    }
#endif // ndef NO_DATABINDING

///// Some of the old code revived to handle the insertion synchronously

    if ( lIndex == -1 || lIndex >= cOptions) // append
    {
        hr = THR(_aryOptions.Append(pOption));
        if ( hr )
            goto Cleanup;

        if ( _hwnd )
        {
            lControlIndex = SendSelectMessage(Select_AddString, 0, (LPARAM)pchText);
            if ( lControlIndex == LB_ERR )
                goto Win32Error;

            Assert(lControlIndex == _aryOptions.Size() - 1);
        }
    }
    else // insert
    {
        hr = THR(_aryOptions.Insert(lIndex, pOption));
        if ( hr )
            goto Cleanup;

        if ( _hwnd )
        {
            lControlIndex = SendSelectMessage(Select_InsertString, lIndex, (LPARAM)pchText);
            if ( lControlIndex == LB_ERR )
                goto Win32Error;

            Assert(lControlIndex == lIndex);
        }
    }

    InvalidateCollection();

    pOption->_fInCollection = TRUE;

    DeferUpdateWidth();

    if ( pOption->_fSELECTED )
    {
        if ( ! _fMultiple )
        {
            SetCurSel(lControlIndex, TRUE);
        }
        else
        {
            SetSel(lControlIndex, TRUE);
        }
    }

    Assert(cOptions == _aryOptions.Size() - 1);

Cleanup:
    _fEnableLayoutRequests = fOldLayoutRequestsEnabled;
    RRETURN(hr);

Win32Error:
    hr = GetLastWin32Error();
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Method:     CSelectElement::SendSelectMessage
//
//  Synopsis:   Sends messages to the hwnd of the select control
//              mapping the abstract messages to the correct LB_*
//              or CB_* Windows messages
//
//  Arguments:  msg:    the abstract message (enumerated type)
//              wParam  pretty obvious I think
//              lParam
//
//----------------------------------------------------------------------------

LRESULT
CSelectElement::SendSelectMessage(WindowMessages msg,
                                  WPARAM wParam,
                                  LPARAM lParam)
{
    Assert(_hwnd);

#ifndef WIN16
    // subclassed from the unicode enabled control on win95, so we don't want the unicode wrapper
    // to convert any unicode to mbcs!
    return ::SendMessageA(_hwnd, SelectMessage(msg), wParam, lParam);
#else

    return ::SendMessage(_hwnd, SelectMessage(msg), wParam, lParam);
#endif
}


//+---------------------------------------------------------------------------
//
//  Method:     CSelectElement::HandleMessage
//
//  Synopsis:   Window message handler. This same method handles
//              WM_xxx messages and TranslateAccelerator calls,
//              distinction is made based on the CMessage::fPreDispatch bit.
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CSelectElement::HandleMessage(CMessage * pMessage)
{
    HRESULT hr = S_FALSE;

    if (!CanHandleMessage())
        goto Cleanup;


    if ( pMessage->message >= WM_KEYFIRST &&
         pMessage->message <= WM_KEYLAST )
    {
        hr = THR(FireStdEventOnMessage(GetFirstBranch(), pMessage));
        if (S_FALSE != hr)
            goto Cleanup;

        if ( pMessage->message == WM_KEYDOWN  )
        {
            if ( _hwndDropList &&
                 pMessage->wParam == VK_LEFT ||
                 pMessage->wParam == VK_RIGHT )
            {
                hr = S_OK;
                goto Cleanup;
            }

            if (    (pMessage->wParam == VK_F4 || (_hwndDropList && pMessage->wParam == VK_RETURN))
                &&  !(pMessage->dwKeyState & (FSHIFT | FCONTROL | FALT)))
            {
                ::SendMessage(_hwnd, pMessage->message, pMessage->wParam, pMessage->lParam);

                hr = S_OK;
                goto Cleanup;
            }
        }

        if ( _fFocus && 
                        (pMessage->message == WM_KEYDOWN ||
                         pMessage->message == WM_KEYUP ) &&
                         (pMessage->wParam == VK_UP    ||
                          pMessage->wParam == VK_DOWN  ||
                          pMessage->wParam == VK_PRIOR ||
                          pMessage->wParam == VK_NEXT  ||
                          pMessage->wParam == VK_HOME  ||
                          pMessage->wParam == VK_F4    ||
                          pMessage->wParam == VK_END   ||
                          pMessage->wParam == VK_SPACE  ) )
        {
            long lDelta = 0;
            if ( !_fHasOptGroup || !HandleKeyForOptGroup(pMessage->wParam, &lDelta))
            {
                ::SendMessage(_hwnd, pMessage->message, pMessage->wParam, pMessage->lParam);

                if ( _fMultiple && lDelta )
                {
                    for (int i = 0; i < abs(lDelta); i++)
                    {
                        ::SendMessage(_hwnd, pMessage->message, 
                                      (WPARAM)(lDelta < 0 ? VK_UP : VK_DOWN), pMessage->lParam);
                    }
                }
            }

            hr = S_OK;
            goto Cleanup;
        }
    }

    switch (pMessage->message)
    {
    case WM_CONTEXTMENU:
        // no context menu popup for listbox/dropdown when in browse mode,
        // popup control context menu when in author mode.
        //
        if (IsEditable(TRUE))
        {
            hr = THR(OnContextMenu(
                    (short)LOWORD(pMessage->lParam),
                    (short)HIWORD(pMessage->lParam),
                    CONTEXT_MENU_CONTROL));
        }
        else
        {
            hr = S_OK;
        }
        break;

    case WM_SETFOCUS:
        // The document received a WM_SETFOCUS message and is forwarding it to us.
        // The select should be the current site.  Set focus to the select's window.

        Assert(this == Doc()->_pElemCurrent);
        if (_hwnd && _hwnd != ::GetFocus())
        {
            //  Lock any focus firing. BecomeCurrent has already done all that.

            CLock Lock(this, ELEMENTLOCK_FOCUS);
            ::SetFocus(_hwnd);
        }
        break;
    }

    if (hr == S_FALSE)
        hr = THR(super::HandleMessage(pMessage));

Cleanup:
    RRETURN1(hr, S_FALSE);
}


HRESULT
CSelectElement::ClickAction(CMessage * pMessage)
{
    if ( pMessage )
        goto Cleanup;

    if ( _aryOptions.Size() > 0 )
    {
        if ( _fMultiple )
        {
            int i;

            for ( i = _aryOptions.Size() - 1; i >= 0; i-- )
            {
                _aryOptions[i]->_fSELECTED = FALSE;
            }
            SetSel(-1, FALSE);

            _aryOptions[0]->_fSELECTED = TRUE;
            SetSel(0, TRUE);
        }
        else
        {
            SetCurSel(0, SETCURSEL_UPDATECOLL);
        }
    }

Cleanup:
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CSelectElement::HandleMouseEvents
//
//  Synopsis:   Window message handler for mouse messages.
//
//  Note:       This handler is shared by the normal WndProc of
//              the SELECT (be it listbox or combobox) and
//              the dynamic subclassing WndProc of the
//              dropdown window of the combobox.
//              This ensures correct event firing for mouse events
//              happening in the dropdown window of the combobox.
//
//----------------------------------------------------------------------------

BOOL
CSelectElement::HandleMouseEvents(HWND hWnd,
                                  UINT msg,
                                  WPARAM wParam,
                                  LPARAM lParam,
                                  BOOL fFromDropDown /*=FALSE*/)
{
    POINT   pt;
    POINT   ptDoc;
    BOOL    fRet = FALSE;
    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();
    BOOL    fFirePropertyChange = FALSE;
    BOOL    fValueChanged = FALSE;

    Assert(pDoc);

    pt.x = (short)LOWORD(lParam);
    pt.y = (short)HIWORD(lParam);

    ptDoc = pt;

    if (pDoc->State() >= OS_INPLACE)
    {
        MapWindowPoints(hWnd, pDoc->_pInPlace->_hwnd, &ptDoc, 1);

        CMessage Message(hWnd, msg, wParam, MAKELPARAM(ptDoc.x, ptDoc.y));    //  Create the Message
        Message.pt = ptDoc;
        hr = THR( Message.SetNodeHit( GetFirstBranch() ) );
        if( hr )
            goto Cleanup;

        LRESULT lResult = NULL; // for calls to CDoc::OnWindowMessage, we don't use it for anything
        BOOL fMouseOverOptGroup = FALSE;

        if ( _fHasOptGroup && !_fMultiple && ( _fListbox || (hWnd == _hwndDropList) ))
        {        
            long lMouseIndex = ::SendMessageA(hWnd, LB_ITEMFROMPOINT, 0, MAKELPARAM(pt.x, pt.y));

            if ( (HIWORD(lMouseIndex) == 0) || _fLButtonHold )
            {
                COptionElement * pOption = _aryOptions[LOWORD(lMouseIndex)]; Assert(pOption);

                if ( pOption->_fIsOptGroup )
                {
                    fMouseOverOptGroup = TRUE;
                }
                
                if (msg == WM_LBUTTONDOWN)
                {
                    _fLButtonHold = TRUE;
                }

                /*
                if ( _fLButtonHold && (msg != WM_LBUTTONUP) )
                {
                    RECT comboRect;
                    GetClientRect( hWnd , &comboRect );

                    if ( (pt.y <= comboRect.top + 1) || (pt.y >= comboRect.bottom - 2) )
                    {
                        // Scroll

                        long lCurIndex = LOWORD(lMouseIndex);
                        long iNewSel   = - 1;

                        if ( (pt.y <= comboRect.top + 1) && (lCurIndex > 0) )
                        {                            
                            //Scroll up
                         
                            iNewSel = lCurIndex - 1;

                            if ( _aryOptions[iNewSel]->_fIsOptGroup )
                            {
                                iNewSel = GetNearestOption(iNewSel, TRUE);
                            }                            
                        }
                        else if ( (pt.y >= comboRect.bottom - 2) && (lCurIndex < _aryOptions.Size() - 1))
                        {
                            //Scroll down
                         
                            iNewSel = lCurIndex + 1;

                            if ( _aryOptions[iNewSel]->_fIsOptGroup )
                            {
                                iNewSel = GetNearestOption(iNewSel, FALSE);
                            }                            
                        }

                        if ( iNewSel != -1 )                                
                        {
                            SetCurSel(iNewSel, SETCURSEL_UPDATECOLL);
                        }

                        // Don't let the control process scrolling
                        return TRUE;
                    }
                }
*/
            }
        }

        switch ( msg )
        {
        case WM_LBUTTONDOWN:
            _fLButtonDown = TRUE;
            pDoc->_fCanFireDblClick = TRUE;
            //  falls through
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:

            if (_fSendMouseMessagesToDocument)
                _fSendMouseMessagesToDocument = FALSE;

            hr = THR(FireStdEventOnMessage(GetFirstBranch(), &Message));
            if (S_FALSE != hr || fMouseOverOptGroup)
                return TRUE;

        // NOTE - Should the select become current on all buttons
        // or just lbuttondown? right now, right now we do it with all

        // if the message came from the doc's hwnd the set currentcy
        // if it came from ours, then by defn, we are already current on the doc
        if (_hwndDropList != hWnd)
        {
            WHEN_DBG(CLayout *pLayout =)
                              GetUpdatedLayout( GUL_USEFIRSTLAYOUT );
            Assert(pLayout);
            
            if (!IsEditable(TRUE) && !IsMasterParentEditable() )
            {
                hr = THR_NOTRACE(BecomeCurrent(0));
                if (S_OK != hr)
                    return TRUE;
            }
            else if (pDoc->_pElemCurrent != this)
            {
                LONG lButton = 0;

                switch( msg )
                {
                    case WM_LBUTTONDOWN:
                    lButton = 1;
                    break;

                    case WM_RBUTTONDOWN:
                    lButton = 2;
                    break;

                    case WM_MBUTTONDOWN:
                    lButton = 4;
                    break;
                }

                _fSendMouseMessagesToDocument = TRUE;

                hr = THR(pDoc->OnWindowMessage(msg, wParam, 
                    MAKELPARAM(Message.pt.x, Message.pt.y),  &lResult));

                return TRUE;
            }
        }
        break;

        //  Don't bail out from here even if user code cancels the event.
        //  That would prevent the listbox control from seeing the mouseUp
        //  and releasing mouse capture. That would be BAD.
        case WM_LBUTTONUP:

            _fLButtonHold  = FALSE;

            //  The combo seems to get an implicit WM_LBUTTONUP
            //  when the doprdown box is destroyed by an action in
            //  a different window.

            if (_fSendMouseMessagesToDocument)
            {
                hr = THR(pDoc->OnWindowMessage(msg, wParam, 
                    MAKELPARAM(Message.pt.x, Message.pt.y),  &lResult));

                _fSendMouseMessagesToDocument = FALSE;
                
                return TRUE;
            }

            if ( lParam == 0xFFFFFFFF )
                break;

            hr = THR(FireStdEventOnMessage(GetFirstBranch(), &Message));
            if ( S_FALSE != hr || fMouseOverOptGroup )
            {
                _fLButtonDown = FALSE;

                if ( fMouseOverOptGroup )
                {
                    int iCurSel = SendSelectMessage(Select_GetCurSel, 0, 0);

                    Assert( !_fMultiple );
                    // If we ended up on an OptGroup because of scrolling
                    // set the old selection back
                    if ( (iCurSel == -1) ||
                        ((iCurSel != -1) && _aryOptions[iCurSel]->_fIsOptGroup ) )
                    {
                        SetCurSel(_iCurSel, SETCURSEL_UPDATECOLL);
                    }
                }
                break;
            }

            if ( _fLButtonDown  )
            {
                int     iCurSel;
                int     iOldSel = _iCurSel;
                BOOL    fSelectionChanged = FALSE;

                _fLButtonDown = FALSE;
                hr = THR(BecomeUIActive());
                if ( hr )
                    break;

                Message.fEventsFired = FALSE;

                iCurSel = SendSelectMessage(Select_GetCurSel, 0, 0);

                if (iCurSel != _iCurSel)
                    fSelectionChanged = TRUE;

                if (_fListbox && !_fMultiple && fSelectionChanged)
                {
                    SetCurSel(iCurSel, SETCURSEL_UPDATECOLL);
                    fFirePropertyChange = TRUE;
                    fValueChanged = HasValueChanged(iOldSel, GetCurSel());
                    Fire_onchange_guarded();
#ifndef NO_DATABINDING
                    IGNORE_HR(SaveDataIfChanged(ID_DBIND_DEFAULT));
#endif
                }

                if (_fListbox || !fSelectionChanged)
                {
                    hr = Fire_onclick() ? S_FALSE : S_OK;

                    if (S_FALSE != hr)
                        break;
                }
                else
                {
                    _fDeferFiringOnClick = TRUE;
                }
            }

            if ( pDoc->_fGotDblClk )
            {
                EVENTINFO clkEvtInfo;

                Message.fEventsFired = FALSE;

                hr = Fire_ondblclick(NULL, -1, &clkEvtInfo ) ? S_FALSE : S_OK;
                pDoc->_fGotDblClk = FALSE;

                Message.fSelectionHMCalled = FALSE;
                if ( clkEvtInfo._pParam )
                {
                    IGNORE_HR( pDoc->HandleSelectionMessage(&Message, FALSE, &clkEvtInfo, HM_Post ));
                }

                if (S_FALSE != hr)
                    break;
            }
            break;

        case WM_MBUTTONUP:
        case WM_RBUTTONUP:

            if (_fSendMouseMessagesToDocument)
            {
                hr = THR(pDoc->OnWindowMessage(msg, wParam, 
                    MAKELPARAM(Message.pt.x, Message.pt.y),  &lResult));

                _fSendMouseMessagesToDocument = FALSE;

                return TRUE;
            }
            // Follow through with event firing

        case WM_LBUTTONDBLCLK:
        case WM_RBUTTONDBLCLK:
        case WM_MBUTTONDBLCLK:

            hr = THR(FireStdEventOnMessage(GetFirstBranch(), &Message));
            if (S_FALSE != hr || fMouseOverOptGroup)
                return TRUE;

            break;

        case WM_MOUSEWHEEL:
            hr = THR(FireStdEventOnMessage(GetFirstBranch(), &Message));
            if (S_FALSE != hr)
                return TRUE;

            if ( _fHasOptGroup && !_fListbox && (hWnd != _hwndDropList) )
            {
                BOOL keyHandled = FALSE;
                long iNewSel = -1;

                if (GET_WHEEL_DELTA_WPARAM(wParam) > 0)
                {
                    // equivalent with key-up
                    if (_iCurSel > 0 && _aryOptions[_iCurSel - 1]->_fIsOptGroup)
                    {
                        keyHandled = TRUE;
                        iNewSel = GetNearestOption(_iCurSel - 1, TRUE);
                    }
                }
                else
                {
                    // equivalent with key-down
                    if (_iCurSel < _aryOptions.Size() - 1 && _aryOptions[_iCurSel + 1]->_fIsOptGroup)
                    {
                        keyHandled = TRUE;
                        iNewSel = GetNearestOption(_iCurSel + 1, FALSE);
                    }
                }

                if ( keyHandled )
                {
                    if ( iNewSel != -1 )
                    {
                        SetCurSel(iNewSel, SETCURSEL_UPDATECOLL);
                    }
                    return TRUE;
                }
            }
            break;

        case WM_MOUSEMOVE:
            // We always send mousemove messages to the document so 
            // the onmouseover event will get fired for the element. 
            // EXCEPT when this message is coming from the dropdown 
            // message proc, then we let windows do its thing.
            if (!fFromDropDown)
            {
                hr = THR(pDoc->OnWindowMessage(msg, wParam, 
                    MAKELPARAM(Message.pt.x, Message.pt.y),  &lResult));

                if (hr)
                    return TRUE;
            }

            // Fall through

        default:
            if (fMouseOverOptGroup)
                return TRUE;
        }
        //  Fire events
    }

    if (fFirePropertyChange)
    {
        THR(OnPropertyChange(DISPID_CSelectElement_selectedIndex, 
                             0,
                             (PROPERTYDESC *)&s_propdescCSelectElementselectedIndex));

        // If selectedIndex changed, then maybe the value changed too
        if (fValueChanged)
        {
            THR(OnPropertyChange(DISPID_CSelectElement_value, 
                                 0,
                                 (PROPERTYDESC *)&s_propdescCSelectElementvalue));
        }
    }

Cleanup:
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   DropListWndProc
//
//  Synopsis:   Dynamically installed subclassed wndproc for the
//              dropdown window of the combobox
//
//----------------------------------------------------------------------------

LRESULT CALLBACK
DropListWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CSelectElement * pSelect = (CSelectElement *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    return pSelect->DropWndProc(hWnd, msg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::DropWndProc
//
//  Synopsis:   Handler for the dropdown window's subclassing WndProc
//              (see above).
//
//  Arguments:  [hWnd]   -- HWND of calling window
//              [msg]    -- msg parameter from calling WNDPROC
//              [wParam] -- wParam parameter from calling WNDPROC
//              [lParam] -- lParam parameter from calling WNDPROC
//
//----------------------------------------------------------------------------

LRESULT CALLBACK
CSelectElement::DropWndProc(
        HWND hWnd,
        UINT msg,
        WPARAM wParam,
        LPARAM lParam)
{
    BOOL fProcessed = FALSE;

    //  User event code may pop up the dropdown list, thereby
    //  NULL-ing the stored original WndProc.
    WNDPROC wndProcTmp = s_pfnDropListWndProc;

    if ( msg >= WM_MOUSEFIRST &&
         msg <= WM_MOUSELAST )
    {
        fProcessed = HandleMouseEvents(hWnd, msg, wParam, lParam, TRUE);
    }

    if ( fProcessed )
    {
        return TRUE;
    }

    if ( WM_NCDESTROY == msg && s_pfnDropListWndProc && _hwndDropList )
    {
        //  Unhook subclassing
        SetWindowLongPtr(_hwndDropList, GWLP_WNDPROC, (LONG_PTR)s_pfnDropListWndProc);
        s_pfnDropListWndProc = NULL;
        SetWindowLongPtr(_hwndDropList, GWLP_USERDATA, 0);
        _hwndDropList = NULL;
    }

    return CallWindowProc(wndProcTmp, hWnd, msg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
//  Function:   SelectElementWndProc
//
//  Synopsis:   subclassed wndproc for the HTML SELECT control
//
//              Stolen from the '95 wrapped controls
//
//  Arguments:  [hWnd]   -- hWnd of List Box
//              [msg]    -- message to process
//              [wParam] -- Message's wParam
//              [lParam] -- Message's lParam
//
//  Returns:    Appropriate data depending on message
//
//  Notes:      CONSIDER - this func currently fires events BEFORE calling
//              the button wnd proc.  Should it call first, then
//              fire the event?
//
//----------------------------------------------------------------------------

LRESULT CALLBACK
SelectElementWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CSelectElement * pSelect = (CSelectElement *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    TraceTag((tagSelectWndProc, "msg %d for SEL %d  hwnd %x",
                    msg, (pSelect? pSelect->SN(): 0), hWnd));

    if (!pSelect)
    {
        Assert( msg == WM_NCCREATE );

        CREATESTRUCT *ps = (CREATESTRUCT*) lParam;
        pSelect = (CSelectElement *) ps->lpCreateParams;

        Assert( pSelect );

        SetWindowLongPtr( hWnd, GWLP_USERDATA, (LONG_PTR)pSelect );
        SetWindowLong( hWnd, GWL_ID, s_lIDSelect );

        InterlockedIncrement( & s_lIDSelect );

        pSelect->_rgnVisible.SetRectangle(0,0,ps->cx, ps->cy);

    }
    else if (msg == WM_WINDOWPOSCHANGING && pSelect->_fVisibleChanged)
    {
        pSelect->_fVisibleChanged = false;

        WINDOWPOS *pPos = (WINDOWPOS*)lParam;
        HRGN hrgn = pSelect->_rgnVisible.IsRectangle(0,0,pPos->cx, pPos->cy) ? 0
                  : pSelect->_rgnVisible.ConvertToWindows();

        pSelect->Doc()->GetView()->SetWindowRgn(hWnd, hrgn, !(pPos->flags & SWP_NOREDRAW));

        if (!pSelect->_rgnInvalidate.IsEmpty())
        {
#if DBG == 1
            if (IsTagEnabled(tagSelectInval))
            {
                TraceTag((tagSelectInval, "Inval SEL %d  hwnd %x (Pos/VisChange)",
                                            pSelect->SN(),  hWnd));
                DumpRegion(pSelect->_rgnInvalidate);
            }
#endif
            hrgn = pSelect->_rgnInvalidate.ConvertToWindows();
                   pSelect->_rgnInvalidate.SetEmpty();

            ::InvalidateRgn(hWnd, hrgn, 0);
            ::DeleteObject(hrgn);
        }
    }

#if DBG==1
    if (msg == WM_ERASEBKGND)
    {
        TraceTag((tagEraseBkgndStack, "SelectElementWndProc"));
        TraceCallers(tagEraseBkgndStack, 1, 16);
    }
#endif

    // if we get WM_PAINT while we've turned off repainting, remind
    // ourselves to force a paint when we've turned it back on
    if (msg == WM_PAINT && pSelect->_fNoRedraw)
    {
        pSelect->_fMissedPaint = TRUE;
    }

    return pSelect->WndProc( hWnd, msg, wParam, lParam );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::WndProc
//              stolen from CWrappedControl::WrappedCtrlWinProc
//
//  Synopsis:   Handler for messages sent to the sub-classed controls.
//
//  Arguments:  [hWnd]   -- HWND of calling window
//              [msg]    -- msg parameter from calling WNDPROC
//              [wParam] -- wParam parameter from calling WNDPROC
//              [lParam] -- lParam parameter from calling WNDPROC
//
//  History:    20-Apr-94   SumitC      Created
//              23-Apr-94   SumitC      Add MousePointer, WM_MOUSEACTIVATE
//              17-May-94   SumitC      Rbutton context menu
//              24-May-94   SumitC      common Key* and Mouse* events
//              23-Jul-96   LaszloG     revived and applied to the SELECT element
//
//  Notes:      This is used for handling common control functionality, such
//              as firing standard events, and handling standard properties.
//
//              LaszloG:    There's a slight weirdness as this windproc needs
//                          subclass two different Windows WndProcs:
//                          the listbox and the combo
//
//              Important:  This method should NOT be virtual or else it
//                          will blow up in WM_NCCREATE (this would be NULL then).
//
//----------------------------------------------------------------------------

LRESULT CALLBACK
CSelectElement::WndProc(
        HWND hWnd,
        UINT msg,
        WPARAM wParam,
        LPARAM lParam)
{
    HRESULT hr;
    BOOL fProcessed;
    LRESULT lr;
    BOOL    fFirePropertyChange = FALSE;
    BOOL    fValueChanged = FALSE;
    int     iOldSel = -1;

    if ( ! IsConnectedToPrimaryMarkup() )
        goto DefWindowProc;

    if (IsParentFrozen())
    {                       
        if ((msg >= WM_MOUSEFIRST &&
            msg <= WM_MOUSELAST) ||
         // msg == WM_SETCURSOR  ||     // BUGFIX:18794 (chandras), we shouldn't be doing WM_SETCURSOR handling here, 
                                        // WM_SETCURSOR LPARAM is not a point, but id of message and hittest code
            msg == WM_CONTEXTMENU)
        {                                
            CDoc *      pDoc = Doc();
            POINT       pt;
            LRESULT     lresult;
            BOOL        fNeedConversion;

            pt.x = (short)LOWORD(lParam);
            pt.y = (short)HIWORD(lParam);

            if (WM_LBUTTONDOWN == msg)
            {
                pDoc->_fCanFireDblClick = TRUE;
            }

            // check for keyboard generated context menu generated           
            fNeedConversion = (msg != WM_CONTEXTMENU) || (pt.x != -1) || (pt.y != -1);                        

            if (pDoc->State() >= OS_INPLACE)
            {
                if (!fNeedConversion || MapWindowPoints(hWnd, pDoc->_pInPlace->_hwnd, &pt, 1))
                {
                    pDoc->OnMouseMessage (
                        msg,
                        wParam,
                        MAKELPARAM (pt.x, pt.y),
                        &lresult, 
                        pt.x, pt.y);
                }
            }        

            lr = TRUE;
            goto Return;
        }
    }            

    if ( msg >= WM_MOUSEFIRST &&
         msg <= WM_MOUSELAST )
    {     
        fProcessed = HandleMouseEvents(hWnd, msg, wParam, lParam);
        if ( fProcessed )
        {
            lr = TRUE;
            goto Return;
        }
    }

    switch (msg)
    {
    case WM_SETCURSOR:
        {
            CDoc * pDoc = Doc();
            if ( ( IsParentEditable() || IsMasterParentEditable() )
                 && (pDoc->_pElemCurrent != this) )
                {
                    CLayout *pLayout = GetUpdatedLayout( GUL_USEFIRSTLAYOUT );
                    Assert(pLayout);

                    if (!pLayout->IsAdorned())
                    {
                        SetCursorIDC(IDC_SIZEALL);
                    }
                    else 
                    {
                        SetCursorIDC(IDC_ARROW);
                    }
                    lr = TRUE;
                    goto Return;
                }
        }
        break;

    case WM_SYSCHAR:
    case WM_CHAR:
        if ( ! IsEditable(TRUE) )
        {
            CRect   rc;

            GetUpdatedLayout( GUL_USEFIRSTLAYOUT )->GetRect(&rc, COORDSYS_GLOBAL);

            CMessage Message(hWnd, msg, wParam, MAKELPARAM(rc.left, rc.top));    //  Create the Message

            hr = THR( Message.SetNodeHit( GetFirstBranch() ) );
            if( hr )
            {
                lr = LRESULT(hr);
                goto Return;
            }

            hr = THR(FireStdEventOnMessage(GetFirstBranch(), &Message));
            if (S_FALSE != hr)
            {
                lr = TRUE;
                goto Return;
            }

        }

        break;

    case WM_SETFOCUS:
        if (this == Doc()->_pElemCurrent &&
            !TestLock(CElement::ELEMENTLOCK_FOCUS) &&
            !Doc()->_fInhibitFocusFiring)
        {
            GWPostMethodCall(this, ONCALL_METHOD(CElement, Fire_onfocus, fire_onfocus), 0, TRUE, "CElement::Fire_onfocus");
        }
        _fFocus = TRUE;
        break;

    case WM_KILLFOCUS:
        if (this == Doc()->_pElemCurrent &&
            !TestLock(CElement::ELEMENTLOCK_BLUR))
        {
            GWPostMethodCall(this, ONCALL_METHOD(CElement, Fire_onblur, fire_onblur), 0, TRUE, "CElement::Fire_onblur");
        }
        _fFocus = FALSE;
        break;

    case WM_SYSCOLORCHANGE:
        InvalidateBackgroundBrush();
        break;

#ifndef WIN16
    //  This is a tricky one. We don't paint here, instead we
    //  catch the dropdown window and subclass it.

    //  SPY revealed that a WM_CTLCOLORLISTBOX message is sent to the
    //  combo HWND when the dropped list wants to paint, so that
    //  its colors can be changed. We use this opportunity to
    //  do the dynamic subclassing, as this message comes early enough
    //  and it carries the HWND of the dropdown list as a bonus.

    //  The case handler falls through to the paint logic so that the
    //  droplist colors can be adjusted.

    case WM_CTLCOLORLISTBOX:
        if ( _fTriggerComboSubclassing && ! _fListbox )
        {
            HWND hwndDropList = (HWND)lParam;
            TCHAR achClassName[512];

            _fTriggerComboSubclassing = FALSE;

            Assert(hwndDropList);
            if ( GetClassName(hwndDropList, achClassName, ARRAY_SIZE(achClassName)) &&
                 0 == _tcscmp(achClassName, TEXT("ComboLBox")) &&
                 NULL == s_pfnDropListWndProc ) //  Guard against double subclassing,
                                                //  which loses the original WndProc
            {
                _hwndDropList = hwndDropList;
                s_pfnDropListWndProc = (WNDPROC)GetWindowLongPtr(hwndDropList, GWLP_WNDPROC);
                SetWindowLongPtr(hwndDropList, GWLP_WNDPROC, (LONG_PTR)DropListWndProc);
                SetWindowLongPtr(hwndDropList, GWLP_USERDATA, (LONG_PTR)this);
            }
        }

        //  !! Falls through !!
    case OCM__BASE + WM_CTLCOLORLISTBOX:
    case OCM__BASE + WM_CTLCOLOREDIT:
    case OCM__BASE + WM_CTLCOLORSTATIC:
        //  get the colors from the style sheet
        //  select appropriate pen and brush into the DC in wParam
        {
            CColorValue ccv;
            HDC hDC = (HDC) wParam;

            if ( GetAAdisabled() )
            {
                SetTextColor(hDC, GetSysColorQuick(COLOR_GRAYTEXT));
            }

            if( !_hBrush )
                UpdateBackgroundBrush();

            lr = (LRESULT)_hBrush;
            goto Return;
        }
#endif // !WIN16

    case OCM__BASE + WM_COMMAND:
        {
            int iCurSel;
            //  process the notifications here
            switch ( GET_WM_COMMAND_CMD(wParam, lParam) )
            {
                case CBN_KILLFOCUS:
                    if ( !_fListbox )
                    {
                        IGNORE_HR(Doc()->InvalidateDefaultSite());
                        break;
                    }

                case LBN_KILLFOCUS:
                    if ( _fListbox )
                    {
                        IGNORE_HR(Doc()->InvalidateDefaultSite());
                        break;
                    }

                case LBN_SELCHANGE:
                    iOldSel = _iCurSel;
                    if ( !_fMultiple )
                    {
                        iCurSel = SendSelectMessage(Select_GetCurSel, 0, 0);
                        if ( iCurSel != _iCurSel && _fListbox ) // comboboxes get this message if the list is dropped
                                                               // we don't want to fire anything in that case.
                        {
                            if ( iCurSel != -1 && _aryOptions[iCurSel]->_fIsOptGroup )
                                break;

                            SetCurSel(iCurSel, (SETCURSEL_UPDATECOLL | SETCURSEL_DONTTOUCHHWND));
                            // We must check the value before we fire onchange
                            fFirePropertyChange = TRUE;
                            fValueChanged = HasValueChanged(iOldSel, GetCurSel());
                            Fire_onchange_guarded();

#ifndef NO_DATABINDING
                            // TODO:: Revisit this IGNORE_HR once we have
                            // a more coherent error handlings strategy for
                            // data-binding.  -cfranks 16 Jan 97
                            IGNORE_HR(SaveDataIfChanged(ID_DBIND_DEFAULT));
#endif
                        }
                    }
                    else
                    {
                        //  Traverse the listbox entries and update the OPTION elements'
                        //  _fSELECTED flag accordingly. If anything changed, fire_onChange.
                        int i;
                        COptionElement * pOption;
                        LRESULT lr;
                        BOOL fFireOnchange = FALSE;

                        for ( i = _aryOptions.Size() - 1; i >= 0; i-- )
                        {
                            pOption = _aryOptions[i];

                            if ( pOption->_fIsOptGroup )
                                continue;

                            lr = SendSelectMessage(Select_GetSel, i, 0);
                            if ( lr == LB_ERR )
                                break;

                            fFireOnchange = fFireOnchange || (!!lr != !!pOption->_fSELECTED);
                            pOption->_fSELECTED = lr;
                        }

                        if ( fFireOnchange )
                        {
                            // We must check the value before we fire onchange
                            fFirePropertyChange = TRUE;
                            fValueChanged = HasValueChanged(iOldSel, GetCurSel());
                            Fire_onchange_guarded();
                        }

#ifndef NO_DATABINDING
                        // NOTE: This may be odd since we don't officially
                        // data bind to multiple slections.  However, I think
                        // the behavior is that the first one is saved, so we
                        // should be consistent and still fire it immediately.
                        IGNORE_HR(SaveDataIfChanged(ID_DBIND_DEFAULT));
#endif
                    }
                    break;

                case CBN_SELENDOK:
                    if ( ! _fListbox )  //  cannot be multiple
                    {
                        iCurSel = SendSelectMessage(Select_GetCurSel, 0, 0);
                        if ( iCurSel != _iCurSel )
                        {
                            if ( iCurSel != -1 && _aryOptions[iCurSel]->_fIsOptGroup )
                                break;

                            iOldSel = _iCurSel;
                            SetCurSel(iCurSel, (SETCURSEL_UPDATECOLL | SETCURSEL_DONTTOUCHHWND));
                            // Sometimes SELENDOK gets called after the control is gone
                            // We don't want to fire onpropertychange is this case.
                            // TODO: (krisma) We may want events to fire if we're not
                            // in the tree. If that's the case, we'll need to take another 
                            // look at this. (This is here to fix 34064.)
                            if (!!(GetFirstBranch()))
                            {
                                fFirePropertyChange = TRUE;
                                fValueChanged = HasValueChanged(iOldSel, GetCurSel());
                            }
                            Fire_onchange_guarded();
#ifndef NO_DATABINDING
                            // NOTE:: Revisit this IGNORE_HR once we have
                            // a more coherent error handlings strategy for
                            // data-binding.  -cfranks 16 Jan 97
                            IGNORE_HR(SaveDataIfChanged(ID_DBIND_DEFAULT));
#endif
                        }
                        if (_fDeferFiringOnClick)
                        {
                            _fDeferFiringOnClick = FALSE;

                            Fire_onclick();
                        }
                    }
                    break;

                case CBN_DROPDOWN:

                    Assert(!_fListbox);

                    _fTriggerComboSubclassing = TRUE;

                    break;

                case CBN_CLOSEUP:

                    //  Unhook subclassing
#if NEVER
                    if ( s_pfnDropListWndProc && _hwndDropList )
                    {
                        SetWindowLongPtr(_hwndDropList, GWLP_WNDPROC, (LONG_PTR)s_pfnDropListWndProc);
                        s_pfnDropListWndProc = NULL;
                        SetWindowLongPtr(_hwndDropList, GWLP_USERDATA, 0);
                        _hwndDropList = NULL;
                    }
#endif
                    if ( _fLButtonDown )
                    {
                        _fLButtonDown = FALSE;
                    }

                    //  check the selection. If the user tabs out, CBN_SELENDOK is NOT sent
                    //  so the new selection has to be checked here.

                    int iCurSel = GetCurSel();
                    if ( iCurSel != _iCurSel )
                    {
                        iOldSel = iCurSel;
                        SetCurSel(iCurSel, (SETCURSEL_UPDATECOLL | SETCURSEL_DONTTOUCHHWND));
                        fFirePropertyChange = TRUE;
                        fValueChanged = HasValueChanged(iOldSel, GetCurSel());
                        Fire_onchange_guarded();
#ifndef NO_DATABINDING
                        // TODO:: Revisit this IGNORE_HR once we have
                        // a more coherent error handlings strategy for
                        // data-binding.  -cfranks 16 Jan 97

                        // When the user tabs away from the popup list, Trident
                        // changes the current focus element before the SELECT
                        // gets here to change its value.  In this case, we
                        // tell SaveDataIfChanged to treat the SELECT as if it
                        // were still the current focus, so that onbeforeupdate
                        // will fire.  (IE5 bug 74016)
                        IGNORE_HR(SaveDataIfChanged(ID_DBIND_DEFAULT,
                                    /* fLoud */ FALSE, /* fForceIsCurrent */ TRUE));
#endif
                    }

                    break;
            }
        }

        //  Don't let any OCM__BASE-offset reflected message enter the normal WndProc

        lr = TRUE;
        goto Return;


    // The select window is being asked for its accessible object. We create
    // and return the native accessible object to have the same accessible 
    // behavior for the select element(s) over the board.
#if !defined(_MAC) && !defined(WIN16)
    case WM_GETOBJECT:

        CAccBase * pAccSelect;
        
        pAccSelect = GetAccObjOfElement( this );
        if ( !pAccSelect )
        {
            lr = E_FAIL;
            goto Return;
        }
        
        static DYNPROC s_dynprocLresultFromObject =
                { NULL, &g_dynlibOLEACC, "LresultFromObject" };

        // Load up the LresultFromObject pointer.
        hr = THR(LoadProcedure(&s_dynprocLresultFromObject));
        if (hr)
        {
            lr = (LRESULT)hr;
            goto Return;
        }   
        
        lr = (*(LRESULT (APIENTRY *)(REFCLSID, WPARAM, IUnknown *))
                                        s_dynprocLresultFromObject.pfn)(IID_IAccessible, 
                                        wParam, 
                                        (IAccessible *)pAccSelect);
    break;
#endif
    }

// WINCE - cut some win95-only calls, so we can drop wselect.cxx from sources
#if (!defined(WINCE) && !defined(WIN16))
    lr = (CALL_METHOD( this, s_alpfnWideHookProc[ _fListbox ], (
         s_alpfnSelectWndProc[_fListbox], hWnd, msg, wParam, lParam )));

    goto Return;
#else

#ifdef WIN16
    if ( msg > LB_FINDSTRINGEXACT && msg <= WM_APP )
#else
    if ( msg >= WM_USER && msg <= WM_APP )
#endif
    {
#ifndef WIN16
        Assert(!(msg >= WM_USER && msg <= WM_APP));
#endif
        lr = TRUE;
        goto Return;
    }
#endif

DefWindowProc:
    lr = CallWindowProc(s_alpfnSelectWndProc[ _fListbox ], hWnd, msg, wParam, lParam);
    //  Falls through

Return:
    if (fFirePropertyChange)
    {
        THR(OnPropertyChange(DISPID_CSelectElement_selectedIndex, 
                             0,
                             (PROPERTYDESC *)&s_propdescCSelectElementselectedIndex));

        // If selectedIndex changed, then maybe the value changed too
        if (fValueChanged)
        {
            THR(OnPropertyChange(DISPID_CSelectElement_value, 
                                 0,
                                 (PROPERTYDESC *)&s_propdescCSelectElementvalue));
        }
    }
    return lr;
}

//+----------------------------------------------------------------------------
//
//  Memeber: CSelectElement::HasValueChanged
//
//  Has the value of the select element changed?
//
//-----------------------------------------------------------------------------

BOOL
CSelectElement::HasValueChanged(int iOldSel, int iNewSel)
{
    BOOL fReturn = FALSE;
    LPCTSTR pstrOldOptionValue;
    LPCTSTR pstrNewOptionValue;

    Assert (iOldSel < _aryOptions.Size());
    Assert (iNewSel < _aryOptions.Size());

    if (iOldSel == iNewSel)
        goto Return;

    pstrOldOptionValue = (iOldSel > -1) ? _aryOptions[iOldSel]->GetAAvalue()
        : NULL;
    pstrNewOptionValue = (iNewSel > -1) ? _aryOptions[iNewSel]->GetAAvalue()
        : NULL;

    if (!pstrOldOptionValue || !pstrNewOptionValue)
    {
        if (pstrOldOptionValue || pstrNewOptionValue)
        {
            fReturn = TRUE;
        }
        goto Return;
    }

    Assert(pstrOldOptionValue && pstrNewOptionValue);

    fReturn = !_tcsequal(pstrOldOptionValue, pstrNewOptionValue);

Return:
    return fReturn;
}

//+----------------------------------------------------------------------------
//
//
//  Databinding support
//
//
//-----------------------------------------------------------------------------

#ifndef NO_DATABINDING
class CDBindMethodsSelect : public CDBindMethodsSimple
{
    typedef CDBindMethodsSimple super;

public:
    CDBindMethodsSelect() : super(VT_BSTR) {}
    ~CDBindMethodsSelect()  {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;

    virtual HRESULT BoundValueFromElement(CElement *pElem, LONG id,
                                          BOOL fHTML, LPVOID pvData) const;

};

static const CDBindMethodsSelect DBindMethodsSelect;

const CDBindMethods *
CSelectElement::GetDBindMethods()
{
    return &DBindMethodsSelect;
}

//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: Transfer data into bound checkbox.  Only called if DBindKind
//            allows databinding.
//
//  Arguments:
//            [id]      - ID of binding point.  For the select, is always
//                        DISPID_VALUE.
//            [pvData]  - pointer to data to transfer, in this case a bstr.
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethodsSelect::BoundValueToElement(CElement *pElem,
                                         LONG,
                                         BOOL,
                                         LPVOID pvData) const
{
    HRESULT hr = S_OK;
    CSelectElement *pSelect = DYNCAST(CSelectElement, pElem);

    // databinding is shut down for multi-select
    if (!pSelect->_fMultiple)
    {
        hr = pSelect->put_value(*(BSTR *)pvData);
    }

    RRETURN(hr);
}

HRESULT
CDBindMethodsSelect::BoundValueFromElement(CElement *pElem,
                                           LONG,
                                           BOOL,
                                           LPVOID pvData) const
{
    // An S_FALSE return indicates indicates that values shouldn't be
    //  saved to the database.
    HRESULT hr = S_FALSE;
    CSelectElement *pSelect = DYNCAST(CSelectElement, pElem);

    if (pSelect->_fMultiple)
        goto Cleanup;

    // Check to see if there really was a current value.
    if (pSelect->_iCurSel < 0)
        goto Cleanup;

    // Get the current value of the list box, null str if no current value
    hr = pSelect->get_value((BSTR *)pvData);

Cleanup:
    RRETURN1(hr, S_FALSE);

}
#endif // ndef NO_DATABINDING

//+----------------------------------------------------------------------------
//
//  Method:     DoReset
//
//  Synopsis:   implements the HTML form RESET action for the SELECT
//
//  Returns:    S_OK if successful
//              S_FALSE if not applicable for current element
//
//-----------------------------------------------------------------------------
HRESULT
CSelectElement::DoReset(void)
{
    HRESULT hr = S_OK;
    long cOptions;
    int i;

    if ( _fMultiple )
    {
        SetSel(-1, FALSE);
    }
    else
    {
        SetCurSel( _fListbox ? -1 : 0, SETCURSEL_UPDATECOLL);
    }

    if ( _fListbox )
    {
        SetTopIndex(0);
    }

    cOptions = _aryOptions.Size();
    Assert(!_hwnd || SendSelectMessage(Select_GetCount, 0, 0) == cOptions);

    for ( i = 0; i < cOptions; i++ )
    {
        COptionElement * pOptionElement = _aryOptions[i];

        if (pOptionElement)
        {
            pOptionElement->_fSELECTED = pOptionElement->_fDefaultSelected; //  restore objmodel state
            if (pOptionElement->_fDefaultSelected )
            {
                if ( _fMultiple )
                {
                    SetSel(i, TRUE);
                }
                else
                {
                    SetCurSel(i, SETCURSEL_UPDATECOLL);
                    break;
                }
            }
        }
    }

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Method:     GetSubmitInfo
//
//  Synopsis:   returns the submit info string if there is a value
//              (name && value pair)  ... all data lives in the windows control
//
//  Returns:    S_OK if successful
//              S_FALSE if not applicable for current element
//
//-----------------------------------------------------------------------------
HRESULT
CSelectElement::GetSubmitInfo(CPostData * pSubmitData)
{
    LPCTSTR     pstrName = GetAAsubmitname();

    //  no name --> no submit!
    if ( ! pstrName )
        return S_FALSE;

    BuildOptionsCache();

    LPCTSTR     pstrValue = NULL;
    HRESULT     hr = S_FALSE;       //  init hr for no action
    long        lSelectedItem;
    long        i;
    long        cOptions;
    COptionElement * pOptionElement = 0;
    BOOL        fFirstItem;

    // set up for the loop
    if ( _fMultiple )
    {
        // is this a multi select
       cOptions = _aryOptions.Size();
       Assert(!_hwnd || SendSelectMessage(Select_GetCount, 0, 0) == cOptions);

       lSelectedItem = 0;
    }
    else
    {
        cOptions = 1;
        lSelectedItem = _iCurSel;
        if ( lSelectedItem == -1 )
        {
            goto Cleanup;
        }
    }

    // is single, just go get it. if multiple go around the loop cOptions times, checking each.
    fFirstItem = TRUE;
    for ( i = 0; i < cOptions; i++ )
    {
        long fSelected;

        if ( _fMultiple )
        {
            fSelected = _aryOptions[i]->_fSELECTED;

            if ( !fSelected )
                continue;
        }
        else
        {
           i = _iCurSel;  // set up if not multiple...
        }

        // get the value or the text
        pOptionElement = _aryOptions[i];
        pstrValue = pOptionElement->GetAAvalue();

        if ( !pstrValue )    // if no value or null value, go for text
        {
            // if there is no value= then use the text
            pstrValue = pOptionElement->_cstrText;
        }

        //  NOTE(laszlog): Verify that the check for first item is still needed!
        if (!fFirstItem)
        {
            hr = THR(pSubmitData->AppendItemSeparator());
            if ( hr )
                goto Cleanup;
        }

        TraceTag((tagSelectState, "SELECT %lx Submit name=%ls value=%ls", this, pstrName, pstrValue));
        hr = THR(pSubmitData->AppendNameValuePair(pstrName, pstrValue, GetMarkup()));
        if (hr)
            goto Cleanup;

        fFirstItem = FALSE;

        pstrValue = NULL;
    } // end for loop

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::InvokeEx, IDispatch
//
//----------------------------------------------------------------------------

HRESULT
CSelectElement::InvokeEx(DISPID dispidMember,
                         LCID lcid,
                         WORD wFlags,
                         DISPPARAMS *pdispparams,
                         VARIANT *pvarResult,
                         EXCEPINFO *pexcepinfo,
                         IServiceProvider *pSrvProvider)
{
    HRESULT     hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = DispatchInvokeCollection(NULL,
                                  NULL,
                                  _pCollectionCache,
                                  SELECT_OPTION_COLLECTION,
                                  dispidMember,
                                  IID_NULL,
                                  lcid,
                                  wFlags,
                                  pdispparams,
                                  pvarResult,
                                  pexcepinfo,
                                  NULL,
                                  pSrvProvider);

    if (hr)
    {
        hr = THR_NOTRACE(super::ContextInvokeEx(     // need to go via CElement level
            dispidMember,
            lcid,
            wFlags,
            pdispparams,
            pvarResult,
            pexcepinfo,
            pSrvProvider,
            NULL));
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::GetDispID, IDispatchEx
//
//----------------------------------------------------------------------------

HRESULT
CSelectElement::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT     hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = DispatchGetDispIDCollection(this,
                                     (GetDispIDPROC) super::GetDispID,
                                     _pCollectionCache,
                                     SELECT_OPTION_COLLECTION,
                                     bstrName,
                                     grfdex,
                                     pid);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::GetNextDispID, IDispatchEx
//
//----------------------------------------------------------------------------
HRESULT
CSelectElement::GetNextDispID(DWORD grfdex,
                              DISPID id,
                              DISPID *prgid)
{
    HRESULT     hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = DispatchGetNextDispIDCollection(this,
#ifndef WIN16
                                         (GetNextDispIDPROC)&super::GetNextDispID,
#else
                                         CBase::GetNextDispID,
#endif
                                         _pCollectionCache,
                                         SELECT_OPTION_COLLECTION,
                                         grfdex,
                                         id,
                                         prgid);

Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CSelectElement::GetMemberName(
                DISPID id,
                BSTR *pbstrName)
{
    HRESULT     hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = DispatchGetMemberNameCollection(this,
#ifndef WIN16
                                         (GetGetMemberNamePROC)super::GetMemberName,
#else
                                         CBase::GetMemberName,
#endif
                                         _pCollectionCache,
                                         SELECT_OPTION_COLLECTION,
                                         id,
                                         pbstrName);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::AddNewOption
//
// Supports adding option element to the options collection via
// JScript array access e.g.
// options [ 7 ] = new Option();
//----------------------------------------------------------------------------

HRESULT BUGCALL
CSelectElement::AddNewOption(long lIndex, IDispatch *pObject, long index)
{
    HRESULT             hr = S_OK;
    CElement *          pElement = NULL;
    IUnknown *          pUnk;
    long                lDummy;

    if (index < -1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Make sure that pObject is an <OPTION> element
    hr = THR(pObject->QueryInterface(IID_IHTMLOptionElement, (void**)&pUnk));
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    ReleaseInterface(pUnk);

    if (index == -1)
        index = _aryOptions.Size(); // append

    // index is the ordinal position to add/replace
    // If it exists, replace the existing element.
    // If not extend the options array with default elements
    // up to index-1, then add the new element
    // Verify that pObject is an IOptionElement

    if (index < _aryOptions.Size())
    {
        // remove the current element at 'index'
        hr = THR(RemoveOptionHelper(index));
        if (hr)
            goto Cleanup;
    }
    else
    {
        // pad with dummy elements till index - 1

        for (lDummy = _aryOptions.Size(); lDummy < index; lDummy++)
        {
            hr = THR(Doc()->CreateElement(ETAG_OPTION, &pElement));
            if (hr)
                goto Cleanup;

            // insert the dummy element
            hr = THR(AddOptionHelper(DYNCAST(COptionElement, pElement), lDummy, NULL, TRUE));
            if (hr)
                goto Cleanup;

            CElement::ClearPtr(&pElement);
        }
    }

    // insert the new element at 'index'
    Verify(S_OK == THR(pObject->QueryInterface(CLSID_CElement, (void **)&pElement)));

    // Bail out if the element is already in the tree - #25130
    // Also bail out if the element wasn't created in this document
    if (pElement->IsInMarkup() || pElement->Doc() != Doc())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pElement->AddRef();

    // querying for a CLSID does not get us a ref!

    hr = THR(AddOptionHelper(DYNCAST(COptionElement, pElement), index, DYNCAST(COptionElement, pElement)->_cstrText, FALSE));
    if (hr)
        goto Cleanup;

    CElement::ClearPtr(&pElement);

Cleanup:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::BuildOptionsCache
//
//  Synopsis:   Walk the SELECT's subtree, cache the OPTIONs
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::BuildOptionsCache(void)
{
    HRESULT             hr           = S_OK;

    CTreeNode *         pNode;
    CTreeNode *         pNodeSelect;
    CTreePos *          ptp;

    int                 iSelected;
    int                 iOptionCount;

    if ( ! _fOptionsDirty )
        goto Cleanup;

    // Init current selection index and option counter

    iSelected    = -1;
    iOptionCount = -1;
    
    //  Zap the Options

    InvalidateCollection();

    _poptLongestText = NULL;
    _lMaxWidth = 0;
    _aryOptions.DeleteAll();
    _fHasOptGroup = FALSE;

    //  Walk the runs in the SELECT's scope
    //      Grab all the OPTIONs
    //          stuff them into the SELECT's aryOption
    //          stuff them into the listbox
    //          call the OPTION to cache its text
    //      Disregard all other tags
    //  Let the layout recalc itself

    for (pNodeSelect = GetFirstBranch() ;
         pNodeSelect ;
         pNodeSelect = pNodeSelect->NextBranch() )
    {
        for (ptp = pNodeSelect->GetBeginPos()->NextTreePos();
             ptp != pNodeSelect->GetEndPos();
             ptp = ptp->NextTreePos())
        {
            if (ptp->IsBeginNode())
            {
                pNode = ptp->Branch();
                if ( ptp->IsEdgeScope() && 
                     (pNode->Element()->Tag() == ETAG_OPTION || pNode->Element()->Tag() == ETAG_OPTGROUP))
                {
                    COptionElement * pOption = DYNCAST(COptionElement, pNode->Element());

                    pOption->_fIsGroupOption = FALSE;

                    hr = AppendOption(pOption);
                    if ( hr )
                        goto Cleanup;
                
                    iOptionCount++;
                    if (pOption->_fSELECTED )
                    {
                        Assert( pOption->_fIsOptGroup == FALSE );
                        iSelected = iOptionCount;
                    }

                    if (pNode->Element()->Tag() == ETAG_OPTGROUP)
                    {
                        CTreeNode *         pNodeOpt;
                        CTreePos *          ptpOptGrp;

                        _fHasOptGroup = TRUE;

                        for (ptpOptGrp = pNode->GetBeginPos()->NextTreePos();
                             ptpOptGrp != pNode->GetEndPos();
                             ptpOptGrp = ptpOptGrp->NextTreePos())
                        {
                            if (ptpOptGrp->IsBeginNode())
                            {
                                pNodeOpt = ptpOptGrp->Branch();

                                Assert(pNodeOpt->Element()->Tag() != ETAG_OPTGROUP);

                                if ( ptpOptGrp->IsEdgeScope() && pNodeOpt->Element()->Tag() == ETAG_OPTION)
                                {                                    
                                    COptionElement * pOption2 = DYNCAST(COptionElement, pNodeOpt->Element());
                                    pOption2->_fIsGroupOption = TRUE;
                                    
                                    hr = AppendOption(pOption2);
                                    if ( hr )
                                        goto Cleanup;
                    
                                    iOptionCount++;
                                    if (pOption2->_fSELECTED )
                                    {
                                        iSelected = iOptionCount;
                                    }
                                }
                                ptpOptGrp = pNodeOpt->GetEndPos();
                            }
                        }
                    }
                }
                ptp = pNode->GetEndPos();
            }
        }
    }

    //Set the current selection

    if (_fMultiple)
    {
        _iCurSel = -1;
    }
    else
    {
        // Special case - drop down with no selection defaults to first OPTION
        if ( !_fListbox && (iSelected == -1) && (GetLength() > 0) )
        {
            _iCurSel = iSelected = AbsIdxFromRel( 0 );
            Assert( iSelected >= 0 && iSelected < _aryOptions.Size() );
            _aryOptions[iSelected]->_fSELECTED = TRUE;
            if (_hwnd)
                SendSelectMessage(Select_SetCurSel, (WPARAM)iSelected, 0);
        }
        else
        {         
            _iCurSel = iSelected;
        }
    }

    _fOptionsDirty = FALSE;
    _fWindowDirty  = TRUE;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::AppendOption
//
//  Synopsis:   Appends an option to the _aryOptions array
//
//-------------------------------------------------------------------------

HRESULT
CSelectElement::AppendOption(COptionElement * pOption)
{
    HRESULT hr;

    Assert(pOption);

    // Assert that we haven't seen this element before
    Assert( -1 == _aryOptions.Find(pOption) );

    hr = pOption->CacheText();
    if ( hr )
        goto Cleanup;

    hr = _aryOptions.Append(pOption);
    if ( hr )
        goto Cleanup;

    pOption->_fInCollection = TRUE;

    if (pOption->_fSELECTED)
    {
        long lControlIndex = _aryOptions.Find(pOption);

        if ( ! _fMultiple )
        {
            SetCurSel(lControlIndex, SETCURSEL_UPDATECOLL | SETCURSEL_DONTTOUCHHWND);
        }
        else
        {
            SetSel(lControlIndex, TRUE, SETCURSEL_DONTTOUCHHWND);
        }
    }

    TraceTag((tagSelectWalk, "Option index %d, text is %ls %s",_aryOptions.Find(pOption),pOption->_cstrText, pOption->_fSELECTED ? "SELECTED" : "" ));

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::SetVisibleRect
//
//  Synopsis:   Sets the bound of visible part of selector window
//
//  Arguments:  rc      ref to bounding rectangle
//
//  Note:       Calling SetVisibleRect cause deferred redefinition
//              of window region; that happens at WM_WINDOWPOSCHANGING
//              event sent by SetWindowPos.
//-------------------------------------------------------------------------
void CSelectElement::SetVisibleRect(const CRect& rc)
{
    if (_rgnVisible == rc)
        return;

    CRegion2 r(rc);
    r.Subtract(_rgnVisible);
    _rgnInvalidate.Union(r);
    _rgnVisible = rc;

    _fVisibleChanged = true;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::SetVisibleRegion
//
//  Synopsis:   Sets the bound of visible part of selector window
//
//  Arguments:  rgn      ref to new region
//
//  Note:       Calling SetVisibleRegion cause deferred redefinition
//              of window region; that happens at WM_WINDOWPOSCHANGING
//              event sent by SetWindowPos.
//-------------------------------------------------------------------------
void CSelectElement::SetVisibleRegion(const CRegion2& rgn)
{
    if (_rgnVisible == rgn)
        return;

    CRegion2 r(rgn);
    r.Subtract(_rgnVisible);
    _rgnInvalidate.Union(r);
    _rgnVisible = rgn;

    _fVisibleChanged = true;
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::GetNearestOption
//
//  Synopsis:   For the given OptGroup returns the nearest Option 
//              in the direction indicated (fDir = TRUE means UP)
//              If at the end of the list returns -1
//
//-------------------------------------------------------------------------
long CSelectElement::GetNearestOption(long lIndex, BOOL fDir)
{
    Assert( _fHasOptGroup );
    Assert( _aryOptions[lIndex]->_fIsOptGroup );
    Assert( lIndex >= 0 && lIndex < _aryOptions.Size() );

    if (fDir)
    {
        // Search UP
        for(int i = lIndex - 1; i >= 0 && _aryOptions[i]->_fIsOptGroup; i--);
        return i;
    }
    else
    {
        // Search DOWN
        for(int i = lIndex + 1; i < _aryOptions.Size() && _aryOptions[i]->_fIsOptGroup; i++);
        return i < _aryOptions.Size() ? i : -1 ;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectElement::HandleKeyForOptGroup
//
//  Synopsis:   Handles the Up/Down keys in case we are about to select OptGroup
//
//  Arguments:  wParam      key code
//
//  Note:       The function returns true if the selection was OptGroup in which
//              case the nearest eligible option is selected instead
//-------------------------------------------------------------------------
BOOL CSelectElement::HandleKeyForOptGroup(WPARAM wParam, long * lDelta)
{
    Assert( _fHasOptGroup );
    BOOL keyHandled = FALSE;
    long iNewSel = -1;
    long iCurSel =_iCurSel;
    long lPageSize = DEFAULT_COMBO_ITEMS - 3;

    if (_hwndDropList)
    {
        Assert(!_fMultiple);
        iCurSel = ::SendMessageA(_hwndDropList, LB_GETCURSEL, 0, 0);  
    }
    else if (iCurSel == -1)
    {
        Assert(_hwnd);
        Assert(_fListbox);
        iCurSel = ::SendMessageA(_hwnd, LB_GETCURSEL, 0, 0);
        if (!_fMultiple && (iCurSel == -1))
            iCurSel = 0;
    }

    // If no selection ignore keyboard
    if (iCurSel == -1)
    {
        return TRUE;
    }

    switch(wParam)
    {
    case VK_UP:
        iNewSel = iCurSel - 1;
        if (iNewSel >= 0 && _aryOptions[iNewSel]->_fIsOptGroup)
        {
            keyHandled = TRUE;
            iNewSel = GetNearestOption(iNewSel, TRUE);
        }
        break;

    case VK_DOWN:
        iNewSel = iCurSel + 1;
        if ( iNewSel < _aryOptions.Size() )
        {
            if ( _aryOptions[iNewSel]->_fIsOptGroup )
            {
                keyHandled = TRUE;
                iNewSel = GetNearestOption(iNewSel, FALSE);
            }
        }
        else
        {
            iNewSel = -1;
        }        
        break;

    case VK_PRIOR:
        if (_fListbox)
        {
            lPageSize = GetAAsize();
            Assert(lPageSize || _fMultiple);
            lPageSize = (!lPageSize && _fMultiple) ? 3 : lPageSize-1;
            Assert(lPageSize >= 0);
        }

        if (iCurSel - lPageSize <= 0)
        {
            goto Home;
        }
        else if (_aryOptions[iCurSel - lPageSize]->_fIsOptGroup)
        {
            iNewSel = GetNearestOption(iCurSel - lPageSize, TRUE);
            if (iNewSel == -1)
            {
                Assert(_aryOptions[0]->_fIsOptGroup);
                goto Home;
            }
            keyHandled = TRUE;
        }
        break;

    case VK_NEXT:
        if (_fListbox)
        {
            lPageSize = GetAAsize();
            Assert(lPageSize || _fMultiple);
            lPageSize = (!lPageSize && _fMultiple) ? 3 : lPageSize-1;
            Assert(lPageSize >= 0);
        }

        if (iCurSel + lPageSize >= _aryOptions.Size() - 1)
        {
            goto End;
        }
        else if (_aryOptions[iCurSel + lPageSize]->_fIsOptGroup)
        {
            iNewSel = GetNearestOption(iCurSel + lPageSize, FALSE);
            if (iNewSel == -1)
            {
                Assert(_aryOptions[_aryOptions.Size() - 1]->_fIsOptGroup);
                goto End;
            }
            keyHandled = TRUE;
        }
        break;

    case VK_HOME:
Home:        
        if ( _aryOptions[0]->_fIsOptGroup && !_fMultiple )
        {
            keyHandled = TRUE;
            iNewSel = GetNearestOption(0, FALSE);
        }
        break;

    case VK_END:
End:
        iNewSel = _aryOptions.Size() - 1;
        if ( _aryOptions[iNewSel]->_fIsOptGroup && !_fMultiple )
        {
            keyHandled = TRUE;
            iNewSel = GetNearestOption(iNewSel, TRUE);
        }
        break;
    }
        
    if ( keyHandled && iNewSel != -1 )
    {
        if ( _fMultiple )
        {
            keyHandled = FALSE;
            *lDelta = iNewSel - iCurSel;

            switch (wParam)
            {
            case VK_PRIOR:
                *lDelta += lPageSize;
                break;
            case VK_NEXT:
                *lDelta -= lPageSize;
                break;
            case VK_UP:
                *lDelta += 1;
                break;
            case VK_DOWN:
                *lDelta -= 1;
                break;
            }
        }
        else
        {
            SetCurSel(iNewSel, SETCURSEL_UPDATECOLL);
        }
    }

    return keyHandled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\hisvenc.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       hisvenc.cxx
//
//  Contents:   History value encoder
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ENCODE_HXX_
#define X_ENCODE_HXX_
#include "encode.hxx"
#endif

#ifndef X_HISVENC_HXX_
#define X_HISVENC_HXX_
#include "hisvenc.hxx"
#endif

MtDefine(CHistValEncReader, Utilities, "CHistValEncReader")
MtDefine(CHistValEncWriter, Utilities, "CHistValEncWriter")
MtDefine(CHisValConverter,  Utilities, "CHisValConverter")
MtDefine(CHistValEncReaderPchBuf, CHistValEncReader, "CHistValEncReader::_pHistValBuffer")

HRESULT
CHistValEncWriter::UnicodeToWB(TCHAR * pchIn)
{
    HRESULT hr=S_OK;
    int     cch;

    Assert(pchIn);

    // So MultiByteFromWideChar knows what to convert
    _pchBuffer = (TCHAR *)pchIn;
    _cchBuffer = _cchBufferMax = _tcslen(pchIn) + 1;

    hr = THR(MultiByteFromWideChar(FALSE, &cch));

    // Do this to prevent the destructor from trying to
    // free _pchBuffer
     _pchBuffer = NULL;
     _cchBuffer = _cchBufferMax = 0;

    return hr; 
}

HRESULT
CHistValEncReader::WBToUnicode(unsigned char * pchIn)
{
    HRESULT hr=S_OK;
    int     cch;

    Assert(pchIn);

    // So MultiByteFromWideChar knows what to convert
    _pbBuffer = _pbBufferPtr = pchIn;
    _cbBuffer = _cbBufferMax = lstrlenA((const char *)pchIn) + 1;

    hr = THR(WideCharFromMultiByte(FALSE, &cch));

    _pbBuffer = NULL;   // no need to free the writer's memory

    return hr; 
}

HRESULT
CHistValEncReader::MakeRoomForChars(int cch)
{
    if (!_pchBuffer)
    {
        _cchBuffer = _cbBufferMax;      // make the room big enough

        _pchBuffer = (TCHAR *)MemAlloc( Mt(CHistValEncReaderPchBuf),
                                        _cchBuffer * sizeof(TCHAR));
        if (!_pchBuffer)
            RRETURN( E_OUTOFMEMORY );

        _pchEnd = _pchBuffer;

        *_pchEnd = _T('\0');
    }
    else
    {
        AssertSz(FALSE, "CHistValEncReader::MakeRoomForChars : room should be enough");
    }

    CEncodeReader::MakeRoomForChars(cch);
    RRETURN(S_OK);
}

HRESULT
CHisValConverter::Convert(CStr &cstr, CODEPAGE cpFrom, CODEPAGE cpTo)
{
    HRESULT hr = S_OK;
    CHistValEncReader   hvReader(cpTo);
    CHistValEncWriter   hvWriter(cpFrom);

    hr = hvWriter.UnicodeToWB(cstr);

    if (FAILED(hr))
        goto Cleanup;

    hvReader.WBToUnicode((unsigned char *)hvWriter._pbBuffer);

    if (FAILED(hr))
        goto Cleanup;

    cstr.Set(hvReader._pchBuffer);

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\imgelem.cxx ===
//+---------------------------------------------------------------------
//
//   File:      image.cxx
//
//  Contents:   Img element class, etc..
//
//  Classes:    CImgElement, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_TYPES_H_
#define X_TYPES_H_
#include "types.h" // for s_enumdeschtmlReadyState
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_MSRATING_HXX_
#define X_MSRATING_HXX_
#include "msrating.hxx" // AreRatingsEnabled()
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_IMGLYT_HXX_
#define X_IMGLYT_HXX_
#include "imglyt.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

#define _cxx_
#include "img.hdl"

ExternTag(tagMsoCommandTarget);
ExternTag(tagTooltip);
MtDefine(CImgElement, Elements, "CImgElement")
MtDefine(CImageElementFactory, Elements, "CImageElementFactory")

#ifndef WIN16
extern NEWIMGTASKFN NewImgTaskArt;
#endif


#ifndef NO_PROPERTY_PAGE
const CLSID * const CImgElement::s_apclsidPages[] =
{
    // Browse-time pages
    &CLSID_CImageBrowsePropertyPage,
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1       
    NULL
};
#endif // NO_PROPERTY_PAGE



const CElement::CLASSDESC CImgElement::s_classdesc =
{
    {
        &CLSID_HTMLImg,                 // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_CARETINS_SL |
        ELEMENTDESC_NEVERSCROLL |
        ELEMENTDESC_EXBORDRINMOV,       // _dwFlags
        &IID_IHTMLImgElement,           // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLImgElement,    // _pfnTearOff
    NULL                                // _pAccelsRun
};

CImgElement::CImgElement (ELEMENT_TAG eTag, CDoc *pDoc)
      : super(eTag, pDoc)
{
#ifdef WIN16
    m_baseOffset = ((BYTE *) (void *) (CBase *)this) - ((BYTE *) this);
    m_ElementOffset = ((BYTE *) (void *) (CElement *)this) - ((BYTE *) this);
#endif
    _pMap = NULL;
    _fCanClickImage = FALSE;
    _fNoUIActivateInDesign = TRUE;
}


//+------------------------------------------------------------------------
//
//  Member:     Init
//
//  Synopsis:   
//
//-------------------------------------------------------------------------

HRESULT
CImgElement::Init()
{
    HRESULT hr = S_OK;

    _pImage = new CImgHelper(Doc(), this, FALSE);

    if (!_pImage)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    hr = super::Init();

Cleanup:
    RRETURN(hr);
}

HRESULT
CImgElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert (ppElement);

    *ppElement = new CImgElement(pht->GetTag(), pDoc);

    RRETURN ((*ppElement) ? S_OK : E_OUTOFMEMORY);
}

//+----------------------------------------------------------------------------------
//
//  Member:     CImgElement::GetDispID, per IDispatchEx
//
//-----------------------------------------------------------------------------------

HRESULT
CImgElement::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pid)
{
    HRESULT         hr;

    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));

    // Add the hack for the Jeremie test.  If the property we're looking
    // for is  lowSrc, return the dispid for lowsrc.
    if (hr == DISP_E_UNKNOWNNAME && !_tcscmp(bstrName, _T("lowSrc")))
    {
        BSTR    bstrTmp;

        hr = FormsAllocString(_T("lowsrc"), &bstrTmp);
        if (FAILED(hr))
            goto Cleanup;
        hr = THR_NOTRACE(super::GetDispID(bstrTmp, grfdex, pid));
        FormsFreeString(bstrTmp);
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CImgElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CImgElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_TEAROFF(this, IDispatchEx, NULL);
        QI_HTML_TEAROFF(this, IHTMLElement2, NULL);
        QI_HTML_TEAROFF(this, IHTMLImgElement2, NULL);
		QI_TEAROFF(this, IOleCommandTarget, NULL);
    }

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        RRETURN(S_OK);
    }

    RRETURN(super::PrivateQueryInterface(iid, ppv));
}

//+------------------------------------------------------------------------
//
//  Member:     InvokeExReady
//
//  Synopsis  :this is only here to handle readyState queries, everything
//      else is passed on to the super
//
//+------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

STDMETHODIMP
CImgElement::ContextThunk_InvokeExReady(DISPID dispid,
                        LCID lcid,
                        WORD wFlags,
                        DISPPARAMS *pdispparams,
                        VARIANT *pvarResult,
                        EXCEPINFO *pexcepinfo,
                        IServiceProvider *pSrvProvider)
{
    IUnknown * pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    HRESULT  hr = S_OK;

    hr = THR(ValidateInvoke(pdispparams, pvarResult, pexcepinfo, NULL));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(ReadyStateInvoke(dispid, wFlags, _pImage->_readyStateFired, pvarResult));
    if (hr == S_FALSE)
    {
        hr = THR_NOTRACE(super::ContextInvokeEx(dispid,
                                         lcid,
                                         wFlags,
                                         pdispparams,
                                         pvarResult,
                                         pexcepinfo,
                                         pSrvProvider,
                                         pUnkContext ? pUnkContext : (IUnknown*)this));
    }

Cleanup:
    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

EXTERN_C const GUID CLSID_HTMLObjectElement;

void
CImgElement::EnsureMap()
{
    _pMap = NULL;

    CMarkup * pMarkup = NULL;
    LPCTSTR pchUSEMAP;

    CDoc * pDoc = Doc();
    


    if (pDoc->_fInImageObject) 
    {         
        HRESULT hr = S_OK;
        IOleClientSite * pIOCS = NULL;
        COleSite *pOS = NULL;

        hr = pDoc->GetClientSite(&pIOCS);
        if(!hr)
            hr = IUnknown_QueryService(pIOCS, CLSID_HTMLObjectElement, CLSID_HTMLObjectElement, (void **) &pOS);
        if(!hr)
            pMarkup = pOS->GetMarkup();

        ReleaseInterface(pIOCS);
        
        if (hr)
            return;

        if (pMarkup == NULL)
            return;
        
        
        Assert(ETAG_OBJECT == pOS->Tag());
        CObjectElement * pOE = DYNCAST(CObjectElement, pOS);
        pchUSEMAP = pOE->GetAAuseMap();
    }
    else
    {
        pMarkup = GetMarkup();
        if (pMarkup == NULL)
            return;        
        pchUSEMAP = GetAAuseMap();

    }
 
    CMapElement * pMap = pMarkup->GetMapHead();

    if (pMap == NULL)
        return;

#if DBG==1
    // Checked for a loop in the linked list.  Who would have
    // thought the canonical interview question would actually
    // be useful?
    CMapElement *pPtr1 = pMap;
    CMapElement *pPtr2 = pMap;

    for( ; ; )
    {
        pPtr2 = pPtr2->_pMapNext;
        if( !pPtr2 )    // Ran off end
            break;
        pPtr2 = pPtr2->_pMapNext;
        if( !pPtr2 )    // Ran off end
            break;

        pPtr1 = pPtr1->_pMapNext;

        if( pPtr1 == pPtr2 )
        {
            AssertSz( FALSE, "Loop in linked list of image maps - we're about to go into an infinite loop" );
            break;
        }
    }
#endif // DBG

    if (pchUSEMAP == NULL || *pchUSEMAP == 0)
        return;

    pchUSEMAP = _tcschr(pchUSEMAP, _T('#'));

    if (pchUSEMAP == NULL)
        return;

    pchUSEMAP += 1;

    if (*pchUSEMAP == 0)
        return;

    LONG lSourceIndexMin = LONG_MAX;
    LONG lSourceIndex;
    LPCTSTR pchName;
    BOOL fEqual;

    // Find the map which has the same name and smallest source index

    for (; pMap; pMap = pMap->_pMapNext)
    {
        pchName = pMap->GetAAname();
        fEqual = pchName ? !FormsStringICmp(pchUSEMAP, pchName) : FALSE;

        if (!fEqual)
        {
            pchName = pMap->GetAAid();
            fEqual = pchName ? !FormsStringICmp(pchUSEMAP, pchName) : FALSE;
        }

        if (!fEqual)
        {
            pchName = pMap->GetAAuniqueName();
            fEqual = pchName ? !FormsStringICmp(pchUSEMAP, pchName) : FALSE;
        }

        if (fEqual)
        {
            lSourceIndex = pMap->GetSourceIndex();

            if (lSourceIndex < lSourceIndexMin)
            {
                _pMap = pMap;
                lSourceIndexMin = lSourceIndex;
            }
        }
    }

}

 
//+---------------------------------------------------------------------------
//
//  Member:     CImgElement::Notify
//
//  Synopsis:   Receives notifications
//
//+---------------------------------------------------------------------------

void
CImgElement::Notify(CNotification *pNF)
{
    CAreaElement *  pArea;
    HRESULT         hr = S_OK;
    CElement::CLock  Lock(this);

    super::Notify(pNF);
    Assert(_pImage);

    _pImage->Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_QUERYFOCUSSABLE:
        if (!IsEditable(TRUE))
        {
            CQueryFocus *   pQueryFocus = (CQueryFocus *) pNF->DataAsPtr();

            pQueryFocus->_fRetVal = FALSE;

            // uses a client-side image map?
            if (EnsureAndGetMap())
            {
                CAreaElement *  pArea;

                if (S_OK == THR(_pMap->GetAreaContaining(pQueryFocus->_lSubDivision, &pArea)))
                {
                    pQueryFocus->_fRetVal = pArea && (pArea->GetUrl() || pArea->GetAAtabIndex() != htmlTabIndexNotSet);
                }
            }

            // is a server-side image map?
            else if (GetAAisMap())
            {
                CAnchorElement * pAnchor = GetContainingAnchor();
                pQueryFocus->_fRetVal = pAnchor && pAnchor->GetUrl();
            }
        }
        break;
    case NTYPE_ELEMENT_QUERYTABBABLE:
        if (!IsEditable(TRUE))
        {
            CQueryFocus *   pQueryFocus = (CQueryFocus *) pNF->DataAsPtr();

            // Assume that focussability is already checked for, and only make
            // sure that tabIndex is non-negative for subdivision
            Assert(IsFocussable(pQueryFocus->_lSubDivision));
            pQueryFocus->_fRetVal = TRUE;

            // uses a client-side image map?
            if (EnsureAndGetMap())
            {
                CAreaElement *  pArea;

                if (S_OK == THR(_pMap->GetAreaContaining(pQueryFocus->_lSubDivision, &pArea)))
                {
                    Assert(pArea);
                    if (pArea)
                    {
                        short tabIndex = pArea->GetAAtabIndex();

                        if (tabIndex != htmlTabIndexNotSet && tabIndex < 0)
                        {
                            pQueryFocus->_fRetVal = FALSE;
                        }
                    }
                }
            }
        }
        break;
    case NTYPE_ELEMENT_SETFOCUS:
        {
            CHyperlink *    pHyperlink  = NULL;

            // uses a client-side image map?
            if (EnsureAndGetMap())
            {
                CAreaElement *  pArea;

                if (S_OK == THR(_pMap->GetAreaContaining(Doc()->_lSubCurrent, &pArea)))
                {
                    pHyperlink = pArea;
                }
            }

            // is a server-side image map?
            else if (GetAAisMap())
            {
                pHyperlink = GetContainingAnchor();
            }

            if (pHyperlink)
            {
                IGNORE_HR(pHyperlink->SetStatusText());
            }
        }
        break;

    case NTYPE_AREA_TABINDEX_CHANGE:
    case NTYPE_AREA_FOCUS:
        EnsureMap();
        if (_pMap)
        {
            long    l;

            pNF->Data((void **)&pArea);

            if (OK(_pMap->SearchArea(pArea, &l)))
            {
                pNF->SetFlag(NFLAGS_SENDENDED);

                if (pNF->Type() == NTYPE_AREA_FOCUS)
                {
                    //
                    // Search for the area in the map.  If found, then make
                    // myself current.
                    //

                    hr = THR(focusHelper(l));
                    if (hr)
                        goto Cleanup;
                }
                else
                {
                    Assert(NTYPE_AREA_TABINDEX_CHANGE == pNF->Type());
                    OnTabIndexChange();
                }
            }
        }
    
    case NTYPE_ELEMENT_ENTERTREE:
        EnterTree();
        break;

    case NTYPE_BASE_URL_CHANGE:
        OnPropertyChange( DISPID_CImgElement_useMap, 
                          ((PROPERTYDESC *)&s_propdescCImgElementuseMap)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCImgElementuseMap);
        OnPropertyChange( DISPID_CImgElement_src, 
                          ((PROPERTYDESC *)&s_propdescCImgElementsrc)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCImgElementsrc);
        OnPropertyChange( DISPID_CImgElement_dynsrc, 
                          ((PROPERTYDESC *)&s_propdescCImgElementdynsrc)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCImgElementdynsrc);
        OnPropertyChange( DISPID_CImgElement_lowsrc, 
                          ((PROPERTYDESC *)&s_propdescCImgElementlowsrc)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCImgElementlowsrc);
        break;
    }

Cleanup:
    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     EnterTree
//
//+---------------------------------------------------------------------------
HRESULT
CImgElement::EnterTree()
{
    EnsureMap();

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     HandleMessage
//
//  Synopsis:   Handle messages bubbling when the passed site is non null
//
//  Arguments:  [pMessage]  -- message
//              [pChild]    -- pointer to child when bubbling allowed
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CImgElement::HandleMessage(CMessage * pMessage)
{
    HRESULT hr              = S_FALSE;
    BOOL    fInBrowseMode   = !IsEditable(TRUE);
    TCHAR * pchUrl;
    TCHAR   cBuf[pdlUrlLen];
    TCHAR * pchExpandedUrl  = cBuf;
    IUniformResourceLocator *   pURLToDrag      = NULL;

    EnsureMap();
    if (_pMap)
    {
        CAreaElement *  pArea = NULL;

        IGNORE_HR(_pMap->GetAreaContaining(pMessage->lSubDivision, &pArea));
        if (fInBrowseMode && pArea)
        {
            switch(pMessage->message)
            {
            case WM_CHAR:
            case WM_SYSCHAR:
                switch (pMessage->wParam)
                {
                case VK_RETURN:

                    // For <AREA>, pressing Enter is same as clicking with mouse
                    if (GetCurrentArea())
                    {
                        pMessage->lSubDivision = Doc()->_lSubCurrent;
                        pMessage->SetNodeClk(GetFirstBranch());
                        hr = S_OK;
                    }
                    break ;
                }
                break ;

            case WM_MOUSEWHEEL:
                if (   (pMessage->dwKeyState & FSHIFT)
                    && (((short) HIWORD(pMessage->wParam)) > 0))
                {
                    pMessage->SetNodeClk(GetFirstBranch());
                    hr = S_OK;
                }
                break;

            case WM_LBUTTONDOWN:
            case WM_RBUTTONDOWN:
                Doc()->SetMouseCapture(
                    MOUSECAPTURE_METHOD(CImgElement, HandleCaptureMessageForArea, handlecapturemessageforarea),
                    this);

                // Set the limits for a mouse move before showing
                // the no entry cursor
                _rcWobbleZone.left   = pMessage->pt.x - g_sizeDragMin.cx;
                _rcWobbleZone.right  = pMessage->pt.x + g_sizeDragMin.cx + 1;
                _rcWobbleZone.top    = pMessage->pt.y - g_sizeDragMin.cy;
                _rcWobbleZone.bottom = pMessage->pt.y + g_sizeDragMin.cy + 1;

                // Can click while mouse is inside wobble zone
                _fCanClickImage = TRUE;
                hr = S_OK;
                break;

            case WM_MOUSEOVER:
                if (!pArea->_fHasMouseOverCancelled)
                {
                    pArea->SetStatusText();
                }
                break;

            case WM_SETCURSOR:
                {
                    TCHAR * pchUrl;

                    if (S_OK == pArea->GetUrlComponent(NULL, URLCOMP_WHOLE, &pchUrl) && pchUrl)
                    {
                        SetCursorStyle(pArea->GetHyperlinkCursor());
                        MemFreeString(pchUrl);
                        hr = S_OK;
                    }
                }
                break;

            case WM_LBUTTONUP:
                if (_fCanClickImage)    // If click is allowed,
                {
                    Assert(SameScope(pMessage->pNodeHit, this));
                    pMessage->SetNodeClk(GetFirstBranch());
                }
                // Release the mouse capture.
                // Doc()->SetMouseCapture(NULL, NULL);
                TakeCapture(FALSE);
                _fCanClickImage = FALSE;
                hr = S_OK;
                break;

            case WM_RBUTTONUP:
                hr = S_FALSE;

                // Release the mouse capture.
                // Doc()->SetMouseCapture(NULL, NULL, TRUE);
                TakeCapture(FALSE);
                _fCanClickImage = FALSE;
                break;

            case WM_MOUSEMOVE:
                if (!_fCanClickImage)
                    break;

                // If the user moved the mouse outside of the wobble zone,
                if(!PtInRect(&_rcWobbleZone, pMessage->pt))
                {
                    CDoc * pDoc = Doc();

                    _fCanClickImage = FALSE;                     // Disable click
                    SetCursorStyle(IDC_NO);

                    // Release the mouse capture.
                    //pDoc->SetMouseCapture(NULL, NULL, TRUE);
                    TakeCapture(FALSE);

                    // initiate drag-drop
                    if (!pDoc->_fIsDragDropSrc)
                    {
                        // fully resolve URL
                        hr = THR(CMarkup::ExpandUrl(
                            NULL, pArea->GetAAhref(), ARRAY_SIZE(cBuf), pchExpandedUrl, this));
                        if (hr)
                        {
                            hr = S_OK;
                            break;
                        }
                            
                        if (S_OK == THR(CreateLinkDataObject(pchExpandedUrl, NULL, &pURLToDrag)))
                        {
                            if (!DragElement(GetUpdatedLayout(), pMessage->dwKeyState, pURLToDrag, pMessage->lSubDivision))
                            {
                                // release the capture and let someone else handle the
                                // WM_MOUSEMOVE by leaving hr=S_FALSE
                                // pDoc->SetMouseCapture(NULL,NULL);
                                TakeCapture(FALSE);
                                break;
                            }
                        }
                    }
                }
                hr = S_OK;
                break;
            }
        }
    }

    if (!hr)
        goto Cleanup;

    if (fInBrowseMode)
    {
        if (hr == S_FALSE)
        {
            CAnchorElement * pAnchorElement = GetContainingAnchor();

            if (pAnchorElement)
            {
                switch (pMessage->message)
                {

                // Need to handle 'Enter' for server-side image maps (IE5 bug #4091)                        
                case WM_CHAR:
                case WM_SYSCHAR:
                    if (pMessage->wParam == VK_RETURN && GetAAisMap())
                    {
                        // Pressing Enter is same as clicking with mouse
                        pMessage->SetNodeClk(GetFirstBranch());
                        hr = S_OK;
                    }
                    break ;
                case WM_LBUTTONDOWN:
                    // If it is not a image map then this message is really
                    // meant for the anchor element.
                    if (GetAAisMap())
                    {
                        hr = S_OK;
                         Doc()->SetMouseCapture(MOUSECAPTURE_METHOD(CImgElement, HandleCaptureMessageForImage, handlecapturemessageforimage),
                                                this);
                    }
                    else if (!HasCapture())
                    {
                        // NOTE (sujalp): We have to simulate as if the message
                        // was received by the anchor (pAnchorElement) directly and hence
                        // we pass pAnchorElement and not NULL , though it is coming via
                        // the child.
                        hr = THR (pAnchorElement->HandleMessage (pMessage)) ;
                    }
                    break;

                case WM_RBUTTONDOWN:

                    // See sujal's note, above
                    hr = THR(pAnchorElement->HandleMessage(pMessage));
                    break;

                case WM_SETCURSOR:

                    SetCursorStyle(pAnchorElement->GetHyperlinkCursor());

                    hr = pAnchorElement->GetUrlComponent(NULL, URLCOMP_WHOLE, &pchUrl);
                    if (!hr && pchUrl)
                    {
                        TCHAR *pchFriendlyUrl;
                        BOOL fShowStatusText = TRUE;
                        CDoc * pDoc = Doc();

                        if (GetAAisMap())
                        {
                            Assert(pMessage->IsContentPointValid());
                            pchFriendlyUrl = GetFriendlyUrl(
                                                    pchUrl,
                                                    pDoc->GetPrimaryUrl(),
                                                    pDoc->_pOptionSettings->fShowFriendlyUrl,
                                                    TRUE,
                                                    pMessage->ptContent.x,
                                                    pMessage->ptContent.y);
                        }
                        else
                        {
                            pchFriendlyUrl = GetFriendlyUrl(pchUrl, pDoc->GetPrimaryUrl(),
                                                            pDoc->_pOptionSettings->fShowFriendlyUrl, TRUE);

                            // if previous element under mouse is not the same as current element under the mouse,
                            // set the status text for the anchor that is under (or IS) the curent element.
                            fShowStatusText = DifferentScope(pDoc->_pNodeLastMouseOver, this);
                        }

                        if (fShowStatusText)
                        {
                            pDoc->SetStatusText(pchFriendlyUrl, STL_ROLLSTATUS, GetMarkup());
                        }

                        MemFreeString(pchFriendlyUrl);
                        MemFreeString(pchUrl);
                    }

                    hr = S_OK;
                    break;

                default:
                     ;
                }
            }

            // Prepare for drag-drop
            switch (pMessage->message)
            {
                case WM_LBUTTONDOWN:
                case WM_RBUTTONDOWN:
                    _rcWobbleZone.left   = pMessage->pt.x - g_sizeDragMin.cx;
                    _rcWobbleZone.right  = pMessage->pt.x + g_sizeDragMin.cx + 1;
                    _rcWobbleZone.top    = pMessage->pt.y - g_sizeDragMin.cy;
                    _rcWobbleZone.bottom = pMessage->pt.y + g_sizeDragMin.cy + 1;

                    // Can click while mouse is inside wobble zone
                    _fCanClickImage = TRUE;
                    break;
            }
        }
    }


    // WM_CONTEXTMENU message should always be handled.
    if (pMessage->message == WM_CONTEXTMENU)
    {
        Assert(_pImage);
        hr = THR(_pImage->ShowImgContextMenu(pMessage));
    }

    // And process the message if it hasn't been already.
    if (hr == S_FALSE)
    {
        switch (pMessage->message)
        {
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
            if (fInBrowseMode)
            {
                // if it was not NULL it was handled before
                Doc()->SetMouseCapture(
                                       MOUSECAPTURE_METHOD(CImgElement, HandleCaptureMessageForImage, handlecapturemessageforimage),
                                       this);
                hr = S_OK;
            }
            break;

#ifndef NO_MENU
        case WM_MENUSELECT:
        case WM_INITMENUPOPUP:
            hr = S_FALSE;
            break;
#endif // NO_MENU

        case WM_SETCURSOR:
            if ( (!IsEditable(/*fCheckContainerOnly*/FALSE) && ! IsMasterParentEditable()) || 
                 (Doc()->IsPointInSelection(pMessage->pt) && Doc()->GetSelectionType() == SELECTION_TYPE_Text))
            {
                SetCursorStyle(IDC_ARROW);
            }
            else 
            {
                hr = super::HandleMessage(pMessage);
                if (hr == S_FALSE)
                {
                   SetCursorStyle(IDC_SIZEALL);
                }
            }
            hr = S_OK;
            break;
        }

        if (hr == S_FALSE)
        {
            hr = THR(super::HandleMessage(pMessage));
        }
    }

Cleanup:
    
    ReleaseInterface(pURLToDrag);
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     HandleCaptureMessageForImage
//
//  Synopsis:   Tracks mouse while user is clicking on an IMG in an A
//
//  Arguments:  [pMessage]  -- message
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CImgElement::HandleCaptureMessageForImage (CMessage * pMessage)
{
    HRESULT     hr = S_OK;

    switch (pMessage->message)
    {
    case WM_LBUTTONUP:
        if (_fCanClickImage)
        {
            pMessage->SetNodeClk(GetFirstBranch());
        }
        // Fall thru

    case WM_MBUTTONUP:
    case WM_RBUTTONUP:
        TakeCapture(FALSE);
        // Doc()->SetMouseCapture(NULL, NULL);
        if (pMessage->message == WM_RBUTTONUP)
            hr = S_FALSE;
        break;

    case WM_MOUSEMOVE:
    {
        // If the user moves the mouse outside the wobble zone,
        // show the no-entry , plus disallow a subsequent OnClick
        POINT ptCursor = { LOWORD(pMessage->lParam), HIWORD(pMessage->lParam) };
        CDoc *pDoc = Doc();

        if ( _fCanClickImage && !PtInRect(&_rcWobbleZone, ptCursor))
        {
            _fCanClickImage = FALSE;
        }

        // initiate drag-drop
        if (!_fCanClickImage && !pDoc->_fIsDragDropSrc)
        {
            Assert(!pDoc->_pDragDropSrcInfo);
#ifdef NEVER
            if (!pDoc->_pElementOMCapture)
#endif
            {
                DragElement(GetUpdatedLayout(), pMessage->dwKeyState, NULL, -1);
            }
        }
        // Intentional drop through to WM_SETCURSOR - WM_SETCURSOR is NOT sent
        // while the Capture is set
    }

    case WM_SETCURSOR:
        {
            LPCTSTR idc;
            CAnchorElement * pAnchorElement = GetContainingAnchor();
            CRect   rc;


            GetUpdatedLayout()->GetClientRect(&rc);

            if (pAnchorElement && PtInRect(&rc, pMessage->ptContent))
                idc = pAnchorElement->GetHyperlinkCursor();
            else
                idc = IDC_ARROW;

            SetCursorStyle(idc);
            hr = S_OK;
        }
        break;
    }

    if (hr == S_FALSE)
        hr = THR(super::HandleMessage(pMessage));

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     HandleCaptureMessageForArea
//
//  Synopsis:   Tracks mouse while user is clicking on an IMG with an AREA
//
//  Arguments:  [pMessage]  -- message
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CImgElement::HandleCaptureMessageForArea(CMessage * pMessage)
{
    RRETURN1(HandleMessage(pMessage), S_FALSE);
}


//=------------------------------------------------------------------------=
//
// Function:    DocPtToImgPt
//
// Synopsis:    Converts the point from a position relative to the document
//              to being a position relative to the upper left corner of
//              the iamge.
//
// Arguments:   POINT *ppt - The point to be converted.
//
//=------------------------------------------------------------------------=
void
CImgElement::DocPtToImgPt(POINT *ppt)
{
// TODO: Call CDispNode::GlobalToContentPoint (brendand)
}

//+---------------------------------------------------------------------------
//
//  Member:     FindEnclosingAnchorScope
//
//  Synopsis:   Finds the enclosing <A HREF> tag
//
//  Returns:    NULL if no enclosing <A> or if enclosing <A> has no HREF
//              Otherwise, returns the enclosing <A> element
//
//----------------------------------------------------------------------------

CAnchorElement*
CImgElement::FindEnclosingAnchorScope()
{
    CTreeNode * pNode = GetFirstBranch();

    if (pNode)
    {
        for (pNode = pNode->Parent(); pNode; pNode=pNode->Parent())
        {
            if (pNode->Tag() == ETAG_A)
            {
                if (NULL != (LPTSTR) DYNCAST(CAnchorElement, pNode->Element())->GetAAhref())
                {
                    return DYNCAST(CAnchorElement, pNode->Element());
                }
                else
                {
                    return NULL;
                }
            }
            if (pNode->ShouldHaveLayout())
                break;
        }
    }

    return NULL;
}

HRESULT
CImgElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT             hr          = S_OK;
    CUnitValue          uvBorder    = GetAAborder();
    BYTE                i;
    CAnchorElement *    pAnchor     = FindEnclosingAnchorScope();
    LPCTSTR             szUseMap    = NULL;

    _fBelowAnchor = !!pAnchor;

    if (uvBorder.IsNull())
    {
        // check if the image is inside an anchor
        // or useMap is set and begin with #

        if (    _fBelowAnchor
            ||  (szUseMap = GetAAuseMap()) != NULL && _tcschr(szUseMap, _T('#')))
        {
            uvBorder.SetValue( 2, CUnitValue::UNIT_PIXELS );
        }
    }

    // Set the anchor border
    if (!uvBorder.IsNull())
    {
        COLORREF crColor;
        DWORD dwRawValue = uvBorder.GetRawValue();

        if (_fBelowAnchor)
            crColor = GetAnchorColor(pAnchor);
        else
        {
            if (szUseMap && _tcschr(szUseMap, _T('#')))
            {
                Assert(pCFI->_pNodeContext && SameScope(this, pCFI->_pNodeContext));
                CTreeNode *  pNode = pCFI->_pNodeContext->Parent();
                CColorValue  colorValue;

                while(pNode && pNode->Tag() != ETAG_BODY)
                    pNode = pNode->Parent();
                
                if (pNode)
                {
                    colorValue = DYNCAST(CBodyElement, pNode->Element())->GetAAlink();
                }

                crColor = colorValue.IsDefined() ? colorValue.GetColorRef()
                                               : Doc()->_pOptionSettings->crAnchor();
            }
            else
                crColor = 0x00000000;
        }

        pCFI->PrepareFancyFormat();
        CColorValue ccv; ccv.SetValue(crColor, FALSE);
        CUnitValue cuv; cuv.SetRawValue(dwRawValue);
        for (i = 0; i < SIDE_MAX; i++)
        {
            pCFI->_ff()._bd.SetBorderColor(i, ccv);
            pCFI->_ff()._bd.SetBorderWidth(i, cuv);
            pCFI->_ff()._bd.SetBorderStyle(i, fmBorderStyleSingle);
        }
        pCFI->UnprepareForDebug();
    }

    hr = THR(super::ApplyDefaultFormat(pCFI));
    if (hr || !_pImage)
        goto Cleanup;

    _pImage->SetImgAnim(pCFI->_pcf->IsDisplayNone()
                        || pCFI->_pcf->IsVisibilityHidden());

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CBlockElement::Save
//
//  Synopsis:   Save the tag to the specified stream.
//
//-------------------------------------------------------------------------

HRESULT
CImgElement::Save(CStreamWriteBuff * pStmWrBuff, BOOL fEnd)
{
    if (fEnd)
        return S_OK;        // No end IMG tag

    CElement * pelAnchorClose = NULL;
    HRESULT hr;

    if (pStmWrBuff->TestFlag(WBF_FOR_RTF_CONV))
    {
        //
        // RichEdit2.0 crashes when it gets rtf with nested field
        // tags (easily generated by the rtf to html converter for
        // <a><img></a> (images in anchors).  To work around this,
        // we close any anchors this image may be in before writing
        // the image tag, and reopen them immediately after.
        //
        pelAnchorClose = GetFirstBranch()->SearchBranchToFlowLayoutForTag(ETAG_A)->SafeElement();
    }

    if (pelAnchorClose)
    {
        hr = pelAnchorClose->WriteTag(pStmWrBuff, TRUE, TRUE);
        if (hr)
            goto Cleanup;
    }

    hr = super::Save(pStmWrBuff, fEnd);
    if (hr)
        goto Cleanup;

    if (pelAnchorClose)
    {
        hr = pelAnchorClose->WriteTag(pStmWrBuff, FALSE, TRUE);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     GetAnchorColor
//
//  Synopsis:   Link color for anchor is taken from body
//
//  Returns:    COLORREF
//
//----------------------------------------------------------------------------

COLORREF
CImgElement::GetAnchorColor(CAnchorElement * pAnchorElement)
{
    Assert(pAnchorElement->Tag() == ETAG_A);
    return(pAnchorElement->GetLinkColor());
}

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT
CImgElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;

    switch (dispid)
    {
    case DISPID_CImgElement_useMap:
        // Force a revalidation of the map
        EnsureMap();
        break;
    case DISPID_CImgElement_src:
        if (_pImage)
        {
            hr = _pImage->SetImgSrc(IMGF_REQUEST_RESIZE | IMGF_INVALIDATE_FRAME);
        }
        break;
    case DISPID_CImgElement_lowsrc:
        if (_pImage)
        {
            LPCTSTR szUrl = GetAAsrc();

            if (!szUrl)
            {
                Assert(_pImage);
                hr = _pImage->FetchAndSetImgCtx(GetAAlowsrc(), IMGF_REQUEST_RESIZE | IMGF_INVALIDATE_FRAME);
            }

        }
        break;

#ifndef NO_AVI
    case DISPID_CImgElement_dynsrc:
        if (_pImage)
        {
            hr = _pImage->SetImgDynsrc();
        }
        break;
#endif
    }

    if (OK(hr))
        hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));

    RRETURN(hr);
}


#ifndef NO_DATABINDING
class CDBindMethodsImg : public CDBindMethodsSimple
{
    typedef CDBindMethodsSimple super;

public:
    CDBindMethodsImg() : super(VT_BSTR, DBIND_ONEWAY) {}
    ~CDBindMethodsImg()    {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;

};

static const CDBindMethodsImg DBindMethodsImg;

const CDBindMethods *
CImgElement::GetDBindMethods()
{
    return &DBindMethodsImg;
}

//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: Transfer data into bound checkbox.  Only called if DBindKind
//            allows databinding.
//
//  Arguments:
//            [id]      - ID of binding point.  For the checkbox, is always
//                        DISPID_VALUE.
//            [pvData]  - pointer to data to transfer, in this case a boolean.
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethodsImg::BoundValueToElement(CElement *pElem,
                                      LONG,
                                      BOOL,
                                      LPVOID pvData) const
{
    // Implement in quickest, but most inefficient way possible:
    RRETURN(DYNCAST(CImgElement, pElem)->put_src(*(BSTR *)pvData));
}
#endif // ndef NO_DATABINDING


CAreaElement *
CImgElement::GetCurrentArea()
{
    CAreaElement * pArea;

    if (HasCurrency())
    {
        EnsureMap();
        if (    _pMap
            && S_OK == _pMap->GetAreaContaining(Doc()->_lSubCurrent, &pArea))
        {
            return pArea;
        }
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImgElement::QueryStatus, public
//
//  Synopsis:   Implements QueryStatus for CImgElement
//
//  Notes:      This override of CImgBase::QueryStatus allows special
//              handling of hyperlink context menu entries for images
//              with active areas in client side maps
//
//----------------------------------------------------------------------------

HRESULT
CImgElement::QueryStatus(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    int idm;

    TraceTag((tagMsoCommandTarget, "CImgElement::QueryStatus"));

    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));
    Assert(cCmds == 1);

    MSOCMD *        pCmd    = &rgCmds[0];
    HRESULT         hr      = S_OK;
    CAreaElement *  pArea   = GetCurrentArea();

    Assert(!pCmd->cmdf);

    // Give first chance to <AREA>
    if (pArea)
    {
        hr = THR_NOTRACE(pArea->QueryStatusHelper(pguidCmdGroup, cCmds, rgCmds, pcmdtext));
        if (hr || pCmd->cmdf)
            goto Cleanup;
    }

    idm = CBase::IDMFromCmdID(pguidCmdGroup, pCmd->cmdID);
    switch (idm)
    {
    case IDM_FOLLOWLINKC:
    case IDM_FOLLOWLINKN:
    case IDM_PRINTTARGET:
    case IDM_SAVETARGET:

        // Plug a ratings security hole.
        if ((idm == IDM_PRINTTARGET || idm == IDM_SAVETARGET) &&
            S_OK == AreRatingsEnabled())
        {
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
            break;
        }
        break;
    case IDM_ADDFAVORITES:
    case IDM_COPYSHORTCUT:
        {
            CAnchorElement * pAnchorElement = GetContainingAnchor();

            if (pAnchorElement && pAnchorElement->GetAAhref())
            {
                pCmd->cmdf = MSOCMDSTATE_UP;
            }
        }
        break;

    case IDM_IMAGE:
        // When a single image is selected, allow to bring up an insert image dialog
        pCmd->cmdf = MSOCMDSTATE_UP;
    }

    if (!pCmd->cmdf)
    {
        Assert(_pImage);
        hr = _pImage->QueryStatus(
                    pguidCmdGroup,
                    1,
                    pCmd,
                    pcmdtext);
        if (!pCmd->cmdf)
        {
            hr = THR_NOTRACE(super::QueryStatus(pguidCmdGroup, 1, pCmd, pcmdtext));
        }
    }

Cleanup:
    SRETURN_NOTRACE(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CImgElement::Exec, public
//
//  Synopsis:   Executes a command on the CImgElement
//
//  Notes:      This override of CImgBase::Exec allows special
//              handling of hyperlink context menu entries for images
//              with active areas in client side maps
//
//----------------------------------------------------------------------------

HRESULT
CImgElement::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    TraceTag((tagMsoCommandTarget, "CImgElement::Exec"));

    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));

    int                 idm         = CBase::IDMFromCmdID(pguidCmdGroup, nCmdID);
    HRESULT             hr          = MSOCMDERR_E_NOTSUPPORTED;
    POINT               pt;
    DWORD               dwPt;
    CAreaElement *      pArea       = GetCurrentArea();
    CAnchorElement *    pAnchorElement = GetContainingAnchor();

    // Give first chance to <AREA>
    if (pArea)
    {
        hr = THR_NOTRACE(pArea->ExecHelper(
                    pguidCmdGroup,
                    nCmdID,
                    nCmdexecopt,
                    pvarargIn,
                    pvarargOut));

        if (hr != MSOCMDERR_E_NOTSUPPORTED)
            goto Cleanup;
    }

    switch (idm)
    {
    case IDM_FOLLOWLINKC:
    case IDM_FOLLOWLINKN:
    case IDM_SAVETARGET:
    case IDM_PRINTTARGET:

        if (pAnchorElement && GetAAisMap() &&
            (idm == IDM_FOLLOWLINKC || idm == IDM_FOLLOWLINKN))
        {
            if (!pvarargIn ||  V_VT(pvarargIn) != VT_I4)
            {
                AssertSz(0, "Missing argument ptMouse for click on server-side image map");
                break;
            }
            dwPt = (DWORD)V_I4(pvarargIn);
            pt.x = MAKEPOINTS(dwPt).x;
            pt.y = MAKEPOINTS(dwPt).y;
            ScreenToClient(Doc()->_pInPlace->_hwnd, &pt);
            hr = THR(ClickOnServerMap(pt, idm == IDM_FOLLOWLINKN));
        }
        break;

    case IDM_COPYSHORTCUT:
        if (pAnchorElement && pAnchorElement->GetAAhref())
            hr = THR(pAnchorElement->CopyLinkToClipboard(GetAAalt()));
        break;

    case IDM_ADDFAVORITES:

        TCHAR   cBuf[pdlUrlLen];
        TCHAR * pszURL = cBuf;
        TCHAR * pszTitle;

        if (pAnchorElement)
        {
            CDoc * pDoc = Doc();

            hr = THR(CMarkup::ExpandUrl(NULL, 
                    pAnchorElement->GetAAhref(),
                    ARRAY_SIZE(cBuf),
                    pszURL,
                    pAnchorElement));

            pszTitle = (LPTSTR) pAnchorElement->GetAAtitle();
            if (!pszTitle)
                pszTitle = (LPTSTR) GetAAalt();
            if (!pszTitle)
                pszTitle = (LPTSTR) GetAAtitle();

            if (!hr && pszURL)
                hr = pDoc->AddToFavorites(pszURL, pszTitle);
        }
        break;
    }

    if (hr == MSOCMDERR_E_NOTSUPPORTED && _pImage)
    {
        hr = THR_NOTRACE(_pImage->Exec(
                pguidCmdGroup,
                nCmdID,
                nCmdexecopt,
                pvarargIn,
                pvarargOut));
    }

    if (hr == MSOCMDERR_E_NOTSUPPORTED)
        hr = THR_NOTRACE(super::Exec(
                pguidCmdGroup,
                nCmdID,
                nCmdexecopt,
                pvarargIn,
                pvarargOut));

Cleanup:
    SRETURN_NOTRACE(hr);
}

HRESULT
CImgElement::ClickOnServerMap(POINT pt, BOOL fOpenInNewWindow)
{
    HRESULT hr      = S_OK;
    TCHAR * szTemp  = NULL;
    CAnchorElement * pAnchorElement = GetContainingAnchor();

// TODO: Call CDispNode::GlobalToContentPoint (brendand)
// (krisma) Or should we assume that the point passed in has
// already been transformed? I vote for the latter.
    hr = THR(Format(FMT_OUT_ALLOC, &szTemp, 0,
        _T("<0s>?<1d>,<2d>"),
        (LPTSTR) pAnchorElement->GetAAhref(),
        (long)pt.x,
        (long)pt.y));
    if (hr)
        goto Cleanup;

    hr = THR(Doc()->FollowHyperlink(szTemp,
                                    (LPTSTR) pAnchorElement->GetAAtarget(),
                                    pAnchorElement,
                                    NULL,
                                    FALSE,
                                    NULL,
                                    fOpenInNewWindow,
                                    NULL,
                                    NULL,
                                    0,
                                    ERROR_SUCCESS,
                                    FALSE,
                                    NULL,
                                    FALSE,
                                    CDoc::FHL_HYPERLINKCLICK|CDoc::FHL_SETDOCREFERER));

    delete szTemp; // must delete temp string, error or no error
Cleanup:
    // Do not want this to bubble, so..
    if (S_FALSE == hr)
        hr = S_OK;
    RRETURN(hr);
}


HRESULT
CImgElement::ClickAction(CMessage * pMessage)
{
    HRESULT             hr              = S_OK;
    CAnchorElement *    pAnchorElement  = GetContainingAnchor();
    BOOL                fOpenInNewWindow;
    POINT               ptClick;

    // If we're a clientside image map, pass it to the area.
    EnsureMap();
    if (_pMap)
    {
        CAreaElement *  pArea;

        hr = THR(_pMap->GetAreaContaining(pMessage ? pMessage->lSubDivision : 0, &pArea));
        if (hr)
            goto Cleanup;

        hr = THR(pArea->ClickAction(pMessage));
        goto Cleanup;
    }

    // Don't handle clicks if not surrouneded by an anchor
    if (!pAnchorElement)
        goto Cleanup;

    // Pass click to anchor if not server-side image map

    if (!GetAAisMap())
    {
        // if we're an image w/o a map in an anchor
        // send the click to the anchor
        hr = THR(pAnchorElement->ClickAction(pMessage));

        goto Cleanup;
    }

    // We come here only when the click is on a server-side image map
    if (pMessage && (pMessage->message == WM_LBUTTONUP || pMessage->message == WM_MOUSEWHEEL))
    {
        // We came here because of mouse click
        Assert(pMessage->IsContentPointValid());
        fOpenInNewWindow = (pMessage->message != WM_MOUSEWHEEL) && (pMessage->dwKeyState & MK_SHIFT);
        ptClick = pMessage->ptContent;
    }
    else
    {
        CRect   rc;

        // We came here because of 'Enter' keystroke or the 'click' method call
        fOpenInNewWindow = FALSE;

        ptClick = g_Zero.pt;
    }

    hr = THR(ClickOnServerMap(ptClick, fOpenInNewWindow));

Cleanup:
    // Do not want this to bubble, so..
    if (S_FALSE == hr)
        hr = S_OK;

    RRETURN(hr);
}

const CImageElementFactory::CLASSDESC CImageElementFactory::s_classdesc =
{
    {
        &CLSID_HTMLImageElementFactory,      // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        NULL,                                // _apClsidPages
#endif // NO_PROPERTY_PAGE
        NULL,                                // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLImageElementFactory,       // _piidDispinterface
        &s_apHdlDescs,                       // _apHdlDesc
    },
    (void *)s_apfnIHTMLImageElementFactory,  // _apfnTearOff
};



HRESULT STDMETHODCALLTYPE
CImageElementFactory::create(VARIANT varWidth, VARIANT varHeight, IHTMLImgElement**ppnewElem )
{
    HRESULT hr;
    CElement    *pElement = NULL;
    CImgElement *pImgElem;
    CVariant varI4Width;
    CVariant varI4Height;

    // We must return into a ptr else there's no-one holding onto a ref!
    if ( !ppnewElem )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppnewElem = NULL;

    // actualy ( [ long width, long height ] )
    // Create an Image element parented to the root site

    // This is some temproary unfinished code just to test the call
    hr = THR(_pMarkup->CreateElement(ETAG_IMG, &pElement));
    if ( hr )
        goto Cleanup;

    pImgElem = DYNCAST(CImgElement, pElement);

    // Set the flag that indicates we're parented invisibly to the resize
    // this stops unpleasantness with ResizeElement.
    // TODO: Is this necessary any longer (it's a RequestResize carry-over) (brendand)
    pImgElem->_pImage->_fCreatedWithNew = TRUE;

    hr = THR(pImgElem->QueryInterface ( IID_IHTMLImgElement, (void **)ppnewElem ));

    // Set the width & height if supplied
    if (varWidth.vt != VT_EMPTY && varWidth.vt != VT_ERROR)
        pImgElem->_pImage->_fSizeInCtor = TRUE;

    hr = THR(varI4Width.CoerceVariantArg(&varWidth, VT_I4) );
    if ( hr == S_OK )
    {
        hr = pImgElem->putWidth(V_I4(&varI4Width));
    }
    if ( !OK(hr) )
        goto Cleanup;

    hr = THR(varI4Height.CoerceVariantArg(&varHeight, VT_I4) );
    if ( hr == S_OK )
    {
        hr = pImgElem->putHeight(V_I4(&varI4Height));
    }
    if ( !OK(hr) )
        goto Cleanup;

Cleanup:
    if (OK(hr))
    {
        hr = S_OK; // not to propagate possible S_FALSE
    }
    else
    {
        ReleaseInterface(*(IUnknown**)ppnewElem);
    }

    CElement::ClearPtr(&pElement);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// Member: get_mimeType
//
//----------------------------------------------------------------------------
extern BSTR GetFileTypeInfo(TCHAR * pszFileName);

STDMETHODIMP
CImgElement::get_mimeType(BSTR *pMimeType)
{
    HRESULT hr = S_OK;
    TCHAR * pchCachedFile = NULL;

    if ( !pMimeType )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *pMimeType = NULL;

    hr = _pImage->GetFile(&pchCachedFile);

    if (!hr && pchCachedFile)
    {
        *pMimeType = GetFileTypeInfo(pchCachedFile);
    }

    MemFreeString(pchCachedFile);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
// Member: get_fileSize
//
//----------------------------------------------------------------------------
STDMETHODIMP
CImgElement::get_fileSize(BSTR *pFileSize)
{
    HRESULT hr = S_OK;
    TCHAR   szBuf[64];
    TCHAR * pchCachedFile = NULL;

    if (pFileSize == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pFileSize = NULL;

    Assert(_pImage);
    hr = _pImage->GetFile(&pchCachedFile);
    if (!hr && pchCachedFile)
    {
        WIN32_FIND_DATA wfd;
        HANDLE hFind = FindFirstFile(pchCachedFile, &wfd);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);

            Format(0, szBuf, ARRAY_SIZE(szBuf), _T("<0d>"), (long)wfd.nFileSizeLow);
            *pFileSize = SysAllocString(szBuf);
        }
    }
    else
    {
        *pFileSize = SysAllocString(_T("-1"));
        hr = S_OK;
    }

Cleanup:
    MemFreeString(pchCachedFile);
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
// Member: get_fileCreatedDate
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CImgElement::get_fileCreatedDate(BSTR * pFileCreatedDate)
{
    HRESULT hr = S_OK;
    TCHAR * pchCachedFile = NULL;

    if (pFileCreatedDate == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pFileCreatedDate = NULL;

    Assert(_pImage);
    hr = _pImage->GetFile(&pchCachedFile);
    if (!hr && pchCachedFile)
    {
        WIN32_FIND_DATA wfd;
        HANDLE hFind = FindFirstFile(pchCachedFile, &wfd);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);
            // we always return the local time in a fixed format mm/dd/yyyy to make it possible to parse
            // FALSE means we do not want the time
            hr = THR(ConvertDateTimeToString(wfd.ftCreationTime, pFileCreatedDate, FALSE));
        }
    }

Cleanup:
    MemFreeString(pchCachedFile);
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
// Member: get_fileModifiedDate
//
//----------------------------------------------------------------------------
STDMETHODIMP
CImgElement::get_fileModifiedDate(BSTR * pFileModifiedDate)
{
    HRESULT hr = S_OK;
    TCHAR * pchCachedFile = NULL;

    if (pFileModifiedDate == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pFileModifiedDate = NULL;

    Assert(_pImage);
    hr = _pImage->GetFile(&pchCachedFile);
    if (!hr && pchCachedFile)
    {
        WIN32_FIND_DATA wfd;
        HANDLE hFind = FindFirstFile(pchCachedFile, &wfd);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);
             // we always return the local time in a fixed format mm/dd/yyyy to make it possible to parse
            // FALSE means we do not want the time
            hr = THR(ConvertDateTimeToString(wfd.ftLastWriteTime, pFileModifiedDate, FALSE));
        }
    }

Cleanup:
    MemFreeString(pchCachedFile);
    RRETURN(SetErrorInfo(hr));
}

// TODO (lmollico): get_fileUpdatedDate won't work if src=file://image
//+---------------------------------------------------------------------------
//
// Member: get_fileUpdatedDate
//
//----------------------------------------------------------------------------
STDMETHODIMP
CImgElement::get_fileUpdatedDate(BSTR * pFileUpdatedDate)
{
    HRESULT hr     = S_OK;
    TCHAR   cBuf[pdlUrlLen];
    TCHAR * pszUrl = cBuf;

    if (pFileUpdatedDate == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pFileUpdatedDate = NULL;

    hr = THR(CMarkup::ExpandUrl(NULL, GetAAsrc(), ARRAY_SIZE(cBuf), pszUrl, this));

    if (hr)
        goto Cleanup;

    if (pszUrl)
    {
        TCHAR                       strBuffer[MAX_CACHE_ENTRY_INFO_SIZE];

        INTERNET_CACHE_ENTRY_INFO * pInfo = (INTERNET_CACHE_ENTRY_INFO *) strBuffer;
        DWORD                       cInfo = MAX_CACHE_ENTRY_INFO_SIZE;

        if (RetrieveUrlCacheEntryFile(pszUrl, pInfo, &cInfo, 0))
        {
            // We always return the local time in a fixed format mm/dd/yyyy to 
            // make it possible to parse. FALSE means we do not want the time.

            hr = THR(ConvertDateTimeToString(pInfo->LastModifiedTime, pFileUpdatedDate, FALSE));

            DoUnlockUrlCacheEntryFile(pszUrl, 0);
        }

    }

Cleanup:

    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
// Member: get_href
//
//----------------------------------------------------------------------------
STDMETHODIMP
CImgElement::get_href(BSTR *pHref)
{
    HRESULT hr = S_OK;
    LPCTSTR pchUrl = NULL;

    if (pHref == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pHref = NULL;

#ifndef NO_AVI
    if (_pImage && _pImage->_pBitsCtx)
        pchUrl = _pImage->_pBitsCtx->GetUrl();
    else
#endif // ndef NO_AVI
        if (_pImage && _pImage->_pImgCtx)
        pchUrl = _pImage->_pImgCtx->GetUrl();

    if (pchUrl)
        *pHref = SysAllocString(pchUrl);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
// Member: get_protocol
//
//----------------------------------------------------------------------------
extern TCHAR * ProtocolFriendlyName(TCHAR * szUrl);

STDMETHODIMP
CImgElement::get_protocol(BSTR * pProtocol)
{
    HRESULT hr      = S_OK;
    LPCTSTR pchUrl  = NULL;
    TCHAR * pResult;

    if (pProtocol == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pProtocol = NULL;

#ifndef NO_AVI
    if (_pImage && _pImage->_pBitsCtx)
        pchUrl = _pImage->_pBitsCtx->GetUrl();
    else
#endif // ndef NO_AVI
    if (_pImage && _pImage->_pImgCtx)
        pchUrl = _pImage->_pImgCtx->GetUrl();

    if (pchUrl)
    {
        pResult = ProtocolFriendlyName((TCHAR *)pchUrl);
        if (pResult)
        {
            int z = (_tcsncmp(pResult, 4, _T("URL:"), -1) == 0) ? (4) : (0);
            * pProtocol = SysAllocString(pResult + z);
            SysFreeString(pResult);
        }
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));

}

//+----------------------------------------------------------------------------
//
// Member: get_nameProp
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CImgElement::get_nameProp(BSTR * pName)
{
    *pName = NULL;

    TCHAR   cBuf[pdlUrlLen];
    TCHAR   * pszUrl  = cBuf;
    TCHAR   * pszName = NULL;

    HRESULT   hr      = THR(CMarkup::ExpandUrl(NULL, GetAAsrc(), ARRAY_SIZE(cBuf), pszUrl, this));
    if (!hr)
    {
        pszName = _tcsrchr(pszUrl, _T('/'));
        if (!pszName)
            pszName = pszUrl;
        else
            pszName ++;

        * pName = SysAllocString(pszName);
    }
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------
//
//  Method:     CImgElem::GetSubdivisionCount
//
//  Synopsis:   returns the count of subdivisions
//
//-----------------------------------------------------------------------------

HRESULT
CImgElement::GetSubDivisionCount(long *pc)
{
    HRESULT hr = S_OK;

    if (IsEditable(TRUE) || !EnsureAndGetMap())
    {
        hr = THR(super::GetSubDivisionCount(pc));
        goto Cleanup;
    }

    
    *pc = _pMap->GetAreaCount();

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Method:     CImgElem::GetSubdivisionTabs
//
//  Synopsis:   returns the subdivisions tabindices
//
//-----------------------------------------------------------------------------

HRESULT
CImgElement::GetSubDivisionTabs(long *pTabs, long c)
{
    HRESULT         hr = S_OK;

    if (!c)
        goto Cleanup;

    EnsureMap();
    if (!_pMap)
        goto Cleanup;

    hr = THR(_pMap->GetAreaTabs(pTabs, c));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Method:     CImgElem::SubDivisionFromPt
//
//  Synopsis:   returns the subdivisions tabindices
//
//-----------------------------------------------------------------------------

HRESULT
CImgElement::SubDivisionFromPt(POINT pt, long *plSub)
{
    RECT            rcView;
    HRESULT         hr = S_OK;
    CLayout *       pLayout;

    Assert(GetFirstBranch());

    *plSub = -1;

    EnsureMap();
    if (!_pMap)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pLayout = GetUpdatedLayout();
    pLayout->GetClientRect(&rcView);
    if (PtInRect(&rcView, pt))
    {
        hr = THR(_pMap->GetAreaContaining(pt, plSub));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CImgElement::GetFocusShape
//
//  Synopsis:   Returns the shape of the focus outline that needs to be drawn
//              when this element has focus. This function creates a new
//              CShape-derived object. It is the caller's responsibility to
//              release it.
//
//----------------------------------------------------------------------------

HRESULT
CImgElement::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    CAreaElement *  pArea = NULL;
    HRESULT         hr = S_FALSE;
    const CParaFormat  *  pPF = GetFirstBranch()->GetParaFormat();
    BOOL            fRTL = pPF->HasRTL(FALSE);
    CLayout *       pLayout = GetUpdatedLayout();
    CSize           size = g_Zero.size;
    if(fRTL)
    {
        // we are only interested in adjusting the x positioning
        // for RTL direction.
        CRect rcClient;
        pLayout->GetClientRect(&rcClient);
        size.cx = rcClient.Width();
    }

    *ppShape = NULL;

    EnsureMap();

    if (!_pMap)
    {
        hr = THR(super::GetFocusShape(lSubDivision, pdci, ppShape));
        goto Cleanup;
    }

    hr = THR(_pMap->GetAreaContaining(lSubDivision, &pArea));
    if (hr)
        goto Cleanup;

    switch(pArea->_nShapeType)
    {
    case SHAPE_TYPE_RECT:
        {
            CRectShape * pShape = new CRectShape;

            if (!pShape)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            pShape->_rect = pArea->_coords.Rect;
            if(fRTL)
            {
                pShape->OffsetShape(-size);
            }

            *ppShape = pShape;
            break;
        }
    case SHAPE_TYPE_CIRCLE:
        {
            CCircleShape * pShape = new CCircleShape;

            if (!pShape)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            pShape->Set(pArea->_coords.Circle.lx,
                        pArea->_coords.Circle.ly,
                        pArea->_coords.Circle.lradius);
            if(fRTL)
            {
                pShape->OffsetShape(-size);
            }
            *ppShape = pShape;
            break;
        }
    case SHAPE_TYPE_POLY:
        {
            CPolyShape * pShape;

            if (pArea->_ptList.Size() < 2)
            {
                hr = S_FALSE;
                goto Cleanup;
            }

            pShape = new CPolyShape;
            if (!pShape)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            pShape->_aryPoint.Copy(pArea->_ptList, FALSE);
            if(fRTL)
            {
                pShape->OffsetShape(-size);
            }
            *ppShape = pShape;
            break;
        }
    default:
        Assert(FALSE && "Invalid Shape");
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+----------------------------------------------------------------------------
//
//  Function:   DoSubDivisionEvents
//
//  Synopsis:   Fire the specified event on the given subdivision.
//
//  Arguments:  [dispidEvent]   -- dispid of the event to fire.
//              [dispidProp]    -- dispid of prop containing event func.
//              [pvb]           -- Boolean return value
//              [pbTypes]       -- Pointer to array giving the types of parms
//              [...]           -- Parameters
//
//-----------------------------------------------------------------------------

HRESULT
CImgElement::DoSubDivisionEvents(
    long        lSubDivision,
    DISPID      dispidEvent,
    DISPID      dispidProp,
    BOOL      * pfRet)
{
    CAreaElement *  pArea;

    if (lSubDivision < 0)
        return S_OK;

    EnsureMap();
    if (   _pMap 
        && OK(_pMap->GetAreaContaining(lSubDivision, &pArea))
        && Doc() == pArea->Doc())
    {
        Assert(pArea->GetFirstBranch());
        pArea->BubbleEventHelper(
            pArea->GetFirstBranch(),
            0,
            dispidEvent,
            dispidProp,
            FALSE,
            pfRet);
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CImgElement::ShowTooltip
//
//  Synopsis:   Show the tooltip for this element.
//
//----------------------------------------------------------------------------

HRESULT
CImgElement::ShowTooltip(CMessage *pmsg, POINT pt)
{
    HRESULT         hr = S_OK;
    CAreaElement *  pArea = NULL;
    CStr            strTitle;
    BOOL            fRTL = FALSE;
    CDoc *          pDoc = Doc();

    TraceTag((tagTooltip, "IMG <%d:%d>", pt.x, pt.y));

    if (pDoc->_pInPlace == NULL)
        goto Cleanup;

    // If the mouse is on an <AREA>, show the area's tooltip
    EnsureMap();
    if (_pMap && pmsg->lSubDivision >= 0)
    {
        if (S_OK == THR(_pMap->GetAreaContaining(pmsg->lSubDivision, &pArea)))
        {
            // We only show title tooltip for area
            //

            IGNORE_HR(pArea->GetUrlTitle(&strTitle));
            if (strTitle.Length() > 0)
            {
                CRect   rc, rcImgClient;

                pArea->GetBoundingRect(&rc);

                Assert(_pImage);
                _pImage->Layout()->GetClientRect(&rcImgClient, COORDSYS_GLOBAL);
                rc.OffsetRect(rcImgClient.TopLeft().AsSize());

                if(IsRectEmpty(&rc))
                {
                    rc.left = pt.x - 10;
                    rc.right = pt.x + 10;
                    rc.top = pt.y - 10;
                    rc.bottom = pt.y + 10;
                }

                // Complex Text - determine if element is right to left for tooltip style setting
                fRTL = GetFirstBranch()->GetCharFormat()->_fRTL;

                // Ignore spurious WM_ERASEBACKGROUNDs generated by tooltips
                CServer::CLock Lock(pDoc, SERVERLOCK_IGNOREERASEBKGND);
                
                if (!pDoc->_pDocPopup)
                {
                    FormsShowTooltip(
                        strTitle,
                        pDoc->_pInPlace->_hwnd,
                        *pmsg,
                        &rc,
                        (DWORD_PTR) GetMarkup(),
                        (DWORD_PTR) this,
                        fRTL);
                }
            }
            goto Cleanup;
        }
    }

    // check to see if tooltip should display the title property
    //
    hr = THR(super::ShowTooltip(pmsg, pt));
    if (hr == S_OK)
        goto Cleanup;

    Assert(_pImage);
    hr = _pImage->ShowTooltip(pmsg, pt);

Cleanup:
    RRETURN1 (hr, S_FALSE);
}

HRESULT CImgElement::GetHeight(long *pl)
{
    VARIANT v;
    HRESULT hr;

    hr = THR(s_propdescCImgElementheight.a.HandleUnitValueProperty(
            HANDLEPROP_VALUE | (PROPTYPE_VARIANT << 16),
            &v,
            this,
            CVOID_CAST(GetAttrArray())));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&v) == VT_I4);
    Assert(pl);

    *pl = V_I4(&v);

Cleanup:
    RRETURN(hr);
}

HRESULT CImgElement::putHeight(long l)
{
    VARIANT v;

    if ( l < 0 )
        l = 0;

    V_VT(&v) = VT_I4;
    V_I4(&v) = l;

    RRETURN(s_propdescCImgElementheight.a.HandleUnitValueProperty(
            HANDLEPROP_SET | HANDLEPROP_AUTOMATION | HANDLEPROP_DONTVALIDATE | (PROPTYPE_VARIANT << 16),
            &v,
            this,
            CVOID_CAST(GetAttrArray())));
}

HRESULT CImgElement::GetWidth(long *pl)
{
    VARIANT v;
    HRESULT hr;

    hr = THR(s_propdescCImgElementwidth.a.HandleUnitValueProperty(
            HANDLEPROP_VALUE | (PROPTYPE_VARIANT << 16),
            &v,
            this,
            CVOID_CAST(GetAttrArray())));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&v) == VT_I4);
    Assert(pl);

    *pl = V_I4(&v);

Cleanup:
    RRETURN(hr);
}

HRESULT CImgElement::putWidth(long l)
{
    VARIANT v;

    if ( l < 0 )
        l = 0;

    V_VT(&v) = VT_I4;
    V_I4(&v) = l;

    RRETURN(s_propdescCImgElementwidth.a.HandleUnitValueProperty(
            HANDLEPROP_SET | HANDLEPROP_DONTVALIDATE | HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
            &v,
            this,
            CVOID_CAST(GetAttrArray())));
}

STDMETHODIMP CImgElement::put_height(long l)
{
    RRETURN(SetErrorInfoPSet(putHeight(l), DISPID_CImgElement_width));
}

STDMETHODIMP CImgElement::get_height(long *p)
{
    Assert(_pImage);
    RRETURN (_pImage->get_height(p));
}

STDMETHODIMP CImgElement::put_width(long l)
{
    RRETURN(SetErrorInfoPSet(putWidth(l), DISPID_CImgElement_width));
}

STDMETHODIMP CImgElement::get_width(long *p)
{
    Assert(_pImage);
    RRETURN (_pImage->get_width(p));
}

STDMETHODIMP
CImgElement::get_src(BSTR * pstrFullSrc)
{
    HRESULT hr;
    Assert(_pImage);
    hr = _pImage->get_src(pstrFullSrc);
    RRETURN(SetErrorInfo(hr));
}

//+------------------------------------------------------------------
//
//  member : put_src
//
//  sysnopsis : impementation of the interface src property set
//          since this is a URL property we want the crlf striped out
//
//-------------------------------------------------------------------

STDMETHODIMP
CImgElement::put_src(BSTR bstrSrc)
{
    RRETURN(SetErrorInfo(s_propdescCImgElementsrc.b.SetUrlProperty(bstrSrc,
                        this,
                        (CVoid *)(void *)(GetAttrArray()))));
}


//+----------------------------------------------------------------------------
//
// Methods:     get/set_hspace
//
// Synopsis:    hspace for aligned images is 3 pixels by default, so we need
//              a method to identify if a default value is specified.
//
//-----------------------------------------------------------------------------

STDMETHODIMP CImgElement::put_hspace(long v)
{
    return s_propdescCImgElementhspace.b.SetNumberProperty(v, this, CVOID_CAST(GetAttrArray()));
}

STDMETHODIMP CImgElement::get_hspace(long * p)
{
    HRESULT hr = s_propdescCImgElementhspace.b.GetNumberProperty(p, this, CVOID_CAST(GetAttrArray()));

    if(!hr)
        *p = *p == -1 ? 0 : *p;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member : [get_/put_] onload
//
//  synopsis : store in this element's propdesc
//
//+----------------------------------------------------------------------------

HRESULT
CImgElement:: put_onload(VARIANT v)
{
    HRESULT hr = THR(s_propdescCImgElementonload .a.HandleCodeProperty(
                HANDLEPROP_SET | HANDLEPROP_AUTOMATION |
                (PROPTYPE_VARIANT << 16),
                &v,
                this,
                CVOID_CAST(GetAttrArray())));

    RRETURN( SetErrorInfo( hr ));
}

HRESULT
CImgElement:: get_onload(VARIANT *p)
{
    HRESULT hr = THR(s_propdescCImgElementonload.a.HandleCodeProperty(
                    HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                    p,
                    this,
                    CVOID_CAST(GetAttrArray())));

    RRETURN( SetErrorInfo( hr ));
}

HRESULT
CImgElement::get_readyState(BSTR * p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr=THR(s_enumdeschtmlReadyState.StringFromEnum(_pImage->_readyStateFired, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CImgElement::get_readyState(VARIANT * pVarRes)
{
    HRESULT hr = S_OK;

    if (!pVarRes)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = get_readyState(&V_BSTR(pVarRes));
    if (!hr)
        V_VT(pVarRes) = VT_BSTR;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CImgElement::get_readyStateValue(long *plRetValue)
{
    HRESULT     hr = S_OK;

    if (!plRetValue)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plRetValue = _pImage->_readyStateFired;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


void
CImgElement::Passivate()
{
    if (_pImage)
    {
        _pImage->Passivate();
        delete _pImage;
        _pImage = NULL;
    }
    super::Passivate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\imganim.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       imganim.cxx
//
//  Contents:   Implementation of CImgAnim and CAnimSync classes
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_IMGANIM_HXX_
#define X_IMGANIM_HXX_
#include "imganim.hxx"
#endif

DeclareTag(tagImgAnim, "CImgAnim", "Trace anim");

MtDefine(CAnimSync, PerThread, "CAnimSync")
MtDefine(CAnimSync_aryClients_pv, CAnimSync, "CAnimSync::_aryClients::_pv")
MtDefine(CImgAnim, PerThread, "CImgAnim")
MtDefine(CImgAnim_aryAnimSync_pv, CImgAnim, "CImgAnim::_aryAnimSync::_pv")

BOOL
CAnimSync::IsEmpty()
{
    return _aryClients.Size() == 0;
}

CImgCtx *
CAnimSync::GetImgCtx()
{
    Assert(!IsEmpty());

    if (!IsEmpty())
    {
        CLIENT * pClient = &_aryClients[0];
        CImgCtx * pImgCtx;

        pClient->pfnCallback(pClient->pvObj, ANIMSYNC_GETIMGCTX,
                             pClient->pvArg, (void **)&pImgCtx, NULL);

        return pImgCtx;
    }
    else
        return NULL;
}

HRESULT
CAnimSync::Register(void * pvObj, DWORD_PTR dwDocId, DWORD_PTR dwImgId,
                    CAnimSync::ASCALLBACK pfnCallback, void * pvArg)
{
    CLIENT client;

    if (IsEmpty())
    {
        CImgCtx * pImgCtx;

        _dwDocId = dwDocId;
        _dwImgId = dwImgId;
        _state = ANIMSTATE_PLAY;

        pfnCallback(pvObj, ANIMSYNC_GETIMGCTX, pvArg, (void **)&pImgCtx, NULL);

        if(!pImgCtx)
            return S_FALSE;
        pImgCtx->InitImgAnimState(&_imgAnimState);
    }

    client.pvObj       = pvObj;
    client.pfnCallback = pfnCallback;
    client.pvArg       = pvArg;

    RRETURN(_aryClients.AppendIndirect(&client));
}

void
CAnimSync::Unregister(void * pvObj)
{
    int cClients = _aryClients.Size(), iClient = 0;

    for ( ; iClient < cClients; iClient++)
    {
        if (_aryClients[iClient].pvObj == pvObj)
        {
            _aryClients.Delete(iClient);
            return;
        }
    }

    AssertSz(FALSE, "CAnimSync: Could not unregister object");
}

void
CAnimSync::OnTimer(DWORD *pdwFrameTimeMS)
{
    BOOL fInvalidated;
    CImgCtx * pImgCtx = GetImgCtx();

    _fInvalidated = FALSE;

    if (pImgCtx)
    {
        if (pImgCtx->NextFrame(&_imgAnimState, GetTickCount(), pdwFrameTimeMS))
        {
            int       cClients = _aryClients.Size();
            CLIENT *  pClient  = _aryClients;

            for ( ; cClients > 0; cClients--, pClient++ )
            {
                pClient->pfnCallback(pClient->pvObj, ANIMSYNC_TIMER,
                                     pClient->pvArg, (void **) &fInvalidated,
                                     &_imgAnimState);

                if (fInvalidated)
                    _fInvalidated = TRUE;

                TraceTag((tagImgAnim, "DrawFrame\n"));
            }

            if (_imgAnimState.fStop)
            {
                _state = ANIMSTATE_STOP;
                _imgAnimState.fStop = FALSE;
            }
        }
    }
    else
        *pdwFrameTimeMS = 0xFFFFFFFF;
}

void
CAnimSync::Invalidate()
{
    int       cClients = _aryClients.Size();
    CLIENT *  pClient  = _aryClients;
    BOOL      fInvalidated;

    _fInvalidated = FALSE;

    for ( ; cClients > 0; cClients--, pClient++ )
    {
        pClient->pfnCallback(pClient->pvObj, ANIMSYNC_INVALIDATE,
                             pClient->pvArg, (void **) &fInvalidated, NULL);

        if (fInvalidated)
            _fInvalidated = TRUE;
    }
}

void
CAnimSync::Update(HWND *pHwnd)
{
    int       cClients = _aryClients.Size();
    CLIENT *  pClient  = _aryClients;
    HWND      hwnd     = NULL;
    HWND      hwndPrev = *pHwnd;

    for ( ; cClients > 0; cClients--, pClient++ )
    {
        pClient->pfnCallback(pClient->pvObj, ANIMSYNC_GETHWND,
                             pClient->pvArg, (void **) &hwnd, NULL);

        if (hwnd && (hwnd != hwndPrev))
        {
            UpdateWindow(hwnd);
            hwndPrev = hwnd;
        }
    }

    if (hwnd)
        *pHwnd = hwnd;
}

void KillImgAnimTimerProc()
{
    KillTimer(TLS(gwnd.hwndGlobalWindow), TIMER_IMG_ANIM);  
}

void RestartImgAnimTimerProc()
{
    if (TLS(pImgAnim))
        TLS(pImgAnim)->OnTimer();
}

VOID CALLBACK ImgAnimTimerProc(HWND hWnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    Assert(TLS(pImgAnim));

    if (TLS(pImgAnim))
        TLS(pImgAnim)->OnTimer();
}

CImgAnim * GetImgAnim()
{
    return TLS(pImgAnim);
}

CImgAnim * CreateImgAnim()
{
    if (TLS(pImgAnim) == NULL)
    {
        TLS(pImgAnim) = new CImgAnim();
    }

    return TLS(pImgAnim);
}

void DeinitImgAnim(THREADSTATE *pts)
{
    delete pts->pImgAnim;
    pts->pImgAnim = NULL;
}

CImgAnim::CImgAnim()
    : _aryAnimSync(Mt(CImgAnim_aryAnimSync_pv))
{
    _dwInterval = 0xFFFFFFFF;
}

CImgAnim::~CImgAnim()
{
    KillTimer(TLS(gwnd.hwndGlobalWindow), TIMER_IMG_ANIM);
    Assert(_aryAnimSync.Size() == 0);
}

void
CImgAnim::SetInterval(DWORD dwInterval)
{
    _dwInterval = dwInterval;

    if (dwInterval == 0xFFFFFFFF)
    {
        KillTimer(TLS(gwnd.hwndGlobalWindow), TIMER_IMG_ANIM);
    }
    else
    {
        // Windows NT rounds the time up to 10.  If time is less
        // than 10, NT spews to the debugger.  Work around
        // this problem by rounding up to 10.

        if (dwInterval < 10)
            dwInterval = 10;

        SetTimer(TLS(gwnd.hwndGlobalWindow), TIMER_IMG_ANIM, dwInterval, &ImgAnimTimerProc);
    }
}

void
CImgAnim::SetAnimState(DWORD_PTR dwDocId, ANIMSTATE state)
{
    int cAnimSync;
    CAnimSync **ppAnimSync;
    BOOL fPlay = FALSE;

    for (cAnimSync = _aryAnimSync.Size(), ppAnimSync = _aryAnimSync;
         cAnimSync > 0;
         cAnimSync--, ppAnimSync++)
    {
        if (    *ppAnimSync
            && (*ppAnimSync)->_dwDocId == dwDocId
            && (*ppAnimSync)->_state != ANIMSTATE_STOP)
        {
            (*ppAnimSync)->_state = state;
            if (state == ANIMSTATE_PLAY)
                fPlay = TRUE;
        }
    }
    if (fPlay)
        OnTimer();
}

CAnimSync *
CImgAnim::GetAnimSync(LONG lCookie)
{
    Assert(lCookie > 0 && lCookie <= _aryAnimSync.Size());
    Assert(_aryAnimSync[lCookie - 1]);

    return _aryAnimSync[lCookie - 1];
}

IMGANIMSTATE *
CImgAnim::GetImgAnimState(LONG lCookie)
{
    return &(GetAnimSync(lCookie)->_imgAnimState);
}

HRESULT
CImgAnim::FindOrCreateAnimSync(DWORD_PTR dwDocId, DWORD_PTR dwImgId, LONG * plCookie, CAnimSync ** ppAnimSyncOut)
{
    int cAnimSync;
    CAnimSync **ppAnimSync;
    HRESULT hr = S_OK;

    for (cAnimSync = _aryAnimSync.Size(), ppAnimSync = _aryAnimSync;
         cAnimSync > 0;
         cAnimSync--, ppAnimSync++)
    {
        if (    *ppAnimSync
            && (*ppAnimSync)->_dwDocId == dwDocId
            && (*ppAnimSync)->_dwImgId == dwImgId)
        {
            *ppAnimSyncOut = *ppAnimSync;
            *plCookie = _aryAnimSync.Size() - cAnimSync + 1;
            goto Cleanup;
        }
    }

    *ppAnimSyncOut = new CAnimSync();
    if (!*ppAnimSyncOut)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = _aryAnimSync.Append(*ppAnimSyncOut);
    if (hr)
        goto Cleanup;

    *plCookie = _aryAnimSync.Size();

Cleanup:
    RRETURN(hr);
}

HRESULT
CImgAnim::RegisterForAnim(void * pvObj, DWORD_PTR dwDocId, DWORD_PTR dwImgId,
                          CAnimSync::ASCALLBACK pfnCallback,
                          void * pvArg,
                          LONG * plCookie)
{
    HRESULT hr;
    CAnimSync * pAnimSync;

    hr = FindOrCreateAnimSync(dwDocId, dwImgId, plCookie, &pAnimSync);
    if (hr)
        goto Cleanup;

    hr = pAnimSync->Register(pvObj, dwDocId, dwImgId, pfnCallback, pvArg);
    if (hr)
    {
        if (pAnimSync->IsEmpty())
        {
            CleanupAnimSync(*plCookie);
        }
        *plCookie = 0;
        goto Cleanup;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

void
CImgAnim::CleanupAnimSync(LONG lCookie)
{
    Assert(lCookie > 0 && lCookie <= _aryAnimSync.Size());

    CAnimSync ** ppAnimSync = &_aryAnimSync[lCookie - 1];
    CAnimSync * pAnimSync = *ppAnimSync;

    if (pAnimSync && pAnimSync->IsEmpty())
    {
        delete pAnimSync;
        *ppAnimSync = NULL;

        if (lCookie == _aryAnimSync.Size())
        {
            for (; lCookie-- > 0 && *ppAnimSync == NULL; --ppAnimSync)
            {
                _aryAnimSync.Delete(lCookie);
            }
        }
    }
}

void
CImgAnim::UnregisterForAnim(void * pvObj, LONG lCookie)
{
    CAnimSync * pAnimSync = GetAnimSync(lCookie);

    if (pAnimSync)
    {
        pAnimSync->Unregister(pvObj);
        CleanupAnimSync(lCookie);
    }
}

void
CImgAnim::OnTimer()
{
    int cAnimSync;
    CAnimSync **ppAnimSync;
    DWORD dwInterval = 0xFFFFFFFF;
    DWORD dwFrameTimeMS;
    HWND hwnd = NULL;

    for (cAnimSync = _aryAnimSync.Size(), ppAnimSync = _aryAnimSync;
         cAnimSync > 0;
         cAnimSync--, ppAnimSync++)
    {
        if (*ppAnimSync && ((*ppAnimSync)->_state == ANIMSTATE_PLAY))
        {
            (*ppAnimSync)->OnTimer(&dwFrameTimeMS);

            if (dwFrameTimeMS < dwInterval)
                dwInterval = dwFrameTimeMS;
        }
    }

    for (cAnimSync = _aryAnimSync.Size(), ppAnimSync = _aryAnimSync;
         cAnimSync > 0;
         cAnimSync--, ppAnimSync++)
    {
        if (*ppAnimSync && ((*ppAnimSync)->_state == ANIMSTATE_PLAY) && (*ppAnimSync)->_fInvalidated)
        {
            (*ppAnimSync)->Update(&hwnd);
        }
    }

    SetInterval(dwInterval);
}

void
CImgAnim::ProgAnim(LONG lCookie)
{
    CAnimSync * pAnimSync = GetAnimSync(lCookie);
    DWORD dwFrameTimeMS;

    if (pAnimSync && (pAnimSync->_state == ANIMSTATE_PLAY))
    {
        CImgCtx * pImgCtx = pAnimSync->GetImgCtx();

        if (pImgCtx)
        {
            if (pImgCtx->NextFrame(GetImgAnimState(lCookie), GetTickCount(), &dwFrameTimeMS))
            {
                pAnimSync->Invalidate();
            }

            if (dwFrameTimeMS < _dwInterval)
                SetInterval(dwFrameTimeMS);
        }
    }
}

void
CImgAnim::StopAnim(LONG lCookie)
{
    CAnimSync * pAnimSync = GetAnimSync(lCookie);

    if (pAnimSync)
    {
        pAnimSync->_state = ANIMSTATE_STOP;
    }
}

void
CImgAnim::StartAnim(LONG lCookie)
{
    CAnimSync * pAnimSync = GetAnimSync(lCookie);

    if (pAnimSync && (pAnimSync->_state != ANIMSTATE_PLAY))
    {
        pAnimSync->_state = ANIMSTATE_PLAY;
        OnTimer();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\imghlper.cxx ===
//+---------------------------------------------------------------------
//
//  File:       imghlper.cxx
//
//  Contents:   Img helper class, etc..
//
//  Classes:    CImgHelper, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SHFOLDER_H_
#define X_SHFOLDER_H_
#include "shfolder.h"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_IMGHLPER_HXX_
#define X_IMGHLPER_HXX_
#include "imghlper.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_IMGANIM_HXX_
#define X_IMGANIM_HXX_
#include "imganim.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_TYPES_H_
#define X_TYPES_H_
#include "types.h" // for s_enumdeschtmlReadyState
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_MMPLAY_HXX_
#define X_MMPLAY_HXX_
#include "mmplay.hxx"
#endif

#ifndef X_TASKMAN_HXX_
#define X_TASKMAN_HXX_
#include "taskman.hxx"
#endif

#ifndef X_IMGART_HXX_
#define X_IMGART_HXX_
#include "imgart.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X__DXFROBJ_H_
#define X__DXFROBJ_H_
#include "_dxfrobj.h" // for cf_HTML
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_IMGLYT_HXX_
#define X_IMGLYT_HXX_
#include "imglyt.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include "_txtsave.h"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

#ifndef X_SELECOBJ_HXX_
#define X_SELECOBJ_HXX_
#include "selecobj.hxx"
#endif

#ifndef X_TABLE_HXX_
#define X_TABLE_HXX_
#include "table.hxx"
#endif

extern BOOL g_fScreenReader;
extern BYTE g_bJGJitState;

extern void SetCachedImageSize(LPCTSTR pchURL, SIZE size);
extern BOOL GetCachedImageSize(LPCTSTR pchURL, SIZE *psize);
#ifndef NO_ART
extern NEWIMGTASKFN NewImgTaskArt;
#endif

extern HRESULT
CreateImgDataObject(CDoc * pDoc, CImgCtx * pImgCtx, CBitsCtx * pBitsCtx,
                    CElement * pElement, CGenDataObject ** ppImgDO);

DWORD g_dwImgIdInc = 0x80000000;

DeclareTag(tagImgBase, "CImgHelper", "Trace events");
DeclareTag(tagNoImgAnim, "CImgHelper", "No Image animation");
DeclareTag(tagImgAnimDirect, "CImgHelper", "Draw img anim frames directly");
ExternTag(tagMsoCommandTarget);

MtDefine(CImgHelperGetUrl, Utilities, "CImgHelper::GetUrl")

#ifndef NO_AVI
ATOM GetWndClassAtom(UINT uIndex);
LRESULT CALLBACK ActiveMovieWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#endif // ndef NO_AVI

ExternTag(tagLayoutTasks);


static void CopyDibToClipboard(CImgCtx * pImgCtx, CGenDataObject * pDO)
{
    HRESULT hr;
    HGLOBAL hgDib = NULL;
    IStream *pStm = NULL;

    Assert(pImgCtx && pDO);

    hr = CreateStreamOnHGlobal(NULL, FALSE, &pStm);
    if (hr)
        goto Cleanup;
    hr = pImgCtx->SaveAsBmp(pStm, FALSE);

    GetHGlobalFromStream(pStm, &hgDib);

    if (!hr && hgDib)
    {
        pDO->AppendFormatData(CF_DIB, hgDib);
        hgDib = NULL;
    }

Cleanup:
    if (hgDib)
        GlobalFree(hgDib);
    ReleaseInterface(pStm);
}

static void CopyHtmlToClipboard(CElement * pElement, CGenDataObject * pDO)
{
    HRESULT hr;
    CDoc *  pDoc;
    HGLOBAL hgHTML = NULL;
    IStream *pStm = NULL;

    Assert(pElement && pDO);
    pDoc = pElement->Doc();

    CMarkupPointer  mpStart(pDoc), mpEnd(pDoc);

    hr = CreateStreamOnHGlobal(NULL, FALSE, &pStm);
    if (hr)
        goto Cleanup;

    hr = mpStart.MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeBegin);
    if (hr)
        goto Cleanup;
    hr = mpEnd.MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd);
    if (hr)
        goto Cleanup;

    {
        CStreamWriteBuff    StreamWriteBuff(pStm, CP_UTF_8);

        hr = THR( StreamWriteBuff.Init() );
        if( hr )
            goto Cleanup;

        CRangeSaver         rs(
                                &mpStart,
                                &mpEnd,
                                RSF_CFHTML,
                                &StreamWriteBuff,
                                mpStart.Markup());

        StreamWriteBuff.SetFlags(WBF_NO_NAMED_ENTITIES);
        hr = THR(rs.Save());
        if (hr)
            goto Cleanup;
        StreamWriteBuff.Terminate();    // appends a null character
    }

    GetHGlobalFromStream(pStm, &hgHTML);

    if (hgHTML)
    {
        pDO->AppendFormatData(cf_HTML, hgHTML);
    }

Cleanup:
    ReleaseInterface(pStm);
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateImgDataObject
//
//  Synopsis:   Create an image data object (supports CF_HDROP, CF_HTML & CF_DIB formats)
//
//----------------------------------------------------------------------------
HRESULT
CreateImgDataObject(CDoc * pDoc, CImgCtx * pImgCtx, CBitsCtx * pBitsCtx,
                    CElement * pElement, CGenDataObject ** ppImgDO)
{
    HRESULT          hr;
    TCHAR *          pchPath = NULL;
    CGenDataObject * pImgDO = NULL;
    IDataObject *    pDO = NULL;

    if (!pImgCtx && !pBitsCtx)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pImgDO = new CGenDataObject(pDoc);
    if (!pImgDO)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Add CF_HDROP format
    if (pBitsCtx)
        hr = pBitsCtx->GetFile(&pchPath);
    else
        hr = pImgCtx->GetFile(&pchPath);
    if (!hr)
        CopyFileToClipboard(pchPath, pImgDO);

    // Add CF_DIB format
    if (pImgCtx && !pBitsCtx)
        CopyDibToClipboard(pImgCtx, pImgDO);

    // Add CF_HTML format
    if (pElement)
        CopyHtmlToClipboard(pElement, pImgDO);

    if (ppImgDO)
    {
        *ppImgDO = pImgDO;
        pImgDO = NULL;
        hr = S_OK;
    }
    else
    {
        // Tell the shell that we want a copy, not a move
        pImgDO->SetPreferredEffect(DROPEFFECT_COPY);

        hr = THR(pImgDO->QueryInterface(IID_IDataObject, (void **)&pDO));
        if (hr)
            goto Cleanup;
        
        // TODO : FerhanE: 
        // With native frames, the SetClipboard was left on the CDoc and that is a security issue.
        // I am moving it to the window. All places but the background image security check passes
        // an owner element, but that one seems to not pass one on purpose. Not clear what the 
        // reasoning is. For now, I am plugging everything but that. I can not think of an exploit on this.
        //
        // We need to make it so that we have a CWindow pointer in this function as a better and long term solution.
        //
        if (pElement)
        {
            CWindow * pWindow = pElement->GetCWindowPtr();

            if (pWindow)
                hr = THR(pWindow->SetClipboard(pDO));
        }
    }

Cleanup:
    // cast to disambiguate between IUnknown's of IDataObject and IDropSource
    ReleaseInterface((IDataObject *) pImgDO);
    ReleaseInterface(pDO);
    MemFreeString(pchPath);
    RRETURN(hr);
}


#define IMP_IMG_FIRE_BOOL(eventName)\
    BOOL CImgHelper::Fire_##eventName() \
    { \
        Assert(_pOwner); \
        if (_fIsInputImage) \
        { \
            return DYNCAST(CInput, _pOwner)->Fire_##eventName(); \
        } \
        else \
        {\
            return DYNCAST(CImgElement, _pOwner)->Fire_##eventName(); \
        }\
    }

#define IMP_IMG_FIRE_VOID(eventName)\
    void CImgHelper::Fire_##eventName() \
    { \
        Assert(_pOwner); \
        if (_fIsInputImage) \
        { \
            DYNCAST(CInput, _pOwner)->Fire_##eventName(); \
        } \
        else \
        {\
            DYNCAST(CImgElement, _pOwner)->Fire_##eventName(); \
        }\
    }

#define IMP_IMG_GETAA(returnType, propName)\
    returnType CImgHelper::GetAA##propName () const \
    { \
        Assert(_pOwner); \
        if (_fIsInputImage) \
        { \
            return DYNCAST(CInput, _pOwner)->GetAA##propName(); \
        } \
        else\
        {\
            return DYNCAST(CImgElement, _pOwner)->GetAA##propName(); \
        }\
    }

#define IMP_IMG_SETAA(paraType, propName)\
    HRESULT CImgHelper::SetAA##propName (paraType pv) \
    { \
        Assert(_pOwner); \
        if (_fIsInputImage) \
        { \
            return DYNCAST(CInput, _pOwner)->SetAA##propName(pv); \
        } \
        else\
        {\
            return DYNCAST(CImgElement, _pOwner)->SetAA##propName(pv); \
        }\
    }

    IMP_IMG_GETAA (LPCTSTR, alt);

    IMP_IMG_GETAA (LPCTSTR, src);
    IMP_IMG_SETAA (LPCTSTR, src);

    IMP_IMG_GETAA (CUnitValue, border);
    IMP_IMG_GETAA (long, vspace);
    IMP_IMG_GETAA (long, hspace);
    IMP_IMG_GETAA (LPCTSTR, lowsrc);
    IMP_IMG_GETAA (LPCTSTR, vrml);
    IMP_IMG_GETAA (LPCTSTR, dynsrc);
    IMP_IMG_GETAA (htmlStart, start);

    IMP_IMG_GETAA (VARIANT_BOOL, complete);
    IMP_IMG_SETAA (VARIANT_BOOL, complete);

    IMP_IMG_GETAA (long, loop);
    IMP_IMG_GETAA (LPCTSTR, onload);
    IMP_IMG_GETAA (LPCTSTR, onerror);
    IMP_IMG_GETAA (LPCTSTR, onabort);
    IMP_IMG_GETAA (LPCTSTR, name);
    IMP_IMG_GETAA (LPCTSTR, title);
    IMP_IMG_GETAA (VARIANT_BOOL, cache);

    IMP_IMG_FIRE_VOID (onerror);
    IMP_IMG_FIRE_VOID (onload);
    IMP_IMG_FIRE_VOID (onabort);
    IMP_IMG_FIRE_VOID (onreadystatechange);
    IMP_IMG_FIRE_BOOL (onbeforecopy);
    IMP_IMG_FIRE_BOOL (onbeforepaste);
    IMP_IMG_FIRE_BOOL (onbeforecut);
    IMP_IMG_FIRE_BOOL (oncut);
    IMP_IMG_FIRE_BOOL (oncopy);
    IMP_IMG_FIRE_BOOL (onpaste);

CImageLayout *CImgHelper::Layout( CLayoutContext *pLayoutContext /*=NULL*/)
{
    Assert(_pOwner);

    // Return null if we are not rendering the image, i.e. we don't have a CImageLayout
    if (_pOwner->HasSlavePtr())
        return NULL;

    return DYNCAST(CImageLayout ,_pOwner->GetUpdatedLayout( pLayoutContext ));
}

void
CImgHelper::SetImgAnim(BOOL fDisplayNoneOrHidden)
{
    if (!!_fDisplayNoneOrHidden != !!fDisplayNoneOrHidden)
    {
        _fDisplayNoneOrHidden = fDisplayNoneOrHidden;

        if (_fAnimated)
        {
            if (_fDisplayNoneOrHidden)
            {
                if (_lCookie)
                {
                    CImgAnim * pImgAnim = GetImgAnim();

                    if (pImgAnim)
                    {
                        pImgAnim->UnregisterForAnim(this, _lCookie);
                        _lCookie = 0;
                    }
                }
            }
            else
            {
                CImgAnim * pImgAnim = CreateImgAnim();

                if (pImgAnim)
                {
                    if (!_lCookie)
                        pImgAnim->RegisterForAnim(this, (DWORD_PTR) Doc(), g_dwImgIdInc++,
                                                  OnAnimSyncCallback, NULL, &_lCookie);

                    if (_lCookie)
                        pImgAnim->ProgAnim(_lCookie);
                }
            }
        }
    }
}

CImgHelper::CImgHelper (CDoc *pDoc, CSite *pSite, BOOL fIsInput)
{
    _pOwner = pSite;
    _fIsInputImage = fIsInput;
    _fIsInPlace = pDoc ? pDoc->State() >= OS_INPLACE : FALSE;
    _fExpandAltText = (pDoc && pDoc->_pOptionSettings) ?
            (g_fScreenReader || pDoc->_pOptionSettings->fExpandAltText)
            && !pDoc->_pOptionSettings->fShowImages
        : FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     EnterTree
//
//-------------------------------------------------------------------------
HRESULT
CImgHelper::EnterTree()
{
    HRESULT hr = S_OK;
    TCHAR   cBuf[pdlUrlLen];
    TCHAR * pchNewUrl = cBuf;
    CDoc * pDoc = Doc();

    _fIsInPlace = pDoc->State() >= OS_INPLACE;

    if (_readyStateImg == READYSTATE_COMPLETE)
        goto Cleanup;
    //
    // If we are currently doing markup services parsing, we may want to absolutify
    // the src for this image.
    //

    if (_pOwner->GetMarkup()->_fMarkupServicesParsing && pDoc->_fPasteIE40Absolutify && !pDoc->_fNoFixupURLsOnPaste)
    {
        LPCTSTR szUrl;

        Assert( !IsInPrimaryMarkup() );

        if ((szUrl = GetAAsrc()) != NULL && *szUrl)
        {
            hr = THR(
                CMarkup::ExpandUrl(_pOwner->GetMarkup()->GetFrameOrPrimaryMarkup(),
                    szUrl, ARRAY_SIZE(cBuf), pchNewUrl, _pOwner,
                    URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE,
                    LPTSTR( pDoc->_cstrPasteUrl)));
            if (hr)
                goto Cleanup;

            hr = THR( SetAAsrc( pchNewUrl ) );

            if (hr)
                goto Cleanup;
        }
    }

    if (!_pOwner->GetMarkup()->_fInnerHTMLMarkup)
    {
        _fCache = GetAAcache();

        // Ignore HR for the following two cases:
        // if load fails for security or other reason, it's not a problem for Init2
        // of the img element.

        IGNORE_HR(SetImgDynsrc());
        IGNORE_HR(SetImgSrc(IMGF_DEFER_ONWDWNCHAN));    // Don't request resize; don't invalidate frame
    }

Cleanup:

    RRETURN(hr);
}

void
CImgHelper::ExitTree(CNotification * pnf)
{
    CImgCtx * pImgCtx = GetImgCtx();

#ifndef NO_AVI
    if ((_pVideoObj || _hwnd) && !pnf->IsSecondChance())
    {
        pnf->SetSecondChanceRequested();
        return;
    }
#endif

    if (_fIsInPlace)
    {
        _fIsInPlace = FALSE;
        SetActivity();
    }

#ifndef NO_AVI
    SetVideo();
    if (_pVideoObj)
    {
        _pVideoObj->Release();
        _pVideoObj = NULL;
    }
    if (_hwnd)
    {
        DestroyWindow(_hwnd);
        _hwnd = NULL;
    }
#endif // ndef NO_AVI

    if (_pImgCtx && _lCookie)
    {
        CImgAnim * pImgAnim = GetImgAnim();

        if (pImgAnim)
        {
            pImgAnim->UnregisterForAnim(this, _lCookie);
            _lCookie = 0;
            //
            // make sure undo can register animation again
            //
            _fDisplayNoneOrHidden = !_fDisplayNoneOrHidden;
        }
    }

    if( _readyStateImg < READYSTATE_COMPLETE && pnf->IsSecondChance())
    {
        SetImgCtx(NULL, 0);
        SetBitsCtx(NULL);
    }
    else if( pImgCtx )
    {
        pImgCtx->Disconnect();
    }

    if (_hbmCache)
    {
        DeleteObject(_hbmCache);
        _hbmCache = NULL;
    }    
}

//+------------------------------------------------------------------------
//
//  Member:     FetchAndSetImgCtx
//
//-------------------------------------------------------------------------

HRESULT
CImgHelper::FetchAndSetImgCtx(const TCHAR *pchUrl, DWORD dwSetFlags)
{
    CImgCtx *pImgCtx;
    HRESULT hr;

    BOOL fPendingRoot = FALSE;

    if (IsInMarkup())
    {
        fPendingRoot = _pOwner->GetMarkup()->IsPendingRoot();
    }

    hr = THR(Doc()->NewDwnCtx(DWNCTX_IMG, pchUrl, _pOwner, (CDwnCtx **)&pImgCtx, fPendingRoot));

    if (hr == S_OK)
    {
        SetImgCtx(pImgCtx, dwSetFlags);

        if (pImgCtx)
            pImgCtx->Release();
    }

    RRETURN(hr);
}

HRESULT
CImgHelper::SetImgSrc(DWORD dwSetFlags)
{
    HRESULT hr;
    LPCTSTR szUrl = GetAAsrc();

    if (szUrl)
        hr = FetchAndSetImgCtx(szUrl, dwSetFlags);
    else
        hr = FetchAndSetImgCtx(GetAAlowsrc(), dwSetFlags);

    RRETURN(hr);
}

BOOL MarkupCanAccessLocalUrl(CMarkup *pMarkup, LPCTSTR szUrl)
{
    DWORD   dwZone;
    IInternetSecurityManager *pSecurityManager;
    TCHAR szExpandedURL[pdlUrlLen];
    HRESULT hr;

    if (!pMarkup)
        return FALSE;

    pSecurityManager = pMarkup->GetSecurityManager();

    if (!pSecurityManager)
        return FALSE;

    hr = THR(CMarkup::ExpandUrl(pMarkup, szUrl, ARRAY_SIZE(szExpandedURL), szExpandedURL, NULL));
    if (SUCCEEDED(hr))
    {
        pSecurityManager->MapUrlToZone(szExpandedURL, &dwZone, 0);

        if (dwZone == URLZONE_LOCAL_MACHINE)
        {
            pSecurityManager->MapUrlToZone(CMarkup::GetUrl(pMarkup), &dwZone, 0);
            if (dwZone != URLZONE_LOCAL_MACHINE)
                return FALSE;
        }
    }

    return TRUE;
}

HRESULT
CImgHelper::SetImgDynsrc()
{
    HRESULT hr = S_OK;
    LPCTSTR szDynSrcUrl;

    if (!(Doc()->_dwLoadf  & DLCTL_VIDEOS ))
        goto Cleanup;

    szDynSrcUrl = GetAAdynsrc();
    if (szDynSrcUrl)
    {
        CBitsCtx *pBitsCtx = NULL;

        BOOL fPendingRoot = FALSE;

        if (IsInMarkup())
        {
            CMarkup *pMarkup = _pOwner->GetMarkup();

            fPendingRoot = pMarkup->IsPendingRoot();
            if (!MarkupCanAccessLocalUrl(pMarkup, szDynSrcUrl))
                hr = E_ACCESSDENIED;
        }

        if (hr == S_OK)
            hr = THR(Doc()->NewDwnCtx(DWNCTX_FILE, szDynSrcUrl,
            _pOwner, (CDwnCtx **)&pBitsCtx, fPendingRoot));

        if (hr == S_OK)
        {
            SetBitsCtx(pBitsCtx);

            if (pBitsCtx)
                pBitsCtx->Release();
        }
    }

Cleanup:
    RRETURN(hr);
}

// if pImgCtx is not secure and the document is secure, hide for security

SSL_SECURITY_STATE SecStateFromSecFlags(DWORD dwFlags);

void
CImgHelper::UpdateHideForSecurity()
{
    DWORD sf;
    SSL_SECURITY_STATE sss;
    SSL_PROMPT_STATE sps;
    BOOL fPendingRoot = FALSE;
    BOOL fHide = FALSE;

    if (!_pImgCtx)
        goto Decided;

    if (IsInMarkup())
    {
        fPendingRoot = _pOwner->GetMarkup()->IsPendingRoot();
    }

    Doc()->GetRootSslState(fPendingRoot, &sss, &sps);

    if (sss >= SSL_SECURITY_SECURE)
    {
        sf = _pImgCtx->GetSecFlags();

        if (SecStateFromSecFlags(sf) < SSL_SECURITY_SECURE)
        {
            // If document is secure and image was not secure, hide image
            // and show placeholder so that we can't be spoofed

            // (This strategy is only used when an unsecure image was not loaded
            // successfully)

            fHide = TRUE;
        }
    }

Decided:
    if (!!fHide != !!_fHideForSecurity)
    {
        _fHideForSecurity = fHide;
        if (ShouldHaveLayout())
            InvalidateFrame();
    }
}

void
CImgHelper::InvalidateFrame()
{
    // Do nothing if we are not rendering the image, i.e. we don't have CImageLayout
    if (_pOwner->HasSlavePtr())
        return;

    CRect   rcImg;
    if (_fIsInputImage)
    {
        DYNCAST(CInput, _pOwner)->_pImage->GetRectImg(&rcImg);
    }
    else
    {
        DYNCAST(CImgElement, _pOwner)->_pImage->GetRectImg(&rcImg);
    }
    Layout()->Invalidate(&rcImg);
}



void
CImgHelper::SetImgCtx(CImgCtx * pImgCtx, DWORD dwSetFlags)
{
    if (_pImgCtx && _lCookie)
    {
        CImgAnim * pImgAnim = GetImgAnim();

        if (pImgAnim)
        {
            pImgAnim->UnregisterForAnim(this, _lCookie);
            _lCookie = 0;
        }
    }
    _fAnimated = FALSE;

    if (pImgCtx)
    {
        ULONG ulChgOn = IMGCHG_COMPLETE;
        CDoc *pDoc = Doc();

        if (_fIsActive)
            ulChgOn |= IMGCHG_VIEW;
        if (    pDoc->_pOptionSettings
            &&  pDoc->_pOptionSettings->fPlayAnimations 
            && !_pOwner->IsPrintMedia() )
#if DBG==1
        if (!IsTagEnabled(tagNoImgAnim))
#endif
            ulChgOn |= IMGCHG_ANIMATE;

        SIZE sizeImg;
        BOOL fSelectSizeChange = TRUE;
        if ((_fCreatedWithNew || !IsInMarkup()) && !_fSizeInCtor && GetCachedImageSize(pImgCtx->GetUrl(), &sizeImg))
        {
            putWidth(sizeImg.cx);
            putHeight(sizeImg.cy);
            fSelectSizeChange = FALSE;
        }

        ulChgOn |= (((_fCreatedWithNew || !IsInMarkup()) && !_fSizeInCtor && fSelectSizeChange) ? IMGCHG_SIZE : 0);

        // also need size if we've gone through CalcSize without an ImgCtx already
        ulChgOn |= (_fNeedSize ? IMGCHG_SIZE : 0);

        SetReadyStateImg(READYSTATE_UNINITIALIZED);

        pImgCtx->SetCallback(OnDwnChanCallback, this);
        pImgCtx->SelectChanges(ulChgOn, 0, TRUE);
        if (!(pImgCtx->GetState(FALSE, NULL) & (IMGLOAD_COMPLETE | IMGLOAD_STOPPED | IMGLOAD_ERROR)))
            pImgCtx->SetProgSink(CMarkup::GetProgSinkHelper(_pOwner->GetMarkup()));

        pImgCtx->AddRef(); // addref the new before releasing the old
    }

    if (_pImgCtx)
    {
        _pImgCtx->SetProgSink(NULL);
        _pImgCtx->Disconnect();
        _pImgCtx->SetLoad(FALSE, NULL, FALSE);
        if (!pImgCtx)
        {
            _pImgCtx->Release();
            _pImgCtx = NULL;

            if ((dwSetFlags & IMGF_REQUEST_RESIZE) && ShouldHaveLayout())
                ResizeElement(NFLAGS_FORCE);

            UpdateHideForSecurity();
        }

        if (_pImgCtxPending)
        {
            _pImgCtxPending->SetLoad(FALSE, NULL, FALSE);
            _pImgCtxPending->Disconnect();
            _pImgCtxPending->Release();           
        }
  
        _pImgCtxPending = pImgCtx;       
    }
    else
    {
        _pImgCtx = pImgCtx;

        if (    (dwSetFlags & (IMGF_REQUEST_RESIZE | IMGF_INVALIDATE_FRAME))
            &&  ShouldHaveLayout())
        {
            if (dwSetFlags & IMGF_REQUEST_RESIZE)
                ResizeElement(NFLAGS_FORCE);
            else
                InvalidateFrame();
        }

        UpdateHideForSecurity();
    }

    // Request layout only if we don't have a pending context.  If we have a
    // pending context, we will request layout when we actually switch to the
    // new context.
    if (!_pImgCtxPending)
    {
        RequestLayout();
    }

    _fSizeChange = FALSE;
    _fNeedSize = FALSE;

    if (pImgCtx)
    {
        if (dwSetFlags & IMGF_DEFER_ONWDWNCHAN)
        {
            GWPostMethodCall(this,
                ONCALL_METHOD(CImgHelper, DeferredOnDwnChan, DeferredOnDwnChan),
                (DWORD_PTR) pImgCtx, TRUE, "CImgHelper::DeferredOnDwnChan");           
        }
        else
        {
            OnDwnChan (pImgCtx);
        }
    }
}


void CImgHelper::RequestLayout()
{
    if (!_pOwner->HasSlavePtr() && ShouldHaveLayout())
    {
        //
        // If there is no pending call to resize the element,
        // post a layout request so that CLayout::EnsureDispNode gets a chance to
        // execute and adjust the opacity of the display node

        // $$ktam: We don't yet support image breaking (multiple layouts for images)
        // so the first/only layout here is fine.

        if (!Layout( GUL_USEFIRSTLAYOUT )->IsSizeThis())
        {
            TraceTagEx((tagLayoutTasks, TAG_NONAME,
                        "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CImgHelper::SetImgCtx() [lazy layout del]",
                        Layout(),
                        Layout()->_pElementOwner,
                        Layout()->_pElementOwner->TagName(),
                        Layout()->_pElementOwner->_nSerialNumber));
            Layout( GUL_USEFIRSTLAYOUT )->PostLayoutRequest(LAYOUT_MEASURE);
        }
    }
}


void CImgHelper::SetBitsCtx(CBitsCtx *pBitsCtx)
{
    if (_pBitsCtx)
    {
        _pBitsCtx->SetProgSink(NULL);
        _pBitsCtx->Disconnect();
        _pBitsCtx->Release();
    }

    _pBitsCtx = pBitsCtx;

    if (pBitsCtx)
    {
        pBitsCtx->AddRef(); // addref then new before releasing the old

        _fStopped = FALSE;

        if (pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
            OnDwnChan(pBitsCtx);
        else
        {
            pBitsCtx->SetProgSink(CMarkup::GetProgSinkHelper(_pOwner->GetMarkup()));
            pBitsCtx->SetCallback(OnDwnChanCallback, this);
            pBitsCtx->SelectChanges(DWNCHG_COMPLETE, 0, TRUE);
        }
    }
}

HRESULT CImgHelper::putHeight(long l)
{
    Assert(_pOwner);
    if (_fIsInputImage)
    {
        RRETURN (DYNCAST(CInput, _pOwner)->putHeight(l));
    }
    else
    {
        RRETURN (DYNCAST(CImgElement, _pOwner)->putHeight(l));
    }
}

HRESULT CImgHelper::GetHeight(long *pl)
{
    Assert(_pOwner);
    if (_fIsInputImage)
    {
        RRETURN (DYNCAST(CInput, _pOwner)->GetHeight(pl));
    }
    else
    {
        RRETURN (DYNCAST(CImgElement, _pOwner)->GetHeight(pl));
    }
}

//
//  OM implementation helper
//
STDMETHODIMP CImgHelper::get_height(long *p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!IsInMarkup())
    {
        hr = THR(GetHeight(p));
    }
    else if (_fCreatedWithNew)
    {
        *p = GetFirstBranch()->GetCascadedheight().GetUnitValue();
    }
    else
    {
        CLayout * pLayout = NULL;
        const CUnitInfo *pUnitInfo = &g_uiDisplay;

        hr = THR(_pOwner->EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        pLayout = _pOwner->GetUpdatedLayout();

        if (!_pOwner->HasVerticalLayoutFlow())
        {
            *p = pLayout->GetContentHeight();
        }
        else
        {
            *p = pLayout->GetContentWidth();
        }

        //
        // but wait, if we are in a media resolution measurement, the value returned is in 
        // a different metric, so we need to untransform it before returning this to the OM call.
        //
        CLayoutContext *pContext  = (pLayout) 
                        ? (pLayout->LayoutContext()) 
                                ? pLayout->LayoutContext() 
                                : pLayout->DefinedLayoutContext() 
                        : NULL;

        if (   pContext 
            && pContext->GetMedia() != mediaTypeNotSet)
        {
           const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                    pContext->GetMedia());

           pUnitInfo = pdiTemp->GetUnitInfo();
        }

        *p = (!_pOwner->HasVerticalLayoutFlow())
                 ? pUnitInfo->DocPixelsFromDeviceY(*p)
                 : pUnitInfo->DocPixelsFromDeviceX(*p);
    }

Cleanup:
    return hr;
}

HRESULT CImgHelper::putWidth(long l)
{
    Assert(_pOwner);
    if (_fIsInputImage)
    {
        RRETURN (DYNCAST(CInput, _pOwner)->putWidth(l));
    }
    else
    {
        RRETURN (DYNCAST(CImgElement, _pOwner)->putWidth(l));
    }
}

HRESULT CImgHelper::GetWidth(long *pl)
{
    Assert(_pOwner);
    if (_fIsInputImage)
    {
        RRETURN (DYNCAST(CInput, _pOwner)->GetWidth(pl));
    }
    else
    {
        RRETURN (DYNCAST(CImgElement, _pOwner)->GetWidth(pl));
    }
}

//
// OM implementation helper
//
STDMETHODIMP CImgHelper::get_width(long *p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!IsInMarkup())
    {
        hr = THR(GetWidth(p));
    }
    else if (_fCreatedWithNew)
    {
        *p = GetFirstBranch()->GetCascadedwidth().GetUnitValue();
    }
    else
    {
        CLayout * pLayout = NULL;
        const CUnitInfo *pUnitInfo = &g_uiDisplay;

        hr = THR(_pOwner->EnsureRecalcNotify());
        if (hr)
            goto Cleanup;

        pLayout = _pOwner->GetUpdatedLayout();

        if (!_pOwner->HasVerticalLayoutFlow())
        {
            *p = pLayout->GetContentWidth();
        }
        else
        {
            *p = pLayout->GetContentHeight();
        }
        //
        // but wait, if we are in a media resolution measurement, the value returned is in 
        // a different metric, so we need to untransform it before returning this to the OM call.
        //
        CLayoutContext *pContext  = (pLayout) 
                        ? (pLayout->LayoutContext()) 
                                ? pLayout->LayoutContext() 
                                : pLayout->DefinedLayoutContext() 
                        : NULL;

        if (   pContext 
            && pContext->GetMedia() != mediaTypeNotSet)
        {
           const CDocInfo * pdiTemp = pLayout->GetView()->GetMeasuringDevice(
                                    pContext->GetMedia());

           pUnitInfo = pdiTemp->GetUnitInfo();
        }
        *p = (!_pOwner->HasVerticalLayoutFlow())
                 ? pUnitInfo->DocPixelsFromDeviceX(*p)
                 : pUnitInfo->DocPixelsFromDeviceY(*p);
    }

Cleanup:
    return hr;
}


void 
CImgHelper::DeferredOnDwnChan (DWORD_PTR pDwnChan)
{   
    // OnDwnChan callback could have already happened, in which case
    // we don't need to do anything
    if ((CDwnChan *)pDwnChan == _pImgCtxPending || 
        (CDwnChan *)pDwnChan == _pImgCtx || 
        (CDwnChan *)pDwnChan == _pBitsCtx)
    {
        OnDwnChan ((CDwnChan *) pDwnChan);    
    }
}

//+------------------------------------------------------------------------
//
//  Method:     CImgHelper::OnDwnChan
//
//-------------------------------------------------------------------------

void
CImgHelper::OnDwnChan(CDwnChan * pDwnChan)
{
    BOOL fPending = FALSE;
    CDoc *pDoc = Doc();
   
    if (!pDoc || !pDoc->PrimaryMarkup())
        return;

    Assert(pDwnChan == _pImgCtxPending || pDwnChan == _pImgCtx || pDwnChan == _pBitsCtx);

    if (pDwnChan == _pImgCtxPending)
    {
        if (_pImgCtxPending->GetState() & (IMGCHG_VIEW | IMGCHG_COMPLETE))
        {
            if (_pImgCtx && _lCookie)
            {
                CImgAnim * pImgAnim = GetImgAnim();

                if (pImgAnim)
                {
                    pImgAnim->UnregisterForAnim(this, _lCookie);
                    _lCookie = 0;
                }
            }

            _pImgCtx->Release();
            _pImgCtx = _pImgCtxPending;
            _pImgCtxPending = NULL;
            fPending = TRUE;
            RequestLayout();
            UpdateHideForSecurity();
        }
    }

#ifdef NO_AVI
    if (pDwnChan == _pImgCtx)
#else
    if (pDwnChan == _pImgCtx && !(_pBitsCtx && _pVideoObj))
#endif
    {
        ULONG ulState;
        SIZE  size;

        TraceTag((tagImgBase, "[%08lX] OnDwnChan (enter) '%ls'", this,
            GetAAsrc()));

        ulState = _pImgCtx->GetState(TRUE, &size);

        if ((ulState & IMGCHG_SIZE) || fPending)
        {
            if (IsInMarkup())
            {
                CTreeNode *pNode;
                CTreeNode::CLock  Lock;

                if( Lock.Init(GetFirstBranch()) )
                    return;

                SetReadyStateImg(READYSTATE_LOADING);
                pNode = GetFirstBranch();
                if (!pNode)
                    return;

                CUnitValue uvWidth = pNode->GetCascadedwidth();
                CUnitValue uvHeight = pNode->GetCascadedheight();

                TraceTag((tagImgBase, "[%08lX] OnChan IMGCHG_SIZE", this));

                if (uvWidth.IsNull() || uvHeight.IsNull() || _fExpandAltText)
                {
                    if (_fCreatedWithNew)
                    {
                        putWidth(size.cx);
                        putHeight(size.cy);
                    }
                    else
                    {
                        TraceTag((tagImgBase, "[%08lX] OnChan ResizeElement", this));
                        CRect rc;

                        GetRectImg(&rc);
                        if (    rc.right - rc.left != size.cx
                            ||  rc.bottom - rc.top != size.cy
                            ||  _fExpandAltText)
                        {
                            ResizeElement();
                        }
                    }

                    if (!(ulState & IMGLOAD_ERROR) && size.cx && size.cy)
                        SetCachedImageSize(_pImgCtx->GetUrl(), size);
                }
            }
            else
            {
                putWidth(size.cx);
                putHeight(size.cy);

                if (!(ulState & IMGLOAD_ERROR) && size.cx && size.cy)
                    SetCachedImageSize(_pImgCtx->GetUrl(), size);
            }
        }

        if (ulState & IMGCHG_VIEW)
        {
            if (_fIsActive)
            {
                long nrc;
                RECT prc[2];
                CRect rectImg;

                TraceTag((tagImgBase, "[%08lX] OnChan IMGCHG_VIEW", this));

                GetRectImg(&rectImg);
                _pImgCtx->GetUpdateRects(prc, &rectImg, &nrc);

                _pOwner->GetUpdatedLayout(GUL_USEFIRSTLAYOUT)->Invalidate(prc, nrc);
            }
        }
        else if (fPending)
        {
            InvalidateFrame();
        }

        if (ulState & IMGCHG_ANIMATE)
        {
            CImgAnim * pImgAnim = CreateImgAnim();

            _fAnimated = TRUE;

            if (pImgAnim)
            {
                if (!_lCookie && !_fDisplayNoneOrHidden)
                {
                    pImgAnim->RegisterForAnim(this, (DWORD_PTR) pDoc, _pImgCtx->GetImgId(),
                                              OnAnimSyncCallback, NULL,
                                              &_lCookie);
                }

                if (_lCookie)
                    pImgAnim->ProgAnim(_lCookie);
            }
        }

        if (ulState & IMGCHG_COMPLETE)
        {
            TraceTag((tagImgBase, "[%08lX] OnChan IMGCHG_COMPLETE", this));
            Assert(_pOwner);
            CElement::CLock  Lock(_pOwner);

            if (ulState & (IMGLOAD_ERROR | IMGLOAD_STOPPED))
            {
                // If document is secure and image had an error on loading, hide partial image
                // data and show placeholder so that we can't be spoofed

                UpdateHideForSecurity();

                if ((_fCreatedWithNew || !IsInMarkup()) && !_fSizeInCtor)
                {
                    GetPlaceHolderBitmapSize(TRUE, &size);
                    putWidth(size.cx + GRABSIZE*2);
                    putHeight(size.cy + GRABSIZE*2);
                }

                if (ulState & IMGLOAD_STOPPED)
                {
                    Fire_onabort();
                }
                else
                {
                    if (_lCookie)
                    {
                        CImgAnim * pImgAnim = GetImgAnim();
                        if (pImgAnim)
                        {
                            pImgAnim->UnregisterForAnim(this, _lCookie);
                            _lCookie = 0;
                        }
                    }

                    Fire_onerror();

                    if (g_bJGJitState == JIT_NEED_JIT)
                    {
                        g_bJGJitState = JIT_PENDING;
                        IGNORE_HR(GWPostMethodCall(pDoc, ONCALL_METHOD(CDoc, FaultInJG, faultinjg), 0, FALSE, "CDoc::FaultInJG"));
                    }
                }

            }

            if (ulState & IMGLOAD_COMPLETE)
            {
                BOOL fPendingRoot = FALSE;

                if (IsInMarkup())
                {
                    fPendingRoot = _pOwner->GetMarkup()->IsPendingRoot();
                }

                Doc()->OnSubDownloadSecFlags(fPendingRoot, _pImgCtx->GetUrl(), _pImgCtx->GetSecFlags());

                SetReadyStateImg(READYSTATE_COMPLETE);
                SetAAcomplete(TRUE);
            }

            if (_pImgCtx)
            {
                _pImgCtx->SetProgSink(NULL);
            }
            if (!GetFirstBranch())
            {
                TraceTag((tagImgBase, "[%08lX] OnChan (leave)", this));
                return;
            }
        }

        TraceTag((tagImgBase, "[%08lX] OnChan (leave)", this));
    }
#ifndef NO_AVI
    else if (pDwnChan == _pBitsCtx)
    {
        ULONG ulState = _pBitsCtx->GetState();

        if (ulState & DWNLOAD_COMPLETE)
        {
            BOOL fPendingRoot = FALSE;

            if (IsInMarkup())
            {
                fPendingRoot = _pOwner->GetMarkup()->IsPendingRoot();
            }

            // If unsecure download, may need to remove lock icon on Doc
            pDoc->OnSubDownloadSecFlags(fPendingRoot, _pBitsCtx->GetUrl(), _pBitsCtx->GetSecFlags());
            
            // Create the video object if it doesn't exist
            if (!_pVideoObj)
            {
                _pVideoObj = (CIEMediaPlayer *) new (CIEMediaPlayer);
                pDoc->_fBroadcastInteraction = TRUE;
                pDoc->_fBroadcastStop = TRUE;
            }

            if (_pVideoObj)
            {
                TCHAR * pchFile = NULL;

                if (OK(_pBitsCtx->GetFile(&pchFile)) &&
                    OK(_pVideoObj->SetURL(pchFile)))    // Initialize & RenderFile
                    _pVideoObj->SetLoopCount(GetAAloop());
                else
                {
                    _pVideoObj->Release();
                    _pVideoObj = NULL;
                }
                MemFreeString(pchFile);
            }

            ResizeElement();

            SetVideo();

        }
        else if (ulState & DWNLOAD_ERROR)
        {
            if (_pVideoObj)
            {
                _pVideoObj->Release();
                _pVideoObj = NULL;
            }
            if (_hwnd)
            {
                DestroyWindow(_hwnd);
                _hwnd = NULL;
            }
        }

        if (ulState & (DWNLOAD_COMPLETE | DWNLOAD_STOPPED | DWNLOAD_ERROR))
        {
            _pBitsCtx->SetProgSink(NULL);
        }
    }
#endif // NO_AVI
}


//--------------------------------------------------------------------------
//
//  Method:     CImgHelper::ImgAnimCallback
//
//  Synopsis:   Called by the CImgAnim when certain events take place.
//
//--------------------------------------------------------------------------

void
CImgHelper::OnAnimSync(DWORD dwReason, void *pvParam, void **ppvDataOut,
                     IMGANIMSTATE * pImgAnimState)
{
    switch (dwReason)
    {
    case ANIMSYNC_GETIMGCTX:
        *(CImgCtx **) ppvDataOut = _pImgCtx;
        break;

    case ANIMSYNC_GETHWND:
        {
            CDoc * pDoc = Doc();

            *(HWND *) ppvDataOut = pDoc->_pInPlace ? pDoc->_pInPlace->_hwnd : NULL;
        }
        break;

    case ANIMSYNC_TIMER:
    #if DBG==1
        if (IsTagEnabled(tagImgAnimDirect))
        {
            if (_fIsActive)
                InvalidateFrame();
            *(BOOL *) ppvDataOut = FALSE;
        }
        else
    #endif
        if (_fIsActive)
        {
            InvalidateFrame();
            *(BOOL *) ppvDataOut = TRUE;
        }
        else
            *(BOOL *) ppvDataOut = FALSE;

        if (pImgAnimState->fLoop)
            Fire_onload();
        break;

    case ANIMSYNC_INVALIDATE:
        if (_fIsActive)
        {
            InvalidateFrame();
            *(BOOL *) ppvDataOut = TRUE;
        }
        else
            *(BOOL *) ppvDataOut = FALSE;
        break;

    default:
        Assert(FALSE);
    }
}

//+-------------------------------------------------------------------------
//
//  Method      CImgHelper::Cleanup
//
//  Synopsis    Shutdown main object by releasing references to
//              other objects and generally cleaning up.
//
//              Release any event connections held by the form.
//
//--------------------------------------------------------------------------
void
CImgHelper::CleanupImage ( )
{
#ifndef NO_AVI
    if (_pVideoObj)
    {
        _pVideoObj->Release();
        _pVideoObj = NULL;
    }
#endif // NO_AVI

    SetImgCtx(NULL, 0);
    SetBitsCtx(NULL);

    if (_hwnd)
    {
        DestroyWindow(_hwnd);
        _hwnd = NULL;
    }

    if (_hbmCache)
    {
        DeleteObject(_hbmCache);
        _hbmCache = NULL;
    }

    GWKillMethodCall(this, ONCALL_METHOD(CImgHelper, DeferredOnDwnChan, DeferredOnDwnChan), 0);
}

//--------------------------------------------------------------------------
//
//  Method:     CImgHelper::Passivate
//
//  Synopsis:   This function is called when the main reference count
//              goes to zero.  The destructor is called when
//              the reference count for the main object and all
//              embedded sub-objects goes to zero.
//
//--------------------------------------------------------------------------

void
CImgHelper::Passivate ( )
{
    Assert(!IsInMarkup());

    CleanupImage();
}

#ifndef NO_AVI

//+-------------------------------------------------------------------------
//
//  Function:   ActiveMovieWndProc
//
//--------------------------------------------------------------------------

LRESULT CALLBACK
ActiveMovieWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CImgHelper *pImgHelper;

    switch (msg)
    {
    case WM_NCCREATE:
        pImgHelper = (CImgHelper *) ((LPCREATESTRUCTW) lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pImgHelper);
        return TRUE;
        break;

    case WM_NCDESTROY:
        pImgHelper = (CImgHelper *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
        if (pImgHelper)
            pImgHelper->_hwnd = NULL;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);
        return TRUE;
        break;

    case WM_MOUSEMOVE:
        pImgHelper = (CImgHelper *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
        if (pImgHelper && pImgHelper->GetAAstart() == htmlStartmouseover)
            pImgHelper->Replay();
        break;

    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
        POINT ptMap;
        HWND hwndParent = GetParent(hwnd);
        ptMap.x = LOWORD(lParam);
        ptMap.y = HIWORD(lParam);
        MapWindowPoints(hwnd, hwndParent, &ptMap, 1);
        lParam = MAKELPARAM(ptMap.x, ptMap.y);
        return SendMessage(hwndParent, msg, wParam, lParam);
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
//  Member:     CImgHelper::SetVideo
//
//  Synopsis:   Checks if we should animate the image
//
//----------------------------------------------------------------------------

void
CImgHelper::SetVideo()
{
    HRESULT hr;
    BOOL fEnableInteraction;
    TCHAR * pszWndClass;

    if (!_pVideoObj)
        return;

    fEnableInteraction = Doc()->_fEnableInteraction;

    if (_fVideoPositioned && _fIsInPlace && fEnableInteraction && !_fStopped)
    {
        CRect rcImg;
        CDoc *pDoc = Doc();

        _pOwner->GetUpdatedLayout()->GetClientRect(&rcImg, COORDSYS_GLOBAL);

        if (!GetWndClassAtom(WNDCLASS_AMOVIE))
        {
            hr = THR(RegisterWindowClass(
                WNDCLASS_AMOVIE,
                ActiveMovieWndProc,
                0,
                NULL, NULL));
            if (hr)
                return;
        }

        pszWndClass = (TCHAR *)(DWORD_PTR)GetWndClassAtom(WNDCLASS_AMOVIE);

        if ((_hwnd == NULL) && !_pVideoObj->IsAudio())
        {
            _hwnd = TW32(NULL, CreateWindow(
                pszWndClass,
                NULL,
                WS_CHILD | WS_VISIBLE,
                rcImg.left, rcImg.top,
                rcImg.right - rcImg.left,
                rcImg.bottom - rcImg.top,
                pDoc->GetHWND(),
                NULL,
                g_hInstCore,
                this));

            if (_hwnd == NULL)
                return;
        }

        OffsetRect(&rcImg, -rcImg.left, -rcImg.top);
        _pVideoObj->SetVideoWindow(_hwnd);

        _pVideoObj->SetNotifyWindow(pDoc->GetHWND(), WM_ACTIVEMOVIE, (LONG_PTR)this);
        _pVideoObj->SetWindowPosition(&rcImg);
        _pVideoObj->SetVisible(TRUE);

        if (GetAAstart() == htmlStartfileopen)
            _pVideoObj->Play();

        // We're not interested in playing the entire animation when
        // printing, we just want to get the first frame up, so stop it
        // right away.
        if ( _pOwner->GetMarkup() && _pOwner->GetMarkup()->IsPrintMedia() )
        {
            _pVideoObj->Stop();
        }
    }
    else if (!_fIsInPlace || !fEnableInteraction)
    {

        // remove us from notifications
        _pVideoObj->SetNotifyWindow(NULL, WM_ACTIVEMOVIE, (LONG_PTR)this);

        // Stop the video
        _pVideoObj->Stop();
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImgHelper::Replay
//
//----------------------------------------------------------------------------

void
CImgHelper::Replay()
{
    if (_pVideoObj)
    {
        if (_pVideoObj->GetStatus() == CIEMediaPlayer::IEMM_Completed)
        {
            _pVideoObj->Seek(0);
            _pVideoObj->SetLoopCount(GetAAloop());
        }

        _pVideoObj->Play();
    }
}

#endif // ndef NO_AVI



//+---------------------------------------------------------------------------
//
//  Member:     CImgHelper::SetActivity
//
//  Synopsis:   Turns activity on or off depending on visibility and
//              in-place activation.
//
//----------------------------------------------------------------------------

void
CImgHelper::SetActivity()
{
    if (!!_fIsActive != !!_fIsInPlace)
    {
        CImgCtx * pImgCtx = GetImgCtx();

        _fIsActive = !_fIsActive;

        if (pImgCtx)
        {
            pImgCtx->SelectChanges(_fIsActive ? IMGCHG_VIEW : 0,
                !_fIsActive ? IMGCHG_VIEW : 0, FALSE);
        }
    }
}

BOOL
CImgHelper::IsOpaque()
{
    if (!GetFirstBranch() || !ShouldHaveLayout() || !_pImgCtx)
        return FALSE;

    BOOL fOpaque = (_pImgCtx->GetState() & (IMGTRANS_OPAQUE | IMGLOAD_COMPLETE)) ==
        (IMGTRANS_OPAQUE | IMGLOAD_COMPLETE);
    if (fOpaque)
    {
        BOOL fParentVertical = GetFirstBranch()->IsParentVertical();
        LONG lhSpace = fParentVertical ? GetAAvspace() : GetAAhspace();
        LONG lvSpace = fParentVertical ? GetAAhspace() : GetAAvspace();

        fOpaque = (lvSpace == 0) && (lhSpace != -1 ? (lhSpace == 0) : !IsAligned());
        // In strict CSS1 documets padding reseves space around the image and that makes
        //   the image transparant
        if(fOpaque)
        {
            CTreeNode * pNode = GetFirstBranch();
            CMarkup * pMarkup = _pOwner->GetMarkup();
            if(pMarkup && IsStrictCSS1Document())
            {
                const CFancyFormat * pFF = pNode->GetFancyFormat();
                if(!pFF->GetPadding(SIDE_TOP).IsNull() || !pFF->GetPadding(SIDE_BOTTOM).IsNull()
                  || !pFF->GetPadding(SIDE_LEFT).IsNull() || !pFF->GetPadding(SIDE_RIGHT).IsNull())
                {
                    fOpaque = FALSE;
                }
            }
        }

        
    }

    return fOpaque;
}

//+---------------------------------------------------------------------------
//  Member :     CImgHelper::GetRectImg
//
//  Synopsis   : gets rectImg
//
//+---------------------------------------------------------------------------

void
CImgHelper::GetRectImg(CRect * prectImg)
{
    _pOwner->GetUpdatedLayout(GUL_USEFIRSTLAYOUT)->GetClientRect(prectImg);
}


//+---------------------------------------------------------------------------
//
//  Member:     CImgHelper::OnReadyStateChange
//
//----------------------------------------------------------------------------

void
CImgHelper::OnReadyStateChange()
{   // do not call super::OnReadyStateChange here - we handle firing the event ourselves
    SetReadyStateImg(_readyStateImg);
}

//+------------------------------------------------------------------------
//
//  Member:     CImgHelper::SetReadyStateImg
//
//  Synopsis:   Use this to set the ready state;
//              it fires OnReadyStateChange if needed.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CImgHelper::SetReadyStateImg(long readyStateImg)
{
    long readyState;

    _readyStateImg = readyStateImg;

    readyState = min ((long)_readyStateImg, _pOwner->GetReadyState());

    if ((long)_readyStateFired != readyState)
    {
        _readyStateFired = readyState;

        Fire_onreadystatechange();

        if (_readyStateImg == READYSTATE_COMPLETE)
            Fire_onload();
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CImgHelper::Notify
//
//  Synopsis:   Listen for inplace (de)activation so we can turn on/off
//              animation
//
//-------------------------------------------------------------------------

void
CImgHelper::Notify(CNotification *pNF)
{
    switch (pNF->Type())
    {
    case NTYPE_DOC_STATE_CHANGE_1:
#ifndef NO_AVI
        if (    _pVideoObj 
            &&  !!_fIsInPlace != (Doc()->State() >= OS_INPLACE) )
        {
            pNF->SetSecondChanceRequested();
            break;
        }
#endif

        // fall through
    case NTYPE_DOC_STATE_CHANGE_2:
        {
            CDoc *  pDoc = Doc();
            
            if (!!_fIsInPlace != (pDoc->State() >= OS_INPLACE))
            {
                CImgCtx * pImgCtx = GetImgCtx();

                DWNLOADINFO dli;

                _fIsInPlace = !_fIsInPlace;
                SetActivity();

#ifndef NO_AVI
                SetVideo();
#endif // ndef NO_AVI

                if( SUCCEEDED( _pOwner->GetMarkup()->InitDownloadInfo(&dli) ) )
                {
                    if (pImgCtx && _fIsInPlace && (pDoc->_dwLoadf & DLCTL_DLIMAGES))
                        pImgCtx->SetLoad(TRUE, &dli, FALSE);

                    if (_pBitsCtx && _fIsInPlace)
                        _pBitsCtx->SetLoad(TRUE, &dli, FALSE);
                }
            }
        }
        break;

    case NTYPE_STOP_1:
    case NTYPE_MARKUP_UNLOAD_1:
        {
            CImgCtx * pImgCtx = GetImgCtx();

            if (pImgCtx)
            {
                pImgCtx->SetProgSink(NULL);
                pImgCtx->SetLoad(FALSE, NULL, FALSE);

#ifndef NO_ART
                if (pImgCtx->GetArtPlayer())
                    pNF->SetSecondChanceRequested();
#endif
            }

            if (_pBitsCtx)
            {
                _pBitsCtx->SetProgSink(NULL);
                _pBitsCtx->SetLoad(FALSE, NULL, FALSE);
            }

#ifndef NO_AVI
            if (_pVideoObj)
                pNF->SetSecondChanceRequested();
#endif

            break;
        }

        case NTYPE_STOP_2:
        case NTYPE_MARKUP_UNLOAD_2:
        {
            CImgCtx * pImgCtx = GetImgCtx();
#ifndef NO_AVI
            if (_pVideoObj)
            {
                _pVideoObj->Stop();
                _fStopped = TRUE;
            }
#endif // NO_AVI

#ifndef NO_ART
            if (pImgCtx)
            {
                CArtPlayer * pArtPlayer = pImgCtx->GetArtPlayer();

                if (pArtPlayer)
                {
                    pArtPlayer->DoPlayCommand(IDM_IMGARTSTOP);
                }
            }
#endif NO_ART
        }
        break;

#ifndef NO_AVI
    case NTYPE_ENABLE_INTERACTION_1:
        if (_pVideoObj)
            pNF->SetSecondChanceRequested();
        break;

    case NTYPE_ENABLE_INTERACTION_2:
        SetVideo();
        break;

    case NTYPE_ACTIVE_MOVIE:
        {
            void * pv;;

            pNF->Data(&pv);

            if (_pVideoObj && (pv == this))
                _pVideoObj->NotifyEvent();              // Let the video object know something happened
        }
        break;
#endif

    case NTYPE_ELEMENT_EXITTREE_1:
        GWKillMethodCall(this, ONCALL_METHOD(CImgHelper, DeferredOnDwnChan, DeferredOnDwnChan), 0);
        // fall through ...
    
    case NTYPE_ELEMENT_EXITTREE_2:
        ExitTree(pNF);
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        EnterTree();
        break;

    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CImgHelper::ShowTooltip
//
//  Synopsis:   Displays the tooltip for the site.
//
//  Arguments:  [pt]    Mouse position in container window coordinates
//              msg     Message passed to tooltip for Processing
//
//--------------------------------------------------------------------------

HRESULT
CImgHelper::ShowTooltip(CMessage *pmsg, POINT pt)
{
    HRESULT hr = S_FALSE;
    BOOL fRTL = FALSE;
    CDoc *pDoc = Doc();

    //  Check if we can display alt property as the tooltip.
    //

    TCHAR * pchString;
    CRect   rc;


    pchString = (LPTSTR) GetAAalt();
    if (pchString == NULL)
        goto Cleanup;

    {
        // Ignore spurious WM_ERASEBACKGROUNDs generated by tooltips
        CServer::CLock Lock(pDoc, SERVERLOCK_IGNOREERASEBKGND);

        Assert(GetFirstBranch());
    
        // Complex Text - determine if element is right to left for tooltip style setting
        fRTL = GetFirstBranch()->GetCharFormat()->_fRTL;
        _pOwner->GetUpdatedLayout()->GetRect(&rc, COORDSYS_GLOBAL);

        if (!pDoc->_pDocPopup)
        {
            FormsShowTooltip(pchString, pDoc->_pInPlace->_hwnd, *pmsg, &rc, (DWORD_PTR) _pOwner->GetMarkup(), (DWORD_PTR) this, fRTL);
        }
        hr = S_OK;
    }

Cleanup:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImgHelper::QueryStatus, public
//
//  Synopsis:   Implements QueryStatus for CImgHelper
//
//----------------------------------------------------------------------------

HRESULT
CImgHelper::QueryStatus(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    int idm;

    TraceTag((tagMsoCommandTarget, "CImgHelper::QueryStatus"));

    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));
    Assert(cCmds == 1);

    MSOCMD *    pCmd = &rgCmds[0];
    HRESULT     hr = S_OK;

    Assert(!pCmd->cmdf);

    idm = CBase::IDMFromCmdID(pguidCmdGroup, pCmd->cmdID);
    switch (idm)
    {
    case IDM_ADDFAVORITES:
    {
        TCHAR * pchUrl = NULL;

        pCmd->cmdf = (S_OK == GetUrl(&pchUrl)) ?
                        MSOCMDSTATE_UP :
                        MSOCMDSTATE_DISABLED;

        MemFreeString(pchUrl);
        break;
    }

    case IDM_CUT:
        // Enable if script wants to handle it, otherwise leave it to default
        if (!Fire_onbeforecut())
        {
            pCmd->cmdf = MSOCMDSTATE_UP;
        }
        break;
    case IDM_COPY:
    {
        TCHAR * pchPath = NULL;

        // Enable if script wants to handle it or we know there is something to copy,
        // otherwise leave it to default
        if (    !Fire_onbeforecopy()
            ||  (_pBitsCtx && (S_OK == THR(_pBitsCtx->GetFile(&pchPath))))
            ||  (_pImgCtx && !_pBitsCtx))
        {
            pCmd->cmdf = MSOCMDSTATE_UP;
        }
        MemFreeString(pchPath);
        break;
    }
    case IDM_PASTE:
        // Enable if script wants to handle it, otherwise leave it to default
        if (!Fire_onbeforepaste())
        {
            pCmd->cmdf = MSOCMDSTATE_UP;
        }
        break;

    case IDM_SHOWPICTURE:
    {
        CImgCtx * pImgCtx = GetImgCtx();
        ULONG ulState = pImgCtx
                      ? pImgCtx->GetState()
                      : (_pBitsCtx ? _pBitsCtx->GetState()
                                   : IMGLOAD_NOTLOADED);

        pCmd->cmdf = (ulState & IMGLOAD_COMPLETE) ? MSOCMDSTATE_DISABLED : MSOCMDSTATE_UP;
        break;
    }
    case IDM_MP_PRINTPICTURE:
    case IDM_MP_EMAILPICTURE:
    case IDM_SAVEPICTURE:
    {
        if ((_pBitsCtx && (_pBitsCtx->GetState() & DWNLOAD_COMPLETE)) ||
            (_pImgCtx && (_pImgCtx->GetState() & IMGLOAD_COMPLETE)))
            pCmd->cmdf = MSOCMDSTATE_UP;
        else
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
        break;
    }
    case IDM_MP_MYPICS:
        pCmd->cmdf = MSOCMDSTATE_UP;
        break;
    case IDM_SETWALLPAPER:
        if (Doc()->_pOptionSettings->dwNoChangingWallpaper)
        {
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
            break;
        }
        // fall through
    case IDM_SETDESKTOPITEM:
    {
        ULONG ulState = _pImgCtx ? _pImgCtx->GetState() : IMGLOAD_NOTLOADED;

        pCmd->cmdf = (ulState & IMGLOAD_COMPLETE) ? MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED;
        break;
    }

#ifndef NO_AVI
    case IDM_DYNSRCPLAY:
    pCmd->cmdf = (_pVideoObj && (_pVideoObj->CanPlay())) ? MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED;
    break;

    case IDM_DYNSRCSTOP:
    pCmd->cmdf = (_pVideoObj && _pVideoObj->CanStop()) ? MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED;
    break;
#endif // NO_AVI
#ifndef NO_ART
    case IDM_IMGARTPLAY:
    case IDM_IMGARTSTOP:
    case IDM_IMGARTREWIND:
        pCmd->cmdf = MSOCMDSTATE_DISABLED;
        if (_pImgCtx && Doc()->_pOptionSettings->fPlayAnimations)
        {
            CArtPlayer * pArtPlayer = _pImgCtx->GetArtPlayer();

            if (pArtPlayer)
                pCmd->cmdf = pArtPlayer->QueryPlayState(idm) ? MSOCMDSTATE_UP : MSOCMDSTATE_DISABLED;
        }
        break;
#endif // NO_ART
    }

    RRETURN_NOTRACE(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CImgHelper::Exec, public
//
//  Synopsis:   Executes a command on the CImgHelper
//
//----------------------------------------------------------------------------

HRESULT
CImgHelper::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    TraceTag((tagMsoCommandTarget, "CImgHelper::Exec"));

    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));

    int                    idm = CBase::IDMFromCmdID(pguidCmdGroup, nCmdID);
    HRESULT                hr = MSOCMDERR_E_NOTSUPPORTED;
    IHTMLSelectionObject * pSel = NULL;

    switch (idm)
    {
    case IDM_CUT:
        Fire_oncut();
        //
        // marka - we normally want to not allow a cut of an image in BrowseMode
        // but if we're in edit mode - we want to allow it.
        //
        // this bug was introduced as now a site selected image will be current
        // we can probably remove this once we make the currency work again as before
        // 
        //
        if ( ! IsEditable(TRUE))
        {
            hr = S_OK;
        }
        break;
    case IDM_COPY:
    {
        //
        // krisma - If there's a text selection,
        // we want to let the editor handle the copy or we'll end up just
        // copying the image. (IE bug 83358)
        //

        if (_pOwner->HasMarkupPtr())
        {
            CDocument *   pDoc = _pOwner->GetMarkup()->Document();
            htmlSelection eType;
            HRESULT       hrTemp;

            // This is to ensure we have a _pCSelectionObject on the document.
            hrTemp = THR(pDoc->get_selection(&pSel));
            if (hrTemp)
            {
                hr = hrTemp;
                goto Cleanup;
            }

            Assert(pDoc->_pCSelectionObject);

            hrTemp = THR(pDoc->_pCSelectionObject->GetType(&eType));
            if (hrTemp)
            {
                hr = hrTemp;
                goto Cleanup;
            }

            if (eType != htmlSelectionText)
            {
                hr = THR(CreateImgDataObject(Doc(), _pImgCtx, _pBitsCtx, _pOwner, NULL));
            }
        }
        else
        {
            EnsureInMarkup();
            hr = THR(CreateImgDataObject(Doc(), _pImgCtx, _pBitsCtx, _pOwner, NULL));
        }

        Fire_oncopy();
        break;
    }
    case IDM_PASTE:
        Fire_onpaste();

        // MarkA's comments above for IDM_CUT apply here also.
        if ( ! IsEditable(TRUE))
        {
            hr = S_OK;
        }
        break;
    case IDM_SHOWPICTURE:
    {
        DWNLOADINFO dli;
        CImgCtx * pImgCtx = GetImgCtx();

        hr = THR( _pOwner->GetMarkup()->InitDownloadInfo(&dli) );
        if( hr )
            goto Cleanup;

        if (pImgCtx)
            pImgCtx->SetLoad(TRUE, &dli, TRUE);    // Reload on error
        else
        {
            THR(_pOwner->OnPropertyChange(
                                    _fIsInputImage ? DISPID_CInput_src :
                                                    DISPID_CImgElement_src,
                                    0,
                                    _fIsInputImage ? (PROPERTYDESC *)&s_propdescCInputsrc : 
                                                     (PROPERTYDESC *)&s_propdescCImgElementsrc));
        }

        hr = S_OK;
        break;
    }

    case IDM_SAVEPICTURE:
        hr = THR(PromptSaveAs());
        break;

    case IDM_MP_EMAILPICTURE:
    {
        ITridentService2 *pTriSvc2 = NULL;
        BSTR              bstrURL  = NULL;

        get_src(&bstrURL);
        if(!bstrURL)
            break;
        
        if (Doc()->_pTridentSvc && 
            SUCCEEDED(Doc()->_pTridentSvc->QueryInterface(IID_ITridentService2, (void **)&pTriSvc2)))
        {
            pTriSvc2->EmailPicture(bstrURL);
            pTriSvc2->Release();
        }

        hr = S_OK;

        break;
    }
    case IDM_MP_PRINTPICTURE:
    {

        CHAR szBuffer[INTERNET_MAX_URL_LENGTH];
        BSTR bstrURL = NULL;

        get_src(&bstrURL);
        if(!bstrURL)
            break;

        wnsprintfA(szBuffer,INTERNET_MAX_URL_LENGTH,"\"%ws\"", bstrURL);

        PrintHTML(NULL, NULL, szBuffer, 0);

        hr = S_OK;
        
        break;

    }
    case IDM_MP_MYPICS:
    {
        TCHAR szCache[MAX_PATH];

        // get mypics folder...
        hr = SHGetFolderPath(NULL, CSIDL_MYPICTURES | CSIDL_FLAG_CREATE, NULL, 0, szCache);

        // if we found something, open it...
        if (hr == S_OK) {
    
            TCHAR szIniFile[MAX_PATH];
            PathCombine(szIniFile, szCache, TEXT("desktop.ini"));
            SHELLEXECUTEINFO ei = { sizeof(SHELLEXECUTEINFO), 0};
            ei.hwnd = NULL;
            ei.lpFile = szCache;
            ei.nShow = SW_SHOWNORMAL;
            if(ShellExecuteEx(&ei))
                hr = S_OK;
            else
                hr = E_FAIL;
        }

        break;

    }

    case IDM_SETDESKTOPITEM:
    case IDM_SETWALLPAPER:
        if (_pImgCtx)
            Doc()->SaveImgCtxAs(_pImgCtx, NULL, idm);
        hr = S_OK;
        break;

    case IDM_ADDFAVORITES:
        TCHAR * pchUrl;
        TCHAR * pszTitle;

        pchUrl = NULL;
        pszTitle = (LPTSTR) GetAAalt();
        if (!pszTitle)
            pszTitle = (LPTSTR) GetAAtitle();

        hr = GetUrl(&pchUrl);
        if (!hr)
            hr = Doc()->AddToFavorites(pchUrl, pszTitle);
        MemFreeString(pchUrl);
        break;
#ifndef NO_AVI
        case IDM_DYNSRCPLAY:
        Replay();
        _fStopped = FALSE;
        hr = S_OK;
        break;
    case IDM_DYNSRCSTOP:
        if (_pVideoObj)
        {
            _pVideoObj->Stop();
            _fStopped = TRUE;
        }
        hr = S_OK;
        break;
#endif // ndef NO_AVI
#ifndef NO_ART
    case IDM_IMGARTPLAY:
    case IDM_IMGARTSTOP:
    case IDM_IMGARTREWIND:
        if (_lCookie && _pImgCtx)
        {
            CImgAnim * pImgAnim = GetImgAnim();
            CArtPlayer * pArtPlayer = _pImgCtx->GetArtPlayer();

            if (pImgAnim && pArtPlayer)
            {
                if (idm == IDM_IMGARTPLAY)
                {
                    pImgAnim->StartAnim(_lCookie);
                    pArtPlayer->DoPlayCommand(IDM_IMGARTPLAY);
                }
                else if (idm == IDM_IMGARTSTOP)
                {
                     pArtPlayer->DoPlayCommand(IDM_IMGARTSTOP);
                     pImgAnim->StopAnim(_lCookie);
                }
                else // idm == IDM_IMGARTREWIND
                {
                    pArtPlayer->DoPlayCommand(IDM_IMGARTREWIND);
                    pImgAnim->StartAnim(_lCookie);
                    pArtPlayer->_fRewind = TRUE;
                }
            }
        }
        break;
#endif // NO_ART
    }

Cleanup:
    ReleaseInterface(pSel);

    RRETURN_NOTRACE(hr);
}

//+-------------------------------------------------------------------
//
//  Member  : ShowImgContextMenu
//
//  synopsis   : Implementation of interface src property get. this
//      should return the expanded src (e.g.  file://c:/temp/foo.jpg
//      rather than foo.jpg)
//
//------------------------------------------------------------------

HRESULT
CImgHelper::ShowImgContextMenu(CMessage * pMessage)
{
    HRESULT hr;

    Assert(pMessage);
    Assert(WM_CONTEXTMENU == pMessage->message);

#ifndef NO_ART
    if (_pImgCtx && _pImgCtx->GetMimeInfo() && _pImgCtx->GetMimeInfo()->pfnImg == NewImgTaskArt)
    {
        hr = THR(_pOwner->OnContextMenu(
                MAKEPOINTS(pMessage->lParam).x,
                MAKEPOINTS(pMessage->lParam).y,
                (!IsEditable(TRUE) && (_pImgCtx->GetArtPlayer())) ?
                    (CONTEXT_MENU_IMGART) : (CONTEXT_MENU_IMAGE)));
    }
    else
#endif
    {
        LPCTSTR pchdynSrc = GetAAdynsrc();
        hr = THR(_pOwner->OnContextMenu(
                MAKEPOINTS(pMessage->lParam).x,
                MAKEPOINTS(pMessage->lParam).y,
                (!IsEditable(TRUE) && (pchdynSrc && pchdynSrc[0]) ) ?
                    (CONTEXT_MENU_IMGDYNSRC) : (CONTEXT_MENU_IMAGE)));
    }
    RRETURN(hr);
}


//+-------------------------------------------------------------------
//
//  Member  : get_src
//
//  synopsis   : Implementation of interface src property get. this
//      should return the expanded src (e.g.  file://c:/temp/foo.jpg
//      rather than foo.jpg)
//
//------------------------------------------------------------------

STDMETHODIMP
CImgHelper::get_src(BSTR * pstrFullSrc)
{
    HRESULT hr;
    TCHAR   cBuf[pdlUrlLen];
    TCHAR  * pchNewUrl = cBuf;

    if (!pstrFullSrc)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pstrFullSrc = NULL;

    hr = THR(CMarkup::ExpandUrl(_pOwner->GetMarkupForBaseUrl(), GetAAsrc(), ARRAY_SIZE(cBuf), pchNewUrl, _pOwner));
    if (hr || (pchNewUrl == NULL))
        goto Cleanup;

    *pstrFullSrc = SysAllocString(pchNewUrl);
    if (!*pstrFullSrc)
        hr = E_OUTOFMEMORY;

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------
//
//  member : CImgHelper::GetFile
//
//-------------------------------------------------------------------

HRESULT
CImgHelper::GetFile(TCHAR **ppchFile)
{
    HRESULT hr = E_FAIL;

    Assert(ppchFile);

    *ppchFile = NULL;

#ifndef NO_AVI
    if (_pBitsCtx)
    {
        if (_pBitsCtx->GetState() & DWNLOAD_COMPLETE)
            hr = _pBitsCtx->GetFile(ppchFile);
        else
            hr = S_OK;
    }
    else
#endif // ndef NO_AVI
    if (_pImgCtx)
    {
        if (_pImgCtx->GetState() & DWNLOAD_COMPLETE)
            hr = _pImgCtx->GetFile(ppchFile);
        else
            hr = S_OK;
    }
    else
    {
        // TODO DOM May be we could return anything more informative
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------
//
//  member : CImgHelper::GetUrl
//
//-------------------------------------------------------------------

HRESULT
CImgHelper::GetUrl(TCHAR **ppchUrl)
{
    HRESULT hr = E_FAIL;

    Assert(ppchUrl);

    *ppchUrl = NULL;

#ifndef NO_AVI
    if (_pBitsCtx)
        hr = THR(MemAllocString(Mt(CImgHelperGetUrl), _pBitsCtx->GetUrl(), ppchUrl));
    else
#endif // ndef NO_AVI
    if (_pImgCtx)
        hr = THR(MemAllocString(Mt(CImgHelperGetUrl), _pImgCtx->GetUrl(), ppchUrl));

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CImgHelper::PromptSaveAs
//
//  Synopsis:   Brings up the 'Save As' dialog and saves the image.
//
//  Arguments:  pchPath     Returns the file to whic the image was saved.
//
//----------------------------------------------------------------------------

HRESULT
CImgHelper::PromptSaveAs(TCHAR * pchFileName /*=NULL*/, int cchFileName /*=0*/)
{
    if (_pBitsCtx && (_pBitsCtx->GetState() & DWNLOAD_COMPLETE))
        Doc()->SaveImgCtxAs(NULL, _pBitsCtx, IDM_SAVEPICTURE, pchFileName, cchFileName);
    else if (_pImgCtx && (_pImgCtx->GetState() & DWNLOAD_COMPLETE))
        Doc()->SaveImgCtxAs(_pImgCtx, NULL, IDM_SAVEPICTURE, pchFileName, cchFileName);
    RRETURN(S_OK);
}

void
CImgHelper::GetMarginInfo(CParentInfo * ppri,
                          LONG        * plLMargin,
                          LONG        * plTMargin,
                          LONG        * plRMargin,
                          LONG        * plBMargin)
{
    BOOL fParentVertical = GetFirstBranch()->IsParentVertical();
    LONG lhSpace  = fParentVertical ? GetAAvspace() : GetAAhspace();
    LONG lvSpace  = fParentVertical ? GetAAhspace() : GetAAvspace();
    BOOL fUseDefMargin = _pOwner->IsAligned() && !_pOwner->IsAbsolute() && (lhSpace == -1);
    LONG lhMargin = 0;
    LONG lvMargin = 0;

    if (lhSpace < 0)
        lhSpace = 0;
    if (lvSpace < 0)
        lvSpace = 0;

    lhSpace = ppri->DeviceFromDocPixelsX(lhSpace);
    lvSpace = ppri->DeviceFromDocPixelsY(lvSpace);

    if (plLMargin)
    {
        *plLMargin += lhSpace;
        lhMargin   += *plLMargin;
    }
    if (plRMargin)
    {
        *plRMargin += lhSpace;
        lhMargin   += *plRMargin;
    }
    if (plTMargin)
    {
        lvMargin   += *plTMargin;
        *plTMargin += lvSpace;
    }
    if (plBMargin)
    {
        lvMargin   += *plBMargin;
        *plBMargin += lvSpace;
    }
    if (lhMargin > 0 || lvMargin > 0)
    {
        // if vertical margins are defined,
        // Netscape compatibility should goes away.
        // but if just vspace is defined,
        // we still need to preserve this compatibility
        fUseDefMargin = FALSE;
    }

    if (   !IsStrictCSS1Document()  //don't apply netscape compat in Strict mode
        && fUseDefMargin 
        && (plLMargin || plRMargin))
    {
        // (srinib/yinxie) - netscape compatibility, aligned images have
        // a 3 pixel hspace by default
        Assert(ppri);
        long lhSpace = ppri->DeviceFromDocPixelsX( DEF_HSPACE );
        if (plLMargin)
        {
            *plLMargin += lhSpace;
        }
        if (plRMargin)
        {
            *plRMargin += lhSpace;
        }
    }
}

void
CImgHelper::CalcSize(
    CCalcInfo * pci,
    SIZE *      psize)
{
    SIZE            sizeImg;
    CBorderInfo     bi;
    SIZE            sizeBorderHVSpace2;
    CPeerHolder   * pPH = _pOwner->GetLayoutPeerHolder();

    sizeImg = g_Zero.size;

    Assert(pci);
    Assert(psize);

    CDoc *pDoc                   = Doc();
    CTreeNode * pNode            = GetFirstBranch();
    const CFancyFormat * pFF     = pNode->GetFancyFormat();
    const CCharFormat  * pCF     = pNode->GetCharFormat();
    BOOL fVerticalLayoutFlow     = pCF->HasVerticalLayoutFlow();
    BOOL fWritingModeUsed        = pCF->_fWritingModeUsed;
    const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
    const CUnitValue & cuvHeight = pFF->GetLogicalHeight(fVerticalLayoutFlow, fWritingModeUsed);
    BOOL fStrictCSS1Document = IsStrictCSS1Document();
    long lParentWidth;
    long lParentHeight  = pci->_sizeParent.cy;
    BOOL fHasWidth;
    BOOL fHasHeight;
    BOOL fMaxWidth;
    BOOL fMaxHeight;
    SIZE sizeNew, sizePlaceHolder;
    BOOL fHasSize;
    ULONG ulState;
    TCHAR * pchAlt = NULL;
    RECT rcText;

    if (IsStrictCSS1Document())
    {
        lParentWidth = pci->_sizeParent.cx;
        fHasWidth    = pFF->UseLogicalUserWidth(pCF->_fUseUserHeight, fVerticalLayoutFlow, fWritingModeUsed);
        fHasHeight   = pFF->UseLogicalUserHeight(pCF->_fUseUserHeight, fVerticalLayoutFlow, fWritingModeUsed);
        fMaxWidth    =  fHasWidth 
                    &&  cuvWidth.IsPercent() 
                    &&  (   pci->_smMode == SIZEMODE_MMWIDTH || pci->_smMode == SIZEMODE_MINWIDTH   );
        fMaxHeight   =  fHasHeight 
                    &&  cuvHeight.IsPercent() 
                    &&  (   pci->_smMode == SIZEMODE_MMWIDTH || pci->_smMode == SIZEMODE_MINWIDTH   );
    }
    else 
    {
        lParentWidth = psize->cx;
        fHasWidth    = !cuvWidth.IsNullOrEnum();
        fHasHeight   = !cuvHeight.IsNullOrEnum();
        fMaxWidth    =  cuvWidth.IsPercent() 
                    &&  (   pci->_smMode == SIZEMODE_MMWIDTH || pci->_smMode == SIZEMODE_MINWIDTH   );
        fMaxHeight   =  cuvHeight.IsPercent() 
                    &&  (   pci->_smMode == SIZEMODE_MMWIDTH || pci->_smMode == SIZEMODE_MINWIDTH   );
    }

    _pOwner->GetBorderInfo( pci, &bi, FALSE, FALSE );

    sizeBorderHVSpace2.cx = bi.aiWidths[SIDE_LEFT] + bi.aiWidths[SIDE_RIGHT];
    sizeBorderHVSpace2.cy = bi.aiWidths[SIDE_TOP] + bi.aiWidths[SIDE_BOTTOM];

    if (fStrictCSS1Document)
    {
        const CUnitValue & cuvPaddingLeft   = pFF->GetLogicalPadding(SIDE_LEFT, fVerticalLayoutFlow, fWritingModeUsed);
        const CUnitValue & cuvPaddingTop    = pFF->GetLogicalPadding(SIDE_TOP, fVerticalLayoutFlow, fWritingModeUsed);
        const CUnitValue & cuvPaddingRight  = pFF->GetLogicalPadding(SIDE_RIGHT, fVerticalLayoutFlow, fWritingModeUsed);
        const CUnitValue & cuvPaddingBottom = pFF->GetLogicalPadding(SIDE_BOTTOM, fVerticalLayoutFlow, fWritingModeUsed);

        // NOTE : for both horizontal and vertical paddings we provide lParentWidth as a reference (for percentage values), 
        //        this is done intentionally as per css spec.
        _lPadding[SIDE_LEFT]   = cuvPaddingLeft.XGetPixelValue(pci, lParentWidth, pNode->GetFontHeightInTwips(&cuvPaddingLeft));
        _lPadding[SIDE_TOP]    = cuvPaddingTop.YGetPixelValue(pci, lParentWidth, pNode->GetFontHeightInTwips(&cuvPaddingTop));
        _lPadding[SIDE_RIGHT]  = cuvPaddingRight.XGetPixelValue(pci, lParentWidth, pNode->GetFontHeightInTwips(&cuvPaddingRight));
        _lPadding[SIDE_BOTTOM] = cuvPaddingBottom.YGetPixelValue(pci, lParentWidth, pNode->GetFontHeightInTwips(&cuvPaddingBottom));
    }
    else 
    {
        _lPadding[SIDE_LEFT]   = 
        _lPadding[SIDE_TOP]    = 
        _lPadding[SIDE_RIGHT]  = 
        _lPadding[SIDE_BOTTOM] = 0;

        // NOTE : adjust size provided by parent only if this is not CSS1 strict case.
        lParentWidth  = max(0L, lParentWidth-sizeBorderHVSpace2.cx);
        lParentHeight = max(0L, lParentHeight-sizeBorderHVSpace2.cy);
    }

#ifndef NO_AVI
    if (_pBitsCtx && _pVideoObj)
    {
        ulState = _pBitsCtx->GetState(); // TODO (lmollico): ulState should be an IMGLOAD_*
        fHasSize = OK(_pVideoObj->GetSize(&sizeImg));
    }
    else
#endif // ndef NO_AVI
    if (_pImgCtx)
    {
        if (!_fSizeChange)
        {
            _pImgCtx->SelectChanges(IMGCHG_SIZE, 0, FALSE);

            _fSizeChange = TRUE;
        }
        ulState = _pImgCtx->GetState(FALSE, &sizeImg);
        fHasSize = (sizeImg.cx || sizeImg.cy);
    }
    else
    {
        ulState = IMGLOAD_NOTLOADED;
        fHasSize = FALSE;
        _fNeedSize = TRUE;
    }

    if (!fHasSize && pci->_fTableCalcInfo)
    {
        CTableCalcInfo * ptci = (CTableCalcInfo *) pci;
        ptci->_fDontSaveHistory = TRUE;
    }


    //
    //  This object needs sizing, first determine if we have a layoutBehavior
    //  that wants full delegation.  If not, then do the normal sizing
    //  We do this block of code here, because the variable setup above has
    //  sideeffects in the imgctx and in the tablecalcinfo, and this avoids bugs.
    //---------------------------------------------------------------------------
    if (   pPH 
        && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_FULLDELEGATION))
    {
        // There is a peer layout that wants full_delegation of the sizing.        
        POINT pt;

        pt.x = pt.y = 0;

        //NOTE: It doesn't make sense to honor the offsetPoint here
        if (Layout())
            Layout()->DelegateCalcSize(BEHAVIORLAYOUTINFO_FULLDELEGATION,
                                       pPH, pci, *psize, &pt, psize);
    }
    else
    {
        // Normal (non-delegated) size calculation happens here
        if (fHasSize ||
            (_pImgCtx && !_fExpandAltText && GetCachedImageSize(_pImgCtx->GetUrl(), &sizeImg)))
        {
            sizePlaceHolder.cx = sizeNew.cx = pci->DeviceFromDocPixelsX(sizeImg.cx);
            sizePlaceHolder.cy = sizeNew.cy = pci->DeviceFromDocPixelsY(sizeImg.cy);
        }
        else
        {
            SIZE sizeGrab;
            GetPlaceHolderBitmapSize(ulState & (IMGLOAD_ERROR | IMGLOAD_STOPPED),
                                     &sizeNew);
            sizeNew.cx = pci->DeviceFromDocPixelsX(sizeNew.cx);
            sizeNew.cy = pci->DeviceFromDocPixelsY(sizeNew.cy);
            sizeGrab.cx = pci->DeviceFromDocPixelsX(GRABSIZE);
            sizeGrab.cy = pci->DeviceFromDocPixelsY(GRABSIZE);

            pchAlt = (TCHAR *)GetAAalt();

            if (pchAlt && *pchAlt)
            {
                const CCharFormat *pCF = pNode->GetCharFormat();

                CIntlFont intlfont(pci,
                                   pci->_hdc,
                                   _pOwner->GetMarkup()->GetCodePage(),
                                   pCF ? pCF->_lcid : 0,
                                   pDoc->_sBaselineFont,
                                   pchAlt);

                rcText.left = rcText.top = rcText.right = rcText.bottom = 0;
                DrawTextInCodePage(WindowsCodePageFromCodePage(_pOwner->GetMarkup()->GetCodePage()),
                         pci->_hdc, pchAlt, -1, &rcText, DT_CALCRECT | DT_NOPREFIX);

                sizePlaceHolder.cx = sizeNew.cx + 3 * sizeGrab.cx + rcText.right - rcText.left;
                sizePlaceHolder.cy = max(sizeNew.cy, rcText.bottom - rcText.top) + 2 * sizeGrab.cy;
            }
            else
            {
                sizePlaceHolder.cx = sizeNew.cx + 2 * sizeGrab.cx;
                sizePlaceHolder.cy = sizeNew.cy + 2 * sizeGrab.cy;
            }
        }
        if (!fHasWidth || !fHasHeight)
        {
            // If the image Width is set, use it
            if (fHasWidth && !fMaxWidth)
            {
                psize->cx = cuvWidth.XGetPixelValue( pci,
                                        lParentWidth,
                                        pNode->GetFontHeightInTwips(&cuvWidth));
            }
            else
            {
                // if height only is set, then the image should be proportional
                // to the real size sizeNew.cx
                if (fHasHeight && !fMaxHeight && (sizeNew.cy > 0))
                {
                    psize->cx = MulDivQuick(cuvHeight.YGetPixelValue(pci,
                                                            lParentHeight,
                                                            pNode->GetFontHeightInTwips(&cuvHeight)),
                                            sizeNew.cx,
                                            sizeNew.cy);
                }
                else
                {
                    psize->cx = sizePlaceHolder.cx;
                }
            }

            // If the image Height is set, use it
            if (fHasHeight && !fMaxHeight)
            {
                psize->cy = cuvHeight.YGetPixelValue(pci,
                                            lParentHeight,
                                            pNode->GetFontHeightInTwips(&cuvHeight));
            }
            else
            {
                // if width only is set, then the image should be proportional
                // to the real size sizeNew.cx
                if (fHasWidth && !fMaxWidth && (sizeNew.cx > 0))
                {
                    psize->cy = MulDivQuick(cuvWidth.XGetPixelValue(pci,
                                                            lParentWidth,
                                                            pNode->GetFontHeightInTwips(&cuvWidth)),
                                            sizeNew.cy,
                                            sizeNew.cx);
                }
                else
                {
                    psize->cy = sizePlaceHolder.cy;
                }
            }

        }
        else
        {
            if (!fMaxWidth)
                psize->cx = cuvWidth.XGetPixelValue(pci,
                                        lParentWidth,
                                        pNode->GetFontHeightInTwips(&cuvWidth));
            else
                psize->cx = sizePlaceHolder.cx;
            if (!fMaxHeight)
                psize->cy = cuvHeight.YGetPixelValue(pci,
                                        lParentHeight,
                                        pNode->GetFontHeightInTwips(&cuvHeight));
            else
                psize->cy = sizePlaceHolder.cy;
        }

        if (_fExpandAltText && pchAlt && *pchAlt && !fHasSize)
        {
            if (psize->cx < sizePlaceHolder.cx)
                psize->cx = sizePlaceHolder.cx;
            if (psize->cy < sizePlaceHolder.cy)
                psize->cy = sizePlaceHolder.cy;
        }

        if (psize->cx > 0)
            psize->cx += sizeBorderHVSpace2.cx + _lPadding[SIDE_LEFT] + _lPadding[SIDE_RIGHT];
        else
            psize->cx = sizeBorderHVSpace2.cx + _lPadding[SIDE_LEFT] + _lPadding[SIDE_RIGHT];
        if (psize->cy > 0)
            psize->cy += sizeBorderHVSpace2.cy + _lPadding[SIDE_TOP] + _lPadding[SIDE_BOTTOM];
        else
            psize->cy = sizeBorderHVSpace2.cy + _lPadding[SIDE_TOP] + _lPadding[SIDE_BOTTOM];


        // but before we can return we need to give a layoutBehavior a chance
        // to override the default natural sizing.
        //-------------------------------------------------------------------
        if (   pPH 
            && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
        {
            // There is a peer layout that wants to modify the natural sizing 
            POINT pt;

            pt.x = pt.y = 0;

        if (Layout())
            Layout()->DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL,
                                       pPH, pci, *psize, &pt, psize);
        }
    } // end else not delegateCalcSize
}

HRESULT
CImgHelper::CacheImage(XHDC hdc, CRect * prcDst, SIZE *pSize, DWORD dwFlags, ULONG ulState)
{
    HRESULT hr = S_OK;
    HDC     hdcMem = NULL;
    HBITMAP hbmSav = NULL;

    hdcMem = GetMemoryDC();
    if (hdcMem == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _xWidCache = prcDst->Width();
    _yHeiCache = prcDst->Height();

    _colorMode = GetDefaultColorMode();

    if (_hbmCache)
        DeleteObject(_hbmCache);

    _hbmCache = CreateCompatibleBitmap(hdc, _xWidCache, _yHeiCache);
    if (_hbmCache == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hbmSav = (HBITMAP) SelectObject(hdcMem, _hbmCache);

    if (!(ulState & IMGTRANS_OPAQUE))
        dwFlags |= DRAWIMAGE_NOTRANS;

    _pImgCtx->DrawEx(XHDC(hdcMem, NULL), prcDst, dwFlags);

Cleanup:
    if (hbmSav)
        SelectObject(hdcMem, hbmSav);
    if (hdcMem)
        ReleaseMemoryDC(hdcMem);

    RRETURN(hr);
}

void
CImgHelper::DrawCachedImage(XHDC hdc, CRect * prcDst, DWORD dwFlags, ULONG ulState)
{
    HDC     hdcMem = NULL;
    HBITMAP hbmSav = NULL;
    DWORD   dwRop;

    hdcMem = GetMemoryDC();
    if (hdcMem == NULL)
        goto Cleanup;

    hbmSav = (HBITMAP) SelectObject(hdcMem, _hbmCache);

    if (ulState & IMGTRANS_OPAQUE)
    {
        dwRop = SRCCOPY;
    }
    else
    {
        _pImgCtx->DrawEx(hdc, prcDst, dwFlags | DRAWIMAGE_MASKONLY);

        dwRop = SRCAND;
    }

    BitBlt(hdc, prcDst->left, prcDst->top,
        prcDst->Width(), prcDst->Height(),
        XHDC(hdcMem, NULL), prcDst->left, prcDst->top, dwRop);

Cleanup:
    if (hbmSav)
        SelectObject(hdcMem, hbmSav);
    if (hdcMem)
        ReleaseMemoryDC(hdcMem);
}

//+---------------------------------------------------------------------------
//
//  Member:     Draw
//
//  Synopsis:   Paint the object. Note that this function does not save draw
//              info. Derived classes must override Draw() and save draw info
//               before calling this function.
//
//----------------------------------------------------------------------------

void
CImgHelper::Draw(CFormDrawInfo *pDI)
{
    ULONG       ulState;
    XHDC        hdc = pDI->GetDC(TRUE);
    CRect       rcDst(pDI->_rc);

    //
    //  image padding adjustments
    //
    rcDst.left   += _lPadding[SIDE_LEFT];
    rcDst.top    += _lPadding[SIDE_TOP];
    rcDst.right  -= _lPadding[SIDE_RIGHT];
    rcDst.bottom -= _lPadding[SIDE_BOTTOM];


#ifndef NO_AVI
    if (_pBitsCtx && _pVideoObj)
        ulState = _pBitsCtx->GetState();
    else
#endif
    if (_pImgCtx)
        ulState = _pImgCtx->GetState();
    else
        ulState = IMGLOAD_NOTLOADED;

    if (!(ulState & (IMGBITS_NONE | IMGLOAD_NOTLOADED | IMGLOAD_ERROR)) && _fHideForSecurity)
        ulState = IMGLOAD_ERROR;

    if (ulState & (IMGBITS_NONE | IMGLOAD_NOTLOADED | IMGLOAD_ERROR))
    {
        SIZE sizePrint;
        SIZE sizeGrab = {GRABSIZE, GRABSIZE};
        CDoc *pDoc = Doc();
        BOOL fMissing = !!(ulState & IMGLOAD_ERROR);

        if (   fMissing 
            || !GetImgCtx() 
            || !pDoc->_pOptionSettings->fShowImages 
            || pDoc->_pOptionSettings->fShowImagePlaceholder)
        {
            BOOL fPrint = Layout(pDI->GetLayoutContext())->ElementOwner()->GetMarkupPtr()->IsPrintMedia();
            const CCharFormat *pCF = GetFirstBranch()->GetCharFormat();
            COLORREF           fgColor = (pCF && pCF->_ccvTextColor.IsDefined()) ?
                                                    pCF->_ccvTextColor.GetColorRef()
                                                :   RGB(0, 0, 0);

            if (fPrint)        // For Printdoc, convert pixels to printer units
            {
                GetPlaceHolderBitmapSize(fMissing, &sizePrint);
                sizePrint.cx = pDI->DeviceFromDocPixelsX(sizePrint.cx);
                sizePrint.cy = pDI->DeviceFromDocPixelsY(sizePrint.cy);
                sizeGrab.cx = pDI->DeviceFromDocPixelsX(GRABSIZE);
                sizeGrab.cy = pDI->DeviceFromDocPixelsY(GRABSIZE);
            }

            DrawPlaceHolder(pDI, hdc, rcDst,
                (LPTSTR) GetAAalt(),
                _pOwner->GetMarkup()->GetCodePage(), pCF ? pCF->_lcid : 0, pDoc->_sBaselineFont,
                &sizeGrab, fMissing,
                fgColor, _pOwner->GetBackgroundColor(), fPrint ? &sizePrint : NULL, FALSE, pDI->DrawImageFlags());
        }
    }
    else if (_lCookie && _fIsInPlace)
    {
        CImgAnim * pImgAnim = GetImgAnim();

        if (pImgAnim)
            _pImgCtx->DrawFrame(hdc, pImgAnim->GetImgAnimState(_lCookie), &rcDst, NULL, NULL, pDI->DrawImageFlags());
    }
    else if (_pImgCtx)
    {
        DWORD dwFlags = pDI->DrawImageFlags();

        if (_fCache)
        {
            SIZE size;
            LONG xWidDst = rcDst.Width();
            LONG yHeiDst = rcDst.Height();

            _pImgCtx->GetState(FALSE, &size);

            if (    (ulState & IMGLOAD_COMPLETE)
                &&  (size.cx != xWidDst || size.cy != yHeiDst)
                &&  (size.cx != 1 || size.cy != 1))
            {
                HRESULT hr = S_OK;

                if (    _xWidCache != xWidDst
                    ||  _yHeiCache != yHeiDst
                    ||  _colorMode != GetDefaultColorMode())
                {
                    hr = CacheImage(hdc, &rcDst, &size, dwFlags, ulState);
                }

                if (hr == S_OK)
                {
                    DrawCachedImage(hdc, &rcDst, dwFlags, ulState);
                    return;
                }
            }
        }

        _pImgCtx->DrawEx(hdc, &rcDst, dwFlags);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\imgsize.cxx ===
//+------------------------------------------------------------------------
//
//  File:       imgsize.cxx
//
//  Contents:   Image size cache
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "shfolder.h"

#ifdef UNIX
#ifndef X_MAINWIN_H_
#define X_MAINWIN_H_
#include <mainwin.h>
#endif
#endif

#ifdef _MAC
#include <folders.h>
extern "C" {
Boolean _CopySzToSt(const char* sz, StringPtr st, short cchSt);
void _FSpFormat(const FSSpec* pfss, char* szBuffer);
}
#endif

struct CACHE_ENTRY
{
    DWORD dwHash;
    WORD  wWidth;
    WORD  wHeight;
};

struct CACHE_FILE
{
    DWORD dwMagic;
    DWORD dwVersion;
    DWORD dwHit;
    DWORD dwMiss;
    CACHE_ENTRY aCacheEntry[2046];
};
 
static HANDLE s_hCacheFileMapping;
static CACHE_FILE *s_pCacheFile;
static BOOL   s_fInitializationTried;

#define MAGIC       0xCAC8EF17
#define OBJ_NAME(x) "MSIMGSIZECache" #x
#define FILE_NAME   "MSIMGSIZ.DAT"

//+------------------------------------------------------------------------
//
//  VERSION     Increment this number with each file format change.
//
//-------------------------------------------------------------------------

#define VERSION 1

//+------------------------------------------------------------------------
//
//  Function:   InitImageSizeCache
//
//  Synopsis:   Open the image size cache file.  Create and initialize it
//              if required. 
//
//-------------------------------------------------------------------------

BOOL
InitImageSizeCache()
{
    BOOL   fInitialize = FALSE;
    HANDLE hMutex = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    CACHE_FILE * pCacheFile;

    if (s_fInitializationTried)
        return s_pCacheFile != NULL;

    s_fInitializationTried = TRUE;

#ifdef WIN16
//    MessageBox(NULL, "Need to implement InitImageSizeCache", "BUGWIN16", MB_OK);
#else
    hMutex = CreateMutexA(NULL, FALSE, OBJ_NAME(Mutex));
    if (!hMutex)
        goto Cleanup;

    if (WaitForSingleObject(hMutex, 4000) != WAIT_OBJECT_0)
        goto Cleanup;

    // Did another thread initialize when we were not looking?

    if (s_pCacheFile)
        goto Cleanup;

    // Open or create new file mapping.

    s_hCacheFileMapping = OpenFileMappingA(FILE_MAP_ALL_ACCESS, FALSE, OBJ_NAME(Map));
    if (s_hCacheFileMapping)
    {
        BOOL    fVersionMismatch = FALSE;
        pCacheFile = (CACHE_FILE *)MapViewOfFile(
                    s_hCacheFileMapping, 
                    FILE_MAP_ALL_ACCESS,            // access
                    0,                              // offset low
                    0,                              // offset high
                    sizeof(CACHE_FILE));            // number of bytes to map

        if (!pCacheFile)
            goto Cleanup;

        // Punt if some other version of Trident has the file open.

        __try
        {
            fVersionMismatch =      pCacheFile->dwMagic != MAGIC
                                ||  pCacheFile->dwVersion != VERSION;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            goto Cleanup;
        }

        if (fVersionMismatch)
            goto Cleanup;
    }
    else
    {
        // File mapping does not exist.  Open or create file.

        HRESULT hr = S_OK;
        char achBuf[MAX_PATH + sizeof(FILE_NAME) +1];
        int  cch;
#ifdef _MAC
        long    foundDirID;
        short   foundVRefNum;
        FSSpec  FileSpec;

        achBuf[0] = NULL;

        FindFolder(kOnSystemDisk, kSystemFolderType, false, &foundVRefNum, &foundDirID);
        FileSpec.vRefNum = foundVRefNum;
        FileSpec.parID = foundDirID;
        _CopySzToSt(FILE_NAME, FileSpec.name, 64);

        _FSpFormat(&FileSpec, achBuf);
#else
#ifdef UNIX
        cch = MwGetUserWindowsDirectoryA(achBuf, MAX_PATH);
#else
        hr = SHGetFolderPathA(NULL, CSIDL_LOCAL_APPDATA, NULL, 0, achBuf);
        if (hr)
            goto Cleanup;

        strcat(achBuf, "\\Microsoft");
        if (!PathFileExistsA(achBuf) && !CreateDirectoryA(achBuf, NULL))
        {
            goto Cleanup;
        }
        strcat(achBuf, "\\Internet Explorer");
        if (!PathFileExistsA(achBuf) && !CreateDirectoryA(achBuf, NULL))
        {
            goto Cleanup;
        }

        cch = strlen(achBuf);
#endif
        if (cch == 0)
            goto Cleanup;

        if (achBuf[cch - 1] != FILENAME_SEPARATOR)
            achBuf[cch++] = FILENAME_SEPARATOR;
        strcpy(&achBuf[cch], FILE_NAME);
#endif // _MAC

        hFile = CreateFileA(
            achBuf,
            GENERIC_READ | GENERIC_WRITE,       // access mode
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share mode
            NULL,                               // security
            OPEN_ALWAYS,                        // disposition
            0,                                  // flags and attributes
            NULL);                              // template file

        if (hFile == INVALID_HANDLE_VALUE)
            goto Cleanup;

        // Do we need to initialize the file?

        if (GetLastError() != ERROR_ALREADY_EXISTS)
            fInitialize = TRUE;
      
        if (GetFileSize(hFile, NULL) != sizeof(CACHE_FILE))
        {
            fInitialize = TRUE;
            SetFilePointer(hFile, sizeof(CACHE_FILE), NULL, FILE_BEGIN);
            SetEndOfFile(hFile);
        }

        // Create the mapping.

        s_hCacheFileMapping = CreateFileMappingA(
                hFile,                          // file
                NULL,                           // security
                PAGE_READWRITE,                 // protect
                0,                              // size low
                0,                              // size high
                OBJ_NAME(Map));                 // name

        if (!s_hCacheFileMapping)
            goto Cleanup;

        // Map view of file.

        pCacheFile = (CACHE_FILE *)MapViewOfFile(
                    s_hCacheFileMapping, 
                    FILE_MAP_ALL_ACCESS,            // access
                    0,                              // offset low
                    0,                              // offset high
                    sizeof(CACHE_FILE));            // number of bytes to map

        if (!pCacheFile)
            goto Cleanup;

        // Reset the contents of the file if we are opening it for the
        // first time or if the file contents do not look right.

        __try
        {
            if (fInitialize ||
                pCacheFile->dwMagic != MAGIC ||
                pCacheFile->dwVersion != VERSION)
            {
                memset(pCacheFile, 0, sizeof(CACHE_FILE));
                pCacheFile->dwMagic = MAGIC;
                pCacheFile->dwVersion = VERSION;
                FlushViewOfFile(pCacheFile, sizeof(CACHE_FILE));
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }

    }
    
    s_pCacheFile = pCacheFile;

Cleanup:
    if (!s_pCacheFile && s_hCacheFileMapping)
    {
        CloseHandle(s_hCacheFileMapping);
        s_hCacheFileMapping = NULL;
    }

    if (hMutex)
    {
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
    }  

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }
#endif // ndef WIN16

    return s_pCacheFile != NULL;
}

//+------------------------------------------------------------------------
//
//  Function:   DeinitImageSizeCache
//
//  Synopsis:   Undo action of InitImageSizeCache 
//
//-------------------------------------------------------------------------

void
DeinitImageSizeCache()
{
#ifndef WIN16
    if (s_pCacheFile)
    {
        FlushViewOfFile(s_pCacheFile, sizeof(CACHE_FILE));
        UnmapViewOfFile(s_pCacheFile);
    }
#endif // ndef WIN16
    if (s_hCacheFileMapping)
    {
        CloseHandle(s_hCacheFileMapping);
    }

    s_pCacheFile = NULL;
    s_hCacheFileMapping = NULL;
}

//+------------------------------------------------------------------------
//
//  Function:   HashData
//
//  Synopsis:   Compute hash of bytes.
//
//-------------------------------------------------------------------------

// TODO (garybu) Hash function is duplicated. Should export common fn from shlwapi.

const static BYTE Translate[256] =
{
    1, 14,110, 25, 97,174,132,119,138,170,125,118, 27,233,140, 51,
    87,197,177,107,234,169, 56, 68, 30,  7,173, 73,188, 40, 36, 65,
    49,213,104,190, 57,211,148,223, 48,115, 15,  2, 67,186,210, 28,
    12,181,103, 70, 22, 58, 75, 78,183,167,238,157,124,147,172,144,
    176,161,141, 86, 60, 66,128, 83,156,241, 79, 46,168,198, 41,254,
    178, 85,253,237,250,154,133, 88, 35,206, 95,116,252,192, 54,221,
    102,218,255,240, 82,106,158,201, 61,  3, 89,  9, 42,155,159, 93,
    166, 80, 50, 34,175,195,100, 99, 26,150, 16,145,  4, 33,  8,189,
    121, 64, 77, 72,208,245,130,122,143, 55,105,134, 29,164,185,194,
    193,239,101,242,  5,171,126, 11, 74, 59,137,228,108,191,232,139,
    6, 24, 81, 20,127, 17, 91, 92,251,151,225,207, 21, 98,113,112,
    84,226, 18,214,199,187, 13, 32, 94,220,224,212,247,204,196, 43,
    249,236, 45,244,111,182,153,136,129, 90,217,202, 19,165,231, 71,
    230,142, 96,227, 62,179,246,114,162, 53,160,215,205,180, 47,109,
    44, 38, 31,149,135,  0,216, 52, 63, 23, 37, 69, 39,117,146,184,
    163,200,222,235,248,243,219, 10,152,131,123,229,203, 76,120,209
};

#define HashData MSHTMLHashData // avoid conflict with shlwapi
void HashData(LPBYTE pbData, DWORD cbData, LPBYTE pbHash, DWORD cbHash)
{
    DWORD i, j;
    //  seed the hash
    for (i = cbHash; i-- > 0;)
        pbHash[i] = (BYTE) i;

    //  do the hash
    for (j = cbData; j-- > 0;)
    {
        for (i = cbHash; i-- > 0;)
            pbHash[i] = Translate[pbHash[i] ^ pbData[j]];
    }
}

//+------------------------------------------------------------------------
//
//  Function:   GetCachedImageSize
//
//  Synopsis:   Get cached image size, returns FALSE if not found. 
//
//-------------------------------------------------------------------------

BOOL
GetCachedImageSize(LPCTSTR pchURL, SIZE *psize)
{
    CACHE_ENTRY *pCacheEntry;

    struct { DWORD dw; WORD  w; } Hash;

    if (!InitImageSizeCache())
        return FALSE;

    HashData((BYTE *)pchURL, _tcslen(pchURL) * sizeof(TCHAR), (BYTE *)&Hash, sizeof(Hash));
    if (Hash.dw == 0) Hash.dw = 1;

    pCacheEntry = &s_pCacheFile->aCacheEntry[Hash.w % ARRAY_SIZE(s_pCacheFile->aCacheEntry)];

    // The following chunk of code can read bad values because the cache memory 
    // is shared by multiple processes.  We don't bother with the expense
    // of a mutex because we can tolerate fetching a bad image size.

    //
    // read / write to/from Maped file can raise exceptions
    //
    __try
    {
        if (pCacheEntry->dwHash == Hash.dw)
        {
            psize->cx = pCacheEntry->wWidth;
            psize->cy = pCacheEntry->wHeight;
            #if DBG==1
                s_pCacheFile->dwHit += 1;
            #endif
            return TRUE;
        }
    #if DBG==1
        s_pCacheFile->dwMiss += 1;
    #endif
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return FALSE;
}


//+------------------------------------------------------------------------
//
//  Function:   SetCachedImageSize
//
//  Synopsis:   Save image size for future use. 
//
//-------------------------------------------------------------------------

void
SetCachedImageSize(LPCTSTR pchURL, SIZE size)
{
    CACHE_ENTRY *pCacheEntry;

    struct { DWORD dw; WORD  w; } Hash;

    if (!InitImageSizeCache())
        return;

    HashData((BYTE *)pchURL, _tcslen(pchURL) * sizeof(TCHAR), (BYTE *)&Hash, sizeof(Hash));
    if (Hash.dw == 0) Hash.dw = 1;
    pCacheEntry = &s_pCacheFile->aCacheEntry[Hash.w % ARRAY_SIZE(s_pCacheFile->aCacheEntry)];

    // The following chunk of code can confuse GetCachedImageSize because
    // the cache memory is shared by multiple processes.  We don't 
    // bother with the expense of a mutex because we can tolerate fetching a 
    // bad image size.

    //
    // read / write to/from Maped file can raise exceptions
    //

    __try
    {
        pCacheEntry->wWidth = size.cx;
        pCacheEntry->wHeight = size.cy;
        pCacheEntry->dwHash = Hash.dw;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\inputtxt.cxx ===
//+---------------------------------------------------------------------
//
//   File:      inputtxt.cxx
//
//  Contents:   InputTxt element class, etc..
//
//  Classes:    CInput, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SIZE_HXX_
#define X_SIZE_HXX_
#include "size.hxx"
#endif

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include <cguid.h>
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"
#endif

#ifndef X_IMGHLPER_HXX_
#define X_IMGHLPER_HXX_
#include "imghlper.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_INPUTBTN_HXX_
#define X_INPUTBTN_HXX_
#include "inputbtn.hxx"
#endif

#ifndef X_IMGHLPER_HXX_
#define X_IMGHLPER_HXX_
#include "imghlper.hxx"
#endif

#ifndef X_INPUTLYT_HXX_
#define X_INPUTLYT_HXX_
#include "inputlyt.hxx"
#endif

#ifndef X_CKBOXLYT_HXX_
#define X_CKBOXLYT_HXX_
#include "ckboxlyt.hxx"
#endif

#ifndef X_IMGLYT_HXX_
#define X_IMGLYT_HXX_
#include "imglyt.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X__TEXT_H_
#define X__TEXT_H_
#include "_text.h"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif

#ifndef X_THEMEHLP_HXX_
#define X_THEMEHLP_HXX_
#include "themehlp.hxx"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif


#define _cxx_
#include "inputtxt.hdl"

DeclareTag(tagAllowMorphing, "CInput", "Allow input one time morphing");

MtDefine(CInput, Elements, "CInput")
MtDefine(CInputSetValueHelperReal, Locals, "CInput::SetValueHelperReal (temp)")
MtDefine(CRadioGroupAry, Elements, "CRadioGroupAry")
MtDefine(CRadioGroupAry_pv, CRadioGroupAry, "CRadioGroupAry::_pv")

HRESULT GetCallerCommandTarget (CBase *pBase, IServiceProvider *pSP, BOOL fFirstScriptSite, IOleCommandTarget **ppCommandTarget);

//
// This is a generic creation function for our input controls
// parser.cpp should point to this function for ETAG_INPUT
//

HRESULT
CreateInputElement(CHtmTag *pht, CDoc *pDoc, CElement **ppElement)
{
    HRESULT         hr = S_OK;
    long            iType;
    TCHAR *         pchType;

    Assert(pht->Is(ETAG_INPUT));

    // Fetch type from the attributes and map to enum. Default to input text.

    if (!pht->ValFromName(_T("type"), &pchType) ||
            FAILED(s_enumdeschtmlInput.EnumFromString(pchType, &iType, FALSE)))
    {
        iType = htmlInputText;
    }

    // Map input type enum to create function.

    switch (iType)
    {
        default:
            // Convert bogus Input types to default. These enum values exist only
            // because TEXTAREA, HTMLAREA and SELECT support the type attribute
            // and use these values to specify the type. These values have no
            // meaning when used with an INPUT tag and are mapped to the default
            // value of htmlInputText.
            iType= htmlInputText;
            // fall through
        case htmlInputReset:
        case htmlInputSubmit:
        case htmlInputButton:
        case htmlInputHidden:
        case htmlInputPassword:
        case htmlInputText:
        case htmlInputFile:
        case htmlInputImage:
        case htmlInputRadio:
        case htmlInputCheckbox:
            hr = THR(CInput::CreateElement(pht, pDoc, ppElement, (htmlInput)iType));
            if (hr == S_OK)
                DYNCAST(CInput, *ppElement)->_fScriptCreated = pht->IsDynamic();
            break;
    }

    RRETURN(hr);
}


CElement::ACCELS CInput::s_AccelsInputTxtRun    = CElement::ACCELS (NULL, IDR_ACCELS_INPUTTXT_RUN);

static const TCHAR s_achUtf8[] = TEXT("utf-8");

// Input Class Decriptor
const CElement::CLASSDESC CInput::s_classdescHidden =
{
    {
        &CLSID_HTMLInputElement,    // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE |          // _dwFlags
        ELEMENTDESC_DONTINHERITSTYLE |
        ELEMENTDESC_SHOWTWS |
        ELEMENTDESC_VPADDING |
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLInputElement,   // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLInputElement, // _pfnTearOff
    &s_AccelsInputTxtRun                // _pAccelsRun
};

const CElement::CLASSDESC CInput::s_classdescPassword =
{
    {
        &CLSID_HTMLInputElement,    // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE |          // _dwFlags
        ELEMENTDESC_DONTINHERITSTYLE |
        ELEMENTDESC_SHOWTWS |
        ELEMENTDESC_VPADDING |
        ELEMENTDESC_CANSCROLL |
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLInputElement,     // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLInputElement, // _pfnTearOff
    &s_AccelsInputTxtRun                // _pAccelsRun
};

const CElement::CLASSDESC CInput::s_classdescText =
{
    {
        &CLSID_HTMLInputElement,    // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE |          // _dwFlags
        ELEMENTDESC_DONTINHERITSTYLE |
        ELEMENTDESC_SHOWTWS |
        ELEMENTDESC_VPADDING |
        ELEMENTDESC_CANSCROLL |
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLInputElement,     // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLInputElement, // _pfnTearOff
    &s_AccelsInputTxtRun                // _pAccelsRun
};

const CElement::CLASSDESC CInput::s_classdescBtn =
{
    {
        &CLSID_HTMLInputElement,      // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_TEXTSITE |
        ELEMENTDESC_DONTINHERITSTYLE |
        ELEMENTDESC_SHOWTWS |
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NEVERSCROLL |
        ELEMENTDESC_NOANCESTORCLICK|
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLInputElement,       // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLInputElement,  // _pfnTearOff
    NULL                                    // _pAccelsRun
};

// Submit Class Decriptor

const CElement::CLASSDESC CInput::s_classdescSubmit =
{
    {
        &CLSID_HTMLInputElement,    // _pclsid
        0,                                // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                   // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                           // _pcpi
        ELEMENTDESC_TEXTSITE |
        ELEMENTDESC_DONTINHERITSTYLE |
        ELEMENTDESC_DEFAULT |             // input/submit is the default button
        ELEMENTDESC_SHOWTWS |
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NEVERSCROLL |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLInputElement,     // _piidDispinterface
        &s_apHdlDescs,                    // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLInputElement,  // _pfnTearOff
    NULL                                  // _pAccelsRun
};

// Reset Class Decriptor

const CElement::CLASSDESC CInput::s_classdescReset =
{
    {
        &CLSID_HTMLInputElement,     // _pclsid
        0,                                 // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                    // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                            // _pcpi
        ELEMENTDESC_TEXTSITE |
        ELEMENTDESC_DONTINHERITSTYLE |
        ELEMENTDESC_CANCEL |               // input/reset is the cancel button
        ELEMENTDESC_SHOWTWS |
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NEVERSCROLL |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLInputElement,      // _piidDispinterface
        &s_apHdlDescs,                     // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLInputElement,  // _pfnTearOff
    NULL                                   // _pAccelsRun
};

const CElement::CLASSDESC CInput::s_classdescFile =
{
    {
        &CLSID_HTMLInputElement,        // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE |          // _dwFlags
        ELEMENTDESC_DONTINHERITSTYLE |
        ELEMENTDESC_SHOWTWS |
        ELEMENTDESC_CANSCROLL |
        ELEMENTDESC_VPADDING |
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_OMREADONLY |        // block OM from accessing value
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLInputElement,     // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLInputElement,  // _apfnTearOff
    &s_AccelsInputTxtRun                // _pAccelsRun
};

const CElement::CLASSDESC CInput::s_classdescCheckbox =
{
    {
        &CLSID_HTMLInputElement,      // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                      // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                              // _pcpi
        ELEMENTDESC_NEVERSCROLL     |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_HASDEFDESCENT,          // _dwFlags
        &IID_IHTMLInputElement,       // _piidDispinterface
        &s_apHdlDescs,                       // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLInputElement,  //_apfnTearOff
    NULL                                     // _pAccelsRun
};


const CElement::CLASSDESC CInput::s_classdescImage =
{
    {
        &CLSID_HTMLInputElement,        // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NEVERSCROLL     |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_DEFAULT |           // input/image can act as default button -#3397
        ELEMENTDESC_EXBORDRINMOV,       // _dwFlags
        &IID_IHTMLInputElement,    // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLInputElement,  // _pfnTearOff
    NULL                                // _pAccelsRun
};
   
static const IID * s_aInputInterface[] =   {
            &IID_IHTMLInputTextElement,         //    htmlInputNotSet = 0,
            &IID_IHTMLInputButtonElement,       //    htmlInputButton = 1,
            &IID_IHTMLOptionButtonElement,      //    htmlInputCheckbox = 2,
            &IID_IHTMLInputFileElement,         //    htmlInputFile = 3,
            &IID_IHTMLInputHiddenElement,       //    htmlInputHidden = 4,
            &IID_IHTMLInputImage,               //    htmlInputImage = 5,
            &IID_IHTMLInputTextElement,         //    htmlInputPassword = 6,
            &IID_IHTMLOptionButtonElement,      //    htmlInputRadio = 7,
            &IID_IHTMLInputButtonElement,       //    htmlInputReset = 8,
            NULL,                               //    htmlInputSelectOne = 9,
            NULL,                               //    htmlInputSelectMultiple = 10,
            &IID_IHTMLInputButtonElement,       //    htmlInputSubmit = 11,
            &IID_IHTMLInputTextElement,         //    htmlInputText = 12,
            NULL,                               //    htmlInputTextarea = 13,
            NULL,                               //    htmlInputRichtext = 14,
            };

CInput::CInput (ELEMENT_TAG etag, CDoc *pDoc, htmlInput type)
: CSite(etag, pDoc)
{
    _fHasInitValue  = FALSE;
    _fInSave        = FALSE;
#ifdef WIN16
    m_baseOffset = ((BYTE *) (void *) (CBase *)this) - ((BYTE *) this);
    m_ElementOffset = ((BYTE *) (void *) (CElement *)this) - ((BYTE *) this);
#endif
    SetType(type);
    SetTypeAtCreate(type);
    switch (type)
    {
    case htmlInputImage:
        _fNoUIActivateInDesign = TRUE;
    case htmlInputButton:
    case htmlInputReset:
    case htmlInputSubmit:
        _fActsLikeButton = TRUE;
        break;
    }
    _icfButton = -1;
}


#ifndef NO_PROPERTY_PAGE
const CLSID * const CInput::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE

extern class CFontCache & fc();

BOOL
IsTypeMultiline(htmlInput type)
{
    switch (type)
    {
    case htmlInputButton:
    case htmlInputSubmit:
    case htmlInputReset:
    case htmlInputHidden:
        return TRUE;
    default:
        return FALSE;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     Init
//
//  Synopsis:
//
//-------------------------------------------------------------------------

HRESULT
CInput::Init()
{
    HRESULT hr = S_OK;

    if (GetType() == htmlInputImage)
    {
        _pImage = new CImgHelper(Doc(), this, TRUE);

        if (!_pImage)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = super::Init();

Cleanup:
    RRETURN(hr);
}

HRESULT
CInput::Init2(CInit2Context * pContext)
{
    HRESULT hr = S_OK;
    CMarkup * pSlaveMarkup = NULL;

    htmlInput           type = GetType();

    // Convert bogus Input types to default. These enum values exist only
    // because TEXTAREA, HTMLAREA and SELECT support the type attribute
    // and use these values to specify the type. These values have no
    // meaning when used with an INPUT tag and are mapped to the default
    // value of htmlInputText.
    if (GetAAtype() != type)
    {
        Assert(type == htmlInputText);
        hr = THR(SetAAtype(type));
        if (hr)
            goto Cleanup;
    }

    switch(type)
    {
    case    htmlInputRadio:

        // Defer clearing the other radio buttons in the group. This would
        // prevent the collections from being accessed prematurely in
        // SetChecked() called from super::Init2(). The clearing would
        // happen in AddToCollections().

        _fDeferClearGroup = TRUE;

        // fall through

    case    htmlInputCheckbox:

        hr = THR(super::Init2(pContext));
        if (type == htmlInputRadio)
        {
            _fDeferClearGroup = FALSE;
        }
        goto Cleanup;

    case    htmlInputImage:
            RRETURN1 (super::Init2(pContext), S_INCOMPLETE);
    }

    hr = THR(super::Init2(pContext));
    if (hr)
        goto Cleanup;

    // create inner element
    hr = THR(CreateSlave());
    if (hr)
        goto Cleanup;

    if (HasSlavePtr())
    {
        pSlaveMarkup = GetSlavePtr()->GetMarkup();
        if (pSlaveMarkup)
            pSlaveMarkup->_fNoUndoInfo = TRUE;
    }

    // Set the default value for the control, if any. The default value
    // is specified using the 'value' attribute. If none was specified,
    // submit and reset buttons have their own implicit default values.

    hr = PrivateInit2();
    if (hr)
        goto Cleanup;

    if (pSlaveMarkup)
        pSlaveMarkup->_fNoUndoInfo = FALSE;

#ifdef  NEVER
    if (_fHasInitValue)
    {
        hr = SetValueHelper((TCHAR *) _cstrDefaultValue, _cstrDefaultValue.Length(), FALSE);
        if (hr)
            goto Cleanup;
    }
    else
    {
        UINT    uiBtnDefault    = IDS_BUTTONCAPTION_SUBMIT;
        TCHAR   pszCaption[128];
        int     c;
        
        switch (type)
        {
        case htmlInputReset:
            uiBtnDefault = IDS_BUTTONCAPTION_RESET;
            // fall through
        case htmlInputSubmit:
            c = LoadString(GetResourceHInst(),
                           uiBtnDefault, pszCaption, ARRAY_SIZE(pszCaption));
            if (c)
            {
                hr = THR(SetValueHelper(pszCaption, c));
                if (hr)
                    goto Cleanup;
            }
            break;
        }
    }

    _fTextChanged = FALSE;
#endif

Cleanup:

    RRETURN1(hr, S_INCOMPLETE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CInput::QueryStatus
//
//  Synopsis:   Called to discover if a given command is supported
//              and if it is, what's its state.  (disabled, up or down)
//
//--------------------------------------------------------------------------

HRESULT
CInput::QueryStatus(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));
    Assert(cCmds == 1);

    HRESULT     hr = S_OK;
    MSOCMD *    pCmd = & rgCmds[0];
    ULONG       cmdID;
    htmlInput   type = GetType();
    
    Assert(Doc());
    Assert(!pCmd->cmdf);

    cmdID = CBase::IDMFromCmdID( pguidCmdGroup, pCmd->cmdID );

    if (type == htmlInputImage)
    {
        Assert(_pImage);
        hr = _pImage->QueryStatus(
                    pguidCmdGroup,
                    1,
                    pCmd,
                    pcmdtext);
        if (!pCmd->cmdf)
        {
            hr = super::QueryStatus(pguidCmdGroup,
                                     1,
                                     pCmd,
                                     pcmdtext);
        }
        RRETURN_NOTRACE(hr);
    }
    else if (IsOptionButton())
    {
        RRETURN_NOTRACE(super::QueryStatus(
            pguidCmdGroup,
            1,
            pCmd,
            pcmdtext));
    }

    switch (cmdID)
    {
    case IDM_COPY:
    case IDM_CUT:
        if (type == htmlInputPassword)
        {
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
            return S_OK;
        }
        break;

    case IDM_INSERTOBJECT:
        // Don't allow objects to be inserted in input controls
        pCmd->cmdf = MSOCMDSTATE_DISABLED;
        return S_OK;

    case IDM_SELECTALL:
        // Button text should not be selectable in browse mode
        if (!IsEditable(TRUE) && IsButton())
        {
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
            return S_OK;
        }
        break;

    case IDM_PASTE:
        if (type == htmlInputFile)
        {
            IOleCommandTarget * pCT = NULL;
            
            GetCallerCommandTarget(this, NULL, FALSE, &pCT);
            if (pCT)
            {
                CVariant    Var;

                //
                // If this is a trusted doc, allow it to go through.
                //
                
                pCT->Exec(
                        &CGID_ScriptSite,
                        CMDID_SCRIPTSITE_TRUSTEDDOC,
                        0,
                        NULL,
                        &Var);
                ReleaseInterface(pCT);

                if (V_VT(&Var) == VT_BOOL && V_BOOL(&Var) == VARIANT_TRUE)
                    break;
                
                // Eat up command if being called through om
                hr = S_OK;  
                pCmd->cmdf = MSOCMDSTATE_DISABLED;
            }
        }
        break;
    }

    if (!pCmd->cmdf)
    {
        hr = super::QueryStatus(pguidCmdGroup,
                                     1,
                                     pCmd,
                                     pcmdtext);
    }

    RRETURN_NOTRACE(hr);
}


HRESULT
CInput::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));

    int      idm = CBase::IDMFromCmdID(pguidCmdGroup, nCmdID);
    HRESULT  hr  = MSOCMDERR_E_NOTSUPPORTED;

    if (hr == MSOCMDERR_E_NOTSUPPORTED)
    {
        htmlInput type = GetType();

        switch(type)
        {
        case htmlInputImage:
            Assert(_pImage);
            hr = _pImage->Exec(
                pguidCmdGroup,
                nCmdID,
                nCmdexecopt,
                pvarargIn,
                pvarargOut);
            break;
        case htmlInputFile:
            if (idm == IDM_PASTE)
            {
                IOleCommandTarget * pCT = NULL;
                CDoc *pDoc = Doc();

                if (pDoc->TestLock(FORMLOCK_QSEXECCMD))
                {
                    hr = E_ACCESSDENIED;
                }
                else
                {                
                    GetCallerCommandTarget(this, NULL, FALSE, &pCT);
                    if (pCT)
                    {
                        CVariant    Var;
                    
                        //
                        // If this is a trusted doc, allow it to go through.
                        //
                    
                        pCT->Exec(
                                &CGID_ScriptSite,
                                CMDID_SCRIPTSITE_TRUSTEDDOC,
                                0,
                                NULL,
                                &Var);
                        ReleaseInterface(pCT);
                    
                        if (V_VT(&Var) == VT_BOOL && V_BOOL(&Var) == VARIANT_TRUE)
                            break;
                    
                        // Eat up command if being called through om
                        hr = E_ACCESSDENIED;  
                    }
                }
            }
            break;
        }

        if (hr == MSOCMDERR_E_NOTSUPPORTED)
        {
            hr = super::Exec(
                    pguidCmdGroup,
                    nCmdID,
                    nCmdexecopt,
                    pvarargIn,
                    pvarargOut);
        }
    }

    RRETURN_NOTRACE(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CInput::Save
//
//  Synopsis:   Save the element to the stream
//
//-------------------------------------------------------------------------

HRESULT
CInput::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr = S_OK;
    BOOL    fIsButton = IsButton();

    if (GetType() == htmlInputImage)
    {
        RRETURN (super::Save(pStreamWrBuff, fEnd));
    }

    // We do not want to call super here since that would dump what
    // is in the runs.

    Assert(!_fInSave);
    _fInSave = TRUE;

    if (IsOptionButton())
    {
        hr = SaveCheckbox(pStreamWrBuff, fEnd);
        goto Cleanup;
    }

    if (!fIsButton && !fEnd && !pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT))
    {
        DWORD dwOldFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);

        hr = WriteTag(pStreamWrBuff, fEnd);

        pStreamWrBuff->RestoreFlags(dwOldFlags);
    }

    if (fIsButton)
    {
        if (!fEnd)
        {
            pStreamWrBuff->BeginPre();
        }

        hr = super::Save(pStreamWrBuff, fEnd);
        if (hr)
            goto Cleanup;

        if(     fEnd 
            &&  (   !pStreamWrBuff->GetElementContext() 
                 || GetFirstCp() >= pStreamWrBuff->GetElementContext()->GetFirstCp() ) )
        {
            pStreamWrBuff->EndPre();
        }
    }

Cleanup:

    Assert(_fInSave); // this will catch recursion
    _fInSave = FALSE;

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Template:   CCharFilter
//
//  Synopsis:   This is a template class that will pre-process an input string
//              character class out of an input string without disturbing
//              the original string. It makes a copy of the string if
//              needed and copies to the stack if possible, allocating
//              only if the string is longer than a certain length.
//
//              Pre-processing will either filter out CR/LF (if !fMultiLine),
//              or converts each of LF, CR-LF and LF-CR to a CR. Also, presence
//              of non-ASCII characters is checked for.
//-----------------------------------------------------------------------------

MtDefine(CCharPreprocessPchAlloc, Locals, "CCharPreprocess::_pchAlloc");

#define BASELEN 64
class CCharPreprocess
{
public:
    CCharPreprocess()  { _pchAlloc = NULL; _chOR = 0; _fPrevIsCR = _fPrevIsLF = FALSE;}
    ~CCharPreprocess() { MemFree(_pchAlloc); }

    HRESULT         Preprocess(const TCHAR *pchIn, ULONG cchIn, BOOL fMultiLine);
    const TCHAR *   Pch() { return const_cast<TCHAR*>(_pchResult); }
    ULONG           Cch() { return _cchResult; }
    BOOL            FAsciiOnly() { return _chOR <= 0x7F; }  

private:
    TCHAR   _ach[BASELEN];
    TCHAR * _pchAlloc;
    TCHAR * _pchResult;
    ULONG   _cchResult;
    TCHAR   _chOR;
    BOOL    _fPrevIsCR;
    BOOL    _fPrevIsLF;
};

HRESULT
CCharPreprocess::Preprocess(const TCHAR *pchIn, ULONG cchIn, BOOL fMultiLine)
{
    const TCHAR *pch;
    TCHAR *pchTo;
    ULONG cch;
    HRESULT hr;

    for (pch = pchIn, cch = cchIn; cch; pch++, cch--)
    {
        _chOR |= *pch;

        if (*pch == _T('\r') || *pch == _T('\n'))
        {
            if (cchIn > BASELEN)
            {
                hr = THR(MemRealloc(Mt(CCharPreprocessPchAlloc), (void**)&_pchAlloc, cchIn * sizeof(TCHAR)));
                if (hr)
                    RRETURN(hr);

                _pchResult = _pchAlloc;
            }
            else
            {
                _pchResult = _ach;
            }

            pchTo = _pchResult;
            memcpy(pchTo, pchIn, (cchIn - cch) * sizeof(TCHAR));
            pchTo += (cchIn - cch);
            _cchResult = (cchIn - cch);

            for (; cch; pch++, cch--)
            {
                _chOR |= *pch;

                if (fMultiLine)
                {
                    if (*pch == _T('\r'))
                    {
                        if (!_fPrevIsLF)
                        {
                            *pchTo++ = _T('\r');
                            _cchResult++;
                            _fPrevIsCR = TRUE;
                        }
                        else
                        {
                            _fPrevIsCR = FALSE;
                        }
                        _fPrevIsLF = FALSE;
                    }
                    else if (*pch == _T('\n'))
                    {
                        if (!_fPrevIsCR)
                        {
                            *pchTo++ = _T('\r');
                            _cchResult++;
                            _fPrevIsLF = TRUE;
                        }
                        else
                        {
                            _fPrevIsLF = FALSE;
                        }
                        _fPrevIsCR = FALSE;
                    }
                    else
                    {
                        *pchTo++ = *pch;
                        _cchResult++;
                        _fPrevIsCR = _fPrevIsLF = FALSE;
                    }
                }
                else
                {
                    if (!(*pch == _T('\r') || *pch == _T('\n')))
                    {
                        *pchTo++ = *pch;
                        _cchResult++;
                    }
                }

            }
            return S_OK;
        }
    }

    _pchResult = const_cast<TCHAR*>(pchIn);
    _cchResult = cchIn;
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Method:     SetValueHelper
//
//  Synopsis:   Removes forbidden characters from the string before
//              setting the value.
//
//-------------------------------------------------------------------------

HRESULT
CInput::SetValueHelper(const TCHAR *psz, int c, BOOL fOM /* = TRUE */)
{
    //  This is a no-op for <input type=file>
    //  When the file control needs to update its contents
    //  for the file pick dialog, it will call
    //  SetValueHelperReal directly.

    HRESULT             hr;
    BOOL                fAsciiOnly = FALSE;
    CCharPreprocess     Charf;

    if (TestClassFlag(ELEMENTDESC_OMREADONLY))
        return S_OK;

#ifdef  NEVER   // look at bug 24311 
    if (IsTextOrFile())
    {
        int l = GetAAmaxLength();
        c = min(c, l);
    }
#endif

    // Type is not set until Init2() is called
    Assert (GetType() != htmlInputNotSet);
    hr = Charf.Preprocess(psz, c, IsTypeMultiline(GetType()));
    if (hr)
        RRETURN(hr);

    psz = Charf.Pch();
    c = Charf.Cch();
    fAsciiOnly = Charf.FAsciiOnly();

    RRETURN(THR(SetValueHelperReal(psz, c, fAsciiOnly, fOM)));
}



HRESULT
CInput::SetValueHelperReal(const TCHAR *psz, int c, BOOL fAsciiOnly, BOOL fOM /* = TRUE */)
{
    HRESULT     hr = S_OK;

    if (!HasSlavePtr())
    {
        _cstrDefaultValue.Set(psz, c);
        _fTextChanged = FALSE;
        _fHasInitValue = TRUE;
    }
    else
    {
        CElement *      pElemSlave = GetSlavePtr();

        Assert(pElemSlave->IsInMarkup());

        // Special case - if the current text in the input is the empty string and we 
        // are setting it also to empty don't set _fFiredValuePropChange flag because 
        // it will inhibit firing the first OnPropertyChange on the element

        if (c != 0 || pElemSlave->GetElementCch() != 0)
        {
            hr = THR(pElemSlave->GetMarkup()->FastElemTextSet(pElemSlave, psz, c, fAsciiOnly));
            if (hr)
                goto Cleanup;

            // Set this to prevent OnPropertyChange(_Value_) from firing twice
            // when value is set through OM. This flag is cleared in OnTextChange().
            _fFiredValuePropChange = fOM;
        }

        hr = THR(_cstrLastValue.Set(psz, c));
        _fLastValueSet = TRUE;
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CInput::SetValueHelperInternal(CStr *pstr, BOOL fOM /* = TRUE */)
{
    HRESULT hr = S_OK;
    htmlInput   type = GetType();

    switch (type)
    {
    case    htmlInputText:
    case    htmlInputHidden:
    case    htmlInputPassword:
    case    htmlInputButton:
    case    htmlInputReset:
    case    htmlInputSubmit:
    case    htmlInputFile:
        hr = THR(SetValueHelper((LPTSTR) *pstr, pstr->Length(), fOM));

#ifndef NO_DATABINDING
        if (SUCCEEDED(hr))
        {
            // if the value is changed by script (or any way besides user
            // typing, or databinding), try to save the value into the
            // database.  But if user cancels this, leave the new value
            // in place.
            hr = SaveDataIfChanged(ID_DBIND_DEFAULT);
            if (SUCCEEDED(hr) || hr == E_ABORT)
                hr = S_OK;
        }
#endif

        _fTextChanged = FALSE;
        break;
    default:
        _fHasInitValue = TRUE;
        _cstrDefaultValue.Set(*pstr);
    }

    RRETURN(hr);
}

HRESULT
CInput::SetValueHelper(CStr *pstr)
{
    return SetValueHelperInternal(pstr);
}


HRESULT
CInput::GetValueHelper(CStr *pstr, BOOL fIsSubmit)
{
    HRESULT hr          = S_OK;

    switch (GetType())
    {
    case    htmlInputText:
    case    htmlInputHidden:
    case    htmlInputPassword:
    case    htmlInputFile:
    case    htmlInputButton:
    case    htmlInputReset:
    case    htmlInputSubmit:
        // Do not save password contents
        if (_fInSave && !IsEditable(TRUE) && GetType() == htmlInputPassword)
        {
            Assert(!fIsSubmit);
            pstr->Set(_T(""));
            goto Cleanup;
        }

        if (HasSlavePtr())
        {
            hr = THR(GetSlavePtr()->GetPlainTextInScope(pstr));
        }
        else
        {
            pstr->Set(*GetLastValue());
        }
        break;
    case    htmlInputCheckbox:
    case    htmlInputRadio:
        if (!_fHasInitValue && !_fInSave)
        {
            pstr->Set(_T("on"));
            goto Cleanup;
        }
        //fall through
    default:
        pstr->Set(_cstrDefaultValue);
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CInput::GetValueHelper(CStr *pstr)
{
    HRESULT     hr = S_OK;
    hr = GetValueHelper(pstr, FALSE);
    RRETURN (hr);
}


const CBase::CLASSDESC *
CInput::GetClassDesc() const
{
    switch (GetType())
    {
        case htmlInputReset:
            return (CBase::CLASSDESC *)&s_classdescReset;

        case htmlInputSubmit:
            return (CBase::CLASSDESC *)&s_classdescSubmit;

        case htmlInputButton:
            return (CBase::CLASSDESC *)&s_classdescBtn;

        case htmlInputPassword:
            return (CBase::CLASSDESC *)&s_classdescPassword;

        case htmlInputHidden:
            return (CBase::CLASSDESC *)&s_classdescHidden;

        case htmlInputFile:
            return (CBase::CLASSDESC *)&s_classdescFile;

        case htmlInputCheckbox:
        case htmlInputRadio:
            return (CBase::CLASSDESC *)&s_classdescCheckbox;

        case htmlInputImage:
            return (CBase::CLASSDESC *)&s_classdescImage;

        default:
            return (CBase::CLASSDESC *)&s_classdescText;
    }
}


HRESULT
CInput::CreateElement(CHtmTag *pht, CDoc *pDoc, CElement **ppElement, htmlInput type)
{
    Assert(ppElement);

    *ppElement = new CInput(pht->GetTag(), pDoc, type);

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}


//+---------------------------------------------------------------------------
//
//  Member: CInput::GetInfo
//
//  Params: [gi]: The GETINFO enumeration.
//
//  Descr:  Returns the information requested in the enum
//
//----------------------------------------------------------------------------
DWORD
CInput::GetInfo(GETINFO gi)
{
    switch (gi)
    {
    case GETINFO_HISTORYCODE:
        return MAKELONG(GetType(), Tag());
    }

    return super::GetInfo(gi);
}

//+------------------------------------------------------------------------
//
//  Member:     CInput::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------
                
HRESULT
CInput::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;

    if (!_fScriptCreated)
    {
        // if the type (or interface) has not been changed
        // we only support the old interface
        if (*s_aInputInterface[_typeAtCreate] == iid)
        {
            switch (iid.Data1)
            {
                QI_HTML_TEAROFF(this, IHTMLInputImage, NULL);
                QI_HTML_TEAROFF(this, IHTMLInputHiddenElement, NULL);
                QI_HTML_TEAROFF(this, IHTMLInputTextElement, NULL);
                QI_HTML_TEAROFF(this, IHTMLOptionButtonElement, NULL);
                QI_HTML_TEAROFF(this, IHTMLInputButtonElement, NULL);
                QI_HTML_TEAROFF(this, IHTMLInputFileElement, NULL);

                default:
                    AssertSz(FALSE, "Invalid interface IID");
            }
            goto Cleanup;
        }
        else
        {
            int i;

            // all possible interfaces are in between htmlInputNotSet
            // and htmlInputImage
            for (i =  (int)htmlInputNotSet; i <= (int)htmlInputImage; i++)
            {
                if (*s_aInputInterface[i] == iid)
                {
                    RRETURN (E_NOINTERFACE);
                }
            }
        }
    }

    switch(GetType())
    {
    case htmlInputImage:
        switch (iid.Data1)
        {
            QI_TEAROFF(this, IDispatchEx, NULL);
            QI_HTML_TEAROFF(this, IHTMLElement2, NULL);
            QI_HTML_TEAROFF(this, IHTMLInputElement, NULL);
            QI_HTML_TEAROFF(this, IHTMLInputElement2, NULL);
        }
        break;
    default:
        switch (iid.Data1)
        {
            QI_HTML_TEAROFF(this, IHTMLInputElement, NULL);
            QI_HTML_TEAROFF(this, IHTMLInputElement2, NULL);
        }
        break;
    }

Cleanup:

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        RRETURN(S_OK);
    }

    RRETURN(super::PrivateQueryInterface(iid, ppv));
}

HRESULT
CInput::EnterTree()
{
    htmlInput             type    = GetType();
    HRESULT               hr      = S_OK;
    CMarkup *             pMarkup = GetMarkup(); Assert(pMarkup);
    CMarkupTransNavContext * ptnc = pMarkup->EnsureTransNavContext();

    if (!ptnc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _iHistoryIndex  = (unsigned short)ptnc->_dwHistoryIndex++;

#if DBG==1
    if (!IsTagEnabled(tagAllowMorphing))
#endif
    
    // no morphing allowed once the element is entering the tree
    _fHasMorphed = TRUE;
    
    switch (type)
    {
    case    htmlInputFile:
    case    htmlInputText:
    case    htmlInputHidden:
    case    htmlInputPassword:
        DYNCAST(CInputLayout, Layout())->SetDisplayWordWrap(FALSE);
        GetUpdatedLayout()->_fAllowSelectionInDialog = TRUE;
        break;

    case    htmlInputSubmit:
        SetDefaultElem();
        // fall through
    case    htmlInputButton:
    case    htmlInputReset:
        DYNCAST(CInputLayout, Layout())->SetDisplayWordWrap(FALSE);
        break;
    case    htmlInputRadio:
            _fDeferClearGroup = TRUE;
    case    htmlInputCheckbox:
        {
            VARIANT_BOOL    checked  = VARIANT_FALSE;

            hr = S_OK;

            get_PropertyHelper(&checked, (PROPERTYDESC *)&s_propdescCInputdefaultChecked);

            SetChecked(checked);
            if (type == htmlInputRadio)
            {
                _fDeferClearGroup = FALSE;
            }

            _fLastValue = !!checked;
        }
        break;
    case    htmlInputImage :
        SetDefaultElem();
        break;
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CInput::LoadHistoryValue()
{
    HRESULT         hr = S_OK;
    CStr            cstrVal;
    DWORD           dwTemp;
    IStream        *pStream = NULL;
    BOOL            fHistorySet = FALSE;
    VARIANT_BOOL    checked = VARIANT_FALSE;
    VARIANT_BOOL    defaultChecked = VARIANT_FALSE;
    CMarkup *       pMarkup = GetMarkup();
    DWORD           dwHistoryIndex = 0x80000000 | (DWORD)_iHistoryIndex & 0x0FFFF;

    if( !pMarkup )
        goto NoHistory;

    hr = THR(pMarkup->GetLoadHistoryStream(dwHistoryIndex, HistoryCode(), &pStream));
    if (hr)
    {
        if (IsOptionButton())
            goto NoHistory;
        else
            goto Cleanup;
    }

    if (pStream)
    {
        CDataStream ds(pStream);

        if (IsOptionButton())
        {
            if (OK(THR(ds.LoadDword(&dwTemp))))
            {
                checked = (VARIANT_BOOL)(BOOL)dwTemp;
                fHistorySet = TRUE;
            }
        }
        else
        {
            Assert(IsTextOrFile());
            DWORD   dwEncoding;

            // Load encoding changing history
            hr = THR(ds.LoadDword(&dwEncoding));
            if (hr)
                goto Cleanup;

            if (!dwEncoding)
            {
                
                // load value
                hr = THR(ds.LoadCStr(&cstrVal));
                if (hr)                
                    goto Cleanup;

                // load _fTextChanged
                hr = THR(ds.LoadDword(&dwTemp));
                if (hr)
                    goto Cleanup;

                _fTextChanged = dwTemp ? TRUE : FALSE;
                
                if (_fTextChanged)
                {
                    hr = THR(SetValueHelperInternal(&cstrVal));
                    if (hr)
                        goto Cleanup;

                    IGNORE_HR(OnPropertyChange(DISPID_A_VALUE, 
                                               0, 
                                               (PROPERTYDESC *)&s_propdescCInputvalue));
                }
            }
        }
    }
NoHistory:
    if (IsOptionButton())
    {
        hr = S_OK;

#if DBG==1
        if (!fHistorySet)      // This should already be set when we enter the tree
        {
            get_PropertyHelper(&defaultChecked, (PROPERTYDESC *)&s_propdescCInputdefaultChecked);
            Assert((!!defaultChecked) == (!!_fChecked));
        }
#endif

        if (fHistorySet)
        {
            get_PropertyHelper(&defaultChecked, (PROPERTYDESC *)&s_propdescCInputdefaultChecked);
            if ((!!defaultChecked) != (!!checked))
                SetChecked(checked);
        }

        _fLastValue = !!checked;
    }

Cleanup:
    ReleaseInterface(pStream);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     DoReset
//
//  Synopsis:   Called from CForm::Reset(). this helper assistes the form reset
//      operation by restoreing the default value to the value of this input
//      element
//
//----------------------------------------------------------------------------

HRESULT
CInput::DoReset(void)
{
    HRESULT hr = S_OK;

    switch(GetType())
    {
    case    htmlInputFile:
        hr = THR(SetValueHelperReal(NULL, 0));

        if (hr == S_OK)
            IGNORE_HR(OnPropertyChange(DISPID_A_VALUE, 
                                       0, 
                                       (PROPERTYDESC *)&s_propdescCInputvalue));
        break;
    case    htmlInputCheckbox:
    case    htmlInputRadio:
        VARIANT_BOOL bCheck;
        hr = THR(get_PropertyHelper(&bCheck, (PROPERTYDESC *)&s_propdescCInputdefaultChecked));

        if (hr)
            goto Cleanup;

        hr = THR(put_checked(bCheck));
        break;
    case    htmlInputText:
    case    htmlInputHidden:
    case    htmlInputPassword:
        hr = SetValueHelperInternal( &_cstrDefaultValue);
        break;
    }

Cleanup:
    RRETURN (hr);
}

HRESULT
CInput::GetSubmitInfoForImg(CPostData * pSubmitData)
{
    HRESULT     hr;
    LPCTSTR     pchName = GetAAsubmitname();

    // Write x coord
    if (pchName)
    {
        hr = THR(pSubmitData->AppendEscaped(pchName, GetMarkup()));
        if (hr)
            goto Cleanup;
        hr = THR(pSubmitData->Append(".x"));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(pSubmitData->Append("x"));
        if (hr)
            goto Cleanup;
    }
    hr = THR(pSubmitData->AppendValueSeparator());
    if (hr)
        goto Cleanup;

    hr = THR(pSubmitData->Append(_pt.x));
    if (hr)
        goto Cleanup;

    hr = THR(pSubmitData->AppendItemSeparator());
    if (hr)
        goto Cleanup;

    // Write y coord
    if (pchName)
    {
        hr = THR(pSubmitData->AppendEscaped(pchName, GetMarkup()));
        if (hr)
            goto Cleanup;
        hr = THR(pSubmitData->Append(".y"));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(pSubmitData->Append("y"));
        if (hr)
            goto Cleanup;
    }
    hr = THR(pSubmitData->AppendValueSeparator());
    if (hr)
        goto Cleanup;

    hr = THR(pSubmitData->Append(_pt.y));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  Method:     GetSubmitInfo
//
//  Synopsis:   returns the submit info string if there is a value
//              (name && value pair)
//
//  Returns:    S_OK if successful
//              E_NOTIMPL if not applicable for current element
//
//-----------------------------------------------------------------------------
HRESULT
CInput::GetSubmitInfo(CPostData * pSubmitData)
{
    htmlInput   type = GetType();
    LPCTSTR     pstrName;
    CFormElement    *pForm;
    ULONG       cElements;
    CStr        cstrValue;
    HRESULT     hr = S_FALSE;

    if (type == htmlInputImage)
    {
        RRETURN(GetSubmitInfoForImg(pSubmitData));
    }

    pstrName = GetAAsubmitname();

    //  no name --> no submit!
    if ( ! pstrName )
        return S_FALSE;

    hr = GetValueHelper(&cstrValue, TRUE);

    if (hr)
        goto Cleanup;

    if (type == htmlInputFile)
    {
        if (_fDirtiedByOM && !(HasMarkupPtr() && GetMarkup()->IsMarkupTrusted()))
        {
            // Null out the contents, set focus back to the control and cancel the submit operation
            AssertSz(FALSE, "Attempted security breach - trying to submit InputFile dirtied through OM");
            _fDirtiedByOM = FALSE;
            IGNORE_HR(SetValueHelperReal(NULL, 0, TRUE, FALSE));
            IGNORE_HR(BecomeCurrent(0));
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }
        else
        {
            RRETURN1(THR(pSubmitData->AppendNameFilePair(pstrName, cstrValue, GetMarkup())), S_FALSE);
        }
    }

    pForm = GetParentForm();

    if (!pForm)
        goto Cleanup;

    cElements  = pForm->_pCollectionCache->SizeAry(CFormElement::FORM_SUBMIT_COLLECTION);

    if (IsOptionButton())
    {
        VARIANT_BOOL  bCheck;
        HRESULT hr = THR(get_checked(&bCheck));

        if (hr || !bCheck)
        {
            hr = S_FALSE;
            goto Cleanup;
        }
    }

    if ( _tcsiequal( pstrName, TEXT("_charset_")) && htmlInputHidden == type)
    {
        TCHAR   achCharset[MAX_MIMECSET_NAME];

        if (pSubmitData->_fCharsetNotDefault && pForm->Utf8InAcceptCharset())
        {
            Assert(sizeof(s_achUtf8) <= sizeof(achCharset));
            memcpy(achCharset, s_achUtf8, sizeof(s_achUtf8));
        }
        else
        {
            hr = THR(GetMlangStringFromCodePage(
                pSubmitData->_cpInit ? 
                pSubmitData->_cpInit :
                pSubmitData->GetCP(GetMarkup()), 
                achCharset,
                ARRAY_SIZE(achCharset)));
            if (hr)
                goto Cleanup;
        }

        hr = THR(pSubmitData->AppendNameValuePair(pstrName, 
            achCharset, GetMarkup()));
    }    
    else if ( type != htmlInputText || _tcsicmp( pstrName, TEXT("isindex")) )
    {
        hr = THR(pSubmitData->AppendNameValuePair(pstrName, cstrValue, GetMarkup()));
    }
    else
    {
        Assert (htmlInputText == type);
        // For <ISINDEX ...> we don't submit the "name=" part.
        /* NASA fix (bug 27359)
            If the ISINDEX textbox is the first element we're submitting
            (not necessarily the first element on the form), we don't
            submit the name-value pair.
        */
        if (!pSubmitData->Size())
        {
            hr = THR(pSubmitData->AppendEscaped(cstrValue, GetMarkup()));
        }
        else
        {
            hr = THR(pSubmitData->AppendNameValuePair(pstrName, cstrValue, GetMarkup()));
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


HRESULT CInput::DoClick(CMessage * pMessage, CTreeNode *pNodeContext,
                              BOOL fFromLabel, EVENTINFO* pEvtInfo /*= NULL */, BOOL fFromClick )
{
    HRESULT hr = S_OK;

    if (IsOptionButton())
    {
        hr = DoClickCheckbox(pMessage, pNodeContext, fFromLabel, pEvtInfo);
    }
    else 
    {
        hr = super::DoClick(pMessage, pNodeContext, fFromLabel, pEvtInfo, fFromClick);
    }
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CInput::GetEnabled
//
//  Synopsis:   return not disabled
//
//----------------------------------------------------------------------------

STDMETHODIMP
CInput::GetEnabled(VARIANT_BOOL * pfEnabled)
{
    if (!pfEnabled)
        RRETURN(E_INVALIDARG);

    *pfEnabled = !GetAAdisabled();
    return S_OK;
}

HRESULT BUGCALL
CInput::select(void)
{
    HRESULT             hr          = S_OK;
    CMarkup *           pMarkup;
    CDoc *              pDoc        = Doc();
    CMarkupPointer      ptrStart(pDoc);
    CMarkupPointer      ptrEnd(pDoc); 
    IMarkupPointer *    pIStart; 
    IMarkupPointer *    pIEnd; 
    SELECTION_TYPE eType = SELECTION_TYPE_Text;
    BOOL fEqual;
    
    if (!HasSlavePtr() || !IsInMarkup())
        goto Cleanup;
    pMarkup = GetSlavePtr()->GetMarkup();
    if (!pMarkup)
        goto Cleanup;

#if 0
    hr = pDoc->SetEditContext(this, TRUE, FALSE);
#else
    // We need to make this current because that's the only
    // way selection works right now. GetCurrentSelectionRenderingServices()
    // looks for the current element. MarkA should fix this.
    hr = BecomeCurrent(0);
#endif
    if (hr)
        goto Cleanup;

    hr = ptrStart.MoveToCp(1, pMarkup);
    if (hr)
        goto Cleanup;
    hr = ptrEnd.MoveToCp(pMarkup->GetTextLength() - 1, pMarkup);
    if (hr)
        goto Cleanup;
    Verify(S_OK == ptrStart.QueryInterface(IID_IMarkupPointer, (void**)&pIStart));
    Verify(S_OK == ptrEnd.QueryInterface(IID_IMarkupPointer, (void**)&pIEnd));

    Verify( S_OK == pIStart->IsEqualTo( pIEnd, & fEqual ));

    if ( fEqual )
    {
        eType = SELECTION_TYPE_Caret;
    }
    
    hr = pDoc->Select(pIStart, pIEnd, eType );
    pIStart->Release();
    pIEnd->Release();
Cleanup:
    if (S_FALSE == hr)
        hr = S_OK;
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT
CInput::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;
    htmlInput type = GetType();

    switch (dispid)
    {
    case DISPID_CInput_type:
        {
           htmlInput typeNew = GetAAtype();

           // NOTE: (krisma) if we should ever want to turn on infinite morphing,
           // just remove the next bit of code. You can then probably get rid of
           // the _fHasMorphed flag.
           if (_fHasMorphed || type != htmlInputText)
           {
                // We need to set the type back to it's old value.
                hr = SetAAtype(type);
                if (hr)
                    goto Cleanup;

                hr = OLECMDERR_E_NOTSUPPORTED;
                goto Cleanup;
           }
           // End of morph-limiting code.
           else
           {

           // The following types are valid, but we realy just want a textbox.
           if (typeNew == htmlInputNotSet         ||
               typeNew == htmlInputSelectOne      ||
               typeNew == htmlInputSelectMultiple ||
               typeNew == htmlInputTextarea       ||
               typeNew == htmlInputRichtext)
           {
               typeNew = htmlInputText;
               hr = SetAAtype(typeNew);
               if (hr)
                   goto Cleanup;
           }

           // Do we realy have to do anything?
           if (typeNew == type)
               break;

           if ((typeNew == htmlInputCheckbox  ||
                typeNew == htmlInputRadio     ||
                typeNew == htmlInputImage)    &&
               (type    != htmlInputCheckbox  &&
                type    != htmlInputRadio     &&
                type    != htmlInputImage))
           {
                Assert (HasSlavePtr());
                CElement * pElemSlave = DelSlavePtr();

                // Stop listening to events on the slave
                SetupSlaveEventSink(FALSE, pElemSlave);

                pElemSlave->DelMasterPtr();
                pElemSlave->Release();
           }

           // delete the image helper
           if (type == htmlInputImage)
           {
               Assert(_pImage);
               _fNoUIActivateInDesign = FALSE;      //  TRUE for InputImage, FALSE otherwise.
               _pImage->CleanupImage();
               delete _pImage;
               _pImage = NULL;
           }
            
           _fActsLikeButton =  (typeNew == htmlInputButton
                             || typeNew == htmlInputReset
                             || typeNew == htmlInputSubmit);

           SetType(typeNew);

           if (HasLayoutPtr())
           {
               CLayout * pLayout;
           
               pLayout = DelLayoutPtr();
               pLayout->Detach();
               pLayout->Release();
           }

           // If we're changing from a password, we have to remove the value
           if (type == htmlInputPassword)
           {
               hr = SetValueHelperReal(_T(""), 0, TRUE, FALSE);
           }

           if (typeNew == htmlInputImage)
           {
               _fNoUIActivateInDesign = TRUE;       //  TRUE for InputImage, FALSE otherwise.
               // if the new type is input image, create the imbedded input image instance
               _pImage = new CImgHelper(Doc(), this, TRUE);
               if (!_pImage)
               {
                   hr = E_OUTOFMEMORY;
                   goto Cleanup;
               }
           }

           dwFlags |= ELEMCHNG_CLEARCACHES | ELEMCHNG_SITEREDRAW | ELEMCHNG_REMEASUREINPARENT;
           _fHasMorphed = TRUE;

           hr = PrivateInit2();
           if (hr)
               goto Cleanup;
           }
        }
        break;

    case DISPID_CInput_value:
        _fTextChanged = TRUE;
        break;

    case DISPID_CElement_submitName:
        {
            // DISPID_CInput_name gets changes to DISPID_CElement_submitName before we get here
            // and that prevents onpropertychange from firing for the name property (bug 30267)
            // This call gets us to fire onpropertychage if the name is changed.
            hr = OnPropertyChange(DISPID_CInput_name, 
                                  dwFlags, 
                                  (PROPERTYDESC *)&s_propdescCInputname);
            if (hr)
                goto Cleanup;
        }
        break;
    case DISPID_CInput_readOnly:
        if (IsTextOrFile())
            _fReadOnly = !!GetAAreadOnly();
        break;

    case DISPID_CInput_src:
        if (_pImage && type == htmlInputImage)
        {
            hr = _pImage->SetImgSrc(IMGF_REQUEST_RESIZE | IMGF_INVALIDATE_FRAME);
        }
        break;
    case DISPID_CInput_lowsrc:
        if (_pImage && type == htmlInputImage)
        {
            LPCTSTR szUrl = GetAAsrc();

            if (!szUrl)
            {
                Assert(_pImage);
                hr = _pImage->FetchAndSetImgCtx(GetAAlowsrc(), IMGF_REQUEST_RESIZE | IMGF_INVALIDATE_FRAME);
            }

        }
        break;

#ifndef NO_AVI
    case DISPID_CInput_dynsrc:
        if (_pImage && GetType() == htmlInputImage)
        {
            hr = _pImage->SetImgDynsrc();
        }
        break;
#endif
    }

    hr = (THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc)));

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CInput::BecomeUIActive
//
//  Synopsis:   Check imeMode to set state of IME.
//
//  Notes:      This is the method that external objects should call
//              to force sites to become ui active.
//
//--------------------------------------------------------------------------

HRESULT
CInput::BecomeUIActive()
{
    HRESULT hr = S_OK;
    htmlInput   type = GetType();

    hr = THR(super::BecomeUIActive());
    if (hr)
        goto Cleanup;

    if (type == htmlInputText)
    {
        hr = THR(SetImeState());
        if (hr)
            goto Cleanup;
    }

Cleanup:    
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CInput::GetFocusShape
//
//  Synopsis:   Returns the shape of the focus outline that needs to be drawn
//              when this element has focus. This function creates a new
//              CShape-derived object. It is the caller's responsibility to
//              release it.
//
//----------------------------------------------------------------------------

HRESULT
CInput::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    HRESULT     hr;
    htmlInput   type        = GetType();
    CLayout *   pLayout     = Layout();

    Assert(ppShape);

    switch(type)
    {
    case htmlInputCheckbox:
    case htmlInputRadio:
        if (HasSlavePtr())
        {
            hr = super::GetFocusShape(lSubDivision, pdci, ppShape);
        }
        else
        {
            hr = DYNCAST(CCheckboxLayout, pLayout)->GetFocusShape(lSubDivision, pdci, ppShape);
        }
        break;
    case htmlInputButton:
    case htmlInputReset:
    case htmlInputSubmit:
        hr = DYNCAST(CInputButtonLayout, pLayout)->GetFocusShape(lSubDivision, pdci, ppShape);
        break;
    case htmlInputFile:
        hr = DYNCAST(CInputFileLayout, pLayout)->GetFocusShape(lSubDivision, pdci, ppShape);
        break;
    case htmlInputImage:
        if (HasSlavePtr())
        {
            hr = super::GetFocusShape(lSubDivision, pdci, ppShape);
        }
        else
        {
            hr = DYNCAST(CInputImageLayout, pLayout)->GetFocusShape(lSubDivision, pdci, ppShape);
        }
        break;
    default:
        // Never want focus rect for text/password
        *ppShape = NULL;
        hr = S_FALSE;
        break;
    }
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CInput::RequestYieldCurrency
//
//  Synopsis:   Check if OK to Relinquish currency
//
//  Arguments:  BOOl fForce -- if TRUE, force change and ignore user cancelling the
//                             onChange event
//
//  Returns:    S_OK: ok to yield currency
//
//--------------------------------------------------------------------------

HRESULT
CInput::RequestYieldCurrency(BOOL fForce)
{
    CStr    cstr;
    HRESULT hr = S_OK;
    BOOL    fIsText = IsTextOrFile();
    BOOL    fIsOptionButton = IsOptionButton();

    if(IsButton())
        RRETURN1(super::RequestYieldCurrency(fForce), S_FALSE);

    if ((fIsText && (hr = GetValueHelper(&cstr)) == S_OK) ||
        (fIsOptionButton && _fLastValue != _fChecked))
    {
        BOOL fFire =  fIsText ? (FormsStringCmpLoc(cstr, *GetLastValue()) != 0)
            : (_fLastValue != _fChecked);

        if (!fFire)
            goto Cleanup;

        if (!Fire_onchange())   //JS event
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    
        if (!IsInMarkup())
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = super::RequestYieldCurrency(fForce);
        if (hr == S_OK)
        {
            if (fIsText)
            {
                _cstrLastValue.Set(cstr);
                _fLastValueSet = TRUE;
            }
            else 
            {
                Assert(fIsOptionButton);
                _fLastValue = _fChecked;
            }
        }
    }

Cleanup:
    if (fForce && FAILED(hr))
    {
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CInput::YieldCurrency
//
//  Synopsis:   Relinquish currency
//
//  Arguments:  pSiteNew    New site that wants currency
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------

HRESULT
CInput::YieldCurrency(CElement *pElemNew)
{
    HRESULT hr;

    _fDoReset = FALSE;
    hr = THR(super::YieldCurrency(pElemNew));
    if (hr)
        goto Cleanup;

    switch(GetType())
    {
    case    htmlInputFile:
        if (_fButtonHasFocus)
        {
            BtnHelperKillFocus();
        }
        break;
    case    htmlInputButton:
    case    htmlInputSubmit:
    case    htmlInputReset:
            _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, FLAG_HASFOCUS);
            GetUpdatedLayout()->Invalidate();
            break;
    case    htmlInputCheckbox:
    case    htmlInputRadio:
            _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, FLAG_HASFOCUS);
            break;
    }

Cleanup:
    RRETURN(hr);
}

HRESULT BUGCALL
CInput::HandleMessage(CMessage * pMessage)
{
    HRESULT     hr = S_FALSE;
    htmlInput   type = GetType();

    switch(type)
    {
    case    htmlInputButton:
    case    htmlInputReset:
    case    htmlInputSubmit:
        hr = HandleButtonMessage(pMessage);
        break;
    case    htmlInputText:
    case    htmlInputHidden:
    case    htmlInputPassword:
        hr = HandleTextMessage (pMessage);
        break;
    case    htmlInputFile:
        hr = HandleFileMessage (pMessage);
        break;
    case    htmlInputCheckbox:
    case    htmlInputRadio:
        hr = HandleCheckboxMessage (pMessage);
        break;
    case    htmlInputImage:
        hr = HandleImageMessage (pMessage);
        break;
    default:
        AssertSz(FALSE, "Invalid input element");
    }

    RRETURN1(hr, S_FALSE);
}

HRESULT BUGCALL
CInput::HandleFileMessage(CMessage * pMessage)
{
    HRESULT hr = S_FALSE;
    BOOL fButtonMessage = FALSE;
    BOOL fTextEditMessage = FALSE;

    switch ( pMessage->message )
    {
    case WM_SETFOCUS:
        if ( _fButtonHasFocus )
        {
            BtnHelperSetFocus();
            fButtonMessage = TRUE;
        }
        else
        {
            fTextEditMessage = TRUE;
        }

        break;

    case WM_KILLFOCUS:
        if ( _fButtonHasFocus )
        {
            fButtonMessage = TRUE;
            hr = S_OK;
        }
        else
        {
            fTextEditMessage = TRUE;
        }

        break;

    case WM_KEYDOWN:
        if ( pMessage->wParam == VK_TAB )
        {
            if ( pMessage->dwKeyState & FSHIFT )
            {
                //  BackTAB
                if ( _fButtonHasFocus )
                {
                    CDoc    *pDoc = Doc();
                    BtnHelperKillFocus();
                    // set caret
                    if (pDoc->_pCaret)
                    {
                        pDoc->_pCaret->Show( FALSE );
                    }
                    hr = S_OK;
                }
                else
                {
                    fTextEditMessage = TRUE;
                }
            }
            else
            {
                //  Forward TAB
                if ( _fButtonHasFocus )
                {
                    fTextEditMessage = TRUE;
                    fButtonMessage = TRUE;
                }
                else
                {
                    BtnHelperSetFocus();
                    hr = S_OK;
                }
            }
        }
        else
        {
            fButtonMessage = _fButtonHasFocus;
            fTextEditMessage = ! fButtonMessage;
        }

        break;

    default:

        if ( HasCapture() )
        {
            fButtonMessage = _fButtonHasCapture;
        }
        else
        {
            CInputFileLayout * pLayout = DYNCAST(CInputFileLayout, GetUpdatedLayout());

            if (pLayout)
            {
                CRect  rc;
                CPoint pt = pMessage->coordinateSystem == COORDSYS_GLOBAL ? pMessage->pt : pMessage->ptContent;
                HTHEME hTheme = GetTheme(THEME_BUTTON); // only care about button case

                pLayout->GetButtonRect(&rc);

                pLayout->TransformPoint(&pt, pMessage->coordinateSystem, COORDSYS_BOX);
                
                fButtonMessage = rc.Contains(pt);

                if (    hTheme
                    &&  (pMessage->message == WM_MOUSEMOVE || pMessage->message == WM_MOUSELEAVE))
                {
                    UINT msgOriginal = pMessage->message;

                    if (    pMessage->message == WM_MOUSEMOVE  
                        &&  !MouseOver()
                        &&  fButtonMessage)
                    {
                        //
                        // mouse over button part from text part
                        //
                        pMessage->message = WM_MOUSEOVER;
                        hr = THR(BtnHandleMessage(pMessage));
                        pMessage->message = msgOriginal;
                        goto Cleanup;
                    }

                    else if (MouseOver() &&  !fButtonMessage)
                    {
                        //
                        // mouse leave from button part
                        //
                        pMessage->message = WM_MOUSELEAVE;
                        hr = THR(BtnHandleMessage(pMessage));
                        pMessage->message = msgOriginal;
                        goto Cleanup;
                    }
               }
            }

            if ( !fButtonMessage &&
                 pMessage->message == WM_LBUTTONDOWN )
            {
                BtnHelperKillFocus();
            }
            else if ( pMessage->message >= WM_KEYFIRST &&
                      pMessage->message <= WM_KEYLAST )
            {
                fButtonMessage = _fButtonHasFocus;
            }
        }

        fTextEditMessage = ! fButtonMessage;

        break;
    }


    if ( fButtonMessage )
    {
        _fBtnHelperRequestsCurrency = TRUE;
        if (    pMessage->message != WM_LBUTTONDOWN
            ||  !BecomeCurrent(pMessage->lSubDivision, NULL, pMessage))
        {
            hr = THR(BtnHandleMessage(pMessage));
        }
        _fBtnHelperRequestsCurrency = FALSE;
    }
    if ( fTextEditMessage )
    {
        hr = THR(HandleTextMessage(pMessage));
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
// Member:      CInputImage::HandleMessage
//
// Synopsis:    Handle window message
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CInput::HandleImageMessage(CMessage * pMessage)
{
    HRESULT hr = S_FALSE;

    // Use hyperlink cursor (IE3 compat.)
    if (WM_SETCURSOR == pMessage->message)
    {
        SetCursorStyle(MAKEINTRESOURCE(IDC_HYPERLINK));
        hr = S_OK;
        goto Cleanup;
    }
    // WM_CONTEXTMENU message should always be handled.
    else if (WM_CONTEXTMENU == pMessage->message)
    {
        Assert(_pImage);
        hr = THR(_pImage->ShowImgContextMenu(pMessage));
    }
    else if (!IsEditable(TRUE))
    {
        hr = BtnHandleMessage(pMessage);
    }
    if (hr == S_FALSE)
    {
        // image does not have their own handlemessage
        hr = super::HandleMessage(pMessage);
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT BUGCALL
CInput::HandleButtonMessage(CMessage * pMessage)
{
    HRESULT hr = S_FALSE;
    BOOL    fEditable = IsEditable( TRUE );

    if (!CanHandleMessage())
        goto Cleanup;

    if (!fEditable)
    {
        if (!IsEnabled())
            goto Cleanup;

        hr = BtnHandleMessage(pMessage);
        if (hr == S_FALSE)
        {
            hr = super::HandleMessage(pMessage);
        }
    }
    else
    {
        if (pMessage->message == WM_CONTEXTMENU)
        {
            hr = THR(OnContextMenu(
                    (short)LOWORD(pMessage->lParam),
                    (short)HIWORD(pMessage->lParam),
                    CONTEXT_MENU_CONTROL));
        }
        if (hr == S_FALSE)
        {
            hr = super::HandleMessage(pMessage);
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT BUGCALL
CInput::HandleTextMessage(CMessage * pMessage)
{
    HRESULT         hr = S_FALSE;
    CFormElement *  pForm;
    BOOL            fEditable = IsEditable(TRUE);
    BOOL            fEnabled  = IsEnabled();

    Assert(IsTextOrFile());

    if ( !CanHandleMessage() ||
         (!fEditable && !fEnabled) )
    {
        goto Cleanup;
    }

    if (!fEditable && _fDoReset)
    {
        if (pMessage->message == WM_KEYDOWN)
        {
            if (pMessage->wParam == VK_ESCAPE)
            {
                pForm = GetParentForm();
                if (pForm)
                {
                    _fDoReset = FALSE;
                    hr = THR(pForm->DoReset(TRUE));
                    if (hr != S_FALSE)
                        goto Cleanup;
                }
            }
            else
            {
                _fDoReset = FALSE;
            }
        }
    }

    switch (pMessage->message)
    {
        case WM_CHAR:
            if (pMessage->wParam == VK_RETURN)
            {
                BOOL    fOnlyTextbox;

                pForm = GetParentForm();
                if (pForm)
                {
                    hr = THR(pForm->FOnlyTextbox(this, &fOnlyTextbox));
                    if (FAILED(hr))
                        goto Cleanup;
                    if (fOnlyTextbox)
                    {
                        IGNORE_HR(pForm->DoSubmit(this, TRUE));
                        hr = S_OK;
                        goto Cleanup;
                    }
                    else
                    {
                        hr = S_FALSE;
                    }
                }
            }
            break;


        // We handle all WM_CONTEXTMENUs
        case WM_CONTEXTMENU:
            hr = THR(OnContextMenu(
                    (short) LOWORD(pMessage->lParam),
                    (short) HIWORD(pMessage->lParam),
                    CONTEXT_MENU_CONTROL));
            goto Cleanup;
    }

    if (!fEditable  &&
        pMessage->message == WM_KEYDOWN &&
        pMessage->wParam == VK_ESCAPE)
    {
        _fDoReset = TRUE;
        SetValueHelperInternal(GetLastValue(), FALSE);

        hr = S_FALSE;
        goto Cleanup;
    }

    // Since we let TxtEdit handle messages we do JS events after
    // it comes back
    Assert(S_FALSE == hr);
    hr = super::HandleMessage(pMessage);

Cleanup:

    RRETURN1(hr, S_FALSE);
}


HRESULT
CInput::ClickAction(CMessage * pMessage)
{
    HRESULT         hr = S_OK;
    htmlInput       type = GetType();

    switch(type)
    {
    case    htmlInputButton:
        // Do nothing;
        break;
    case    htmlInputReset:
    case    htmlInputSubmit:
        hr = ClickActionButton(pMessage);
        break;
    case    htmlInputFile:
        hr = ClickActionFile(pMessage);
        break;
    case    htmlInputCheckbox:
        if (BTN_GETSTATUS(_wBtnStatus, FLAG_TRISTATE))
        {
            _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, FLAG_TRISTATE);
            GetUpdatedLayout()->Invalidate();
        }
        else
        {
            put_checked(_fChecked ? VB_FALSE : VB_TRUE);
        }
        break;
    case    htmlInputRadio:
        // Do nothing if unnamed (Netscape Compat.)
        if (!_fChecked && GetAAname())
            put_checked(VB_TRUE);
        break;
    case    htmlInputImage:
        hr = ClickActionImage(pMessage);
        goto Cleanup;
        break;
    default:
        hr = super::ClickAction(pMessage);
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CInput::ClickActionButton(CMessage * pMessage)
{
    HRESULT         hr = S_OK;
    CFormElement *  pForm;

    pForm = GetParentForm();
    if (pForm)
    {
        switch (GetType())
        {
            case htmlInputReset:
                hr = THR(pForm->DoReset(TRUE));
                break;

            case htmlInputSubmit:
                hr = THR(pForm->DoSubmit(this, TRUE));
                break;
        }
        if (hr == S_FALSE)
            hr = S_OK;
    }
    RRETURN1(hr, S_FALSE);
}

HRESULT
CInput::ClickActionImage(CMessage * pMessage)
{
    HRESULT         hr = S_OK;
    CFormElement *  pForm;

    if (pMessage &&
        pMessage->message >= WM_MOUSEFIRST &&
        pMessage->message <= WM_MOUSELAST)
    {
        _pt.x = pMessage->ptContent.x;
        _pt.y = pMessage->ptContent.y;
    }
    else
    {
        GetUpdatedLayout()->GetPosition(&_pt, COORDSYS_FLOWCONTENT);
    }

    pForm = GetParentForm();
    if (pForm)
    {
        pForm->DoSubmit(this, TRUE);
    }
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CInput::ClickActionFile
//
//  Synopsis:   Display the File Open... common dialog here.
//
//----------------------------------------------------------------------------

HRESULT
CInput::ClickActionFile(CMessage * pMessage)
{
    HRESULT hr                      = S_OK;
    TCHAR   achBuf[FORMS_BUFLEN];
    CStr    cstr;
    BSTR    bstr                    = NULL;

    // Do not click if the control is readonly (#67776)
    if (_fReadOnly)
        goto Cleanup;

    // Do nothing unless the click is in the button portion (indicated
    // by non-zero click data)
    if (pMessage && 0 == pMessage->dwClkData)
        goto Cleanup;

    hr = THR(GetValueHelper(&cstr));
    if ( hr )
        goto Cleanup;

    if ( cstr )
    {
        _tcsncpy(achBuf, cstr, FORMS_BUFLEN);
        achBuf[FORMS_BUFLEN-1] = 0;
    }
    else
    {
        *achBuf = 0;
    }

    hr = THR(FormsGetFileName(FALSE,
                              Doc()->_pInPlace->_hwnd,
                              IDS_UPLOADFILE,
                              achBuf,
                              ARRAY_SIZE(achBuf), (LPARAM)0));

    if ( FAILED(hr) )
        goto Cleanup;

    if ( S_OK == hr )
    {
        BOOL fFire =  FormsStringCmpLoc(achBuf, *GetLastValue()) != 0;

        hr = THR(SetValueHelperReal(achBuf, _tcslen(achBuf), FALSE));
        if ( hr )
            goto Cleanup;

        if (fFire)
        {
            if (!Fire_onchange())   //JS event
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            IGNORE_HR(OnPropertyChange(DISPID_A_VALUE, 
                                       0, 
                                       (PROPERTYDESC *)&s_propdescCInputvalue));
        }
    }
    else
    {
        //  S_FALSE means the user cancelled the dialog
        hr = S_OK;
    }

Cleanup:
    SysFreeString(bstr);

    // Do not want this to bubble, so..
    if (S_FALSE == hr)
        hr = S_OK;

    RRETURN(hr);
}

THEMECLASSID
CInput::GetInputThemeClsId() const
{
    switch(GetType())
    {
    case    htmlInputCheckbox:
    case    htmlInputRadio:
    case    htmlInputButton:
    case    htmlInputSubmit:
    case    htmlInputReset:
        return THEME_BUTTON;
    case    htmlInputText:
    case    htmlInputFile:
    case    htmlInputTextarea:
    case    htmlInputPassword:
        return THEME_EDIT;
    }
    return THEME_NO;
}

HRESULT
CInput::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT         hr = S_OK;
    enum _htmlInput type = GetType();
    CDoc *          pDoc;
    LOGFONT         lf;
    BYTE            i;
    BOOL            fIsButton;
    CUnitValue      uvBorderWidth(2, CUnitValue::UNIT_PIXELS);
    HTHEME          hTheme = NULL;
    
    switch(type)
    {
    case    htmlInputImage:
    case    htmlInputCheckbox:
    case    htmlInputRadio:
        hr = super::ApplyDefaultFormat(pCFI);
        goto Cleanup;
    }

    pDoc        = Doc();
    fIsButton   = IsButton();

    pCFI->PrepareCharFormat();
    pCFI->PrepareFancyFormat();
    pCFI->PrepareParaFormat();

    hTheme = GetMarkup()->GetTheme(GetInputThemeClsId());

    DefaultFontInfoFromCodePage( GetMarkup()->GetCodePage(), &lf, pDoc );

    //
    // set char format
    //
    
    pCFI->_cf()._wWeight = 400;
    pCFI->_cf()._yHeight = 200; // 10 * 20 twips NS compatibility
    // pCFI->_cf()._yHeight = 160; // 8 * 20 twips IE3 compatibility    

    // Themed password control requires 0x25cf character. So we need to
    // pickup a font which supports it.
    // HACKHACK (grzegorz): Use always Tahoma font in this situation.
    if (g_fThemedPlatform && htmlInputPassword == GetType())
    {
        _tcsncpy(lf.lfFaceName, _T("Tahoma"), LF_FACESIZE);
    }

    pCFI->_cf()._fBold = FALSE;
    if (fIsButton)
    {
        // Set default color and let super override it with the use style
        pCFI->_cf()._ccvTextColor.SetSysColor(COLOR_BTNTEXT);
        pCFI->_ff()._ccvBackColor.SetSysColor(COLOR_BTNFACE);

        pCFI->_bBlockAlign     = htmlBlockAlignCenter;

        pCFI->_ff()._bd._bBorderSoftEdges = TRUE;

        pCFI->_ff()._bd._ccvBorderColorLight.SetSysColor(COLOR_BTNFACE);
        pCFI->_ff()._bd._ccvBorderColorDark.SetSysColor(COLOR_3DDKSHADOW);
        pCFI->_ff()._bd._ccvBorderColorHilight.SetSysColor(COLOR_BTNHIGHLIGHT);
        pCFI->_ff()._bd._ccvBorderColorShadow.SetSysColor(COLOR_BTNSHADOW);

        if (pCFI->_cf()._fVisibilityHidden || pCFI->_cf()._fDisplayNone)
            _fButtonWasHidden = TRUE;

        //
        // Add default padding
        //
    }
    else
    {
        // No vertical spacing between para's
        pCFI->_ff()._cuvSpaceBefore.SetPoints(0);
        pCFI->_ff()._cuvSpaceAfter.SetPoints(0);

        pCFI->_cf()._ccvTextColor.SetSysColor(COLOR_WINDOWTEXT);
        pCFI->_ff()._ccvBackColor.SetSysColor(COLOR_WINDOW);

        // border
        pCFI->_ff()._bd._ccvBorderColorLight.SetSysColor(COLOR_3DLIGHT);
        pCFI->_ff()._bd._ccvBorderColorDark.SetSysColor(COLOR_3DDKSHADOW);
        pCFI->_ff()._bd._ccvBorderColorHilight.SetSysColor(COLOR_BTNHIGHLIGHT);
        pCFI->_ff()._bd._ccvBorderColorShadow.SetSysColor(COLOR_BTNSHADOW);

        //
        // Add default padding
        //
        CUnitValue      uv;

        uv.SetValue(TEXT_INSET_DEFAULT_LEFT, CUnitValue::UNIT_PIXELS);

        for (i = 0; i < SIDE_MAX; i++)
        {
            pCFI->_ff().SetPadding(i, uv);
        }
    }

    // Since its the same value to which X and Y are being set, logical/physical does not matter here.
    pCFI->_ff().SetOverflowX(styleOverflowHidden);
    pCFI->_ff().SetOverflowY(styleOverflowHidden);

    // our intrinsics shouldn't inherit the cursor property. they have a 'default'
    pCFI->_cf()._bCursorIdx = styleCursorAuto;
    pCFI->_pf()._cuvTextIndent.SetPoints(0);

    pCFI->_cf()._bCharSet = lf.lfCharSet;
    pCFI->_cf().SetFaceName( lf.lfFaceName);

    if (pCFI->_cf().NeedAtFont())
    {
        ApplyAtFontFace(&pCFI->_cf(), Doc(), GetMarkup());
    }

    pCFI->_cf()._fNarrow = IsNarrowCharSet(pCFI->_cf()._bCharSet);

    for (i = 0; i < SIDE_MAX; i++)
    {
        pCFI->_ff()._bd.SetBorderWidth(i, uvBorderWidth);
        if (!fIsButton)
            pCFI->_ff()._bd.SetBorderStyle(i, fmBorderStyleSunken);
    }

    pCFI->UnprepareForDebug();

    hr = THR(super::ApplyDefaultFormat(pCFI));
    if(hr)
        goto Cleanup;

    pCFI->PrepareParaFormat();
    pCFI->PrepareCharFormat();    
    pCFI->PrepareFancyFormat();
    
    if (hTheme && !pCFI->_ff().IsThemeDisabled()) // set theme defaults
    {                    
        // set theme defaults for properties not already set
 
        if (!pCFI->_fFontSet && !GetThemeFont(hTheme, NULL, fIsButton ? BP_PUSHBUTTON : EP_EDITTEXT, 
                                              fIsButton ? PBS_NORMAL : ETS_NORMAL, TMT_FONT, &lf))
        {
            long twips;

            if (!pCFI->_fFontWeightSet)
                pCFI->_cf()._wWeight = lf.lfWeight;

            if (!pCFI->_fFontHeightSet)
            {
                twips = MulDivQuick( lf.lfHeight, TWIPS_PER_INCH, g_sizePixelsPerInch.cy );

                if(twips < 0)
                    twips = - twips;

                pCFI->_cf().SetHeightInTwips( twips );
            }
        }    
    }


    pCFI->_pf()._fPreInner = TRUE;

    if (type == htmlInputHidden && !IsEditable(TRUE))
    {
        pCFI->_cf()._fDisplayNone = TRUE;
    }

    // font height in CharFormat is already nonscaling size in twips
    pCFI->_cf().SetHeightInNonscalingTwips( pCFI->_pcf->_yHeight );

    if (type == htmlInputPassword)
    {
        pCFI->_cf()._fPassword = TRUE;
    }

    pCFI->UnprepareForDebug();

    FixupEditable(pCFI);

Cleanup:
    RRETURN(hr);
}

//
// this is really a 3D array
//
// checkbox, radio
// checked, unchecked, mixed
// 4 states: normal, hot, pressed, disabled
//

static int aryOptionButtonThemeState[2][3][4]=
{
    {
        {CBS_UNCHECKEDNORMAL, CBS_UNCHECKEDHOT, CBS_UNCHECKEDPRESSED, CBS_UNCHECKEDDISABLED},
        {CBS_CHECKEDNORMAL,   CBS_CHECKEDHOT,   CBS_CHECKEDPRESSED,   CBS_CHECKEDDISABLED},
        {CBS_MIXEDNORMAL,     CBS_MIXEDHOT,     CBS_MIXEDPRESSED,     CBS_MIXEDDISABLED},
    },
    {
        {RBS_UNCHECKEDNORMAL, RBS_UNCHECKEDHOT, RBS_UNCHECKEDPRESSED, RBS_UNCHECKEDDISABLED},
        {RBS_CHECKEDNORMAL,   RBS_CHECKEDHOT,   RBS_CHECKEDPRESSED,   RBS_CHECKEDDISABLED},
        {-1,                  -1,               -1,                   -1},
    }
};

int
CInput::GetThemeState()
{

    switch (GetType())
    {
    case htmlInputButton:
    case htmlInputReset:
    case htmlInputSubmit:
    
        if (!IsEnabled())
        {
            return PBS_DISABLED;
        }
        else if (Pressed())
        {
            return PBS_PRESSED;
        }
        else if (MouseOver())
        {
            return PBS_HOT;
        }
        else
        {
            CDoc *pDoc = Doc();

            if (    pDoc 
                &&  _fDefault
                &&  pDoc->HasFocus())
            {
                return PBS_DEFAULTED;
            }
        }
        break;
    case htmlInputRadio:
    case htmlInputCheckbox:
    {
        int i, j, k;
        VARIANT_BOOL    checked;

        i = GetType() == htmlInputRadio ? 1 : 0;

        GetChecked(&checked);

        j = checked ? 1 : 0;

        //
        // this is a checkbox and mixed
        //

        if (!i && BTN_GETSTATUS(_wBtnStatus, FLAG_TRISTATE))
        {
            j = 2;
        }

        if (!IsEnabled())
        {
            k = 3;
        }
        else if (Pressed())
        {
            k = 2;
        }
        else if (MouseOver())
        {
            k = 1;
        }
        else
        {
            k = 0;
        }

        Assert(aryOptionButtonThemeState[i][j][k] > 0);
        return aryOptionButtonThemeState[i][j][k];
    }
    case htmlInputText:
    case htmlInputTextarea:
    case htmlInputPassword:
        if (!IsEnabled())
        {
            return ETS_DISABLED;
        }
        return ETS_NORMAL;

    case htmlInputFile:
        if (!IsEnabled())
        {
            return PBS_DISABLED;
        }
        else if (Pressed())
        {
            return PBS_PRESSED;
        }
        else if (MouseOver())
        {
            return PBS_HOT;
        }
        else
        {
            CDoc *pDoc = Doc();

            if (    pDoc 
                &&  _fButtonHasFocus
                &&  pDoc->HasFocus())
            {
                return PBS_DEFAULTED;
            }
        }
        break;
    default:
        break;
    }

    //
    // PBS_NORMAL can represent normal case for all controls
    //

    return PBS_NORMAL;
}

DWORD
CInput::GetNonThemedBorderInfo(
    CDocInfo * pdci,
    CBorderInfo *pborderinfo,
    BOOL fAll,
    BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    DWORD   nBorders;

    Assert(IsButton());
    pborderinfo->abStyles[SIDE_TOP]    =
    pborderinfo->abStyles[SIDE_RIGHT]  =
    pborderinfo->abStyles[SIDE_BOTTOM] =
    pborderinfo->abStyles[SIDE_LEFT]   = BTN_PRESSED(_wBtnStatus)
                                                ? fmBorderStyleSunken
                                                : fmBorderStyleRaised;
    nBorders = super::GetBorderInfo( pdci, pborderinfo, fAll, TRUE FCCOMMA FCPARAM);

    {
        int xyFlatX = 1;
        int xyFlatY = 1;
        if (pdci)
        {
            xyFlatX = pdci->DeviceFromDocPixelsX(xyFlatX);
            xyFlatY = pdci->DeviceFromDocPixelsY(xyFlatY);
        }
        pborderinfo->aiWidths[SIDE_TOP]    += xyFlatY;
        pborderinfo->aiWidths[SIDE_RIGHT]  += xyFlatX;
        pborderinfo->aiWidths[SIDE_BOTTOM] += xyFlatY;
        pborderinfo->aiWidths[SIDE_LEFT]   += xyFlatX;
    }

    if (!fAllPhysical && HasVerticalLayoutFlow())
    {
        pborderinfo->FlipBorderInfo();
    }
    
    return nBorders;
}

DWORD
CInput::GetBorderInfo(CDocInfo * pdci, CBorderInfo *pborderinfo, BOOL fAll, BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    DWORD   nBorders;
    HTHEME  hTheme = NULL;
    RECT rc;

    // for themed controls, we report no border
    // because the theming engine draws everything.
    // we don't want to draw our own border, so 
    // we report that there's none to draw.

    switch (GetType())
    {
    case htmlInputButton:
    case htmlInputReset:
    case htmlInputSubmit:
    {  
        hTheme = GetTheme(GetInputThemeClsId());

        if (hTheme && !GetThemeBackgroundExtent(hTheme, NULL, EP_EDITTEXT, ETS_NORMAL, &g_Zero.rc, &rc))
        {   
            nBorders = GetNonThemedBorderInfo( pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);

            pborderinfo->aiWidths[SIDE_LEFT]   = pdci->DeviceFromDocPixelsX(-rc.left);            
            pborderinfo->aiWidths[SIDE_RIGHT]  = pdci->DeviceFromDocPixelsX(rc.right);
            pborderinfo->aiWidths[SIDE_TOP]    = pdci->DeviceFromDocPixelsY(-rc.top);
            pborderinfo->aiWidths[SIDE_BOTTOM] = pdci->DeviceFromDocPixelsY(rc.bottom);

            nBorders = DISPNODEBORDER_SIMPLE;
        }
        else
        {
            nBorders = GetNonThemedBorderInfo( pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);
        }
        break;
    }
    case htmlInputFile:
        hTheme = GetTheme(GetInputThemeClsId());

        if (hTheme && !GetThemeBackgroundExtent(hTheme, NULL, EP_EDITTEXT, ETS_NORMAL, &g_Zero.rc, &rc))
        {   
            pborderinfo->aiWidths[SIDE_LEFT]   = pdci->DeviceFromDocPixelsX(-rc.left);            
            pborderinfo->aiWidths[SIDE_RIGHT]  = pdci->DeviceFromDocPixelsX(rc.right);
            pborderinfo->aiWidths[SIDE_TOP]    = pdci->DeviceFromDocPixelsY(-rc.top);
            pborderinfo->aiWidths[SIDE_BOTTOM] = pdci->DeviceFromDocPixelsY(rc.bottom);

            nBorders = DISPNODEBORDER_SIMPLE;
        }
        else
        {
            nBorders = super::GetBorderInfo( pdci, pborderinfo, fAll, TRUE FCCOMMA FCPARAM);
            if (!fAllPhysical && HasVerticalLayoutFlow())
            {
                pborderinfo->FlipBorderInfo();
            }
        }

        if (!_fRealBorderSize)
        {
            // We reserve space for the fake button in the extra right border
            BOOL fRightToLeft = GetFirstBranch()->GetParaFormat(FCPARAM)->HasRTL(FALSE);
            
            pborderinfo->aiWidths[(!fRightToLeft ? SIDE_RIGHT : SIDE_LEFT)] += 
                DYNCAST(CInputFileLayout, GetUpdatedLayout( GUL_USEFIRSTLAYOUT ))->_sizeButton.cx
                + (pdci ? pdci->DeviceFromDocPixelsX(cxButtonSpacing) : cxButtonSpacing);
        }
        nBorders = DISPNODEBORDER_COMPLEX;
        break;
    case htmlInputText:
    case htmlInputPassword:
        
        hTheme = GetTheme(GetInputThemeClsId());
        
        if (hTheme && !GetThemeBackgroundExtent(hTheme, NULL, EP_EDITTEXT, GetThemeState(), &g_Zero.rc, &rc))
        {                        

            // The reason we are adding one to the result from
            // GetThemeBackgroundExtent is that in the Luna 
            // theme, edit controls have a border that is
            // one pixel smaller than non-themed controls.
            // This will ensure that we draw the Luna input
            // controls the same size as non-themed controls.
            // However, this will not be the case if other
            // themes come along that have a size other than
            // one pixel. This will then have to be revisited.
            // This is the best solution for now because future
            // themes will not break or look dumb, they just 
            // might be bigger than current controls.

            pborderinfo->aiWidths[SIDE_LEFT]   = pdci->DeviceFromDocPixelsX(-rc.left + 1);            
            pborderinfo->aiWidths[SIDE_RIGHT]  = pdci->DeviceFromDocPixelsX(rc.right + 1);
            pborderinfo->aiWidths[SIDE_TOP]    = pdci->DeviceFromDocPixelsY(-rc.top + 1);
            pborderinfo->aiWidths[SIDE_BOTTOM] = pdci->DeviceFromDocPixelsY(rc.bottom + 1);

            nBorders = DISPNODEBORDER_SIMPLE;
            break;                        
        }
        
        // FALL THROUGH TO THE DEFAULT IF NO THEME OR THEME FAILS

    default:
        nBorders = super::GetBorderInfo( pdci, pborderinfo, fAll, TRUE FCCOMMA FCPARAM);
        if (!fAllPhysical && HasVerticalLayoutFlow())
        {
            pborderinfo->FlipBorderInfo();
        }
    }

    return nBorders;
}

void
CInput::Notify(CNotification *pNF)
{
    IStream *       pStream = NULL;
    HRESULT         hr = S_OK;
    CStr            cstrVal;
    htmlInput       type = GetType();
    
    // Defer clearing the other radio buttons in the group. This would
    // prevent the collections from being accessed prematurely in
    // SetChecked() called from super::Init2(). The clearing would
    // happen in AddToCollections().
    if (type == htmlInputRadio 
        && pNF->IsType(NTYPE_DELAY_LOAD_HISTORY))
    {
        _fDeferClearGroup = TRUE;
    }

    super::Notify(pNF);
    if (type == htmlInputImage)
    {
        Assert(_pImage);
        _pImage->Notify(pNF);
    }

    switch (pNF->Type())
    {

    case NTYPE_ELEMENT_GOTMNEMONIC:
    {
        if (! IsEditable(/*fCheckContainerOnly*/TRUE) && type == htmlInputText )
        {
            hr = THR( select());
        }                 
    }        
    break;

    case NTYPE_ELEMENT_LOSTMNEMONIC:
    {
        if (! IsEditable(/*fCheckContainerOnly*/TRUE) && type == htmlInputText )
        {
            Doc()->DestroyAllSelection();
        }                 
    }        
    break;
    
    case NTYPE_ELEMENT_QUERYTABBABLE:
        if (GetType() == htmlInputRadio)
        {
            CElement * pElemCurrent = Doc()->_pElemCurrent;

            //
            // this is the current element or this is a radio of different group
            // AND this radio is checked or there is no checked radio
            //
            ((CQueryFocus *)pNF->DataAsPtr())->_fRetVal = 
                                            IsEditable(TRUE)
                                            ||
                                            ((      this == pElemCurrent 
                                                ||  !FInSameGroup(pElemCurrent))
                                            && 
          