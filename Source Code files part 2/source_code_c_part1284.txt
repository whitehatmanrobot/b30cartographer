of the log buffer.

BOOL	LOG::FLGIIsFreeSpace(const BYTE* const pb, ULONG cb)
	{
	Assert( cb < m_cbLGBuf );
	// There is never a time when the entire log buffer
	// is free. This state never occurs.
	Assert( cb != m_cbLGBuf );

	if ( cb == 0 )
		return fTrue;

	return ( CbLGFree() >= cb ) &&
		( PbMaxPtrForUsed( pb ) >= m_pbEntry && PbMaxPtrForUsed( pb ) < PbMaxWrite() ) &&
		( PbMaxPtrForUsed( pb ) + cb > m_pbEntry && PbMaxPtrForUsed( pb ) + cb <= PbMaxWrite() );
	}

// Returns whether cb bytes at pb are in the free portion of the log buffer.

BOOL	LOG::FIsFreeSpace(const BYTE* const pb, ULONG cb)
	{
	const BOOL fResult = FLGIIsFreeSpace( pb, cb );
	// verify with cousin
	Assert( fResult == ! FLGIIsUsedSpace( pb, cb ) );
	return fResult;
	}

// Internal implementation function to determine whether cb
// bytes at pb are in the used portion of the log buffer.

BOOL	LOG::FLGIIsUsedSpace(const BYTE* const pb, ULONG cb)
	{
	Assert( cb <= m_cbLGBuf );

	if ( cb == 0 )
		return fFalse;

	if ( cb < m_cbLGBuf )
		{
		return ( CbLGUsed() >= cb ) &&
			( PbMaxPtrForFree( pb ) >= m_pbWrite && PbMaxPtrForFree( pb ) < PbMaxEntry() ) &&
			( PbMaxPtrForFree( pb ) + cb > m_pbWrite && PbMaxPtrForFree( pb ) + cb <= PbMaxEntry() );
		}
	else
		{
		// special case
		return pb == m_pbWrite && pb == m_pbEntry;
		}
	}

// Returns whether cb bytes at pb are in the used portion of the log buffer.

BOOL	LOG::FIsUsedSpace(const BYTE* const pb, ULONG cb)
	{
	const BOOL fResult = FLGIIsUsedSpace( pb, cb );
	// verify with cousin
#ifdef DEBUG
	// If the user is asking if all of the log buffer is used,
	// we don't want to verify with FLGIIsFreeSpace() because that
	// is an impossibility for us.
	if ( cb != m_cbLGBuf )
		{
		Assert( fResult == ! FLGIIsFreeSpace( pb, cb ) );
		}
#endif
	return fResult;
	}


//	adds log record defined by (pb,cb) 
//	at *ppbET, wrapping around if necessary

VOID LOG::LGIAddLogRec( const BYTE* const pb, INT cb, BYTE **ppbET )
	{
	BYTE *pbET = *ppbET;

	Assert( cb < m_pbLGBufMax - m_pbLGBufMin );

	// With wraparound, we don't need to do 2 separate copies.
	// We can just blast into the address space and it'll go
	// into the second mapping.

	// We must be pointing into the main mapping of the log buffer.
	Assert( pbET >= m_pbLGBufMin );
	Assert( pbET < m_pbLGBufMax );

	// Ensure that we don't memcpy() past our 2 mappings.
	Assert( pbET + cb <= m_pbLGBufMin + 2 * ( m_cbLGBuf ) );

#ifdef DEBUG
		{
		// m_pbWrite should be pointing inside the log buffer.
		Assert( m_pbWrite >= m_pbLGBufMin && m_pbWrite < m_pbLGBufMax );
		
		BYTE *pbWrapWrite = ( m_pbWrite < pbET ) ? ( m_pbWrite + m_cbLGBuf ) : m_pbWrite;
		// Ensure that we don't write into space where valid
		// log records already exist.
		Assert( pbET + cb <= pbWrapWrite );
		}
#endif

	// Do not kill valid log records!
	Assert( FIsFreeSpace( pbET, cb ) );

	UtilMemCpy( pbET, pb, cb );
	if ( !COSMemoryMap::FCanMultiMap() )
		{
		// simulate wrap around by copying the logs on LGBuf and mapped LGBuf
		Assert( pbET < m_pbLGBufMax );
		ULONG cbToLGBufEnd = ULONG( m_pbLGBufMax - pbET );
	
		memcpy( pbET + m_cbLGBuf, pb, min( cb, cbToLGBufEnd ) );
		if ( cb > cbToLGBufEnd )
			{
			memcpy( m_pbLGBufMin, pb + cbToLGBufEnd, cb - cbToLGBufEnd );
			}
		}

	//	return next available entry
	//
	pbET += cb;
	// If we're now pointing into the 2nd mapping, fix us up
	// so we point into the main mapping of the log buffer.
	if ( pbET >= m_pbLGBufMax )
		{
		// We should never be pointing past the 2nd mapping.
		Assert( pbET < m_pbLGBufMax + m_cbLGBuf );
		pbET -= m_cbLGBuf;
		}
	// Point inside first mapping.
	Assert( pbET >= m_pbLGBufMin && pbET < m_pbLGBufMax );
	*ppbET = pbET;
	return;
	}


//
//	Add log record to circular log buffer. Signal flush thread to flush log
//	buffer if at least (g_lLogBuffers / 2) disk sectors are ready for flushing.
//	Return error if we run out of log buffer space.
//
//	RETURNS		JET_errSuccess, or error code from failing routine
//				or errLGNotSynchronous if there's not enough space,
//				or JET_errLogWriteFail if the log is down.
//

#ifdef DEBUG
BYTE rgbDumpLogRec[ 8192 ];
#endif

ERR LOG::ErrLGILogRec( const DATA *rgdata, const INT cdata, const BOOL fLGFlags, LGPOS *plgposLogRec )
	{
	ERR		err			= JET_errSuccess;
	INT		cbReq;
	INT		idata;
	BOOL	fNewGen		= ( fLGFlags & fLGCreateNewGen );
	BYTE*	pbSectorBoundary;
	BOOL	fFormatJetTmpLog	= fFalse;

#ifdef DEBUG
	BYTE*	pbOldEntry = pbNil;
#endif

	// No one should be adding log records if we're in redo mode.
	Assert( fFalse == m_fRecovering || ( fTrue == m_fRecovering && fRecoveringRedo != m_fRecoveringMode ) );

	Assert( !m_fLogDisabledDueToRecoveryFailure );
	if ( m_fLogDisabledDueToRecoveryFailure )
		return ErrERRCheck( JET_errLogDisabledDueToRecoveryFailure );
		
	Assert( m_fLogDisabled == fFalse );
	Assert( rgdata[0].Pv() != NULL );
	Assert( !m_fDBGNoLog );

	//	cbReq is total net space required for record
	//
	for ( cbReq = 0, idata = 0; idata < cdata; idata++ )
		{
		cbReq += rgdata[idata].Cb();
		}

	//	get m_pbEntry in order to add log record
	//
	forever
		{
		INT		ibEntry;
		INT		csecReady;
		INT		cbAvail;
		INT		csecToExclude;
		INT		cbFraction;
		INT		csecToAdd;
		INT		isecLGFileEndT = 0;

		m_critLGBuf.Enter();
		if ( m_fLGNoMoreLogWrite )
			{
			m_critLGBuf.Leave();
			return ErrERRCheck( JET_errLogWriteFail );
			}

		// XXX
		// Should probably Assert() that we have a valid m_pbLastChecksum

		//	if just initialized or no input since last flush
		//

		// We should always be dealing with valid pointers.
		Assert( m_pbWrite >= m_pbLGBufMin );
		Assert( m_pbWrite < m_pbLGBufMax );
		Assert( m_pbEntry >= m_pbLGBufMin );
		Assert( m_pbEntry < m_pbLGBufMax );

		//	calculate available space
		//
		// This case is handled properly by the below code, but we're
		// just curious how often this happens.
		AssertSz( m_pbWrite != m_pbEntry,
			"We just wanted to know how often m_pbWrite == m_pbEntry. Press OK to continue.");
		// m_pbWrite == m_pbEntry means log buffer is FULL (which is ok)!!!!
		if ( m_pbWrite >= m_pbEntry )
			cbAvail = ULONG( m_pbWrite - m_pbEntry );
		else
			cbAvail = ULONG( ( m_pbLGBufMax - m_pbEntry ) + ( m_pbWrite - m_pbLGBufMin ) );

		if ( 0 == cbAvail )
			{
			// XXX
			// I now believe that this can happen. Consider the case where
			// we're flushing and we just added the new LRCHECKSUM at the
			// end of the log buffer, using up all available space. Then
			// we release m_critLGBuf and start doing our I/O. During that
			// I/O time, someone tries to add new log records -- then
			// m_pbEntry == m_pbWrite which means no space. They just need
			// to wait until the I/O completes and the flush thread
			// moves forward m_pbWrite which will free up space.
			//
			// What will happen now is that the goto Restart will signal
			// the flush thread to flush (it's currently flushing),
			// we'll return errLGSynchronousWait_Whatever, the flush will
			// finish and the client will try to add the log record again.
			AssertSz( fFalse, "No space in log buffer to append (or flush). Flush must be in progress. Press OK to continue.");
			// See bug VisualStudio7:202353 for info on VC7 beta not
			// generating the code for this goto statement.
			goto Restart;
			}

		//	calculate sectors of buffer ready to flush. Excluding
		//	the half filled sector.
		 
		csecToExclude = ( cbAvail - 1 ) / m_cbSec + 1;
		csecReady = m_csecLGBuf - csecToExclude;

		//	check if add this record, it will reach the point of
		//	the sector before last sector of current log file and the point
		//	is enough to hold a lrtypMS and lrtypEnd. Note we always
		//	reserve the last sector as a shadow sector.
		//	if it reach the point, check if there is enough space to put
		//	NOP to the end of log file and cbLGMSOverhead of NOP's for the
		//	first sector of next generation log file. And then set m_pbEntry
		//	there and continue adding log record.
		 
		
		if ( m_pbLGFileEnd != pbNil )
			{
			Assert( m_isecLGFileEnd != 0 );
			// already creating new log, do not bother to check fNewGen. 
			goto AfterCheckEndOfFile;
			}

		ibEntry = ULONG( m_pbEntry - PbSecAligned( m_pbEntry ) );
		
		//	check if after adding this record, the sector will reach
		//	the sector before last sector. If it does, let's patch NOP.
		 
		if ( fNewGen )
			{
#ifdef UNLIMITED_DB
			//	if AttachInfo needs to be logged, then we must have just
			//	started a new gen
			Assert( !m_fLGNeedToLogDbList );
#endif

			// last sector is the one that will be patched with NOP

			// Notice that with FASTFLUSH, we don't need any terminating
			// LRCHECKSUM at the end of the log file. The last LRCHECKSUM
			// (before the last bunch of data) will have a cbNext == 0
			// which signifies that its range that it covers is the last
			// range of data in the log file. Note that it may be preferable
			// to change the format to always have a terminating LRCHECKSUM
			// simplify the startup code (so we don't need to check to see
			// if we need to create a new log file in a certain circumstance).
			cbFraction = ibEntry;
			if ( 0 == cbFraction )
				{
				csecToAdd = 0;
				}
			else
				{
				csecToAdd = ( cbFraction - 1 ) / m_cbSec + 1;
				}
			Assert( csecToAdd >= 0 && csecToAdd <= 1 );
			isecLGFileEndT = m_isecWrite + csecReady + csecToAdd;
			}
		else
			{
			// check if new gen is necessary

			// for the end of the log file, we do not need to stick
			// in an LRCHECKSUM at the end.
#ifdef UNLIMITED_DB
			cbFraction = ibEntry + cbReq + ( m_fLGNeedToLogDbList ? m_cbLGDbListInUse : 0 );
#else
			cbFraction = ibEntry + cbReq;
#endif			
			if ( 0 == cbFraction )
				{
				csecToAdd = 0;
				}
			else
				{
				csecToAdd = ( cbFraction - 1 ) / m_cbSec + 1;
				}
			Assert( csecToAdd >= 0 );

			// The m_csecLGFile - 1 is because the last sector of the log file
			// is reserved for the shadow sector.

			if ( csecReady + m_isecWrite + csecToAdd >= ( m_csecLGFile - 1 ) )
				{
#ifdef UNLIMITED_DB
				//	if this enforce fires, it means we're at the start of
				//	a log record, but the logfile is not big enough to
				//	fit the attachment list plus the current log record
				Enforce( !m_fLGNeedToLogDbList );
#endif

				// We can't fit the new log records and an LRCHECKSUM,
				// so let's make a new log generation.
				// - 1 is to reserve last sector as shadow sector.
				isecLGFileEndT = m_csecLGFile - 1;
				fNewGen = fTrue;
				}
			}

		if ( fNewGen )
			{
			INT cbToFill;

			//	Adding the new record, we will reach the point. So let's
			//	check if there is enough space to patch NOP all the way to
			//	the end of file. If not enough, then wait the log flush to
			//	flush.
			 
			INT csecToFill = isecLGFileEndT - ( m_isecWrite + csecReady );
			Assert( csecToFill > 0 || csecToFill == 0 && ibEntry == 0 );

			// We fill up to the end of the file, plus the first
			// cbLGMSOverhead bytes of the next sector in the log file.
			// This is to reserve space for the beginning LRMS in the
			// next log file.

			// This implicitly takes advantage of the knowledge that
			// we'll have free space up to a sector boundary -- in other
			// words, m_pbWrite is always sector aligned.

			// See bug VisualStudio7:202353 for info on VC7 beta not
			// generating the code for this goto statement.

			if ( ( cbAvail / m_cbSec ) <= csecToFill + 1 )
				//	available space is not enough to fill to end of file plus
				//	first sector of next generation. Wait flush to generate
				//	more space.
				 
				goto Restart;

			//	now we have enough space to patch.
			//	Let's set m_pbLGFileEnd for log flush to generate new log file.

			//	Zero out sizeof( LRCHECKSUM ) bytes in the log buffer that will
			//	later be written to the next log file.
			cbToFill = csecToFill * m_cbSec - ibEntry + sizeof( LRCHECKSUM );
			
			//	If this Assert() goes off, please verify that the compiler has
			//	generated code for the "goto Restart" above. In January 2001,
			//	spenlow found a codegen problem with version 13.0.9037
			//	of the compiler (VC7 beta). See bug VisualStudio7:202353.
			AssertRTL( cbToFill <= cbAvail );

#ifdef DEBUG
			pbOldEntry = m_pbEntry;
#endif
			// Takes advantage of VM wrap-around to memset() over wraparound boundary.
			Assert( m_pbEntry >= m_pbLGBufMin && m_pbEntry < m_pbLGBufMax );
			Assert( FIsFreeSpace( m_pbEntry, cbToFill ) );
			memset( m_pbEntry, lrtypNOP, cbToFill );

			if ( !COSMemoryMap::FCanMultiMap() )
				{
				memset( m_pbEntry + m_cbLGBuf, lrtypNOP, min( cbToFill, m_pbLGBufMax - m_pbEntry ) );
				if ( m_pbEntry + cbToFill > m_pbLGBufMax )
					memset( m_pbLGBufMin, lrtypNOP, m_pbEntry + cbToFill - m_pbLGBufMax );
				}

			m_pbEntry += cbToFill;
			if ( m_pbEntry >= m_pbLGBufMax )
				{
				m_pbEntry -= m_cbLGBuf;
				}
			Assert( m_pbEntry >= m_pbLGBufMin && m_pbEntry < m_pbLGBufMax );
			Assert( sizeof( LRCHECKSUM ) == m_pbEntry - PbSecAligned( m_pbEntry ) );
			Assert( FIsUsedSpace( pbOldEntry, cbToFill ) );

			// m_pbLGFileEnd points to the LRMS for use in the next log file.

			// Setup m_pbLGFileEnd to point to the sector boundary of the last
			// stuff that should be written to the log file. This is noticed
			// by ErrLGIWriteFullSectors() to switch to the next log file.
			m_pbLGFileEnd = m_pbEntry - sizeof( LRCHECKSUM );
			// m_pbLGFileEnd should be sector aligned
			Assert( PbSecAligned( m_pbLGFileEnd ) == m_pbLGFileEnd );
			m_isecLGFileEnd = isecLGFileEndT;

#ifdef UNLIMITED_DB
			Assert( !m_fLGNeedToLogDbList );
			m_fLGNeedToLogDbList = fTrue;
#endif			

			// No need to setup m_lgposMaxFlushPoint here since
			// flushing thread will do that. Notice that another
			// thread can get in to m_critLGBuf before flushing thread
			// and they can increase m_lgposMaxFlushPoint.

			// send signal to generate new log file 
			LGSignalFlush();
			
			// start all over again with new m_pbEntry, cbAvail etc. 
			m_critLGBuf.Leave();
			continue;
			}


AfterCheckEndOfFile:

		// Because m_csecLGBuf differs from m_pinst->m_lLogBuffers
		// because the log buffers have to be a multiple of the system
		// memory allocation granularity, the flush threshold should be
		// half of the actual size of the log buffer (not the logical
		// user requested size).
		if ( csecReady > m_csecLGBuf / 2 )
			{
			//	reach the threshold, flush before adding new record
			//
			// XXX
			// The above comment seems misleading because although
			// this signals the flush thread, the actual flushing
			// doesn't happen until we release m_critLGBuf which
			// doesn't happen until we add the new log records and exit.
			LGSignalFlush();
			cLGCapacityFlush.Inc( m_pinst );
			}

#ifdef UNLIMITED_DB
		//	we're now committed to adding the log record
		//	to the log buffer, so we may update cbReq
		//	if we need to log AttachInfo
		if ( m_fLGNeedToLogDbList )
			{
			cbReq += m_cbLGDbListInUse;
			}
#endif			

		// make sure cbAvail is enough to hold one LRMS and end type.

		// XXX
		// I think this can be ">=" since we don't need space
		// for an lrtypEnd or anything like that. Why did the
		// !FASTFLUSH code use > instead of >=??? Since
		// cbLGMSOverhead takes into account the lrtypEnd,
		// why does it need to be >????

		// If we have enough space in the log buffer for
		// the log records and for an LRCHECKSUM (we always need
		// space for it for the next flush to insert).

		// Note that this implicitly keeps in mind the NOP-space
		// that we will have to fill the last sector before
		// putting an LRMS on the next sector (so it's contiguous
		// on one sector).
		if ( cbAvail > cbReq + sizeof( LRCHECKSUM ) )
			{
			//	no need to flush 
			break;
			}
		else
			{
			//	restart.  Leave critical section for other users
			//
Restart:
			LGSignalFlush();
			cLGStall.Inc( m_pinst );
			err = ErrERRCheck( errLGNotSynchronous );
			Assert( m_critLGBuf.FOwner() );
			goto FormatJetTmpLog;
			}
		}


#ifdef UNLIMITED_DB
	if ( fLGFlags & fLGInterpretLR )
		{
		const LRTYP		lrtyp	= *( (LRTYP *)rgdata[0].Pv() );
		switch ( lrtyp )
			{
			case lrtypCreateDB:
				err = ErrLGPreallocateDbList_( ( (LRCREATEDB *)rgdata[0].Pv() )->dbid );
				break;
			case lrtypAttachDB:
				err = ErrLGPreallocateDbList_( ( (LRATTACHDB *)rgdata[0].Pv() )->dbid );
				break;

			default:
				AssertSzRTL( fFalse, "Unexpected LRTYP" );
			case lrtypDetachDB:
			case lrtypForceDetachDB:
				err = JET_errSuccess;
				break;
			}

		if ( err < 0 )
			{
			CallSx( err, JET_errOutOfMemory );
			Assert( m_fLGNoMoreLogWrite );
			m_critLGBuf.Leave();
			return err;
			}
		}
#endif


	//	now we are holding m_pbEntry, let's add the log record.
	//
	GetLgposOfPbEntry( &m_lgposLogRec );
	if ( m_fRecovering || m_fBackupInProgress )
		{
		cLGRecordOffset.Clear( m_pinst );
		}
	else
		{
		cLGRecordOffset.Set( m_pinst, CbOffsetLgpos( m_lgposLogRec, lgposMin ) );
		}
#ifdef DEBUG
	Assert( CmpLgpos( &m_lgposLastLogRec, &m_lgposLogRec ) < 0 );
	m_lgposLastLogRec = m_lgposLogRec;
#endif

	if ( plgposLogRec )
		*plgposLogRec = m_lgposLogRec;

	Assert( m_pbEntry >= m_pbLGBufMin );
	Assert( m_pbEntry < m_pbLGBufMax );


	//	setup m_lgposMaxFlushPoint so it points to the first byte of log data that will NOT be making it to disk
	//
	//	in the case of a multi-sector flush, this will point to the log record which "hangs over" the sector
	//		boundary; it will mark that log record as not being flushed and will thus prevent the buffer manager
	//		from flushing the database page
	//
	//	in the case of a single-sector flush, this will not be used at all

	//	calculate the sector boundary where the partial data begins 
	//		(full-sector data is before this point -- there may not be any)

	pbSectorBoundary = PbSecAligned( m_pbEntry + cbReq );

	// note that we use PbGetEndOfLogData() so we don't point after
	// a LRCK that was just added. bwahahahaha!!
	if ( PbSecAligned( PbGetEndOfLogData() ) == pbSectorBoundary )
		{

		//	the new log record did not put us past a sector boundary
		//
		//	it was put into a partially full sector and does not hang over, so do not bother settting
		//		m_lgposMaxFlushPoint
		
		}
	else
		{

		//	the new log record is part of a multi-sector flush
		//
		//	if it hangs over the edge, then we cannot include it when calculating m_lgposMaxFlushPoint
		
		BYTE *		pbEnd					= m_pbEntry;

#ifdef UNLIMITED_DB
		BOOL		fCheckDataFitsInSector	= fTrue;
		if ( m_fLGNeedToLogDbList )
			{
			BYTE * const pbLREnd = pbEnd + m_cbLGDbListInUse;

			if ( pbLREnd > pbSectorBoundary )
				{
				//	DbList already forces us to go beyond the
				//	sector boundary, so no need to check rest
				//	of data
				fCheckDataFitsInSector = fFalse;
				Assert( pbEnd == m_pbEntry );
				}
			else
				{
				pbEnd = pbLREnd;
				}
			}
#else
		const BOOL	fCheckDataFitsInSector	= fTrue;
#endif

		if ( fCheckDataFitsInSector )
			{
			for ( idata = 0; idata < cdata; idata++ )
				{
				BYTE * const pbLREnd = pbEnd + rgdata[ idata ].Cb();
				if ( pbLREnd > pbSectorBoundary )
					{

					//	the log record hangs over the edge and cannot be included in m_lgposMaxFlushPoint
					//
					//	reset pbEnd so it points to the start of the log record 
					//		(we use pbEnd to set m_lgposMaxFlushPoint)

					pbEnd = m_pbEntry;
					break;
					}
				else
					{

					//	this segment of the log record will not hang over
					//
					//	include it and continue checking

					pbEnd = pbLREnd;
					}
				}
			}


#ifdef DEBUG
		LGPOS lgposOldMaxFlushPoint = m_lgposMaxFlushPoint;
#endif	//	DEBUG

		//	notice that pbEnd may have wrapped into the second mapping of the log buffer

		Assert( pbEnd >= m_pbLGBufMin && pbEnd < ( m_pbLGBufMax + m_cbLGBuf ) );
		GetLgpos( ( pbEnd >= m_pbLGBufMax ) ? ( pbEnd - m_cbLGBuf ) : ( pbEnd ),
			&m_lgposMaxFlushPoint );
		Assert( CmpLgpos( &m_lgposMaxFlushPoint, &m_lgposLogRec ) >= 0 );

		// max flush point must always be increasing.

		Assert( CmpLgpos( &lgposOldMaxFlushPoint, &m_lgposMaxFlushPoint ) <= 0 );

#ifdef DEBUG
		//	m_lgposMaxFlushPoint should be pointing to the beginning OR the end of the last log record

		LGPOS lgposLogRecEndT = m_lgposLogRec;
		AddLgpos( &lgposLogRecEndT, cbReq );
		Assert( CmpLgpos( &m_lgposMaxFlushPoint, &m_lgposLogRec ) == 0 ||
				CmpLgpos( &m_lgposMaxFlushPoint, &lgposLogRecEndT ) == 0 );
#endif	//	DEBUG
		}

#ifdef DEBUG
	pbOldEntry = m_pbEntry;
#endif
	Assert( FIsFreeSpace( m_pbEntry, cbReq ) );

#ifdef UNLIMITED_DB
	if ( m_fLGNeedToLogDbList )
		{
		LGIAddLogRec( m_pbLGDbListBuffer, m_cbLGDbListInUse, &m_pbEntry );
		m_fLGNeedToLogDbList = fFalse;
		}
#endif		

	//  add all the data streams to the log buffer.  if we catch an exception
	//  during this process, we will fail the addition of the log record with an
	//  error but we will still store a fully formed log record in the buffer by
	//  filling it out with a fill pattern

	//  CONSIDER:  handle this zero buffer differently

		{
		static const BYTE rgbFill[ g_cbPageMax ] = { 0 };

		TRY
			{
			for ( idata = 0; idata < cdata; idata++ )
				{
				Assert( rgdata[idata].Cb() <= sizeof( rgbFill ) );
				
				LGIAddLogRec( (BYTE *)rgdata[idata].Pv(), rgdata[idata].Cb(), &m_pbEntry );
				}
			}
		EXCEPT( efaExecuteHandler )
			{
			for ( ; idata < cdata; idata++ )
				{
				Assert( rgdata[idata].Cb() <= sizeof( rgbFill ) );
				
				LGIAddLogRec( rgbFill, rgdata[idata].Cb(), &m_pbEntry );
				}

			err = ErrERRCheck( errLGRecordDataInaccessible );
			}
		ENDEXCEPT
		}

	Assert( FIsUsedSpace( pbOldEntry, cbReq ) );

	Assert( m_pbEntry >= m_pbLGBufMin && m_pbEntry < m_pbLGBufMax );

	//	add a dummy fill record to indicate end-of-data
	//
	// XXX
	// Since we just did a bunch of AddLogRec()'s, how can m_pbEntry be
	// equal to m_pbLGBufMax? This seems like it should be an Assert().
	// Maybe in the case where the number of log records added is zero?
	// That itself should be an Assert()

	Assert( m_pbEntry < m_pbLGBufMax && m_pbEntry >= m_pbLGBufMin );

#ifdef DEBUG
	if ( m_fDBGTraceLog )
		{
		DWORD dwCurrentThreadId = DwUtilThreadId();
		BYTE *pb;
		
		g_critDBGPrint.Enter();

		//	must access rgbDumpLogRec in g_critDBGPrint.
		 
		pb = rgbDumpLogRec;
		for ( idata = 0; idata < cdata; idata++ )
			{
			UtilMemCpy( pb, rgdata[idata].Pv(), rgdata[idata].Cb() );
			pb += rgdata[idata].Cb();
			}

		LR	*plr	= (LR *)rgbDumpLogRec;

		//	we nevee explicitly log NOPs
		Assert( lrtypNOP != plr->lrtyp );
		Assert( 0 == GetNOP() );
		
		if ( dwCurrentThreadId == m_dwDBGLogThreadId )
			DBGprintf( "$");
		else if ( FLGDebugLogRec( plr ) )
			DBGprintf( "#");
		else
			DBGprintf( "<");
				
		DBGprintf( " {%u} %u,%u,%u",
					dwCurrentThreadId,
					m_lgposLogRec.lGeneration,
					m_lgposLogRec.isec,
					m_lgposLogRec.ib );
		ShowLR( plr, this );
		
		g_critDBGPrint.Leave();
		}
#endif

//	GetLgposOfPbEntry( &lgposEntryT );

	//  monitor statistics  
	cLGRecord.Inc( m_pinst );


#ifdef UNLIMITED_DB
	if ( fLGFlags & fLGInterpretLR )
		{
		const LRTYP		lrtyp	= *( (LRTYP *)rgdata[0].Pv() );
		switch ( lrtyp )
			{
			case lrtypCreateDB:
				LGAddToDbList_( ( (LRCREATEDB *)rgdata[0].Pv() )->dbid );
				break;
			case lrtypAttachDB:
				LGAddToDbList_( ( (LRATTACHDB *)rgdata[0].Pv() )->dbid );
				break;
			case lrtypDetachDB:
			case lrtypForceDetachDB:
				LGRemoveFromDbList_( ( (LRDETACHCOMMON *)rgdata[0].Pv() )->dbid );
				break;
			default:
				AssertSzRTL( fFalse, "Unexpected LRTYP" );
			}
		}
#endif
	
FormatJetTmpLog:

	Assert( m_critLGBuf.FOwner() );

	if ( CmpLgpos( m_lgposLogRec, m_lgposCreateAsynchTrigger ) >= 0 &&
		FLGICreateAsynchIOCompletedTryWait() )
		{
		Assert( m_fCreateAsynchLogFile );

		//	Everyone else's trigger-checks should fail since this thread will handle this
		
		m_lgposCreateAsynchTrigger = lgposMax;

		fFormatJetTmpLog = fTrue;
		}
		
	//	now we are done with the insertion to buffer.
	//
	m_critLGBuf.Leave();

	if ( fFormatJetTmpLog )
		{
		LGICreateAsynchIOIssue();
		}

	return err;
	}


//	This function was created as a workaround to a VC7 beta compiler
//	codegen bug that caused "goto Restart" statements in ErrLGILogRec()
//	to have no code (and no magic fall-through). See bug VisualStudio7:202353.
//	The workaround is to reduce the complexity of ErrLGILogRec() by
//	putting this code in FLGICreateAsynchIOCompleted() and forcing the
//	function to never be inlined by the compiler.

#pragma auto_inline( off )

BOOL LOG::FLGICreateAsynchIOCompletedTryWait()
	{
	return m_asigCreateAsynchIOCompleted.FTryWait();
	}

#pragma auto_inline( on )


ERR LOG::ErrLGTryLogRec(
	const DATA	* const rgdata,
	const ULONG	cdata,
	const BOOL	fLGFlags,
	LGPOS		* const plgposLogRec )
	{
	if ( m_pttFirst )
		{
		ERR		err		= JET_errSuccess;

		//	There a list of trace in temp memory structure. Log them first.
		do {
			m_critLGTrace.Enter();
			if ( m_pttFirst )
				{
				TEMPTRACE *ptt = m_pttFirst;
				err = ErrLGITrace( ptt->ppib, ptt->szData, fTrue /* fInternal */ );
				m_pttFirst = ptt->pttNext;
				if ( m_pttFirst == NULL )
					{
					Assert( m_pttLast == ptt );
					m_pttLast = NULL;
					}
				OSMemoryHeapFree( ptt );
				}
			m_critLGTrace.Leave();
			} while ( m_pttFirst != NULL && err == JET_errSuccess );

		if ( err != JET_errSuccess )
			return err;
		}

	//	No trace to log or trace list is taken care of, log the normal log record

	return ErrLGILogRec( rgdata, cdata, fLGFlags, plgposLogRec );
	}

//	Group commits, by waiting to give others a chance to flush this
//	and other commits.
//
ERR LOG::ErrLGWaitCommit0Flush( PIB *ppib )
	{
	ERR		err			= JET_errSuccess;
	BOOL	fFlushLog	= fFalse;

	//  if the log is disabled or we are recovering, skip the wait

	if ( m_fLogDisabled || m_fRecovering )
		{
		goto Done;
		}

	//  this session had better have a log record it is waiting on
	//  NOTE:  this is usually a Commit0, but can be a CreateDB/AttachDB/DetachDB

	Assert( CmpLgpos( &ppib->lgposCommit0, &lgposMax ) != 0 );

	//  if our Commit0 record has already been written to the log, no need to wait

	m_critLGBuf.Enter();
	if ( CmpLgpos( &ppib->lgposCommit0, &m_lgposToFlush ) < 0 )
		{
		m_critLGBuf.Leave();
		goto Done;
		}

	//  if the log is down, you're hosed

	if ( m_fLGNoMoreLogWrite )
		{
		err = ErrERRCheck( JET_errLogWriteFail );
		m_critLGBuf.Leave();
		goto Done;
		}

	//  add this session to the log flush wait queue
	
	m_critLGWaitQ.Enter();
	cLGUsersWaiting.Inc( m_pinst );
	
	Assert( !ppib->FLGWaiting() );
	ppib->SetFLGWaiting();
	ppib->ppibNextWaitFlush = ppibNil;

	if ( m_ppibLGFlushQHead == ppibNil )
		{
		m_ppibLGFlushQTail = m_ppibLGFlushQHead = ppib;
		ppib->ppibPrevWaitFlush = ppibNil;
		}
	else
		{
		Assert( m_ppibLGFlushQTail != ppibNil );
		ppib->ppibPrevWaitFlush = m_ppibLGFlushQTail;
		m_ppibLGFlushQTail->ppibNextWaitFlush = ppib;
		m_ppibLGFlushQTail = ppib;
		}

	m_critLGWaitQ.Leave();
	m_critLGBuf.Leave();

	//  signal a log flush

	LGSignalFlush();
	cLGCommitFlush.Inc( m_pinst );

	//  wait forever for our Commit0 to be flushed to the log

	ppib->asigWaitLogFlush.Wait();

	//  the log write failed

	if ( m_fLGNoMoreLogWrite )
		{
		err = ErrERRCheck( JET_errLogWriteFail );
		}

	//  the log write succeeded

	else
		{
#ifdef DEBUG

		//  verify that out Commit0 record is now on disk
		
		LGPOS lgposToFlushT;

		m_critLGBuf.Enter();
		lgposToFlushT = m_lgposToFlush;
		// XXX
		// Curiously, this non-FASTFLUSH code uses a >= comparison
		// to see if something has gone to disk, but it seems like
		// > should be used (for both new and old flushing).

		Assert( CmpLgpos( &m_lgposToFlush, &ppib->lgposCommit0 ) > 0 );
		m_critLGBuf.Leave();

#endif  //  DEBUG
		}

Done:
	Assert( !ppib->FLGWaiting() );
	Assert(	err == JET_errLogWriteFail || err == JET_errSuccess );
	
	return err;
	}

// Kicks off synchronous log flushes until all log data is flushed

ERR LOG::ErrLGWaitAllFlushed( IFileSystemAPI *const pfsapi )
	{
	forever
		{
		LGPOS	lgposEndOfData;
		INT		cmp;
		
		m_critLGBuf.Enter();

		//	BUG X5:83888 
		//
		//		we create a torn-write after a clean shutdown because we don't flush the last LRCK record
		//		(we weren't seeing it because PbGetEndOfLogData() was pointing AT the LRCK instead of PAST it)
		//
		//		make sure we wait until we flush up to m_pbEntry (rather than PbGetEndOfLogData())

		BYTE* const	pbEndOfData = m_pbEntry;

		GetLgpos( pbEndOfData, &lgposEndOfData );
		cmp = CmpLgpos( &lgposEndOfData, &m_lgposToFlush );

		m_critLGBuf.Leave();

		if ( cmp > 0 )
			{
			// synchronously ask for flush
			ERR err = ErrLGFlushLog( pfsapi, fTrue );
			if ( err < 0 )
				{
				return err;
				}
			}
		else
			{
			// All log data is flushed, so we're done.
			break;
			}
		}
		
	return JET_errSuccess;
	}

ERR LOG::ErrLGITrace( PIB *ppib, CHAR *sz, BOOL fInternal )
	{
	ERR				err;
	DATA 			rgdata[2];
	INT				cdata;
	LRTRACE			lrtrace;

	//	No trace in recovery mode

	if ( m_fRecovering )
		return JET_errSuccess;

	if ( m_fLogDisabled )
		return JET_errSuccess;

	lrtrace.lrtyp = lrtypTrace;
	if ( ppib != ppibNil )
		{
		Assert( ppib->procid < 64000 );
		lrtrace.le_procid = ppib->procid;
		}
	else
		{
		lrtrace.le_procid = procidNil;
		}
	lrtrace.le_cb = USHORT( strlen( sz ) + 1 );
	rgdata[0].SetPv( (BYTE *) &lrtrace );
	rgdata[0].SetCb( sizeof( lrtrace ) );
	cdata = 1;

	if ( lrtrace.le_cb )
		{
		rgdata[1].SetCb( lrtrace.le_cb );
		rgdata[1].SetPv( reinterpret_cast<BYTE *>( sz ) );
		cdata = 2;
		}

	if ( fInternal )
		{
		//	To prevent recursion, do not call ErrLGLogRec which then callback
		//	ErrLGTrace

		return ErrLGILogRec( rgdata, cdata, fLGNoNewGen, pNil );
		}

	err = ErrLGTryLogRec( rgdata, cdata, fLGNoNewGen, pNil );
	if ( err == errLGNotSynchronous )
		{
		//	Trace should not block anyone, put the record in a temp
		//	space and log it next time. It is OK to loose trace if the system
		//	crashes.

		TEMPTRACE *ptt;

		ptt = (TEMPTRACE *) PvOSMemoryHeapAlloc( sizeof( TEMPTRACE ) + lrtrace.le_cb );
		if ( !ptt )
			{
			return( ErrERRCheck( JET_errOutOfMemory ) );
			}
		ptt->ppib = ppib;
		ptt->pttNext = NULL;
		
		m_critLGTrace.Enter();
		if ( m_pttLast != NULL )
			m_pttLast->pttNext = ptt;
		else
			m_pttFirst = ptt;
		m_pttLast = ptt;
		m_critLGTrace.Leave();
		UtilMemCpy( ptt->szData, sz, lrtrace.le_cb );

		return JET_errSuccess;
		}

	return err;
	}

ERR LOG::ErrLGTrace( PIB *ppib, CHAR *sz )
	{
	return ErrLGITrace( ppib, sz, fFalse );
	}


/*	write log file header.  No need to make a shadow since
 *	it will not be overwritten.
/**/
ERR LOG::ErrLGWriteFileHdr(
	LGFILEHDR* const	plgfilehdr,	// log file header to set checksum of and write
	IFileAPI* const		pfapi		// file to write to (default: m_pfapiLog)
	)
	{
	ERR		err;

	Assert( plgfilehdr->lgfilehdr.dbms_param.le_lLogBuffers );

	plgfilehdr->lgfilehdr.le_ulChecksum = UlUtilChecksum( (BYTE*) plgfilehdr, sizeof( LGFILEHDR ) );

	//	the log file header should be aligned on any volume regardless of sector size

	Assert( m_cbSecVolume <= sizeof( LGFILEHDR ) );
	Assert( sizeof( LGFILEHDR ) % m_cbSecVolume == 0 );

	//	issue the write

 	err = pfapi->ErrIOWrite( 0, m_csecHeader * m_cbSec, (BYTE *)plgfilehdr );
 	if ( err < 0 )
		{
		LGReportError( LOG_FILE_SYS_ERROR_ID, err, pfapi );

		err = ErrERRCheck( JET_errLogWriteFail );
		LGReportError( LOG_HEADER_WRITE_ERROR_ID, err, pfapi );

		m_fLGNoMoreLogWrite = fTrue;
		}

	//	update performance counters

	cLGWrite.Inc( m_pinst );
	cLGBytesWritten.Add( m_pinst, m_csecHeader * m_cbSec );

	return err;
	}

ERR LOG::ErrLGWriteFileHdr( LGFILEHDR* const plgfilehdr )
	{
	return ErrLGWriteFileHdr( plgfilehdr, m_pfapiLog );
	}

/*
 *	Read log file header, detect any incomplete or
 *	catastrophic write failures.  These failures will be used to
 *	determine if the log file is valid or not.
 *
 *	On error, contents of plgfilehdr are unknown.
 *
 *	RETURNS		JET_errSuccess, or error code from failing routine
 */
ERR LOG::ErrLGReadFileHdr(
	IFileAPI * const	pfapiLog,
	LGFILEHDR *			plgfilehdr,
	const BOOL			fNeedToCheckLogID,
	const BOOL			fBypassDbPageSizeCheck )
	{
	ERR		err;
	QWORD	qwFileSize;
	QWORD	qwCalculatedFileSize;
	QWORD	qwSystemFileSize;

	/*	read log file header.  Header is written only during
	/*	log file creation and cannot become corrupt unless system
	/*	crash in the middle of file creation.
	/**/
	Call( pfapiLog->ErrIORead( 0, sizeof( LGFILEHDR ), (BYTE* const)plgfilehdr ) );

	/*	check if the data is bogus.
	 */
	if ( plgfilehdr->lgfilehdr.le_ulChecksum != UlUtilChecksum( (BYTE*)plgfilehdr, sizeof(LGFILEHDR) ) )
		{
		err = ErrERRCheck( JET_errLogFileCorrupt );
		}

	/*	check for old JET version
	/**/
	if ( *(long *)(((char *)plgfilehdr) + 24) == 4
		 && ( *(long *)(((char *)plgfilehdr) + 28) == 909		//	NT version
			  || *(long *)(((char *)plgfilehdr) + 28) == 995 )	//	Exchange 4.0
		 && *(long *)(((char *)plgfilehdr) + 32) == 0
		)
		{
		/*	version 500
		/**/
		err = ErrERRCheck( JET_errDatabase500Format );
		}
	else if ( *(long *)(((char *)plgfilehdr) + 20) == 443
		 && *(long *)(((char *)plgfilehdr) + 24) == 0
		 && *(long *)(((char *)plgfilehdr) + 28) == 0 )
		{
		/*	version 400
		/**/
		err = ErrERRCheck( JET_errDatabase400Format );
		}
	else if ( *(long *)(((char *)plgfilehdr) + 44) == 0
		 && *(long *)(((char *)plgfilehdr) + 48) == 0x0ca0001 )
		{
		/*	version 200
		/**/
		err = ErrERRCheck( JET_errDatabase200Format );
		}
	Call( err );

	if ( ulLGVersionMajor != plgfilehdr->lgfilehdr.le_ulMajor
		|| ulLGVersionMinor != plgfilehdr->lgfilehdr.le_ulMinor
		|| ulLGVersionUpdate < plgfilehdr->lgfilehdr.le_ulUpdate )
		{
		Call( ErrERRCheck( JET_errBadLogVersion ) );
		}

	// check filetype
	if( filetypeUnknown != plgfilehdr->lgfilehdr.le_filetype // old format
		&& filetypeLG != plgfilehdr->lgfilehdr.le_filetype )
		{
		// not a log file
		Call( ErrERRCheck( JET_errFileInvalidType ) );
		}

	if ( m_fSignLogSet )
		{
		if ( fNeedToCheckLogID )
			{
			if ( memcmp( &m_signLog, &plgfilehdr->lgfilehdr.signLog, sizeof( m_signLog ) ) != 0 )
				Error( ErrERRCheck( JET_errBadLogSignature ), HandleError );
			}
		}
	else
		{
		m_signLog = plgfilehdr->lgfilehdr.signLog;

		if ( !fBypassDbPageSizeCheck )
			{
			const UINT	cbPageT	= ( plgfilehdr->lgfilehdr.le_cbPageSize == 0 ?
										g_cbPageDefault :
										plgfilehdr->lgfilehdr.le_cbPageSize );
			if ( cbPageT != g_cbPage )
				Call( ErrERRCheck( JET_errPageSizeMismatch ) );
			}

		m_fSignLogSet = fTrue;
		}

//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
/*****
	//	make sure the log sector size is correct

	if ( m_fRecovering || m_fHardRestore || m_cbSecVolume == ~(ULONG)0 )
		{

		//	we are recovering (or we are about to -- thus, the sector size is not set) which means we 
		//		must bypass the enforcement of the log sector size and allow the user to recover 
		//		(we will error out after recovery is finished)

		//	nop
		}
	else
		{

		//	we are not recovering

		if ( plgfilehdr->lgfilehdr.le_cbSec != m_cbSecVolume )
			{

			//	the sector size of this log does not match the current volume's sector size

			Call( ErrERRCheck( JET_errLogSectorSizeMismatch ) );
			}
		}
****/
//	---** TEMPORARY FIX **---
if ( plgfilehdr->lgfilehdr.le_cbSec != m_cbSecVolume )
	{
	Call( ErrERRCheck( JET_errLogSectorSizeMismatch ) );
	}


	//	make sure all the log file sizes match properly (real size, size from header, and system-param size)

	Call( pfapiLog->ErrSize( &qwFileSize ) );
	qwCalculatedFileSize = QWORD( plgfilehdr->lgfilehdr.le_csecLGFile ) * 
						   QWORD( plgfilehdr->lgfilehdr.le_cbSec );
	if ( qwFileSize != qwCalculatedFileSize )
		{
		Call( ErrERRCheck( JET_errLogFileSizeMismatch ) );
		}
	if ( m_pinst->m_fUseRecoveryLogFileSize )
		{

		//	we are recovering which means we must bypass the enforcement of the log file size
		//		and allow the user to recover (so long as all the recovery logs are the same size)

		if ( m_pinst->m_lLogFileSizeDuringRecovery == 0 )
			{

			//	this is the first log the user is reading during recovery

			//	initialize the recovery log file size

			Assert( qwCalculatedFileSize % 1024 == 0 );
			m_pinst->m_lLogFileSizeDuringRecovery = LONG( qwCalculatedFileSize / 1024 );
			}

		//	enforce the recovery log file size
		
		qwSystemFileSize = QWORD( m_pinst->m_lLogFileSizeDuringRecovery ) * 1024;
		}
	else if ( m_pinst->m_fSetLogFileSize )
		{

		//	we are not recovering, so we must enforce the size set by the user

		qwSystemFileSize = QWORD( m_pinst->m_lLogFileSize ) * 1024;
		}
	else
		{

		//	we are not recovering, but the user never set a size for us to enforce

		//	set the size using the current log file on the user's behalf

		qwSystemFileSize = qwCalculatedFileSize;
		m_pinst->m_fSetLogFileSize = fTrue;
		m_pinst->m_lLogFileSize = LONG( qwCalculatedFileSize / 1024 );
		}
	if ( qwFileSize != qwSystemFileSize )
		{
		Call( ErrERRCheck( JET_errLogFileSizeMismatch ) );
		}

HandleError:
	if ( err == JET_errSuccess )
		{
		
		//	we have successfully opened the log file, and the volume sector size has been
		//		set meaning we are allowed to adjust the sector sizes
		//		(when the volume sector size is not set, we are recovering but we have not
		//		 yet started the redo phase -- we are in preparation)

		m_cbSec = plgfilehdr->lgfilehdr.le_cbSec;
		Assert( m_cbSec >= 512 );
		m_csecHeader = sizeof( LGFILEHDR ) / m_cbSec;
		m_csecLGFile = plgfilehdr->lgfilehdr.le_csecLGFile;
		}
	else
		{
		CHAR		szLogfile[IFileSystemAPI::cchPathMax];
		CHAR		szErr[8];
		const UINT 	csz = 2;
		const CHAR	* rgszT[csz] = { szLogfile, szErr };

		if ( pfapiLog->ErrPath( szLogfile ) < 0 )
			{
			szLogfile[0] = 0;
			}
		sprintf( szErr, "%d", err );

		if ( JET_errBadLogVersion == err )
			{
			UtilReportEvent(
				( m_fDeleteOldLogs ? eventWarning : eventError ),
				LOGGING_RECOVERY_CATEGORY,
				LOG_BAD_VERSION_ERROR_ID,
				csz - 1,
				rgszT,
				0, 
				NULL,
				m_pinst );
			}
		else
			{
			UtilReportEvent(
				eventError,
				LOGGING_RECOVERY_CATEGORY,
				LOG_HEADER_READ_ERROR_ID,
				csz,
				rgszT,
				0,
				NULL,
				m_pinst );
			}

		m_fLGNoMoreLogWrite = fTrue;
		}

	return err;
	}


/*	Create the log file name (no extension) corresponding to the lGeneration
/*	in szFName. NOTE: szFName need minimum 9 bytes.
/*
/*	PARAMETERS	rgbLogFileName	holds returned log file name
/*				lGeneration 	log generation number to produce	name for
/*	RETURNS		JET_errSuccess
/**/

const char rgchLGFileDigits[] =
	{
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
	};
const LONG lLGFileBase = sizeof(rgchLGFileDigits)/sizeof(char); 


VOID LOG::LGSzFromLogId( CHAR *szFName, LONG lGeneration )
	{
	LONG	ich;

	strcpy( szFName, m_szJetLogNameTemplate );
	for ( ich = 7; ich > 2; ich-- )
		{
		szFName[ich] = rgchLGFileDigits[lGeneration % lLGFileBase];
		lGeneration = lGeneration / lLGFileBase;
		}

	return;
	}


/*	copy tm to a smaller structure logtm to save space on disk.
 */
VOID LGIGetDateTime( LOGTIME *plogtm )
	{
	DATETIME tm;

	UtilGetCurrentDateTime( &tm );

	plogtm->bSeconds = BYTE( tm.second );
	plogtm->bMinutes = BYTE( tm.minute );
	plogtm->bHours = BYTE( tm.hour );
	plogtm->bDay = BYTE( tm.day );
	plogtm->bMonth = BYTE( tm.month );
	plogtm->bYear = BYTE( tm.year - 1900 );
	}


//	open edb.log and recognize the case where we crashed while creating a new log file

ERR LOG::ErrLGOpenJetLog( IFileSystemAPI *const pfsapi )
	{
	ERR		err;
	CHAR	szPathJetTmpLog[IFileSystemAPI::cchPathMax];
	CHAR	szFNameT[IFileSystemAPI::cchPathMax];
#ifdef DEBUG
	BOOL	fRetryOpen = fFalse;
#endif	//	DEBUG

	//	create the file name/path for edb.log and edbtmp.log

	LGMakeLogName( m_szLogName, m_szJet );
	LGMakeLogName( szPathJetTmpLog, m_szJetTmp );

OpenLog:

	//	try to open edb.log

	err = pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog, fTrue );

	if ( err < 0 )
		{
		if ( JET_errFileNotFound != err )
			{
			//	we failed to open edb.log, but the failure was not related to the file not being found
			//	we must assume there was a critical failure during file-open such as "out of memory"
			LGReportError( LOG_OPEN_FILE_ERROR_ID, err );
			return err; 
			}

		err = ErrUtilPathExists( pfsapi, szPathJetTmpLog, NULL );
		if ( err < 0 )
			{
			//	edb.log does not exist, and there's some problem accessing
			//	edbtmp.log (most likely it doesn't exist either), so
			//	return file-not-found on edb.log
			return ErrERRCheck( JET_errFileNotFound );
			}

		CallS( err );	//	warnings not expected

		//	we don't have edb.log, but we have edbtmp.log
		//
		//	this can only happen one of two possible ways:
		//		a) we were creating the first generation in edbtmp.log -- edb.log never even existed
		//		   we crashed during this process
		//		b) we had just finished creating the next generation in edbtmp.log
		//		   we renamed edb.log to edbXXXXX.log
		//		   we were ABOUT to rename edbtmp.log to edb.log, but crashed
		//
		//
		//	in case 'a', we never finished creating edb.log (using edbtmp.log), so we can safely say 
		//	that it never really existed
		//
		//	we delete edbtmp.log and return JET_errFileNotFound to the user to reflect this case
		//
		//
		//	in case 'b', we expect edbtmp.log to be a valid log file, although we can't be sure because the
		//	logfile size might be wrong or the pattern might be compromized...
		//
		//	instead of trying to use edbtmp.log, we will rename the previous generational log to edb.log and 
		//	then delete edbtmp.log.  since the new edb.log will be full, the user will immediately create the
		//	next log generation using edbtmp.log (which is what they were doing before they crashed)
		//
		//	NOTE: if we crash during the rename and the delete, we will have edb.log and edbtmp.log which is
		//		  a perfectly valid state -- seeing this will cause us to delete edbtmp.log right away

		LONG lGenMaxT;

		CallR ( ErrLGIGetGenerationRange( pfsapi, m_szLogCurrent, NULL, &lGenMaxT ) );
		if ( 0 != lGenMaxT )
			{
			CHAR szPathJetGenerationalLogT[IFileSystemAPI::cchPathMax];

			//	we are in case 'b' -- a generational log exists

			//	rename the generation log to edb.log
			//	NOTE: m_szLogName was setup at the start of this function

			LGSzFromLogId( szFNameT, lGenMaxT );
			LGMakeLogName( szPathJetGenerationalLogT, szFNameT );
			CallR( pfsapi->ErrFileMove( szPathJetGenerationalLogT, m_szLogName ) );

			//	try to open edb.log again

#ifdef DEBUG
			Assert( !fRetryOpen );
			fRetryOpen = fTrue;
#endif	//	DEBUG

			goto OpenLog;
			}

		//	we are in case 'a' -- no previous generational log exists
		//	fall through so that we delete edbtmp.log and return JET_errFileNotFound
		err = ErrERRCheck( JET_errFileNotFound );
		}
	else
		{
		CallS( err );	//	no warnings expected
		}


	//	if we got here, then edb.log exists, so clean up edbtmp.log
	(VOID)pfsapi->ErrFileDelete( szPathJetTmpLog );

	return err;
	}


ERR LOG::ErrLGIUpdateGenRequired(
	IFileSystemAPI * const	pfsapi,
	const LONG 				lGenMinRequired,
	const LONG 				lGenMaxRequired, 
	const LOGTIME 			logtimeGenMaxCreate,
	BOOL * const			pfSkippedAttachDetach )
	{
	ERR						errRet 			= JET_errSuccess;
	IFileSystemAPI *		pfsapiT;

	if ( pfSkippedAttachDetach )
		{
		*pfSkippedAttachDetach = fFalse;
		}

	Assert( m_critCheckpoint.FOwner() );

	FMP::EnterCritFMPPool();

	for ( DBID dbidT = dbidUserLeast; dbidT < dbidMax; dbidT++ )
		{
		ERR err;
		IFMP ifmp;

		ifmp = m_pinst->m_mpdbidifmp[ dbidT ];
		if ( ifmp >= ifmpMax )
			continue;

		FMP 		*pfmpT			= &rgfmp[ ifmp ];
		
		if ( pfmpT->FReadOnlyAttach() )
			continue;

		pfmpT->RwlDetaching().EnterAsReader();

		//	need to check ifmp again. Because the db may be cleaned up
		//	and FDetachingDB is reset, and so is its ifmp in m_mpdbidifmp.

		if (   m_pinst->m_mpdbidifmp[ dbidT ] >= ifmpMax 
			|| pfmpT->FSkippedAttach() || pfmpT->FDeferredAttach()
			|| !pfmpT->Pdbfilehdr() )
			{
			pfmpT->RwlDetaching().LeaveAsReader();
			continue;
			}

			
		if ( !pfmpT->FAllowHeaderUpdate() ) 
			{
			if ( pfSkippedAttachDetach )
				{
				*pfSkippedAttachDetach = fTrue;
				}
			pfmpT->RwlDetaching().LeaveAsReader();
			continue;
			}

		// during Snapshot we don't update the database pages so
		// we don't want to update the db header
		// (we can have genRequired not up-to-date as no pages are flushed)
		if ( pfmpT->FDuringSnapshot() )
			{
			pfmpT->RwlDetaching().LeaveAsReader();
			continue;
			}
			
		DBFILEHDR_FIX *pdbfilehdr	= pfmpT->Pdbfilehdr();
		Assert( pdbfilehdr );

		if( lGenMaxRequired )
			{
			LONG lGenMaxRequiredOld;

#ifdef DEBUG
			// we should have the same time for the same generation
			LOGTIME tmEmpty;
			memset( &tmEmpty, '\0', sizeof( LOGTIME ) );
			Assert ( pdbfilehdr->le_lGenMaxRequired != lGenMaxRequired || 0 == lGenMaxRequired || 0 == pdbfilehdr->le_lGenMaxRequired ||
					0 == memcmp( &pdbfilehdr->logtimeGenMaxCreate, &tmEmpty, sizeof( LOGTIME ) ) || 
					0 == memcmp( &pdbfilehdr->logtimeGenMaxCreate, &logtimeGenMaxCreate, sizeof( LOGTIME ) ) );
#endif					

			lGenMaxRequiredOld 	= pdbfilehdr->le_lGenMaxRequired;
			
			/*
			We have the following scenario:
			- start new log -> update m_plgfilehdrT -> call this function with genMax = 5 (from m_plgfilehdrT)
			- other thread is updating the checkpoint file setting genMin but is passing genMax from m_plgfilehdr
			which is still 4 because the log thread is moving m_plgfilehdrT into m_plgfilehdr later on

			The header ends up with genMax 4 and data is logged in 5 -> Wrong !!! We need max (old, new)
			*/
			pdbfilehdr->le_lGenMaxRequired = max( lGenMaxRequired, lGenMaxRequiredOld );
			Assert ( lGenMaxRequiredOld <= pdbfilehdr->le_lGenMaxRequired );			

			// if we updated the genMax with the value passed in, update the time with the new value as well
			if ( pdbfilehdr->le_lGenMaxRequired == lGenMaxRequired )
				{
				memcpy( &pdbfilehdr->logtimeGenMaxCreate, &logtimeGenMaxCreate, sizeof( LOGTIME ) );
				}

			}


		if ( lGenMinRequired )
			{
			LONG lGenMinRequiredOld;

			lGenMinRequiredOld 	= pdbfilehdr->le_lGenMinRequired;
			pdbfilehdr->le_lGenMinRequired = max( lGenMinRequired, pdbfilehdr->le_lgposAttach.le_lGeneration );
			Assert ( lGenMinRequiredOld <= pdbfilehdr->le_lGenMinRequired );			
			}

		pfsapiT = pfsapi;

		err = ErrUtilWriteShadowedHeader(
				pfsapiT,
				pfmpT->SzDatabaseName(),
				fTrue,
				(BYTE *)pdbfilehdr,
				g_cbPage,
				pfmpT->Pfapi() );
			
		pfmpT->RwlDetaching().LeaveAsReader();

		if ( errRet == JET_errSuccess )
			errRet = err;
		}

	FMP::LeaveCritFMPPool();

	return errRet;
	}


//	used by ErrLGCheckState

ERR LOG::ErrLGICheckState( IFileSystemAPI *const pfsapi )
	{
	ERR		err		= JET_errSuccess;

	m_critLGResFiles.Enter();

	//	re-check status in case disk space has been freed

	if ( m_ls != lsNormal )
		{
		CHAR	* szT	= m_szLogCurrent;

		m_szLogCurrent = m_szLogFilePath;
		(VOID)ErrLGICreateReserveLogFiles( pfsapi );
		m_szLogCurrent = szT;

		if ( m_ls != lsNormal )
			{
			err = ErrERRCheck( JET_errLogDiskFull );
			}
		}
	if ( err >= JET_errSuccess && m_fLogSequenceEnd )
		{
		err = ErrERRCheck( JET_errLogSequenceEnd );
		}

	m_critLGResFiles.Leave();

	return err;
	}



//	make sure the reserve logs exist (res1.log and res2.log)

ERR LOG::ErrLGICreateReserveLogFiles( IFileSystemAPI *const pfsapi, const BOOL fCleanupOld )
	{
	const LS			lsBefore = m_ls;
	CHAR  				szPathJetLog[IFileSystemAPI::cchPathMax];
	const CHAR* const	rgszResLogBaseNames[] = { szLogRes2, szLogRes1 };
	const size_t		cResLogBaseNames = sizeof( rgszResLogBaseNames ) / sizeof( rgszResLogBaseNames[ 0 ] );

	Assert( m_critLGResFiles.FOwner() );

	if ( lsBefore == lsOutOfDiskSpace )
		return ErrERRCheck( JET_errLogDiskFull );

	m_ls = lsNormal;

	if ( fCleanupOld )
		{
		IFileFindAPI*	pffapi			= NULL;
		QWORD			cbSize;
		const QWORD		cbSizeExpected	= QWORD( m_csecLGFile ) * m_cbSec;
			
		//	we need to cleanup the old reserve logs if they are the wrong size
		//	NOTE: if the file-delete call(s) fail, it is ok because this will be
		//		handled later when ErrLGNewLogFile expands/shrinks the reserve
		//		reserve log to its proper size
		//		(this solution is purely proactive)

		for ( size_t iResLogBaseNames = 0; iResLogBaseNames < cResLogBaseNames; ++iResLogBaseNames )
			{
			LGMakeLogName( szPathJetLog, rgszResLogBaseNames[ iResLogBaseNames ] );
			if (	pfsapi->ErrFileFind( szPathJetLog, &pffapi ) == JET_errSuccess &&
					pffapi->ErrNext() == JET_errSuccess &&
					pffapi->ErrSize( &cbSize ) == JET_errSuccess &&
					cbSizeExpected != cbSize )
				{
				(void)pfsapi->ErrFileDelete( szPathJetLog );
				}
			delete pffapi;
			pffapi = NULL;
			}
		}

	for ( size_t iResLogBaseNames = 0; iResLogBaseNames < cResLogBaseNames; ++iResLogBaseNames )
		{
		LGMakeLogName( szPathJetLog, rgszResLogBaseNames[ iResLogBaseNames ] );
		ERR err = ErrUtilPathExists( pfsapi, szPathJetLog );
		if ( err == JET_errFileNotFound )
			{
			IFileAPI*	pfapiT = NULL;
			err = ErrUtilCreateLogFile(	pfsapi, 
										szPathJetLog, 
										&pfapiT, 
										QWORD( m_csecLGFile ) * m_cbSec );
			if ( err >= 0 )
				{
				delete pfapiT;
				}
			}
		if ( err < 0 )
			{
			if ( lsBefore == lsNormal )
				{
				UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY, LOW_LOG_DISK_SPACE, 0, NULL );
				}
			m_ls = lsQuiesce;
			break;
			}
		}

	//	We tried to ensure that our reserve log files exist and may or may not have succeeded

	return JET_errSuccess;
	}

//	Create Asynchronous Log File Assert

#define CAAssert( expr ) AssertRTL( expr )

//	Parameters
//
//		pfsapi
//			[in] file system interface for log directory
//		ppfapi
//			[out] file interface to opened edbtmp.log
//		pszPathJetTmpLog
//			[in] full path to edbtmp.log that we will be opening.
//		pfResUsed
//			[out] Whether the edbtmp.log file that was opened was formerly
//			a reserve log file.
//
//	Return Values
//
//		Errors cause *ppfapi to be NULL.

ERR LOG::ErrLGIOpenTempLogFile(
	IFileSystemAPI* const	pfsapi,
	IFileAPI** const		ppfapi,
	const _TCHAR* const		pszPathJetTmpLog,
	BOOL* const				pfResUsed
	)
	{
	ERR		err	= JET_errSuccess;

	CAAssert( pfsapi );
	CAAssert( ppfapi );
	CAAssert( pszPathJetTmpLog );
	CAAssert( pfResUsed );
	
	*ppfapi = NULL;
	*pfResUsed = fFalse;

	//	Delete any existing edbtmp.log in case it exists.
	
	err = pfsapi->ErrFileDelete( pszPathJetTmpLog );
	Call( JET_errFileNotFound == err ? JET_errSuccess : err );

	err = ErrLGIOpenArchivedLogFile( pfsapi, ppfapi, pszPathJetTmpLog );

	//  We don't have an edbtmp.log open because we couldn't reuse an old log file,
	//	so try to create a new one.
	
	if ( ! *ppfapi )
		{
		err = pfsapi->ErrFileCreate( pszPathJetTmpLog, ppfapi, fFalse, fFalse, fFalse );

		//	Error in trying to create a new edbtmp.log so try to use a reserve log
		//	instead.
		
		if ( err < JET_errSuccess )
			{
			Call( ErrLGIOpenReserveLogFile( pfsapi, ppfapi, pszPathJetTmpLog ) );
			*pfResUsed = fTrue;
			CAAssert( *ppfapi );
			}
		}
	else
		{
		CAAssert( err >= JET_errSuccess );
		}

HandleError:
	if ( err < JET_errSuccess )
		{
		if ( *ppfapi )
			{
			delete *ppfapi;
			*ppfapi = NULL;
			
			const ERR errFileDel = pfsapi->ErrFileDelete( pszPathJetTmpLog );
			}
		*pfResUsed = fFalse;
		}
	return err;
	}

ERR LOG::ErrLGIOpenArchivedLogFile(
	IFileSystemAPI* const	pfsapi,
	IFileAPI** const		ppfapi,
	const _TCHAR* const		pszPathJetTmpLog
	)
	{
	ERR		err = JET_errSuccess;
	_TCHAR	szLogName[ IFileSystemAPI::cchPathMax ];

	CAAssert( pfsapi );
	CAAssert( ppfapi );
	CAAssert( pszPathJetTmpLog );
	
	*ppfapi = NULL;
	
	//	If circular log file flag set and backup not in progress
	//	then find oldest log file and if no longer needed for
	//	soft-failure recovery, then rename to szJetTempLog.
	//	Also delete any unnecessary log files.

	//	SYNC: No locking necessary for m_fLGCircularLogging since it is immutable
	//	while the instance is initialized.

	//	SYNC: We don't need to worry about a backup starting or stopping while
	//	we're executing since if circular logging is enabled, a backup will not mess
	//	with the archived log files.

	if ( m_fLGCircularLogging && !m_fBackupInProgress )
		{
		/*	when find first numbered log file, set lgenLGGlobalOldest to log file number
		/**/
		LONG lgenLGGlobalOldest = 0;

		(void)ErrLGIGetGenerationRange( pfsapi, m_szLogFilePath, &lgenLGGlobalOldest, NULL );

		/*	if found oldest generation and oldest than checkpoint,
		/*	then move log file to szJetTempLog.  Note that the checkpoint
		/*	must be flushed to ensure that the flushed checkpoint is
		/*	after then oldest generation.
		/**/
		if ( lgenLGGlobalOldest != 0 )
			{
			//	UNDONE:	related issue of checkpoint write
			//			synchronization with dependent operations
			//	UNDONE:	error handling for checkpoint write
			(VOID) ErrLGUpdateCheckpointFile( pfsapi, fFalse );
			if ( lgenLGGlobalOldest <
				m_pcheckpoint->checkpoint.le_lgposCheckpoint.le_lGeneration )
				{
				CHAR	szFNameT[ IFileSystemAPI::cchPathMax ];
				
				LGSzFromLogId( szFNameT, lgenLGGlobalOldest );
				LGMakeLogName( szLogName, szFNameT );
				err = pfsapi->ErrFileMove( szLogName, pszPathJetTmpLog );
				CAAssert( err < 0 || err == JET_errSuccess );
				if ( err == JET_errSuccess )
					{
					err = pfsapi->ErrFileOpen( pszPathJetTmpLog, ppfapi );
					if ( err < JET_errSuccess )
						{
						//	We renamed the archived log file to edbtmp.log but were
						//	unable to open it, so let us try to rename it back.
						
						if ( pfsapi->ErrFileMove( pszPathJetTmpLog, szLogName ) < JET_errSuccess )
							{
							//	Unable to rename log file back (a file which we can't open), so
							//	try to delete it as last resort to stablize filesystem state.
							
							(VOID) pfsapi->ErrFileDelete( pszPathJetTmpLog );
							}
						}
					else
						{
						ERR	errFilDel = JET_errSuccess;
						
						/*	delete unnecessary log files.  At all times, retain
						/*	a continguous and valid sequence.
						/**/
						while ( errFilDel == JET_errSuccess )
							{
							lgenLGGlobalOldest++;
							CAAssert( lgenLGGlobalOldest <= 
								m_pcheckpoint->checkpoint.le_lgposCheckpoint.le_lGeneration );
							if ( lgenLGGlobalOldest == m_pcheckpoint->checkpoint.le_lgposCheckpoint.le_lGeneration )
								break;
							LGSzFromLogId( szFNameT, lgenLGGlobalOldest );
							LGMakeLogName( szLogName, szFNameT );
							errFilDel = pfsapi->ErrFileDelete( szLogName );
							}
						}
					}
				}
			}
		}

	return err;
	}

ERR LOG::ErrLGIOpenReserveLogFile(
	IFileSystemAPI* const	pfsapi,
	IFileAPI** const		ppfapi,
	const _TCHAR* const		pszPathJetTmpLog
	)
	{
	ERR		err = JET_errSuccess;
	_TCHAR	szLogName[ IFileSystemAPI::cchPathMax ];

	CAAssert( pfsapi );
	CAAssert( ppfapi );
	CAAssert( pszPathJetTmpLog );

	*ppfapi = NULL;

	CAAssert( m_critLGResFiles.FNotOwner() );
	m_critLGResFiles.Enter();
	
	/*	use reserved log file and change to log state
	/**/
	LGMakeLogName( szLogName, szLogRes2 );
	err = pfsapi->ErrFileMove( szLogName, pszPathJetTmpLog );
	CAAssert( err < 0 || err == JET_errSuccess );
	if ( err == JET_errSuccess )
		{
		err = pfsapi->ErrFileOpen( pszPathJetTmpLog, ppfapi );
		if ( ! *ppfapi )
			{
			//	We renamed res2.log to edbtmp.log but were unable to open it,
			//	so try to rename it back. If this fails, we should delete edbtmp.log
			//	because we can't rename it and we can't open it and we still need
			//	to try to use res1.log.
			
			if ( pfsapi->ErrFileMove( pszPathJetTmpLog, szLogName ) < JET_errSuccess )
				{
				//	If this fails, we're in real bad shape where we can't even try
				//	to use res1.log.
				
				(void) pfsapi->ErrFileDelete( pszPathJetTmpLog );
				}
			}
		}

	if ( m_ls == lsNormal )
		{
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY, LOW_LOG_DISK_SPACE, 0, NULL );
		m_ls = lsQuiesce;
		}

	if ( ! *ppfapi )
		{
		//	couldn't use res2, try res1
		LGMakeLogName( szLogName, szLogRes1 );
		err = pfsapi->ErrFileMove( szLogName, pszPathJetTmpLog );
		CAAssert( err < 0 || err == JET_errSuccess );
		if ( err == JET_errSuccess )
			{
			err = pfsapi->ErrFileOpen( pszPathJetTmpLog, ppfapi );
			if ( ! *ppfapi )
				{
				//	Unable to open edbtmp.log (formerly known as res1.log), so
				//	at least try to rename it back (yeesh, we are in a bad place).

				(void) pfsapi->ErrFileMove( pszPathJetTmpLog, szLogName );
				}
			}
		CAAssert( m_ls == lsQuiesce || m_ls == lsOutOfDiskSpace );
		}

	if ( ! *ppfapi )
		{
		CAAssert( err < JET_errSuccess );
		CAAssert( m_ls == lsQuiesce || m_ls == lsOutOfDiskSpace );
		if ( m_ls == lsQuiesce )
			{
			const CHAR*	rgpszString[] = {
				m_szJetLog	// short name without any directory components i.e. edb.log
				};

			// If we could not open either of the reserved log files,
			// because the disk is full, then we're out of luck and
			// really out of disk space.
			UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY, LOG_DISK_FULL, sizeof( rgpszString ) / sizeof( rgpszString[ 0 ] ), rgpszString, 0, NULL, m_pinst );
			m_ls = lsOutOfDiskSpace;
			}
		}
	else
		{
		CAAssert( err >= JET_errSuccess );
		}

	m_critLGResFiles.Leave();

	return err;
	}

DWORD LOG::CbLGICreateAsynchIOSize()
	{
	CAAssert( !m_asigCreateAsynchIOCompleted.FTryWait() );
	CAAssert( m_ibJetTmpLog < QWORD( m_csecLGFile ) * m_cbSec );
	const QWORD	cbIO = min(
		cbLogExtendPattern - m_ibJetTmpLog % cbLogExtendPattern,
		( QWORD( m_csecLGFile ) * m_cbSec ) - m_ibJetTmpLog );
	CAAssert( DWORD( cbIO ) == cbIO );
	return DWORD( cbIO );
	}

VOID LOG::LGICreateAsynchIOIssue()
	{
	//	We acquired the signal so we're the only thread messing with edbtmp.log

	CAAssert( ! m_asigCreateAsynchIOCompleted.FTryWait() );
	
	const QWORD	ib	= m_ibJetTmpLog;
	const DWORD	cb	= CbLGICreateAsynchIOSize();

	CAAssert( ib < QWORD( m_csecLGFile ) * m_cbSec );
	CAAssert( cb > 0 );
	
	m_ibJetTmpLog += cb;

	//	Should not hold log buffer over the issuing of this asynch I/O.
	//	Issuing of asynch I/O isn't guaranteed to be fast (i.e. might be
	//	waiting for a free IO request-related block to be available).
	
	CAAssert( m_critLGBuf.FNotOwner() );
	
	//	Error will be completed.
	CAAssert( m_pfapiJetTmpLog );
	(void) m_pfapiJetTmpLog->ErrIOWrite(
		ib,
		cb,
		rgbLogExtendPattern,
		LGICreateAsynchIOComplete_,
		reinterpret_cast< DWORD_PTR >( this ) );
	}

void LOG::LGICreateAsynchIOComplete_(
	const ERR			err,
	IFileAPI* const		pfapi,
	const QWORD			ibOffset,
	const DWORD			cbData,
	const BYTE* const	pbData,
	const DWORD_PTR		keyIOComplete
	)
	{
	LOG* const	plog = reinterpret_cast< LOG* >( keyIOComplete );
	CAAssert( plog );
	plog->LGICreateAsynchIOComplete( err, pfapi, ibOffset, cbData, pbData );
	}

void LOG::LGICreateAsynchIOComplete(
	const ERR			err,
	IFileAPI* const		pfapi,
	const QWORD			ibOffset,
	const DWORD			cbData,
	const BYTE* const	pbData
	)
	{
	CAAssert( m_fCreateAsynchLogFile );
	CAAssert( m_pfapiJetTmpLog );
	CAAssert( JET_errSuccess == m_errCreateAsynch );
	m_errCreateAsynch = err;

	//	If success, and more I/O to do, set trigger for when next I/O
	//	should occur, otherwise leave trigger as lgposMax to prevent any
	//	further checking or writing.
	
	if ( err >= JET_errSuccess )
		{
		CAAssert( m_ibJetTmpLog <= QWORD( m_csecLGFile ) * m_cbSec );
		if ( m_ibJetTmpLog < QWORD( m_csecLGFile ) * m_cbSec )
			{
			m_critLGBuf.Enter();
			LGPOS	lgpos = { 0, 0, m_plgfilehdr->lgfilehdr.le_lGeneration };
			CAAssert( static_cast< DWORD >( m_ibJetTmpLog ) == m_ibJetTmpLog );
			AddLgpos( &lgpos, static_cast< DWORD >( m_ibJetTmpLog ) );
			
			m_lgposCreateAsynchTrigger = lgpos;
			m_critLGBuf.Leave();
			}
		}
	CAAssert( !m_asigCreateAsynchIOCompleted.FTryWait() );
	m_asigCreateAsynchIOCompleted.Set();
	}

//	Wait for any IOs to the edbtmp.log to complete, then close the file.

VOID LOG::LGCreateAsynchWaitForCompletion()
	{
	//	SYNC:
	//	Must be inside of m_critLGFlush or in LOG termination because we
	//	can't have the flush task concurrently modify m_pfapiJetTmpLog.
	
	if ( m_pfapiJetTmpLog ||					// edbtmp.log opened
		m_errCreateAsynch < JET_errSuccess )	// error trying to open edbtmp.log
		{
		CAAssert( m_fCreateAsynchLogFile );
		
		if ( m_pfapiJetTmpLog )
			{
			CallS( m_pfapiJetTmpLog->ErrIOIssue() );
			}
		m_asigCreateAsynchIOCompleted.Wait();
		delete m_pfapiJetTmpLog;
		m_pfapiJetTmpLog = NULL;
		m_fCreateAsynchResUsed = fFalse;
		m_errCreateAsynch = JET_errSuccess;
		m_ibJetTmpLog = 0;
		m_lgposCreateAsynchTrigger = lgposMax;
		}
	}	


//  ================================================================
VOID LOG::CheckForGenerationOverflow()
//  ================================================================
	{
	//	generate error on log generation number roll over
	
	Assert( lGenerationMax < lGenerationMaxDuringRecovery );
	const LONG	lGenMax = ( m_fRecovering ? lGenerationMaxDuringRecovery : lGenerationMax );
	if ( m_plgfilehdr->lgfilehdr.le_lGeneration >= lGenMax )
		{
		//	we should never hit this during recovery because we allocated extra log generations
		//	if we do hit this, it means we need to reserve MORE generations!

		Assert( !m_fRecovering );

		//	enter "log sequence end" mode where we prevent all operations except things like rollback/term
		//	NOTE: we allow the new generation to be created so we can use it to make a clean shutdown

		m_critLGResFiles.Enter();
		m_fLogSequenceEnd = fTrue;
		m_critLGResFiles.Leave();
		}
	}


//  ================================================================
VOID LOG::CheckLgposCreateAsyncTrigger()
//  ================================================================
//
//	It is possible that m_lgposCreateAsynchTrigger != lgposMax if
//	edbtmp.log hasn't been completely formatted (the last I/O that
//	completed properly set the trigger). This will prevent
//	anyone from trying to wait for the signal since the trigger will
//	be lgpos infinity. Note that in this situation it is ok to read
//	m_lgposCreateAsynchTrigger outside of m_critLGBuf since no
//	one else can write to it (we're in m_critLGFlush which
//	prevents this function from writing to it, and any outstanding
//	I/O has completed so it won't write).
//
//-
	{
	if ( CmpLgpos( lgposMax, m_lgposCreateAsynchTrigger ) )
		{
		m_critLGBuf.Enter();
		m_lgposCreateAsynchTrigger = lgposMax;
		m_critLGBuf.Leave();
		}
	}


//  ================================================================
VOID LOG::InitLgfilehdrT()
//  ================================================================
	{
	m_plgfilehdrT->lgfilehdr.le_ulMajor		= ulLGVersionMajor;
	m_plgfilehdrT->lgfilehdr.le_ulMinor		= ulLGVersionMinor;
	m_plgfilehdrT->lgfilehdr.le_ulUpdate	= ulLGVersionUpdate;

	m_plgfilehdrT->lgfilehdr.le_cbSec		= USHORT( m_cbSec );
	m_plgfilehdrT->lgfilehdr.le_csecHeader	= USHORT( m_csecHeader );
	m_plgfilehdrT->lgfilehdr.le_csecLGFile	= USHORT( m_csecLGFile );

	m_plgfilehdrT->lgfilehdr.le_cbPageSize = USHORT( g_cbPage );	
	}


//  ================================================================
VOID LOG::SetFLGFlagsInLgfilehdrT( const BOOL fResUsed )
//  ================================================================
	{
	m_plgfilehdrT->lgfilehdr.fLGFlags = 0;
	m_plgfilehdrT->lgfilehdr.fLGFlags |= fResUsed ? fLGReservedLog : 0;
	m_plgfilehdrT->lgfilehdr.fLGFlags |= m_fLGCircularLogging ? fLGCircularLoggingCurrent : 0;
	//	Note that we check the current log file header for circular logging currently or in the past
	m_plgfilehdrT->lgfilehdr.fLGFlags |= ( m_plgfilehdr->lgfilehdr.fLGFlags & ( fLGCircularLoggingCurrent | fLGCircularLoggingHistory ) ) ? fLGCircularLoggingHistory : 0;
	}


//  ================================================================
VOID LOG::AdvanceLgposToFlushToNewGen( const LONG lGeneration )
//  ================================================================
	{
	m_lgposToFlush.lGeneration = lGeneration;
	m_lgposToFlush.isec = (WORD) m_csecHeader;
	m_lgposToFlush.ib = 0;
	}


//  ================================================================
VOID LOG::GetSignatureInLgfilehdrT( IFileSystemAPI * const pfsapi )
//  ================================================================
//
//	This is the first logfile in the series (generation 1). Generate
//	a new signature
//
//-
	{
	Assert( 1 == m_plgfilehdrT->lgfilehdr.le_lGeneration );
	
	SIGGetSignature( &m_plgfilehdrT->lgfilehdr.signLog );

	//	first generation, set checkpoint
	
	m_pcheckpoint->checkpoint.le_lgposCheckpoint.le_lGeneration = m_plgfilehdrT->lgfilehdr.le_lGeneration;
	m_pcheckpoint->checkpoint.le_lgposCheckpoint.le_isec = (WORD) m_csecHeader;
	m_pcheckpoint->checkpoint.le_lgposCheckpoint.le_ib = 0;
	cLGCheckpoint.Set( m_pinst, CbOffsetLgpos( m_pcheckpoint->checkpoint.le_lgposCheckpoint, lgposMin ) );
	m_pcheckpoint->checkpoint.signLog = m_plgfilehdrT->lgfilehdr.signLog;
	
	//	update checkpoint file before write log file header to make the
	//	attachment information in check point will be consistent with
	//	the newly generated log file.
	
	(VOID) ErrLGUpdateCheckpointFile( pfsapi, fFalse );
	}


//  ================================================================
VOID LOG::SetSignatureInLgfilehdrT( IFileSystemAPI * const pfsapi )
//  ================================================================
//
//	Set the signature in the new logfile header
//	If this is the first logfile (generation 1) this will generate a new signature
//
//-
	{
	if ( 1 == m_plgfilehdrT->lgfilehdr.le_lGeneration )
		{
		GetSignatureInLgfilehdrT( pfsapi );
		}
	else
		{
		Assert( m_fSignLogSet );
		m_plgfilehdrT->lgfilehdr.signLog = m_signLog;
		}
	}


//  ================================================================
ERR LOG::ErrOpenTempLogFile(
	IFileSystemAPI * const 	pfsapi,
	IFileAPI ** const 		ppfapi,
	const CHAR * const 		szPathJetTmpLog,
	BOOL * const 			pfResUsed,
	QWORD * const 			pibPattern )
//  ================================================================
//
//	Open a temporary logfile. This involves either:
//		- waiting for the background thread to create the logfile
//		- opening/creating the file conventionally
//
//-
	{	
	ERR err = JET_errSuccess;

	if ( ( m_errCreateAsynch < JET_errSuccess ) || m_pfapiJetTmpLog )
		{
		CAAssert( m_fCreateAsynchLogFile );
		
		//	Wait for any outstanding IO to complete

		if ( m_pfapiJetTmpLog )
			{
			CallS( m_pfapiJetTmpLog->ErrIOIssue() );
			}
		m_asigCreateAsynchIOCompleted.Wait();
		
		*ppfapi 	= m_pfapiJetTmpLog;
		*pfResUsed 	= m_fCreateAsynchResUsed;

		//	If there was an error, leave *pibPattern to default so we don't
		//	accidentally use the wrong value for the wrong file. Scenario:
		//	some new developer modifies some code below that opens up
		//	a different file, yet leaves *pibPattern set to the previous
		//	high-water mark from the previous file we're err'ing out on.
		//
		if ( m_errCreateAsynch >= JET_errSuccess )
			{
			*pibPattern	= m_ibJetTmpLog;
			}
		
		err 		= m_errCreateAsynch;
		
		m_pfapiJetTmpLog 		= NULL;
		m_fCreateAsynchResUsed 	= fFalse;
		m_errCreateAsynch 		= JET_errSuccess;
		m_ibJetTmpLog 			= 0;

		CheckLgposCreateAsyncTrigger();

		if ( JET_errDiskFull == err && ! *pfResUsed )
			{
			CAAssert( JET_errDiskFull == err );
			CAAssert( ! *pfResUsed );
						
			delete *ppfapi;
			*ppfapi = NULL;

			//	Upon disk full from asynchronous log file creation, there must
			//	be an edbtmp.log at this point because any creation errors
			//	during asynch creation would have caused the reserves to
			//	be tried. And if the reserves have been tried, we can't be
			//	in this code path.
			
			Call( pfsapi->ErrFileDelete( szPathJetTmpLog ) );

			Call( ErrLGIOpenReserveLogFile( pfsapi, ppfapi, szPathJetTmpLog ) );
			*pfResUsed = fTrue;
			}
		else
			{
			Call( err );
			}
		}
	else
		{
		Call( ErrLGIOpenTempLogFile( pfsapi, ppfapi, szPathJetTmpLog, pfResUsed ) );
		}
		
	CAAssert( *ppfapi );
	CAAssert( !m_asigCreateAsynchIOCompleted.FTryWait() );

HandleError:
	return err;
	}

//  ================================================================
ERR LOG::ErrFormatLogFile(
	IFileSystemAPI * const 	pfsapi,
	IFileAPI ** const 		ppfapi,
	const CHAR * const 		szPathJetTmpLog,
	BOOL * const 			pfResUsed,
	const QWORD& 			cbLGFile,
	const QWORD& 			ibPattern )
//  ================================================================
//
//	Synchronously fill the rest of the file.
//
//	If we run out of space on the disk when making a new log file or
//	reusing an archived log file (which might be a different size than
//	our current log files, I believe), then we should delete the file we're
//	trying to write to (which may free up some more space in the case
//	of extending an archived log file).
//
//	Complete formatting synchronously if it hasn't completed and truncate
//	log file to correct size if necessary
//
//-
	{
	ERR err = JET_errSuccess;
	
	err = ErrUtilFormatLogFile( *ppfapi, cbLGFile, ibPattern );
	if ( JET_errDiskFull == err && ! *pfResUsed )
		{
		delete *ppfapi;
		*ppfapi = NULL;

		//	If we can't delete the current edbtmp.log, we are in a bad place.
		
		Call( pfsapi->ErrFileDelete( szPathJetTmpLog ) );

		Call( ErrLGIOpenReserveLogFile( pfsapi, ppfapi, szPathJetTmpLog ) );
		*pfResUsed = fTrue;

		//	If we are unable to fill/extend the reserved log file, we've
		//	made all attempts to make a new log file.
		Call( ErrUtilFormatLogFile( *ppfapi, cbLGFile ) );
		}
	else
		{
		Call( err );
		}

HandleError:
	return err;
	}


//  ================================================================
VOID LOG::InitPlrckChecksumExistingLogfile(
	const LOGTIME& 			tmOldLog,
	LRCHECKSUM ** const 	pplrck )
//  ================================================================
	{
	//	set position of first record
	
	Assert( m_lgposToFlush.lGeneration && m_lgposToFlush.isec );

	//	overhead contains one LRMS and one will-be-overwritten lrtypNOP
	
	Assert( m_pbEntry >= m_pbLGBufMin && m_pbEntry < m_pbLGBufMax );
	Assert( m_pbWrite >= m_pbLGBufMin && m_pbWrite < m_pbLGBufMax );

	// I think this is the case where we're being called from
	// ErrLGIWriteFullSectors() and the stuff before m_pbWrite has already
	// been written to the old log file. ErrLGILogRec() has reserved
	// space for this LRCHECKSUM that we're setting up here, and
	// other threads may be appending log records to the log buffer
	// right after this reserved space.
	//
	// This could also be the case when we're called during ErrLGRedoFill()
	// and that just setup m_pbWrite = m_pbEntry = m_pbLGBufMin.

	// sector aligned
	
	Assert( m_pbWrite < m_pbLGBufMax );
	Assert( PbSecAligned( m_pbWrite ) == m_pbWrite );
	*pplrck = reinterpret_cast< LRCHECKSUM* >( m_pbWrite );

	// In the first case (from the comment above), this will already be setup
	
	m_pbLastChecksum = m_pbWrite;

	m_plgfilehdrT->lgfilehdr.tmPrevGen = tmOldLog;
	}	


//  ================================================================
VOID LOG::InitPlrckChecksumNewLogfile( LRCHECKSUM ** const pplrck )
//  ================================================================
	{		
	//	no currently valid logfile initialize checkpoint to start of file
	// This is the case when we're called from ErrLGSoftStart().
	// Append to log buffer after an initial LRCHECKSUM record.
	
	m_pbEntry = m_pbLGBufMin + sizeof( LRCHECKSUM );
	m_pbWrite = m_pbLGBufMin;

	*pplrck = reinterpret_cast< LRCHECKSUM* >( m_pbLGBufMin );

	m_pbLastChecksum = m_pbLGBufMin;
	}
	

//  ================================================================
VOID LOG::InitPlrckChecksum(
	const LOGTIME& tmOldLog,
	const BOOL fLGFlags,
	LRCHECKSUM ** const pplrck )
//  ================================================================
//
//	set lgfilehdr and m_pbLastMSFlush and m_lgposLastMSFlush.
//
//-
	{
	if ( fLGFlags == fLGOldLogExists || fLGFlags == fLGOldLogInBackup )
		{
		InitPlrckChecksumExistingLogfile( tmOldLog, pplrck );		
		}
	else
		{
		InitPlrckChecksumNewLogfile( pplrck );		
		}

	memset( reinterpret_cast< BYTE* >( *pplrck ), 0, sizeof( LRCHECKSUM ) );
	(*pplrck)->lrtyp = lrtypChecksum;
	
	if ( !COSMemoryMap::FCanMultiMap() )
		{
		*(LRCHECKSUM*)(m_pbWrite + m_cbLGBuf) = **pplrck;
		}		
	}


//  ================================================================
ERR LOG::ErrWriteLrck(
	IFileAPI * const 		pfapi,
	LRCHECKSUM * const 		plrck,
	const BOOL				fLogAttachments )
//  ================================================================
//
//  Write down the single "empty" LRCK to disk to signify at correct log file.
//
//-
	{
	ERR err = JET_errSuccess;
	
	Assert( pNil != plrck );
	Assert( lrtypChecksum == plrck->lrtyp );
	
	plrck->bUseShortChecksum = bShortChecksumOff;
	plrck->le_ulShortChecksum = 0;
	plrck->le_ulChecksum = UlComputeChecksum( plrck, m_plgfilehdrT->lgfilehdr.le_lGeneration );

	if ( !COSMemoryMap::FCanMultiMap() )
		{
		*(LRCHECKSUM*)(m_pbWrite + m_cbLGBuf) = *plrck;
		}

#ifdef UNLIMITED_DB
	if ( fLogAttachments )
		{
		Assert( !m_fLGNeedToLogDbList );

		Call( ErrLGLoadDbListFromFMP_() );

		//	force logging of attachments next time a new log record is buffered
		//	don't need critLGBuf here because we are in the non-concurrent logging case
		m_fLGNeedToLogDbList = fTrue;
		}
	else
		{

		//	this is the case where we are concurrently logging to the buffer while creating a new log file
		//	ErrLGILogRec should have setup the database attachments log record already (if there were any)
		//	UNDONE: may go off on RecoveryUndo if it is the first record in the log file
		Assert( m_pbEntry == m_pbWrite + sizeof(LRCHECKSUM)
			|| lrtypDbList == ( (LR*)( m_pbWrite + sizeof( LRCHECKSUM ) ) )->lrtyp );
		}
#endif	//	UNLIMITED_DB

	//	the log sector sizes must match (mismatch cases should prevent us from
	//		getting to this codepath)

	Assert( m_cbSecVolume == m_cbSec );

	//	write the first log record and its shadow

	err = pfapi->ErrIOWrite( m_csecHeader * m_cbSec, m_cbSec, m_pbWrite );
	if ( err < 0 )
		{
		//	report errors and disable the log
		LGReportError( LOG_FILE_SYS_ERROR_ID, err, pfapi );

		err = ErrERRCheck( JET_errLogWriteFail );
		LGReportError( LOG_WRITE_ERROR_ID, err, pfapi );

		m_fLGNoMoreLogWrite = fTrue;
		goto HandleError;
		}

	//	update performance counters

	cLGWrite.Inc( m_pinst );
	cLGBytesWritten.Add( m_pinst, m_cbSec );

	//	ulShortChecksum does not change for the shadow sector
	
	plrck->le_ulChecksum = UlComputeShadowChecksum( plrck->le_ulChecksum );
	
	//	write the shadow sector

	err = pfapi->ErrIOWrite( ( m_csecHeader + 1 ) * m_cbSec, m_cbSec, m_pbWrite );
 	if ( err < 0 )
		{
		//	report errors and disable the log
		LGReportError( LOG_FILE_SYS_ERROR_ID, err, pfapi );

		err = ErrERRCheck( JET_errLogWriteFail );
		LGReportError( LOG_WRITE_ERROR_ID, err, pfapi );

		m_fLGNoMoreLogWrite = fTrue;
		goto HandleError;
		}

	//	update performance counters

	cLGWrite.Inc( m_pinst );
	cLGBytesWritten.Add( m_pinst, m_cbSec );

	Assert( m_critLGFlush.FOwner() );
	m_fHaveShadow = fTrue;

HandleError:
	return err;
	}


//  ================================================================
ERR LOG::ErrStartAsyncLogFileCreation(
	IFileSystemAPI * const 	pfsapi,
	const CHAR * const 		szPathJetTmpLog )
//  ================================================================
//
//	Start working on preparing edbtmp.log by opening up the file and
//	setting the trigger for the first I/O. Note that we will only do
//	asynch creation if we can extend the log file with arbitrarily big
//	enough I/Os.
//
//-
	{
	if ( m_fCreateAsynchLogFile && cbLogExtendPattern >= 1024 * 1024 )
		{
		CAAssert( !m_pfapiJetTmpLog );
		CAAssert( !m_fCreateAsynchResUsed );
		CAAssert( !m_ibJetTmpLog );
		CAAssert( JET_errSuccess == m_errCreateAsynch );
		CAAssert( !m_asigCreateAsynchIOCompleted.FTryWait() );
		CAAssert( 0 == m_ibJetTmpLog );

		//	Treat an error in opening like an error in an asynch I/O
		//	(except for the fact that m_pfapiJetTmpLog == NULL which
		//	isn't true in the case of an asynch I/O error).
		
		m_errCreateAsynch = ErrLGIOpenTempLogFile(
								pfsapi,
								&m_pfapiJetTmpLog,
								szPathJetTmpLog,
								&m_fCreateAsynchResUsed );
				
		if ( m_errCreateAsynch >= JET_errSuccess )
			{
			//	Configure trigger to cause first formatting I/O when a half
			//	chunk of log buffer has been filled. This is because we don't
			//	want to consume the log disk with our edbtmp.log I/O since
			//	it's pretty likely that someone is waiting for a log flush to
			//	edb.log right now (especially since we've been spending our
			//	time finishing formatting, renaming files, etc.).
			
			m_critLGBuf.Enter();
			LGPOS	lgpos = { 0, 0, m_plgfilehdr->lgfilehdr.le_lGeneration };
			AddLgpos( &lgpos, CbLGICreateAsynchIOSize() / 2 );
			m_lgposCreateAsynchTrigger = lgpos;
			m_critLGBuf.Leave();
			}

		m_asigCreateAsynchIOCompleted.Set();
		}

	return JET_errSuccess;		
	}


//  ================================================================
ERR LOG::ErrUpdateGenRequired( IFileSystemAPI * const pfsapi )
//  ================================================================
//
//	Update all the database headers with proper lGenMinRequired and lGenMaxRequired.
//
//-
	{
	LONG	lGenMinRequired;
	
	m_critCheckpoint.Enter();
	
	// Now disallow header update by other threads (log writer or checkpoint advancement)
	// 1. For the log writer it is OK to generate a new log w/o updating the header as no log operations
	// for this db will be logged in new logs <- THIS CASE
	// 2. For the checkpoint: don't advance the checkpoint if db's header weren't update 

	if ( m_fRecovering && m_fRecoveringMode == fRecoveringRedo )
		{
		// during recovery we don't update  the checkpoint  (or don't have it during hard recovery)
		// so we may have the current genMin in the header 
		// bigger than m_pcheckpoint->checkpoint.le_lgposCheckpoint.le_lGeneration
		// We want to keep the existing one so reset the new genMin
		lGenMinRequired = 0;
		}
	else
		{
		lGenMinRequired = m_pcheckpoint->checkpoint.le_lgposCheckpoint.le_lGeneration;
		}
		
	const ERR err = ErrLGIUpdateGenRequired(
			pfsapi,
			lGenMinRequired,
			m_plgfilehdrT->lgfilehdr.le_lGeneration,
			m_plgfilehdrT->lgfilehdr.tmCreate,
			NULL );
	m_critCheckpoint.Leave();

	return err;
	}


//  ================================================================
ERR LOG::ErrRenameTmpLog(
	IFileSystemAPI * const 	pfsapi,
	const CHAR * const 		szPathJetTmpLog,
	const CHAR * const		szPathJetLog )
//  ================================================================
//
//	Rename szJetTmpLog
//	Start the async creation of a new temporary logfile
//	Update lGenMin/MaxRequired in database headers
//
//-
	{
	ERR err = JET_errSuccess;
	
	//	rename szJetTmpLog to szJetLog, and open it as szJetLog
	//	i.e. edbtmp.log => edb.log
	
	Call( pfsapi->ErrFileMove( szPathJetTmpLog, szPathJetLog ) );

	//  FILESYSTEM STATE: edb.log [archive files including edb00001.log]

	Call( ErrStartAsyncLogFileCreation( pfsapi, szPathJetTmpLog ) );

	//	update all the database headers with proper lGenMinRequired and lGenMaxRequired.
	
	Call( ErrUpdateGenRequired( pfsapi ) );

HandleError:
	return err;
	}


//  ================================================================
ERR LOG::ErrLGStartNewLogFile(
	IFileSystemAPI* const	pfsapi,
	const LONG				lgenToClose,
	BOOL					fLGFlags
	)
//  ================================================================
//
//	Begin the creation of a new logfile. This leaves us with 
//	EDBTMP.LOG and [archived logs]
//
//-
	{
	ERR				err			= JET_errSuccess;
	CHAR  			szPathJetLog[ IFileSystemAPI::cchPathMax ];
	CHAR  			szPathJetTmpLog[ IFileSystemAPI::cchPathMax ];
	CHAR			szArchivePath[ IFileSystemAPI::cchPathMax ];	// generational name of current log file if any
	CHAR			szFNameT[ IFileSystemAPI::cchPathMax ];
	LOGTIME			tmOldLog;
	IFileAPI*		pfapi		= NULL;
	LRCHECKSUM*		plrck		= pNil;
	BOOL			fResUsed	= fFalse;
	const QWORD		cbLGFile	= QWORD( m_csecLGFile ) * m_cbSec;
	QWORD			ibPattern	= 0;
	BOOL			fLogAttachments		= ( fLGFlags & fLGLogAttachments );

	//	all other flags are mutually exclusive, so filter out this flag
	fLGFlags &= ~fLGLogAttachments;

	Assert( 0 == fLGFlags
		|| fLGOldLogExists == fLGFlags
		|| fLGOldLogNotExists == fLGFlags
		|| fLGOldLogInBackup == fLGFlags );

	Assert( m_critLGFlush.FOwner() );

	CheckForGenerationOverflow();
	
	LGMakeLogName( szPathJetLog, m_szJet );
	LGMakeLogName( szPathJetTmpLog, m_szJetTmp );

	Call( ErrOpenTempLogFile(
			pfsapi,
			&pfapi,
			szPathJetTmpLog,
			&fResUsed,
			&ibPattern ) );
			
	Call( ErrFormatLogFile(
			pfsapi,
			&pfapi,
			szPathJetTmpLog,
			&fResUsed,
			cbLGFile,
			ibPattern ) );
		
	if ( fLGFlags != fLGOldLogExists && fLGFlags != fLGOldLogInBackup )
		{
		//	reset file header

		memset( m_plgfilehdr, 0, sizeof( LGFILEHDR ) );
		}
	else
		{
		// there was a previous szJetLog file, close it and
		// create an archive name for it, do not rename it yet.
		
		tmOldLog = m_plgfilehdr->lgfilehdr.tmCreate;

		// Compute a generational-name for the current edb.log
		
		LGSzFromLogId( szFNameT, m_plgfilehdr->lgfilehdr.le_lGeneration );
		
		// Remember the current log file name as the generational-name
		
		LGMakeLogName( szArchivePath, szFNameT );
		}

	//	edbtmp.log is still open

	m_critLGBuf.Enter();

	//	initialize the checksum logrecord
	
	InitPlrckChecksum( tmOldLog, fLGFlags, &plrck );
		
	AdvanceLgposToFlushToNewGen( lgenToClose + 1 );
	
	CAAssert( 0 == CmpLgpos( lgposMax, m_lgposCreateAsynchTrigger ) );

	m_critLGBuf.Leave();

	//	initialize the new szJetTempLog file header
	//	write new header into edbtmp.log
	
	InitLgfilehdrT();
	m_plgfilehdrT->lgfilehdr.le_lGeneration = lgenToClose + 1;
	LGIGetDateTime( &m_plgfilehdrT->lgfilehdr.tmCreate );
	m_pinst->SaveDBMSParams( &m_plgfilehdrT->lgfilehdr.dbms_param );

#ifdef UNLIMITED_DB
#else
	LGLoadAttachmentsFromFMP( m_pinst, m_plgfilehdrT->rgbAttach );
#endif	

	SetSignatureInLgfilehdrT( pfsapi );
	SetFLGFlagsInLgfilehdrT( fResUsed );	
	m_plgfilehdrT->lgfilehdr.le_filetype = filetypeLG;

	Call( ErrLGWriteFileHdr( m_plgfilehdrT, pfapi ) );

	//	write the checksum record to the new logfile
	
	Call( ErrWriteLrck( pfapi, plrck, fLogAttachments ) );

	//	Close edb.log if it is open so it may be renamed to edbXXXXX.log
	
	delete m_pfapiLog;
	m_pfapiLog = NULL;

	// Notice that we do not do the rename if we're
	// restoring from backup since edb.log may not exist.
	// (the case where fLGFlags == fLGOldLogInBackup).
	
	if ( fLGFlags == fLGOldLogExists )
		{
		//  FILESYSTEM STATE: edb.log edbtmp.log [archive files]
		
		//	there was a previous szJetLog, rename it to its archive name
		//	i.e. edb.log => edb00001.log
		
		Call( pfsapi->ErrFileMove( szPathJetLog, szArchivePath ) );

		//  FILESYSTEM STATE: edbtmp.log [archive files including edb00001.log]
		}
	else
		{
		//  FILESYSTEM STATE: edbtmp.log [archive files]
		}

	//  FILESYSTEM STATE: edbtmp.log [archive files]

	//	Close edbtmp.log so it may be renamed to edb.log
	
HandleError:

	delete m_pfapiLog;
	m_pfapiLog = NULL;
	
	delete pfapi;
	pfapi = NULL;

	return err;
	}


//  ================================================================
ERR LOG::ErrLGFinishNewLogFile( IFileSystemAPI * const pfsapi )
//  ================================================================
//
//	When this is called we should have EDBTMP.LOG and [archived logs]
//	EDBTMP.LOG will be renamed to EDB.LOG
//
//-
	{
	ERR				err			= JET_errSuccess;
	CHAR  			szPathJetLog[ IFileSystemAPI::cchPathMax ];
	CHAR  			szPathJetTmpLog[ IFileSystemAPI::cchPathMax ];

	Assert( m_critLGFlush.FOwner() );
	
	LGMakeLogName( szPathJetLog, m_szJet );
	LGMakeLogName( szPathJetTmpLog, m_szJetTmp );

	Call( ErrRenameTmpLog( pfsapi, szPathJetTmpLog, szPathJetLog ) );

HandleError:
	return err;
	}


/*
 *	Closes current log generation file, creates and initializes new
 *	log generation file in a safe manner.
 *	create new log file	under temporary name
 *	close active log file (if fLGFlags is fTrue)
 *	rename active log file to archive name numbered log (if fOld is fTrue)
 *	close new log file (still under temporary name)
 *	rename new log file to active log file name
 *	open new active log file with ++lGenerationToClose
 *
 *	PARAMETERS	plgfilehdr		pointer to log file header
 *				lGeneration 	current generation being closed
 *				fOld			TRUE if a current log file needs closing
 *
 *	RETURNS		JET_errSuccess, or error code from failing routine
 *
 *	COMMENTS	Active log file must be completed before new log file is
 *				called. Log file will not be opened upon completion.
 */
ERR LOG::ErrLGNewLogFile(
	IFileSystemAPI* const	pfsapi,
	const LONG				lgenToClose,
	BOOL					fLGFlags
	)
	{
	ERR						err;
	
	Call( ErrLGStartNewLogFile( pfsapi, lgenToClose, fLGFlags ) );
	Call( ErrLGFinishNewLogFile( pfsapi ) );

HandleError:
	if ( JET_errDiskFull == err )
		{
		err = ErrERRCheck( JET_errLogDiskFull );
		}
	
	if ( err < 0 )
		{
		UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, NEW_LOG_ERROR_ID, err );
		m_fLGNoMoreLogWrite = fTrue;
		}
	else
		{
		m_fLGNoMoreLogWrite = fFalse;
		}
	
	return err;
	}


// There are certain possible situations where we just finished reading a
// finished log file (never to be written to again) and it is either
// named edb.log or edbXXXXX.log (generational or archive name). We want to
// make ensure that it gets renamed to an archive name if necessary, and then
// a new log file is created as edb.log that we switch to.

 ERR LOG::ErrLGISwitchToNewLogFile( IFileSystemAPI *const pfsapi, BOOL fLGFlags )
	{
	// special case where the current log file has ended, so we need
	// to create a new log file and write to that instead.
	// Only need to do the switch when we notice that the current log generation
	// is different from the flush point generation
	Assert( pNil != m_plgfilehdr );
	
	if ( m_plgfilehdr->lgfilehdr.le_lGeneration != m_lgposToFlush.lGeneration )
		{
		// If this fires, we probably picked up some other horrible special case or
		// impossible condition. 
		Assert( m_lgposToFlush.lGeneration == m_plgfilehdr->lgfilehdr.le_lGeneration + 1 );

		// There must be a log file open from just calling ErrLGCheckReadLastLogRecord()
		Assert( m_pfapiLog );
		
		ERR			err			= JET_errSuccess;
		CHAR  		szPathJetLog[IFileSystemAPI::cchPathMax];

		// edb.log
		LGMakeLogName( szPathJetLog, m_szJet );
		
		m_critLGFlush.Enter();

		err = ErrUtilPathExists( pfsapi, szPathJetLog );
		if ( err < 0 )
			{
			if ( JET_errFileNotFound == err )
				{
				// edb.log does not exist, so don't try to rename a nonexistant
				// file from edb.log to generational name
				// Some kind of log file is open, so it must be a generational name
				fLGFlags |= fLGOldLogInBackup;
				// close log file because ErrLGNewLogFile( fLGOldLogInBackup ) does not
				// expect an open log file.
				delete m_pfapiLog;
				m_pfapiLog = NULL;
				}
			else
				{
				// other unexpected error
				Call( err );
				}
			}
		else
			{
			// edb.log does exist, so we want it renamed to generational name
			fLGFlags |= fLGOldLogExists;
			// generational archive named log file is still open, but ErrLGNewLogFile
			// will close it and rename it
			}

		Call( ErrLGNewLogFile( pfsapi, m_plgfilehdr->lgfilehdr.le_lGeneration, fLGFlags ) );
		LGMakeLogName( m_szLogName, m_szJet );
		Call( pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog ) );

		m_critLGBuf.Enter();	// <----------------------------

		Assert( m_plgfilehdrT->lgfilehdr.le_lGeneration == m_plgfilehdr->lgfilehdr.le_lGeneration + 1 );
		UtilMemCpy( m_plgfilehdr, m_plgfilehdrT, sizeof( LGFILEHDR ) );
		m_isecWrite = m_csecHeader;
		m_pbLGFileEnd = pbNil;
		m_isecLGFileEnd = 0;

		m_critLGBuf.Leave();	// <----------------------------

HandleError:
		m_critLGFlush.Leave();

		return err;
		}
	return JET_errSuccess;
	}

/*
 *	Log flush thread is signalled to flush log asynchronously when at least
 *	cThreshold disk sectors have been filled since last flush.
 */

VOID LOG::LGFlushLog( const DWORD_PTR dwThreadContext, const DWORD fCalledFromFlushAll, const DWORD_PTR dwThis )
	{
	LOG *plog = (LOG *)dwThis;
#ifdef DEBUG
	plog->m_dwDBGLogThreadId = DwUtilThreadId();
#endif

	int iGroup = plog->m_msLGTaskExec.Enter();

	//	we succeeded to post the flush task.
	//	If we were failed before, decrement the number of failed tasks
	if ( AtomicExchange( (LONG *)&plog->m_fLGFailedToPostFlushTask, fFalse ) )
		{
		const LONG	lCount	= AtomicDecrement( (LONG *)&m_cLGFailedToPost );
		Assert( lCount >= 0 );
		}

	plog->m_critLGFlush.Enter();

	LONG lStatus = AtomicCompareExchange( (LONG *)&plog->m_fLGFlushWait, 1, 0 );

	//	if we have shutdown request
	//	notify the client that we're almost done

	if ( 2 == lStatus )
		{
		plog->m_asigLogFlushDone.Set();
		}
	else
		{
		Assert( 1 == lStatus );
		}
		
	//  try to flush the log

	const BOOL fLogDownBeforeFlush = plog->m_fLGNoMoreLogWrite;
	(void)plog->ErrLGIFlushLog( plog->m_pinst->m_pfsapi );
	const BOOL fLogDownAfterFlush = plog->m_fLGNoMoreLogWrite;

	plog->m_critLGFlush.Leave();

	//  if the log just went down for whatever reason, report it

	if ( !fLogDownBeforeFlush && fLogDownAfterFlush )
		{
		const _TCHAR*	rgpsz[ 1 ];
		DWORD			irgpsz		= 0;
		_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];

		if ( plog->m_pinst->m_pfsapi->ErrPathComplete( plog->m_szLogFilePath, szAbsPath ) < JET_errSuccess )
			{
			_tcscpy( szAbsPath, plog->m_szLogFilePath );
			}

		rgpsz[ irgpsz++ ]	= szAbsPath;

		UtilReportEvent(	eventError,
							LOGGING_RECOVERY_CATEGORY,
							LOG_DOWN_ID,
							irgpsz,
							rgpsz );
		}

	plog->m_msLGTaskExec.Leave( iGroup );

	//	if LGFlush is not called from LGFlushAllLogs 
	//	then do the flush all check
	if ( !fCalledFromFlushAll )
		{
		//	if there are any logs that are waiting to be flushed
		//	use current thread to flush them
		LGFlushAllLogs( 0, fTrue, 0 );
		}
	}

LONG volatile LOG::m_cLGFailedToPost	= 0;
LONG volatile LOG::m_fLGInFlushAllLogs	= fFalse;

VOID LOG::LGFlushAllLogs(
	const DWORD_PTR,					// ignored
	const DWORD fAfterFlushCheck,		// true if it is clean up check after regular log flush, false if it is thread timeout
	const DWORD_PTR )					// ignored
	{
	//	nothing to do?
	if ( 0 == m_cLGFailedToPost )
		{
		return;
		}

	//	try to enter flush all logs crit section
	if ( !AtomicCompareExchange( (LONG *)&m_fLGInFlushAllLogs, fFalse, fTrue ) )
		{
		//	loop check through all the instances
		for ( int ipinst = 0; ipinst < ipinstMax && 0 < m_cLGFailedToPost; ipinst++ )
			{
			//	lock the instance
			extern CRITPOOL< INST* > critpoolPinstAPI;
			CCriticalSection *pcritInst = &critpoolPinstAPI.Crit(&g_rgpinst[ ipinst ]);
			pcritInst->Enter();
			INST *pinst;
			pinst = g_rgpinst[ ipinst ];
			if ( NULL != pinst && pinst->m_fJetInitialized )
				{
				//	if it is waiting to be flushed or is time to flush all the logs flush it
				//	try to enter flush mode
				if ( ( pinst->m_plog->m_fLGFailedToPostFlushTask )
					&& 0 == AtomicCompareExchange( (LONG *)&(pinst->m_plog->m_fLGFlushWait), 0, 1 ) )
					{
					LGFlushLog( 0, fTrue, (DWORD_PTR)(pinst->m_plog) );
					}
				}
			pcritInst->Leave();
			}
			
		//	leave flush all logs critical section
		AtomicExchange( (LONG *)&m_fLGInFlushAllLogs, fFalse );
		}
	}

// Given a pointer into the log buffer and the size of a block
// we want to fit on a single sector, tell us where we should
// put the block.
BYTE* LOG::PbGetSectorContiguous( BYTE* pb, size_t cb )
	{
	Assert( pb >= m_pbLGBufMin && pb < m_pbLGBufMax );
	// If you're going to use this to get space as big as a sector,
	// please review the code.
	Assert( cb > 0 && cb < m_cbSec );
	
	INT		cbToFill = ( m_cbSec * 2 - ULONG( pb - PbSecAligned( pb ) ) ) % m_cbSec;
	
	if ( 0 == cbToFill )
		{
		// We're looking at a sector boundary right now.
		Assert( PbSecAligned( pb ) == pb );
		}
	else if ( cbToFill < cb )
		{
		// We need to fill cbToFill bytes with NOPs and
		// use the space after it.
		Assert( FIsFreeSpace( pb, cbToFill ) );
		pb += cbToFill;
		Assert( pb >= ( m_pbLGBufMin + m_cbSec ) && pb <= m_pbLGBufMax );
		Assert( PbSecAligned( pb ) == pb );
		if ( pb == m_pbLGBufMax )
			{
			pb = m_pbLGBufMin;
			}
		Assert( pb >= m_pbLGBufMin && pb < m_pbLGBufMax );
		// This requires the use of another sector.
		}
	else if ( cbToFill == cb )
		{
		// We've got just the perfect amount of space.
		}
	else
		{
		// We've got plenty of space already
		}
	Assert( FIsFreeSpace( pb, ULONG( cb ) ) );
	return pb;
	}

//	XXX
//	If you modify this function, be sure to modify the class VERIFYCHECKSUM, especially
//	ErrVerifyLRCKStart.

ULONG32 LOG::UlComputeChecksum( const LRCHECKSUM* const plrck, const ULONG32 lGeneration )
	{
	ULONG32 ulChecksum = ulLRCKChecksumSeed;
	const BYTE*	pb = pbNil;
	Assert( NULL != plrck );
	const BYTE*	pbEnd = pbNil;

	// Takes advantage of VM wrap-around

	Assert( reinterpret_cast< const BYTE* >( plrck ) >= m_pbLGBufMin &&
		reinterpret_cast< const BYTE* >( plrck ) < m_pbLGBufMax );

	pb = reinterpret_cast< const BYTE* >( plrck ) - plrck->le_cbBackwards;
	pbEnd = reinterpret_cast< const BYTE* >( plrck );
	
	Assert( pb >= m_pbLGBufMin && pb < m_pbLGBufMax );
	Assert( pbEnd >= m_pbLGBufMin && pbEnd < m_pbLGBufMax );

	Assert( ( pbEnd - pb == 0 ) ? fTrue : FIsUsedSpace( pb, ULONG( pbEnd - pb ) ) );
	Assert( pbEnd >= pb );

	//	checksum the "backward" range
	ulChecksum = UlChecksumBytes( pb, pbEnd, ulChecksum );

 	pb = reinterpret_cast< const BYTE* >( plrck ) + sizeof( *plrck );
	pbEnd = reinterpret_cast< const BYTE* >( plrck )
		+ sizeof( *plrck ) + plrck->le_cbForwards;

	// Stay in region of the 2 mappings
	Assert( pb >= ( m_pbLGBufMin + sizeof( *plrck ) ) );
	Assert( pb <= m_pbLGBufMax );
	Assert( pbEnd > m_pbLGBufMin && pbEnd <= ( m_pbLGBufMax + m_cbLGBuf ) );

	Assert( ( pbEnd - pb == 0 ) ? fTrue 
								: FIsUsedSpace( ( pb == m_pbLGBufMax )	? m_pbLGBufMin 
																		: pb, 
												ULONG( pbEnd - pb ) ) );
	Assert( pbEnd >= pb );

	//	checksum the "forward" range
	ulChecksum = UlChecksumBytes( pb, pbEnd, ulChecksum );

	//	checksum the backward/forward/next pointers
	ulChecksum ^= plrck->le_cbBackwards;
	ulChecksum ^= plrck->le_cbForwards;
	ulChecksum ^= plrck->le_cbNext;

	//	checksum the short checksum on/off byte
	Assert( plrck->bUseShortChecksum == bShortChecksumOn || 
			plrck->bUseShortChecksum == bShortChecksumOff );
	ulChecksum ^= (ULONG32)plrck->bUseShortChecksum;
	
	// The checksum includes the log generation number, so we can't
	// eat old log data from a previous generation and think that it is current data.
	ulChecksum ^= lGeneration;

	return ulChecksum;
	}


ULONG32 LOG::UlComputeShadowChecksum( const ULONG32 ulOriginalChecksum )
	{
	return ulOriginalChecksum ^ ulShadowSectorChecksum;
	}


ULONG32 LOG::UlComputeShortChecksum( const LRCHECKSUM* const plrck, const ULONG32 lGeneration )
	{
	ULONG32 ulChecksum = ulLRCKShortChecksumSeed;
	const BYTE*	pb = pbNil;
	Assert( NULL != plrck );
	const BYTE*	pbEnd = pbNil;

	Assert( reinterpret_cast< const BYTE* >( plrck ) >= m_pbLGBufMin &&
		reinterpret_cast< const BYTE* >( plrck ) < m_pbLGBufMax );

	pb = reinterpret_cast< const BYTE* >( plrck ) - plrck->le_cbBackwards;
	// the region should start on a sector boundary, or plrck->cbBackwards can be zero
	Assert( PbSecAligned( const_cast< BYTE* >( reinterpret_cast< const BYTE* >( plrck ) ) ) == pb || 0 == plrck->le_cbBackwards );
	pbEnd = reinterpret_cast< const BYTE* >( plrck );
	
	Assert( pb >= m_pbLGBufMin && pb < m_pbLGBufMax );
	Assert( pbEnd >= m_pbLGBufMin && pbEnd < m_pbLGBufMax );

	// Can't call without m_critLGBuf
//	Assert( pbEnd - pb == 0 ? fTrue : FIsUsedSpace( pb, pbEnd - pb ) );
	Assert( pbEnd >= pb );

	//	checksum the "backward" region
	ulChecksum = UlChecksumBytes( pb, pbEnd, ulChecksum );

 	pb = reinterpret_cast< const BYTE* >( plrck ) + sizeof( *plrck );
 	// end of short checksum region is the end of the sector.
	pbEnd = PbSecAligned( const_cast< BYTE* >( reinterpret_cast< const BYTE* >( plrck ) ) ) + m_cbSec;

	// Stay in region of the 2 mappings
	Assert( pb >= ( m_pbLGBufMin + sizeof( *plrck ) ) );
	Assert( pb <= m_pbLGBufMax );
	Assert( pbEnd > m_pbLGBufMin && pbEnd <= m_pbLGBufMax );

	// Can't call without m_critLGBuf
//	Assert( pbEnd - pb == 0 ? fTrue : FIsUsedSpace( 
//		( pb == m_pbLGBufMax ) ? m_pbLGBufMin : pb,
//		pbEnd - pb ) );
	Assert( pbEnd >= pb );
	
	//	checksum to the end of the sector (forward region and any garbage in there)
	ulChecksum = UlChecksumBytes( pb, pbEnd, ulChecksum );

	//	checksum the backward/forward/next pointers
	ulChecksum ^= plrck->le_cbBackwards;
	ulChecksum ^= plrck->le_cbForwards;
	ulChecksum ^= plrck->le_cbNext;

	//	checksum the short checksum on/off byte
	Assert( plrck->bUseShortChecksum == bShortChecksumOn || 
			plrck->bUseShortChecksum == bShortChecksumOff );
	ulChecksum ^= (ULONG32)plrck->bUseShortChecksum;
	
	// The checksum includes the log generation number, so we can't
	// eat old log data from a previous generation and think that it is current data.
	ulChecksum ^= lGeneration;

	return ulChecksum;
	}


// Setup the last LRCHECKSUM record in the log file.
// Extend its range to the end of the log file and calculate the checksum.

VOID LOG::SetupLastFileChecksum(
	BYTE* const pbLastChecksum,
	const BYTE* const pbEndOfData
	)
	{
	Assert( pbNil != pbLastChecksum );
	Assert( pbNil != pbEndOfData );
	// we should be sector aligned.
	Assert( PbSecAligned( const_cast< BYTE* >( pbEndOfData ) ) == pbEndOfData );
	LRCHECKSUM* const plrck = reinterpret_cast< LRCHECKSUM* const >( pbLastChecksum );
	// The sector with the last checksum should be the next sector to write out
	Assert( PbSecAligned( m_pbWrite ) == PbSecAligned( pbLastChecksum ) );

	Assert( FIsUsedSpace( pbLastChecksum, sizeof( LRCHECKSUM ) ) );

	// should already have type setup
	Assert( lrtypChecksum == plrck->lrtyp );
#ifdef DEBUG
	ULONG	cbOldForwards = plrck->le_cbForwards;
#endif
	plrck->le_cbForwards = ( pbEndOfData > pbLastChecksum ) ?
		( pbEndOfData - pbLastChecksum - sizeof( LRCHECKSUM ) ) :
		( pbEndOfData + m_cbLGBuf - pbLastChecksum - sizeof( LRCHECKSUM ) );
	Assert( plrck->le_cbForwards < m_cbLGBuf );
	// cbOldForwards could be the same if we were setup near the end of a log file.
	Assert( plrck->le_cbForwards >= cbOldForwards );
	// Last LRCHECKSUM should have cbNext == 0 to signify that it's range
	// is the last data in the log file.
	Assert( 0 == plrck->le_cbNext );
	// this range of data is for the current log generation.

	//	this may be a single-sector range (old checksum is 1 sector behind new checksum)
	//		or a multi-sector range (old checksum is atleast 2 sectors behind old checksum)
	//	only use the short checksum if it is a multi-sector flush
	const ULONG32 cbBackwards = ULONG32( (BYTE*)plrck - PbSecAligned( (BYTE*)plrck ) );
	Assert( plrck->le_cbBackwards == cbBackwards || plrck->le_cbBackwards == 0 );
	if ( cbBackwards + sizeof( LRCHECKSUM ) + plrck->le_cbForwards > m_cbSec )
		{
		Assert( ( cbBackwards + sizeof( LRCHECKSUM ) + plrck->le_cbForwards ) >= ( m_cbSec * 2 ) );
		plrck->bUseShortChecksum = bShortChecksumOn;
		plrck->le_ulShortChecksum = UlComputeShortChecksum( plrck, m_plgfilehdr->lgfilehdr.le_lGeneration );
		}
	else
		{
		plrck->bUseShortChecksum = bShortChecksumOff;
		plrck->le_ulShortChecksum = 0;
		}		
	plrck->le_ulChecksum = UlComputeChecksum( plrck, m_plgfilehdr->lgfilehdr.le_lGeneration );
	if ( !COSMemoryMap::FCanMultiMap() )
		*(LRCHECKSUM*)(m_pbWrite + m_cbLGBuf) = *plrck;
	}

// Setup the last LRCHECKSUM record in the log buffer that will be written out soon.
VOID LOG::SetupLastChecksum(
	BYTE*	pbLastChecksum,
	BYTE*	pbEndOfData
	)
	{
	Assert( pbNil != pbLastChecksum );
	Assert( pbNil != pbEndOfData );
	LRCHECKSUM* const	plrck = reinterpret_cast< LRCHECKSUM* const >( pbLastChecksum );

	Assert( FIsUsedSpace( pbLastChecksum, sizeof( LRCHECKSUM ) ) );

	// plrck->lrtyp should have already been setup
	Assert( lrtypChecksum == plrck->lrtyp );
	// plrck->cbBackwards should already be setup

	//	assume a single-sector range (e.g. no short checksum)
	plrck->bUseShortChecksum = bShortChecksumOff;
	plrck->le_ulShortChecksum = 0;

	// If the LRCHECKSUM is on the same sector as the end of data,
	// we just extend the LRCHECKSUM's range to cover more data.
	if ( PbSecAligned( pbLastChecksum ) == PbSecAligned( pbEndOfData ) )
		{
		// If the last LRCHECKSUM is on the same sector as where we'd
		// hypothetically put the new LRCHECKSUM, just extend the region
		// of the last checksum
		Assert( pbEndOfData > pbLastChecksum );
#ifdef DEBUG
		const ULONG	cbOldForwards = plrck->le_cbForwards;
#endif
		Assert( pbLastChecksum + sizeof( LRCHECKSUM ) <= pbEndOfData );
		plrck->le_cbForwards = ULONG32( pbEndOfData - pbLastChecksum - sizeof( LRCHECKSUM ) );
		// We should only be enlarging (or keeping the same)
		// the range covered by the LRCHECKSUM
		Assert( plrck->le_cbForwards >= cbOldForwards );
		Assert( plrck->le_cbForwards < m_cbSec );

		// Since this LRCHECKSUM is the last in the buffer, and there won't
		// be one added, this should be zero.
		Assert( 0 == plrck->le_cbNext );
		}
	else
		{
		// If LRCHECKSUM records are on different sectors
		// then the range extends up to the sector boundary of the sector
		// containing the next LRCHECKSUM
		BYTE* pbNewAligned = PbSecAligned( pbEndOfData );
		ULONG cb;
		if ( pbNewAligned > pbLastChecksum )
			cb = ULONG( pbNewAligned - pbLastChecksum );
		else
			cb = ULONG( pbNewAligned + m_cbLGBuf - pbLastChecksum );
		plrck->le_cbForwards = cb - sizeof( LRCHECKSUM );		
		Assert( plrck->le_cbForwards < m_cbLGBuf );

		plrck->le_cbNext = ( ( pbEndOfData > pbLastChecksum ) ?
			pbEndOfData - pbLastChecksum :
			pbEndOfData + m_cbLGBuf - pbLastChecksum )
			- sizeof( LRCHECKSUM );

		//	this may be a single-sector range (old checksum is 1 sector behind new checksum)
		//		or a multi-sector range (old checksum is atleast 2 sectors behind old checksum)
		//	only use the short checksum if it is a multi-sector flush
		const ULONG32 cbBackwards = ULONG32( (BYTE*)plrck - PbSecAligned( (BYTE*)plrck ) );
		Assert( plrck->le_cbBackwards == cbBackwards || plrck->le_cbBackwards == 0 );
		if ( cbBackwards + sizeof( LRCHECKSUM ) + plrck->le_cbForwards > m_cbSec )
			{
			Assert( ( cbBackwards + sizeof( LRCHECKSUM ) + plrck->le_cbForwards ) >= ( m_cbSec * 2 ) );
			plrck->bUseShortChecksum = bShortChecksumOn;
			plrck->le_ulShortChecksum = UlComputeShortChecksum( plrck, m_plgfilehdr->lgfilehdr.le_lGeneration );
			}
		}

	Assert( plrck->le_cbNext < m_cbLGBuf );
	// This range of data is for this current log generation.
	plrck->le_ulChecksum = UlComputeChecksum( plrck, m_plgfilehdr->lgfilehdr.le_lGeneration );
	}

// After we know that there's space for a new LRCHECKSUM in the log buffer,
// add it.
BYTE* LOG::PbSetupNewChecksum(
	// where to add the LRCK
	BYTE*	pb,
	// location in log buffer of the last LRCHECKSUM before this one
	BYTE*	pbLastChecksum
	)
	{
	Assert( pbNil != pb );
	Assert( pbNil != pbLastChecksum );
	LRCHECKSUM	lrck;
	BYTE*		pbNew = pb;

	Assert( FIsUsedSpace( pbLastChecksum, sizeof( LRCHECKSUM ) ) );

	lrck.lrtyp = lrtypChecksum;
	// We shouldn't be setting up a new LRCHECKSUM record on
	// the same sector as the last LRCHECKSUM record.
	Assert( PbSecAligned( pb ) != PbSecAligned( pbLastChecksum ) );
	// Backwards range goes up to the beginning of the sector we're on.
	lrck.le_cbBackwards = ULONG32( pb - PbSecAligned( pb ) );
	lrck.le_cbForwards = 0;
	lrck.le_cbNext = 0;
	// Checksums will be calculated later.
	lrck.bUseShortChecksum = bShortChecksumOff;
	lrck.le_ulShortChecksum = 0;
	lrck.le_ulChecksum = 0;

	// Add this new LRCHECKSUM to the log buffer.
	Assert( FIsFreeSpace( pb, sizeof( LRCHECKSUM ) ) );
	LGIAddLogRec( reinterpret_cast< BYTE* >( &lrck ), sizeof( lrck ), &pbNew );
	return pbNew;
	}

// Returns fTrue if there are people waiting for log records to
// be flushed after *plgposToFlush

BOOL LOG::FWakeWaitingQueue( LGPOS * plgposToFlush )
	{
	/*  go through the waiting list and wake those whose log records
	/*  were flushed in this batch.
	/*
	/*  also wake all threads if the log has gone down
	/**/

	/*	wake it up!
	/**/
	m_critLGWaitQ.Enter();

	PIB *	ppibT				= m_ppibLGFlushQHead;
	BOOL	fWaitersExist		= fFalse;

	while ( ppibNil != ppibT )
		{
		//	WARNING: need to save off ppibNextWaitFlush
		//	pointer because once we release any waiter,
		//	the PIB may get released
		PIB	* const	ppibNext	= ppibT->ppibNextWaitFlush;

		// XXX
		// This should be < because the LGPOS we give clients to wait on
		// is the LGPOS of the start of the log record (the first byte of
		// the log record). When we flush, the flush LGPOS points to the
		// first byte of the log record that did *NOT* make it to disk.
		if ( CmpLgpos( &ppibT->lgposCommit0, plgposToFlush ) < 0 || m_fLGNoMoreLogWrite )
			{
			Assert( ppibT->FLGWaiting() );
			ppibT->ResetFLGWaiting();

			if ( ppibT->ppibPrevWaitFlush )
				{
				ppibT->ppibPrevWaitFlush->ppibNextWaitFlush = ppibT->ppibNextWaitFlush;
				}
			else
				{
				m_ppibLGFlushQHead = ppibT->ppibNextWaitFlush;
				}

			if ( ppibT->ppibNextWaitFlush )
				{
				ppibT->ppibNextWaitFlush->ppibPrevWaitFlush = ppibT->ppibPrevWaitFlush;
				}
			else
				{
				m_ppibLGFlushQTail = ppibT->ppibPrevWaitFlush;
				}

			//	WARNING: cannot reference ppibT after this point
			//	because once we free the waiter, the PIB may
			//	get released
			ppibT->asigWaitLogFlush.Set();
			cLGUsersWaiting.Dec( m_pinst );
			}
		else
			{
			fWaitersExist = fTrue;
			}

		ppibT = ppibNext;
		}

	m_critLGWaitQ.Leave();

	return fWaitersExist;
	}


#ifdef LOGPATCH_UNIT_TEST

enum EIOFAILURE
	{
	iofNone			= 0,
	iofClean		= 1,//	clean		-- crash after I/O completes
	//iofTornSmall	= 2,//	torn		-- last sector is torn (anything other than last sector being torn implies
	//iofTornLarge	= 3,//										that later sectors were never written and degrades
						//										to an incomplete-I/O case)
	iofIncomplete1	= 2,//	incomplete1	-- 1 sector was not flushed
	iofIncomplete2	= 3,//	incomplete2	-- 2 sectors were not flushed
	iofMax			= 4
	};

extern BOOL			g_fEnableFlushCheck;	//	enable/disable log-flush checking
extern BOOL			g_fFlushIsPartial;		//	true --> flush should be partial, false --> flush should be full
extern ULONG		g_csecFlushSize;		//	when g_fFlushIsPartial == false, this is the number of full sectors we expect to flush

extern BOOL			g_fEnableFlushFailure;	//	enable/disable log-flush failures
extern ULONG 		g_iIO;					//	I/O that should fail
extern EIOFAILURE	g_iof;					//	method of failure



__declspec( thread ) LONG g_lStandardRandSeed = 12830917;

LONG LTestLogPatchIStandardRand()
	{
    const long a = 16807;
    const long m = 2147483647;
    const long q = 127773;
    const long r = 2836;
    long lo, hi, test;

    hi = g_lStandardRandSeed/q;
    lo = g_lStandardRandSeed%q;
    test = a*lo - r*hi;
    if ( test > 0 )
        g_lStandardRandSeed = test;
    else
        g_lStandardRandSeed = test + m;

    return g_lStandardRandSeed-1;
	}

//	do a single flush and fail when requested

ERR ErrTestLogPatchIFlush(	IFileAPI* const		pfapiLog,
							const QWORD			ibOffset,
							const DWORD			cbData,
							const BYTE* const	pbData )
	{
	ERR err;

	AssertRTL( cbData >= 512 );

	if ( g_fEnableFlushFailure )
		{
		if ( 0 == g_iIO )
			{

			//	this I/O will fail

			switch ( g_iof )
				{
				case iofClean:
					{

					//	do the I/O normally (should succeed)

					err = pfapiLog->ErrIOWrite( ibOffset, cbData, pbData );
					AssertRTL( JET_errSuccess == err );

					//	fail with a common error

					return ErrERRCheck( JET_errDiskIO );
					}

	/****************************
				case iofTornSmall:
				case iofTornLarge:
					{
					BYTE	pbDataTorn[512];
					ULONG	cb;

					//	setup a torn version of the last sector

					memcpy( pbDataTorn, pbData, 512 );

					if ( iofTornSmall == g_iof )
						{
						cb = 1 + ( LTestLogPatchIStandardRand() % 10 );
						}
					else
						{
						cb = 502 + ( LTestLogPatchIStandardRand() % 10 );
						}
					memcpy( pbDataTorn, rgbLogExtendPattern, cb );

					//	do the I/O normally (should succeed)

					err = pfapiLog->ErrIOWrite( ibOffset, cbData - 512, pbData );
					AssertRTL( JET_errSuccess == err );
					err = pfapiLog->ErrIOWrite( ibOffset + cbData - 512, 512, pbDataTorn );
					AssertRTL( JET_errSuccess == err );

					//	fail with a common error

					return ErrERRCheck( JET_errDiskIO );
					}
	*****************************/

				case iofIncomplete1:
					{
					ULONG csec;

					csec = cbData / 512;
					if ( 0 != cbData % 512 )
						{
						AssertSzRTL( fFalse, "cbData is not sector-granular!" );
						return ErrERRCheck( JET_errDiskIO );
						}
					if ( csec < 2 )
						{
						AssertSzRTL( fFalse, "csec is too small!" );
						return ErrERRCheck( JET_errDiskIO );
						}

					//	flush (should be successfull)

					err = pfapiLog->ErrIOWrite( ibOffset, ( csec - 1 ) * 512, pbData );
					AssertRTL( JET_errSuccess == err );

					//	fail with a common error

					return ErrERRCheck( JET_errDiskIO );
					}

				case iofIncomplete2:
					{
					ULONG csec;

					csec = cbData / 512;
					if ( 0 != cbData % 512 )
						{
						AssertSzRTL( fFalse, "cbData is not sector-granular!" );
						return ErrERRCheck( JET_errDiskIO );
						}
					if ( csec < 3 )
						{
						AssertSzRTL( fFalse, "csec is too small!" );
						return ErrERRCheck( JET_errDiskIO );
						}

					//	flush (should be successfull)

					err = pfapiLog->ErrIOWrite(	ibOffset, ( csec - 2 ) * 512, pbData );
					AssertRTL( JET_errSuccess == err );

					//	fail with a common error

					return ErrERRCheck( JET_errDiskIO );
					}

				default:
					AssertSzRTL( fFalse, "Invalid EIOFAILURE value!" );
					return ErrERRCheck( JET_errDiskIO );
				}
			}

		//	decrease the I/O counter

		g_iIO--;
		}

	//	do the I/O normally (should succeed)

	err = pfapiLog->ErrIOWrite( ibOffset, cbData, pbData );
	AssertRTL( JET_errSuccess == err );
	return err;
	}

#endif	//	LOGPATCH_UNIT_TEST


// Writes all the full sectors we have in the log buffer to disk.

ERR LOG::ErrLGIWriteFullSectors(
	IFileSystemAPI *const pfsapi,
	const UINT			csecFull,
	// Sector to start the write at
	const UINT			isecWrite,
	// What to write
	const BYTE* const	pbWrite,
	// Whether there are clients waiting for log records to be flushed
	// after we finish our write
	BOOL* const			pfWaitersExist,
	// LRCHECKSUM in the log buffer that we're going to write to disk
	BYTE* const			pbFirstChecksum,
	// The LGPOS of the last record not completely written out in this write.
	const LGPOS* const	plgposMaxFlushPoint
	)
	{
	ERR				err = JET_errSuccess;
	LGPOS			lgposToFlushT = lgposMin;
	UINT			csecToWrite = csecFull;
	UINT			isecToWrite = isecWrite;
	const BYTE		*pbToWrite = pbWrite;
	BYTE			*pbFileEndT = pbNil;

	// m_critLGFlush guards m_fHaveShadow
	Assert( m_critLGFlush.FOwner() );

	Assert( m_cbSecVolume != ~(ULONG)0 );
	Assert( m_cbSecVolume % 512 == 0 );
	Assert( m_cbSec == m_cbSecVolume );

#ifdef LOGPATCH_UNIT_TEST

	if ( g_fEnableFlushCheck )
		{
		AssertSzRTL( !g_fFlushIsPartial, "expected a partial flush -- got a full flush!" );
		AssertSzRTL( g_csecFlushSize == csecFull, "did not get the number of expected sectors in this full-sector flush!" );

		ULONG _ibT;
		ULONG _cbT;

		_ibT = m_cbSec;	//	do not include the first sector -- it has the LRCK record
		_cbT = csecFull * m_cbSec;
		while ( _ibT < _cbT )
			{
			AssertRTL( 0 != UlChecksumBytes( pbWrite + _ibT, pbWrite + _ibT + m_cbSec, 0 ) );
			_ibT += m_cbSec;
			}
		}

#endif	//	LOGPATCH_UNIT_TEST

	if ( m_fHaveShadow )
		{
		// shadow was written, which means, we need to write
		// out the first sector of our bunch of full sectors,
		// then the rest.

		// start of write has to be in data portion of log file.
		// last sector of log file is reserved for shadow sector
		Assert( isecToWrite >= m_csecHeader && isecToWrite < ( m_csecLGFile - 1 ) );
		// make sure we don't write past end
		Assert( isecToWrite + 1 <= ( m_csecLGFile - 1 ) );

#ifdef LOGPATCH_UNIT_TEST

		CallJ( ErrTestLogPatchIFlush(	m_pfapiLog,
										QWORD( isecToWrite ) * m_cbSec,
										m_cbSec * 1, 
										pbToWrite ), LHandleWrite0Error );

#else	//	!LOGPATCH_UNIT_TEST

		CallJ( m_pfapiLog->ErrIOWrite(	QWORD( isecToWrite ) * m_cbSec,
										m_cbSec * 1, 
										pbToWrite ), LHandleWrite0Error );

#endif	//	LOGPATCH_UNIT_TEST

		cLGWrite.Inc( m_pinst );
		cLGBytesWritten.Add( m_pinst, m_cbSec );
		isecToWrite++;
		pbToWrite += m_cbSec;
		csecToWrite--;
		if ( pbToWrite == m_pbLGBufMax )
			{
			pbToWrite = m_pbLGBufMin;
			}

		// write out rest of the full sectors, if any
		if ( 0 < csecToWrite )
			{
			// start of write has to be in data portion of log file.
			Assert( isecToWrite >= m_csecHeader && isecToWrite < ( m_csecLGFile - 1 ) );
			// make sure we don't write past end
			Assert( isecToWrite + csecToWrite <= ( m_csecLGFile - 1 ) );

			// If the end of the block to write goes past the end of the
			// first mapping of the log buffer, this is considered using
			// the VM wraparound trick.
			if ( pbToWrite + ( m_cbSec * csecToWrite ) > m_pbLGBufMax )
				{
				m_cLGWrapAround++;
				}

#ifdef LOGPATCH_UNIT_TEST

			CallJ( ErrTestLogPatchIFlush(	m_pfapiLog,
											QWORD( isecToWrite ) * m_cbSec,
											m_cbSec * csecToWrite, 
											pbToWrite ), LHandleWrite1Error );

#else	//	!LOGPATCH_UNIT_TEST

			CallJ( m_pfapiLog->ErrIOWrite(	QWORD( isecToWrite ) * m_cbSec,
											m_cbSec * csecToWrite, 
											pbToWrite ), LHandleWrite1Error );

#endif	//	LOGPATCH_UNIT_TEST

			cLGWrite.Inc( m_pinst );
			cLGBytesWritten.Add( m_pinst, m_cbSec * csecToWrite );
			isecToWrite += csecToWrite;
			pbToWrite += m_cbSec * csecToWrite;
			if ( pbToWrite >= m_pbLGBufMax )
				{
				pbToWrite -= m_cbLGBuf;
				}
			}
		}
	else
		{
		// no shadow, which means the last write ended "perfectly"
		// on a sector boundary, so we can just blast out in 1 I/O

		// start of write has to be in data portion of log file.
		Assert( isecToWrite >= m_csecHeader && isecToWrite < ( m_csecLGFile - 1 ) );
		// make sure we don't write past end
		Assert( isecToWrite + csecToWrite <= ( m_csecLGFile - 1 ) );

		// If the end of the block to write goes past the end of the
		// first mapping of the log buffer, this is considered using
		// the VM wraparound trick.
		if ( pbToWrite + ( m_cbSec * csecToWrite ) > m_pbLGBufMax )
			{
			m_cLGWrapAround++;
			}

#ifdef LOGPATCH_UNIT_TEST

		CallJ( ErrTestLogPatchIFlush(	m_pfapiLog,
										QWORD( isecToWrite ) * m_cbSec,
										m_cbSec * csecToWrite, 
										pbToWrite ), LHandleWrite2Error );

#else	//	!LOGPATCH_UNIT_TEST

		CallJ( m_pfapiLog->ErrIOWrite(	QWORD( isecToWrite ) * m_cbSec,
										m_cbSec * csecToWrite, 
										pbToWrite ), LHandleWrite2Error );

#endif	//	LOGPATCH_UNIT_TEST

		cLGWrite.Inc( m_pinst );
		cLGBytesWritten.Add( m_pinst, m_cbSec * csecToWrite );
		isecToWrite += csecToWrite;
		pbToWrite += m_cbSec * csecToWrite;
		if ( pbToWrite >= m_pbLGBufMax )
			{
			pbToWrite -= m_cbLGBuf;
			}
		}

	// There is no shadow sector on the disk for the last chunk of data on disk.
	m_fHaveShadow = fFalse;

	// Free up space in the log buffer since we don't need it 
	// anymore.
	// Once these new log records hit the disk, we should
	// release the clients waiting.

	m_critLGBuf.Enter();	// <====================

	// what we wrote was used space
	Assert( FIsUsedSpace( pbWrite, csecFull * m_cbSec ) );

	// The new on disk LGPOS should be increasing or staying
	// the same (case of a partial sector write, then a really full
	// buffer with a big log record, then a full sector write that
	// doesn't write all of the big log record).
	Assert( CmpLgpos( &m_lgposToFlush, plgposMaxFlushPoint ) <= 0 );
	// remember the flush point we setup earlier at log adding time
	m_lgposToFlush = lgposToFlushT = *plgposMaxFlushPoint;

#ifdef DEBUG
	LGPOS lgposEndOfWrite;
	// Position right after what we wrote up to.
	GetLgpos( const_cast< BYTE* >( pbToWrite ), &lgposEndOfWrite );
	// The flush point should be less than or equal to the LGPOS of
	// the end of what we physically put to disk.
	Assert( CmpLgpos( &lgposToFlushT, &lgposEndOfWrite ) <= 0 );
#endif
	m_isecWrite = isecToWrite;
	// free space in log buffer
	m_pbWrite = const_cast< BYTE* >( pbToWrite );

	// now freed
	Assert( FIsFreeSpace( pbWrite, csecFull * m_cbSec ) );

	pbFileEndT = m_pbLGFileEnd;

	m_critLGBuf.Leave();	// <====================

	// We want to wake clients before we do other time consuming
	// operations like updating checkpoint file, creating new generation, etc.
	
	(VOID) FWakeWaitingQueue( &lgposToFlushT );

	Assert( pbNil != pbToWrite );
	// If we wrote up to the end of the log file
	if ( pbFileEndT == pbToWrite )
		{
		(VOID) ErrLGUpdateCheckpointFile( pfsapi, fFalse );

		Call( ErrLGNewLogFile( pfsapi, m_plgfilehdr->lgfilehdr.le_lGeneration, fLGOldLogExists ) );
		LGMakeLogName( m_szLogName, m_szJet );
		CallJ( pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog ), LHandleOpenError );

		m_critLGBuf.Enter();	// <----------------------------

		Assert( m_plgfilehdrT->lgfilehdr.le_lGeneration == m_plgfilehdr->lgfilehdr.le_lGeneration + 1 );
		UtilMemCpy( m_plgfilehdr, m_plgfilehdrT, sizeof( LGFILEHDR ) );
		m_isecWrite = m_csecHeader;
		m_pbLGFileEnd = pbNil;
		m_isecLGFileEnd = 0;

		m_critLGBuf.Leave();	// <----------------------------
		}

	goto HandleError;

LHandleOpenError:
	LGReportError( LOG_FLUSH_OPEN_NEW_FILE_ERROR_ID, err );
	m_fLGNoMoreLogWrite = fTrue;
	goto HandleError;

LHandleWrite0Error:
	LGReportError( LOG_FLUSH_WRITE_0_ERROR_ID, err );
	m_fLGNoMoreLogWrite = fTrue;
	goto HandleError;
	
LHandleWrite1Error:
	LGReportError( LOG_FLUSH_WRITE_1_ERROR_ID, err );
	m_fLGNoMoreLogWrite = fTrue;
	goto HandleError;

LHandleWrite2Error:
	LGReportError( LOG_FLUSH_WRITE_2_ERROR_ID, err );
	m_fLGNoMoreLogWrite = fTrue;
	goto HandleError;

HandleError:
		{
		// If there was an error, log is down and this will wake
		// everyone, else wake the people we put to disk.
		const BOOL fWaitersExist = FWakeWaitingQueue( &lgposToFlushT );
		if ( pfWaitersExist )
			{
			*pfWaitersExist = fWaitersExist;
			}
		}

	return err;
	}

// Write the last sector in the log buffer which happens to
// be not completely full.

ERR LOG::ErrLGIWritePartialSector(
	// Pointer to the end of real data in this last sector
	// of the log buffer
	BYTE*	pbFlushEnd,
	UINT	isecWrite,
	BYTE*	pbWrite
	)
	{
	ERR		err = JET_errSuccess;
	// We don't grab m_lgposToFlush since that's protected
	// by a critical section we don't want to grab.
	LGPOS	lgposToFlushT = lgposMin;

	// data writes must be past the header of the log file.
	Assert( isecWrite >= m_csecHeader );
	// The real data sector can be at most the 2nd to last sector
	// in the log file.
	Assert( isecWrite < m_csecLGFile - 1 );

	Assert( m_cbSecVolume != ~(ULONG)0 );
	Assert( m_cbSecVolume % 512 == 0 );
	Assert( m_cbSec == m_cbSecVolume );


#ifdef LOGPATCH_UNIT_TEST

	if ( g_fEnableFlushCheck )
		{
		AssertSzRTL( g_fFlushIsPartial, "expected a full flush -- got a partial flush!" );
		}

	CallJ( ErrTestLogPatchIFlush(	m_pfapiLog,
									QWORD( isecWrite ) * m_cbSec,
									m_cbSec * 1, 
									pbWrite ), LHandleWrite3Error );

#else	//	!LOGPATCH_UNIT_TEST

	// write real data
	CallJ( m_pfapiLog->ErrIOWrite(	QWORD( isecWrite ) * m_cbSec,
									m_cbSec * 1, 
									pbWrite ), LHandleWrite3Error );

#endif	//	LOGPATCH_UNIT_TEST

	cLGWrite.Inc( m_pinst );
	cLGBytesWritten.Add( m_pinst, m_cbSec );

		{
		// The shadow should have a different checksum from regular
		// log data sectors in the log file, so we can differentiate
		// the shadow, so we don't accidentally interpret the shadow
		// as regular log data.

		// We do not acquire a critical section, because we're
		// already in m_critLGFlush which is the only place from
		// which m_pbLastChecksum is modified. In addition, the log
		// buffer is guaranteed not to be reallocated during m_critLGFlush.

		Assert( m_critLGFlush.FOwner() );

		// pbWrite better be sector aligned
		Assert( PbSecAligned( pbWrite ) == pbWrite );
		// the last LRCHECKSUM record should be on the shadow sector
		Assert( PbSecAligned( m_pbLastChecksum ) == pbWrite );
		
		LRCHECKSUM* const plrck = reinterpret_cast< LRCHECKSUM* >( m_pbLastChecksum );

		// We modify the checksum by adding a special shadow sector checksum.
		plrck->le_ulChecksum = UlComputeShadowChecksum( plrck->le_ulChecksum );
		}

	// The shadow can be at most the last sector in the log file.
	Assert( isecWrite + 1 < m_csecLGFile );

#ifdef LOGPATCH_UNIT_TEST

	CallJ( ErrTestLogPatchIFlush(	m_pfapiLog,
									QWORD( isecWrite + 1 ) * m_cbSec,
									m_cbSec * 1, 
									pbWrite ), LHandleWrite4Error );

#else	//	!LOGPATCH_UNIT_TEST

	// write shadow sector
	CallJ( m_pfapiLog->ErrIOWrite(	QWORD( isecWrite + 1 ) * m_cbSec,
									m_cbSec * 1, 
									pbWrite ), LHandleWrite4Error );

#endif	//	LOGPATCH_UNIT_TEST

	cLGWrite.Inc( m_pinst );
	cLGBytesWritten.Add( m_pinst, m_cbSec );

	Assert( m_critLGFlush.FOwner() );
	// Flag for ErrLGIWriteFullSectors() to split up a big I/O
	// into 2 I/Os to prevent from overwriting shadow and then killing
	// the real last data sector (because order of sector updating is
	// not guaranteed when writing multiple sectors to disk).
	m_fHaveShadow = fTrue;

	// Free up buffer space
	m_critLGBuf.Enter();	// <====================

	Assert( pbWrite < pbFlushEnd );
	// make sure we wrote stuff that was valid in the log buffer.
	// We are not going to write garbage!!
	Assert( FIsUsedSpace( pbWrite, ULONG( pbFlushEnd - pbWrite ) ) );

	// flush end is end of real data in log buffer.
	GetLgpos( pbFlushEnd, &lgposToFlushT );
	m_lgposToFlush = lgposToFlushT;
	// m_pbWrite and m_isecWrite are already setup fine.
	// m_pbWrite is still pointing to the beginning of this
	// partial sector which will need to be written again
	// once it fills up.
	// m_isecWrite is still pointing to this sector on disk
	// and that makes sense.

	m_critLGBuf.Leave();	// <====================

	goto HandleError;

LHandleWrite3Error:
	LGReportError( LOG_FLUSH_WRITE_3_ERROR_ID, err );
	m_fLGNoMoreLogWrite = fTrue;
	goto HandleError;

LHandleWrite4Error:
	LGReportError( LOG_FLUSH_WRITE_4_ERROR_ID, err );
	m_fLGNoMoreLogWrite = fTrue;
	goto HandleError;

HandleError:

	// We don't care if anyone is waiting, since they can
	// ask for a flush, themselves.
	// Wake anyone we flushed to disk.
	(VOID) FWakeWaitingQueue( &lgposToFlushT );

	return err;
	}

// Called to write out more left over log buffer data after doing a
// full sector write. The hope was that while the full sector write
// was proceeding, more log records were added and we now have another
// full sector write ready to go. If no more stuff was added, just
// finish writing whatever's left in the log buffer.

ERR LOG::ErrLGIDeferredFlush( IFileSystemAPI *const pfsapi, const BOOL fFlushAll )
	{
	ERR		err = JET_errSuccess;
	BYTE*	pbEndOfData = pbNil;
	UINT	isecWrite;
	BYTE*	pbWrite = pbNil;
	BYTE*	pbFirstChecksum = pbNil;
	LGPOS	lgposMaxFlushPoint = lgposMax;
		
	m_critLGBuf.Enter();

	// m_pbLastChecksum should be on the next sector we're going to write out
	// (since it could not be written out last time, unless on a partial).
	Assert( PbSecAligned( m_pbWrite ) == PbSecAligned( m_pbLastChecksum ) );

	// Remember where first LRCHECKSUM record in the log buffer is, so we
	// can pass it to ErrLGIWriteFullSectors() in case of short checksum fixup.
	pbFirstChecksum = m_pbLastChecksum;

	if ( pbNil == m_pbLGFileEnd )
		{
		// append a new checksum if necessary, get a pointer to
		// the end of real log data.
		pbEndOfData = PbAppendNewChecksum( fFlushAll );
		// need max flush point for possible full sector write coming up
		lgposMaxFlushPoint = m_lgposMaxFlushPoint;

		if ( fFlushAll && pbEndOfData != m_pbEntry )
			{
			Assert( pbEndOfData == m_pbLastChecksum );
			Assert( FIsUsedSpace( pbEndOfData, sizeof( LRCHECKSUM ) ) );
			Assert( pbEndOfData + sizeof( LRCHECKSUM ) == m_pbEntry );

			//	BUG X5:83888 
			//
			//		we create a torn-write after a clean shutdown because we don't flush the last LRCK record
			//		(we weren't seeing it because pbEndOfData was pointing AT the LRCK instead of PAST it)
			//
			//		move the end of data past the last LRCHECKSUM record to REAL end of data

			pbEndOfData += sizeof( LRCHECKSUM );
			}
		}
	else
		{
		pbEndOfData = m_pbLGFileEnd;
		Assert( PbSecAligned( pbEndOfData ) == pbEndOfData );
		// max flush point for end of file
		GetLgpos( pbEndOfData, &lgposMaxFlushPoint );
		SetupLastFileChecksum( m_pbLastChecksum, pbEndOfData );
		// m_pbLastChecksum is also setup in ErrLGNewLogFile().
		m_pbLastChecksum = pbEndOfData;
		}
		
	// Get current values.
	isecWrite = m_isecWrite;
	pbWrite = m_pbWrite;
	
	UINT csecFull;
	BOOL fPartialSector;
	
	if ( pbEndOfData < pbWrite )
		{
		csecFull = ULONG( ( pbEndOfData + m_cbLGBuf ) - pbWrite ) / m_cbSec;
		}
	else
		{
		csecFull = ULONG( pbEndOfData - pbWrite ) / m_cbSec;
		}

	fPartialSector = ( 0 !=
		( ( pbEndOfData - PbSecAligned( pbEndOfData ) ) % m_cbSec ) );

#ifdef DEBUG
	// Follow same algorithm as below, but just make sure space is used properly
	if ( 0 == csecFull )
		{
		Assert( fPartialSector );
		Assert( pbEndOfData > pbWrite );
		Assert( FIsUsedSpace( pbWrite, ULONG( pbEndOfData - pbWrite ) ) );
		}
	else
		{
		Assert( FIsUsedSpace( pbWrite, csecFull * m_cbSec ) );
		}
#endif

	m_critLGBuf.Leave();

	if ( 0 == csecFull )
		{
		Assert( fPartialSector );
		Call( ErrLGIWritePartialSector( pbEndOfData, isecWrite, pbWrite ) );
		}
	else
		{
		// we don't care if anyone is waiting, since they'll ask for
		// a flush themselves, since this means they got into the buffer
		// during our I/O.
		Call( ErrLGIWriteFullSectors( pfsapi, csecFull, isecWrite, pbWrite, NULL,
			pbFirstChecksum, &lgposMaxFlushPoint ) );
		}

HandleError:

	return err;
	}

// Returns a pointer to the end of real data in the log buffer.
// This may *NOT* append a new LRCHECKSUM record if it's not needed
// (i.e. the end of the log buffer is on the same sector as the last
// LRCHECKSUM in the log buffer).

BYTE* LOG::PbAppendNewChecksum( const BOOL fFlushAll )
	{
	Assert( m_critLGBuf.FOwner() );

	BYTE* pbEndOfData = pbNil;
	const BOOL fEntryOnSameSector = PbSecAligned( PbGetEndOfLogData() ) == PbSecAligned( m_pbLastChecksum );

	// If m_pbEntry is on the same sector as the last LRCHECKSUM record
	// in the log buffer, we do not need to add a new LRCHECKSUM because
	// we're not done with this sector anyway (clients could add more log
	// records on this sector).
	if ( !fEntryOnSameSector )
		{
		// add a new LRCHECKSUM record
		// start of where we can place lrtypNOP
		BYTE* const pbStartNOP = m_pbEntry;

		//	BUG X5:83888 
		//
		//		prevent an LRCHECKSUM record from using up the rest of the sector exactly
		//		the reasoning for this is tricky to follow:
		//			when fFluahAll=TRUE, we force the user to flush ALL log records
		//			this includes the LRCHECKSUM at the end of the log that is normally invisible thanks
		//				to the messed up special-case code in PbGetEndOfLogData()
		//			so, look at the code below for PbGetSectorContiguous()
		//			in the case where we see that we have exactly enough bytes for an LRCHECKSUM record,
		//				we will not do a NOP-fill -- we will use those bytes and effectively move the
		//				end of data to the sector boundary
		//			when we return to ErrLGFlushLog(), we will see this new end of data (the sector boundary)
		//				and decide that we have N full sectors to flush
		//			we will call ErrLGIWriteFullSectors()
		//			assume no more log records come in while we are flushing (e.g. m_pbEntry still points at
		//				at the beginning of the sector right after the last LRCHECKSUM record)
		//			at the end of ErrLGIWriteFullSectors, we advance m_pbWrite by the number of full sectors
		//				flushed (we can't go back and change them -- they aren't shadowed)
		//
		//			WE HAVE JUST CAUSED OURSELVES LOTS OF PROBLEMS! we wrote the LRCHECKSUM record without
		//				updating its ptrs and we cannot update it!
		//
		//			THE FIX -- during an fFlushAll case, make sure we don't end a sector with an LRCK record!

		pbEndOfData = PbGetSectorContiguous( pbStartNOP, sizeof( LRCHECKSUM ) + ( fFlushAll ? 1 : 0 ) );
		int cbNOP = (int)(( pbEndOfData < pbStartNOP ) ?
			pbEndOfData + m_cbLGBuf - pbStartNOP :
			pbEndOfData - pbStartNOP);
		// NOP space must be free
		Assert( FIsFreeSpace( pbStartNOP, cbNOP ) );
		memset( pbStartNOP, lrtypNOP, cbNOP );
		if ( !COSMemoryMap::FCanMultiMap() )
			{
			memset( pbStartNOP + m_cbLGBuf, lrtypNOP, min( cbNOP, m_pbLGBufMax - pbStartNOP ) );
			if ( pbStartNOP + cbNOP > m_pbLGBufMax )
				memset( m_pbLGBufMin, lrtypNOP, pbStartNOP + cbNOP - m_pbLGBufMax );
			}
		
		if ( PbSecAligned( pbEndOfData ) == pbEndOfData )
			{
			// We either already were pointing to the beginning of a
			// sector, or we just NOPed out some space.
			// If we were pointing to the beginning of a sector
			// then the max flush point is already this value.
			// Otherwise, we'll be increasing the max flush point
			// to the right thing.
#ifdef DEBUG
			LGPOS lgposOldMaxFlushPoint = m_lgposMaxFlushPoint;
#endif
			GetLgpos( pbEndOfData, &m_lgposMaxFlushPoint );
			Assert( CmpLgpos( &lgposOldMaxFlushPoint, &m_lgposMaxFlushPoint ) <= 0 );
			}

		// record NOP-space as used data.
		m_pbEntry = pbEndOfData;

		//	the NOPed space should now be used
		Assert( cbNOP == 0 || FIsUsedSpace( pbStartNOP, cbNOP ) );
		//	we should also have enough room for a new LRCHECKSUM record
		Assert( FIsFreeSpace( pbEndOfData, sizeof( LRCHECKSUM ) ) );

		SetupLastChecksum( m_pbLastChecksum, pbEndOfData );

		// append new LRCHECKSUM in log buffer
		m_pbEntry = PbSetupNewChecksum( pbEndOfData, m_pbLastChecksum );
		// m_pbEntry is now pointing to after the new LRCHECKSUM added.

		//	the checksum record space is now used
		Assert( FIsUsedSpace( pbEndOfData, sizeof( LRCHECKSUM ) ) );

		// remember the new one as the last checksum
		m_pbLastChecksum = pbEndOfData;

		}
	else
		{
		// may be pointing to after the last bit of data,
		// or may be pointing to after the last LRCHECKSUM on the sector
		// (and in the log buffer).
		pbEndOfData = m_pbEntry;
		SetupLastChecksum( m_pbLastChecksum, pbEndOfData );
		// return the end of real log data, so we don't
		// return a pointer to the end of the last LRCHECKSUM.
		pbEndOfData = PbGetEndOfLogData();
		}

	// either pointing to the LRCHECKSUM that was just added, or
	// whatever's at the end of m_pbEntry.
	return pbEndOfData;
	}

// Return the end of actual log data in the log buffer, excluding
// an end LRCHECKSUM record, since that's not real log data that the
// user wants to disk.

BYTE* LOG::PbGetEndOfLogData()
	{
	Assert( FIsUsedSpace( m_pbLastChecksum, sizeof( LRCHECKSUM ) ) );

	BYTE* pbEndOfLastLR = m_pbLastChecksum + sizeof( LRCHECKSUM );
	
	Assert( pbEndOfLastLR > m_pbLGBufMin && pbEndOfLastLR <= m_pbLGBufMax );

	if ( pbEndOfLastLR == m_pbLGBufMax )
		pbEndOfLastLR = m_pbLGBufMin;

	if ( pbEndOfLastLR == m_pbEntry )
		{
		// nothing has been added past the last LRCHECKSUM, so the
		// end of real log data is at the start of the LRCHECKSUM.
		return m_pbLastChecksum;
		}
	else
		{
		// there is data past the last LRCHECKSUM (perhaps on the same
		// sector, or maybe on more sectors).

		return m_pbEntry;
		}
	}

// Flush has been requested. Flush some of the data that we have in 
// the log buffer. This is *NOT* guaranteed to flush everything in the
// log buffer. We'll only flush everything if it goes right up to
// a sector boundary, or if the entire log buffer is being waited on
// (ppib->lgposCommit0).

ERR LOG::ErrLGFlushLog( IFileSystemAPI *const pfsapi, const BOOL fFlushAll )
	{
	ENTERCRITICALSECTION enter( &m_critLGFlush );

	return ErrLGIFlushLog( pfsapi, fFlushAll );
	}

ERR LOG::ErrLGIFlushLog( IFileSystemAPI *const pfsapi, const BOOL fFlushAll )
	{
	ERR		err;
	BOOL	fPartialSector;
	UINT	isecWrite;
	BYTE*	pbWrite;
	UINT	csecFull;
	BYTE*	pbEndOfData;
	BYTE*	pbFirstChecksum;
	LGPOS	lgposMaxFlushPoint;
	BOOL	fNewGeneration;

Repeat:
	fNewGeneration	= fFalse;
	err				= JET_errSuccess;
	fPartialSector	= fFalse;
	pbWrite			= pbNil;
	csecFull		= 0;
	pbEndOfData		= pbNil;
	pbFirstChecksum	= pbNil;
	// Set this to max so we'll Assert() or hang elsewhere if this
	// is used without really being initialized.
	lgposMaxFlushPoint = lgposMax;
	
	m_critLGBuf.Enter();	// <===================================


	if ( m_fLGNoMoreLogWrite )
		{
		m_critLGBuf.Leave();
		Call( ErrERRCheck( JET_errLogWriteFail ) );
		}

	if ( !m_pfapiLog )
		{
		m_critLGBuf.Leave();
		err = JET_errSuccess;
		goto HandleError;
		}

	// XXX
	// gross temp hack to prevent trying to flush during ErrLGSoftStart
	// and recovery redo time.
	if ( ! m_fNewLogRecordAdded )
		{
		m_critLGBuf.Leave();
		err = JET_errSuccess;
		goto HandleError;
		}

	// m_pbLastChecksum should be on the next sector we're going to write out
	// (since it could not be written out last time, unless on a partial).
	Assert( PbSecAligned( m_pbWrite ) == PbSecAligned( m_pbLastChecksum ) );

	// Remember where this checksum record is, before we add a new checksum
	// record, so we can use it to tell ErrLGIWriteFullSectors() which
	// LRCHECKSUM to "fix up" in the special 2 I/O case.
	
	pbFirstChecksum = m_pbLastChecksum;

	if ( pbNil != m_pbLGFileEnd )
		{
		fNewGeneration = fTrue;
		pbEndOfData = m_pbLGFileEnd;
		Assert( PbSecAligned( pbEndOfData ) == pbEndOfData );

		// set flush point for full sector write coming up
		GetLgpos( pbEndOfData, &lgposMaxFlushPoint );

		SetupLastFileChecksum( m_pbLastChecksum, pbEndOfData );
		// m_pbLastChecksum is also set in ErrLGNewLogFile().
		m_pbLastChecksum = pbEndOfData;
		}
	else
		{
		LGPOS	lgposEndOfData = lgposMin;
		
		// Figure out the end of real log data.
		pbEndOfData = PbGetEndOfLogData();

		if ( fFlushAll && pbEndOfData != m_pbEntry )
			{
			Assert( pbEndOfData == m_pbLastChecksum );
			Assert( FIsUsedSpace( pbEndOfData, sizeof( LRCHECKSUM ) ) );
			Assert( pbEndOfData + sizeof( LRCHECKSUM ) == m_pbEntry );

			//	BUG X5:83888 
			//
			//		we create a torn-write after a clean shutdown because we don't flush the last LRCK record
			//		(we weren't seeing it because pbEndOfData was pointing AT the LRCK instead of PAST it)
			//
			//		move the end of data past the last LRCHECKSUM record to REAL end of data

			pbEndOfData += sizeof( LRCHECKSUM );
			}

		GetLgpos( pbEndOfData, &lgposEndOfData );

		// If all real data in the log buffer has been flushed,
		// we're done.
		if ( CmpLgpos( &lgposEndOfData, &m_lgposToFlush ) <= 0 )
			{
			m_critLGBuf.Leave();
			err = JET_errSuccess;
			goto HandleError;		
			}

		// Add an LRCHECKSUM if necessary (if we're on a new
		// sector).
		pbEndOfData = PbAppendNewChecksum( fFlushAll );

		lgposMaxFlushPoint = m_lgposMaxFlushPoint;	

		if ( fFlushAll && pbEndOfData != m_pbEntry )
			{
			Assert( pbEndOfData == m_pbLastChecksum );
			Assert( FIsUsedSpace( pbEndOfData, sizeof( LRCHECKSUM ) ) );
			Assert( pbEndOfData + sizeof( LRCHECKSUM ) == m_pbEntry );

			//	BUG X5:83888 
			//
			//		we create a torn-write after a clean shutdown because we don't flush the last LRCK record
			//		(we weren't seeing it because pbEndOfData was pointing AT the LRCK instead of PAST it)
			//
			//		move the end of data past the last LRCHECKSUM record to REAL end of data

			pbEndOfData += sizeof( LRCHECKSUM );
			}
		}

	// Get current values.
	isecWrite = m_isecWrite;
	pbWrite = m_pbWrite;
	
	if ( pbEndOfData < pbWrite )
		{
		csecFull = ULONG( ( pbEndOfData + m_cbLGBuf ) - pbWrite ) / m_cbSec;
		}
	else
		{
		csecFull = ULONG( pbEndOfData - pbWrite ) / m_cbSec;
		}

	fPartialSector = ( 0 !=
		( ( pbEndOfData - PbSecAligned( pbEndOfData ) ) % m_cbSec ) );

	Assert( csecFull + ( fPartialSector ? 1 : 0 ) <= m_csecLGBuf );

#ifdef DEBUG
		{
		if ( pbNil != m_pbLGFileEnd )
			{
			Assert( csecFull > 0 );
			Assert( ! fPartialSector );
			}
		}
#endif

	// The next time someone grabs the buffer, they'll see our new
	// LRCHECKSUM record and any NOPs. We've only "extended" the used
	// area of the log buffer in these changes.
	// Summary of atomic changes:
	// m_pbEntry <-- points after new LRCHECKSUM
	// m_pbLastChecksum <-- points to the new one we added

#ifdef DEBUG
	// Follow same algorithm as below to do assertions inside of crit. section

	if ( 0 == csecFull )
		{
		Assert( fPartialSector );
		Assert( pbEndOfData > pbWrite );
		Assert( FIsUsedSpace( pbWrite, ULONG( pbEndOfData - pbWrite ) ) );
		}
	else
		{
		Assert( FIsUsedSpace( pbWrite, csecFull * m_cbSec ) );
		}
#endif

	m_critLGBuf.Leave();

	if ( 0 == csecFull )
		{
		// No full sectors, so just write the partial and be done
		// with it.
		Assert( fPartialSector );
		Call( ErrLGIWritePartialSector( pbEndOfData, isecWrite, pbWrite ) );
		}
	else
		{
		// Some full sectors to write once, so blast them out
		// now and hope that someone adds log records while we're writing.
		BOOL fWaitersExist = fFalse;
		Call( ErrLGIWriteFullSectors( pfsapi, csecFull, isecWrite, pbWrite,
			&fWaitersExist, pbFirstChecksum, &lgposMaxFlushPoint ) );

		//	HACK (IVANTRIN): we assume that we can remove following fPartial sector verification
		//	but Adam is not sure. So when we create new generation and there are waiters
		//	left repeat the flush check.
		if ( fWaitersExist && fNewGeneration )
			{
			goto Repeat;
			}

		// Only write some more if we have some more, and if
		// there are people waiting for it to be flushed.
		if ( fPartialSector && fWaitersExist )
			{
			// If there was previously a partial sector in the log buffer
			// the user probably wanted the log recs to disk, so do the
			// smart deferred flush.
			Call( ErrLGIDeferredFlush( pfsapi, fFlushAll ) );
			}
		}


HandleError:

	// should not need to wake anyone up -- should be
	// handled by the other functions.

	return err;
	}

/********************* CHECKPOINT **************************
/***********************************************************
/**/

#ifdef UNLIMITED_DB
LOCAL ERR LOG::ErrLGLoadDbListFromFMP_()
	{
	ATTACHINFO*		pattachinfo		= (ATTACHINFO*)( m_pbLGDbListBuffer + sizeof(LRDBLIST) );

	//	during Redo phase of recovery, must compute attachment list
	//	using atchchk
	//	all other times, the DbList buffer should be dynamically updated
	//	as attach/detach operations occur
	Assert( m_fRecovering );
	Assert( fRecoveringRedo == m_fRecoveringMode );

	FMP::EnterCritFMPPool();

	m_cbLGDbListInUse = sizeof(LRDBLIST);
	m_cLGAttachments = 0;

	for ( DBID dbidT = dbidUserLeast; dbidT < dbidMax; dbidT++ )
		{
		Assert( dbidTemp != dbidT );
		const IFMP	ifmp			= m_pinst->m_mpdbidifmp[ dbidT ];

		if ( ifmp >= ifmpMax )
			continue;

		FMP*		pfmpT			= &rgfmp[ ifmp ];
		ATCHCHK*	patchchk		= pfmpT->Patchchk();
		Assert( NULL != patchchk );
		Assert( pfmpT->FLogOn() );

		CHAR* 		szDatabaseName		= pfmpT->SzDatabaseName();
		CHAR* 		szSLVName			= pfmpT->SzSLVName();
		CHAR*		szSLVRoot			= pfmpT->SzSLVRoot();
		INT			irstmap;

		if ( g_fAlternateDbDirDuringRecovery )
			{
			//	HACK: original database name hangs off the end
			//	of the relocated database name
			szDatabaseName += strlen( szDatabaseName ) + 1;
			}
		else
			{
			irstmap = IrstmapSearchNewName( szDatabaseName );
			if ( irstmap >= 0 )
				{
				szDatabaseName = m_rgrstmap[irstmap].szDatabaseName;
				Assert( NULL != szDatabaseName );
				}
			}

		if ( NULL != szSLVName )
			{
			if ( g_fAlternateDbDirDuringRecovery )
				{
				//	HACK: original SLV name hangs off the end
				//	of the relocated SLV name
				szSLVName += strlen( szSLVName ) + 1;
				}
			else
				{
				irstmap = IrstmapSearchNewName( szSLVName );
				if ( irstmap >= 0 )
					{
					szSLVName = m_rgrstmap[irstmap].szDatabaseName;
					Assert( NULL != szSLVName );
					}
				}
			}


		ULONG			cbNames;
		const ULONG		cbDbName		= (ULONG)strlen( szDatabaseName ) + 1;
		const ULONG		cbSLVName		= ( NULL != szSLVName ? (ULONG)strlen( szSLVName ) + 1 : 0 );
		const ULONG		cbSLVRoot		= ( NULL != szSLVRoot ? (ULONG)strlen( szSLVRoot ) + 1 : 0 );
		const ULONG		cbRequired		= sizeof(ATTACHINFO)
												+ cbDbName
												+ cbSLVName
												+ cbSLVRoot;

		if ( m_cbLGDbListInUse + cbRequired + 1 > m_cbLGDbListBuffer )	//	+1 for sentinel
			{
			pfmpT->RwlDetaching().LeaveAsReader();
			FMP::LeaveCritFMPPool();

			ERR		err;
			CallR( ErrLGResizeDbListBuffer_( fFalse ) );

			//	on success, retry from the beginning
			FMP::EnterCritFMPPool();
			pattachinfo = (ATTACHINFO*)m_pbLGDbListBuffer;
			dbidT = 0;
			continue;
			}
			
		memset( pattachinfo, 0, sizeof(ATTACHINFO) );
			
		Assert( !pfmpT->FVersioningOff() );
		Assert( !pfmpT->FReadOnlyAttach() );
		Assert( !pattachinfo->FSLVExists() );
		Assert( !pattachinfo->FSLVProviderNotEnabled() );

		pattachinfo->SetDbid( dbidT );

		Assert( pfmpT->FLogOn() );

		if( !m_pinst->FSLVProviderEnabled() )
			{
			pattachinfo->SetFSLVProviderNotEnabled();
			}

		Assert( !pfmpT->FReadOnlyAttach() );

		if ( NULL != pfmpT->SzSLVName() )
			{
			//	SLV must always have a root
			Assert( NULL != pfmpT->SzSLVRoot() );
			pattachinfo->SetFSLVExists();
			}

		pattachinfo->SetDbtime( pfmpT->Patchchk()->Dbtime() );
		pattachinfo->SetObjidLast( pfmpT->Patchchk()->ObjidLast() );
		pattachinfo->SetCpgDatabaseSizeMax( pfmpT->Patchchk()->CpgDatabaseSizeMax() );
		pattachinfo->le_lgposAttach = pfmpT->Patchchk()->lgposAttach;
		pattachinfo->le_lgposConsistent = pfmpT->Patchchk()->lgposConsistent;
		UtilMemCpy( &pattachinfo->signDb, &pfmpT->Patchchk()->signDb, sizeof( SIGNATURE ) );
			
			
		strcpy( pattachinfo->szNames, szDatabaseName );
		cbNames = cbDbName;

		if ( pattachinfo->FSLVExists() )
			{
			Assert( NULL != szSLVName );
			strcpy( pattachinfo->szNames + cbNames, szSLVName );
			cbNames += cbSLVName;

			Assert( NULL != pfmpT->SzSLVRoot() );
			strcpy( pattachinfo->szNames + cbNames, pfmpT->SzSLVRoot() );
			cbNames += cbSLVRoot;
			}

		Assert( cbRequired == sizeof(ATTACHINFO) + cbNames );
		pattachinfo->SetCbNames( (USHORT)cbNames );

		//	advance to next attachinfo
		m_cLGAttachments++;
		m_cbLGDbListInUse += cbRequired;
		pattachinfo = (ATTACHINFO*)( (BYTE *)pattachinfo + cbRequired );
		Assert( (BYTE *)pattachinfo - m_pbLGDbListBuffer == m_cbLGDbListInUse );

		//	verify we don't overrun buffer (ensure we have enough room for sentinel)
		Assert( m_cbLGDbListInUse < m_cbLGDbListBuffer );
		}

	//	put a sentinal
	*(BYTE *)pattachinfo = 0;
	m_cbLGDbListInUse++;

	//	must always have at least an LRDBLIST and a sentinel
	Assert( m_cbLGDbListInUse > sizeof(LRDBLIST) );
	Assert( m_cbLGDbListInUse <= m_cbLGDbListBuffer );

	LRDBLIST*	const plrdblist		= (LRDBLIST *)m_pbLGDbListBuffer;
	plrdblist->lrtyp = lrtypDbList;
	plrdblist->ResetFlags();
	plrdblist->SetCAttachments( m_cLGAttachments );
	plrdblist->SetCbAttachInfo( m_cbLGDbListInUse - sizeof(LRDBLIST) );

	FMP::LeaveCritFMPPool();

	return JET_errSuccess;
	}


//	ensure there is enough space to add specified dbid to the db list
LOCAL ERR LOG::ErrLGPreallocateDbList_( const DBID dbid )
	{
	const IFMP		ifmp			= m_pinst->m_mpdbidifmp[ dbid ];
	FMP*			pfmpT			= &rgfmp[ ifmp ];

	Enforce( ifmp < ifmpMax );

	Assert( m_critLGBuf.FOwner() );
	Assert( !m_fRecovering );
	Assert( pfmpT->FLogOn() );
	Assert( NULL != pfmpT->Pdbfilehdr() );
	Assert( 0 == CmpLgpos( lgposMin, pfmpT->LgposAttach() ) );	//	pre-allocating list before attach is actually logged
	Assert( 0 == CmpLgpos( lgposMin, pfmpT->LgposDetach() ) );

	CHAR* 			szDatabaseName	= pfmpT->SzDatabaseName();
	CHAR* 			szSLVName		= pfmpT->SzSLVName();
	CHAR*			szSLVRoot		= pfmpT->SzSLVRoot();

	Assert( NULL != szDatabaseName );
	Assert( NULL == szSLVName || NULL != szSLVRoot );

	const ULONG		cbDbName		= (ULONG)strlen( szDatabaseName ) + 1;
	const ULONG		cbSLVName		= ( NULL != szSLVName ? (ULONG)strlen( szSLVName ) + 1 : 0 );
	const ULONG		cbSLVRoot		= ( NULL != szSLVRoot ? (ULONG)strlen( szSLVRoot ) + 1 : 0 );
	const ULONG		cbRequired		= sizeof(ATTACHINFO)
										+ cbDbName
										+ cbSLVName
										+ cbSLVRoot;

	if ( m_cbLGDbListInUse + cbRequired > m_cbLGDbListBuffer )
		{
		ERR		err;
		CallR( ErrLGResizeDbListBuffer_( fTrue ) );
		}

	return JET_errSuccess;
	}

LOCAL VOID LOG::LGAddToDbList_( const DBID dbid )
	{
	const IFMP		ifmp			= m_pinst->m_mpdbidifmp[ dbid ];
	FMP*			pfmpT			= &rgfmp[ ifmp ];

	Enforce( ifmp < ifmpMax );

	Assert( m_critLGBuf.FOwner() );
	Assert( !m_fRecovering );
	Assert( pfmpT->FLogOn() );
	Assert( NULL != pfmpT->Pdbfilehdr() );
	Assert( 0 != CmpLgpos( lgposMin, pfmpT->LgposAttach() ) );
	Assert( 0 == CmpLgpos( lgposMin, pfmpT->LgposDetach() ) );

	CHAR* 			szDatabaseName	= pfmpT->SzDatabaseName();
	CHAR* 			szSLVName		= pfmpT->SzSLVName();
	CHAR*			szSLVRoot		= pfmpT->SzSLVRoot();

	Assert( NULL != szDatabaseName );
	Assert( NULL == szSLVName || NULL != szSLVRoot );

	ULONG			cbNames;
	const ULONG		cbDbName		= (ULONG)strlen( szDatabaseName ) + 1;
	const ULONG		cbSLVName		= ( NULL != szSLVName ? (ULONG)strlen( szSLVName ) + 1 : 0 );
	const ULONG		cbSLVRoot		= ( NULL != szSLVRoot ? (ULONG)strlen( szSLVRoot ) + 1 : 0 );
	const ULONG		cbRequired		= sizeof(ATTACHINFO)
										+ cbDbName
										+ cbSLVName
										+ cbSLVRoot;

	Enforce( m_cbLGDbListInUse + cbRequired <= m_cbLGDbListBuffer );

	BYTE*			pbSentinel			= m_pbLGDbListBuffer + m_cbLGDbListInUse - 1;
	ATTACHINFO*		pattachinfo;

#ifdef DEBUG
	pattachinfo = (ATTACHINFO *)( m_pbLGDbListBuffer + sizeof(LRDBLIST) );
	Assert( (BYTE *)pattachinfo > m_pbLGDbListBuffer );
	Assert( (BYTE *)pattachinfo <= pbSentinel );
	Assert( 0 == *pbSentinel );
	Assert( pbSentinel + cbRequired < m_pbLGDbListBuffer + m_cbLGDbListBuffer );

	while ( 0 != *( (BYTE *)pattachinfo ) )
		{
		Assert( (BYTE *)pattachinfo > m_pbLGDbListBuffer );
		Assert( (BYTE *)pattachinfo < pbSentinel );

		//	assert not already in list
		Assert( dbid != pattachinfo->Dbid() );
		pattachinfo = (ATTACHINFO *)( (BYTE *)pattachinfo + sizeof(ATTACHINFO) + pattachinfo->CbNames() );
		}
#endif

	m_cbLGDbListInUse += cbRequired;
	m_cLGAttachments++;

	LRDBLIST* const		plrdblist	= (LRDBLIST *)m_pbLGDbListBuffer;
	plrdblist->SetCAttachments( plrdblist->CAttachments() + 1 );
	plrdblist->SetCbAttachInfo( plrdblist->CbAttachInfo() + cbRequired );

	Assert( plrdblist->CAttachments() == m_cLGAttachments );
	Assert( plrdblist->CbAttachInfo() + sizeof(LRDBLIST) == m_cbLGDbListInUse );


	//	append new attachment to the end of the list
	pattachinfo = (ATTACHINFO *)pbSentinel;
	Assert( (BYTE *)pattachinfo >= m_pbLGDbListBuffer + sizeof(LRDBLIST) );

	//	move sentinel
	*( pbSentinel + cbRequired ) = 0;

	//	initialise new attachinfo

	memset( pattachinfo, 0, sizeof(ATTACHINFO) );
	
	Assert( !pfmpT->FVersioningOff() );
	Assert( !pfmpT->FReadOnlyAttach() );
	Assert( !pattachinfo->FSLVExists() );
	Assert( !pattachinfo->FSLVProviderNotEnabled() );

	pattachinfo->SetDbid( dbid );

	Assert( pfmpT->FLogOn() );

	if( !m_pinst->FSLVProviderEnabled() )
		{
		pattachinfo->SetFSLVProviderNotEnabled();
		}

	Assert( !pfmpT->FReadOnlyAttach() );

	if ( NULL != pfmpT->SzSLVName() )
		{
		//	SLV must always have a root
		Assert( NULL != pfmpT->SzSLVRoot() );
		pattachinfo->SetFSLVExists();
		}

	pattachinfo->SetDbtime( pfmpT->DbtimeLast() );
	pattachinfo->SetObjidLast( pfmpT->ObjidLast() );
	pattachinfo->SetCpgDatabaseSizeMax( pfmpT->CpgDatabaseSizeMax() );
	pattachinfo->le_lgposAttach = pfmpT->LgposAttach();

	//	 relays DBISetHeaderAfterAttach behavior for resetting lgposConsistent
	if ( 0 == memcmp( &pfmpT->Pdbfilehdr()->signLog, &m_signLog, sizeof(SIGNATURE) ) )
		{
		pattachinfo->le_lgposConsistent = pfmpT->Pdbfilehdr()->le_lgposConsistent;
		}
	else
		{
		pattachinfo->le_lgposConsistent = lgposMin;
		}
	UtilMemCpy( &pattachinfo->signDb, &pfmpT->Pdbfilehdr()->signDb, sizeof( SIGNATURE ) );

	Assert( NULL != szDatabaseName );
	strcpy( pattachinfo->szNames, szDatabaseName );
	cbNames = (ULONG)strlen( szDatabaseName ) + 1;

	if ( pattachinfo->FSLVExists() )
		{
		Assert( NULL != szSLVName );
		strcpy( pattachinfo->szNames + cbNames, szSLVName );
		cbNames += (ULONG) strlen( szSLVName ) + 1;

		Assert( NULL != pfmpT->SzSLVRoot() );
		strcpy( pattachinfo->szNames + cbNames, pfmpT->SzSLVRoot() );
		cbNames += (ULONG) strlen( pfmpT->SzSLVRoot() ) + 1;
		}

	pattachinfo->SetCbNames( (USHORT)cbNames );
	}

LOCAL VOID LOG::LGRemoveFromDbList_( const DBID dbid )
	{
	const IFMP		ifmp			= m_pinst->m_mpdbidifmp[ dbid ];
	FMP*			pfmpT			= &rgfmp[ ifmp ];

	Enforce( ifmp < ifmpMax );

	Assert( m_critLGBuf.FOwner() );
	Assert( !m_fRecovering );
	Assert( pfmpT->FLogOn() );
	Assert( NULL != pfmpT->Pdbfilehdr() );
	Assert( 0 != CmpLgpos( lgposMin, pfmpT->LgposAttach() ) );
	Assert( 0 != CmpLgpos( lgposMin, pfmpT->LgposDetach() ) );
	Assert( m_cLGAttachments > 0 );

	BYTE*			pbSentinel		= m_pbLGDbListBuffer + m_cbLGDbListInUse - 1;
	ATTACHINFO*		pattachinfo		= (ATTACHINFO*)( m_pbLGDbListBuffer + sizeof(LRDBLIST) );

	Assert( (BYTE *)pattachinfo > m_pbLGDbListBuffer );
	Assert( (BYTE *)pattachinfo <= pbSentinel );
	Assert( 0 == *pbSentinel );

	while ( 0 != *( (BYTE *)pattachinfo ) )
		{
		Assert( (BYTE *)pattachinfo > m_pbLGDbListBuffer );
		Assert( (BYTE *)pattachinfo < pbSentinel );

		//	assert not already in list
		if ( dbid == pattachinfo->Dbid() )
			{
			LRDBLIST* const		plrdblist				= (LRDBLIST *)m_pbLGDbListBuffer;
			const ULONG			cbAttachInfoCurr		= sizeof(ATTACHINFO) + pattachinfo->CbNames();
			BYTE*				pbEndOfAttachInfoCurr	= (BYTE *)pattachinfo + cbAttachInfoCurr;
			UtilMemMove(
				pattachinfo,
				pbEndOfAttachInfoCurr,
				pbSentinel - pbEndOfAttachInfoCurr + 1 );	//	+1 for the sentinel

			Assert( m_cbLGDbListInUse > cbAttachInfoCurr );
			m_cbLGDbListInUse -= cbAttachInfoCurr;
			m_cLGAttachments--;

			Assert( plrdblist->CAttachments() > 0 );
			Assert( plrdblist->CbAttachInfo() > cbAttachInfoCurr );
			plrdblist->SetCAttachments( plrdblist->CAttachments() - 1 );
			plrdblist->SetCbAttachInfo( plrdblist->CbAttachInfo() - cbAttachInfoCurr );

			Assert( plrdblist->CAttachments() == m_cLGAttachments );
			Assert( plrdblist->CbAttachInfo() + sizeof(LRDBLIST) == m_cbLGDbListInUse );
			break;
			}

		pattachinfo = (ATTACHINFO *)( (BYTE *)pattachinfo + sizeof(ATTACHINFO) + pattachinfo->CbNames() );

		//	assert dbid must be in the list
		Assert( 0 != *( (BYTE *)pattachinfo ) );
		}

#ifdef DEBUG
	pbSentinel = m_pbLGDbListBuffer + m_cbLGDbListInUse - 1;
	pattachinfo = (ATTACHINFO*)( m_pbLGDbListBuffer + sizeof(LRDBLIST) );
	while ( 0 != *( (BYTE *)pattachinfo ) )
		{
		Assert( (BYTE *)pattachinfo > m_pbLGDbListBuffer );
		Assert( (BYTE *)pattachinfo < pbSentinel );

		//	assert not in list
		Assert( dbid != pattachinfo->Dbid() );
		pattachinfo = (ATTACHINFO *)( (BYTE *)pattachinfo + sizeof(ATTACHINFO) + pattachinfo->CbNames() );
		}
	Assert( (BYTE *)pattachinfo == pbSentinel );
#endif		
	}

LOCAL ERR LOG::ErrLGResizeDbListBuffer_( const BOOL fCopyContents )
	{
	BYTE*		pbOldBuffer	= m_pbLGDbListBuffer;
	ULONG		cbOldBuffer;

	Assert( m_critLGBuf.FOwner() );

	Assert( NULL != pbOldBuffer );
	if ( !fCopyContents )
		{
		//	if not copying contents, release old buffer
		//	up front to permit reuse
		OSMemoryPageFree( pbOldBuffer );
		cbOldBuffer	= m_cbLGDbListInUse;
		}

	m_cbLGDbListInUse = 0;
	m_cLGAttachments = 0;

	//	double the buffer size, up to 64k
	const ULONG		cbDbListBufferGrowMax	= 0x10000;
	if ( m_cbLGDbListBuffer < cbDbListBufferGrowMax )
		{
		m_cbLGDbListBuffer *= 2;
		}
	else
		{
		m_cbLGDbListBuffer += cbDbListBufferGrowMax;
		}
	m_pbLGDbListBuffer = (BYTE *)PvOSMemoryPageAlloc( m_cbLGDbListBuffer, NULL );

	const ERR	errT	= ( NULL != m_pbLGDbListBuffer ? JET_errSuccess : ErrERRCheck( JET_errOutOfMemory ) );

	if ( fCopyContents )
		{
		if ( JET_errSuccess == errT )
			{
			UtilMemCpy( m_pbLGDbListBuffer, pbOldBuffer, cbOldBuffer );
			}

		OSMemoryPageFree( pbOldBuffer );
		}

	if ( errT > 0 )
		{
		//	UNDONE: report log disabled due to out-of-memory updating attachments list
		m_fLGNoMoreLogWrite = fTrue;
		}
	
	return errT;
	}

#else	//	!UNLIMITED_DB

VOID LGLoadAttachmentsFromFMP( INST *pinst, BYTE *pbBuf )
	{
	ATTACHINFO	*pattachinfo	= (ATTACHINFO*)pbBuf;
	
	FMP::EnterCritFMPPool();

	for ( DBID dbidT = dbidUserLeast; dbidT < dbidMax; dbidT++ )
		{
		IFMP ifmp = pinst->m_mpdbidifmp[ dbidT ];

		if ( ifmp >= ifmpMax )
			continue;

		FMP 		*pfmpT			= &rgfmp[ ifmp ];
		ULONG		cbNames;
		const BOOL	fUsePatchchk	= ( pfmpT->Patchchk()
										&& pinst->m_plog->m_fRecovering
										&& pinst->m_plog->m_fRecoveringMode == fRecoveringRedo );

		pfmpT->RwlDetaching().EnterAsReader();
		Assert( pinst->m_plog->m_plgfilehdrT->lgfilehdr.le_lGeneration >= pfmpT->LgposDetach().lGeneration );
		if ( pfmpT->FLogOn() 
			&& ( ( NULL != pfmpT->Pdbfilehdr() 
					&& 0 != CmpLgpos( lgposMin, pfmpT->LgposAttach() )
					&& pinst->m_plog->m_plgfilehdrT->lgfilehdr.le_lGeneration > pfmpT->LgposAttach().lGeneration ) 
					&& ( 0 == CmpLgpos( lgposMin, pfmpT->LgposDetach() )
						|| pinst->m_plog->m_plgfilehdrT->lgfilehdr.le_lGeneration == pfmpT->LgposDetach().lGeneration )
				|| fUsePatchchk ) )
			{

			memset( pattachinfo, 0, sizeof(ATTACHINFO) );
			
			Assert( !pfmpT->FVersioningOff() );
			Assert( !pfmpT->FReadOnlyAttach() );
			Assert( !pattachinfo->FSLVExists() );
			Assert( !pattachinfo->FSLVProviderNotEnabled() );

			pattachinfo->SetDbid( dbidT );

			Assert( pfmpT->FLogOn() );

			if( !pinst->FSLVProviderEnabled() )
				{
				pattachinfo->SetFSLVProviderNotEnabled();
				}

			Assert( !pfmpT->FReadOnlyAttach() );

			if ( NULL != pfmpT->SzSLVName() )
				{
				//	SLV must always have a root
				Assert( NULL != pfmpT->SzSLVRoot() );
				pattachinfo->SetFSLVExists();
				}

			if ( fUsePatchchk )
				{
				pattachinfo->SetDbtime( pfmpT->Patchchk()->Dbtime() );
				pattachinfo->SetObjidLast( pfmpT->Patchchk()->ObjidLast() );
				pattachinfo->SetCpgDatabaseSizeMax( pfmpT->Patchchk()->CpgDatabaseSizeMax() );
				pattachinfo->le_lgposAttach = pfmpT->Patchchk()->lgposAttach;
				pattachinfo->le_lgposConsistent = pfmpT->Patchchk()->lgposConsistent;
				UtilMemCpy( &pattachinfo->signDb, &pfmpT->Patchchk()->signDb, sizeof( SIGNATURE ) );
				}
			else
				{
				pattachinfo->SetDbtime( pfmpT->DbtimeLast() );
				pattachinfo->SetObjidLast( pfmpT->ObjidLast() );
				pattachinfo->SetCpgDatabaseSizeMax( pfmpT->CpgDatabaseSizeMax() );
				pattachinfo->le_lgposAttach = pfmpT->LgposAttach();
				//	 relays DBISetHeaderAfterAttach behavior for resetting lgposConsistent
				if ( 0 == memcmp( &pfmpT->Pdbfilehdr()->signLog, &pinst->m_plog->m_signLog, sizeof(SIGNATURE) ) )
					{
					pattachinfo->le_lgposConsistent = pfmpT->Pdbfilehdr()->le_lgposConsistent;
					}
				else
					{
					pattachinfo->le_lgposConsistent = lgposMin;
					}
				UtilMemCpy( &pattachinfo->signDb, &pfmpT->Pdbfilehdr()->signDb, sizeof( SIGNATURE ) );
				}
			CHAR * szDatabaseName = pfmpT->SzDatabaseName();
			Assert ( szDatabaseName );
			
			if ( pinst->m_plog->m_fRecovering )
				{
				if ( g_fAlternateDbDirDuringRecovery )
					{
					//	HACK: original database name hangs off the end
					//	of the relocated database name
					szDatabaseName += strlen( szDatabaseName ) + 1;
					}
				else
					{
					INT irstmap = pinst->m_plog->IrstmapSearchNewName( szDatabaseName );
					if ( irstmap >= 0 )
						{
						szDatabaseName = pinst->m_plog->m_rgrstmap[irstmap].szDatabaseName;
						}
					}
				}
			Assert( szDatabaseName );

			CHAR * szSLVName = pfmpT->SzSLVName();

			if ( pinst->m_plog->m_fRecovering && szSLVName )
				{
				if ( g_fAlternateDbDirDuringRecovery )
					{
					//	HACK: original SLV name hangs off the end
					//	of the relocated SLV name
					szSLVName += strlen( szSLVName ) + 1;
					}
				else
					{
					INT irstmap = pinst->m_plog->IrstmapSearchNewName( szSLVName );
					if ( irstmap >= 0 )
						{
						szSLVName = pinst->m_plog->m_rgrstmap[irstmap].szDatabaseName;
						}
					Assert( szSLVName );
					}
				}


			strcpy( pattachinfo->szNames, szDatabaseName );
			cbNames = (ULONG) strlen( szDatabaseName ) + 1;

			if ( pattachinfo->FSLVExists() )
				{
				Assert( NULL != szSLVName );
				strcpy( pattachinfo->szNames + cbNames, szSLVName );
				cbNames += (ULONG) strlen( szSLVName ) + 1;

				Assert( NULL != pfmpT->SzSLVRoot() );
				strcpy( pattachinfo->szNames + cbNames, pfmpT->SzSLVRoot() );
				cbNames += (ULONG) strlen( pfmpT->SzSLVRoot() ) + 1;
				}

			pattachinfo->SetCbNames( (USHORT)cbNames );

			//	advance to next attachinfo
			pattachinfo = (ATTACHINFO*)( (BYTE *)pattachinfo + sizeof(ATTACHINFO) + cbNames );

			//	verify we don't overrun buffer (ensure we have enough room for sentinel)
			EnforceSz( pbBuf + cbAttach > (BYTE *)pattachinfo, "Too many databases attached (ATTACHINFO overrun)." );
			}
		pfmpT->RwlDetaching().LeaveAsReader();
		}

	FMP::LeaveCritFMPPool();

	/*	put a sentinal
	/**/
	*(BYTE *)pattachinfo = 0;

	//	UNDONE: next version we will allow it go beyond 4kByte limit
	Assert( pbBuf + cbAttach > (BYTE *)pattachinfo );
	}

#endif	//	UNLIMITED_DB


//	Load attachment information - how and what the db is attached.

ERR ErrLGLoadFMPFromAttachments( INST *pinst, IFileSystemAPI *const pfsapi, BYTE *pbAttach )
	{
	ERR 							err 			= JET_errSuccess;
	const ATTACHINFO				*pattachinfo 	= NULL;
	const BYTE						*pbT;

	for ( pbT = pbAttach; 0 != *pbT; pbT += sizeof(ATTACHINFO) + pattachinfo->CbNames() )
		{
		Assert( pbT - pbAttach < cbAttach );
		pattachinfo = (ATTACHINFO*)pbT;

		CallR ( pinst->m_plog->ErrLGRISetupFMPFromAttach( pfsapi, ppibSurrogate, &pinst->m_plog->m_signLog, pattachinfo) );
		}

	return JET_errSuccess;
	}

VOID LOG::LGFullNameCheckpoint( IFileSystemAPI *const pfsapi, CHAR *szFullName )
	{
	CallS( pfsapi->ErrPathBuild( m_pinst->m_szSystemPath, m_szJet, szChkExt, szFullName ) );
	}

ERR LOG::ErrLGICheckpointInit( IFileSystemAPI *const pfsapi, BOOL *pfGlobalNewCheckpointFile )
	{
	ERR 			err;
	IFileAPI	*pfapiCheckpoint = NULL;
	CHAR			szPathJetChkLog[IFileSystemAPI::cchPathMax];

	*pfGlobalNewCheckpointFile = fFalse;

	Assert( m_pcheckpoint == NULL );
	m_pcheckpoint = (CHECKPOINT *)PvOSMemoryPageAlloc( sizeof(CHECKPOINT), NULL );
	if ( m_pcheckpoint == NULL )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}

	//	Initialize. Used by perfmon counters
	m_pcheckpoint->checkpoint.le_lgposCheckpoint = lgposMin;
	LGFullNameCheckpoint( pfsapi, szPathJetChkLog );
 	err = pfsapi->ErrFileOpen( szPathJetChkLog, &pfapiCheckpoint );

	if ( err == JET_errFileNotFound )
		{
		m_pcheckpoint->checkpoint.le_lgposCheckpoint.le_lGeneration = 1; /* first generation */
		m_pcheckpoint->checkpoint.le_lgposCheckpoint.le_isec = USHORT( sizeof( LGFILEHDR ) / m_cbSec );
		m_pcheckpoint->checkpoint.le_lgposCheckpoint.le_ib = 0;
		cLGCheckpoint.Set( m_pinst, CbOffsetLgpos( m_pcheckpoint->checkpoint.le_lgposCheckpoint, lgposMin ) );

		*pfGlobalNewCheckpointFile = fTrue;
		}
	else
		{
		if ( err >= 0 )
			{
			delete pfapiCheckpoint;
			pfapiCheckpoint = NULL;
			}
		}

	m_fDisableCheckpoint = fFalse;
	err = JET_errSuccess;
	
HandleError:
	if ( err < 0 )
		{
		if ( m_pcheckpoint != NULL )
			{
			OSMemoryPageFree( m_pcheckpoint );
			m_pcheckpoint = NULL;
			}
		}

	Assert( !pfapiCheckpoint );
	return err;
	}


VOID LOG::LGICheckpointTerm( VOID )
	{
	if ( m_pcheckpoint != NULL )
		{
		m_fDisableCheckpoint = fTrue;
		OSMemoryPageFree( m_pcheckpoint );
		m_pcheckpoint = NULL;
		}

	return;
	}


/*	read checkpoint from file.
/**/
ERR LOG::ErrLGReadCheckpoint(
	IFileSystemAPI * const	pfsapi,
	CHAR *					szCheckpointFile,
	CHECKPOINT *			pcheckpoint,
	const BOOL				fReadOnly )
	{
	ERR						err;

	m_critCheckpoint.Enter();

	err = ( fReadOnly ? ErrUtilReadShadowedHeader : ErrUtilReadAndFixShadowedHeader )(
								pfsapi,
								szCheckpointFile,
								(BYTE*)pcheckpoint,
								sizeof(CHECKPOINT) );
	if ( err < 0 )
		{
		/*	it should never happen that both checkpoints in the checkpoint
		/*	file are corrupt.  The only time this can happen is with a
		/*	hardware error.
		/**/
		if ( JET_errFileNotFound == err )
			{
			err = ErrERRCheck( JET_errCheckpointFileNotFound );
			}
		else
			{
			err = ErrERRCheck( JET_errCheckpointCorrupt );
			}
		}
	else if ( m_fSignLogSet )
		{
		if ( memcmp( &m_signLog, &pcheckpoint->checkpoint.signLog, sizeof( m_signLog ) ) != 0 )
			err = ErrERRCheck( JET_errBadCheckpointSignature );
		}

	Call( err );

	// Check if the file indeed is checkpoint file
	if( filetypeUnknown != pcheckpoint->checkpoint.le_filetype // old format
		&& filetypeCHK != pcheckpoint->checkpoint.le_filetype )
		{
		// not a checkpoint file
		Call( ErrERRCheck( JET_errFileInvalidType ) );
		}

HandleError:
	m_critCheckpoint.Leave();
	return err;
	}


/*	write checkpoint to file.
/**/
ERR LOG::ErrLGIWriteCheckpoint( IFileSystemAPI *const pfsapi, CHAR *szCheckpointFile, CHECKPOINT *pcheckpoint )
	{
	ERR		err;
	
	Assert( m_critCheckpoint.FOwner() );
	Assert( pcheckpoint->checkpoint.le_lgposCheckpoint.le_isec >= m_csecHeader );
	Assert( pcheckpoint->checkpoint.le_lgposCheckpoint.le_lGeneration >= 1 );
				
	err = ErrUtilWriteShadowedHeader(	pfsapi, 
										szCheckpointFile, 
										fFalse,
										(BYTE*)pcheckpoint, 
										sizeof( CHECKPOINT ) );

	//	Ignore errors. Bet on that it may be failed temporily (e.g. being locked)	
//	if ( err < 0 )
//		m_fDisableCheckpoint = fTrue;

	return err;
	}

/*	update in memory checkpoint.
/*
/*	computes log checkpoint, which is the lGeneration, isec and ib
/*	of the oldest transaction which either modified a currently-dirty buffer
/*	an uncommitted version (RCE).  Recovery begins redoing from the
/*	checkpoint.
/*
/*	The checkpoint is stored in the checkpoint file, which is rewritten
/*	whenever a isecChekpointPeriod disk sectors are written.
/**/
VOID LOG::LGIUpdateCheckpoint( CHECKPOINT *pcheckpoint )
	{
	PIB		*ppibT;
	LGPOS	lgposCheckpoint;

	Assert( !m_fLogDisabled );

#ifdef DEBUG
	if ( m_fDBGFreezeCheckpoint )
		return;
#endif

	//  we start with the most recent log record on disk.

	// XXX
	// Note that with FASTFLUSH, m_lgposToFlush points to the
	// start of a log record that didn't make it to disk
	// (or to data that hasn't yet been added to the log buffer).

	m_critLGBuf.Enter();
	lgposCheckpoint = m_lgposToFlush;
	m_critLGBuf.Leave();

	/*	find the oldest transaction with an uncommitted update
	 *	must be in critJet to make sure no new transaction are created.
	 */
	m_pinst->m_critPIB.Enter();
	for ( ppibT = m_pinst->m_ppibGlobal; ppibT != NULL; ppibT = ppibT->ppibNext )
		{
		if ( ppibT->level != levelNil &&			/* pib active */
			 ppibT->FBegin0Logged() &&				/* open transaction */
			 CmpLgpos( &ppibT->lgposStart, &lgposCheckpoint ) < 0 )
			{
			lgposCheckpoint = ppibT->lgposStart;
			}
		}
	m_pinst->m_critPIB.Leave();

	/*	find the oldest transaction which dirtied a current buffer
	/*  NOTE:  no concurrency is required as all transactions that could
	/*  NOTE:  dirty any BF are already accounted for by the above code
	/**/

	FMP::EnterCritFMPPool();
	for ( DBID dbid = dbidMin; dbid < dbidMax; dbid++ )
		{
		const IFMP	ifmp	= m_pinst->m_mpdbidifmp[ dbid ];

		if ( ifmp < ifmpMax )
			{
			LGPOS lgposOldestBegin0;
			BFGetLgposOldestBegin0( ifmp, &lgposOldestBegin0 );
			if ( CmpLgpos( &lgposCheckpoint, &lgposOldestBegin0 ) > 0 )
				{
				lgposCheckpoint = lgposOldestBegin0;
				}
			BFGetLgposOldestBegin0( ifmp | ifmpSLV, &lgposOldestBegin0 );
			if ( CmpLgpos( &lgposCheckpoint, &lgposOldestBegin0 ) > 0 )
				{
				lgposCheckpoint = lgposOldestBegin0;
				}


			//	we shouldn't be checkpointing during recovery
			//	except when we're terminating
			//	UNDONE: is there a better way to tell if we're
			//	terminating besides this m_ppibGlobal check?
			Assert( !m_fRecovering
				|| ppibNil == m_pinst->m_ppibGlobal );

			//	update dbtime/trxOldest
			if ( !m_fRecovering
				&& ppibNil != m_pinst->m_ppibGlobal )
				{
				rgfmp[ifmp].UpdateDbtimeOldest();
				}
			}
		}
	FMP::LeaveCritFMPPool();

	/*	set the new checkpoint if it is valid and advancing
	 */
	if (	CmpLgpos( &lgposCheckpoint, &pcheckpoint->checkpoint.le_lgposCheckpoint ) > 0 &&
			lgposCheckpoint.isec != 0 )
		{
		Assert( lgposCheckpoint.lGeneration != 0 );
		pcheckpoint->checkpoint.le_lgposCheckpoint = lgposCheckpoint;
		}
	Assert( pcheckpoint->checkpoint.le_lgposCheckpoint.le_isec >= m_csecHeader );

	/*	set DBMS parameters
	/**/
	m_pinst->SaveDBMSParams( &pcheckpoint->checkpoint.dbms_param );
	Assert( pcheckpoint->checkpoint.dbms_param.le_lLogBuffers );

	// if the checkpoint is on a log file we haven't generated (disk full, etc.)
	// move the checkoint back ONE LOG file
	// anyway the current checkpoint should not be more that one generation ahead of the current log generation
	{
	LONG lCurrentLogGeneration;

	m_critLGBuf.Enter();
	lCurrentLogGeneration = m_plgfilehdr->lgfilehdr.le_lGeneration;

	Assert ( pcheckpoint->checkpoint.le_lgposCheckpoint.le_lGeneration <= lCurrentLogGeneration + 1 );
	pcheckpoint->checkpoint.le_lgposCheckpoint.le_lGeneration = min ( pcheckpoint->checkpoint.le_lgposCheckpoint.le_lGeneration, lCurrentLogGeneration );
	
	m_critLGBuf.Leave();
	}

//	/*	set database attachments
//	/**/
//	LGLoadAttachmentsFromFMP( m_pinst, pcheckpoint->rgbAttach );

	if ( m_lgposFullBackup.lGeneration )
		{
		/*	full backup in progress
		/**/
		pcheckpoint->checkpoint.le_lgposFullBackup = m_lgposFullBackup;
		pcheckpoint->checkpoint.logtimeFullBackup = m_logtimeFullBackup;
		}

	if ( m_lgposIncBackup.lGeneration )
		{
		/*	incremental backup in progress
		/**/
		pcheckpoint->checkpoint.le_lgposIncBackup = m_lgposIncBackup;
		pcheckpoint->checkpoint.logtimeIncBackup = m_logtimeIncBackup;
		}

	return;
	}


/*	update checkpoint file.
/**/
ERR LOG::ErrLGUpdateCheckpointFile( IFileSystemAPI *const pfsapi, BOOL fUpdatedAttachment )
	{
	ERR		err			= JET_errSuccess;
	LGPOS	lgposCheckpointT;
	CHAR	szPathJetChkLog[IFileSystemAPI::cchPathMax];
	BOOL	fCheckpointUpdated;
	CHECKPOINT *pcheckpointT;

	if ( m_fDisableCheckpoint
		|| m_fLogDisabled
		|| !m_fLGFMPLoaded
		|| m_fLGNoMoreLogWrite
		|| m_pinst->FInstanceUnavailable() )
		return JET_errSuccess;

	pcheckpointT = (CHECKPOINT *)PvOSMemoryPageAlloc( sizeof(CHECKPOINT), NULL );
	if ( pcheckpointT == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	
	m_critCheckpoint.Enter();

	/*	save checkpoint
	/**/
	lgposCheckpointT = m_pcheckpoint->checkpoint.le_lgposCheckpoint;
	*pcheckpointT = *m_pcheckpoint;

	/*	update checkpoint
	/**/
	LGIUpdateCheckpoint( pcheckpointT );
	if ( CmpLgpos( &lgposCheckpointT, &pcheckpointT->checkpoint.le_lgposCheckpoint ) < 0 )
		{
		fCheckpointUpdated = fTrue;
		}
	else
		{
		fCheckpointUpdated = fFalse;
		}

	/*	if checkpoint unchanged then return JET_errSuccess
	/**/
	if ( fUpdatedAttachment || fCheckpointUpdated )
		{
		//	no in-memory checkpoint change if failed to write out to any of
		//	the database headers.

		BOOL fSkippedAttachDetach;
		
		// Now disallow header update by other threads (log writer or checkpoint advancement)
		// 1. For the log writer it is OK to generate a new log w/o updating the header as no log operations
		// for this db will be logged in new logs
		// 2. For the checkpoint: don't advance the checkpoint if db's header weren't update  <- THIS CASE

		Call( ErrLGIUpdateGenRequired(
			pfsapi,
			pcheckpointT->checkpoint.le_lgposCheckpoint.le_lGeneration,
			m_plgfilehdr->lgfilehdr.le_lGeneration,
			m_plgfilehdr->lgfilehdr.tmCreate,
			&fSkippedAttachDetach ) );

		if ( fSkippedAttachDetach )
			{
			Call ( ErrERRCheck( errSkippedDbHeaderUpdate ) );
			}

		Assert( m_fSignLogSet );
		pcheckpointT->checkpoint.signLog = m_signLog;
		
		// Write filetypeCHK to header
		pcheckpointT->checkpoint.le_filetype = filetypeCHK;

		LGFullNameCheckpoint( pfsapi, szPathJetChkLog );
		Call( ErrLGIWriteCheckpoint( pfsapi, szPathJetChkLog, pcheckpointT ) );
		*m_pcheckpoint = *pcheckpointT;
		cLGCheckpoint.Set( m_pinst, CbOffsetLgpos( m_pcheckpoint->checkpoint.le_lgposCheckpoint, lgposMin ) );
		}
		
HandleError:
	m_critCheckpoint.Leave();
	OSMemoryPageFree( pcheckpointT );
	return err;
	}

VOID
LOG::CHECKSUMINCREMENTAL::ChecksumBytes( const BYTE* const pbMin, const BYTE* const pbMax )
	{
	const UINT		cbitsPerBytes = 8;
	const ULONG32	ulChecksum = UlChecksumBytes( pbMin, pbMax, 0 );
	const ULONG32	ulChecksumAdjusted = _rotl( ulChecksum, m_cLeftRotate );
	
	m_cLeftRotate = ( ULONG( ( pbMax - pbMin ) % sizeof( ULONG32 ) ) * cbitsPerBytes + m_cLeftRotate ) % ( sizeof( ULONG32 ) * cbitsPerBytes );

	m_ulChecksum ^= ulChecksumAdjusted;
	}

//  ================================================================
ULONG32 LOG::UlChecksumBytes( const BYTE * const pbMin, const BYTE * const pbMax, const ULONG32 ulSeed )
//  ================================================================
//
//  The entire aligned NATIVE_WORD containing pbMin and pbMax must be accessible
//
//  For speed we do the checksum NATIVE_WORD aligned. UlChecksum would end up containing the
//  checksum for all the NATIVE_WORDs containing the bytes we want to checksum, possibly
//  including some unwanted bytes at the start and end. To strip out the unwanted bytes
//  we compute a mask to XOR in. The BYTES we want to keep are replaced in the mask by 0,
//  otherwise we use the original bytes.
//
//  At the end we rotate the checksum to take into account the alignment of the start byte.
//
	{
//	Assert( FHostIsLittleEndian() );
	Assert( pbMin <= pbMax );

	//	special case
	if ( pbMin == pbMax )
		return ulSeed;

	const NATIVE_WORD cBitsInByte = 8;
	const INT cLoop = 16; /* 8 */

	//  round down to the start of the NATIVE_WORD containing the start pointer
	const NATIVE_WORD * pwMin = (NATIVE_WORD *) ( ( (NATIVE_WORD)pbMin / sizeof( NATIVE_WORD ) ) * sizeof( NATIVE_WORD ) );

	//  round up to the start of the next NATIVE_WORD that does not contain any of the end pointer
	const NATIVE_WORD * const pwMax = (NATIVE_WORD *) ( ( ( (NATIVE_WORD)pbMax + sizeof( NATIVE_WORD ) - 1 ) / sizeof( NATIVE_WORD ) ) * sizeof( NATIVE_WORD ) );

	Assert( pwMin < pwMax );

	//  calculate the number of bits in the last NATIVE_WORD that we do _not_ want
	const NATIVE_WORD cbitsUnusedLastWord = ( sizeof( NATIVE_WORD ) - ( (NATIVE_WORD)pbMax % sizeof( NATIVE_WORD ) ) ) * cBitsInByte * ( (NATIVE_WORD)pwMax != (NATIVE_WORD)pbMax );
	Assert( cbitsUnusedLastWord < sizeof( NATIVE_WORD ) * cBitsInByte );
	const NATIVE_WORD wByteMaskLast	= ~( (NATIVE_WORD)(~0) >> cbitsUnusedLastWord );

	//  calculate the number of bits in the first NATIVE_WORD that we _do_ want
	const NATIVE_WORD cbitsUsedFirstWord = ( sizeof( NATIVE_WORD ) - ( (NATIVE_WORD)pbMin % sizeof( NATIVE_WORD ) ) ) * cBitsInByte;
	Assert( cbitsUsedFirstWord > 0 );

	//  strip out the unused bytes in the first NATIVE_WORD. do this first to avoid cache misses
	//  take ~0 to get 0xffff...
	//  right shift to get zeroes in the bytes we want to remove
	//  OR with the original NATIVE_WORD
	// right shifting by 32 is undefined, so do it in two steps
	const NATIVE_WORD wByteMaskFirst	= (NATIVE_WORD)(~0) >> ( cbitsUsedFirstWord - 1 ) >> 1;
	const NATIVE_WORD wFirst			= *(LittleEndian<NATIVE_WORD>*)pwMin;
	const NATIVE_WORD wMaskFirst		= wByteMaskFirst & wFirst;

	NATIVE_WORD wChecksum = 0;
	NATIVE_WORD wChecksumT = 0;

	const ULONG cw = ULONG( pwMax - pwMin );
	pwMin -= ( ( cLoop - ( cw % cLoop ) ) & ( cLoop - 1 ) );

	//	'^' can be calculated with either endian format. Convert
	//	the checksum result for BE at the end instead of convert for
	//	each word.
	
	if( 8 == cLoop )
		{
		switch ( cw % cLoop )
			{	
			while ( 1 )
				{
				case 0:	//  we can put this at the top because pdwMax != pdwMin
					wChecksum  ^= pwMin[0];
				case 7:
					wChecksumT ^= pwMin[1];
				case 6:
					wChecksum  ^= pwMin[2];
				case 5:
					wChecksumT ^= pwMin[3];
				case 4:
					wChecksum  ^= pwMin[4];
				case 3:
					wChecksumT ^= pwMin[5];
				case 2:
					wChecksum  ^= pwMin[6];
				case 1:
					wChecksumT ^= pwMin[7];
					pwMin += cLoop;
					if( pwMin >= pwMax )
						{
						goto EndLoop;
						}
				}
			}
		}
	else if ( 16 == cLoop )
		{
		switch ( cw % cLoop )
			{	
			while ( 1 )
				{
				case 0:	//  we can put this at the top because pdwMax != pdwMin
					wChecksum  ^= pwMin[0];
				case 15:
					wChecksumT ^= pwMin[1];
				case 14:
					wChecksum  ^= pwMin[2];
				case 13:
					wChecksumT ^= pwMin[3];
				case 12:
					wChecksum  ^= pwMin[4];
				case 11:
					wChecksumT ^= pwMin[5];
				case 10:
					wChecksum  ^= pwMin[6];
				case 9:
					wChecksumT ^= pwMin[7];
				case 8:
					wChecksum  ^= pwMin[8];
				case 7:
					wChecksumT ^= pwMin[9];
				case 6:
					wChecksum  ^= pwMin[10];
				case 5:
					wChecksumT ^= pwMin[11];
				case 4:
					wChecksum  ^= pwMin[12];
				case 3:
					wChecksumT ^= pwMin[13];
				case 2:
					wChecksum  ^= pwMin[14];
				case 1:
					wChecksumT ^= pwMin[15];
					pwMin += cLoop;
					if( pwMin >= pwMax )
						{
						goto EndLoop;
						}
				}
			}
		}

EndLoop:
	wChecksum ^= wChecksumT;

	//	It is calculated in little endian form, convert to machine
	//	endian for other arithmatic operations.

	wChecksum = ReverseBytesOnBE( wChecksum );

	//	Take the first unaligned portion into account
	
	wChecksum ^= wMaskFirst;

	//  strip out the unused bytes in the last NATIVE_WORD. do this last to avoid cache misses
	//  take ~0 to get 0xffff..
	//  right shift to get zeroes in the bytes we want to keep
	//  invert (make the zeroes 0xff)
	//  OR with the original NATIVE_WORD
	const NATIVE_WORD wLast			= *((LittleEndian<NATIVE_WORD>*)pwMax-1);
	const NATIVE_WORD wMaskLast		= wByteMaskLast & wLast;
	wChecksum ^= wMaskLast;

	ULONG32 ulChecksum;

	if( sizeof( ulChecksum ) != sizeof( wChecksum ) )
		{
		Assert( sizeof( NATIVE_WORD ) == sizeof( ULONG64 ) );
		const NATIVE_WORD wUpper = ( wChecksum >> ( sizeof( NATIVE_WORD ) * cBitsInByte / 2 ) );
		const NATIVE_WORD wLower = wChecksum & 0x00000000FFFFFFFF;
		Assert( wUpper == ( wUpper & 0x00000000FFFFFFFF ) );
		Assert( wLower == ( wLower & 0x00000000FFFFFFFF ) );

		wChecksum = wUpper ^ wLower;
		Assert( wChecksum == ( wChecksum & 0x00000000FFFFFFFF ) );
		}
	else
		{
		Assert( sizeof( NATIVE_WORD ) == sizeof( ULONG32 ) );
		}
	ulChecksum = ULONG32( wChecksum );

	//  we want the checksum we would have gotten if we had done this unaligned
	//  simply rotate the checksum by the appropriate number of bytes
	ulChecksum = _rotl( ulChecksum, ULONG( cbitsUsedFirstWord ) );

	//  now we have rotated, we can XOR in the seed
	ulChecksum ^= ulSeed;

	return ulChecksum;
	}


#ifndef RTM

//  ================================================================
ULONG32 LOG::UlChecksumBytesNaive( const BYTE * pbMin, const BYTE * pbMax, const ULONG32 ulSeed )
//  ================================================================
	{
	const INT cBitsInByte = 8;

	ULONG32 ulChecksum = ulSeed;

	INT cul = INT( pbMax - pbMin ) / 4;
	const Unaligned< ULONG32 >* pul				= (Unaligned< ULONG32 >*)pbMin;
	const Unaligned< ULONG32 >* const pulMax	= pul + cul;
	while( pul < pulMax )
		{
		ulChecksum ^= *pul++;
		}

	const BYTE * pb = (BYTE *)(pulMax);
	if ( FHostIsLittleEndian() )
		{
		INT ib = 0;
		while( pb < pbMax )
			{
			const BYTE b	= *pb;
			const ULONG32 w	= b;
			ulChecksum ^= ( w << ( ib * cBitsInByte ) );
			++ib;
			Assert( ib < 4 );
			++pb;
			}
		}
	else
		{
		INT ib = 3;
		while( pb < pbMax )
			{
			const BYTE b	= *pb;
			const ULONG32 w	= b;
			ulChecksum ^= ( w << ( ib * cBitsInByte ) );
			--ib;
			Assert( ib >= 0 );
			++pb;
			}

		ulChecksum = ReverseBytes( ulChecksum );
		}

	return ulChecksum;
	}


//  ================================================================
ULONG32 LOG::UlChecksumBytesSlow( const BYTE * pbMin, const BYTE * pbMax, const ULONG32 ulSeed )
//  ================================================================
	{
	const INT cBitsInByte = 8;

	ULONG32 ulChecksum = ulSeed;

	INT ib = 0;
	const BYTE * pb = pbMin;
	while( pb < pbMax )
		{
		const BYTE b	= *pb;
		const ULONG32 w	= b;
		ulChecksum ^= ( w << ( ib * cBitsInByte ) );
		ib++;
		ib %= 4;
		++pb;
		}

	return ulChecksum;
	}


//  ================================================================
BOOL LOG::TestChecksumBytesIteration( const BYTE * pbMin, const BYTE * pbMax, const ULONG32 ulSeed )
//  ================================================================
	{
	const ULONG32 ulChecksum		= UlChecksumBytes( pbMin, pbMax, ulSeed );
	const ULONG32 ulChecksumSlow	= UlChecksumBytesSlow( pbMin, pbMax, ulSeed );
	const ULONG32 ulChecksumNaive	= UlChecksumBytesNaive( pbMin, pbMax, ulSeed );
//	const ULONG32 ulChecksumSpencer	= UlChecksumBytesSpencer( pbMin, pbMax, ulSeed );

	CHECKSUMINCREMENTAL	ck;
	ck.BeginChecksum( ulSeed );
	ck.ChecksumBytes( pbMin, pbMax );
	const ULONG32 ulChecksumIncremental = ck.EndChecksum();

	const BYTE* const pbMid = pbMin + ( ( pbMax - pbMin ) + 2 - 1 ) / 2;	// round up to at least 1 byte if cb == 1
	ck.BeginChecksum( ulSeed );
	ck.ChecksumBytes( pbMin, pbMid );
	ck.ChecksumBytes( pbMid, pbMax );
	const ULONG32 ulChecksumIncremental2 = ck.EndChecksum();

	const BYTE* const pbMax1 = pbMin + ( ( pbMax - pbMin ) + 3 - 1 ) / 3;
	const BYTE* const pbMax2 = pbMin + ( 2 * ( pbMax - pbMin ) + 3 - 1 ) / 3;
	ck.BeginChecksum( ulSeed );
	ck.ChecksumBytes( pbMin, pbMax1 );
	ck.ChecksumBytes( pbMax1, pbMax2 );
	ck.ChecksumBytes( pbMax2, pbMax );
	const ULONG32 ulChecksumIncremental3 = ck.EndChecksum();

	return ( ulChecksum == ulChecksumSlow && 
//			 ulChecksum == ulChecksumSpencer &&
			 ulChecksum == ulChecksumNaive &&
			 ulChecksum == ulChecksumIncremental &&
			 ulChecksum == ulChecksumIncremental2 &&
			 ulChecksum == ulChecksumIncremental3 );
	}


LOCAL const BYTE const rgbTestChecksum[] = {
	0x80, 0x23, 0x48, 0x04, 0x1B, 0x13, 0xA0, 0x03, 0x78, 0x55, 0x4C, 0x54, 0x88, 0x18, 0x4B, 0x63,
	0x98, 0x05, 0x4B, 0xC7, 0x36, 0xE5, 0x12, 0x00, 0xB1, 0x90, 0x1F, 0x02, 0x85, 0x05, 0xE5, 0x04,
	0x80, 0x55, 0x4C, 0x04, 0x00, 0x31, 0x60, 0x89, 0x01, 0x5E, 0x39, 0x66, 0x80, 0x55, 0x12, 0x98,
	0x18, 0x00, 0x00, 0x00, 0x48, 0xE5, 0x12, 0x00, 0x9C, 0x65, 0x1B, 0x04, 0x80, 0x55, 0x4C, 0x04,

	0x60, 0xE5, 0x12, 0x00, 0xDF, 0x7F, 0x1F, 0x04, 0x80, 0x55, 0x4C, 0x04, 0x00, 0x72, 0x91, 0x45,
	0x80, 0x23, 0x48, 0x04, 0x1B, 0x13, 0xA0, 0x03, 0x78, 0x55, 0x4C, 0x54, 0x88, 0x18, 0x4B, 0x63,
	0x98, 0x05, 0x4B, 0xC7, 0x36, 0xE5, 0x12, 0x00, 0xB1, 0x90, 0x1F, 0x02, 0x85, 0x05, 0xE5, 0x04,
	0x80, 0x55, 0x4C, 0x04, 0x00, 0x31, 0x60, 0x89, 0x01, 0x5E, 0x39, 0x66, 0x80, 0x55, 0x12, 0x98

//	128 bytes total
	};


//  ================================================================
BOOL LOG::TestChecksumBytes()
//  ================================================================
	{

	//	perform all possible iterations of checksumming
	//
	//	assume N is the number of bytes in the array
	//	the resulting number of iterations is approximately: ((n)(n+1)) / 2 
	//
	//	for 128 bytes, there are about 16,500 iterations, each of decreasing length
	int i;
	int j;
	for( i = 0; i < sizeof( rgbTestChecksum ) - 1; ++i )
		{
		for( j = i + 1; j < sizeof( rgbTestChecksum ); ++j )
			{
			if ( !TestChecksumBytesIteration( rgbTestChecksum + i, rgbTestChecksum + j, j ) )
				return fFalse;
			}
		}
	return fTrue;
	}


#endif	//	!RTM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_log\logredo.cxx ===
//	LOGREDO - logical part of soft/hard recovery
//	============================================
//
//	ENTRY POINT(S):
//		ErrLGSoftStart
//
//	PURPOSE:
//		Logical part of soft/hard recovery. Replays logfiles, starting from 
//		the begining of logfile pointed by checkpoint. If there is no checkpoint
//		starts from the begining of the lowest available log generation file.
//
//		Main loop is through ErrLRIRedoOperations
//
//	BASE PROTOTYPES:
//		class LOG in log.hxx
//
//	OFTEN USED PROTOTYPES:
//		classes LRxxxx in logapi.hxx
//
/////////////////////////////////////////////

#include "std.hxx"
#include "_ver.hxx"
#include "_space.hxx"
#include "_bt.hxx"
 

const DIRFLAG	fDIRRedo = fDIRNoLog | fDIRNoVersion;

//	checks if page needs a redo of operation
//
INLINE BOOL FLGINeedRedo( const CSR& csr, const DBTIME dbtime )
	{
 	Assert( csr.FLatched() );
	Assert( csr.Dbtime() == csr.Cpage().Dbtime() );
	
	return dbtime > csr.Dbtime();
	}

//	checks if page needs a redo of operation
//
INLINE BOOL FLGNeedRedoCheckDbtimeBefore(
	const CSR&		csr,
	const DBTIME	dbtime,
	const DBTIME	dbtimeBefore,
	ERR*			const perr )
	{
	const BOOL		fRedoNeeded		= FLGINeedRedo( csr, dbtime );

	*perr = JET_errSuccess;

	Assert( dbtimeNil != dbtimeBefore );
	Assert( dbtimeInvalid != dbtimeBefore );
	if ( fRedoNeeded )
		{
		// dbtimeBefore an page should be the same one as in the record
		Assert( csr.Dbtime() == dbtimeBefore );
		if ( csr.Dbtime() != dbtimeBefore )
			{
			*perr = ErrERRCheck( csr.Dbtime() < dbtimeBefore ? JET_errDbTimeTooOld : JET_errDbTimeTooNew );
			}			
		}
	else
		{
		Assert( dbtime > dbtimeBefore );
		Assert( csr.Dbtime() >= dbtime );
		}

	Assert( fRedoNeeded || JET_errSuccess == *perr );
	return fRedoNeeded;
	}

//	checks if page needs a redo of operation
//
INLINE BOOL FLGNeedRedoPage( const CSR& csr, const DBTIME dbtime )
	{
	return FLGINeedRedo( csr, dbtime );
	}

#ifdef DEBUG
//	checks if page needs a redo of operation
//
INLINE BOOL FAssertLGNeedRedo( const CSR& csr, const DBTIME dbtime, const DBTIME dbtimeBefore )
	{
	ERR 		err;
	const BOOL	fRedoNeeded	= FLGNeedRedoCheckDbtimeBefore( csr, dbtime, dbtimeBefore, &err );

	return ( fRedoNeeded && JET_errSuccess == err );
	}
#endif // DEBUG

LOCAL PATCH *PpatchLGSearch( PATCHLST **rgppatchlst, DBTIME dbtimeRedo, PGNO pgno, DBID dbid )
	{
	PATCHLST	*ppatchlst = rgppatchlst[ IppatchlstHash( pgno, dbid ) ];
	PATCH		*ppatch = NULL;

	while ( ppatchlst != NULL && 
			( ppatchlst->pgno != pgno ||
			  ppatchlst->dbid != dbid ) )
		{
		ppatchlst = ppatchlst->ppatchlst;
		}
	
	if ( ppatchlst != NULL )
		{
		ppatch = ppatchlst->ppatch;
		while( ppatch != NULL && ppatch->dbtime < dbtimeRedo )
			{
			PATCH *ppatchT = ppatch;
			ppatch = ppatch->ppatch;
			delete ppatchT;
			}
		ppatchlst->ppatch = ppatch;
		}
	return ppatch;
	}


//	access page RIW latched
//	remove dependence
//
INLINE ERR ErrLGIAccessPage(
	PIB				*ppib,
	CSR				*pcsr,
	const IFMP		ifmp,
	const PGNO		pgno )
	{
	Assert( pgnoNull != pgno );
	Assert( NULL != ppib );
	Assert( !pcsr->FLatched() );

	const ERR		err		= pcsr->ErrGetRIWPage( ppib, ifmp, pgno );
	switch( err )
		{
		case JET_errOutOfMemory:
		case wrnBFPageFault:
		case wrnBFPageFlushPending:
		case JET_errReadVerifyFailure:
		case JET_errDiskIO:
		case JET_errDiskFull:
		case JET_errPageNotInitialized:
		case JET_errFileIOBeyondEOF:
 			break;
		default:
			CallS( err );
		}
			
	return err;
	}


//	retrieves new page from database or patch file
//		
ERR LOG::ErrLGRIAccessNewPage(
	PIB *				ppib,
	CSR *				pcsrNew,
	const IFMP			ifmp,
	const PGNO			pgnoNew,
	const DBTIME		dbtime,
	const SPLIT * const	psplit,
	const BOOL			fRedoSplitPage,
	BOOL *				pfRedoNewPage )
	{
	//	access new page
	//	if hard-restore
	//		if page exists
	//			if page's dbtime < dbtime of oper
	//				release page
	//				get new page
	//			else
	//				check patch file
	//		if must check patch file
	//			get patch for page
	//			if patch page exists
	//				Assert patch page's dbtime >= dbtime of oper
	//				replace page with patch
	//				acquire RIW latch
	//			else
	//				get new page
	//		else
	//			if page's dbtime < dbtime of oper
	//				release page
	//				get new page
	//	else if page exists
	//		if page's dbtime < dbtime of oper
	//			release page
	//			get new page
	//	else
	//		get new page
	//
	ERR					err;
	const BOOL			fDependencyRequired		= ( NULL == psplit
													|| FBTISplitDependencyRequired( psplit ) );

	//	assume new page needs to be redone
	*pfRedoNewPage = fTrue;

	err = ErrLGIAccessPage( ppib, pcsrNew, ifmp, pgnoNew );

	if ( m_fHardRestore )
		{
		//	We can only consult the patch file if the split page does not
		//	need to be redone, otherwise we might end up grabbing a copy of
		//	the new page that's way too advanced.  If the split page needs
		//	to be redone, then don't bother going to the patch file and just
		//	force the new page to be redone as well.
		//	Note that if a dependency is not required, NEVER check the patch
		//	file -- the page will simply get recreated if necessary.
		BOOL	fCheckPatch		= !fRedoSplitPage && fDependencyRequired;

		if ( err >= 0 )
			{
			//	see if page is already up-to-date
			Assert( latchRIW == pcsrNew->Latch() );

			*pfRedoNewPage = FLGNeedRedoPage( *pcsrNew, dbtime );
			if ( *pfRedoNewPage )
				{
				//	fall through to check the patch and see if we can find the
				//	up-to-date page there
				pcsrNew->ReleasePage();
				}
			else
				{
				//	page is up-to-date for this operation, don't bother trying
				//	to patch it.
				fCheckPatch = fFalse;
				}
			}


		//	At this point, if fCheckPatch is TRUE, then either the new page
		//	was successfully read, but it's not up-to-date, or the new page
		//	could not successfully be read.
		if ( fCheckPatch )
			{
			PATCH	*ppatch;

			Assert( !fRedoSplitPage );
			Assert( fDependencyRequired );

			Assert( fRestorePatch == m_fRestoreMode || fRestoreRedo == m_fRestoreMode );

			AssertSz ( fSnapshotNone == m_fSnapshotMode, "No patch file for snapshot restore" ); 
			ppatch = PpatchLGSearch( m_rgppatchlst, dbtime, pgnoNew, rgfmp[ifmp].Dbid() );

			if ( ppatch != NULL )
				{
#ifdef ELIMINATE_PAGE_PATCHING
				//	should be impossible
				EnforceSz( fFalse, "Patching no longer supported." );
				return ErrERRCheck( JET_errBadPatchPage );
#else
				//	patch exists and is later than operation
				//
				Assert( ppatch->dbtime >= dbtime );
				CallR( ErrLGIPatchPage( ppib, pgnoNew, ifmp, ppatch ) );

				CallS( ErrLGIAccessPage( ppib, pcsrNew, ifmp, pgnoNew ) ); 
				Assert( latchRIW == pcsrNew->Latch() );

				*pfRedoNewPage = FLGNeedRedoPage( *pcsrNew, dbtime );
				if ( *pfRedoNewPage )
					{
					Assert( fFalse );	//	shouldn't need to redo the page, since page's dbtime is >= operation dbtime
					pcsrNew->ReleasePage();
					}
#endif	//	ELIMINATE_PAGE_PATCHING
				}
			}
		}

	else if ( err >= 0 )
		{
		//	get new page if page is older than operation
		//
		Assert( latchRIW == pcsrNew->Latch() );

		*pfRedoNewPage = FLGNeedRedoPage( *pcsrNew, dbtime );
		if ( *pfRedoNewPage )
			{
			Assert( fRedoSplitPage || !fDependencyRequired );
			pcsrNew->ReleasePage();
			}
		}

	Assert( !*pfRedoNewPage || !pcsrNew->FLatched() );
	
	//	if new page needs to be redone, then so should split page
	//	(because split page is dependent on new page)
	if ( *pfRedoNewPage && !fRedoSplitPage && fDependencyRequired )
		{
		Assert( fFalse );	//	should be impossible
		return ErrERRCheck( JET_errDatabaseBufferDependenciesCorrupted );
		}
	
	return JET_errSuccess;
	}


ERR ErrDBStoreDBPath( INST *pinst, IFileSystemAPI *const pfsapi, CHAR *szDBName, CHAR **pszDBPath )
	{
	CHAR	szFullName[IFileSystemAPI::cchPathMax];
	SIZE_T	cb;
	CHAR	*sz;

	if ( pfsapi->ErrPathComplete( szDBName, szFullName ) < 0 )
		{
		// UNDONE: should be illegal name or name too long etc.
		return ErrERRCheck( JET_errDatabaseNotFound );
		}

	cb = strlen(szFullName) + 1;
	if ( !( sz = static_cast<CHAR *>( PvOSMemoryHeapAlloc( cb ) ) ) )
		{
		*pszDBPath = NULL;
		return ErrERRCheck( JET_errOutOfMemory );
		}
	UtilMemCpy( sz, szFullName, cb );
	Assert( sz[cb - 1] == '\0' );
	if ( *pszDBPath != NULL )
		OSMemoryHeapFree( *pszDBPath );
	*pszDBPath = sz;

	return JET_errSuccess;
	}

//	Returns ppib for a given procid from log record.
//
//			PARAMETERS      procid          process id of session being redone
//                          pppib           out ppib
//
//      RETURNS         JET_errSuccess or error from called routine
//

CPPIB *LOG::PcppibLGRIOfProcid( PROCID procid )
	{
	CPPIB   *pcppib = m_rgcppib;
	CPPIB   *pcppibMax = pcppib + m_ccppib;

	//	find pcppib corresponding to procid if it exists
	//
	for ( ; pcppib < pcppibMax; pcppib++ )
		{
		if ( procid == pcppib->procid )
			{
			Assert( procid == pcppib->ppib->procid );
			return pcppib;
			}
		}
	return NULL;
	}


//+------------------------------------------------------------------------
//
//      ErrLGRIPpibFromProcid
//      =======================================================================
//
//      ERR ErrLGRIPpibFromProcid( procid, pppib )
//
//      Initializes a redo information block for a session to be redone.
//      A BeginSession is performed and the corresponding ppib is stored
//      in the block.  Start transaction level and transaction level
//      validity are initialized.  Future references to this sessions
//      information block will be identified by the given procid.
//
//      PARAMETERS      procid  process id of session being redone
//                              pppib
//
//      RETURNS         JET_errSuccess, or error code from failing routine
//
//-------------------------------------------------------------------------
ERR LOG::ErrLGRIPpibFromProcid( PROCID procid, PIB **pppib )
	{
	ERR		err = JET_errSuccess;

	//	if no record for procid then start new session
	//
	if ( ( *pppib = PpibLGRIOfProcid( procid ) ) == ppibNil )
		{
		//	check if have run out of ppib table lookup
		//	positions. This could happen if between the
		//	failure and redo, the number of system PIBs
		//	set in CONFIG.DAE has been changed.
		//
		if ( m_pcppibAvail >= m_rgcppib + m_ccppib )
			{
			Assert( 0 );    /* should never happen */
			return ErrERRCheck( JET_errTooManyActiveUsers );
			}
		m_pcppibAvail->procid = procid;

		//	use procid as unique user name
		//
		CallR( ErrPIBBeginSession( m_pinst, &m_pcppibAvail->ppib, procid, fFalse ) );
		Assert( procid == m_pcppibAvail->ppib->procid );
		*pppib = m_pcppibAvail->ppib;

		m_pcppibAvail++;
		}

	return JET_errSuccess;
	}


//	gets fucb from hash table that meets given criteria
//
FUCB * TABLEHFHASH::PfucbGet( IFMP ifmp, PGNO pgnoFDP, PROCID procid, BOOL fSpace ) const
	{
	const UINT uiHash = UiHash( pgnoFDP, ifmp, procid );

	TABLEHF	*ptablehf = rgtablehf[ uiHash ];

	for ( ; ptablehf != NULL; ptablehf = ptablehf->ptablehfNext )
		{
		FUCB *pfucb = ptablehf->pfucb;
		if ( pfucb->ifmp == ifmp &&
			 PgnoFDP( pfucb ) == pgnoFDP &&
			 pfucb->ppib->procid == procid &&
			 ( fSpace && FFUCBSpace( pfucb ) || 
			   !fSpace && !FFUCBSpace( pfucb ) ) )
			{
			return pfucb;
			}
		}

	Assert( ptablehf == NULL );
	return pfucbNil;
	}


//	creates new fucb with given criteria
//	links fucb to hash table
//
ERR	TABLEHFHASH::ErrCreate(
	PIB			*ppib,
	const IFMP	ifmp,
	const PGNO	pgnoFDP,
	const OBJID	objidFDP,
	const BOOL	fUnique,
	const BOOL	fSpace,
	FUCB		**ppfucb )
	{
	Assert( pfucbNil == PfucbGet( ifmp, pgnoFDP, ppib->procid, fSpace ) );

	ERR			err		= JET_errSuccess;
	
	TABLEHF	*ptablehf = (TABLEHF *) PvOSMemoryHeapAlloc( sizeof( TABLEHF ) );
	if ( NULL == ptablehf )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	FUCB		*pfucb	= pfucbNil;
	FCB			*pfcb;
	BOOL		fState;
	const UINT	uiHash	=  UiHash( pgnoFDP, ifmp, ppib->procid );

	//	create fucb
	//
	Call( ErrFUCBOpen( ppib, ifmp, &pfucb ) );
	pfucb->pvtfndef = &vtfndefIsam;

	//	set ifmp
	//
	pfucb->ifmp	= ifmp;

	Assert( pfcbNil == pfucb->u.pfcb );

	//	get fcb for table, if one exists
	//
	pfcb = FCB::PfcbFCBGet( ifmp, pgnoFDP, &fState );
	Assert( pfcbNil == pfcb || fFCBStateInitialized == fState );
	if ( pfcbNil == pfcb )
		{
		//	there exists no fcb for FDP
		//		allocate new fcb as a regular table FCB 
		//		and set up for FUCB
		//
		err = FCB::ErrCreate( ppib, ifmp, pgnoFDP, &pfcb );
		Assert( err != errFCBExists );	//	should not get this here since we are single-threaded
		Call( err );
		Assert( pfcb != pfcbNil );
		Assert( pfcb->IsLocked() );
		Assert( pfcb->WRefCount() == 0 );
		Assert( !pfcb->UlFlags() );

		Assert( objidNil == pfcb->ObjidFDP() );
		pfcb->SetObjidFDP( objidFDP );

		if ( pgnoSystemRoot == pgnoFDP )
			{
			pfcb->SetTypeDatabase();
			}
		else
			{
			pfcb->SetTypeTable();
			}

		//	FCB always initialised as unique, though
		//	this flag is ignored during recovery
		//	(uniqueness is strictly determined by
		//	FUCB's flags)
		Assert( pfcb->FUnique() );		// FCB always initialised as unique
		if ( !fUnique )
			pfcb->SetNonUnique();
		pfcb->Unlock();

		//	insert the FCB into the global list

		pfcb->InsertList();

		//	link in the FUCB to new FCB
		//
		pfcb->Link( pfucb );
		Assert( pfcb->WRefCount() >= 1 );

		//	complete the creation of this FCB

		pfcb->Lock();
		pfcb->CreateComplete();
		pfcb->Unlock();
		}
	else
		{
		//	link in the FUCB to new FCB
		//
		pfcb->Link( pfucb ); 

		//	release FCB for the PfcbFCBGet() call
		//
		Assert( pfcb->WRefCount() > 1 );
		pfcb->Release();
		}

	//	set unique-ness in FUCB if requested
	//
	Assert( !FFUCBSpace( pfucb ) );
	Assert( ( fUnique && FFUCBUnique( pfucb ) )
		|| ( !fUnique && !FFUCBUnique( pfucb ) ) );

	if ( fSpace )
		{
		FUCBSetOwnExt( pfucb );
		}
	
	pfucb->dataSearchKey.Nullify();
	pfucb->cColumnsInSearchKey = 0;
	KSReset( pfucb );

	*ppfucb = pfucb;
	
	//	link to hash
	//
	Assert( pfucb != pfucbNil );
	ptablehf->ptablehfNext 	= rgtablehf[ uiHash ];
	ptablehf->pfucb			= pfucb;
	rgtablehf[uiHash]		= ptablehf;

HandleError:
	if ( err < 0 )
		{
		OSMemoryHeapFree( ptablehf );
		if ( pfucb != pfucbNil )
			{
			FUCBClose( pfucb );
			}
		}

	return err;
	}


//	deletes fucb from hash
//
VOID TABLEHFHASH::Delete( FUCB *pfucb )
	{
	const PGNO	pgnoFDP = PgnoFDP( pfucb );
	const IFMP	ifmp	= pfucb->ifmp;
	Assert( pfucb == PfucbGet( ifmp, pgnoFDP, pfucb->ppib->procid, FFUCBSpace( pfucb ) ) );

	const UINT	uiHash = UiHash( pgnoFDP, ifmp, pfucb->ppib->procid );

	Assert( NULL != rgtablehf[uiHash] );
	
	TABLEHF		**pptablehfPrev = &(rgtablehf[uiHash]);
	
	for ( ; (*pptablehfPrev) != NULL ; pptablehfPrev = &((*pptablehfPrev)->ptablehfNext) )
		{
		if ( (*pptablehfPrev)->pfucb == pfucb )
			{
			//	unlink tablehf
			//
			TABLEHF	*ptablehfDelete = *pptablehfPrev;
			*pptablehfPrev = ptablehfDelete->ptablehfNext;

			//	release tablehf
			//
			OSMemoryHeapFree( ptablehfDelete );
			return;
			}
		}
		
	Assert( fFalse );
	return;
	}

	
//	closes all cursors created on database during recovery by given session
//	releases corresponding table handles
//
VOID TABLEHFHASH::Purge( PIB *ppib, IFMP ifmp )
	{
	Assert( PinstFromPpib( ppib )->m_plog->m_ptablehfhash != NULL );
	
	FUCB	*pfucb = ppib->pfucbOfSession;
	FUCB	*pfucbNext;

	for ( ; pfucb != pfucbNil; pfucb = pfucbNext )
		{
		pfucbNext = pfucb->pfucbNextOfSession;

		if ( ifmp == pfucb->ifmp &&
			 pfucb->ppib->procid == ppib->procid )
			{
			Assert( pfucb->ppib == ppib );
			Assert( pfucb == this->PfucbGet( ifmp, 
										   PgnoFDP( pfucb ), 
										   ppib->procid, 
										   FFUCBSpace( pfucb ) ) );
			this->Delete( pfucb );

			//	unlink and close fucb
			//
			FCBUnlink( pfucb );
			FUCBClose( pfucb );
			}
		}

	return;
	}


//	releases all references to this table
//
VOID TABLEHFHASH::Purge( IFMP ifmp, PGNO pgnoFDP )
	{
	BOOL	fState;
	FCB		*pfcb = FCB::PfcbFCBGet( ifmp, pgnoFDP, &fState );
	
	if ( pfcbNil == pfcb )
		{
		return;
		}

	FUCB	*pfucb;
	FUCB	*pfucbNext;
	
	//	close every cursor opened on FCB
	//
	for ( pfucb = pfcb->Pfucb(); pfucb != pfucbNil; pfucb = pfucbNext )
		{
		pfucbNext = pfucb->pfucbNextOfFile;
		Assert( pfucb == this->PfucbGet( ifmp, 
										   PgnoFDP( pfucb ), 
										   pfucb->ppib->procid, 
										   FFUCBSpace( pfucb ) ) );
		this->Delete( pfucb );
		
		//	unlink and close fucb
		//
		FCBUnlink( pfucb );
		FUCBClose( pfucb );
		}

	Assert( 1 == pfcb->WRefCount() );
	pfcb->Release();

	VERNullifyAllVersionsOnFCB( pfcb );

	pfcb->PrepareForPurge();
	pfcb->Purge();
	return;
	}


//	releases and closes all unversioned tables in hash
//
VOID TABLEHFHASH::PurgeUnversionedTables( )
	{
	INT		i;
	
	for ( i = 0; i < ctablehf; i++ )
		{
		TABLEHF		*ptablehf;
		TABLEHF		*ptablehfNext; 
		
		for ( ptablehf = rgtablehf[i]; ptablehf != NULL; ptablehf = ptablehfNext )
			{
			ptablehfNext = ptablehf->ptablehfNext;
			
			FUCB	*pfucb = ptablehf->pfucb;
			Assert( pfucb != pfucbNil );
			Assert( pfucb->ppib != ppibNil );

			if ( !FFUCBVersioned( pfucb ) )
				{
				this->Delete( pfucb );

				//	unlink and close fucb
				//
				FCBUnlink( pfucb );
				FUCBClose( pfucb );
				}
			}
		}
		
	return;
	}

	
//	Returns pfucb for given pib and FDP.
//
//  PARAMETERS		ppib	pib of session being redone
//					fdp		FDP page for logged page
//					ppfucb	out FUCB for open table for logged page
//
//  RETURNS			JET_errSuccess or error from called routine
//

LOCAL ERR ErrLGRIGetFucb(
	TABLEHFHASH *ptablehfhash,
	PIB			*ppib,
	const IFMP	ifmp,
	const PGNO	pgnoFDP,
	const OBJID	objidFDP,
	const BOOL	fUnique,
	const BOOL	fSpace,
	FUCB		**ppfucb )
	{
	FUCB    	*pfucb		= ptablehfhash->PfucbGet( ifmp, pgnoFDP, ppib->procid, fSpace );

	Assert( ptablehfhash != NULL );
	
	//	allocate an all-purpose fucb for this table, if not already allocated
	//
	if ( NULL == pfucb )
		{
		//	fucb not created
		//
		ERR	err	= ptablehfhash->ErrCreate(
									ppib, 
									ifmp, 
									pgnoFDP,
									objidFDP,
									fUnique, 
									fSpace, 
									&pfucb );
		Assert( errFCBAboveThreshold != err );
		Assert( errFCBTooManyOpen != err );
		
		if ( JET_errTooManyOpenTables == err
			|| JET_errOutOfCursors == err )
			{
			//	release tables without uncommitted versions and retry
			//
			ptablehfhash->PurgeUnversionedTables( );
			err = ptablehfhash->ErrCreate(
									ppib, 
									ifmp, 
									pgnoFDP,
									objidFDP,
									fUnique, 
									fSpace, 
									&pfucb );
			}

		CallR( err );
		}
		
	pfucb->bmCurr.Nullify();

	//	reset copy buffer and flags
	//
	Assert( !FFUCBDeferredChecksum( pfucb ) );
	Assert( !FFUCBUpdateSeparateLV( pfucb ) );
	FUCBResetUpdateFlags( pfucb );

	Assert( pfucb->ppib == ppib );

#ifdef DEBUG
	if ( fSpace )
		{
		Assert( FFUCBUnique( pfucb ) );
		Assert( FFUCBSpace( pfucb ) );
		}
	else
		{
		Assert( !FFUCBSpace( pfucb ) );
		if ( fUnique )
			{
			Assert( FFUCBUnique( pfucb ) );
			}
		else
			{
			Assert( !FFUCBUnique( pfucb ) );
			}
		}
#endif		

	*ppfucb = pfucb;
	return JET_errSuccess;
	}


VOID LOG::LGEndPpibAndTableHashGlobal(  )
	{	
	delete [] m_rgcppib;
	m_pcppibAvail =
	m_rgcppib = NULL;
	m_ccppib = 0;

	if ( m_ptablehfhash != NULL )
		{
		m_ptablehfhash->Purge();
		OSMemoryHeapFree( m_ptablehfhash );
		m_ptablehfhash = NULL;
		}		
	}


ERR LOG::ErrLGRIInitSession(
	IFileSystemAPI *const	pfsapi,
	DBMS_PARAM				*pdbms_param,
	BYTE					*pbAttach,
	LGSTATUSINFO			*plgstat,
	const REDOATTACHMODE	redoattachmode )
	{
	ERR						err				= JET_errSuccess;
	CPPIB					*pcppib;
	CPPIB					*pcppibMax;
	DBID					dbid;

	/*	set log stored db environment
	/**/
	if ( pdbms_param )
		m_pinst->RestoreDBMSParams( pdbms_param );

	CallR( ErrITSetConstants( m_pinst ) );

	CallR( m_pinst->ErrINSTInit() );

#ifdef UNLIMITED_DB
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		//	should not have any FMPs allocated at this point
		Assert( ifmpMax == m_pinst->m_mpdbidifmp[ dbid ] );
		}
#else
	//	restore the attached dbs
	Assert( pbAttach );
	if ( redoattachmodeInitBeforeRedo == redoattachmode )
		{
		err = ErrLGLoadFMPFromAttachments( m_pinst, pfsapi, pbAttach );
		CallS( err );
		Call( err );
		}
	else
		{
		Assert( 0 == *pbAttach );
		}

	/*	Make sure all the attached database are consistent!
	 */
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP		ifmp		= m_pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;

		FMP			*pfmp		= &rgfmp[ifmp];
		CHAR		*szDbName;
		REDOATTACH	redoattach;

		if ( !pfmp->FInUse() || !pfmp->Patchchk() )
			continue;

		szDbName = pfmp->SzDatabaseName();
		Assert ( szDbName );

		Assert( redoattachmodeInitBeforeRedo == redoattachmode );

		if ( m_fHardRestore || m_irstmapMac > 0 )
			{
			if ( 0 > IrstmapSearchNewName( szDbName ) )
				{
				/*	not in the restore map, set to skip it.
				 */
				Assert( pfmp->Pdbfilehdr() == NULL );
				pfmp->SetSkippedAttach();
				err = JET_errSuccess;
				continue;
				}
			}

		Assert( !pfmp->FReadOnlyAttach() );
		Call( ErrLGRICheckAttachedDb(
					pfsapi,
					ifmp,
					&m_signLog,
					&redoattach,
					redoattachmode ) );
		Assert( NULL != pfmp->Pdbfilehdr() );

		switch ( redoattach )
			{
			case redoattachNow:
				Assert( !pfmp->FReadOnlyAttach() );
				Call( ErrLGRIRedoAttachDb(
							pfsapi,
							ifmp,
							pfmp->Patchchk()->CpgDatabaseSizeMax(),
							redoattachmode ) );
				break;

			case redoattachCreate:
			default:
				Assert( fFalse );	//	should be impossible, but as a firewall, set to defer the attachment
			case redoattachDefer:
				Assert( !pfmp->FReadOnlyAttach() );
				LGRISetDeferredAttachment( ifmp );
				break;
			}

		/* keep attachment info and update it. */
		Assert( pfmp->Patchchk() != NULL );
		}
#endif		

	/*	initialize CPPIB structure
	/**/
	Assert( g_lSessionsMax > 0 );
	m_ccppib = m_pinst->m_lSessionsMax + cpibSystem;
	Assert( m_rgcppib == NULL );
	m_rgcppib = new CPPIB[m_ccppib];
	if ( m_rgcppib == NULL )
		{
		m_ccppib = 0;
		Call ( ErrERRCheck( JET_errOutOfMemory ) );
		}

	pcppibMax = m_rgcppib + m_ccppib;
	for ( pcppib = m_rgcppib; pcppib < pcppibMax; pcppib++ )
		{
		pcppib->procid = procidNil;
		pcppib->ppib = NULL;
		}
	m_pcppibAvail = m_rgcppib;

	//	allocate and initialize global hash for table handles
	//
	if ( NULL == m_ptablehfhash )
		{
		m_ptablehfhash = (TABLEHFHASH *) PvOSMemoryHeapAlloc( sizeof( TABLEHFHASH ) );
		if ( NULL == m_ptablehfhash )
			{
			LGEndPpibAndTableHashGlobal(  );
			Call ( ErrERRCheck( JET_errOutOfMemory ) );
			}

		new ( m_ptablehfhash ) TABLEHFHASH;
		}
		
	Assert ( JET_errSuccess <= err );
	return err;
HandleError:
	Assert ( JET_errSuccess > err );

	// clean up instance resources allocated in ErrINSTInit
	m_fLogDisabledDueToRecoveryFailure = fTrue;
	m_pinst->ErrINSTTerm( termtypeError );
	m_fLogDisabledDueToRecoveryFailure = fFalse;

	return err;
	}


ERR ErrLGICheckDatabaseFileSize( IFileSystemAPI *const pfsapi, PIB *ppib, IFMP ifmp )
	{
	ERR		err;
	FMP		*pfmp	= rgfmp + ifmp;

	err = ErrDBSetLastPageAndOpenSLV( pfsapi, ppib, ifmp, fFalse );
	if ( JET_errFileNotFound == err )
		{
		//	UNDONE: The file should be there. Put this code to get around
		//	UNDONE: such that DS database file that was not detached can
		//	UNDONE: continue recovering.
		const CHAR	*rgszT[1];
		rgszT[0] = pfmp->SzDatabaseName();
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY, FILE_NOT_FOUND_ERROR_ID, 1, rgszT );
		}
	else if( err >= JET_errSuccess )
		{
		CallS( err );
		
		/*	set file size to what the FMP (and OwnExt) says it should be.
		 */
		const PGNO	pgnoLast	= pfmp->PgnoLast();
		err = ErrIONewSize( ifmp, pgnoLast );
		}

	return err;
	}

LOCAL VOID LGICleanupTransactionToLevel0( PIB * const ppib )
	{
	//	there should be no more RCEs
	Assert( 0 == ppib->level );
	Assert( prceNil == ppib->prceNewest );
	for ( FUCB *pfucb = ppib->pfucbOfSession; pfucb != pfucbNil; pfucb = pfucb->pfucbNextOfSession )
		{
		FUCBResetVersioned( pfucb );
		}

	ppib->trxBegin0		= trxMax;
	ppib->lgposStart	= lgposMax;
	ppib->ResetDistributedTrx();
	VERSignalCleanup( ppib );

	//	empty the list of expected RCEs
	ppib->RemoveAllDeferredRceid();
	}

ERR LOG::ErrLGEndAllSessionsMacro( BOOL fLogEndMacro )
	{
	ERR		err 		= JET_errSuccess;
	CPPIB   *pcppib 	= m_rgcppib;
	CPPIB   *pcppibMax 	= m_rgcppib + m_ccppib;

	Assert( pcppib != NULL || m_ccppib == 0 );
	for ( ; pcppib < pcppibMax; pcppib++ )
		{
		PIB *ppib = pcppib->ppib;

		if ( ppib == NULL )
			break;

		Assert( sizeof(JET_SESID) == sizeof(ppib) );
		CallR( ppib->ErrAbortAllMacros( fLogEndMacro ) );
		}
		
	return JET_errSuccess;
	}

ERR LOG::ErrLGRIEndAllSessionsWithError( )
	{
	ERR		err;

	CallR( ErrLGEndAllSessionsMacro( fFalse /* fLogEndMacro */ ) );

	(VOID) m_pinst->m_pver->ErrVERRCEClean();

	Assert( m_rgcppib != NULL );
	Assert( m_ptablehfhash != NULL );		
	LGEndPpibAndTableHashGlobal();

	/*	term with checkpoint updates
	/**/
	CallS( m_pinst->ErrINSTTerm( termtypeError ) );

	return err;
	}

LOCAL VOID LGReportAttachedDbMismatch( const CHAR* const szDbName, const BOOL fEndOfRecovery )
	{
	CHAR		szErrT[8];
	const CHAR*	rgszT[2]		= { szErrT, szDbName };

	Assert( NULL != szDbName );
	Assert( strlen( szDbName ) > 0 );

	sprintf( szErrT, "%d", JET_errAttachedDatabaseMismatch );

	UtilReportEvent(
		eventError,
		LOGGING_RECOVERY_CATEGORY,
		( fEndOfRecovery ?
				ATTACHED_DB_MISMATCH_END_OF_RECOVERY_ID :
				ATTACHED_DB_MISMATCH_DURING_RECOVERY_ID ),
		2,
		rgszT );
	}

/*
 *      Ends redo session.
 *  If fEndOfLog, then write log records to indicate the operations
 *  for recovery. If fPass1 is true, then it is for phase1 operations,
 *  otherwise for phase 2.
 */

ERR LOG::ErrLGRIEndAllSessions( IFileSystemAPI *const pfsapi, BOOL fEndOfLog, const LE_LGPOS *ple_lgposRedoFrom, BYTE *pbAttach )
	{
	ERR		err			= JET_errSuccess;
	CPPIB   *pcppib;
	CPPIB   *pcppibMax;
	PIB		*ppib		= ppibNil;

	BOOL fNeedCallNSTTerm = fTrue;

	BOOL fNeedSoftRecovery = fFalse;


	//	UNDONE: is this call needed?
	//
	//(VOID)ErrVERRCEClean( );

	//	Set current time to attached db's dbfilehdr

	for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP ifmp = m_pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;
			
		FMP *pfmp = &rgfmp[ ifmp ];

		//	If there is no redo operations on an attached db, then
		//	pfmp->dbtimeCurrent may == 0, i.e. no operation, then do
		//	not change pdbfilehdr->dbtime

		if ( pfmp->Pdbfilehdr() != NULL &&
			 pfmp->DbtimeCurrentDuringRecovery() > pfmp->DbtimeLast() )
			{
			pfmp->SetDbtimeLast( pfmp->DbtimeCurrentDuringRecovery() );
			}
		}

#ifndef RTM

	//	make sure there are no deferred RCEs for any session	
	pcppib = m_rgcppib;
	pcppibMax = pcppib + m_ccppib;
	for ( ; pcppib < pcppibMax; pcppib++ )
		{
		ppib = pcppib->ppib;

		if ( ppib == NULL )
			break;

		ppib->AssertNoDeferredRceid();
		}
#endif	//	!RTM		
	
	CallR ( ErrLGEndAllSessionsMacro( fTrue /* fLogEndMacro */ ) );

	pcppib = m_rgcppib;
	pcppibMax = pcppib + m_ccppib;
	for ( ; pcppib < pcppibMax; pcppib++ )
		{
		ppib = pcppib->ppib;

		if ( ppib == NULL )
			break;

#ifdef DTC
		if ( ppib->FPreparedToCommitTrx() )
			{
			JET_CALLBACK	pfn		= m_pinst->m_pfnRuntimeCallback;

			Assert( ppib->FDistributedTrx() );
			Assert( 1 == ppib->level );

			if ( NULL == pfn )
				{
				return ErrERRCheck( JET_errDTCMissingCallbackOnRecovery );
				}

			const ERR	errCallback		= (*pfn)(
												JET_sesidNil,
												JET_dbidNil,
												JET_tableidNil,
												JET_cbtypDTCQueryPreparedTransaction,
												ppib->PvDistributedTrxData(),
												(VOID *)ppib->CbDistributedTrxData(),
												NULL,
												NULL );
			switch( errCallback )
				{
				case JET_wrnDTCCommitTransaction:
					{
					if ( TrxCmp( m_pinst->m_trxNewest, ppib->trxBegin0 ) > 0 )
						{
						ppib->trxCommit0 = m_pinst->m_trxNewest;
						}
					else
						{
						ppib->trxCommit0 = ppib->trxBegin0 + 2;
						m_pinst->m_trxNewest = ppib->trxCommit0;
						}
						
					LGPOS	lgposCommit;
					CallR( ErrLGCommitTransaction( ppib, 0, &lgposCommit ) );

					VERCommitTransaction( ppib );
					LGICleanupTransactionToLevel0( ppib );
					break;
					}

				case JET_wrnDTCRollbackTransaction:
					//	EndSession() below will force rollback, but must the fact we're going
					//	to rollback in case we crash before fully rolling-back (to ensure that
					//	on next recovery, DTC won't direct us to commit the transaction instead)
					CallR( ErrLGPrepareToRollback( ppib ) );
					break;
				
				default:
					//	UNDONE: add eventlog
					err = ErrERRCheck( JET_errDTCCallbackUnexpectedError );
					return err;
				}
			}
#endif	//	DTC

		Assert( sizeof(JET_SESID) == sizeof(ppib) );
		CallR( ErrIsamEndSession( (JET_SESID)ppib, 0 ) );
		pcppib->procid = procidNil;
		pcppib->ppib = NULL;
		}

	// (VOID) m_pinst->m_pver->ErrVERRCEClean( );
	(VOID) m_pinst->m_pver->ErrVERRCEClean( );

	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid ++ )
		{
		if ( m_pinst->m_mpdbidifmp[ dbid ] < ifmpMax )
			{
			CallR( ErrBFFlush( m_pinst->m_mpdbidifmp[ dbid ] ) );
			CallR( ErrBFFlush( m_pinst->m_mpdbidifmp[ dbid ] | ifmpSLV ) );
			}
		}

	/*	Detach all the faked attachment. Detach all the databases that were restored
	 *	to new location. Attach those database with new location.
	 */
		{
		Assert( ppibNil == ppib );
		CallR( ErrPIBBeginSession( m_pinst, &ppib, procidNil, fFalse ) );

		Assert( !ppib->FRecoveringEndAllSessions() );
		ppib->SetFRecoveringEndAllSessions();

		for ( dbid = dbidUserLeast; fEndOfLog && dbid < dbidMax; dbid++ )
			{
			const IFMP	ifmp	= m_pinst->m_mpdbidifmp[ dbid ];
			if ( ifmp >= ifmpMax )
				continue;

			FMP *pfmp = &rgfmp[ ifmp ];

			if ( m_fHardRestore && pfmp->FSkippedAttach() )
				{
				Assert (!pfmp->Pdbfilehdr());
				Assert (!pfmp->FAttached() );

				// if the skipped database is attached in other instance
				// that instance will take care of the database state
				if ( ifmpMax == FMP::ErrSearchAttachedByNameSz( pfmp->SzDatabaseName() ) )
					{
					// the database isn't attached (in this process at least !)
					// and we still have the attach pending (skipped) so the database should be
					// - inconsistent after a crash and we need to allow soft recovery
					// - we haven't played forward but in this case the current logs are temporary logs
					// - we played forward but some logs were deleted at the end, we don't know if
					// the db is consistent or not but we should allow play forward just to check that
					fNeedSoftRecovery = fTrue;
					}
				}
			}
			

		for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			const IFMP	ifmp	= m_pinst->m_mpdbidifmp[ dbid ];
			if ( ifmp >= ifmpMax )
				continue;

			FMP *pfmp = &rgfmp[ ifmp ];

			if ( pfmp->Pdbfilehdr()
				&& CmpLgpos( &lgposMax, &pfmp->Pdbfilehdr()->le_lgposAttach ) != 0 )
				{
				//	make sure the attached database's size is consistent with the file size.

				Call( ErrLGICheckDatabaseFileSize( pfsapi, ppib, ifmp ) );
				}

			if ( !fEndOfLog )
				continue;


			/*	if a db is attached. Check if it is restored to a new location.
			 */
			if ( ( m_fHardRestore || m_irstmapMac > 0 ) && pfmp->Pdbfilehdr() )
				{
				// the recovered databases should shutdown: as we will not have a term record
				// if we will softrecover un-restored databases, we need the 
				// detach for the restored databases
				if ( fNeedSoftRecovery )
					{
					Call( ErrIsamDetachDatabase( (JET_SESID) ppib, NULL, pfmp->SzDatabaseName(), 0 ) );
					}
				}
			else
				{
				/*	for each faked attached database, log database detachment
				/*	This happen only when someone restore a database that was compacted,
				/*	attached, used, then crashed. When restore, we ignore the compact and
				/*	attach after compact since the db does not match. At the end of restore
				/*	we fake a detach since the database is not recovered.
				/**/
				if ( !pfmp->Pdbfilehdr() && pfmp->Patchchk() )
					{
					Assert( pfmp->Patchchk() );
					Assert( pfmp->FInUse() );

					if ( pfmp->FDeferredAttach() )
						{
						//	we deferred an attachment because the db was missing,
						//	because it was brought to a consistent state beyond
						//	the attachment point.  However, we've now hit the
						//	end of the log and the attachment is still outstanding.
						//	UNDONE: Need eventlog entry
						if ( !m_fLastLRIsShutdown )
							{
#ifdef IGNORE_BAD_ATTACH							
							const BOOL	fIgnoreMissingDB	= m_fReplayingIgnoreMissingDB;
#else
							const BOOL	fIgnoreMissingDB	= fFalse;
#endif
							if ( m_fReplayingIgnoreMissingDB )
								{
								LGPOS lgposRecT;
								Call( ErrLGForceDetachDB( ppib, ifmp, fLRForceDetachCloseSessions, &lgposRecT ) );
								}
							else
								{
								LGReportAttachedDbMismatch( pfmp->SzDatabaseName(), fTrue );
								AssertTracking();
								Call( ErrERRCheck( JET_errAttachedDatabaseMismatch ) );
								}
							}
						}
					else
						{
						//	only reason to have outstanding ATCHCHK
						//	is for deferred attachment or because hard restore skipped
						//	some attachments
						Assert( pfmp->FSkippedAttach() );
						}

					/*	clean up the fmp entry
					/**/
					pfmp->ResetFlags();
					pfmp->Pinst()->m_mpdbidifmp[ pfmp->Dbid() ] = ifmpMax;

				//	SLV name/root, if any, is allocated in same space as db name
					OSMemoryHeapFree( pfmp->SzDatabaseName());
					pfmp->SetSzDatabaseName( NULL );
					pfmp->SetSzSLVName( NULL );
					pfmp->SetSzSLVRoot( NULL );

					OSMemoryHeapFree( pfmp->Patchchk() );
					pfmp->SetPatchchk( NULL );
					}

				if ( pfmp->PatchchkRestored() )
					{
					OSMemoryHeapFree( pfmp->PatchchkRestored() );
					pfmp->SetPatchchkRestored( NULL );
					}
				}
			}

		PIBEndSession( ppib );
		ppib = ppibNil;
		}

	Assert( m_rgcppib != NULL );
	Assert( m_ptablehfhash != NULL );		
	LGEndPpibAndTableHashGlobal(  );
	
	if ( fEndOfLog && !fNeedSoftRecovery )
		{
		/*	enable checkpoint updates
		/**/
		m_fLGFMPLoaded = fTrue;
		}

	*pbAttach = 0;

	/*	term with checkpoint updates
	/**/
	CallS( m_pinst->ErrINSTTerm( fNeedSoftRecovery?termtypeError:termtypeNoCleanUp ) );
	
	m_pinst->m_pbAttach = NULL;
	fNeedCallNSTTerm = fFalse;
	
	/*	stop checkpoint updates
	/**/	
	m_fLGFMPLoaded = fFalse;

	if ( fEndOfLog )
		{

		if ( !fNeedSoftRecovery )
			{
			LE_LGPOS le_lgposRecoveryUndo;
			le_lgposRecoveryUndo = m_lgposRecoveryUndo;
			Call( ErrLGRecoveryQuit(
				this,
				&le_lgposRecoveryUndo,
				ple_lgposRedoFrom,
				m_fHardRestore ) );
			}
		else if ( NULL != m_pcheckpointDeleted )
			{
			// write back the checkpoint file
			CHAR	szPathJetChkLog[IFileSystemAPI::cchPathMax];
			
			Assert( m_fSignLogSet );
			Assert ( 0 == memcmp( &(m_pcheckpointDeleted->checkpoint.signLog), &m_signLog, sizeof(SIGNATURE) ) );
		
			m_critCheckpoint.Enter();
			LGFullNameCheckpoint( pfsapi, szPathJetChkLog );
			err = ErrLGIWriteCheckpoint( pfsapi, szPathJetChkLog, m_pcheckpointDeleted );
			m_critCheckpoint.Leave();
			Call ( err );
			}
			
		if ( NULL != m_pcheckpointDeleted )
			{
			OSMemoryPageFree ((void *) m_pcheckpointDeleted);
			m_pcheckpointDeleted = NULL;
			}
		}
		
	/*	Note: flush is needed in case a new generation is generated and
	/*	the global variable szLogName is set while it is changed to new names.
	/*	critical section not requested, not needed
	/**/

	// The above comment is misleading, because we really want to flush the log
	// so that all our data will hit the disk if we've logged a lrtypRecoveryQuit.
	// If it doesn't hit the disk, we'll be missing a quit record on disk and we'll
	// be in trouble. Note that calling ErrLGFlushLog() will not necessarily flush
	// all of the log buffers.
	if ( m_fRecovering && fRecoveringRedo == m_fRecoveringMode )
		{
		// If we're in redo mode, we didn't log anything, so there's no need
		// to try and flush. We don't want to call ErrLGWaitAllFlushed() when
		// we're in redo mode.
		}
	else
		{
		err = ErrLGWaitAllFlushed( pfsapi );
		}

HandleError:

	if ( ppib != ppibNil )
		PIBEndSession( ppib );

	LGEndPpibAndTableHashGlobal(  );

	if (fNeedCallNSTTerm)
		{
		Assert ( JET_errSuccess > err);
		m_fLogDisabledDueToRecoveryFailure = fTrue;
		m_pinst->ErrINSTTerm( termtypeError );
		m_fLogDisabledDueToRecoveryFailure = fFalse;
		}
		
	return err;
	}


#define cbSPExt 30

#ifdef DEBUG
void LOG::LGRITraceRedo(const LR *plr)
	{
	/* easier to debug */
	if ( m_fDBGTraceRedo )
		{
		g_critDBGPrint.Enter();

		if ( GetNOP() > 0 )
			{
			CheckEndOfNOPList( plr, this );
			}

		if ( 0 == GetNOP() || plr->lrtyp != lrtypNOP )
			{
			PrintLgposReadLR();
			ShowLR(plr, this);
			}

		g_critDBGPrint.Leave();
		}
	}
#endif


#ifdef DEBUG
#ifndef RFS2

#undef CallJ
#undef CallR

#define CallJ(f, hndlerr)                                                                       \
		{                                                                                                       \
		if ((err = (f)) < 0)                                                            \
			{                                                                                               \
			AssertSz(0,"Debug Only: ignore this assert");   \
			goto hndlerr;                                                                   \
			}                                                                                               \
		}

#define CallR(f)                                                                                        \
		{                                                                                                       \
		if ((err = (f)) < 0)                                                            \
			{                                                                                               \
			AssertSz(0,"Debug Only: ignore this assert");   \
			return err;                                                                             \
			}                                                                                               \
		}

#endif
#endif


VOID LGIReportEventOfReadError( IFMP ifmp, PGNO pgno, ERR err )
	{
	CHAR szT1[16];
	CHAR szT2[16];
	const CHAR *rgszT[3];

	rgszT[0] = rgfmp[ifmp].SzDatabaseName();
	sprintf( szT1, "%d", pgno );
	rgszT[1] = szT1;
	sprintf( szT2, "%d", err );
	rgszT[2] = szT2;
 
	UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
		RESTORE_DATABASE_READ_PAGE_ERROR_ID, 3, rgszT );
	}


ERR ErrLGIStoreLogRec( PIB *ppib, DBTIME dbtime, const LR *plr )
	{
	INT cb = CbLGSizeOfRec( plr );

	return ppib->ErrInsertLogrec( dbtime, plr, cb );
	}


//	Check redo condition to decide if we need to skip redoing
//	this log record.

ERR LOG::ErrLGRICheckRedoCondition(
	const DBID		dbid,					//	dbid from the log record.
	DBTIME			dbtime,					//	dbtime from the log record.
	OBJID			objidFDP,				//	objid so far,
	PIB				*ppib,					//	returned ppib
	const BOOL		fUpdateCountersOnly,	//	if TRUE, operation will NOT be redone, but still need to update dbtimeLast and objidLast counters
	BOOL			*pfSkip )				//	returned skip flag
	{
	ERR				err;
	INST * const	pinst	= PinstFromPpib( ppib );
	const IFMP		ifmp	= pinst->m_mpdbidifmp[ dbid ];

	//	By default we want to skip it.

	*pfSkip = fTrue;

	//	check if we have to redo the database.

	if ( ifmp >= ifmpMax )
		return JET_errSuccess;

	FMP * const		pfmp	= rgfmp + ifmp;

	if ( NULL == pfmp->Pdbfilehdr() )
		return JET_errSuccess;

	//	We haven't reach the point the database is attached.

	if ( CmpLgpos( &m_lgposRedo, &pfmp->Pdbfilehdr()->le_lgposAttach ) <= 0 )
		return JET_errSuccess;

	//	check if database needs opening.

	if ( !fUpdateCountersOnly
		&& !FPIBUserOpenedDatabase( ppib, dbid ) )
		{
		IFMP	ifmpT	= ifmp;
		CallR( ErrDBOpenDatabase( ppib, 
								  pfmp->SzDatabaseName(), 
								  &ifmpT, 
								  NO_GRBIT ) );
		Assert( ifmpT == ifmp );
		}
	
	//	Keep track of lasgest dbtime so far, since the number could be
	//	logged out of order, we need to check if dbtime > than dbtimeCurrent.

	Assert( m_fRecoveringMode == fRecoveringRedo );
	if ( dbtime > pfmp->DbtimeCurrentDuringRecovery() )
		pfmp->SetDbtimeCurrentDuringRecovery( dbtime );
	if ( objidFDP > pfmp->ObjidLast() )
		pfmp->SetObjidLast( objidFDP );

	if ( fUpdateCountersOnly )
		{
		Assert( *pfSkip );
		}
	else
		{
		//	We do need to redo this log record.
		*pfSkip = fFalse;
		}

	return JET_errSuccess;
	}


ERR LOG::ErrLGRICheckRedoCondition2(
	const PROCID	procid,
	const DBID		dbid,					//	dbid from the log record.
	DBTIME			dbtime,					//	dbtime from the log record.
	OBJID			objidFDP,
	LR				*plr,
	PIB				**pppib,				//	returned ppib
	BOOL			*pfSkip )				//	returned skip flag
	{
	ERR				err;
	PIB				*ppib;
	BOOL			fUpdateCountersOnly		= fFalse;	//	if TRUE, redo not needed, but must still update dbtimeLast and objidLast counters

	*pfSkip = fTrue;

	CallR( ErrLGRIPpibFromProcid( procid, &ppib ) );
	*pppib = ppib;

	if ( ppib->FAfterFirstBT() )
		{
		Assert( NULL != plr || !ppib->FMacroGoing( dbtime ) );
		if ( ppib->FMacroGoing( dbtime )
			&& lrtypUndoInfo != plr->lrtyp )
			{
			return ErrLGIStoreLogRec( ppib, dbtime, plr );
			}
		}
	else
		{
		//	BUGFIX (X5:178265 and NT:214397): it's possible
		//	that there are no Begin0's between the first and
		//	last log records, in which case nothing needs to
		//	get redone.  HOWEVER, the dbtimeLast and objidLast
		//	counters in the db header would not have gotten
		//	flushed (they only get flushed on a DetachDb or a
		//	clean shutdown), so we must still track these
		//	counters during recovery so that we can properly
		//	update the database header on RecoveryQuit (since
		//	we pass TRUE for the fUpdateCountersOnly param to
		//	ErrLGRICheckRedoCondition() below, that function
		//	will do nothing but update the counters for us).
		fUpdateCountersOnly = fTrue;
		}

	return ErrLGRICheckRedoCondition(
			dbid,
			dbtime,
			objidFDP,
			ppib,
			fUpdateCountersOnly,
			pfSkip );
	}


//	sets dbtime on write-latched pages
//
INLINE VOID LGRIRedoDirtyAndSetDbtime( CSR *pcsr, DBTIME dbtime )
	{
	if ( latchWrite == pcsr->Latch() )
		{
		pcsr->Dirty();
		pcsr->SetDbtime( dbtime );
		}
	}

LOCAL ERR ErrLGRIRedoFreeEmptyPages(
	FUCB				* const pfucb,
	LREMPTYTREE			* const plremptytree )
	{
	ERR					err						= JET_errSuccess;
	const INST			* pinst					= PinstFromPpib( pfucb->ppib );
	const IFMP			ifmp					= pfucb->ifmp;
	CSR					* const pcsr			= &pfucb->csr;
	const EMPTYPAGE		* const rgemptypage		= (EMPTYPAGE *)plremptytree->rgb;
	const CPG			cpgToFree				= plremptytree->CbEmptyPageList() / sizeof(EMPTYPAGE);

	Assert( ifmp == pinst->m_mpdbidifmp[ plremptytree->dbid ] );
	Assert( plremptytree->CbEmptyPageList() % sizeof(EMPTYPAGE) == 0 );
	Assert( cpgToFree > 0 );

	for ( INT i = 0; i < cpgToFree; i++ )
		{
		BOOL fRedoNeeded;

		CallR( ErrLGIAccessPage( pfucb->ppib, pcsr, ifmp, rgemptypage[i].pgno ) );

		Assert( latchRIW == pcsr->Latch() );
		Assert( rgemptypage[i].pgno == pcsr->Pgno() );

		fRedoNeeded	= FLGNeedRedoCheckDbtimeBefore( *pcsr,
													plremptytree->le_dbtime,
													rgemptypage[i].dbtimeBefore,
													&err );

		// for the FLGNeedRedoCheckDbtimeBefore error code
		if ( err < 0 )
			{
			pcsr->ReleasePage();
			return err;
			}

		//	upgrade latch if needed
		//
		if ( fRedoNeeded )
			{
			pcsr->SetILine( 0 );
			pcsr->UpgradeFromRIWLatch();
			pcsr->CoordinatedDirty( plremptytree->le_dbtime );
			pcsr->Cpage().SetEmpty();
			}

		pcsr->ReleasePage();
		}

	return JET_errSuccess;
	}

	
ERR LOG::ErrLGRIRedoNodeOperation( const LRNODE_ *plrnode, ERR *perr )
	{
	ERR				err;
	PIB				*ppib;
	const PGNO		pgno		= plrnode->le_pgno;
	const PGNO		pgnoFDP		= plrnode->le_pgnoFDP;
	const OBJID		objidFDP	= plrnode->le_objidFDP;	// Debug only info.
	const PROCID	procid 		= plrnode->le_procid;
	const DBID		dbid		= plrnode->dbid;
	const DBTIME	dbtime		= plrnode->le_dbtime;
	const BOOL		fUnique		= plrnode->FUnique();
	const BOOL		fSpace		= plrnode->FSpace();
	const DIRFLAG	dirflag 	= plrnode->FVersioned() ? fDIRNull : fDIRNoVersion;
	VERPROXY		verproxy;

	verproxy.rceid = plrnode->le_rceid;
	verproxy.level = plrnode->level;
	verproxy.proxy = proxyRedo;

	Assert( !plrnode->FVersioned() || !plrnode->FSpace() );
	Assert( !plrnode->FVersioned() || rceidNull != verproxy.rceid );
	Assert( !plrnode->FVersioned() || verproxy.level > 0 );
	
	BOOL fSkip;
	CallR( ErrLGRICheckRedoCondition2(
				procid,
				dbid,
				dbtime,
				objidFDP,
				(LR *) plrnode,	//	can be in macro.
				&ppib,
				&fSkip ) );
	if ( fSkip )
		return JET_errSuccess;

	if ( ppib->level > plrnode->level )
		{
		//	if operation was performed by concurrent CreateIndex, the
		//	updater could be at a higher trx level than when the
		//	indexer logged the operation
		//	UNDONE: explain why Undo and UndoInfo can have ppib at higher trx
		Assert( plrnode->FConcCI()
			|| lrtypUndoInfo == plrnode->lrtyp
			|| lrtypUndo == plrnode->lrtyp );
		}
	else
		{
		//	UNDONE: for lrtypUndoInfo, is it really possible for ppib to
		//	be at lower level than logged operation?
		Assert( ppib->level == plrnode->level
			|| lrtypUndoInfo == plrnode->lrtyp );
		}

	//	reset CSR
	//
	CSR		csr;
	INST	*pinst = PinstFromPpib( ppib );
	IFMP	ifmp = pinst->m_mpdbidifmp[ dbid ];
	BOOL	fRedoNeeded;

	CallR( ErrLGIAccessPage( ppib, &csr, ifmp, pgno ) );
	Assert( latchRIW == csr.Latch() );

	fRedoNeeded = lrtypUndoInfo == plrnode->lrtyp ?
								fFalse : 
								FLGNeedRedoCheckDbtimeBefore( csr, dbtime, plrnode->le_dbtimeBefore, &err );

	// for the FLGNeedRedoCheckDbtimeBefore error code
	Call( err );
	
	//	set CSR
	//	upgrade latch if needed
	//
	csr.SetILine( plrnode->ILine() );
	if ( fRedoNeeded )
		{
		csr.UpgradeFromRIWLatch();
		}

	LGRITraceRedo( plrnode );

	FUCB	*pfucb;

	Assert( !fRedoNeeded || objidFDP == csr.Cpage().ObjidFDP() );

	Call( ErrLGRIGetFucb( m_ptablehfhash, ppib, ifmp, pgnoFDP, objidFDP, fUnique, fSpace, &pfucb ) );

	//	BUG?? pfucb->ppib maybe the indexer ppib while the logged ppib
	//	BUG?? maybe the updater, the proxy ppib
	//	BUG??
	//	BUG?? -cheen

	Assert( pfucb->ppib == ppib );
	
	switch ( plrnode->lrtyp )
		{
		default:
			Assert( fFalse );
			break;

		case lrtypSetExternalHeader:
			{			
			if ( !fRedoNeeded )
				{
				CallS( err );
				goto HandleError;
				}

			DATA				data;
			LRSETEXTERNALHEADER	*plrsetextheader = (LRSETEXTERNALHEADER *) plrnode;

			data.SetPv( plrsetextheader->rgbData );
			data.SetCb( plrsetextheader->CbData() );

			NDResetVersionInfo( &csr.Cpage() );
			err = ErrNDSetExternalHeader( pfucb, &csr, &data, dirflag | fDIRRedo );
			CallS( err );
			Call( err );
			}
			break;
			
		case lrtypUndoInfo:
			{
			//	restore undo information in version store
			//		for a page flushed with uncommitted change
			//		if RCE already exists for this operation at the same level,
			//			do nothing
			//
			LRUNDOINFO	*plrundoinfo = (LRUNDOINFO *) plrnode;
			RCE			*prce;
			const OPER	oper = plrundoinfo->le_oper;

			Assert( !fRedoNeeded );
			
			//	mask PIB fields to logged values for creating version
			//
			const TRX	trxOld 		= ppib->trxBegin0;
			const LEVEL	levelOld	= ppib->level;

			Assert( pfucb->ppib == ppib );

			if ( 0 == ppib->level )
				{
				//	RCE is not useful, since there is no transaction to roll back
				//
				goto HandleError;
				}

			//	remove this RCE from the list of uncreated RCEs
			Call( ppib->ErrDeregisterDeferredRceid( plrundoinfo->le_rceid ) );
				
			Assert( trxOld == plrundoinfo->le_trxBegin0 );
			ppib->level		= min( plrundoinfo->level, ppib->level );
			ppib->trxBegin0 = plrundoinfo->le_trxBegin0;
			
			//	force RCE to be recreated at same current level as ppib
			Assert( plrundoinfo->level == verproxy.level );
			verproxy.level = ppib->level;
			
			Assert( operReplace == oper ||
					operFlagDelete == oper );
			Assert( FUndoableLoggedOper( oper ) );
			
			BOOKMARK	bm;
			bm.key.prefix.Nullify();
			bm.key.suffix.SetPv( plrundoinfo->rgbData );
			bm.key.suffix.SetCb( plrundoinfo->CbBookmarkKey() );

			bm.data.SetPv( plrundoinfo->rgbData + plrundoinfo->CbBookmarkKey() );
			bm.data.SetCb( plrundoinfo->CbBookmarkData() );

			//	set up fucb as in do-time
			//
			if ( operReplace == oper )
				{
				pfucb->kdfCurr.Nullify();
				pfucb->kdfCurr.key = bm.key;
				pfucb->kdfCurr.data.SetPv( plrundoinfo->rgbData + 
											 plrundoinfo->CbBookmarkKey() +
											 plrundoinfo->CbBookmarkData() );
				pfucb->kdfCurr.data.SetCb( plrundoinfo->le_cbData );
				}
			
			//	create RCE
			//
			Assert( plrundoinfo->le_pgnoFDP == PgnoFDP( pfucb ) );
			CallJ( PverFromPpib( ppib )->ErrVERModify( pfucb, bm, oper, &prce, &verproxy ), RestorePIB );
			Assert( prceNil != prce );

			//	if oper is replace, set verreplace in RCE
			if ( prce->FOperReplace() )
				{
				VERREPLACE* pverreplace = (VERREPLACE*)prce->PbData();

				pverreplace->cbMaxSize	= plrundoinfo->le_cbMaxSize;
				pverreplace->cbDelta	= 0;
				}

			// Pass pcsrNil to prevent creation of UndoInfo
			VERInsertRCEIntoLists( pfucb, pcsrNil, prce );

		RestorePIB:
			ppib->level 	= levelOld;
			ppib->trxBegin0 = trxOld;

			if ( JET_errPreviousVersion == err )
				{
				err = JET_errSuccess;
				}
			Call( err );

			//	skip to release page
			//
			goto HandleError;
			}
			break;
			
		case lrtypUndo:
			{
			LRUNDO  *plrundo = (LRUNDO *)plrnode;

			CallR( ErrLGRIPpibFromProcid( plrundo->le_procid, &ppib ) );

			Assert( !ppib->FMacroGoing( dbtime ) );

			//	check transaction level
			//
			if ( ppib->level <= 0 )
				{
				Assert( fFalse );
				break;
				}

			LGRITraceRedo( plrnode );

			Assert( plrundo->le_pgnoFDP == PgnoFDP( pfucb ) );
			VERRedoPhysicalUndo( m_pinst, plrundo, pfucb, &csr, fRedoNeeded );

			if ( !fRedoNeeded )
				{
				CallS( err );
				goto HandleError;
				}
			}
			break;
		
		case lrtypInsert:
			{			
			LRINSERT	    *plrinsert = (LRINSERT *)plrnode;

			KEYDATAFLAGS	kdf;
			
			kdf.key.prefix.SetPv( (BYTE *) plrinsert->szKey );
			kdf.key.prefix.SetCb( plrinsert->CbPrefix() );

			kdf.key.suffix.SetPv( (BYTE *)( plrinsert->szKey ) + plrinsert->CbPrefix() );
			kdf.key.suffix.SetCb( plrinsert->CbSuffix() );

			kdf.data.SetPv( (BYTE *)( plrinsert->szKey ) + kdf.key.Cb() );
			kdf.data.SetCb( plrinsert->CbData() );

			kdf.fFlags	= 0;

			if ( kdf.key.prefix.Cb() > 0 )
				{
				Assert( plrinsert->CbPrefix() > cbPrefixOverhead );
				kdf.fFlags	|= fNDCompressed; 
				}

			//	even if operation is not redone, create version
			//	for rollback support.
			//
			if ( plrinsert->FVersioned() )
				{
				//  we don't need to set the version bit as the version store will be empty at the end of recovery
				RCE			*prce = prceNil;
				BOOKMARK	bm;
					
				NDGetBookmarkFromKDF( pfucb, kdf, &bm );
				Call( PverFromPpib( ppib )->ErrVERModify( pfucb, bm, operInsert, &prce, &verproxy ) );
				Assert( prceNil != prce );
				//  we have the page latched and we are not logging so the NDInsert won't fail
				VERInsertRCEIntoLists( pfucb, &csr, prce );
				}

			if( fRedoNeeded )
				{
				Assert( plrinsert->ILine() == csr.ILine() );
				//  no logging of versioning so this can't fail
				NDResetVersionInfo( &csr.Cpage() );				
				CallS( ErrNDInsert( pfucb, &csr, &kdf, dirflag | fDIRRedo, rceidNull, NULL ) );
				}
			else
				{
				err = JET_errSuccess;
				goto HandleError;
				}
			}
			break;

		case lrtypFlagInsert:
			{
			LRFLAGINSERT    *plrflaginsert = (LRFLAGINSERT *)plrnode;
			
			if ( plrflaginsert->FVersioned() )
				{
				KEYDATAFLAGS	kdf;

				kdf.data.SetPv( plrflaginsert->rgbData + plrflaginsert->CbKey() );
				kdf.data.SetCb( plrflaginsert->CbData() );

				kdf.key.prefix.Nullify();
				kdf.key.suffix.SetCb( plrflaginsert->CbKey() );
				kdf.key.suffix.SetPv( plrflaginsert->rgbData );

				BOOKMARK	bm;
				RCE			*prce = prceNil;
					
				NDGetBookmarkFromKDF( pfucb, kdf, &bm );
				Call( PverFromPpib( ppib )->ErrVERModify( pfucb, bm, operInsert, &prce, &verproxy ) );
				Assert( prceNil != prce );
				VERInsertRCEIntoLists( pfucb, &csr, prce );
				}

			if( fRedoNeeded )
				{
				Assert( plrflaginsert->ILine() == csr.ILine() );
				NDGet( pfucb, &csr );
				Assert( FNDDeleted( pfucb->kdfCurr ) );
			

				NDResetVersionInfo( &csr.Cpage() );
				err = ErrNDFlagInsert( pfucb, &csr, dirflag | fDIRRedo, rceidNull, NULL );
				CallS( err );
				}
			else
				{
				err = JET_errSuccess;
				goto HandleError;
				}
			Call( err );
			}
			break;
			
		case lrtypFlagInsertAndReplaceData:
			{
			LRFLAGINSERTANDREPLACEDATA	*plrfiard = 
										(LRFLAGINSERTANDREPLACEDATA *)plrnode;
			KEYDATAFLAGS	kdf;
			RCE	* prce;

			kdf.data.SetPv( plrfiard->rgbData + plrfiard->CbKey() );
			kdf.data.SetCb( plrfiard->CbData() );

			VERPROXY		verproxyReplace;
			verproxyReplace.rceid = plrfiard->le_rceidReplace;
			verproxyReplace.level = plrfiard->level;
			verproxyReplace.proxy = proxyRedo;

			if ( plrfiard->FVersioned() )
				{
				kdf.key.prefix.Nullify();
				kdf.key.suffix.SetCb( plrfiard->CbKey() );
				kdf.key.suffix.SetPv( plrfiard->rgbData );

				BOOKMARK	bm;
				RCE			*prce = prceNil;
					
				NDGetBookmarkFromKDF( pfucb, kdf, &bm );
				Call( PverFromPpib( ppib )->ErrVERModify( pfucb, bm, operInsert, &prce, &verproxy ) );
				Assert( prceNil != prce );
				VERInsertRCEIntoLists( pfucb, &csr, prce );
				}

			if( fRedoNeeded )
				{
				Assert( verproxyReplace.level == verproxy.level );		
				Assert( plrfiard->ILine() == csr.ILine() );
				NDGet( pfucb, &csr );
				Assert( FNDDeleted( pfucb->kdfCurr ) );

				//	page may be reorganized 
				//	copy key from node
				//

				BYTE *rgb;
				BFAlloc( (VOID **)&rgb );

//				BYTE	rgb[g_cbPageMax];
				
				pfucb->kdfCurr.key.CopyIntoBuffer( rgb, g_cbPage );
			
				kdf.key.prefix.SetCb( pfucb->kdfCurr.key.prefix.Cb() );
				kdf.key.prefix.SetPv( rgb );
				kdf.key.suffix.SetCb( pfucb->kdfCurr.key.suffix.Cb() );
				kdf.key.suffix.SetPv( rgb + kdf.key.prefix.Cb() );
				Assert( FKeysEqual( kdf.key, pfucb->kdfCurr.key ) );

				if( plrfiard->FVersioned() )
					{
					verproxy.rceid = plrfiard->le_rceidReplace;
					
					//  we need to create the replace version for undo
					//  if we don't need to redo the operation, the undo-info will create
					//  the version if necessary
					BOOKMARK bm;

					NDGetBookmarkFromKDF( pfucb, pfucb->kdfCurr, &bm );
//					Call( PverFromPpib( ppib )->ErrVERModify( pfucb, bm, operReplace, &prce, &verproxy ) );
					err = PverFromPpib( ppib )->ErrVERModify( pfucb, bm, operReplace, &prce, &verproxy );
					if ( err < 0 )
						{
						BFFree( rgb );
						goto HandleError;
						}					
					Assert( prceNil != prce );
					VERInsertRCEIntoLists( pfucb, &csr, prce );				
					}
								
				NDResetVersionInfo( &csr.Cpage() );
				err = ErrNDFlagInsertAndReplaceData( pfucb, 
													 &csr, 
													 &kdf, 
													 dirflag | fDIRRedo,
													 rceidNull, 
													 rceidNull,
													 prceNil,
													 NULL );

				BFFree( rgb );
				
				CallS( err );
				Call( err );
				}
			else
				{
				err = JET_errSuccess;
				goto HandleError;
				}
			}
			break;
			
		case lrtypReplace:
		case lrtypReplaceD:
			{
			LRREPLACE	* const plrreplace	= (LRREPLACE *)plrnode;

			if ( !fRedoNeeded )
				{

				//	add this RCE to the list of uncreated RCEs
				if ( plrreplace->FVersioned() )
					{
					Call( ppib->ErrRegisterDeferredRceid( plrnode->le_rceid ) );
					}
				
				CallS( err );
				goto HandleError;
				}
				
			RCE				*prce = prceNil;
			const UINT		cbOldData = plrreplace->CbOldData();
			const UINT		cbNewData = plrreplace->CbNewData();
			DATA			data;
			BYTE			*rgbRecNew = NULL;
//			BYTE			rgbRecNew[g_cbPageMax];

			//	cache node
			//
			Assert( plrreplace->ILine() == csr.ILine() );
			NDGet( pfucb, &csr );

			if ( plrnode->lrtyp == lrtypReplaceD )
				{
				SIZE_T 	cb;
				BYTE 	*pbDiff	= (BYTE *)( plrreplace->szData );
				ULONG	cbDiff 	= plrreplace->Cb();

				BFAlloc( (VOID **)&rgbRecNew );

				LGGetAfterImage( pbDiff,
								 cbDiff, 
								 (BYTE *)pfucb->kdfCurr.data.Pv(),
								 pfucb->kdfCurr.data.Cb(),
								 rgbRecNew,
								 &cb );
				Assert( cb < g_cbPage );
//				Assert( cb < sizeof( rgbRecNew ) );

				data.SetPv( rgbRecNew );
				data.SetCb( cb );
				}
			else
				{
				data.SetPv( plrreplace->szData );
				data.SetCb( plrreplace->Cb() );
				}
			Assert( data.Cb() == cbNewData );

			//	copy bm to pfucb->bmCurr
			//
			BYTE *rgb;
			BFAlloc( (VOID **)&rgb );
//			BYTE	rgb[g_cbPageMax];
			pfucb->kdfCurr.key.CopyIntoBuffer( rgb, g_cbPage );
			
			Assert( FFUCBUnique( pfucb ) );
			pfucb->bmCurr.data.Nullify();
			
			pfucb->bmCurr.key.prefix.SetCb( pfucb->kdfCurr.key.prefix.Cb() );
			pfucb->bmCurr.key.prefix.SetPv( rgb );
			pfucb->bmCurr.key.suffix.SetCb( pfucb->kdfCurr.key.suffix.Cb() );
			pfucb->bmCurr.key.suffix.SetPv( rgb + pfucb->kdfCurr.key.prefix.Cb() );
			Assert( CmpKey( pfucb->bmCurr.key, pfucb->kdfCurr.key ) == 0 );

			//  if we have to redo the operation we have to create the version
			//  the page has the proper before-image on it
			if( plrreplace->FVersioned() )
				{
//				Call( PverFromPpib( ppib )->ErrVERModify( pfucb, pfucb->bmCurr, operReplace, &prce, &verproxy ) );
				err = PverFromPpib( ppib )->ErrVERModify( pfucb, pfucb->bmCurr, operReplace, &prce, &verproxy );
				if ( err < 0 )
					{
					BFFree( rgb );
					if ( NULL != rgbRecNew )
						{
						BFFree( rgbRecNew );
						}
					goto HandleError;
					}
				Assert( prceNil != prce );
				VERInsertRCEIntoLists( pfucb, &csr, prce );
				}

			NDResetVersionInfo( &csr.Cpage() );
			err = ErrNDReplace( pfucb, &csr, &data, dirflag | fDIRRedo, rceidNull, prceNil );

			BFFree( rgb );
			if ( NULL != rgbRecNew )
				{
				BFFree( rgbRecNew );
				}
			CallS( err );
			Call( err );
			}
			break;

		case lrtypFlagDelete:
			{
			const LRFLAGDELETE 	* const plrflagdelete	= (LRFLAGDELETE *)plrnode;

			if ( !fRedoNeeded )
				{
				
				//  we'll create the version using the undo-info if necessary

				//	add this RCE to the list of uncreated RCEs
				if ( plrflagdelete->FVersioned() )
					{
					Call( ppib->ErrRegisterDeferredRceid( plrnode->le_rceid ) );
					}
				
				CallS( err );
				goto HandleError;
				}
				
			//	cache node
			//
			Assert( plrflagdelete->ILine() == csr.ILine() );
			NDGet( pfucb, &csr );

			//  if we have to redo the operation we have to create the version
			if( plrflagdelete->FVersioned() )
				{
				BOOKMARK	bm;
				RCE			*prce = prceNil;
					
				NDGetBookmarkFromKDF( pfucb, pfucb->kdfCurr, &bm );
				Call( PverFromPpib( ppib )->ErrVERModify( pfucb, bm, operFlagDelete, &prce, &verproxy ) );
				Assert( prceNil != prce );
				VERInsertRCEIntoLists( pfucb, &csr, prce );
				}

			//	redo operation
			//
			NDResetVersionInfo( &csr.Cpage() );
			err = ErrNDFlagDelete( pfucb, &csr, dirflag | fDIRRedo, rceidNull, NULL );
			CallS( err );
			Call( err );
			}
			break;

		case lrtypDelete:
			{
			LRDELETE        *plrdelete = (LRDELETE *) plrnode;

			if ( !fRedoNeeded )
				{
				err = JET_errSuccess;
				goto HandleError;
				}

			//	redo node delete
			//
			Assert( plrdelete->ILine() == csr.ILine() );
			NDResetVersionInfo( &csr.Cpage() );
			err = ErrNDDelete( pfucb, &csr );
			CallS( err );
			Call( err );
			}
			break;

			
		case lrtypDelta:
			{
			LRDELTA *plrdelta	= (LRDELTA *) plrnode;
			LONG    lDelta 		= plrdelta->LDelta();
			USHORT	cbOffset	= plrdelta->CbOffset();

			Assert( plrdelta->ILine() == csr.ILine() );

			if ( dirflag & fDIRNoVersion )
				{
				Assert( fFalse );
				err = JET_errLogFileCorrupt;
				goto HandleError;
				}

			VERDELTA	verdelta;
			RCE			*prce = prceNil; 
				
			verdelta.lDelta				= lDelta;
			verdelta.cbOffset			= cbOffset;
			verdelta.fDeferredDelete	= fFalse;
			verdelta.fFinalize			= fFalse;

			BOOKMARK	bm;
			bm.key.prefix.Nullify();
			bm.key.suffix.SetPv( plrdelta->rgbData );
			bm.key.suffix.SetCb( plrdelta->CbBookmarkKey() );
			bm.data.SetPv( (BYTE *)plrdelta->rgbData + plrdelta->CbBookmarkKey() );
			bm.data.SetCb( plrdelta->CbBookmarkData() );

			pfucb->kdfCurr.data.SetPv( &verdelta );
			pfucb->kdfCurr.data.SetCb( sizeof( VERDELTA ) );

			Call( PverFromPpib( ppib )->ErrVERModify( pfucb, bm, operDelta, &prce, &verproxy ) );
			Assert( prce != prceNil );
			VERInsertRCEIntoLists( pfucb, &csr, prce );
			
			if( fRedoNeeded )
				{
				NDGet( pfucb, &csr );
				NDResetVersionInfo( &csr.Cpage() );
				err = ErrNDDelta( pfucb, 
							  &csr, 
							  cbOffset,
							  &lDelta, 
							  sizeof( lDelta ),
							  NULL, 
							  0,
							  NULL,
							  dirflag | fDIRRedo,
							  rceidNull );
				CallS( err );
				}
			else
				{
				err = JET_errSuccess;
				goto HandleError;
				}
			Call( err );
			}
			break;

		case lrtypSLVSpace:
			{
			const LRSLVSPACE * const plrslvspace	= (LRSLVSPACE *) plrnode;

			Assert( plrslvspace->ILine() == csr.ILine() );

			if ( !( dirflag & fDIRNoVersion ) )
				{
				VERSLVSPACE	verslvspace;
				RCE			*prce = prceNil; 

				verslvspace.oper	= SLVSPACEOPER( BYTE( plrslvspace->oper ) );
				verslvspace.ipage	= plrslvspace->le_ipage;
				verslvspace.cpages	= plrslvspace->le_cpages;
				verslvspace.fileid	= CSLVInfo::fileidNil;
				verslvspace.cbAlloc	= 0;
				verslvspace.wszFileName[0] = 0;
				
				BOOKMARK	bm;
				bm.key.prefix.Nullify();
				bm.key.suffix.SetPv( const_cast<BYTE *>( plrslvspace->rgbData ) );
				bm.key.suffix.SetCb( plrslvspace->le_cbBookmarkKey );
				bm.data.SetPv( (BYTE *)plrslvspace->rgbData + plrslvspace->le_cbBookmarkKey );
				bm.data.SetCb( plrslvspace->le_cbBookmarkData );

				pfucb->kdfCurr.data.SetPv( &verslvspace );
				pfucb->kdfCurr.data.SetCb( OffsetOf( VERSLVSPACE, wszFileName ) + sizeof( wchar_t ) );

				Call( PverFromPpib( ppib )->ErrVERModify( pfucb, bm, operSLVSpace, &prce, &verproxy ) );
				Assert( prce != prceNil );
				VERInsertRCEIntoLists( pfucb, &csr, prce );
				}
			
			if( fRedoNeeded )
				{
				NDGet( pfucb, &csr );
				NDResetVersionInfo( &csr.Cpage() );
				err = ErrNDMungeSLVSpace( pfucb, 
										  &csr, 
										  SLVSPACEOPER( BYTE( plrslvspace->oper ) ),
										  plrslvspace->le_ipage, 
										  plrslvspace->le_cpages,
										  dirflag | fDIRRedo,
										  rceidNull );
				CallS( err );
				Call( err );
				}
			else
				{
				err = JET_errSuccess;
				goto HandleError;
				}

			break;
			}

		case lrtypEmptyTree:
			{
			Call( ErrLGRIRedoFreeEmptyPages( pfucb, (LREMPTYTREE *)plrnode ) );
			if ( fRedoNeeded )
				{
				csr.Dirty();
				NDSetEmptyTree( &csr );
				}
			else
				{
				err = JET_errSuccess;
				goto HandleError;
				}
				
			break;
			}
		}

	Assert( fRedoNeeded );
	Assert( csr.FDirty() );
	
	//	the timestamp set in ND operation is not correct so reset it
	//
	csr.SetDbtime( dbtime );

	err = JET_errSuccess;

HandleError:
	Assert( pgno == csr.Pgno() );
	Assert( csr.FLatched() );

	csr.ReleasePage();
	return err;
	}


#define	fNSGotoDone		1
#define	fNSGotoCheck	2

#define	FSameTime( ptm1, ptm2 )		( memcmp( (ptm1), (ptm2), sizeof(LOGTIME) ) == 0 )


ERR LOG::ErrLGRedoFill( IFileSystemAPI *const pfsapi, LR **pplr, BOOL fLastLRIsQuit, INT *pfNSNextStep )
	{
	ERR     err, errT = JET_errSuccess;
	LONG    lgen;
	BOOL    fCloseNormally;
	LOGTIME tmOldLog = m_plgfilehdr->lgfilehdr.tmCreate;
	CHAR    szT[IFileSystemAPI::cchPathMax];
	CHAR    szFNameT[IFileSystemAPI::cchPathMax];
	LE_LGPOS   le_lgposFirstT;
	BOOL    fJetLog = fFalse;
	CHAR	szOldLogName[ IFileSystemAPI::cchPathMax ];
	LGPOS	lgposOldLastRec = m_lgposLastRec;

	/*	split log name into name components
	/**/
	CallS( pfsapi->ErrPathParse( m_szLogName, szT, szFNameT, szT ) );

	/*	end of redoable logfile, read next generation
	/**/
	if ( UtilCmpFileName( szFNameT, m_szJet ) == 0 )
		{
		Assert( m_szLogCurrent != m_szRestorePath );

		/*	we have done all the log records
		/**/
		*pfNSNextStep = fNSGotoDone;
		err = JET_errSuccess;
		goto CheckGenMaxReq;
		}

	/* close current logfile, open next generation */
	delete m_pfapiLog;
	/* set m_pfapiLog as NULL to indicate it is closed. */
	m_pfapiLog = NULL;

	strcpy( szOldLogName, m_szLogName );

OpenNextLog:

	lgen = m_plgfilehdr->lgfilehdr.le_lGeneration + 1;
	LGSzFromLogId( szFNameT, lgen );
	LGMakeLogName( m_szLogName, szFNameT );

	// if we replayed all logs from target directory
	if ( m_szLogCurrent == m_szTargetInstanceLogPath && m_lGenHighTargetInstance == m_plgfilehdr->lgfilehdr.le_lGeneration )
		{
		Assert ( '\0' != m_szTargetInstanceLogPath[0] );	
		// we don't have to try nothing more
		err = JET_errFileNotFound;
		goto NoMoreLogs;
		}

	err = pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog );

	if ( err == JET_errFileNotFound )
		{
		if ( m_szLogCurrent == m_szRestorePath || m_szLogCurrent == m_szTargetInstanceLogPath )
			{
NoMoreLogs:
			// if we have a target instance or we didn't replayed those
			// try that directory
			if ( m_szTargetInstanceLogPath[0] && m_szLogCurrent != m_szTargetInstanceLogPath)
				m_szLogCurrent = m_szTargetInstanceLogPath;
			// try instance directory
			else
				m_szLogCurrent = m_szLogFilePath;
	
			LGSzFromLogId( szFNameT, lgen );
			LGMakeLogName( m_szLogName, szFNameT );
			err = pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog );
			}
			
		}
		
	if ( err == JET_errFileNotFound )
		{

		//	open failed, try szJet

		Assert( !m_pfapiLog );
		strcpy( szFNameT, m_szJet );
		LGMakeLogName( m_szLogName, szFNameT );
		err = pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog );
		if ( JET_errSuccess == err )
			{
			fJetLog = fTrue;
			}
		}
	if ( err < 0 )
		{
		//	If open next generation fail and we haven't finished
		//	all the backup logs, then return as abrupt end.
		
		if ( !m_fReplayingReplicatedLogFiles &&
			 m_fHardRestore && lgen <= m_lGenHighRestore )
			{
			m_fAbruptEnd = fTrue;
			goto AbruptEnd;
			}

		if ( m_fReplayingReplicatedLogFiles &&
				(	err == JET_errFileNotFound ||
					err == JET_errFileAccessDenied ) )
			{
			//	We are in the mode of replaying a log. The expected
			//	log file was not found, sleep for 300 ms and retry to
			//	to open the next generation log file till it succeeds.

			UtilSleep( 300 );
			(VOID)ErrLGUpdateCheckpointFile( pfsapi, fFalse );
			goto OpenNextLog;
			}

		if ( err == JET_errFileNotFound )
			{
StartNewLog:
			/* we run out of log files, create a new edb.log in current
			 * directory for later use.
			 */
			m_critLGFlush.Enter();
			/*	Reset LG buf pointers since we are done with all the
			 *      old log records in buffer.
			 */
			m_critLGBuf.Enter();
			m_pbEntry = m_pbLGBufMin;
			m_pbWrite = m_pbLGBufMin;
			m_critLGBuf.Leave();

#ifdef UNLIMITED_DB
			const BOOL	fLGFlags	= fLGOldLogInBackup|fLGLogAttachments;
#else
			const BOOL	fLGFlags	= fLGOldLogInBackup;
#endif
			if ( ( err = ErrLGNewLogFile( pfsapi, lgen - 1, fLGFlags ) ) < 0 )
				{
				m_critLGFlush.Leave();
				return err;
				}

			m_critLGBuf.Enter();
			UtilMemCpy( m_plgfilehdr, m_plgfilehdrT, sizeof( LGFILEHDR ) );
			m_isecWrite = m_csecHeader;
			m_critLGBuf.Leave();

			m_critLGFlush.Leave();

			Assert( m_plgfilehdr->lgfilehdr.le_lGeneration == lgen );

			strcpy( szFNameT, m_szJet );
			LGMakeLogName( m_szLogName, szFNameT );
			err = pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog );

			*pfNSNextStep = fNSGotoDone;
			return err;
			}

		/* Open Fails */
		Assert( fFalse );
		Assert( !m_pfapiLog );
		if ( fLastLRIsQuit )
			{
			/* we are lucky, we have a normal end */
			*pfNSNextStep = fNSGotoDone;
			err = JET_errSuccess;
			goto CheckGenMaxReq;
			}
		return err;
		}

	//	We got the next log to play, but if last one is abruptly ended
	//	we want to stop here.

	if ( m_fAbruptEnd )
		{
		CHAR szT1[16];
		CHAR szT2[16];
		const CHAR *rgszT[3];
AbruptEnd:
		rgszT[0] = szOldLogName;
		sprintf( szT1, "%d", lgposOldLastRec.isec );
		rgszT[1] = szT1;
		sprintf( szT2, "%d", lgposOldLastRec.ib );
		rgszT[2] = szT2;
		UtilReportEvent(	eventError,
							LOGGING_RECOVERY_CATEGORY,
							REDO_END_ABRUPTLY_ERROR_ID,
							sizeof( rgszT ) / sizeof( rgszT[ 0 ] ),
							rgszT,
							0, 
							NULL,
							m_pinst );

		return ErrERRCheck( JET_errRedoAbruptEnded );
		}

	// save the previous log header
	UtilMemCpy( m_plgfilehdrT, m_plgfilehdr, sizeof(LGFILEHDR) );

	/* reset the log buffers */
	CallR( ErrLGReadFileHdr( m_pfapiLog, m_plgfilehdr, fCheckLogID ) );

	if ( !FSameTime( &tmOldLog, &m_plgfilehdr->lgfilehdr.tmPrevGen ) )
		{
		// we found a edb.log older. We need to delete it is that's
		// specified by the user
		
		if ( m_fHardRestore && m_fDeleteOutOfRangeLogs && fJetLog && m_plgfilehdr->lgfilehdr.le_lGeneration < lgen )
			{
			/* close current logfile, open next generation */
			delete m_pfapiLog;
			/* set m_pfapiLog as NULL to indicate it is closed. */
			m_pfapiLog = NULL;
			fJetLog = fFalse;

			CHAR szGenLast[32];
			CHAR szGenDelete[32];
			const CHAR *rgszT[] = { szGenLast, szGenDelete, m_szLogName };
			sprintf( szGenLast, "%d", lgen - 1);
			sprintf( szGenDelete, "%d", m_plgfilehdr->lgfilehdr.le_lGeneration);
			UtilReportEvent( eventWarning, LOGGING_RECOVERY_CATEGORY, DELETE_LAST_LOG_FILE_TOO_OLD_ID, sizeof(rgszT) / sizeof(rgszT[0]), rgszT );

			CallR ( pfsapi->ErrFileDelete( m_szLogName ) );

			// we need to copy back the previous log log header
			// so that the new edb.log will have the right prevInfo
			UtilMemCpy( m_plgfilehdr, m_plgfilehdrT, sizeof(LGFILEHDR) );

			goto StartNewLog;
			}

		return ErrERRCheck( JET_errInvalidLogSequence );
		}

	le_lgposFirstT.le_lGeneration = m_plgfilehdr->lgfilehdr.le_lGeneration;
	le_lgposFirstT.le_isec = (WORD)m_csecHeader;
	le_lgposFirstT.le_ib = 0;

	m_lgposLastRec.isec = 0;

	//	scan the log to find traces of corruption before going record-to-record
	//	if any corruption is found, an error will be returned
	err = ErrLGCheckReadLastLogRecordFF( pfsapi, &fCloseNormally );
	if ( err == JET_errSuccess || FErrIsLogCorruption( err ) )
		{
		errT = err;
		}
	else
		{
		Assert( err < 0 );
		CallR( err );
		}

	//	Check if abrupt end if the file size is not the same as recorded.
	
	QWORD cbSize;
	CallR( m_pfapiLog->ErrSize( &cbSize ) );
	if ( cbSize != m_plgfilehdr->lgfilehdr.le_cbSec * QWORD( m_plgfilehdr->lgfilehdr.le_csecLGFile ) )
		{
		m_fAbruptEnd = fTrue;
		}
	
	//	now scan the first record
	//	there should be no errors about corruption since they'll be handled by ErrLGCheckReadLastLogRecordFF
	CallR( ErrLGLocateFirstRedoLogRecFF( &le_lgposFirstT, (BYTE **)pplr ) );
	//	we expect no warnings -- only success at this point
	CallS( err );
	*pfNSNextStep = fNSGotoCheck;

	//	If log is not end properly and we haven't finished
	//	all the backup logs, then return as abrupt end.
	
	//	UNDONE: for soft recovery, we need some other way to know
	//	UNDONE: if the record is played up to the crashing point.
		
	if ( m_fHardRestore && lgen <= m_lGenHighRestore
		 && m_fAbruptEnd )
		{
		goto AbruptEnd;
		}

CheckGenMaxReq:
	// check the genMaxReq+genMaxCreateTime of this log with all dbs
	if ( m_fRecovering )
		{
		LOGTIME tmEmpty;

		memset( &tmEmpty, '\0', sizeof( LOGTIME ) );
		
		for ( DBID dbidT = dbidUserLeast; dbidT < dbidMax; dbidT++ )
			{
			const IFMP	ifmp	= m_pinst->m_mpdbidifmp[ dbidT ];

			if ( ifmp >= ifmpMax )
				continue;

			FMP *		pfmpT	= &rgfmp[ ifmp ];

			Assert( !pfmpT->FReadOnlyAttach() );
			if ( pfmpT->FSkippedAttach() || pfmpT->FDeferredAttach() )
				{
				//	skipped attachments is a restore-only concept
				Assert( !pfmpT->FSkippedAttach() || m_fHardRestore );
				continue;
				}

			DBFILEHDR_FIX *pdbfilehdr	= pfmpT->Pdbfilehdr();
			Assert( pdbfilehdr );

			LONG lGenMaxRequired = pdbfilehdr->le_lGenMaxRequired;
			LONG lGenCurrent = m_plgfilehdr->lgfilehdr.le_lGeneration;
			
			// if the time of the log file does not match 
			if ( lGenMaxRequired == lGenCurrent && 
				 memcmp( &pdbfilehdr->logtimeGenMaxCreate, &tmEmpty, sizeof( LOGTIME ) ) &&
				 memcmp( &pdbfilehdr->logtimeGenMaxCreate, &m_plgfilehdr->lgfilehdr.tmCreate, sizeof( LOGTIME ) ) )
				{	
				LONG lGenMinRequired = pfmpT->Pdbfilehdr()->le_lGenMinRequired;
		
				CHAR szT2[32];
				CHAR szT3[32];
				const CHAR *rgszT[4];
				LOGTIME tm;

				rgszT[0] = pfmpT->SzDatabaseName();
				rgszT[1] = m_szLogName;

				tm = pdbfilehdr->logtimeGenMaxCreate;
				sprintf( szT2, " %02d/%02d/%04d %02d:%02d:%02d ",
							(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
							(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
				rgszT[2] = szT2;

				tm = m_plgfilehdr->lgfilehdr.tmCreate;
				sprintf( szT3, " %02d/%02d/%04d %02d:%02d:%02d ",
							(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
							(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
				rgszT[3] = szT3;
		
				UtilReportEvent(	eventError,
							LOGGING_RECOVERY_CATEGORY,
							REDO_HIGH_LOG_MISMATCH_ERROR_ID,
							sizeof( rgszT ) / sizeof( rgszT[ 0 ] ),
							rgszT );
				
				return ErrERRCheck( JET_errRequiredLogFilesMissing );
				}
			}		
		}

	//	we should have success at this point
	CallS( err );

	//	return the error from ErrLGCheckReadLastLogRecordFF
	return errT;
	}

ERR LOG::ErrReplaceRstMapEntry( const CHAR *szName, SIGNATURE * pDbSignature, const BOOL fSLVFile )
	{
	INT  irstmap;
	
	Assert ( pDbSignature );

	for ( irstmap = 0; irstmap < m_irstmapMac; irstmap++ )
		{
		if ( 0 == memcmp( pDbSignature, &m_rgrstmap[irstmap].signDatabase, sizeof(SIGNATURE) ) &&
			fSLVFile == m_rgrstmap[irstmap].fSLVFile )
			{
			char * szSrcDatabaseName;
			
			// found the entry we want to replace
			Assert ( m_rgrstmap[irstmap].szDatabaseName );

			if ( 0 == UtilCmpFileName(m_rgrstmap[irstmap].szDatabaseName, szName) )
				return JET_errSuccess;
			
			if ( ( szSrcDatabaseName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( szName ) + 1 ) ) ) == NULL )
				return ErrERRCheck( JET_errOutOfMemory );
				
			strcpy( szSrcDatabaseName, szName );

			{
			const UINT	csz	= 2;
			const CHAR	* rgszT[csz];

			rgszT[0] = m_rgrstmap[irstmap].szDatabaseName;
			rgszT[1] = szSrcDatabaseName;
			UtilReportEvent( eventInformation, LOGGING_RECOVERY_CATEGORY, 
				DB_LOCATION_CHANGE_DETECTED, csz, rgszT, 0, NULL, m_pinst );
			}
			
			OSMemoryHeapFree( m_rgrstmap[irstmap].szDatabaseName );
			m_rgrstmap[irstmap].szDatabaseName = szSrcDatabaseName;
			
			return JET_errSuccess;
			}
		}
	
	return JET_errFileNotFound;
	}

INT LOG::IrstmapLGGetRstMapEntry( const CHAR *szName, const CHAR *szDbNameIfSLV )
	{
	INT  irstmap;
	BOOL fFound = fFalse;
	BOOL fSLVFile = (NULL != szDbNameIfSLV);

	Assert( szName );
	//	NOTE: rstmap ALWAYS uses the OS file-system

	for ( irstmap = 0; irstmap < m_irstmapMac; irstmap++ )
		{
		CHAR			szPathT[IFileSystemAPI::cchPathMax];
		CHAR			szFNameT[IFileSystemAPI::cchPathMax];
		const CHAR	* 	szT;
		const CHAR *	szRst;

		if ( m_fExternalRestore || m_fReplayingReplicatedLogFiles )
			{
			/*	Use the database path to search.
			 */
			szT = szName;
			szRst = m_rgrstmap[irstmap].szDatabaseName;
			}
		else
			{
			/*	use the generic name to search
			 */
			 // if we search a SLV file, the generic name is the database one
			CallS( m_pinst->m_pfsapi->ErrPathParse( fSLVFile?szDbNameIfSLV:szName, szPathT, szFNameT, szPathT ) );
			szT = szFNameT;
			szRst = m_rgrstmap[irstmap].szGenericName;
			}

		if ( _stricmp( szRst, szT ) == 0 && (fSLVFile == m_rgrstmap[irstmap].fSLVFile ) )
			{
			fFound = fTrue;
			break;
			}
		}
	if ( !fFound )
		return -1;
	else
		return irstmap;
	}


INT LOG::IrstmapSearchNewName( const CHAR *szName )
	{
	INT  irstmap;
	BOOL fFound = fFalse;

	Assert( szName );

	for ( irstmap = 0; irstmap < m_irstmapMac; irstmap++ )
		{
		if ( m_rgrstmap[irstmap].szNewDatabaseName && 0 == UtilCmpFileName( m_rgrstmap[irstmap].szNewDatabaseName, szName ) )
			{
			Assert ( m_rgrstmap[irstmap].szDatabaseName );
			return irstmap;
			}			
		}
		
	return -1;
	}


ERR LOG::ErrLGRISetupFMPFromAttach(
				IFileSystemAPI *const	pfsapi,
				PIB						*ppib,
				const SIGNATURE			*pSignLog,
				const ATTACHINFO * 		pAttachInfo,
				LGSTATUSINFO *			plgstat )
	{
	ERR								err 				= JET_errSuccess;
	const CHAR						*szDbName;
	const CHAR						*szSLVName;
	const CHAR						*szSLVRoot;
	BOOL 							fSkippedAttach = fFalse;

	Assert ( pAttachInfo );
	Assert ( pAttachInfo->CbNames() > 0 );

	szDbName = pAttachInfo->szNames;
	if ( pAttachInfo->FSLVExists() )
		{
		szSLVName = szDbName + strlen( szDbName ) + 1;
		Assert( 0 != *szSLVName );

		szSLVRoot = szSLVName + strlen( szSLVName ) + 1;
		Assert( 0 != *szSLVRoot );
		}
	else
		{
		szSLVName = NULL;
		szSLVRoot = NULL;
		}

	if ( m_fExternalRestore || m_irstmapMac > 0  )
		{
		INT			irstmap;
		//	attach the database specified in restore map.
		//
		err = ErrLGGetDestDatabaseName( pfsapi, szDbName, &irstmap, plgstat );
		if ( JET_errFileNotFound == err )
			{
			/*	not in the restore map, set to skip it.
			 */
			fSkippedAttach = fTrue;
			err = JET_errSuccess;
			}
		else
			{
			Call( err );
			szDbName = m_rgrstmap[irstmap].szNewDatabaseName;
			}			
		}
					
	if ( NULL != szSLVName )
		{
		if ( m_fExternalRestore || m_irstmapMac > 0 )
			{
			INT		irstmap;
			// pAttachInfo->szNames is still original szDbName for this SLV
			err = ErrLGGetDestDatabaseName( pfsapi, szSLVName, &irstmap, plgstat, pAttachInfo->szNames );
			if ( JET_errFileNotFound == err )
				{
				/*	not in the restore map, set to skip it.
				 */
				// the database should be set skipped already
				Assert ( fSkippedAttach  );
				fSkippedAttach = fTrue;
				err = JET_errSuccess;
				}
			else
				{
				Call( err );
				szSLVName = m_rgrstmap[irstmap].szNewDatabaseName;
				}
			}
		}
	//	Get one free fmp entry

	IFMP	ifmp;
	CallR( FMP::ErrNewAndWriteLatch(
					&ifmp,
					szDbName,
					szSLVName,
					szSLVRoot,
					ppib,
					m_pinst,
					pfsapi,
					pAttachInfo->Dbid() ) );

	FMP		*pfmpT;
	pfmpT = &rgfmp[ ifmp ];
		
	Assert( !pfmpT->Pfapi() );
	Assert( NULL == pfmpT->Pdbfilehdr() );
	Assert( pfmpT->FInUse() );
	Assert( pfmpT->Dbid() == pAttachInfo->Dbid() );

	//	get logging/versioning flags (versioning can only be disabled if logging is disabled)
	pfmpT->ResetReadOnlyAttach();
	pfmpT->ResetVersioningOff();
	pfmpT->SetLogOn();

	if( pAttachInfo->FSLVProviderNotEnabled() )
		{
		pfmpT->SetSLVProviderNotEnabled();
		}

	if ( fSkippedAttach )
		{
		pfmpT->SetSkippedAttach();
		pfmpT->SetLogOn();
		pfmpT->ResetVersioningOff();
		}

	LGPOS	lgposConsistent;
	LGPOS	lgposAttach;

	lgposConsistent = pAttachInfo->le_lgposConsistent;
	lgposAttach = pAttachInfo->le_lgposAttach;

	//	get lgposAttch
	err = ErrLGRISetupAtchchk(
				ifmp,
				&pAttachInfo->signDb,
				pSignLog,
				&lgposAttach,
				&lgposConsistent,
				pAttachInfo->Dbtime(),
				pAttachInfo->ObjidLast(),
				pAttachInfo->CpgDatabaseSizeMax() );
				
	pfmpT->ReleaseWriteLatch( ppib );
	
HandleError:
	return err;
	}

ERR ErrLGRISetupAtchchk(
	const IFMP					ifmp,
	const SIGNATURE				*psignDb,
	const SIGNATURE				*psignLog,
	const LGPOS					*plgposAttach,
	const LGPOS					*plgposConsistent,
	const DBTIME				dbtime,
	const OBJID					objidLast,
	const CPG					cpgDatabaseSizeMax )
	{
	FMP				*pfmp		= &rgfmp[ifmp];
	ATCHCHK			*patchchk;

	Assert( NULL != pfmp );
	
	if ( pfmp->Patchchk() == NULL )
		{
		patchchk = static_cast<ATCHCHK *>( PvOSMemoryHeapAlloc( sizeof( ATCHCHK ) ) );
		if ( NULL == patchchk )
			return ErrERRCheck( JET_errOutOfMemory );
		pfmp->SetPatchchk( patchchk );
		}
	else
		{
		patchchk = pfmp->Patchchk();
		}

	patchchk->signDb = *psignDb;
	patchchk->signLog = *psignLog;
	patchchk->lgposAttach = *plgposAttach;
	patchchk->lgposConsistent = *plgposConsistent;
	patchchk->SetDbtime( dbtime );
	patchchk->SetObjidLast( objidLast );
	patchchk->SetCpgDatabaseSizeMax( cpgDatabaseSizeMax );
	pfmp->SetLgposAttach( *plgposAttach );

	return JET_errSuccess;
	}

LOCAL VOID LGRIReportUnableToReadDbHeader( const ERR err, const CHAR *szDbName )
	{
	CHAR		szT1[16];
	const CHAR	* rgszT[2];

	rgszT[0] = szDbName;
	sprintf( szT1, "%d", err );
	rgszT[1] = szT1;
 
	UtilReportEvent(
			eventWarning,
			LOGGING_RECOVERY_CATEGORY,
			RESTORE_DATABASE_READ_HEADER_WARNING_ID,
			2,
			rgszT );
	}

ERR LOG::ErrLGRICheckRedoCreateDb(
	IFileSystemAPI *const	pfsapi,
	const IFMP					ifmp,
	DBFILEHDR					*pdbfilehdr,
	REDOATTACH					*predoattach )
	{
	ERR				err;
	FMP	* 			pfmp		= &rgfmp[ifmp];
	ATCHCHK	* 		patchchk	= pfmp->Patchchk();
	const CHAR * 	szDbName 	= pfmp->SzDatabaseName();

	Assert( NULL != pfmp );
	Assert( NULL == pfmp->Pdbfilehdr() );
	Assert( NULL != patchchk );
	Assert( NULL != szDbName );
	Assert( NULL != pdbfilehdr );
	Assert( NULL != predoattach );
	
	Assert( !pfmp->FReadOnlyAttach() );
	err = ErrUtilReadAndFixShadowedHeader( pfsapi, szDbName, (BYTE*)pdbfilehdr, g_cbPage, OffsetOf( DBFILEHDR, le_cbPageSize ) );
	if ( err >= JET_errSuccess && pdbfilehdr->Dbstate() == JET_dbstateJustCreated )
		{
		// we have to delete the edb and the stm but we have to make sure
		// that the stm is matching if it exists
		if ( pdbfilehdr->FSLVExists() )
			{
			SLVFILEHDR *pslvfilehdr = NULL;
			err = ErrSLVAllocAndReadHeader(	pfsapi, 
											rgfmp[ifmp].FReadOnlyAttach(),
											rgfmp[ifmp].SzSLVName(),
											pdbfilehdr,
											&pslvfilehdr );
			// if the SLV file is missing, delete the EDB as well because it is just created
			if ( JET_errSLVStreamingFileMissing == err )
				{
				Assert( NULL == pslvfilehdr );
				err = JET_errSuccess;
				}
			else
				{
				if ( NULL != pslvfilehdr )
					{
					if ( JET_errDatabaseStreamingFileMismatch == err )
						{
						// we get mismatch but the signature is matching as
						//	we do get the header we know that it is the
						//	same db so we can delete the stm as well
						err = JET_errSuccess;
						}

					OSMemoryPageFree( (VOID *)pslvfilehdr );
					pslvfilehdr = NULL;
					}
				CallR( err );
				
				// the SLV and EDB are matching, we first delete the SLV
// ***			deletion now performed in ErrDBCreateDatabase() via JET_bitDbOverwriteExisting
// ***			CallR( pfsapi->ErrFileDelete( rgfmp[ifmp].SzSLVName() ) );
				}
			}

// ***	deletion now performed in ErrDBCreateDatabase() via JET_bitDbOverwriteExisting
// ***	CallR( pfsapi->ErrFileDelete( szDbName ) );

		*predoattach = redoattachCreate;
		return JET_errSuccess;
		}

	else if ( JET_errDiskIO == err
		|| ( err >= 0
			&& pdbfilehdr->Dbstate() != JET_dbstateConsistent
			&& pdbfilehdr->Dbstate() != JET_dbstateForceDetach
			&& pdbfilehdr->Dbstate() != JET_dbstateInconsistent ) )
		{
		// JET_dbstateJustCreated dealt with above
		Assert( JET_errDiskIO == err || pdbfilehdr->Dbstate() != JET_dbstateJustCreated );

		//	header checksums incorrectly or invalid state, so go ahead and recreate the db
		*predoattach = redoattachCreate;
		return JET_errSuccess;
		}

	else if ( err < 0 )
		{
		switch ( err )
			{
			case JET_errFileNotFound:
			case JET_errInvalidPath:
			case JET_errFileAccessDenied:
				//	assume database got deleted in the future
				*predoattach = redoattachDefer;
				err = JET_errSuccess;
				break;

			default:
				if ( !m_pinst->m_fNoInformationEvent )
					{
					LGRIReportUnableToReadDbHeader( err, szDbName );
					}
			}

		return err;
		}
	
	if ( memcmp( &pdbfilehdr->signLog, &m_signLog, sizeof( SIGNATURE ) ) != 0 )
		{
		CallR( ErrERRCheck( JET_errDatabaseLogSetMismatch ) );
		}

	const INT	i	= CmpLgpos( &pdbfilehdr->le_lgposAttach, &patchchk->lgposAttach );
	if ( 0 == i )
		{
		if ( 0 == memcmp( &pdbfilehdr->signDb, &patchchk->signDb, sizeof(SIGNATURE) ) )
			{
			if ( CmpLgpos( &patchchk->lgposAttach, &pdbfilehdr->le_lgposConsistent ) <= 0 )
				{
				//	db was brought to a consistent state in the future, so no
				//	need to redo operations until then, so attach null
				*predoattach = redoattachDefer;
				}
			else
				{
				CallR( ErrLGRICheckAttachNow( pdbfilehdr, szDbName ) );
			
				//	db never brought to consistent state after it was created
				Assert( 0 == CmpLgpos( &lgposMin, &pdbfilehdr->le_lgposConsistent ) );
				Assert( JET_dbstateInconsistent == pdbfilehdr->Dbstate() );
				*predoattach = redoattachNow;
				}
			}
		else
			{
			//	database has same log signature and lgposAttach as
			//	what was logged, but db signature is different - must
			//	have manipulated the db with logging disabled, which
			//	causes us to generate a new signDb.
			//	Defer this attachment.  We will attach later on when
			//	we hit the AttachDb log record matching this signDb.
			AssertTracking();
			*predoattach = redoattachDefer;
			}
		}
	else if ( i > 0 )
		{
		//	database was attached in the future (if db signatures match)
		//	or deleted then recreated in the future (if db signatures don't match),
		//	but in either case, we simply defer attachment to the future
		*predoattach = redoattachDefer;
		}
	else
		{
		//	this must be a different database (but with the same name)
		//	that was deleted in the past, so just overwrite it
		Assert( 0 != memcmp( &pdbfilehdr->signDb, &patchchk->signDb, sizeof(SIGNATURE) ) );
		*predoattach = redoattachCreate;
		}

	return err;
	}


ERR LOG::ErrLGRICheckRedoAttachDb(
	IFileSystemAPI *const	pfsapi,
	const IFMP					ifmp,
	DBFILEHDR					*pdbfilehdr,
	const SIGNATURE				*psignLogged,
	REDOATTACH					*predoattach,
	const REDOATTACHMODE		redoattachmode )
	{
	ERR				err;
	FMP * 			pfmp		= &rgfmp[ifmp];
	ATCHCHK * 		patchchk	= pfmp->Patchchk();
	const CHAR * 	szDbName 	= pfmp->SzDatabaseName();

	Assert( NULL != pfmp );
	Assert( NULL == pfmp->Pdbfilehdr() );
	Assert( NULL != patchchk );
	Assert( NULL != szDbName );
	Assert( NULL != pdbfilehdr );
	Assert( NULL != psignLogged );
	Assert( NULL != predoattach );
	
	Assert( !pfmp->FReadOnlyAttach() );
	err = ErrUtilReadAndFixShadowedHeader( pfsapi, szDbName, (BYTE*)pdbfilehdr, g_cbPage, OffsetOf( DBFILEHDR, le_cbPageSize ) );
	if ( JET_errDiskIO == err
		|| ( err >= 0
			&& pdbfilehdr->Dbstate() != JET_dbstateConsistent
			&& pdbfilehdr->Dbstate() != JET_dbstateForceDetach
			&& pdbfilehdr->Dbstate() != JET_dbstateInconsistent ) )
		{
		if ( JET_dbstateForceDetach == pdbfilehdr->Dbstate() )
			{
			CHAR		szT1[128];
			const CHAR	*rgszT[3];
			LOGTIME		tm;

			/*	log event that the database is not recovered completely
			/**/
			rgszT[0] = szDbName;
			tm = pdbfilehdr->signDb.logtimeCreate;
			sprintf( szT1, "%d/%d/%d %d:%d:%d",
				(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
				(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
			rgszT[1] = szT1;

			UtilReportEvent(
					eventError,
					LOGGING_RECOVERY_CATEGORY,
					RESTORE_DATABASE_MISSED_ERROR_ID,
					2,
					rgszT );
			}
		
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		return err;
		}
	else if ( err < 0 )
		{
		switch ( err )
			{
			case JET_errFileNotFound:
			case JET_errInvalidPath:
			case JET_errFileAccessDenied:
				//	assume database got deleted in the future
				*predoattach = redoattachDefer;
				err = JET_errSuccess;
				break;

			default:
				if ( !m_pinst->m_fNoInformationEvent )
					{
					LGRIReportUnableToReadDbHeader( err, szDbName );
					}
			}

		return err;
		}
	
	const BOOL	fMatchingSignDb			= ( 0 == memcmp( &pdbfilehdr->signDb, &patchchk->signDb, sizeof(SIGNATURE) ) );
	const BOOL	fMatchingSignLog		= ( 0 == memcmp( &pdbfilehdr->signLog, &m_signLog, sizeof(SIGNATURE) ) );
	const BOOL	fMatchingLoggedSignLog	= ( 0 == memcmp( &pdbfilehdr->signLog, psignLogged, sizeof(SIGNATURE) ) );

	if ( fMatchingSignLog )
		{
		//	db is in sync with current log set, so use normal attach logic below

		//	only way logged log signature doesn't match db log signature
		//	is if we're redoing an attachment
		Assert( fMatchingLoggedSignLog || redoattachmodeAttachDbLR == redoattachmode );
		}
	else if ( fMatchingLoggedSignLog )
		{
		//	if db matches prev log signature, then it should also match lgposConsistent
		//	(since dbfilehdr never got updated, it must have both prev log signature
		//	and prev lgposConsistent)
		if ( 0 == CmpLgpos( &patchchk->lgposConsistent, &pdbfilehdr->le_lgposConsistent ) )
			{
			if ( fMatchingSignDb )
				{
				Assert( !pfmp->FReadOnlyAttach() );
				CallR( ErrLGRICheckAttachNow( pdbfilehdr, szDbName ) );
			
				//	the attach operation was logged, but header was not changed.
				//	set up the header such that it looks like it is set up after
				//	attach (if this is currently a ReadOnly attach, the header
				//	update will be deferred to the next non-ReadOnly attach)
				Assert( redoattachmodeAttachDbLR == redoattachmode );
				Assert( 0 == CmpLgpos( &patchchk->lgposAttach, &m_lgposRedo ) );

				//	UNDONE: in theory, lgposAttach should already have been set
				//	when the ATCHCHK was setup, but ivantrin says he's not 100%
				//	sure, so to be safe, we definitely set the lgposAttach here
				Assert( 0 == CmpLgpos( patchchk->lgposAttach, pfmp->LgposAttach() ) );
				pfmp->SetLgposAttach( patchchk->lgposAttach );
				if ( pdbfilehdr->FSLVExists() )
					{
					SLVFILEHDR *pslvfilehdr = NULL;
					err = ErrSLVAllocAndReadHeader(	pfsapi, 
													rgfmp[ifmp].FReadOnlyAttach(),
													rgfmp[ifmp].SzSLVName(),
													pdbfilehdr,
													&pslvfilehdr );
					if ( pslvfilehdr == NULL )
						{
						CallR( err );
						}
					DBISetHeaderAfterAttach( pdbfilehdr, patchchk->lgposAttach, ifmp, fFalse /* no keep bkinfo */);
					Assert( pdbfilehdr->le_objidLast > 0 );
					Assert( pslvfilehdr != NULL );
					//	Previous attach succeeded to update only SLV header, but not a DB header
					if ( err < 0 )
						{
						//	if we successfully detached STM file, but database.
						//	reset consistent position
						pslvfilehdr->le_lgposConsistent = pdbfilehdr->le_lgposConsistent;
						err = ErrSLVCheckDBSLVMatch( pdbfilehdr, pslvfilehdr );
						}
					if ( err < 0 )
						{
						OSMemoryPageFree( (VOID *)pslvfilehdr );
						pslvfilehdr = NULL;
						CallR( err );
						}
					Assert( pslvfilehdr != NULL );
					err = ErrSLVSyncHeader(	pfsapi, 
											rgfmp[ifmp].FReadOnlyAttach(),
											rgfmp[ifmp].SzSLVName(), 
											pdbfilehdr, 
											pslvfilehdr );
					OSMemoryPageFree( (VOID *)pslvfilehdr );
					pslvfilehdr = NULL;
					CallR( err );	
					}
				else
					{
					DBISetHeaderAfterAttach( pdbfilehdr, patchchk->lgposAttach, ifmp, fFalse /* no keep bkinfo */);
					Assert( pdbfilehdr->le_objidLast > 0 );
					}
				CallR( ErrUtilWriteShadowedHeader(	pfsapi, 
													szDbName,
													fTrue,
													(BYTE *)pdbfilehdr, 
													g_cbPage ) );
				*predoattach = redoattachNow;
				}
			else
				{
				//	database has same log signature and lgposConsistent as
				//	what was logged, but db signature is different - must
				//	have manipulated the db with logging disabled, which
				//	causes us to generate a new signDb.
				//	Defer this attachment.  We will attach later on when
				//	we hit the AttachDb log record matching this signDb.
				AssertTracking();
				*predoattach = redoattachDefer;
				}
			}
		else
			{
			if ( fMatchingSignDb )
				{
				//	this should be impossible, because it means that we missed
				//	replaying a shutdown (to bring the db to a consistent state)
				Assert( fFalse );
				err = ErrERRCheck( JET_errConsistentTimeMismatch );
				}
			else
				{
				*predoattach = redoattachDefer;
				}
			}

		return err;
		}
	else
		{
		//	the database's log signature is not the same as current log set or
		//	as the log set before it was attached, so just ignore it
		*predoattach = redoattachDefer;
		return JET_errSuccess;
		}

	const INT	i	= CmpLgpos( &pdbfilehdr->le_lgposConsistent, &patchchk->lgposConsistent );

	//	if log signature in db header doesn't match logged log signature,
	//	then comparing lgposConsistent is irrelevant and must instead
	//	rely on lgposAttach comparison
	if ( !fMatchingLoggedSignLog
		|| 0 == i
		|| 0 == CmpLgpos( &pdbfilehdr->le_lgposConsistent, &lgposMin ) )
		{
		if ( fMatchingSignDb )
			{
			const INT	j	= CmpLgpos( &pdbfilehdr->le_lgposAttach, &patchchk->lgposAttach );
			if ( 0 == j )
				{
				CallR( ErrLGRICheckAttachNow( pdbfilehdr, szDbName ) );
			
				//	either lgposAttach also matches, or we're redoing a new attach
				*predoattach = redoattachNow;
				}
			else if ( j < 0 )
				{
				if ( redoattachmodeAttachDbLR == redoattachmode && fMatchingLoggedSignLog )
					{
					CallR( ErrLGRICheckAttachNow( pdbfilehdr, szDbName ) );
					*predoattach = redoattachNow;
					}
				else
					{
					//	lgposConsistent match, but the lgposAttach in the database is before
					//	the logged lgposAttach, which means the attachment was somehow skipped
					//	in this database (typically happens when a file copy of the database
					//	is copied back in)
					LGReportAttachedDbMismatch( szDbName, fFalse );
					AssertTracking();
					CallR( ErrERRCheck( JET_errAttachedDatabaseMismatch ) );
					}
				}
			else
				{
				// Removed the following assert. The assert where probably here when
				// the 3rd OR condition (0 == CmpLgpos( &pdbfilehdr->le_lgposConsistent, &lgposMin ) )
				// was missing. See bug X5:114743 for the scenario in with the assert is false 
				// and we have to defer the attachements
				//	only way we could have same lgposConsistent, but lgposAttach
				//	in db is in the future is if this is a ReadOnly attach
				//Assert( redoattachmodeAttachDbLR == redoattachmode );
				//Assert( fReadOnly || !fMatchingLoggedSignLog );
				
				*predoattach = redoattachDefer;
				}
			}
		else
			{
#ifdef DEBUG			
			//	database has same log signature and lgposConsistent as
			//	what was logged, but db signature is different - must
			//	have recreated db or manipulated it with logging disabled,
			//	which causes us to generate a new signDb
			if ( 0 == CmpLgpos( &pdbfilehdr->le_lgposConsistent, &lgposMin ) )
				{
				//	there's a chance we can still hook up with the correct
				//	signDb in the future
				}
			else
				{
				//	can no longer replay operations against this database
				//	because we've hit a point where logging was disabled
				//	UNDONE: add eventlog entry
				AssertTracking();
				}
#endif

			*predoattach = redoattachDefer;
			}
		}
	else if ( i > 0
		&& ( redoattachmodeInitBeforeRedo == redoattachmode 
			|| CmpLgpos( &pdbfilehdr->le_lgposConsistent, &m_lgposRedo ) > 0 ) )
		{
		//	database was brought to a consistent state in the future
		//	(if db signatures match) or deleted then recreated and 
		//	reconsisted in the future (if db signatures don't match),
		//	but in either case, we simply defer attachment to the future
		Assert( redoattachmodeInitBeforeRedo == redoattachmode
			|| redoattachmodeAttachDbLR == redoattachmode );
		Assert( 0 != CmpLgpos( &pdbfilehdr->le_lgposConsistent, &lgposMin ) );
		Assert( CmpLgpos( &pdbfilehdr->le_lgposAttach, &patchchk->lgposAttach ) >= 0 );
		*predoattach = redoattachDefer;
		}
	else
		{
		if ( fMatchingSignDb )
			{
			//	One way to get here is to do the following:
			//		- shutdown cleanly
			//		- make a file copy of the db
			//		- start up and re-attach
			//		- make a backup
			//		- shutdown cleanly
			//		- copy back original database
			//		- start up and re-attach
			//		- shutdown cleanly
			//		- restore from backup
			//	When hard recovery hits the attachment to the
			//	original database, the dbfilehdr's lgposConsistent
			//	will be greater than the logged one, but less
			//	than the current lgposRedo.
			//
			//	Another way to hit this is if the lgposConsistent
			//	in the dbfilehdr is less than the logged lgposConsistent.
			//	This is usually caused when an old copy of the database
			//	is being played against a more current copy of the log files.
			//
			AssertTracking();
			CallR( ErrERRCheck( JET_errConsistentTimeMismatch ) );
			}
		else
			{
			Assert( 0 != CmpLgpos( &pdbfilehdr->le_lgposConsistent, &lgposMin ) );

			//	database has been manipulated with logging disabled in
			//	the past.  Therefore, we cannot replay operations
			//	since we are missing the non-logged operations.
			//	UNDONE: add eventlog entry
			AssertTracking();

			*predoattach = redoattachDefer;
			}
		}

	return err;
	}

			
ERR LOG::ErrLGRICheckAttachedDb(
	IFileSystemAPI *const	pfsapi,
	const IFMP					ifmp,
	const SIGNATURE				*psignLogged,			//	pass NULL for CreateDb
	REDOATTACH					*predoattach,
	const REDOATTACHMODE		redoattachmode )
	{
	ERR				err;
	FMP				*pfmp		= &rgfmp[ifmp];
	DBFILEHDR		*pdbfilehdr;

	Assert( NULL != pfmp );
	Assert( NULL == pfmp->Pdbfilehdr() );
	Assert( NULL != pfmp->Patchchk() );
	Assert( NULL != predoattach );

	pdbfilehdr = (DBFILEHDR *)PvOSMemoryPageAlloc( g_cbPage, NULL );
	if ( NULL == pdbfilehdr )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	Assert( !pfmp->FReadOnlyAttach() );
	if ( redoattachmodeCreateDbLR == redoattachmode )
		{
		Assert( NULL == psignLogged );
		err = ErrLGRICheckRedoCreateDb( pfsapi, ifmp, pdbfilehdr, predoattach );
		}
	else
		{
		Assert( NULL != psignLogged );
		err = ErrLGRICheckRedoAttachDb(
					pfsapi,
					ifmp,
					pdbfilehdr,
					psignLogged,
					predoattach,
					redoattachmode );
		Assert( redoattachCreate != *predoattach );
		}

	//	if redoattachCreate, dbfilehdr will be allocated
	//	when we re-create the db
	if ( err >= 0 && redoattachCreate != *predoattach )
		{
		const ATCHCHK	*patchchk	= pfmp->Patchchk();
		Assert( NULL != patchchk );
		
		const DBTIME	dbtime	= max( (DBTIME) patchchk->Dbtime(), (DBTIME) pdbfilehdr->le_dbtimeDirtied );
		const OBJID		objid	= max( (OBJID) patchchk->ObjidLast(), (OBJID) pdbfilehdr->le_objidLast );

		pfmp->SetDbtimeLast( dbtime );
		pfmp->SetObjidLast( objid );
		err = pfmp->ErrSetPdbfilehdr( pdbfilehdr );
		CallS( err );
		}
	else
		{
		OSMemoryPageFree( pdbfilehdr );
		}

	return err;
	}

//	we've determined this is the correct attachment point,
//	but first check database header for possible logfile mismatches
LOCAL ERR LOG::ErrLGRICheckAttachNow(
	DBFILEHDR	* pdbfilehdr,
	const CHAR	* szDbName )
	{
	ERR			err					= JET_errSuccess;
	const LONG	lGenMinRequired		= pdbfilehdr->le_lGenMinRequired;
	const LONG	lGenCurrent			= m_plgfilehdr->lgfilehdr.le_lGeneration;
		
	if ( lGenMinRequired			//	0 means db is consistent or this is an ESE97 db
		&& lGenMinRequired < lGenCurrent )
		{
		const LONG	lGenMaxRequired	= pdbfilehdr->le_lGenMaxRequired;
		CHAR		szT1[16];
		CHAR		szT2[16];
		CHAR		szT3[16];
		const UINT	csz = 4;
		const CHAR *rgszT[csz];

		rgszT[0] = szDbName;
		sprintf( szT1, "%d", lGenMinRequired );
		rgszT[1] = szT1;
		sprintf( szT2, "%d", lGenMaxRequired );
		rgszT[2] = szT2;
		sprintf( szT3, "%d", lGenCurrent );
		rgszT[3] = szT3;
		
		UtilReportEvent( 
				eventError, 
				LOGGING_RECOVERY_CATEGORY,
				REDO_MISSING_LOW_LOG_ERROR_ID, 
				sizeof( rgszT ) / sizeof( rgszT[ 0 ] ), 	
				rgszT, 
				0, 
				NULL, 
				m_pinst );

		err = ErrERRCheck( JET_errRequiredLogFilesMissing );
		}

	else if ( pdbfilehdr->bkinfoFullCur.le_genLow && !m_fHardRestore )
		{
		//	soft recovery on backup set database
		const CHAR	*rgszT[1];

		rgszT[0] = szDbName;
	
		//	attempting to use a database which did not successfully
		//	complete conversion
		UtilReportEvent(
				eventError,
				LOGGING_RECOVERY_CATEGORY,
				ATTACH_TO_BACKUP_SET_DATABASE_ERROR_ID,
				1,
				rgszT );
							
		//	soft recovery on backup set database
		err = ErrERRCheck( JET_errSoftRecoveryOnBackupDatabase );
		}


	return err;
	}

ERR LOG::ErrLGRIRedoCreateDb(
	PIB				*ppib,
	const IFMP		ifmp,
	const DBID		dbid,
	const JET_GRBIT	grbit,
	SIGNATURE		*psignDb )
	{
	ERR				err;
	FMP				*pfmp	= &rgfmp[ifmp];
	IFMP			ifmpT	= ifmp;
	const CHAR		*szDbName = pfmp->SzDatabaseName() ;
	const CHAR		*szSLVName = pfmp->SzSLVName() ;
	const CHAR		*szSLVRoot = pfmp->SzSLVRoot();

	Assert( dbid < dbidMax );
	Assert( dbidTemp != dbid );
	CallR( ErrDBCreateDatabase(
				ppib,
				NULL,
				szDbName,
				szSLVName,
				szSLVRoot,
				0,
				&ifmpT,
				dbid,
				cpgDatabaseMin,
				grbit,
				psignDb ) );
	Assert( ifmp == ifmpT );

	/*	close it as it will get reopened on first use
	/**/
	CallR( ErrDBCloseDatabase( ppib, ifmp, 0 ) );
	CallSx( err, JET_wrnDatabaseAttached );

	/*	restore information stored in database file
	/**/
	BKINFO * pbkInfoToCopy;
					
	if ( FSnapshotRestore() )
		{
		pbkInfoToCopy = &(pfmp->Pdbfilehdr()->bkinfoSnapshotCur);
		}
	else
		{
		pbkInfoToCopy = &(pfmp->Pdbfilehdr()->bkinfoFullCur);
		}

	pbkInfoToCopy->le_genLow = m_lGenLowRestore;
	pbkInfoToCopy->le_genHigh = m_lGenHighRestore;

	pfmp->SetDbtimeCurrentDuringRecovery( pfmp->DbtimeLast() );

	Assert( pfmp->Pdbfilehdr()->le_objidLast == pfmp->ObjidLast() );

	return err;
	}

ERR LOG::ErrLGRIRedoAttachDb(
	IFileSystemAPI *const	pfsapi,
	const IFMP					ifmp,
	const CPG					cpgDatabaseSizeMax,
	const REDOATTACHMODE		redoattachmode )
	{
	ERR				err			= JET_errSuccess;
	FMP				*pfmp		= &rgfmp[ifmp];
	const DBID		dbid		= pfmp->Dbid();
	IFileAPI	*pfapi;
	const CHAR					*szDbName = pfmp->SzDatabaseName();

	Assert( NULL != pfmp );
	Assert( NULL != szDbName );

#ifdef ELIMINATE_PATCH_FILE
#else
	if ( m_fHardRestore )
		{
		//	load patch file only for inconsistent backup databases
		if ( JET_dbstateInconsistent == pfmp->Pdbfilehdr()->Dbstate() )
			{
			CallR( ErrLGPatchDatabase( pfsapi, ifmp, dbid ) );
			}
		}
#endif

	const BOOL fSLVProviderNotEnabled = pfmp->FSLVProviderNotEnabled();
	
	/*	Do not re-create the database. Simply attach it. Assuming the
	 *	given database is a good one since signature matches.
	 */
	pfmp->ResetFlags();
	pfmp->SetAttached();

	pfmp->SetDatabaseSizeMax( cpgDatabaseSizeMax );
	Assert( pfmp->CpgDatabaseSizeMax() != 0xFFFFFFFF );

	// Versioning flag is not persisted (since versioning off
	// implies logging off).
	Assert( !pfmp->FVersioningOff() );
	pfmp->ResetVersioningOff();

	// If there's a log record for CreateDatabase(), then logging
	// must be on.
	Assert( !pfmp->FLogOn() );
	pfmp->SetLogOn();
	
	/*	Update database file header as necessary
	 */
	Assert( !pfmp->FReadOnlyAttach() );
	BOOL	fUpdateHeader	= fFalse;
	SLVFILEHDR *pslvfilehdr = NULL;
	ERR	errSLV = JET_errSuccess;

	if ( pfmp->Pdbfilehdr()->FSLVExists() )
		{
		errSLV = ErrSLVAllocAndReadHeader(	pfsapi, 
										rgfmp[ifmp].FReadOnlyAttach(),
										rgfmp[ifmp].SzSLVName(),
										rgfmp[ifmp].Pdbfilehdr(),
										&pslvfilehdr );
		if ( pslvfilehdr == NULL )
			{
			CallR( errSLV );
			}
		}
	if ( redoattachmodeAttachDbLR == redoattachmode )
		{
		BOOL	fKeepBackupInfo = m_fHardRestore;

		//	on attach after a hard restore, the attach must be created
		//	by previous recovery undo mode. Do not erase backup info then.
		if ( fKeepBackupInfo )
			{
			const INT irstmap = IrstmapSearchNewName( szDbName ) ;
			Assert ( 0 <= irstmap );
			fKeepBackupInfo = (0 == UtilCmpFileName(m_rgrstmap[irstmap].szDatabaseName, m_rgrstmap[irstmap].szNewDatabaseName ) );
			}
			
		//	UNDONE: in theory, lgposAttach should already have been set
		//	when the ATCHCHK was setup, but ivantrin says he's not 100%
		//	sure, so to be safe, we definitely set the lgposAttach here
		Assert( 0 == CmpLgpos( m_lgposRedo, pfmp->LgposAttach() ) );
		pfmp->SetLgposAttach( m_lgposRedo );
		DBISetHeaderAfterAttach( pfmp->Pdbfilehdr(), m_lgposRedo, ifmp, fKeepBackupInfo );
		fUpdateHeader = fTrue;
		}
	else if ( JET_dbstateInconsistent != pfmp->Pdbfilehdr()->Dbstate() )
		{
		//	must force inconsistent during recovery (may currently be marked as
		//	consistent because we replayed a RcvQuit and are now replaying an Init)
		FireWall();		//	should no longer be possible with forced detach on shutdown
		pfmp->Pdbfilehdr()->SetDbstate( JET_dbstateInconsistent, m_plgfilehdr->lgfilehdr.le_lGeneration, &m_plgfilehdr->lgfilehdr.tmCreate );
		fUpdateHeader = fTrue;
		}

	if ( pfmp->Pdbfilehdr()->FSLVExists() )
		{
		if ( errSLV < JET_errSuccess )
			{
			//	if we successfully detached STM file, but database.
			//	reset consistent position
			Assert( NULL != pslvfilehdr );
			pslvfilehdr->le_lgposConsistent = pfmp->Pdbfilehdr()->le_lgposConsistent;
			err = ErrSLVCheckDBSLVMatch( pfmp->Pdbfilehdr(), pslvfilehdr );
			fUpdateHeader = fTrue;
			}
		OSMemoryPageFree( (VOID*) pslvfilehdr );
		CallR( err );
		}

	//	SoftRecoveryOnBackupDatabase check should already have been performed in
	//	ErrLGRICheckAttachedDb()
	Assert( 0 == pfmp->Pdbfilehdr()->bkinfoFullCur.le_genLow
		|| m_fHardRestore );
		
	if ( fUpdateHeader )
		{
		Assert( pfmp->Pdbfilehdr()->le_objidLast > 0 );
		if ( pfmp->Pdbfilehdr()->FSLVExists() )
			{
			CallR( ErrSLVSyncHeader(	pfsapi, 
										rgfmp[ifmp].FReadOnlyAttach(),
										rgfmp[ifmp].SzSLVName(),
										rgfmp[ifmp].Pdbfilehdr() ) );
			}
		CallR( ErrUtilWriteShadowedHeader(	pfsapi, 
											szDbName,
											fTrue,
											(BYTE *)pfmp->Pdbfilehdr(), 
											g_cbPage ) );
		}

	Assert( JET_dbstateInconsistent == pfmp->Pdbfilehdr()->Dbstate() );

	/*	restore information stored in database file
	/**/
	BKINFO * pbkInfoToCopy;
					
	if ( FSnapshotRestore() )
		{
		pbkInfoToCopy = &(pfmp->Pdbfilehdr()->bkinfoSnapshotCur);
		}
	else
		{
		pbkInfoToCopy = &(pfmp->Pdbfilehdr()->bkinfoFullCur);
		}
		
	pbkInfoToCopy->le_genLow = m_lGenLowRestore;
	pbkInfoToCopy->le_genHigh = m_lGenHighRestore;

	CallR( pfsapi->ErrFileOpen( szDbName, &pfapi ) );
	pfmp->SetPfapi( pfapi );
	pfmp->SetDbtimeCurrentDuringRecovery( 0 );
	Assert( pfmp->ObjidLast() == pfmp->Pdbfilehdr()->le_objidLast
		|| ( pfmp->ObjidLast() > pfmp->Pdbfilehdr()->le_objidLast && redoattachmodeInitBeforeRedo == redoattachmode ) );

	Assert( !pfmp->FReadOnlyAttach() );

	// we allow header update before starting o log any operation
	pfmp->SetAllowHeaderUpdate();

	if ( pfmp->Pdbfilehdr()->FSLVExists() )
		{
		//	must call after setting ReadOnly flag because this functions reads the flag

		CallR( ErrFILEOpenSLV( pfsapi, ppibNil, ifmp ) );
		}

	/*	Keep extra copy of patchchk for error message.
	 */
	CallR( pfmp->ErrCopyAtchchk() );

	return err;
	}

VOID LOG::LGRISetDeferredAttachment( const IFMP ifmp )
	{
	FMP		*pfmp	= &rgfmp[ifmp];

	Assert( NULL != pfmp );
	
	Assert( !pfmp->Pfapi() );
	Assert( pfmp->FInUse() );
	Assert( NULL != pfmp->Pdbfilehdr() );
	pfmp->FreePdbfilehdr();

	// Versioning flag is not persisted (since versioning off
	// implies logging off).
	Assert( !pfmp->FVersioningOff() );
	pfmp->ResetVersioningOff();			//	

	Assert( !pfmp->FReadOnlyAttach() );
	//	still have to set fFlags for keep track of the db status.
///	Assert( !pfmp->FLogOn() );
	pfmp->SetLogOn( );


	pfmp->SetDeferredAttach();
	}

#ifdef UNLIMITED_DB
LOCAL ERR LOG::ErrLGRIRedoInitialAttachments_( IFileSystemAPI *const pfsapi )
	{
	ERR		err		= JET_errSuccess;

	/*	Make sure all the attached database are consistent!
	 */
	for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP		ifmp		= m_pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;

		FMP			*pfmp		= &rgfmp[ifmp];
		CHAR		*szDbName;
		REDOATTACH	redoattach;

		if ( !pfmp->FInUse() || !pfmp->Patchchk() )
			continue;

		szDbName = pfmp->SzDatabaseName();
		Assert ( szDbName );

		if ( m_fHardRestore || m_irstmapMac > 0 )
			{
			if ( 0 > IrstmapSearchNewName( szDbName ) )
				{
				/*	not in the restore map, set to skip it.
				 */
				Assert( pfmp->Pdbfilehdr() == NULL );
				pfmp->SetSkippedAttach();
				err = JET_errSuccess;
				continue;
				}
			}

		Assert( !pfmp->FReadOnlyAttach() );
		Call( ErrLGRICheckAttachedDb(
					pfsapi,
					ifmp,
					&m_signLog,
					&redoattach,
					redoattachmodeInitBeforeRedo ) );
		Assert( NULL != pfmp->Pdbfilehdr() );

		switch ( redoattach )
			{
			case redoattachNow:
				Assert( !pfmp->FReadOnlyAttach() );
				Call( ErrLGRIRedoAttachDb(
							pfsapi,
							ifmp,
							pfmp->Patchchk()->CpgDatabaseSizeMax(),
							redoattachmodeInitBeforeRedo ) );
				break;

			case redoattachCreate:
			default:
				Assert( fFalse );	//	should be impossible, but as a firewall, set to defer the attachment
			case redoattachDefer:
				Assert( !pfmp->FReadOnlyAttach() );
				LGRISetDeferredAttachment( ifmp );
				break;
			}

		/* keep attachment info and update it. */
		Assert( pfmp->Patchchk() != NULL );
		}

HandleError:
	return err;
	}
#endif	//	UNLIMITED_DB


ERR LOG::ErrLGRIRedoSpaceRootPage( 	PIB 				*ppib, 
									const LRCREATEMEFDP *plrcreatemefdp, 
									BOOL 				fAvail )
	{
	ERR			err;
	const DBID	dbid 		= plrcreatemefdp->dbid;
	const PGNO	pgnoFDP		= plrcreatemefdp->le_pgno;
	const OBJID	objidFDP	= plrcreatemefdp->le_objidFDP;
	const CPG	cpgPrimary	= plrcreatemefdp->le_cpgPrimary;
	const PGNO	pgnoRoot	= fAvail ? 
									plrcreatemefdp->le_pgnoAE : 
									plrcreatemefdp->le_pgnoOE ;
	const CPG	cpgExtent	= fAvail ?
								cpgPrimary - 1 - 1 - 1 :
								cpgPrimary;

	const PGNO	pgnoLast 	= pgnoFDP + cpgPrimary - 1;
	const ULONG	fPageFlags	= plrcreatemefdp->le_fPageFlags;
								
	FUCB		*pfucb		= pfucbNil;

	CSR		csr;
	INST	*pinst = PinstFromPpib( ppib );
	IFMP	ifmp = pinst->m_mpdbidifmp[ dbid ];

	//	could be a page beyond db-size for a hard-restore
	//
	err = ErrLGIAccessPage( ppib, &csr, ifmp, pgnoRoot );

	//	check if the FDP page need be redone
	//
	if ( err >= 0 && !FLGNeedRedoPage( csr, plrcreatemefdp->le_dbtime ) )
		{
		csr.ReleasePage();
		goto HandleError;
		}

	if ( err >= 0 )
		{
		csr.ReleasePage();
		}
	Assert( !csr.FLatched() );

	LGRITraceRedo( plrcreatemefdp );

	Call( ErrLGRIGetFucb( m_ptablehfhash, ppib, ifmp, pgnoFDP, objidFDP, plrcreatemefdp->FUnique(), fTrue, &pfucb ) );
	pfucb->u.pfcb->SetPgnoOE( plrcreatemefdp->le_pgnoOE );
	pfucb->u.pfcb->SetPgnoAE( plrcreatemefdp->le_pgnoAE );
	Assert( plrcreatemefdp->le_pgnoOE + 1 == plrcreatemefdp->le_pgnoAE );

	Assert( FFUCBOwnExt( pfucb ) );
	FUCBResetOwnExt( pfucb );

	Call( csr.ErrGetNewPageForRedo(
					ppib, 
					ifmp,
					fAvail ? PgnoAE( pfucb ) : PgnoOE( pfucb ), 
					objidFDP,
					plrcreatemefdp->le_dbtime,
					fPageFlags | CPAGE::fPageRoot | CPAGE::fPageLeaf | CPAGE::fPageSpaceTree ) );

	SPICreateExtentTree( pfucb, &csr, pgnoLast, cpgExtent, fAvail );
	
	//	set dbtime to logged dbtime
	//	release page 
	//
	Assert( latchWrite == csr.Latch() );
	csr.SetDbtime( plrcreatemefdp->le_dbtime );
	csr.ReleasePage();

HandleError:
	if ( pfucb != pfucbNil )
		{
		FUCBSetOwnExt( pfucb );
		}
		
	Assert( !csr.FLatched() );
	return err;
	}
	

//	redo single extent creation
//
LOCAL ERR ErrLGIRedoFDPPage( TABLEHFHASH *ptablehfhash, PIB *ppib, const LRCREATESEFDP *plrcreatesefdp )
	{
	ERR				err;
	const DBID		dbid 		= plrcreatesefdp->dbid;
	const PGNO		pgnoFDP		= plrcreatesefdp->le_pgno;
	const OBJID		objidFDP	= plrcreatesefdp->le_objidFDP;
	const DBTIME	dbtime		= plrcreatesefdp->le_dbtime;
	const PGNO		pgnoParent	= plrcreatesefdp->le_pgnoFDPParent;
	const CPG		cpgPrimary	= plrcreatesefdp->le_cpgPrimary;
	const BOOL		fUnique		= plrcreatesefdp->FUnique();
	const ULONG		fPageFlags	= plrcreatesefdp->le_fPageFlags;


	FUCB			*pfucb;
	CSR				csr;
	INST			*pinst = PinstFromPpib( ppib );
	IFMP			ifmp = pinst->m_mpdbidifmp[ dbid ];

	//	could be a page beyond db-size for a hard-restore
	//
	err = ErrLGIAccessPage( ppib, &csr, ifmp, pgnoFDP );

	//	check if the FDP page need be redone
	//
	if ( err >= 0 && !FLGNeedRedoPage( csr, dbtime ) )
		{
		csr.ReleasePage();
		goto HandleError;
		}

	if ( err >= 0 )
		{
		csr.ReleasePage();
		}
	Assert( !csr.FLatched() );

	Call( ErrLGRIGetFucb( ptablehfhash, ppib, ifmp, pgnoFDP, objidFDP, fUnique, fFalse, &pfucb ) );
	pfucb->u.pfcb->SetPgnoOE( pgnoNull );
	pfucb->u.pfcb->SetPgnoAE( pgnoNull );

	//	UNDONE: I can't tell if it's possible to get a cached FCB that used to belong to
	//	a different btree, so to be safe, reset the values for objidFDP and fUnique
	pfucb->u.pfcb->SetObjidFDP( objidFDP );
	if ( fUnique )
		pfucb->u.pfcb->SetUnique();
	else
		pfucb->u.pfcb->SetNonUnique();

	//	It is okay to call ErrGetNewPage() instead of ErrGetNewPageForRedo()
	//	here because if the new page succeeds, we are guaranteed to make it
	//	to the code below that updates the dbtime
	Call( ErrSPICreateSingle(
				pfucb,
				&csr,
				pgnoParent,
				pgnoFDP,
				objidFDP,
				cpgPrimary,
				fUnique,
				fPageFlags ) );

	//	set dbtime to logged dbtime
	//	release page 
	//
	Assert( latchWrite == csr.Latch() );
	csr.SetDbtime( dbtime );
	csr.ReleasePage();

HandleError:
	Assert( !csr.FLatched() );
	return err;
	}
	

//	redo multiple extent creation
//
LOCAL ERR ErrLGIRedoFDPPage( TABLEHFHASH *ptablehfhash, PIB *ppib, const LRCREATEMEFDP *plrcreatemefdp )
	{
	ERR				err;
	const DBID		dbid 		= plrcreatemefdp->dbid;
	const PGNO		pgnoFDP		= plrcreatemefdp->le_pgno;
	const OBJID		objidFDP	= plrcreatemefdp->le_objidFDP;
	const DBTIME	dbtime		= plrcreatemefdp->le_dbtime;
	const PGNO		pgnoOE		= plrcreatemefdp->le_pgnoOE;
	const PGNO		pgnoAE		= plrcreatemefdp->le_pgnoAE;
	const PGNO		pgnoParent	= plrcreatemefdp->le_pgnoFDPParent;
	const CPG		cpgPrimary	= plrcreatemefdp->le_cpgPrimary;
	const BOOL		fUnique		= plrcreatemefdp->FUnique();
	const ULONG		fPageFlags	= plrcreatemefdp->le_fPageFlags;

	FUCB			*pfucb;
	SPACE_HEADER	sph;

	CSR		csr;
	INST			*pinst = PinstFromPpib( ppib );
	IFMP			ifmp = pinst->m_mpdbidifmp[ dbid ];

	//	could be a page beyond db-size for a hard-restore
	//
	err = ErrLGIAccessPage( ppib, &csr, ifmp, pgnoFDP );

	//	check if the FDP page need be redone
	//
	if ( err >= 0 && !FLGNeedRedoPage( csr, dbtime ) )
		{
		csr.ReleasePage();
		goto HandleError;
		}

	if ( err >= 0 )
		{
		csr.ReleasePage();
		}
	Assert( !csr.FLatched() );

	Call( ErrLGRIGetFucb( ptablehfhash, ppib, ifmp, pgnoFDP, objidFDP, fUnique, fFalse, &pfucb ) );
	pfucb->u.pfcb->SetPgnoOE( pgnoOE );
	pfucb->u.pfcb->SetPgnoAE( pgnoAE );
	Assert( pgnoOE + 1 == pgnoAE );

	//	UNDONE: I can't tell if it's possible to get a cached FCB that used to belong to
	//	a different btree, so to be safe, reset the values for objidFDP and fUnique
	pfucb->u.pfcb->SetObjidFDP( objidFDP );
	if ( fUnique )
		pfucb->u.pfcb->SetUnique();
	else
		pfucb->u.pfcb->SetNonUnique();

	//	get pgnoFDP to initialize in current CSR pgno
	//
	Call( csr.ErrGetNewPageForRedo(
					pfucb->ppib,
					pfucb->ifmp,
					pgnoFDP,
					objidFDP,
					dbtime,
					fPageFlags | CPAGE::fPageRoot | CPAGE::fPageLeaf ) );

	sph.SetPgnoParent( pgnoParent );
	sph.SetCpgPrimary( cpgPrimary );
	
	Assert( sph.FSingleExtent() );	// initialised with these defaults
	Assert( sph.FUnique() );

	sph.SetMultipleExtent();
	
	if ( !fUnique )
		sph.SetNonUnique();
	
	sph.SetPgnoOE( pgnoOE );
	Assert( sph.PgnoOE() == pgnoFDP + 1 );

	SPIInitPgnoFDP( pfucb, &csr, sph );

	//	set dbtime to logged dbtime
	//	release page 
	//
	Assert( latchWrite == csr.Latch() );
	csr.SetDbtime( dbtime );
	csr.ReleasePage();

HandleError:
	Assert( !csr.FLatched() );
	return err;
	}


ERR	LOG::ErrLGRIRedoConvertFDP( PIB *ppib, const LRCONVERTFDP *plrconvertfdp )
	{
	ERR				err;
	const PGNO		pgnoFDP				= plrconvertfdp->le_pgno;
	const OBJID		objidFDP			= plrconvertfdp->le_objidFDP;
	const DBID		dbid				= plrconvertfdp->dbid;
	const DBTIME	dbtime				= plrconvertfdp->le_dbtime;
	const PGNO		pgnoAE				= plrconvertfdp->le_pgnoAE;
	const PGNO		pgnoOE				= plrconvertfdp->le_pgnoOE;
	const PGNO		pgnoSecondaryFirst	= plrconvertfdp->le_pgnoSecondaryFirst;
	const CPG		cpgSecondary		= plrconvertfdp->le_cpgSecondary;
	
	BOOL			fRedoAE;
	BOOL			fRedoOE;
	FUCB			*pfucb = pfucbNil;
	SPACE_HEADER	sph;
	EXTENTINFO		rgext[(cpgSmallSpaceAvailMost+1)/2 + 1];
	INT				iextMac = 0;

	CSR		csrRoot;
	CSR		csrAE;
	CSR		csrOE;
	INST			*pinst = PinstFromPpib( ppib );
	IFMP			ifmp = pinst->m_mpdbidifmp[ dbid ];

	LGRITraceRedo( plrconvertfdp );

	//	get cursor for operation
	//
	Assert( rgfmp[ifmp].Dbid() == dbid );
	Call( ErrLGRIGetFucb( m_ptablehfhash, ppib, ifmp, pgnoFDP, objidFDP, plrconvertfdp->FUnique(), fTrue, &pfucb ) );
	pfucb->u.pfcb->SetPgnoOE( pgnoOE );
	pfucb->u.pfcb->SetPgnoAE( pgnoAE );
	Assert( pgnoOE + 1 == pgnoAE );

	//	could be a page beyond db-size for a hard-restore
	//
	Call( ErrLGIAccessPage( ppib, &csrRoot, ifmp, pgnoFDP ) );

	//	check if the FDP page need be redone
	//
	if ( !FLGNeedRedoCheckDbtimeBefore( csrRoot, dbtime, plrconvertfdp->le_dbtimeBefore, &err ) )
		{
		//	read in AvailExt and OwnExt root pages (get from patch file if necessary)
		//	and verify they don't have to be redone either.

		Call( ErrLGRIAccessNewPage( ppib, &csrAE, ifmp, pgnoAE, dbtime, NULL, fFalse, &fRedoAE ) );
		Call( ErrLGRIAccessNewPage( ppib, &csrOE, ifmp, pgnoOE, dbtime, NULL, fFalse, &fRedoOE ) );

		Assert( !fRedoAE );
		Assert( !fRedoOE );

		err = JET_errSuccess;
		goto HandleError;
		}

	// for the FLGNeedRedoCheckDbtimeBefore error code
	Call ( err );

	ULONG fPageFlags;
	fPageFlags = csrRoot.Cpage().FFlags()
					& ~CPAGE::fPageRepair
					& ~CPAGE::fPageRoot
					& ~CPAGE::fPageLeaf
					& ~CPAGE::fPageParentOfLeaf;

	//	get AvailExt and OwnExt root pages from db or patch file
	Call( ErrLGRIAccessNewPage( ppib, &csrAE, ifmp, pgnoAE, dbtime, NULL, fTrue, &fRedoAE ) );
	Call( ErrLGRIAccessNewPage( ppib, &csrOE, ifmp, pgnoOE, dbtime, NULL, fTrue, &fRedoOE ) );

	SPIConvertGetExtentinfo( pfucb, &csrRoot, &sph, rgext, &iextMac );
	Assert( sph.FSingleExtent() );
	sph.SetMultipleExtent();
	sph.SetPgnoOE( pgnoSecondaryFirst );

	//	create new pages for OwnExt and AvailExt root
	//		if redo is needed
	//
	if ( fRedoOE )
		{
		Call( csrOE.ErrGetNewPageForRedo(
						ppib,
						ifmp,
						pgnoOE,
						objidFDP,
						dbtime,
						fPageFlags | CPAGE::fPageRoot | CPAGE::fPageLeaf | CPAGE::fPageSpaceTree ) );
		Assert( latchWrite == csrOE.Latch() );
		Call( ErrBFDepend( csrOE.Cpage().PBFLatch(), csrRoot.Cpage().PBFLatch() ) );
		}

	if ( fRedoAE )
		{
		Call( csrAE.ErrGetNewPageForRedo(
						ppib,
						ifmp,
						pgnoAE,
						objidFDP,
						dbtime,
						fPageFlags | CPAGE::fPageRoot | CPAGE::fPageLeaf | CPAGE::fPageSpaceTree ) );
		Assert( latchWrite == csrAE.Latch() );
		Call( ErrBFDepend( csrAE.Cpage().PBFLatch(), csrRoot.Cpage().PBFLatch() ) );
		}
	
	Assert( FAssertLGNeedRedo( csrRoot, dbtime, plrconvertfdp->le_dbtimeBefore ) );
	
	csrRoot.UpgradeFromRIWLatch();

	Assert( FFUCBOwnExt( pfucb ) );
	FUCBResetOwnExt( pfucb );

	//	dirty pages and set dbtime to logged dbtime
	//
	Assert( latchWrite == csrRoot.Latch() );
	LGRIRedoDirtyAndSetDbtime( &csrRoot, dbtime );
	LGRIRedoDirtyAndSetDbtime( &csrAE, dbtime );
	LGRIRedoDirtyAndSetDbtime( &csrOE, dbtime );

	SPIPerformConvert( pfucb, &csrRoot, &csrAE, &csrOE, &sph, pgnoSecondaryFirst, cpgSecondary, rgext, iextMac );

HandleError:
	csrRoot.ReleasePage();
	csrOE.ReleasePage();
	csrAE.ReleasePage();
	
	if ( pfucb != pfucbNil )
		{
		FUCBSetOwnExt( pfucb );
		}
		
	return err;
	}

	
ERR LOG::ErrLGRIRedoOperation( LR *plr )
	{
	ERR		err = JET_errSuccess;
	LEVEL   levelCommitTo;

	Assert( !m_fNeedInitialDbList );

	switch ( plr->lrtyp )
		{

	default:
		{
#ifndef RFS2
		AssertSz( fFalse, "Debug Only, Ignore this Assert" );
#endif
		return ErrERRCheck( JET_errLogCorrupted );
		}

	//	****************************************************
	//	single-page operations
	//	****************************************************

	case lrtypInsert:
	case lrtypFlagInsert:
	case lrtypFlagInsertAndReplaceData:
	case lrtypReplace:
	case lrtypReplaceD:
	case lrtypFlagDelete:
	case lrtypDelete:
	case lrtypDelta:
	case lrtypUndo:
	case lrtypUndoInfo:
	case lrtypSetExternalHeader:
	case lrtypSLVSpace:
	case lrtypEmptyTree:
		err = ErrLGRIRedoNodeOperation( (LRNODE_ * ) plr, &m_errGlobalRedoError );
		
		Assert( JET_errWriteConflict != err );
		CallS( err );
		CallR( err );
		break;


	/****************************************************
	 *     Transaction Operations                       *
	 ****************************************************/

	case lrtypBegin:
	case lrtypBegin0:
#ifdef DTC	
	case lrtypBeginDT:
#endif	
		{
		LRBEGINDT	*plrbeginDT = (LRBEGINDT *)plr;
		PIB			*ppib;

		LGRITraceRedo( plr );

		Assert( plrbeginDT->clevelsToBegin >= 0 );
		Assert( plrbeginDT->clevelsToBegin <= levelMax );
		CallR( ErrLGRIPpibFromProcid( plrbeginDT->le_procid, &ppib ) );

		Assert( !ppib->FMacroGoing() );

		/*	do BT only after first BT based on level 0 is executed
		/**/
		if ( ppib->FAfterFirstBT() || 0 == plrbeginDT->levelBeginFrom )
			{
			Assert( ppib->level <= plrbeginDT->levelBeginFrom );

			if ( 0 == ppib->level )
				{
				Assert( 0 == plrbeginDT->levelBeginFrom );
				Assert( lrtypBegin != plr->lrtyp );
				ppib->trxBegin0 = plrbeginDT->le_trxBegin0;
				ppib->lgposStart = m_lgposRedo;
				m_pinst->m_trxNewest = ( TrxCmp( m_pinst->m_trxNewest, ppib->trxBegin0 ) > 0 ? m_pinst->m_trxNewest : ppib->trxBegin0 );
				//  at redo time RCEClean can throw away any committed RCE as they are only
				//  needed for rollback
				}
			else
				{
				Assert( lrtypBegin == plr->lrtyp );
				}

			/*	issue begin transactions
			/**/
			while ( ppib->level < plrbeginDT->levelBeginFrom + plrbeginDT->clevelsToBegin )
				{
				VERBeginTransaction( ppib );
				}

			/*	assert at correct transaction level
			/**/
			Assert( ppib->level == plrbeginDT->levelBeginFrom + plrbeginDT->clevelsToBegin );

			ppib->SetFAfterFirstBT();

#ifdef DTC
			if ( lrtypBeginDT == plr->lrtyp )
				ppib->SetFDistributedTrx();
#endif				
			}
		break;
		}

	case lrtypRefresh:
		{
		LRREFRESH	*plrrefresh = (LRREFRESH *)plr;
		PIB			*ppib;

		LGRITraceRedo( plr );

		CallR( ErrLGRIPpibFromProcid( plrrefresh->le_procid, &ppib ) );

		Assert( !ppib->FMacroGoing() );
		if ( !ppib->FAfterFirstBT() )
			break;

		/*	imitate a begin transaction.
		 */
		Assert( ppib->level <= 1 );
		ppib->level = 1;
		ppib->trxBegin0 = plrrefresh->le_trxBegin0;
			
		break;
		}

	case lrtypCommit:
	case lrtypCommit0:
		{
		LRCOMMIT0	*plrcommit0 = (LRCOMMIT0 *)plr;
		PIB			*ppib;

		CallR( ErrLGRIPpibFromProcid( plrcommit0->le_procid, &ppib ) );

		if ( !ppib->FAfterFirstBT() )
			break;

		/*	check transaction level
		/**/
		Assert( !ppib->FMacroGoing() );
		Assert( ppib->level >= 1 );

		LGRITraceRedo( plr );

		levelCommitTo = plrcommit0->levelCommitTo;
		Assert( levelCommitTo <= ppib->level );

		while ( ppib->level > levelCommitTo )
			{
			Assert( ppib->level > 0 );
			if ( 1 == ppib->level )
				{
				Assert( lrtypCommit0 == plr->lrtyp );
				ppib->trxCommit0 = plrcommit0->le_trxCommit0;
				m_pinst->m_trxNewest = ( TrxCmp( m_pinst->m_trxNewest, ppib->trxCommit0 ) > 0 ?
											m_pinst->m_trxNewest :
											ppib->trxCommit0 );
				VERCommitTransaction( ppib );
				LGICleanupTransactionToLevel0( ppib );
				}
			else
				{
				Assert( lrtypCommit == plr->lrtyp );
				VERCommitTransaction( ppib );
				}
			}

		break;
		}

	case lrtypRollback:
		{
		LRROLLBACK	*plrrollback = (LRROLLBACK *)plr;
		LEVEL   	level = plrrollback->levelRollback;
		PIB			*ppib;

		CallR( ErrLGRIPpibFromProcid( plrrollback->le_procid, &ppib ) );

		Assert( !ppib->FMacroGoing() );
		if ( !ppib->FAfterFirstBT() )
			break;

		/*	check transaction level
		/**/
		Assert( ppib->level >= level );

		LGRITraceRedo( plr );

		while ( level-- && ppib->level > 0 )
			{
			err = ErrVERRollback( ppib );
			CallSx( err, JET_errRollbackError );
			CallR ( err );
			}

		if ( 0 == ppib->level )
			{
			LGICleanupTransactionToLevel0( ppib );
			}
			
		break;
		}

#ifdef DTC
	case lrtypPrepCommit:
		{
		const LRPREPCOMMIT	* const plrprepcommit	= (LRPREPCOMMIT *)plr;
		PIB					* ppib;

		CallR( ErrLGRIPpibFromProcid( plrprepcommit->le_procid, &ppib ) );

		if ( !ppib->FAfterFirstBT() )
			break;

		Assert( !ppib->FMacroGoing() );
		Assert( 1 == ppib->level );
		Assert( ppib->FDistributedTrx() );

		LGRITraceRedo( plr );

		CallR( ppib->ErrAllocDistributedTrxData( plrprepcommit->rgbData, plrprepcommit->le_cbData ) );
		ppib->SetFPreparedToCommitTrx();
		break;
		}

	case lrtypPrepRollback:
		{
		const LRPREPROLLBACK	* const plrpreprollback	= (LRPREPROLLBACK *)plr;
		PIB						* ppib;

		CallR( ErrLGRIPpibFromProcid( plrpreprollback->le_procid, &ppib ) );

		if ( !ppib->FAfterFirstBT() )
			break;

		Assert( !ppib->FMacroGoing() );
		Assert( 1 == ppib->level );
		Assert( ppib->FDistributedTrx() );
		Assert( ppib->FPreparedToCommitTrx() );

		LGRITraceRedo( plr );

		//	resetting the PreparedToCommit flag will force rollback at the
		//	end of recovery
		ppib->ResetFPreparedToCommitTrx();
		break;
		}
#endif	//	DTC

		           
	/****************************************************
	 *     Split Operations                             *
	 ****************************************************/

	case lrtypSplit:
	case lrtypMerge:
		{
		LRPAGE_ *		plrpage		= (LRPAGE_ *)plr;
		PIB *			ppib;
		const DBTIME	dbtime		= plrpage->le_dbtime;

		CallR( ErrLGRIPpibFromProcid( plrpage->le_procid, &ppib ) );	

		if ( !ppib->FAfterFirstBT() )
			{
			//	BUGFIX (X5:178265 and NT:214397): it's possible
			//	that there are no Begin0's between the first and
			//	last log records, in which case nothing needs to
			//	get redone.  HOWEVER, the dbtimeLast and objidLast
			//	counters in the db header would not have gotten
			//	flushed (they only get flushed on a DetachDb or a
			//	clean shutdown), so we must still track these
			//	counters during recovery so that we can properly
			//	update the database header on RecoveryQuit (since
			//	we pass TRUE for the fUpdateCountersOnly param to
			//	ErrLGRICheckRedoCondition() below, that function
			//	will do nothing but update the counters for us).

			BOOL		fSkip;
			const OBJID	objidFDP	= ( lrtypSplit == plr->lrtyp ?
											( (LRSPLIT *)plr )->le_objidFDP :
											( (LRMERGE *)plr )->le_objidFDP );

			CallS( ErrLGRICheckRedoCondition(
						plrpage->dbid,
						dbtime,
						objidFDP,
						ppib,
						fTrue,
						&fSkip ) );
			Assert( fSkip );
			break;
			}

		Assert( ppib->FMacroGoing( dbtime ) );

		CallR( ErrLGIStoreLogRec( ppib, dbtime, plrpage ) );
		break;
		}


	//***************************************************
	//	Misc Operations
	//***************************************************

	case lrtypCreateMultipleExtentFDP:
		{
		LRCREATEMEFDP	*plrcreatemefdp = (LRCREATEMEFDP *)plr;
		const DBID		dbid = plrcreatemefdp->dbid;
		PIB				*ppib;

		INST			*pinst = m_pinst;
		IFMP			ifmp = pinst->m_mpdbidifmp[ dbid ];
		
		FMP::AssertVALIDIFMP( ifmp );

		//	remove cursors created on pgnoFDP earlier
		//
		if ( NULL != m_ptablehfhash )
			{
			m_ptablehfhash->Purge( ifmp, plrcreatemefdp->le_pgno );
			}
			
		BOOL fSkip;
		CallR( ErrLGRICheckRedoCondition2(
				plrcreatemefdp->le_procid,
				dbid,
				plrcreatemefdp->le_dbtime,
				plrcreatemefdp->le_objidFDP,
				NULL,	//	can not be in macro.
				&ppib,
				&fSkip ) );
		if ( fSkip )
			break;

		LGRITraceRedo( plrcreatemefdp );
		CallR( ErrLGIRedoFDPPage( m_ptablehfhash, ppib, plrcreatemefdp ) );

		CallR( ErrLGRIRedoSpaceRootPage( ppib, plrcreatemefdp, fTrue ) );
		
		CallR( ErrLGRIRedoSpaceRootPage( ppib, plrcreatemefdp, fFalse ) );
		break;
		}

	case lrtypCreateSingleExtentFDP:
		{
		LRCREATESEFDP	*plrcreatesefdp = (LRCREATESEFDP *)plr;
		const PGNO		pgnoFDP = plrcreatesefdp->le_pgno;
		const DBID		dbid = plrcreatesefdp->dbid;
		PIB				*ppib;

		INST			*pinst = m_pinst;
		IFMP			ifmp = pinst->m_mpdbidifmp[ dbid ];
		FMP::AssertVALIDIFMP( ifmp );
		
		//	remove cursors created on pgnoFDP earlier
		//
		if ( NULL != m_ptablehfhash )
			{
			m_ptablehfhash->Purge( ifmp, pgnoFDP );
			}
			
		BOOL fSkip;
		CallR( ErrLGRICheckRedoCondition2(
					plrcreatesefdp->le_procid,
					dbid,
					plrcreatesefdp->le_dbtime,
					plrcreatesefdp->le_objidFDP,
					NULL,
					&ppib,
					&fSkip ) );
		if ( fSkip )
			break;

		//	redo FDP page if needed
		//
		LGRITraceRedo( plrcreatesefdp );
		CallR( ErrLGIRedoFDPPage( m_ptablehfhash, ppib, plrcreatesefdp ) );
		break;
		}

	case lrtypConvertFDP:
		{
		LRCONVERTFDP	*plrconvertfdp = (LRCONVERTFDP *)plr;
		PIB				*ppib;

		BOOL fSkip;
		CallR( ErrLGRICheckRedoCondition2(
				plrconvertfdp->le_procid,
				plrconvertfdp->dbid,
				plrconvertfdp->le_dbtime,
				plrconvertfdp->le_objidFDP,
				plr,
				&ppib,
				&fSkip ) );
		if ( fSkip )
			break;

		CallR( ErrLGRIRedoConvertFDP( ppib, plrconvertfdp ) );
		break;
		}

	case lrtypSLVPageAppend:
		{
		LRSLVPAGEAPPEND	*	plrSLVPageAppend	= (LRSLVPAGEAPPEND *)plr;
		PIB				*	ppib;
		BOOL 				fSkip;

		if( !plrSLVPageAppend->FDataLogged() )
			{
			//	the information wasn't logged, we can't redo anything
			
			// on hard recovery we have to error out if we don't have the data
			// Even during hard recovery we may don't have the data before the backup start 
			// as if cicrular logging is on we log the data only during backup
			// If we hit a log after the backup (play forward) the data is not in the backup SLV
			// and we have to error out: "don't play forward if circular logging !"
			Assert ( !m_fHardRestore || m_lGenHighRestore );
			if ( m_fHardRestore && m_plgfilehdr->lgfilehdr.le_lGeneration > m_lGenHighRestore )
				{
				CallR( ErrERRCheck ( JET_errStreamingDataNotLogged ) );
				}
			
			Assert ( !m_fHardRestore || m_plgfilehdr->lgfilehdr.le_lGeneration <= m_lGenHighRestore );
			break;
			}
			
		//	for SLV operations, we don't care about transactional visibility
		//	(can't roll them back) so skip transaction check in
		//	ErrLGRICheckRedoCondition2() and ALWAYS redo SLV operations even
		//	if we're in the middle of a transaction.
		CallR( ErrLGRIPpibFromProcid(
					plrSLVPageAppend->le_procid,
					&ppib ) );
		CallR( ErrLGRICheckRedoCondition(
					DBID( plrSLVPageAppend->dbid & dbidMask ),
					dbtimeInvalid,
					objidNil,
					ppib,
					fFalse,
					&fSkip ) );
		if ( fSkip )
			break;

		CallR( ErrLGRIRedoSLVPageAppend( ppib, plrSLVPageAppend ) );
		break;
		}

	} /*** end of switch statement ***/

	return JET_errSuccess;
	}


//	reconstructs rglineinfo during recovery
//		calcualtes kdf and cbPrefix of lineinfo
//		cbSize info is not calculated correctly since it is not needed in redo
//
LOCAL ERR ErrLGIRedoSplitLineinfo( FUCB					*pfucb,
								   SPLITPATH 			*psplitPath, 
								   DBTIME				dbtime,
								   const KEYDATAFLAGS&	kdf )
	{
	SPLIT	*psplit = psplitPath->psplit;
	ERR err = JET_errSuccess;

	Assert( psplit != NULL );
	Assert( psplit->psplitPath == psplitPath );
	Assert( NULL == psplit->rglineinfo );
	Assert( FAssertLGNeedRedo( psplitPath->csr, dbtime, psplitPath->dbtimeBefore )
		|| !FBTISplitDependencyRequired( psplit ) );

	psplit->rglineinfo = new LINEINFO[psplit->clines];
							 
	if ( NULL == psplit->rglineinfo )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	memset( psplit->rglineinfo, 0, sizeof( LINEINFO ) * psplit->clines );

	if ( !FLGNeedRedoCheckDbtimeBefore( psplitPath->csr, dbtime, psplitPath->dbtimeBefore, &err ) )
		{
		CallS( err );

		//	split page does not need redo but new page needs redo
		//	set rglineinfo and cbPrefix for appended node
		//
		Assert( !FBTISplitDependencyRequired( psplit ) );
		Assert( psplit->clines - 1 == psplit->ilineOper );
		Assert( psplit->ilineSplit == psplit->ilineOper );
		Assert( FLGNeedRedoPage( psplit->csrNew, dbtime ) );
		
		psplit->rglineinfo[psplit->ilineOper].kdf = kdf;

		if ( ilineInvalid != psplit->prefixinfoNew.ilinePrefix )
			{
			Assert( 0 == psplit->prefixinfoNew.ilinePrefix );
			Assert( kdf.key.Cb() > cbPrefixOverhead );
			psplit->rglineinfo[psplit->ilineOper].cbPrefix = kdf.key.Cb();
			}

		return JET_errSuccess;
		}
	else
		{
		Call( err );
		}
	
	INT		ilineFrom;
	INT		ilineTo;

	for ( ilineFrom = 0, ilineTo = 0; ilineTo < psplit->clines; ilineTo++ )
		{
		if ( psplit->ilineOper == ilineTo && 
			 splitoperInsert == psplit->splitoper )
			{
			//	place to be inserted node here
			//
			psplit->rglineinfo[ilineTo].kdf = kdf;
			
			//	do not increment ilineFrom
			//
			continue;
			}

		//	get node from page
		//	
		psplitPath->csr.SetILine( ilineFrom );

		NDGet( pfucb, &psplitPath->csr );

		if ( ilineTo == psplit->ilineOper &&
			 splitoperNone != psplit->splitoper )
			{
			//	get key from node
			//	and data from parameter
			//
			Assert( splitoperInsert != psplit->splitoper );
			Assert( splitoperReplace == psplit->splitoper ||
					splitoperFlagInsertAndReplaceData == psplit->splitoper );

			psplit->rglineinfo[ilineTo].kdf.key		= pfucb->kdfCurr.key;
			psplit->rglineinfo[ilineTo].kdf.data	= kdf.data;
			psplit->rglineinfo[ilineTo].kdf.fFlags	= pfucb->kdfCurr.fFlags;
			}
		else
			{
			psplit->rglineinfo[ilineTo].kdf			= pfucb->kdfCurr;
			}

		Assert( ilineFrom <= ilineTo &&
				ilineFrom + 1 >= ilineTo ); 
		ilineFrom++;
		}

	//	set cbPrefixes for nodes in split page
	//
	if ( psplit->prefixinfoSplit.ilinePrefix != ilineInvalid )
		{
		Assert( psplit->prefixSplitNew.Cb() > 0 );
		
		KEY		keyPrefix;
		keyPrefix.Nullify();
		keyPrefix.suffix = psplit->prefixSplitNew;
		Assert( FKeysEqual( keyPrefix, 
						psplit->rglineinfo[psplit->prefixinfoSplit.ilinePrefix].kdf.key ) );

		for ( INT iline = 0; iline < psplit->ilineSplit ; iline++ )
			{
			LINEINFO	*plineinfo = &psplit->rglineinfo[iline];
			const INT	cbCommon = CbCommonKey( keyPrefix, plineinfo->kdf.key );

			Assert( 0 == plineinfo->cbPrefix );
			if ( cbCommon > cbPrefixOverhead )
				{
				plineinfo->cbPrefix = cbCommon;
				}
			}
		}

	//	set cbPrefixes for nodes in new page
	//
	if ( FLGNeedRedoPage( psplit->csrNew, dbtime )
		&& ilineInvalid != psplit->prefixinfoNew.ilinePrefix )
		{
		const INT	ilinePrefix = psplit->ilineSplit + 
								  psplit->prefixinfoNew.ilinePrefix;
		Assert( psplit->clines > ilinePrefix );
		
		KEY		keyPrefix = psplit->rglineinfo[ilinePrefix].kdf.key;

		for ( INT iline = psplit->ilineSplit; iline < psplit->clines ; iline++ )
			{
			LINEINFO	*plineinfo = &psplit->rglineinfo[iline];
			const INT	cbCommon = CbCommonKey( keyPrefix, plineinfo->kdf.key );

			Assert( 0 == plineinfo->cbPrefix );
			if ( cbCommon > cbPrefixOverhead )
				{
				plineinfo->cbPrefix = cbCommon;
				}
			}
		}
	return JET_errSuccess;

HandleError:		
	delete [] psplit->rglineinfo;
	
	return err;
	}
	

//	reconstructs split structre during recovery
//		access new page and upgrade to write-latch, if necessary
//		access right page and upgrade to write-latch, if necessary
//		update split members from log record	
//
ERR LOG::ErrLGRIRedoInitializeSplit( PIB *ppib, const LRSPLIT *plrsplit, SPLITPATH *psplitPath )
	{
	ERR				err;
	BOOL			fRedoNewPage	= fFalse;

	const DBID		dbid			= plrsplit->dbid;
	const PGNO		pgnoSplit		= plrsplit->le_pgno;
	const PGNO		pgnoNew			= plrsplit->le_pgnoNew;
	const PGNO		pgnoRight		= plrsplit->le_pgnoRight;
	const OBJID		objidFDP		= plrsplit->le_objidFDP;
	const DBTIME	dbtime			= plrsplit->le_dbtime;
	const SPLITTYPE	splittype		= SPLITTYPE( BYTE( plrsplit->splittype ) );

	const ULONG		fNewPageFlags	= plrsplit->le_fNewPageFlags;
	const ULONG		fSplitPageFlags	= plrsplit->le_fSplitPageFlags;

	INST			*pinst			= m_pinst;
	IFMP			ifmp			= pinst->m_mpdbidifmp[ dbid ];
	
	Assert( pgnoNew != pgnoNull );
	Assert( latchRIW == psplitPath->csr.Latch() );

	//	allocate split structure
	//
	SPLIT	*psplit = static_cast<SPLIT *>( PvOSMemoryHeapAlloc( sizeof(SPLIT) ) );
	if ( psplit == NULL )
		{
		CallR( ErrERRCheck( JET_errOutOfMemory ) );
		}
	memset( (BYTE *)psplit, 0, sizeof(SPLIT) );
	new( &psplit->csrRight ) CSR;
	new( &psplit->csrNew ) CSR;

	psplit->pgnoSplit 	= pgnoSplit;

	psplit->splittype	= splittype;
	psplit->splitoper	= SPLITOPER( BYTE( plrsplit->splitoper ) );
	
	psplit->ilineOper	= plrsplit->le_ilineOper;
	psplit->clines		= plrsplit->le_clines;
	Assert( psplit->clines < g_cbPage );

	psplit->ilineSplit	= plrsplit->le_ilineSplit;

	psplit->fNewPageFlags	= fNewPageFlags;
	psplit->fSplitPageFlags	= fSplitPageFlags;

	psplit->cbUncFreeSrc	= plrsplit->le_cbUncFreeSrc;
	psplit->cbUncFreeDest	= plrsplit->le_cbUncFreeDest;
			
	psplit->prefixinfoSplit.ilinePrefix	= plrsplit->le_ilinePrefixSplit;
	psplit->prefixinfoNew.ilinePrefix	= plrsplit->le_ilinePrefixNew;

	//	latch the new-page 

	psplit->pgnoNew		= plrsplit->le_pgnoNew;
	Assert( rgfmp[ifmp].Dbid() == dbid );
	Call( ErrLGRIAccessNewPage(
				ppib,
				&psplit->csrNew,
				ifmp,
				pgnoNew,
				dbtime,
				psplit,
				FLGNeedRedoPage( psplitPath->csr, dbtime ),
				&fRedoNewPage ) );

	if ( fRedoNewPage )
		{
		//	create new page
		//
		Assert( !psplit->csrNew.FLatched() );
		Call( psplit->csrNew.ErrGetNewPageForRedo(
									ppib,
									ifmp,
									pgnoNew,
									objidFDP,
									dbtime,
									fNewPageFlags ) );

		if ( FBTISplitDependencyRequired( psplit ) )
			{
			Call( ErrBFDepend(	psplit->csrNew.Cpage().PBFLatch(),
								psplitPath->csr.Cpage().PBFLatch() ) );
			}
		}
	else
		{
		Assert( latchRIW == psplit->csrNew.Latch() );
 		Assert( !FLGNeedRedoPage( psplit->csrNew, dbtime ) );
		}

	if ( pgnoRight != pgnoNull )
		{
		Call( ErrLGIAccessPage( ppib, &psplit->csrRight, ifmp, pgnoRight ) );
		Assert( latchRIW == psplit->csrRight.Latch() );
		Assert( dbtimeNil != plrsplit->le_dbtimeRightBefore );
		Assert( dbtimeInvalid != plrsplit->le_dbtimeRightBefore );
		psplit->dbtimeRightBefore = plrsplit->le_dbtimeRightBefore;
		}

	if ( plrsplit->le_cbKeyParent > 0 )
		{
		const INT	cbKeyParent = plrsplit->le_cbKeyParent;

		psplit->kdfParent.key.suffix.SetPv( PvOSMemoryHeapAlloc( cbKeyParent ) );
		if ( psplit->kdfParent.key.suffix.Pv() == NULL )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		psplit->fAllocParent		= fTrue;
		psplit->kdfParent.key.suffix.SetCb( cbKeyParent );
		UtilMemCpy( psplit->kdfParent.key.suffix.Pv(),
				((BYTE *) plrsplit ) + sizeof( LRSPLIT ),
				cbKeyParent );

		psplit->kdfParent.data.SetCb( sizeof( PGNO ) );
		psplit->kdfParent.data.SetPv( &psplit->pgnoSplit );
		}

	if ( plrsplit->le_cbPrefixSplitOld > 0 )
		{
		const INT	cbPrefix = plrsplit->le_cbPrefixSplitOld;
		psplit->prefixSplitOld.SetPv( PvOSMemoryHeapAlloc( cbPrefix ) );
		if ( psplit->prefixSplitOld.Pv() == NULL )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		psplit->prefixSplitOld.SetCb( cbPrefix );

		UtilMemCpy( psplit->prefixSplitOld.Pv(), 
				((BYTE*) plrsplit) + sizeof( LRSPLIT ) + plrsplit->le_cbKeyParent,
				cbPrefix );
		}
		
	if ( plrsplit->le_cbPrefixSplitNew > 0 )
		{
		const INT	cbPrefix = plrsplit->le_cbPrefixSplitNew;
		psplit->prefixSplitNew.SetPv( PvOSMemoryHeapAlloc( cbPrefix ) );
		if ( psplit->prefixSplitNew.Pv() == NULL )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		psplit->prefixSplitNew.SetCb( cbPrefix );

		UtilMemCpy( psplit->prefixSplitNew.Pv(), 
				((BYTE*) plrsplit) + 
					sizeof( LRSPLIT ) + 
					plrsplit->le_cbKeyParent + 
					plrsplit->le_cbPrefixSplitOld,
				cbPrefix );
		}

	Assert( psplit->csrNew.Pgno() != pgnoNull );
	Assert( plrsplit->le_pgnoNew == psplit->csrNew.Pgno() );
	Assert( plrsplit->le_pgnoRight == psplit->csrRight.Pgno() );

	//	link psplit ot psplitPath
	//
	psplitPath->psplit = psplit;
	psplit->psplitPath = psplitPath;
	
	//	if (non-append) split page is flushed
	//		new page should be as well
	Assert( FAssertLGNeedRedo( psplitPath->csr, dbtime, plrsplit->le_dbtimeBefore )
		|| !fRedoNewPage
		|| !FBTISplitDependencyRequired( psplit ) );
	if ( fRedoNewPage )
		{
		Assert( latchWrite == psplit->csrNew.Latch() );
		}
	else
		{
		Assert( latchRIW == psplit->csrNew.Latch() );
 		}

HandleError:
	if ( err < 0 )
		{
		BTIReleaseSplit( pinst, psplit );
		}
	return err;
	}


//	reconstructs splitPath and split
//
ERR LOG::ErrLGRIRedoSplitPath( PIB *ppib, const LRSPLIT *plrsplit, SPLITPATH **ppsplitPath )
	{
	Assert( lrtypSplit == plrsplit->lrtyp );
	ERR				err;
	const DBID		dbid		= plrsplit->dbid;
	const PGNO		pgnoSplit	= plrsplit->le_pgno; 
	const PGNO		pgnoNew		= plrsplit->le_pgnoNew;
	const DBTIME	dbtime		= plrsplit->le_dbtime;

	INST			*pinst = m_pinst;
	IFMP			ifmp = pinst->m_mpdbidifmp[ dbid ];

	//	allocate new splitPath
	//
	CallR( ErrBTINewSplitPath( ppsplitPath ) );
	
	SPLITPATH *psplitPath = *ppsplitPath;

	CallR( ErrLGIAccessPage( ppib, &psplitPath->csr, ifmp, pgnoSplit ) );
	Assert( latchRIW == psplitPath->csr.Latch() );

	//	allocate new split if needed
	//
	if ( pgnoNew != pgnoNull )
		{
		Call( ErrLGRIRedoInitializeSplit( ppib, plrsplit, psplitPath ) );
		Assert( NULL != psplitPath->psplit );
		}

	psplitPath->dbtimeBefore = plrsplit->le_dbtimeBefore;
	if ( psplitPath->psplitPathParent != NULL )
		{
		Assert( psplitPath == psplitPath->psplitPathParent->psplitPathChild );
		psplitPath->psplitPathParent->dbtimeBefore = plrsplit->le_dbtimeParentBefore;
		}
		
HandleError:
	return err;
	}


//	allocate and initialize mergePath structure
//	access merged page 
//	if redo is needed,
//		upgrade latch
//
LOCAL ERR ErrLGIRedoMergePath( PIB 				*ppib, 
							   const LRMERGE	*plrmerge,
							   MERGEPATH		**ppmergePath )
	{
	ERR				err;
	const DBID		dbid	= plrmerge->dbid;
	const PGNO		pgno	= plrmerge->le_pgno;
	const DBTIME	dbtime	= plrmerge->le_dbtime;
	INST			*pinst	= PinstFromPpib( ppib );
	IFMP			ifmp	= pinst->m_mpdbidifmp[ dbid ];

	//	initialize merge path
	//
	CallR( ErrBTINewMergePath( ppmergePath ) );

	MERGEPATH *pmergePath = *ppmergePath;

	CallR( ErrLGIAccessPage( ppib, &pmergePath->csr, ifmp, pgno ) );
	Assert( latchRIW == pmergePath->csr.Latch() );

	pmergePath->iLine		= plrmerge->ILine();	
	pmergePath->fKeyChange 	= ( plrmerge->FKeyChange() ? fTrue : fFalse );
	pmergePath->fDeleteNode	= ( plrmerge->FDeleteNode() ? fTrue : fFalse );
	pmergePath->fEmptyPage	= ( plrmerge->FEmptyPage() ? fTrue : fFalse );

	pmergePath->dbtimeBefore = plrmerge->le_dbtimeBefore;
	if ( pmergePath->pmergePathParent != NULL )
		{
		Assert( pmergePath == pmergePath->pmergePathParent->pmergePathChild );
		pmergePath->pmergePathParent->dbtimeBefore = plrmerge->le_dbtimeParentBefore;
		}

	return err;
	}


//	allocates and initializes leaf-level merge structure
//	access sibling pages 
//	if redo is needed, 
//		upgrade to write-latch
//
ERR LOG::ErrLGRIRedoInitializeMerge( PIB 			*ppib, 
									 FUCB			*pfucb,
									 const LRMERGE 	*plrmerge, 
									 MERGEPATH		*pmergePath )
	{
	ERR				err;

	Assert( NULL == pmergePath->pmergePathChild );
	CallR( ErrBTINewMerge( pmergePath ) );

	MERGE			*pmerge				= pmergePath->pmerge;
	const PGNO		pgnoRight			= plrmerge->le_pgnoRight;
	const PGNO		pgnoLeft			= plrmerge->le_pgnoLeft;
	const DBID		dbid				= plrmerge->dbid;
	const DBTIME	dbtime				= plrmerge->le_dbtime;
	const MERGETYPE	mergetype			= MERGETYPE( BYTE( plrmerge->mergetype ) );

	INST			*pinst				= PinstFromPpib( ppib );
	IFMP			ifmp				= pinst->m_mpdbidifmp[ dbid ];

	BOOL			fRedoRightPage		= fFalse;
	const BOOL		fRedoMergedPage		= FLGNeedRedoCheckDbtimeBefore( pmergePath->csr, dbtime, plrmerge->le_dbtimeBefore, &err );
	Call( err );
	

	//	access left page
	//
	if ( pgnoLeft != pgnoNull )
		{
		Call( ErrLGIAccessPage( ppib, &pmerge->csrLeft, ifmp, pgnoLeft ) );
		Assert( latchRIW == pmerge->csrLeft.Latch() );
		Assert( dbtimeNil != plrmerge->le_dbtimeLeftBefore );
		Assert( dbtimeInvalid != plrmerge->le_dbtimeLeftBefore );
		pmerge->dbtimeLeftBefore = plrmerge->le_dbtimeLeftBefore;
		}

	if ( pgnoRight != pgnoNull )
		{
		//	access right page
		//	if hard-restore
		//		get patch for page
		//		if patch page exists
		//			Assert patch page's dbtime >= dbtime of oper
		//			replace page with patch
		//			acquire RIW latch
		//		else if page does not exist
		//			return
		//		else
		//			if page's dbtime < dbtime of oper
		//				upgrade latch
		//	else
		//		if page does not exist
		//			return
		//		if page's dbtime < dbtime of oper
		//			upgrade latch
		//

		//	unlike split, the right page should already exist, so we
		//	shouldn't get errors back from AccessPage()
		Call( ErrLGIAccessPage( ppib, &pmerge->csrRight, ifmp, pgnoRight ) );
		Assert( latchRIW == pmerge->csrRight.Latch() );
		Assert( dbtimeNil != plrmerge->le_dbtimeRightBefore );
		Assert( dbtimeInvalid != plrmerge->le_dbtimeRightBefore );
		pmerge->dbtimeRightBefore = plrmerge->le_dbtimeRightBefore;

		Assert( latchRIW == pmerge->csrRight.Latch() );
 		fRedoRightPage = FLGNeedRedoCheckDbtimeBefore( pmerge->csrRight, dbtime, pmerge->dbtimeRightBefore, &err );
		Call( err );

		//	If restoring, then need to consult patch file only if right
		//	page is not new enough, but merged page is (in which case
		//	up-to-date right page MUST be in patch file).
		//	In addition, there's no need to obtain page from patch file
		//	for an EmptyPage merge, even if it's out-of-date, because
		//	all that will be updated is the page pointer.
		if ( m_fHardRestore
			&& fRedoRightPage
			&& !fRedoMergedPage
			&& mergetypeEmptyPage != mergetype )
			{
			//	merged page is up-to-date, but right page isn't, so the
			//	correct right page must be available in the patch file
			PATCH	*ppatch;
			
			Assert( fRestorePatch == m_fRestoreMode || fRestoreRedo == m_fRestoreMode );
			Assert( rgfmp[ifmp].Dbid() == dbid );

			// it should not happend during snapshot restore
			AssertSz ( fSnapshotNone == m_fSnapshotMode, "No patch file for snapshot restore" ); 
			ppatch = PpatchLGSearch( m_rgppatchlst, dbtime, pgnoRight, dbid );

			if ( ppatch != NULL )
				{
#ifdef ELIMINATE_PAGE_PATCHING
				//	should be impossible
				EnforceSz( fFalse, "Patching no longer supported." );
				return ErrERRCheck( JET_errBadPatchPage );
#else
				//	patch exists and is later than operation
				//
				Assert( ppatch->dbtime >= dbtime );

				//	release currently-latched page so we can load the
				//	page from the patch file
				Assert( latchRIW == pmerge->csrRight.Latch() );
				pmerge->csrRight.ReleasePage();
				
				CallR( ErrLGIPatchPage( ppib, pgnoRight, ifmp, ppatch ) );
				
				CallS( ErrLGIAccessPage( ppib, &pmerge->csrRight, ifmp, pgnoRight ) );
				Assert( latchRIW == pmerge->csrRight.Latch() );

				fRedoRightPage = FLGNeedRedoCheckDbtimeBefore( pmerge->csrRight, dbtime, pmerge->dbtimeRightBefore, &err );
				Assert( !fRedoRightPage );
				CallS( err );
#endif	//	ELIMINATE_PAGE_PATCHING
				}
			}

		if ( fRedoRightPage )
			{
			Assert( FAssertLGNeedRedo( pmerge->csrRight, dbtime, pmerge->dbtimeRightBefore ) );
			
			if ( mergetypeEmptyPage != mergetype )
				{
				//	if right page needs to be redone, then so should merged page
				//	(because merged page is dependent on right page)
				if ( !fRedoMergedPage )
					{
					Assert( fFalse );	//	should be impossible
					Call( ErrERRCheck( JET_errDatabaseBufferDependenciesCorrupted ) );
					}
				
				Assert( pmerge->csrRight.Latch() == latchRIW );

				Assert( mergetypeFullRight == mergetype ||
						mergetypePartialRight == mergetype );

				//  depend the right page on the merge page so that the data
				//  moved from the merge page to the right page will always
				//  be available no matter when we crash

				Call( ErrBFDepend(	pmerge->csrRight.Cpage().PBFLatch(),
									pmergePath->csr.Cpage().PBFLatch() ) );
				}
			}
		}

	if ( plrmerge->le_cbKeyParentSep > 0 )
		{
		const INT	cbKeyParentSep = plrmerge->le_cbKeyParentSep;

		pmerge->kdfParentSep.key.suffix.SetPv( PvOSMemoryHeapAlloc( cbKeyParentSep ) );
		if ( pmerge->kdfParentSep.key.suffix.Pv() == NULL )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		pmerge->fAllocParentSep		= fTrue;
		pmerge->kdfParentSep.key.suffix.SetCb( cbKeyParentSep );
		UtilMemCpy( pmerge->kdfParentSep.key.suffix.Pv(),
				((BYTE *) plrmerge ) + sizeof( LRMERGE ),
				cbKeyParentSep );
		}

	Assert( 0 == plrmerge->ILineMerge() || mergetypePartialRight == mergetype );
	pmerge->ilineMerge		= plrmerge->ILineMerge();	
	pmerge->mergetype		= mergetype;
			
	pmerge->cbSizeTotal		= plrmerge->le_cbSizeTotal;
	pmerge->cbSizeMaxTotal	= plrmerge->le_cbSizeMaxTotal;
	pmerge->cbUncFreeDest	= plrmerge->le_cbUncFreeDest;

	//	if merged page needs redo
	//		allocate and initialize rglineinfo
	//
	if ( fRedoMergedPage )
		{
		CSR		*pcsr = &pmergePath->csr;
		CSR		*pcsrRight = &pmerge->csrRight;
		Assert( latchRIW == pcsr->Latch() );
		
		const INT	clines	= pmergePath->csr.Cpage().Clines();
		pmerge->clines		= clines;

		Assert( pmerge->rglineinfo == NULL );
		pmerge->rglineinfo 	= new LINEINFO[clines];
		if ( NULL == pmerge->rglineinfo )
			{
			return ErrERRCheck( JET_errOutOfMemory );
			}

		KEY		keyPrefix;
		keyPrefix.Nullify();
		if ( fRedoRightPage )
			{
			Assert( FAssertLGNeedRedo( *pcsrRight, dbtime, pmerge->dbtimeRightBefore ) );
			
			NDGetPrefix( pfucb, pcsrRight );
			keyPrefix = pfucb->kdfCurr.key;
			Assert( pfucb->kdfCurr.data.FNull() );
			}
			
		memset( pmerge->rglineinfo, 0, sizeof( LINEINFO ) * clines );

		for ( INT iline = 0; iline < clines; iline++ )
			{
			LINEINFO	*plineinfo = pmerge->rglineinfo + iline;
			pcsr->SetILine( iline );
			NDGet( pfucb, pcsr );
			plineinfo->kdf = pfucb->kdfCurr;

			if ( fRedoRightPage )
				{
				Assert( FAssertLGNeedRedo( *pcsrRight, dbtime, pmerge->dbtimeRightBefore ) );

				//	calculate cbPrefix for node 
				//	with respect to prefix on right page
				//
				INT		cbCommon = CbCommonKey( pfucb->kdfCurr.key,	keyPrefix );

				Assert( 0 == plineinfo->cbPrefix );
				if ( cbCommon > cbPrefixOverhead )
					{
					plineinfo->cbPrefix = cbCommon;
					}
				}
			}
		}

HandleError:
	return err;
	}

	
//	reconstructs merge structures and fucb
//
ERR LOG::ErrLGRIRedoMergeStructures( PIB		*ppib,
									 DBTIME		dbtime,
									 MERGEPATH	**ppmergePathLeaf, 
									 FUCB		**ppfucb )
	{
	ERR				err;
	const LRMERGE	*plrmerge	= (LRMERGE *) ppib->PvLogrec( dbtime );
	const DBID		dbid 		= plrmerge->dbid;
	const PGNO		pgnoFDP		= plrmerge->le_pgnoFDP;
	const OBJID		objidFDP	= plrmerge->le_objidFDP;	// Debug only info
	const BOOL		fUnique		= plrmerge->FUnique();
	const BOOL		fSpace		= plrmerge->FSpace();

	INST			*pinst = PinstFromPpib( ppib );
	IFMP			ifmp = pinst->m_mpdbidifmp[ dbid ];

	for ( INT ibNextLR = 0; 
		  ibNextLR < ppib->CbSizeLogrec( dbtime ); 
		  ibNextLR += CbLGSizeOfRec( plrmerge ) )
		{
		plrmerge = (LRMERGE *) ( (BYTE *) ppib->PvLogrec( dbtime ) + ibNextLR );
		Assert( lrtypMerge == plrmerge->lrtyp );

		//	insert and initialize mergePath for this level
		//
		Call( ErrLGIRedoMergePath( ppib, plrmerge, ppmergePathLeaf ) );
		}

	//	get fucb
	//
	Assert( pfucbNil == *ppfucb );
	Call( ErrLGRIGetFucb( m_ptablehfhash, ppib, ifmp, pgnoFDP, objidFDP, fUnique, fSpace, ppfucb ) );

	//	initialize rglineinfo for leaf level of merge
	//
	Assert( NULL != *ppmergePathLeaf );
	Assert( NULL == (*ppmergePathLeaf)->pmergePathChild );

	Call( ErrLGRIRedoInitializeMerge( ppib, *ppfucb, plrmerge, *ppmergePathLeaf ) );
	
HandleError:
	return err;
	}

	
//	reconstructs split structures, FUCB, dirflag and kdf for split
//
ERR LOG::ErrLGIRedoSplitStructures(
	PIB				*ppib,
	DBTIME			dbtime,
	SPLITPATH		**ppsplitPathLeaf,
	FUCB			**ppfucb,
	DIRFLAG			*pdirflag,
	KEYDATAFLAGS	*pkdf,
	RCEID			*prceidOper1,
	RCEID			*prceidOper2 )
	{
	ERR				err;
	LR				*plr;
	SPLITPATH		*psplitPath;
	const LRSPLIT	*plrsplit	= (LRSPLIT *) ppib->PvLogrec( dbtime );
	const DBID		dbid 		= plrsplit->dbid;
	const PGNO		pgnoFDP		= plrsplit->le_pgnoFDP;
	const OBJID		objidFDP	= plrsplit->le_objidFDP;
	IFMP			ifmp;

	Assert(	dbtime	== plrsplit->le_dbtime );
	
	//	split with no oper will use the space fucb
	//
	BOOL			fUnique 	= plrsplit->FUnique();
	BOOL			fSpace		= fTrue;

	Assert( rceidNull == *prceidOper1 );
	Assert( rceidNull == *prceidOper2 );
	
	pkdf->Nullify();
	Assert( fDIRNull == *pdirflag );
	
	for ( INT ibNextLR = 0; 
		  ibNextLR < ppib->CbSizeLogrec( dbtime ); 
		  ibNextLR += CbLGSizeOfRec( plr ) )
		{
		plr = (LR *) ( (BYTE *)ppib->PvLogrec( dbtime ) + ibNextLR );
		switch( plr->lrtyp )
			{
			case lrtypSplit:
				{
				const LRSPLIT	*plrsplit = (LRSPLIT *) plr;

				Assert( dbtime == plrsplit->le_dbtime );
				Assert( pgnoFDP == plrsplit->le_pgnoFDP );
				Call( ErrLGRIRedoSplitPath( ppib, plrsplit, ppsplitPathLeaf ) );
				}
				break;
				
			case lrtypInsert:
				{
				LRINSERT	*plrinsert = (LRINSERT *) plr;

				pkdf->key.suffix.SetPv( (BYTE *) plrinsert + sizeof( LRINSERT ) );
				pkdf->key.suffix.SetCb( plrinsert->CbPrefix() + plrinsert->CbSuffix() );

				pkdf->data.SetPv( (BYTE *) plrinsert + 
								  sizeof( LRINSERT ) +
								  plrinsert->CbPrefix() + 
								  plrinsert->CbSuffix() );
				pkdf->data.SetCb( plrinsert->CbData() );
				*pdirflag |= fDIRInsert;

				*prceidOper1 = plrinsert->le_rceid;
				}
				break;
				
			case lrtypFlagInsertAndReplaceData:
				{
				LRFLAGINSERTANDREPLACEDATA	*plrfiard = (LRFLAGINSERTANDREPLACEDATA *) plr;

				pkdf->key.prefix.Nullify();
				pkdf->key.suffix.SetCb( plrfiard->CbKey() );
				pkdf->key.suffix.SetPv( plrfiard->rgbData );
				pkdf->data.SetPv( (BYTE *) plrfiard + 
								  sizeof( LRFLAGINSERTANDREPLACEDATA ) +
								  plrfiard->CbKey() );
				pkdf->data.SetCb( plrfiard->CbData() );

				*pdirflag 		|= fDIRFlagInsertAndReplaceData;
				*prceidOper1	= plrfiard->le_rceid;
				*prceidOper2	= plrfiard->le_rceidReplace;
				}
				break;
				
			case lrtypReplace:
				{
				LRREPLACE	*plrreplace = (LRREPLACE *) plr;

				pkdf->data.SetPv( (BYTE *) plrreplace + sizeof ( LRREPLACE ) );
				pkdf->data.SetCb( plrreplace->CbNewData() );

				*pdirflag		|= fDIRReplace;
				*prceidOper1	= plrreplace->le_rceid;
				}
				break;
				
			default:
				Assert( fFalse );
				break;
			}

		if ( lrtypSplit != plr->lrtyp )
			{
			//	get fUnique and dirflag
			//
			const LRNODE_	*plrnode	= (LRNODE_ *) plr;

			Assert(	plrnode->le_pgnoFDP == pgnoFDP );
			Assert( plrnode->dbid == dbid );
			Assert( plrnode->le_dbtime == dbtime );

			fUnique		= plrnode->FUnique();
			fSpace		= plrnode->FSpace();

			if ( !plrnode->FVersioned() )
				*pdirflag |= fDIRNoVersion;
			}
		}


	ifmp = PinstFromPpib( ppib )->m_mpdbidifmp[ dbid ];
	
	//	get fucb
	//
	Assert( pfucbNil == *ppfucb );
	Call( ErrLGRIGetFucb( m_ptablehfhash, ppib, ifmp, pgnoFDP, objidFDP, fUnique, fSpace, ppfucb ) );

	//	initialize rglineinfo for every level of split
	//
	for ( psplitPath = *ppsplitPathLeaf; 
		  psplitPath != NULL;
		  psplitPath = psplitPath->psplitPathParent )
		{
		Assert( latchRIW == psplitPath->csr.Latch() );
 		
		err = JET_errSuccess;
		if ( psplitPath->psplit != NULL
			&& ( FLGNeedRedoCheckDbtimeBefore( psplitPath->csr, dbtime, psplitPath->dbtimeBefore, &err )
			 	|| FLGNeedRedoPage( psplitPath->psplit->csrNew, dbtime ) ) )
			{
			Call( err );
			
#ifdef DEBUG
			ERR			errT;
			SPLIT*		psplit			= psplitPath->psplit;
			Assert( NULL != psplit );

			const BOOL	fRedoSplitPage	= FLGNeedRedoCheckDbtimeBefore(
												psplitPath->csr,
												dbtime,
												psplitPath->dbtimeBefore,
												&errT );
			const BOOL	fRedoNewPage	= FLGNeedRedoPage( psplit->csrNew, dbtime );
			CallS( errT );

			if ( !fRedoSplitPage )
				{
				Assert( fRedoNewPage );
				Assert( !FBTISplitDependencyRequired( psplit ) );
				}
#endif

			//	if split page needs redo
			//		allocate and set lineinfo for split page
			//
			Call( ErrLGIRedoSplitLineinfo(
						*ppfucb, 
						psplitPath,
						dbtime,
						( psplitPath == *ppsplitPathLeaf ?
								*pkdf :
								psplitPath->psplitPathChild->psplit->kdfParent ) ) );
			}
		}

HandleError:
	return err;
	}


//	updates dbtime to given value on all write-latched pages
//
LOCAL VOID LGIRedoMergeUpdateDbtime( MERGEPATH *pmergePathLeaf, DBTIME dbtime )
	{
	MERGEPATH	*pmergePath = pmergePathLeaf;
	
	for ( ; pmergePath != NULL; pmergePath = pmergePath->pmergePathParent )
		{
		LGRIRedoDirtyAndSetDbtime( &pmergePath->csr, dbtime );

		MERGE	*pmerge = pmergePath->pmerge;
		if ( pmerge != NULL )
			{
			LGRIRedoDirtyAndSetDbtime( &pmerge->csrLeft, dbtime );
			LGRIRedoDirtyAndSetDbtime( &pmerge->csrRight, dbtime );
			}
		}
		
	return;
	}


//	updates dbtime to given value on all write-latched pages
//
LOCAL VOID LGIRedoSplitUpdateDbtime( SPLITPATH *psplitPathLeaf, DBTIME dbtime )
	{
	SPLITPATH	*psplitPath = psplitPathLeaf;
	
	for ( ; psplitPath != NULL; psplitPath = psplitPath->psplitPathParent )
		{
		LGRIRedoDirtyAndSetDbtime( &psplitPath->csr, dbtime );

		SPLIT	*psplit = psplitPath->psplit;
		if ( psplit != NULL )
			{
			LGRIRedoDirtyAndSetDbtime( &psplit->csrNew, dbtime );
			LGRIRedoDirtyAndSetDbtime( &psplit->csrRight, dbtime );
			}
		}
		
	return;
	}


//	creates version for operation performed atomically with split
//		also links version into appropriate lists
//
ERR	ErrLGIRedoSplitCreateVersion(
	SPLIT				*psplit, 
	FUCB				*pfucb,
	const KEYDATAFLAGS&	kdf,
	const DIRFLAG		dirflag,
	const RCEID			rceidOper1,
	const RCEID			rceidOper2,
	const LEVEL			level )
	{
	ERR					err	= JET_errSuccess;


	Assert( splitoperInsert == psplit->splitoper
		|| splitoperReplace == psplit->splitoper
		|| splitoperFlagInsertAndReplaceData == psplit->splitoper );

	Assert( pfucb->ppib->FAfterFirstBT() );

	Assert( rceidOper1 != rceidNull );
	Assert( splitoperFlagInsertAndReplaceData != psplit->splitoper
		|| rceidOper2 != rceidNull );
	Assert( psplit->fNewPageFlags & CPAGE::fPageLeaf );

	RCE			*prceOper1	= prceNil;
	RCE			*prceOper2	= prceNil;
	const BOOL	fNeedRedo	= ( psplit->ilineOper < psplit->ilineSplit ?
										latchWrite == psplit->psplitPath->csr.Latch() :
										latchWrite == psplit->csrNew.Latch() );
		
	VERPROXY	verproxy;

	verproxy.rceid = rceidOper1;
	verproxy.level = level;
	verproxy.proxy = proxyRedo;

	if ( splitoperReplace == psplit->splitoper )
		{
		//	create version only if page with oper needs redo
		//
		if ( !fNeedRedo )
			{
			Assert( pfucb->bmCurr.key.FNull() );
			goto HandleError;
			}

		Assert( latchWrite == psplit->psplitPath->csr.Latch() ); 
		Assert( dirflag & fDIRReplace );
		Assert( FFUCBUnique( pfucb ) );
		Assert( !pfucb->bmCurr.key.FNull() );

		Call( PverFromPpib( pfucb->ppib )->ErrVERModify( pfucb, pfucb->bmCurr, operReplace, &prceOper1, &verproxy ) );
		}
	else
		{
		Assert( splitoperFlagInsertAndReplaceData == psplit->splitoper ||
				splitoperInsert == psplit->splitoper );
		Assert( ( dirflag & fDIRInsert ) ||
				( dirflag & fDIRFlagInsertAndReplaceData ) );

		//	create version for insert even if oper needs no redo
		//
		BOOKMARK	bm;
		NDGetBookmarkFromKDF( pfucb, kdf, &bm );
		Call( PverFromPpib( pfucb->ppib )->ErrVERModify( pfucb, bm, operInsert, &prceOper1, &verproxy ) );

		//	create version for replace if oper needs redo
		//
		if ( splitoperFlagInsertAndReplaceData == psplit->splitoper
			&& fNeedRedo )
			{
			Assert( dirflag & fDIRFlagInsertAndReplaceData );
			verproxy.rceid = rceidOper2;
			BTISplitGetReplacedNode( pfucb, psplit );
			Call( PverFromPpib( pfucb->ppib )->ErrVERModify( pfucb, bm, operReplace, &prceOper2, &verproxy ) );
			}
		}

	//	link RCE(s) to lists
	//
	Assert( prceNil != prceOper1 );
	Assert( splitoperFlagInsertAndReplaceData == psplit->splitoper &&
				( prceNil != prceOper2 || !fNeedRedo ) ||
			splitoperFlagInsertAndReplaceData != psplit->splitoper &&
				prceNil == prceOper2 );
	BTISplitInsertIntoRCELists( pfucb, 
								psplit->psplitPath, 
								&kdf, 
								prceOper1, 
								prceOper2, 
								&verproxy );

HandleError:
	return err;
	}


//	upgrades latches on pages that need redo
//
LOCAL ERR ErrLGIRedoMergeUpgradeLatches( MERGEPATH *pmergePathLeaf, DBTIME dbtime )
	{
	ERR			err			= JET_errSuccess;
	MERGEPATH*	pmergePath;

	for ( pmergePath = pmergePathLeaf;
		  pmergePath != NULL; 
		  pmergePath = pmergePath->pmergePathParent )
		{
		Assert( pmergePath->csr.FLatched() );
		Assert( latchRIW == pmergePath->csr.Latch() );

 		if ( FLGNeedRedoCheckDbtimeBefore( pmergePath->csr, dbtime, pmergePath->dbtimeBefore, &err ) )
			{
			Call( err );
			pmergePath->csr.UpgradeFromRIWLatch();
			}
		CallS( err );
			
		MERGE	*pmerge = pmergePath->pmerge;
		if ( pmerge != NULL )
			{
			Assert( pmergePath == pmergePathLeaf );
			Assert( ( pgnoNull == pmerge->csrRight.Pgno()
						&& !pmerge->csrRight.FLatched() )
				|| latchRIW == pmerge->csrRight.Latch() );

			if ( pmerge->csrRight.FLatched() && FLGNeedRedoCheckDbtimeBefore( pmerge->csrRight, dbtime, pmerge->dbtimeRightBefore, &err ) )
				{
				Call( err );
				pmerge->csrRight.UpgradeFromRIWLatch();
				}
			CallS( err );

			Assert( ( pgnoNull == pmerge->csrLeft.Pgno()
						&& !pmerge->csrLeft.FLatched() )
				|| latchRIW == pmerge->csrLeft.Latch() );

			if ( pmerge->csrLeft.FLatched() && FLGNeedRedoCheckDbtimeBefore( pmerge->csrLeft, dbtime, pmerge->dbtimeLeftBefore, &err ) )
				{
				Call( err );
				pmerge->csrLeft.UpgradeFromRIWLatch();
				}
			CallS( err );
			}
		}
HandleError:		
	return err;
	}


//	recovers a merge or an empty page operation 
//		with accompanying node delete operations
//	
ERR LOG::ErrLGRIRedoMerge( PIB *ppib, DBTIME dbtime )
	{
	ERR				err;
	const LRMERGE	*plrmerge	= (LRMERGE *) ppib->PvLogrec( dbtime );
	const DBID		dbid 		= plrmerge->dbid;

	Assert( lrtypMerge == plrmerge->lrtyp );
	Assert( dbtime	== plrmerge->le_dbtime );
	
	const OBJID		objidFDP	= plrmerge->le_objidFDP;
	MERGEPATH		*pmergePathLeaf = NULL;
	
	Assert( ppib->FMacroGoing( dbtime ) );
	BOOL fSkip;
	CallR( ErrLGRICheckRedoCondition(
				dbid,
				dbtime,
				objidFDP,
				ppib,
				fFalse,
				&fSkip ) );
	if ( fSkip )
		return JET_errSuccess;
		
	//	reconstructs merge structures write-latching pages that need redo
	//
	FUCB			*pfucb = pfucbNil;
	
	Call( ErrLGRIRedoMergeStructures( ppib, 
									  dbtime,
									  &pmergePathLeaf, 
									  &pfucb ) );
	Assert( pmergePathLeaf != NULL );
	Assert( pmergePathLeaf->pmerge != NULL );

	Assert( pfucb->bmCurr.key.FNull() );
	Assert( pfucb->bmCurr.data.FNull() );

	//	write latch pages that need redo
	//
	Call( ErrLGIRedoMergeUpgradeLatches( pmergePathLeaf, dbtime ) );
	
	//	sets dirty and dbtime on all updated pages
	//
	LGIRedoMergeUpdateDbtime( pmergePathLeaf, dbtime );
	
	//	calls BTIPerformSplit
	//
	BTIPerformMerge( pfucb, pmergePathLeaf );
	
HandleError:
	//	release latches
	//
	if ( pmergePathLeaf != NULL )
		{
		BTIReleaseMergePaths( pmergePathLeaf );
		}

	return err;
	}

//	upgrades latches on pages that need redo
//
LOCAL ERR ErrLGIRedoSplitUpgradeLatches( SPLITPATH *psplitPathLeaf, DBTIME dbtime )
	{
	ERR			err			= JET_errSuccess;
	SPLITPATH*	psplitPath;
	
	for ( psplitPath = psplitPathLeaf;
		  psplitPath != NULL; 
		  psplitPath = psplitPath->psplitPathParent )
		{
		Assert( latchRIW == psplitPath->csr.Latch() );

		if ( FLGNeedRedoCheckDbtimeBefore( psplitPath->csr, dbtime, psplitPath->dbtimeBefore, &err ) )
			{
			Call ( err );
			psplitPath->csr.UpgradeFromRIWLatch();
			}
		CallS( err );

		SPLIT	*psplit = psplitPath->psplit;
		if ( psplit != NULL )
			{
			//	new page should already be write-latched if redo is needed
			//
#ifdef DEBUG			
			if ( FLGNeedRedoPage( psplit->csrNew, dbtime ) )
				{
				Assert( latchWrite == psplit->csrNew.Latch() );
				}
			else
				{
				Assert( latchRIW == psplit->csrNew.Latch() );
 				}

			if ( pgnoNull == psplit->csrRight.Pgno() )
				{
				Assert( !psplit->csrRight.FLatched() );
				}
			else
				{
				Assert( latchRIW == psplit->csrRight.Latch() );
 				}
#endif			

			if ( psplit->csrRight.FLatched() && FLGNeedRedoCheckDbtimeBefore( psplit->csrRight, dbtime, psplit->dbtimeRightBefore, &err ) )
				{
				Call( err );
				psplit->csrRight.UpgradeFromRIWLatch();
				}
			CallS( err );
			}
		}
HandleError:
	return err;
	}

	
//	recovers split operation
//		reconstructs split structures write-latching pages that need redo
//		creates version for operation
//		calls BTIPerformSplit
//		sets dbtime on all updated pages
//
ERR LOG::ErrLGRIRedoSplit( PIB *ppib, DBTIME dbtime )
	{
	ERR				err;
	const LRSPLIT	*plrsplit	= (LRSPLIT *) ppib->PvLogrec( dbtime );
	const DBID		dbid 		= plrsplit->dbid;

	Assert( lrtypSplit == plrsplit->lrtyp );
	Assert( ppib->FMacroGoing( dbtime ) );
	Assert( dbtime == plrsplit->le_dbtime );
	
	const LEVEL		level		= plrsplit->level;
	
	//	if operation was performed by concurrent CreateIndex, the
	//	updater could be at a higher trx level than when the
	//	indexer logged the operation
	Assert( level == ppib->level
			|| ( level < ppib->level && plrsplit->FConcCI() ) );

	const OBJID		objidFDP	= plrsplit->le_objidFDP;
	SPLITPATH		*psplitPathLeaf = NULL;
	
	BOOL fSkip;
	CallR( ErrLGRICheckRedoCondition(
				dbid,
				dbtime,
				objidFDP,
				ppib,
				fFalse,
				&fSkip ) );
	if ( fSkip )
		return JET_errSuccess;
		
	//	reconstructs split structures write-latching pages that need redo
	//
	FUCB			*pfucb				= pfucbNil;
	KEYDATAFLAGS	kdf;
	DIRFLAG			dirflag				= fDIRNull;	
	BOOL			fVersion;
	RCEID			rceidOper1			= rceidNull;
	RCEID			rceidOper2			= rceidNull;
	BOOL			fOperNeedsRedo		= fFalse;
	SPLIT			*psplit;
	BYTE			*rgb				= NULL;
//	BYTE			rgb[g_cbPageMax];
	
	Call( ErrLGIRedoSplitStructures( ppib, 
									 dbtime,
									 &psplitPathLeaf, 
									 &pfucb, 
									 &dirflag, 
									 &kdf,
									 &rceidOper1,
									 &rceidOper2 ) );
	Assert( psplitPathLeaf != NULL );
	Assert( psplitPathLeaf->psplit != NULL );

	Assert( pfucb->bmCurr.key.FNull() );
	Assert( pfucb->bmCurr.data.FNull() );

	//	upgrade latches on pages that need redo
	//
	Call ( ErrLGIRedoSplitUpgradeLatches( psplitPathLeaf, dbtime ) );
	
	psplit = psplitPathLeaf->psplit;

	Assert( !fOperNeedsRedo );		//	initial value
	if ( splitoperNone != psplit->splitoper )
		{
		if ( psplit->ilineOper < psplit->ilineSplit )
			{
			fOperNeedsRedo = ( latchWrite == psplitPathLeaf->csr.Latch() );
			}
		else
			{
			fOperNeedsRedo = ( latchWrite == psplit->csrNew.Latch() );
			}
		}
					  
	if ( splitoperReplace == psplitPathLeaf->psplit->splitoper
		&& fOperNeedsRedo )
		{
		//	copy bookmark to FUCB
		//
		BTISplitGetReplacedNode( pfucb, psplitPathLeaf->psplit );

		Assert( FFUCBUnique( pfucb ) );

		BFAlloc( (VOID **)&rgb );
		pfucb->kdfCurr.key.CopyIntoBuffer( rgb, g_cbPage );
		pfucb->bmCurr.key.suffix.SetPv( rgb );
		pfucb->bmCurr.key.suffix.SetCb( pfucb->kdfCurr.key.Cb() );
		}
	else if ( splitoperFlagInsertAndReplaceData == psplitPathLeaf->psplit->splitoper )
		{
		NDGetBookmarkFromKDF( pfucb, kdf, &pfucb->bmCurr );
		}

	//	creates version for operation
	//
	fVersion = !( dirflag & fDIRNoVersion ) &&
			   !rgfmp[ pfucb->ifmp ].FVersioningOff() && 
			   splitoperNone != psplitPathLeaf->psplit->splitoper;
								
	if ( fVersion )
		{
		Assert( rceidNull != rceidOper1 );
		Assert( level > 0 );
		Call( ErrLGIRedoSplitCreateVersion( psplitPathLeaf->psplit,
											pfucb,
											kdf,
											dirflag,
											rceidOper1,
											rceidOper2,
											level ) );
		}
	
	//	sets dirty and dbtime on all updated pages
	//
	LGIRedoSplitUpdateDbtime( psplitPathLeaf, dbtime );
	
	//	calls BTIPerformSplit
	//
	BTIPerformSplit( pfucb, psplitPathLeaf, &kdf, dirflag );
	
HandleError:
	//	release latches
	//
	if ( psplitPathLeaf != NULL )
		{
		BTIReleaseSplitPaths( PinstFromPpib( ppib ), psplitPathLeaf );
		}

	if ( NULL != rgb )
		{
		BFFree( rgb );
		}

	return err;
	}

	
//	redoes macro operation
//		[either a split or a merge]
//
ERR LOG::ErrLGRIRedoMacroOperation( PIB *ppib, DBTIME dbtime )
	{
	ERR		err;
	LR 		*plr 	= (LR *) ppib->PvLogrec( dbtime );
	LRTYP	lrtyp	= plr->lrtyp;

	Assert( lrtypSplit == lrtyp || lrtypMerge == lrtyp );
	if ( lrtypSplit == lrtyp )
		err = ErrLGRIRedoSplit( ppib, dbtime );
	else
		err = ErrLGRIRedoMerge( ppib, dbtime );

	return err;
	}


//	Page ref is consumed if its a real page number,
//	and if we didn't just encounter this page.
//	Used in inner RedoOperations loop

INLINE UINT CLGRIConsumePageRef( const PGNO pgno, PGNO* const ppgnoLast )
	{
	if ( pgnoNull != pgno && pgno != *ppgnoLast )
		{
		*ppgnoLast = pgno;
		return 1;
		}
	else
		{
		return 0;
		}
	}

//	Scan from lgposRedoFrom to end of usable log generations. 
//	For each log record, perform operations to redo original operation.
//

ERR LOG::ErrLGRIRedoOperations( IFileSystemAPI *const pfsapi, const LE_LGPOS *ple_lgposRedoFrom, BYTE *pbAttach, LGSTATUSINFO *plgstat )
	{
	ERR					err 					= JET_errSuccess;
	ERR 				errT 					= JET_errSuccess;
	LR					*plr;
	BOOL				fLastLRIsQuit			= fFalse;
	BOOL				fShowSectorStatus		= fFalse;

	const CHAR			*szLogNameCurr 			= m_szLogName;
	LGPOS 				lgposPrevGenMaxUpd 		= lgposMin;

	//	initialize global variable
	//
	m_lgposRedoShutDownMarkGlobal = lgposMin;

	//	reset m_pbLastMSFlush before restart
	//
	// Make a log reader to be used by ErrLGLocateFirstRedoLogRec() and ErrLGGetNextRec()
	// and ErrLGCheckReadLastLogRecord().
	Assert( m_plread == pNil );
	m_plread = new LogReader();
	if ( pNil == m_plread )
		{
		CallR( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//	get the size of the log file

	Assert( m_pfapiLog );
	QWORD	cbSize;
	Call( m_pfapiLog->ErrSize( &cbSize ) );

	Assert( m_cbSec > 0 );
	Assert( ( cbSize % m_cbSec ) == 0 );
	UINT	csecSize;
	csecSize = UINT( cbSize / m_cbSec );
	Assert( csecSize > m_csecHeader );

	//	setup the log reader

	Call( m_plread->ErrLReaderInit( this, csecSize ) );
	Call( m_plread->ErrEnsureLogFile() );

	//	scan the log to find traces of corruption before going record-to-record
	//	if any corruption is found, an error will be returned
	BOOL fDummy;
	err = ErrLGCheckReadLastLogRecordFF( pfsapi, &fDummy );
	//	remember errors about corruption but don't do anything with them yet
	//	we will go up to the point of corruption and then return the right error
	if ( err == JET_errSuccess || FErrIsLogCorruption( err ) )
		{
		errT = err;
		}
	else
		{
		Assert( err < 0 );
		Call( err );
		}

	//	now scan thve first record
	//	there should be no errors about corruption since they'll be handled by ErrLGCheckReadLastLogRecordFF
	err = ErrLGLocateFirstRedoLogRecFF( (LE_LGPOS *)ple_lgposRedoFrom, (BYTE **) &plr );
	if ( err == errLGNoMoreRecords )
		{
		//	no records existed in this log -- this means that the log is corrupt
		//	tanslate to the proper corruption message

		//	what recovery mode are we in?

		if ( m_fHardRestore )
			{

			//	we are in hard-recovery mode

			if ( m_plgfilehdr->lgfilehdr.le_lGeneration <= m_lGenHighRestore )
				{

				//	this generation is part of a backup set

				Assert( m_plgfilehdr->lgfilehdr.le_lGeneration >= m_lGenLowRestore );
				Call( ErrERRCheck( JET_errLogCorruptDuringHardRestore ) );
				}
			else
				{

				//	the current log generation is not part of the backup-set

				Call( ErrERRCheck( JET_errLogCorruptDuringHardRecovery ) );
				}
			}
		else
			{

			//	we are in soft-recovery mode 

			Call( ErrERRCheck( JET_errLogFileCorrupt ) );
			}
		}
	else if ( err != JET_errSuccess )
		{
		Call( err );
		}
	//	we don't expect any warnings, so this must be successful
	CallS( err );

#ifdef DEBUG
//	if ( m_lgposLastRec.isec )
		{
		LGPOS	lgpos;
		GetLgposOfPbNext( &lgpos );
		Assert( CmpLgpos( &lgpos, &m_lgposLastRec ) < 0 );
		}
#endif

	//	log redo progress.
	UtilReportEvent( 
				eventInformation, 
				LOGGING_RECOVERY_CATEGORY, 
				STATUS_REDO_ID, 
				1, 
				&szLogNameCurr, 
				0, 
				NULL, 
				m_pinst );

	if ( plgstat )
		{
		fShowSectorStatus = plgstat->fCountingSectors;
		if ( fShowSectorStatus )
			{
			//	reset byte counts
			//
			plgstat->cSectorsSoFar = ple_lgposRedoFrom->le_isec;
			plgstat->cSectorsExpected = m_plgfilehdr->lgfilehdr.le_csecLGFile;
			}
		}


	m_fLastLRIsShutdown = fFalse;

#ifdef UNLIMITED_DB
	Assert( m_fNeedInitialDbList );
#endif

		{
		for ( UINT idbid = 0; idbid < cdbidMax; ++idbid )
			{
			m_rgpgnoLast[ idbid ] = pgnoNull;
			}
		}

	do
		{
		FMP		*pfmp;			// for db operations
		DBID	dbid;			// for db operations
		IFMP	ifmp;

		if ( errLGNoMoreRecords == err )
			{
			INT	fNSNextStep;

			//	if we had a corruption error on this generation, do not process other other generations

			if ( errT != JET_errSuccess )
				{
				goto Done;
				}

			//	bring in the next generation
			err = ErrLGRedoFill( pfsapi, &plr, fLastLRIsQuit, &fNSNextStep );
			//	remember errors about corruption but don't do anything with them yet
			//	we will go up to the point of corruption and then return the right error
			if ( FErrIsLogCorruption( err ) )
				{
				errT = err;
				
				//	make sure we process this log generation (up to the point of corruption)

				fNSNextStep = fNSGotoCheck;
				}
			else if ( err == errLGNoMoreRecords )
				{
				//	no records existed in this log because ErrLGLocateFirstRedoLogRecFF returned this error
				//		this means that the log is corrupt -- setup the proper corruption message

				//	what recovery mode are we in?

				if ( m_fHardRestore )
					{

					//	we are in hard-recovery mode

					if ( m_plgfilehdr->lgfilehdr.le_lGeneration <= m_lGenHighRestore )
						{

						//	this generation is part of a backup set

						Assert( m_plgfilehdr->lgfilehdr.le_lGeneration >= m_lGenLowRestore );
						errT = ErrERRCheck( JET_errLogCorruptDuringHardRestore );
						}
					else
						{

						//	the current log generation is not part of the backup-set

						errT = ErrERRCheck( JET_errLogCorruptDuringHardRecovery );
						}
					}
				else
					{

					//	we are in soft-recovery mode 

					errT = ErrERRCheck( JET_errLogFileCorrupt );
					}

				//	make sure we process this log generation
				
				fNSNextStep = fNSGotoCheck;
				}
			else if ( err != JET_errSuccess )
				{
				Assert( err < 0 );
				Call( err );
				}

			switch( fNSNextStep )
				{
				case fNSGotoDone:
					goto Done;

				case fNSGotoCheck:
					//	log redo progress.
					UtilReportEvent(
							eventInformation,
							LOGGING_RECOVERY_CATEGORY,
							STATUS_REDO_ID,
							1,
							&szLogNameCurr,
							0,
							NULL,
							m_pinst );

					if ( !plgstat )
						{
						if ( fGlobalRepair )
							printf( " Recovering Generation %d.\n", m_plgfilehdr->lgfilehdr.le_lGeneration );
						}
					else
						{
						JET_SNPROG	*psnprog = &(plgstat->snprog);
						ULONG		cPercentSoFar;

						plgstat->cGensSoFar += 1;
						Assert(plgstat->cGensSoFar <= plgstat->cGensExpected);
						cPercentSoFar = (ULONG)
							((plgstat->cGensSoFar * 100) / plgstat->cGensExpected);

						Assert( cPercentSoFar >= psnprog->cunitDone );
						if ( cPercentSoFar > psnprog->cunitDone )
							{
							psnprog->cunitDone = cPercentSoFar;
							(*plgstat->pfnStatus)( 0, JET_snpRestore,
								JET_sntProgress, psnprog);
							}

						if ( fShowSectorStatus )
							{
							/*	reset byte counts
							/**/
							plgstat->cSectorsSoFar = 0;
							plgstat->cSectorsExpected = m_plgfilehdr->lgfilehdr.le_csecLGFile;
							}
						}
					Assert( m_pbNext != pbNil );
					goto CheckNextRec;
				}

			/*	should never get here
			/**/
			Assert( fFalse );
			}

CheckNextRec:
		GetLgposOfPbNext(&m_lgposRedo);

#ifdef RTM
#else
		extern LGPOS g_lgposRedoTrap;
		AssertSzRTL( CmpLgpos( m_lgposRedo, g_lgposRedoTrap ), "Redo Trap" );
#endif

		//	Keep track of last LR to see if it is shutdown mark
		//	Skip those lr that does nothing material. Do not change
		//	m_fLastLRIsShutdown if LR is debug only log record.

		if ( ! m_fDumppingLogs )
			{
			// Possibly pre-read database pages
			Call( ErrLGIPrereadCheck() );

			// Count how many page references we'll be consuming.
		
			switch( plr->lrtyp )
				{
				case lrtypInsert:
				case lrtypFlagInsert:
				case lrtypFlagInsertAndReplaceData:
				case lrtypReplace:
				case lrtypReplaceD:
				case lrtypFlagDelete:
				case lrtypDelete:
				case lrtypDelta:
				case lrtypSLVSpace:
				case lrtypSetExternalHeader:
					{
					const LRPAGE_ * const plrpage = (LRPAGE_ *)plr;
					const PGNO pgno = plrpage->le_pgno;
					const INT idbid = plrpage->dbid - 1;
					if( idbid >= cdbidMax )
						break;

					m_cPageRefsConsumed += CLGRIConsumePageRef( pgno, &m_rgpgnoLast[ idbid ] );
					}
					break;

				case lrtypSplit:
					{
					const LRSPLIT * const plrsplit = (LRSPLIT *)plr;
					const INT idbid = plrsplit->dbid - 1;
					if( idbid >= cdbidMax )
						break;

					m_cPageRefsConsumed += CLGRIConsumePageRef( plrsplit->le_pgno, &m_rgpgnoLast[ idbid ] );
					m_cPageRefsConsumed += CLGRIConsumePageRef( plrsplit->le_pgnoNew, &m_rgpgnoLast[ idbid ] );
					m_cPageRefsConsumed += CLGRIConsumePageRef( plrsplit->le_pgnoParent, &m_rgpgnoLast[ idbid ] );
					m_cPageRefsConsumed += CLGRIConsumePageRef( plrsplit->le_pgnoRight, &m_rgpgnoLast[ idbid ] );
					}
					break;
					
				case lrtypMerge:
					{
					const LRMERGE * const plrmerge = (LRMERGE *)plr;	
					const INT idbid = plrmerge->dbid - 1;
					if( idbid >= cdbidMax )
						break;

					m_cPageRefsConsumed += CLGRIConsumePageRef( plrmerge->le_pgno, &m_rgpgnoLast[ idbid ] );
					m_cPageRefsConsumed += CLGRIConsumePageRef( plrmerge->le_pgnoRight, &m_rgpgnoLast[ idbid ] );
					m_cPageRefsConsumed += CLGRIConsumePageRef( plrmerge->le_pgnoLeft, &m_rgpgnoLast[ idbid ] );
					m_cPageRefsConsumed += CLGRIConsumePageRef( plrmerge->le_pgnoParent, &m_rgpgnoLast[ idbid ] );
					}
					break;

				default:
					break;
				}
			}

		//	if initial DbList has not yet been created,
		//	it must be because we haven't reached
		//	the DbList (or Init) log record yet
		Assert( !m_fNeedInitialDbList
			|| lrtypChecksum == plr->lrtyp
			|| lrtypDbList == plr->lrtyp
			|| lrtypInit2 == plr->lrtyp );

		// update genMaxReq for the databases to avoid the following scenario:
		// - backup set 3-5, play forward 6-10
		// - replay up to 8 and crash
		// - delete logs 7-10
		// - run hard recovery w/o restoring the files
		// we also want to update for soft recovery if we have an older than logs database
		// (like during soft recovery of a offline backup or snapshot)
		if ( m_lgposRedo.lGeneration > lgposPrevGenMaxUpd.lGeneration )
			{
			m_critCheckpoint.Enter();
			err = ErrLGIUpdateGenRequired(
						pfsapi,
						0, // pass 0 to preserve the existing value
						m_lgposRedo.lGeneration,
						m_plgfilehdr->lgfilehdr.tmCreate,
						NULL );
			m_critCheckpoint.Leave();
			CallR ( err );
		 	lgposPrevGenMaxUpd = m_lgposRedo;
		 	}

		switch ( plr->lrtyp )
			{
		case lrtypNOP:
			continue;

			// This may not be optimally efficient to put this
			// so high on the log record processing.
		case lrtypChecksum:
			continue;

		case lrtypTrace:					/* Debug purpose only log records. */
		case lrtypJetOp:
		case lrtypRecoveryUndo:
		case lrtypRecoveryUndo2:
			break;

		case lrtypFullBackup:				/* Debug purpose only log records */
			m_lgposFullBackup = m_lgposRedo;
			m_fRestoreMode = fRestoreRedo;
			break;
			
		case lrtypIncBackup:				/* Debug purpose only log records */
			m_lgposIncBackup = m_lgposRedo;
			m_fRestoreMode = fRestoreRedo;
			break;

		case lrtypBackup:					/* Debug purpose only log records */
			{
			LRLOGBACKUP * plrlb = (LRLOGBACKUP *) plr;
			if ( plrlb->FFull() )
				{
				m_lgposFullBackup = m_lgposRedo;
				m_fRestoreMode = fRestoreRedo;
				}
			else if ( plrlb->FIncremental() )
				{
				m_lgposIncBackup = m_lgposRedo;
				m_fRestoreMode = fRestoreRedo;
				}
			else if ( plrlb->FSnapshotStart() )
				{
				// if we restore a snapshot and the Snapshot Start of the database is the current log record
				if ( fSnapshotBefore == m_fSnapshotMode && 0 == CmpLgpos ( &m_lgposSnapshotStart, &m_lgposRedo ) )
					{
					m_fSnapshotMode = fSnapshotDuring;
					}
				}
			else if ( plrlb->FSnapshotStop() )
				{
				// first SnapshotStop when we are in the logs during the restored snapshot
				// must be the end of the snapshot
				if ( fSnapshotDuring == m_fSnapshotMode )
					{
					m_fSnapshotMode = fSnapshotAfter;
					}
				if ( !m_fHardRestore )
					{
					// snapshot mode set only on hard recovery
					Assert ( fSnapshotNone == m_fSnapshotMode );

					for ( DBID dbidToCheck = dbidUserLeast; dbidToCheck < dbidMax; dbidToCheck++ )
						{
						if ( ifmpMax == m_pinst->m_mpdbidifmp[ dbidToCheck ] )
							continue;
						
						pfmp = &rgfmp[ m_pinst->m_mpdbidifmp[ dbidToCheck ] ];

						if ( !pfmp->FInUse() || !pfmp->FAttached() )
							continue;

						Assert ( pfmp->Pdbfilehdr() );
						
						// if db has snapshot start but no stop (on stop we reset snapshot start)
						// the it must be a crash during snapshot or
						// from a snapshot backup set
						// If crash we should not find the snapshot stop log record during soft recovery
						if ( 0 != CmpLgpos ( &(pfmp->Pdbfilehdr()->bkinfoSnapshotCur.le_lgposMark), &lgposMin ) )
							{
							Assert ( 0 != CmpLgpos ( &(pfmp->Pdbfilehdr()->bkinfoSnapshotCur.le_lgposMark), &m_lgposRedo ) );
							
							// if we found snapshot stop log record past the snapshot start mark in db header
							if ( 0 > CmpLgpos ( &(pfmp->Pdbfilehdr()->bkinfoSnapshotCur.le_lgposMark), &m_lgposRedo ) )
								{
								Call ( ErrERRCheck ( JET_errSoftRecoveryOnSnapshot ) );
								}
							}
						}
					}
				}
			else
				{
				Assert ( fFalse );
				}
			break;
			}

		case lrtypShutDownMark:			/* Last consistency point */
			m_lgposRedoShutDownMarkGlobal = m_lgposRedo;
			m_fLastLRIsShutdown = fTrue;
			break;

		default:
			{
			m_fLastLRIsShutdown = fFalse;

			//	Check the LR that does the real work from here:

			switch ( plr->lrtyp )
				{
			case lrtypEnd:
				AssertSz( fFalse, "lrtypEnd record showed up in a FASTFLUSH log that should not have lrtypEnd records." );
				Call( ErrERRCheck( JET_errLogCorrupted ) );
				break;

			case lrtypMacroBegin:
				{
				PIB *ppib;

				LRMACROBEGIN *plrMacroBegin = (LRMACROBEGIN *) plr;
				Call( ErrLGRIPpibFromProcid( plrMacroBegin->le_procid, &ppib ) );
				
				Assert( !ppib->FMacroGoing( plrMacroBegin->le_dbtime ) );
				Call( ppib->ErrSetMacroGoing( plrMacroBegin->le_dbtime ) );
				break;
				}

			case lrtypMacroCommit:
			case lrtypMacroAbort:
				{
				PIB 		*ppib;
				LRMACROEND 	*plrmend = (LRMACROEND *) plr;
				DBTIME		dbtime = plrmend->le_dbtime;

				Call( ErrLGRIPpibFromProcid( plrmend->le_procid, &ppib ) );

				//	if it is commit, redo all the recorded log records,
				//	otherwise, throw away the logs
				//
				if ( lrtypMacroCommit == plr->lrtyp && ppib->FAfterFirstBT() )
					{					
					Call(ErrLGRIRedoMacroOperation( ppib, dbtime ) );
					}

				//	disable MacroGoing
				//
				ppib->ResetMacroGoing( dbtime );
				
				break;
				}

			case lrtypInit2:
			case lrtypInit:
				{
				/*	start mark the jet init. Abort all active seesions.
				/**/
				LRINIT2  *plrstart = (LRINIT2 *)plr;

				LGRITraceRedo( plr );

				if ( !m_fAfterEndAllSessions )
					{
					Call( ErrLGRIEndAllSessions( pfsapi, fFalse, ple_lgposRedoFrom, pbAttach ) );
					m_fAfterEndAllSessions = fTrue;
					m_fNeedInitialDbList = fFalse;
#ifdef DEBUG
					m_lgposRedoShutDownMarkGlobal = lgposMin;
#endif
					}

				/*	Check Init session for hard restore only.
				 */
				Assert( 0 == *pbAttach );
				Call( ErrLGRIInitSession(
							pfsapi,
							&plrstart->dbms_param,
							pbAttach,
							plgstat,
							redoattachmodeInitLR ) );
				m_fAfterEndAllSessions = fFalse;
				}
				break;

			case lrtypRecoveryQuit:
			case lrtypRecoveryQuit2:
			case lrtypTerm:
			case lrtypTerm2:
				/*	all records are re/done. all rce entries should be gone now.
				/**/
#ifdef DEBUG
				{
				CPPIB   *pcppib = m_rgcppib;
				CPPIB   *pcppibMax = pcppib + m_ccppib;
				for ( ; pcppib < pcppibMax; pcppib++ )
					if ( pcppib->ppib != ppibNil &&
						 pcppib->ppib->prceNewest != prceNil )
						{
						RCE *prceT = pcppib->ppib->prceNewest;
						while ( prceT != prceNil )
							{
							Assert( prceT->FOperNull() );
							prceT = prceT->PrcePrevOfSession();
							}
						}
				}
#endif
				
				/*	quit marks the end of a normal run. All sessions
				/*	have ended or must be forced to end. Any further
				/*	sessions will begin with a BeginT.
				/**/
#ifdef DEBUG
				m_fDBGNoLog = fTrue;
#endif
				/*	set m_lgposLogRec such that later start/shut down
				 *	will put right lgposConsistent into dbfilehdr
				 *	when closing the database.
				 */
				if ( !m_fAfterEndAllSessions )
					{
					Call( ErrLGRIEndAllSessions( pfsapi, fFalse, ple_lgposRedoFrom, pbAttach ) );
					m_fAfterEndAllSessions = fTrue;
#ifdef DEBUG
					m_lgposRedoShutDownMarkGlobal = lgposMin;
#endif
					}

				fLastLRIsQuit = fTrue;
				continue;

	   		/****************************************************/
	   		/*	Database Operations                          */
	   		/****************************************************/
	   		case lrtypDbList:
	   			{
#ifdef UNLIMITED_DB	   			
	   			LRDBLIST*		plrdblist		= (LRDBLIST *)plr;

	   			LGRITraceRedo( plr );

				//	if never replayed an Init and we hit a DbList,
				//	this implicitly tells us we need to redo the Init
	   			if ( m_fNeedInitialDbList )
	   				{
					err = ErrLGLoadFMPFromAttachments( m_pinst, pfsapi, plrdblist->rgb );
					CallS( err );
					Call( err );

					Call( ErrLGRIRedoInitialAttachments_( pfsapi ) );

	   				m_fNeedInitialDbList = fFalse;
	   				}
#endif
				break;
	   			}
	            
			case lrtypCreateDB:
				{
				PIB				*ppib;
				REDOATTACH		redoattach;
				LRCREATEDB		*plrcreatedb	= (LRCREATEDB *)plr;

				dbid = plrcreatedb->dbid;
				Assert( dbid != dbidTemp );

				LGRITraceRedo(plr);
				Call( ErrLGRIPpibFromProcid( plrcreatedb->le_procid, &ppib ) );

				// set-up the FMP
				{
				// build an ATTACHINFO based on this log record
				ATTACHINFO *pAttachInfo = NULL;

				pAttachInfo = static_cast<ATTACHINFO *>( PvOSMemoryHeapAlloc( sizeof( ATTACHINFO ) + plrcreatedb->CbPath() ) );
				if ( NULL == pAttachInfo )
					{
					CallR ( ErrERRCheck( JET_errOutOfMemory ) );
					}
				
				memset( pAttachInfo, 0, sizeof(sizeof( ATTACHINFO ) + plrcreatedb->CbPath()) );
				pAttachInfo->SetDbid( plrcreatedb->dbid );

				Assert ( !pAttachInfo->FSLVExists() );
				if ( plrcreatedb->FCreateSLV() )
					{
					pAttachInfo->SetFSLVExists();
					}

				Assert ( !pAttachInfo->FSLVProviderNotEnabled() );
				if ( plrcreatedb->FSLVProviderNotEnabled() )
					{
					pAttachInfo->SetFSLVProviderNotEnabled();
					}
					
				pAttachInfo->SetCbNames( plrcreatedb->CbPath() );
				pAttachInfo->SetDbtime( 0 );
				pAttachInfo->SetObjidLast( objidNil );
				pAttachInfo->SetCpgDatabaseSizeMax( plrcreatedb->le_cpgDatabaseSizeMax );
				pAttachInfo->le_lgposAttach = m_lgposRedo;
				pAttachInfo->le_lgposConsistent = lgposMin;
				memcpy( &pAttachInfo->signDb, &plrcreatedb->signDb, sizeof(SIGNATURE) );
				memcpy ( pAttachInfo->szNames, (CHAR *)plrcreatedb->rgb, plrcreatedb->CbPath() );		

				err = ErrLGRISetupFMPFromAttach( pfsapi, ppib, &m_signLog, pAttachInfo, plgstat);
				Assert ( pAttachInfo );
				OSMemoryHeapFree( pAttachInfo );
				CallR ( err );
				}
				
				ifmp = m_pinst->m_mpdbidifmp[ dbid ];
				FMP::AssertVALIDIFMP( ifmp );
				pfmp = &rgfmp[ ifmp ];

				if ( pfmp->FSkippedAttach() || pfmp->FDeferredAttach() )
					{
					break;
					}

				const BOOL	fDBPathValid	= ( ErrUtilDirectoryValidate( pfsapi, pfmp->SzDatabaseName() ) >= 0 );
				const BOOL	fDBFileMissing	= ( !fDBPathValid || ( ErrUtilPathExists( pfsapi, pfmp->SzDatabaseName() ) < 0 ) );
				const BOOL	fSLVFileNeeded	= ( NULL != pfmp->SzSLVName()  );
				const BOOL	fSLVFileMissing	= ( fSLVFileNeeded && ( ErrUtilPathExists( pfsapi, pfmp->SzSLVName() ) < 0 ) );
					
				if ( fDBPathValid
					&& fDBFileMissing
					&& ( !fSLVFileNeeded || fSLVFileMissing ) )
					{
					//	both database and SLV are missing, so recreate them
					redoattach = redoattachCreate;
					}
				else
					{
					Assert(	!fDBPathValid
						|| ( !fSLVFileNeeded && !fDBFileMissing )						// DBFile only needed and exists
						|| ( fSLVFileNeeded &&  !fSLVFileMissing && !fDBFileMissing )	// both needed and exist
						|| ( fSLVFileNeeded && ( fSLVFileMissing ^ fDBFileMissing ) )	// both needed but only one exists
						);

					Assert( !pfmp->FReadOnlyAttach() );
					Call( ErrLGRICheckAttachedDb(
								pfsapi,
								ifmp,
								NULL,
								&redoattach,
								redoattachmodeCreateDbLR ) );
					Assert( NULL != pfmp->Pdbfilehdr()
						|| redoattachCreate == redoattach );

					if ( fDBFileMissing )
						{
						// if missing, it is deferred
						Assert( redoattachDefer == redoattach );
						}
					else
						{
		                // database present and need not deferable, but SLV file missing
						if ( redoattachNow == redoattach && fSLVFileNeeded && fSLVFileMissing )
							{
		        	        Call( ErrERRCheck( JET_errSLVStreamingFileMissing ) );
		            	    }					
						}

					//	if redoing attach on db, then SLV must also be present (or not needed)
					Assert( redoattachNow != redoattach
							|| !fSLVFileNeeded
							|| !fSLVFileMissing );
					}

				switch( redoattach )
					{
					case redoattachCreate:
						//	we've already pre-determined (in ErrLGRICheckRedoCreateDb())
						//	that any existing database needs to be overwritten, so
						//	it's okay to unequivocally pass in JET_bitDbOverwriteExisting
						Call( ErrLGRIRedoCreateDb(
									ppib,
									ifmp,
									dbid,
									plrcreatedb->le_grbit | JET_bitDbOverwriteExisting,
									&plrcreatedb->signDb ) );
						break;

					case redoattachNow:
						Assert( !pfmp->FReadOnlyAttach() );
						Call( ErrLGRIRedoAttachDb(
									pfsapi,
									ifmp,
									plrcreatedb->le_cpgDatabaseSizeMax,
									redoattachmodeCreateDbLR ) );
						break;

					default:
						Assert( fFalse );	//	should be impossible, but as a firewall, set to defer the attachment
					case redoattachDefer:
						Assert( !pfmp->FReadOnlyAttach() );
						LGRISetDeferredAttachment( ifmp );
						break;
					}
				}
				break;

			case lrtypAttachDB:
				{
				PIB			*ppib;
				REDOATTACH	redoattach;
				LRATTACHDB  *plrattachdb	= (LRATTACHDB *)plr;
				
				dbid = plrattachdb->dbid;
				Assert( dbid != dbidTemp );

				LGRITraceRedo( plr );

				Call( ErrLGRIPpibFromProcid( plrattachdb->le_procid, &ppib ) );

				if ( m_fHardRestore )
					{
					CHAR        *szDbName		= reinterpret_cast<CHAR *>( plrattachdb->rgb );
					CHAR		*szSLVName		= ( plrattachdb->FSLVExists() ?
														szDbName + strlen( szDbName ) + 1 :		//	SLV name follows db name
														NULL );
					CallSx ( ErrReplaceRstMapEntry( szDbName, &plrattachdb->signDb, fFalse ), JET_errFileNotFound );

					if ( NULL != szSLVName )
						{
						CallSx ( ErrReplaceRstMapEntry( szSLVName, &plrattachdb->signDb, fTrue ), JET_errFileNotFound );
						}
					}

				// set-up the FMP
				{
				// build an ATTACHINFO based on this log record
				ATTACHINFO *pAttachInfo = NULL;

				pAttachInfo = static_cast<ATTACHINFO *>( PvOSMemoryHeapAlloc( sizeof( ATTACHINFO ) + plrattachdb->CbPath() ) );
				if ( NULL == pAttachInfo )
					{
					CallR ( ErrERRCheck( JET_errOutOfMemory ) );
					}

				memset( pAttachInfo, 0, sizeof(sizeof( ATTACHINFO ) + plrattachdb->CbPath()) );
				pAttachInfo->SetDbid( plrattachdb->dbid );

				Assert ( !pAttachInfo->FSLVExists() );
				if ( plrattachdb->FSLVExists() )
					{
					pAttachInfo->SetFSLVExists();
					}

				Assert ( !pAttachInfo->FSLVProviderNotEnabled() );
				if ( plrattachdb->FSLVProviderNotEnabled() )
					{
					pAttachInfo->SetFSLVProviderNotEnabled();
					}
					
				pAttachInfo->SetCbNames( plrattachdb->CbPath() );
				pAttachInfo->SetDbtime( 0 );
				pAttachInfo->SetObjidLast( objidNil );
				pAttachInfo->SetCpgDatabaseSizeMax( plrattachdb->le_cpgDatabaseSizeMax );
				pAttachInfo->le_lgposAttach = m_lgposRedo;
				pAttachInfo->le_lgposConsistent = plrattachdb->lgposConsistent;
				memcpy( &pAttachInfo->signDb, &plrattachdb->signDb, sizeof(SIGNATURE) );
				memcpy ( pAttachInfo->szNames, (CHAR *)plrattachdb->rgb, plrattachdb->CbPath() );		

				err = ErrLGRISetupFMPFromAttach( pfsapi, ppib, &m_signLog, pAttachInfo, plgstat);
				Assert ( pAttachInfo );
				OSMemoryHeapFree( pAttachInfo );
				CallR ( err );
				}
				
				ifmp = m_pinst->m_mpdbidifmp[ dbid ];
				FMP::AssertVALIDIFMP( ifmp );
				pfmp = &rgfmp[ ifmp ];

				if ( pfmp->FSkippedAttach() || pfmp->FDeferredAttach() )
					{
					break;
					}
					
				Assert( !pfmp->FReadOnlyAttach() );
				Call( ErrLGRICheckAttachedDb(
							pfsapi,
							ifmp,
							&plrattachdb->signLog,
							&redoattach,
							redoattachmodeAttachDbLR ) );
				Assert( NULL != pfmp->Pdbfilehdr() );
					
				switch ( redoattach )
					{
					case redoattachNow:
						Assert( !pfmp->FReadOnlyAttach() );
						Call( ErrLGRIRedoAttachDb(
									pfsapi,
									ifmp,
									plrattachdb->le_cpgDatabaseSizeMax,
									redoattachmodeAttachDbLR ) );
						break;

					case redoattachCreate:
					default:
						Assert( fFalse );	//	should be impossible, but as a firewall, set to defer the attachment
					case redoattachDefer:
						Assert( !pfmp->FReadOnlyAttach() );
						LGRISetDeferredAttachment( ifmp );
						break;
					}
				}
				break;

			case lrtypForceDetachDB:
				{
				LRFORCEDETACHDB		*	plrforcedetachdb 	= (LRFORCEDETACHDB *)plr;
				DBID					dbid 				= plrforcedetachdb->dbid;
				
				IFMP 					ifmp 				= m_pinst->m_mpdbidifmp[ dbid ];
				FMP::AssertVALIDIFMP( ifmp );
				
				PIB * 					ppibToClean 		= m_pinst->m_ppibGlobal;
				FMP *					pfmp 				= &rgfmp[ ifmp ];

				Assert ( !pfmp->FReadOnlyAttach() );

				if ( pfmp->Pdbfilehdr() )
					{
					//	Set current time to one at the detach moment
					Assert ( plrforcedetachdb->Dbtime() >= pfmp->DbtimeLast() );
					pfmp->SetDbtimeLast( plrforcedetachdb->Dbtime() );

					// need do add a new state to the db ? Like JET_dbstateDuringForceDetach ...
					// is the db unusable between this point and the detach moment following ?
					Assert ( !m_pinst->m_plog->m_fLogDisabled );
					pfmp->Pdbfilehdr()->SetDbstate( JET_dbstateForceDetach, m_pinst->m_plog->m_plgfilehdr->lgfilehdr.le_lGeneration, &m_pinst->m_plog->m_plgfilehdr->lgfilehdr.tmCreate );				
					pfmp->Pdbfilehdr()->le_dbtimeDirtied = pfmp->DbtimeLast();

					Assert ( !pfmp->FUndoForceDetach() );
					pfmp->SetDbtimeUndoForceDetach( plrforcedetachdb->Dbtime() + (DBTIME) plrforcedetachdb->RceidMax() );
					Assert ( pfmp->FUndoForceDetach() );

					// unnecessary check. It was made during Attach
					// if ( pfmp->Pdbfilehdr()->FSLVExists() )
					//	{
					//	CallR( ErrSLVReadHeader( pfs, ifmp ) );
					//	}
					
					Call( ErrUtilWriteShadowedHeader(	pfsapi, 
														pfmp->SzDatabaseName(), 
														fTrue,
														(BYTE *)pfmp->Pdbfilehdr(), 
														g_cbPage,
														pfmp->Pfapi() ) );

					if ( plrforcedetachdb->FCloseSessions() )
					// we have to Undo operations
						{		
						while ( ppibToClean != ppibNil )
							{						
							if ( ppibToClean->pfucbOfSession && ppibToClean->pfucbOfSession->ifmp == ifmp )
								{
#ifdef DEBUG
								// all FUCB's in this session should be on the same DB
								// (we checked this on ForceDetach)
								{
								FUCB * pfucbToCheck = ppibToClean->pfucbOfSession;
								while ( pfucbToCheck )
									{
									Assert ( pfucbToCheck->ifmp == ifmp );
									pfucbToCheck = pfucbToCheck->pfucbNextOfSession;
									}
								}
#endif // DEBUG
								while ( 1 <= ppibToClean->level )
									{
#ifdef DEBUG
									LEVEL level = ppibToClean->level;
#endif // DEBUG
									
									PIBSetTrxContext( ppibToClean );
									CallSx ( ErrDIRRollback( ppibToClean ), JET_errRollbackError );
									CallR ( err );
									Assert ( ppibToClean->level == level - 1 );
									}							
								}							
							 ppibToClean = ppibToClean->ppibNext;
							 }
						}
#ifdef DEBUG
					else
						{
						// no sessions using the database are supposed to exist at this point
						// 		
						while ( ppibToClean != ppibNil )
							{						
							Assert ( ppibToClean->rgcdbOpen[ pfmp->Dbid() ] == 0 );
							ppibToClean = ppibToClean->ppibNext;
							}
						}
#endif
					Assert ( pfmp->FUndoForceDetach() );
					pfmp->ResetDbtimeUndoForceDetach( );
					Assert ( !pfmp->FUndoForceDetach() );
					
					}
				else
					{
					Assert( pfmp->FSkippedAttach() || pfmp->FDeferredAttach() );
					}
				}
				// after that we just have to perform a normal detach
				
			case lrtypDetachDB:
				{
				LRDETACHDB		*plrdetachdb = (LRDETACHDB *)plr;
				// WARNING WARNING WARNING
				// =======================
				// rgb does not point to Path if it is a LRFORCEDETACH record.
				// If you gonna use that field be sure that you use it correctly.
				// Check plr->lrtyp
				DBID			dbid = plrdetachdb->dbid;

				Assert( dbid != dbidTemp );
				ifmp = m_pinst->m_mpdbidifmp[ dbid ];
				FMP::AssertVALIDIFMP( ifmp );
				pfmp = &rgfmp[ifmp];

				if ( pfmp->Pdbfilehdr() )
					{
					/*	close database for all active user.
					 */
					CPPIB   *pcppib = m_rgcppib;
					CPPIB   *pcppibMax = pcppib + m_ccppib;
					PIB		*ppib;

					/*	find pcppib corresponding to procid if it exists
					 */
					for ( ; pcppib < pcppibMax; pcppib++ )
						{
						PIB *ppib = pcppib->ppib;
						
						if ( ppib == NULL )
							continue;

						while( FPIBUserOpenedDatabase( ppib, dbid ) )
							{
							if ( NULL != m_ptablehfhash )
								{
								//	close all fucb on this database
								//
								m_ptablehfhash->Purge( ppib, ifmp );
								}
							Call( ErrDBCloseDatabase( ppib, ifmp, 0 ) );
							}
						}

					/*	if attached before this detach.
					 *	there should be no more operations on this database entry.
					 *	detach it!!
					 */
					 {
					 BKINFO * pbkInfoToCopy;

					if ( FSnapshotRestore() )
						{
						pbkInfoToCopy = &(pfmp->Pdbfilehdr()->bkinfoSnapshotCur);
						}
					else
						{
						pbkInfoToCopy = &(pfmp->Pdbfilehdr()->bkinfoFullCur);
						}


					if ( pbkInfoToCopy->le_genLow != 0 )
						{
						Assert( pbkInfoToCopy->le_genHigh != 0 );
						Assert ( m_fHardRestore );
						pfmp->Pdbfilehdr()->bkinfoFullPrev = *pbkInfoToCopy;
						memset(	&pfmp->Pdbfilehdr()->bkinfoFullCur, 0, sizeof( BKINFO ) );
						memset(	&pfmp->Pdbfilehdr()->bkinfoIncPrev, 0, sizeof( BKINFO ) );
						memset(	&pfmp->Pdbfilehdr()->bkinfoSnapshotCur, 0, sizeof( BKINFO ) );
						}
					}
					

#ifdef BKINFO_DELETE_ON_HARD_RECOVERY
					// BUG: 175058: delete the previous backup info on any hard recovery
					// this will prevent a incremental backup and log truncation problems
					// UNDONE: the above logic to copy bkinfoFullPrev is probably not needed
					// (we may consider this and delete it)
					if ( m_fHardRestore )
						{
						memset(	&pfmp->Pdbfilehdr()->bkinfoFullPrev, 0, sizeof( BKINFO ) );
						}
#endif // BKINFO_DELETE_ON_HARD_RECOVERY

					Call( ErrLGRIPpibFromProcid( plrdetachdb->le_procid, &ppib ) );
					Assert( !pfmp->FReadOnlyAttach() );

					//	make the size matching, but must flush first to prevent following
					//	sequence of events:
					//	- determine we need to extend from x to x+n
					//	- async flush occurs at page x+y, where 1<=y<=n
					//	- zero out pages from x+1 to x+n, thus overwriting async flush of page x+y
					Call( ErrBFFlush( ifmp ) );
					Call( ErrBFFlush( ifmp | ifmpSLV ) );

					Call( ErrLGICheckDatabaseFileSize( pfsapi, ppib, ifmp ) );

					//	If there is no redo operations on an attached db, then
					//	pfmp->dbtimeCurrent may == 0, then do not change pdbfilehdr->dbtime

					if ( pfmp->DbtimeCurrentDuringRecovery() > pfmp->DbtimeLast() )
						{
						pfmp->SetDbtimeLast( pfmp->DbtimeCurrentDuringRecovery() );
						}

					Call( ErrIsamDetachDatabase( (JET_SESID) ppib, NULL, pfmp->SzDatabaseName(), plrdetachdb->Flags() ) );
					}
				else
					{
					Assert( pfmp->FInUse() );
					if ( pfmp->FInUse() )
						{
						//	SLV name/root, if any, is allocated in same space as db name
						OSMemoryHeapFree( pfmp->SzDatabaseName() );
						pfmp->SetSzDatabaseName( NULL );
						pfmp->SetSzSLVName( NULL );
						pfmp->SetSzSLVRoot( NULL );
						}
					else
						{
						Assert( NULL == pfmp->SzSLVName() );
						}

					pfmp->ResetFlags();
					pfmp->Pinst()->m_mpdbidifmp[ pfmp->Dbid() ] = ifmpMax;
					}

				//	verify skipped/deferred attachment is removed
				Assert( !pfmp->FSkippedAttach() );
				Assert( !pfmp->FDeferredAttach() );

				if ( pfmp->Patchchk() )
					{
					OSMemoryHeapFree( pfmp->Patchchk() );
					pfmp->SetPatchchk( NULL );
					}

				if ( pfmp->PatchchkRestored() )
					{
					OSMemoryHeapFree( pfmp->PatchchkRestored() );
					pfmp->SetPatchchkRestored( NULL );
					}

				LGRITraceRedo(plr);
				}
				break;

			case lrtypExtRestore:
				// for tracing only, should be at a new log generation 
				break;

	   		/****************************************************/
	   		/*	Operations Using ppib (procid)                  */
	   		/****************************************************/
	            
			default:
				Call( ErrLGRIRedoOperation( plr ) );
				} /* switch */
			} /* outer default */
		} /* outer switch */

#ifdef DEBUG
		m_fDBGNoLog = fFalse;
#endif
		fLastLRIsQuit = fFalse;

		/*	update sector status, if we moved to a new sector
		/**/
		Assert( !fShowSectorStatus || m_lgposRedo.isec >= plgstat->cSectorsSoFar );
		Assert( m_lgposRedo.isec != 0 );
		if ( fShowSectorStatus && m_lgposRedo.isec > plgstat->cSectorsSoFar )
			{
			ULONG		cPercentSoFar;
			JET_SNPROG	*psnprog = &(plgstat->snprog);

			Assert( plgstat->pfnStatus );
			
			plgstat->cSectorsSoFar = m_lgposRedo.isec;
			cPercentSoFar = (ULONG)((100 * plgstat->cGensSoFar) / plgstat->cGensExpected);
			
			cPercentSoFar += (ULONG)((plgstat->cSectorsSoFar * 100) /
				(plgstat->cSectorsExpected * plgstat->cGensExpected));

			Assert( cPercentSoFar <= 100 );

			/*	because of rounding, we might think that we finished
			/*	the generation when we really have not, so comparison
			/*	is <= instead of <.
			/**/
			Assert( cPercentSoFar <= (ULONG)( ( 100 * ( plgstat->cGensSoFar + 1 ) ) / plgstat->cGensExpected ) );

			Assert( cPercentSoFar >= psnprog->cunitDone );
			if ( cPercentSoFar > psnprog->cunitDone )
				{
				psnprog->cunitDone = cPercentSoFar;
				(*plgstat->pfnStatus)( 0, JET_snpRestore, JET_sntProgress, psnprog );
				}
			}
		}
	while ( ( err = ErrLGGetNextRecFF( (BYTE **) &plr ) ) == JET_errSuccess
			|| errLGNoMoreRecords == err );

	//	we have dropped out of the replay loop with an unexpected result
	//	this should be some types of error
	Assert( err < 0 );
	//	dispatch the error
	Call( err );

Done:
	err = errT; //JET_errSuccess;
	
HandleError:
	/*	assert all operations successful for restore from consistent
	/*	backups
	/**/
#ifndef RFS2
	AssertSz( err >= 0,     "Debug Only, Ignore this Assert");
#endif

	// Deallocate LogReader
	if ( pNil != m_plread )
		{
		if ( err == JET_errSuccess )
			{
			err = m_plread->ErrLReaderTerm();
			}
		else
			{
			m_plread->ErrLReaderTerm();
			}
		delete m_plread;
		m_plread = pNil;
		}

	return err;
	}



//	cleanup the current logs/checkpoint and start a new sequence
//
//	if we succeed, we will return wrnCleanedUpMismatchedFiles and the user will be at gen 1
//	if we fail, the user will be forced to delete the remaining logs/checkpoint by hand

ERR LOG::ErrLGRICleanupMismatchedLogFiles( IFileSystemAPI* const pfsapi )
	{
	ERR		err = JET_errSuccess;
	ERR		errT;
	LONG	lGen;
	LONG	lGenLast;
	CHAR	rgchFName[IFileSystemAPI::cchPathMax];
	CHAR	szPath[IFileSystemAPI::cchPathMax];

	//	circular logging must be on so that the user knows hard recovery is definitely impossible

	Assert( m_fLGCircularLogging );

	//	close the current log file (this will prevent any log flushing)

	m_critLGFlush.Enter();
	if ( m_pfapiLog )
		{
		delete m_pfapiLog;
		m_pfapiLog = NULL;
		}

	LGCreateAsynchWaitForCompletion();

	m_critLGFlush.Leave();

	//	find the first and last generations

	CallR( ErrLGIGetGenerationRange( pfsapi, m_szLogCurrent, &lGen, &lGenLast ) );

	//	delete edbxxxx.log
	//	start deleting only if we found something (lGen > 0)
	
	for ( ; lGen > 0 && lGen <= lGenLast; lGen++ )
		{
		LGSzFromLogId( rgchFName, lGen );
		strcpy( szPath, m_szLogCurrent );
		strcat( szPath, rgchFName );
		strcat( szPath, szLogExt );
		errT = pfsapi->ErrFileDelete( szPath );
		if ( errT < JET_errSuccess && JET_errFileNotFound != errT && err >= JET_errSuccess )
			{
			err = errT;
			}
		}

	//	delete edb.log and edbtmp.log

	strcpy( szPath, m_szLogCurrent );
	strcat( szPath, m_szJetLog );
	errT = pfsapi->ErrFileDelete( szPath );
	if ( errT < JET_errSuccess && JET_errFileNotFound != errT && err >= JET_errSuccess )
		{
		err = errT;
		}

	strcpy( szPath, m_szLogCurrent );
	strcat( szPath, m_szJetTmpLog );
	errT = pfsapi->ErrFileDelete( szPath );
	if ( errT < JET_errSuccess && JET_errFileNotFound != errT && err >= JET_errSuccess )
		{
		err = errT;
		}

	//	delete the checkpoint file

	LGFullNameCheckpoint( pfsapi, szPath );
	errT = pfsapi->ErrFileDelete( szPath );
	if ( errT < JET_errSuccess && JET_errFileNotFound != errT && err >= JET_errSuccess )
		{
		err = errT;
		}

	//	this is the end of the file-cleanup -- handle the resulting error, if any

	CallR( err );

	//	create the new log (gen 1) using the new log-file size

	m_csecLGFile = CsecLGIFromSize( m_pinst->m_lLogFileSize );

	//	create a new log and open it (using the new size in lLogFileSize)

	m_critLGFlush.Enter();
	
	err = ErrLGNewLogFile( pfsapi, 0, fLGOldLogNotExists );
	if ( err >= JET_errSuccess )
		{

		//	we successfully created a new log

		//	reset fSignLogSetGlobal because we have a new log signature now (setup by ErrLGNewLogFile)

		m_fSignLogSet = fFalse;

		m_critLGBuf.Enter();
		memcpy( m_plgfilehdr, m_plgfilehdrT, sizeof( LGFILEHDR ) );
		m_isecWrite = m_csecHeader;
		m_critLGBuf.Leave();

		Assert( 1 == m_plgfilehdr->lgfilehdr.le_lGeneration );
		Assert( m_pbLastChecksum == m_pbLGBufMin );
		//Assert( 1 == m_lgposLastChecksum.lGeneration );	//	not set by ErrLGNewLogFile
		
		//	open the new log file

		LGMakeLogName( m_szLogName, (CHAR *)m_szJet );
		err = pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog );

		if ( err >= JET_errSuccess )
			{

			//	read the log file hdr and initialize the log params (including the new log signature)

			Assert( !m_fSignLogSet );
			err = ErrLGReadFileHdr( m_pfapiLog, m_plgfilehdr, fFalse );
#ifdef DEBUG
			if ( err >= JET_errSuccess )
				{
				m_lgposLastLogRec = lgposMin;	//	reset the log position of the last record
				}
#endif	//	DEBUG
			}

		}
	else
		{

		//	failed to create the new log

		//	this is ok because we have consistent databases and no logs/checkpoint
		//	soft recovery will run and create the first log generation

		//	nop
		}
	m_critLGFlush.Leave();
	CallR( err );

	//	return a warning indicating that the old logs/checkpoint have been cleaned up

	return ErrERRCheck( wrnCleanedUpMismatchedFiles );//JET_errSuccess;
	}


ERR LOG::ErrLGDeleteOutOfRangeLogFiles(IFileSystemAPI * const pfsapi)
	{
	ERR err = JET_errSuccess;
	LGFILEHDR * plgfilehdr = NULL;
	const LONG lCurrentGeneration = m_plgfilehdr->lgfilehdr.le_lGeneration;
	
	LONG lgenMin = 0;
	LONG lgenMax = 0;
	LONG igen = 0;

	Assert ( m_fDeleteOutOfRangeLogs );

	CallR ( ErrLGIGetGenerationRange( pfsapi, m_szLogFilePath, &lgenMin, &lgenMax ) );

	if ( lgenMin == 0 )
		{
		Assert ( 0 == lgenMax );
		return JET_errSuccess;
		}

	// if all we have is below current generation we are ok
	if ( lgenMax < lCurrentGeneration )
		{
		return JET_errSuccess;
		}
	
	// start from the next generation above the one we did recovered
	lgenMin = max( lgenMin, lCurrentGeneration + 1);
	lgenMax = max( lgenMax, lCurrentGeneration + 1);

	// we need a buffer to read the log to be deleted header
	// so that we can check that it does match the current signature
	plgfilehdr = (LGFILEHDR *)PvOSMemoryPageAlloc( sizeof(LGFILEHDR), NULL );
	if ( plgfilehdr == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}	

	{
	CHAR szFileFrom[16];
	CHAR szFileTo[16];
	CHAR szGeneration[32];
	const CHAR *rgszT[] = { szGeneration, szFileFrom, szFileTo };
	LGSzFromLogId( szFileFrom, lgenMin );
	LGSzFromLogId( szFileTo, lgenMax );
	sprintf( szGeneration, "%d", lCurrentGeneration);
	UtilReportEvent( eventWarning, LOGGING_RECOVERY_CATEGORY, DELETE_LOG_FILE_TOO_NEW_ID, sizeof(rgszT) / sizeof(rgszT[0]), rgszT );
	}

	for ( igen = lgenMin; igen <= lgenMax; igen++ )
		{
		CHAR szFileT[IFileSystemAPI::cchPathMax];
		CHAR szFullName[IFileSystemAPI::cchPathMax];
		IFileAPI * pfapiT = NULL;

		err = ErrLGRSTOpenLogFile( pfsapi, m_szLogFilePath, igen, &pfapiT );
		if ( JET_errFileNotFound == err )
			{
			continue;
			}
		Call ( err );

		// read and check the log signature
		err = ErrLGReadFileHdr( pfapiT, plgfilehdr, fCheckLogID );
		delete pfapiT;
		pfapiT = NULL;
		Call ( err );

		// we have the file and is with the current signature
		// (checked in ReadFileHdr if fCheckLogID set) 
		// but above the soft-recovery range: delete it !
		LGSzFromLogId( szFileT, igen );
		LGMakeLogName( szFullName, szFileT );
		err = pfsapi->ErrFileDelete( szFullName );
		if ( JET_errFileNotFound == err )
			{
			err = JET_errSuccess;
			}
		Call( err );
		}

	err = JET_errSuccess;

HandleError:
	OSMemoryPageFree( plgfilehdr );

	return err;
	}


//	Redoes database operations in log from lgposRedoFrom to end.
//
//  GLOBAL PARAMETERS
//                      szLogName		(IN)		full path to szJetLog (blank if current)
//                      lgposRedoFrom	(INOUT)		starting/ending lGeneration and ilgsec.
//
//  RETURNS
//                      JET_errSuccess
//						error from called routine
//
ERR LOG::ErrLGRRedo( IFileSystemAPI *const pfsapi, CHECKPOINT *pcheckpoint, LGSTATUSINFO *plgstat )
	{
	ERR		err, errBeforeRedo = JET_errSuccess, errRedo = JET_errSuccess, errAfterRedo = JET_errSuccess;
	PIB		*ppibRedo			= ppibNil;
	LGPOS	lgposRedoFrom;
	INT		fStatus;

	//	set flag to suppress logging
	//
	m_fRecovering = fTrue;
	m_fRecoveringMode = fRecoveringRedo;

	Assert( m_pinst->m_fUseRecoveryLogFileSize == fTrue );

//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//	//	setup the sector-size checking parameters
//
Assert( m_cbSec == m_cbSecVolume );
//	Assert( m_cbSecVolume == ~(ULONG)0 );
//	{
//		CHAR rgchFullName[IFileSystemAPI::cchPathMax];
//	
//		//	get atomic write size
//
//		if ( pfsapi->ErrPathComplete( m_szLogFilePath, rgchFullName ) == JET_errInvalidPath )
//			{
//			const CHAR	*szPathT[1] = { m_szLogFilePath };
//			UtilReportEvent(
//				eventError,
//				LOGGING_RECOVERY_CATEGORY,
//				FILE_NOT_FOUND_ERROR_ID,
//				1, szPathT );
//			return ErrERRCheck( JET_errFileNotFound );
//			}
//
//		CallR( pfsapi->ErrFileAtomicWriteSize( rgchFullName, (DWORD*)&m_cbSecVolume ) );
//	}

	//	open the proper log file
	//
	// lgposRedoFrom is based on the checkpoint, which is based on
	// lgposStart which is based on the beginning of a log
	// record (beginning of a begin-transaction).
	lgposRedoFrom = pcheckpoint->checkpoint.le_lgposCheckpoint;

	Call( ErrLGRIOpenRedoLogFile( pfsapi, &lgposRedoFrom, &fStatus ) );
	Assert( m_pfapiLog );

	//	capture the result of ErrLGRIOpenRedoLogFile; it might have a warning from ErrLGCheckReadLastLogRecordFF
	errBeforeRedo = err;

	if ( fStatus != fRedoLogFile )
		{
		Call( ErrERRCheck( JET_errMissingPreviousLogFile ) );
		}

	Assert( m_fRecoveringMode == fRecoveringRedo );
	Call( ErrLGInitLogBuffers( pcheckpoint->checkpoint.dbms_param.le_lLogBuffers ) );

	// XXX
	// The flush point should actually be after the current record
	// because the semantics of m_lgposToFlush are to point to the log
	// record that has not been flushed to disk.
	m_lgposToFlush = lgposRedoFrom;

	m_logtimeFullBackup = pcheckpoint->checkpoint.logtimeFullBackup;
	m_lgposFullBackup = pcheckpoint->checkpoint.le_lgposFullBackup;
	m_logtimeIncBackup = pcheckpoint->checkpoint.logtimeIncBackup;
	m_lgposIncBackup = pcheckpoint->checkpoint.le_lgposIncBackup;

	//	Check attached db already. No need to check in LGInitSession.
	//
	Call( ErrLGRIInitSession(
				pfsapi,
				&pcheckpoint->checkpoint.dbms_param,
				pcheckpoint->rgbAttach,
				plgstat,
				redoattachmodeInitBeforeRedo ) );
	m_fAfterEndAllSessions = fFalse;
#ifdef UNLIMITED_DB
	m_fNeedInitialDbList = fTrue;
#endif

	Assert( m_pfapiLog );

	err = ErrLGRIRedoOperations(
					pfsapi,
					&pcheckpoint->checkpoint.le_lgposCheckpoint,
					pcheckpoint->rgbAttach,
					plgstat );
	//	remember the error code from ErrLGRIRedoOperations() which may have a corruption warning
	//		from ErrLGCheckReadLastLogRecordFF() which it may eventually call
	errRedo = err;

	//	we should have the right sector size by now or an error that will make redo fail

	Assert( m_plgfilehdr != NULL );
	Assert( m_cbSec == m_plgfilehdr->lgfilehdr.le_cbSec || errRedo < 0 );
	Assert( m_cbSec == m_cbSecVolume || errRedo < 0 );
				
	if ( err < 0 )
		{
		//	Flush as much as possible before bail out

		m_fLogDisabledDueToRecoveryFailure = fTrue;
		for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid ++ )
			{
			if ( m_pinst->m_mpdbidifmp[ dbid ] < ifmpMax )
				{
				(VOID)ErrBFFlush( m_pinst->m_mpdbidifmp[ dbid ] );
				(VOID)ErrBFFlush( m_pinst->m_mpdbidifmp[ dbid ] | ifmpSLV );
				}
			}
		m_fLogDisabledDueToRecoveryFailure = fFalse;

#ifdef DEBUG
		//	Recovery should never fail unless some hardware problems
		//	or out of memory (mainly with RFS enabled)
		//	NOTE: it can also fail from corruption
		if ( JET_errDiskFull != errRedo &&
			 JET_errOutOfBuffers != errRedo &&
			 JET_errOutOfMemory != errRedo &&
//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//			 JET_errLogSectorSizeMismatch != errRedo &&
//			 JET_errLogSectorSizeMismatchDatabasesConsistent != errRedo &&
			 !FErrIsLogCorruption( errRedo ) )
			{

			//	force the error code to be reported in the assert

			Assert( JET_errSuccess != errRedo );
			CallS( errRedo );
			AssertSz( fFalse, "Unexpected recovery failure" );
			}
#endif	//	DEBUG

		if ( !m_fAfterEndAllSessions )
			{
			CallR( ErrLGRIEndAllSessionsWithError() );
			}

		Assert( m_ptablehfhash == NULL );
		}
	else
		{	
		//	Check lGenMaxRequired before any UNDO operations
		
		for ( DBID dbidT = dbidUserLeast; dbidT < dbidMax; dbidT++ )
			{
			const IFMP	ifmp	= m_pinst->m_mpdbidifmp[ dbidT ];

			if ( ifmp >= ifmpMax )
				continue;

			FMP 		*pfmpT			= &rgfmp[ ifmp ];

			Assert( !pfmpT->FReadOnlyAttach() );
			if ( pfmpT->FSkippedAttach()
				|| pfmpT->FDeferredAttach() )
				{
				//	skipped attachments is a restore-only concept
				Assert( !pfmpT->FSkippedAttach() || m_fHardRestore );
				continue;
				}

			DBFILEHDR_FIX *pdbfilehdr	= pfmpT->Pdbfilehdr();
			Assert( pdbfilehdr );

			LONG lGenMaxRequired = pdbfilehdr->le_lGenMaxRequired;
			LONG lGenCurrent = m_plgfilehdr->lgfilehdr.le_lGeneration;
			
			if ( lGenMaxRequired > lGenCurrent )
				{	
				LONG lGenMinRequired = pfmpT->Pdbfilehdr()->le_lGenMinRequired;
				CHAR szT1[16];
				CHAR szT2[16];
				CHAR szT3[16];	
				const UINT	csz = 4;
				const CHAR *rgszT[csz];

				rgszT[0] = pfmpT->SzDatabaseName();
				sprintf( szT1, "%d", lGenMinRequired );
				rgszT[1] = szT1;
				sprintf( szT2, "%d", lGenMaxRequired );
				rgszT[2] = szT2;
				sprintf( szT3, "%d", lGenCurrent );
				rgszT[3] = szT3;
		
				UtilReportEvent(	
							eventError,
							LOGGING_RECOVERY_CATEGORY,
							REDO_MISSING_HIGH_LOG_ERROR_ID,
							sizeof( rgszT ) / sizeof( rgszT[ 0 ] ),
							rgszT,
							0,
							NULL,
							m_pinst );

				//	Flush as much as possible before bail out

				m_fLogDisabledDueToRecoveryFailure = fTrue;
				for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid ++ )
					{
					if ( m_pinst->m_mpdbidifmp[ dbid ] < ifmpMax )
						{
						(VOID)ErrBFFlush( m_pinst->m_mpdbidifmp[ dbid ] );
						(VOID)ErrBFFlush( m_pinst->m_mpdbidifmp[ dbid ] | ifmpSLV );
						}
					}
				m_fLogDisabledDueToRecoveryFailure = fFalse;

				if ( !m_fAfterEndAllSessions )
					{
					CallS( ErrLGRIEndAllSessionsWithError() );
					}

				return ErrERRCheck( JET_errRequiredLogFilesMissing );
				}
			}

#ifdef DEBUG
		m_fDBGNoLog = fFalse;
#endif

		//	set checkpoint before any logging activity
		//
		m_pcheckpoint->checkpoint.le_lgposCheckpoint = pcheckpoint->checkpoint.le_lgposCheckpoint;

		BOOL fDummy;
		// Setup log buffers to have end of the current log file.
		Call( ErrLGCheckReadLastLogRecordFF( pfsapi, &fDummy ) );
		CallS( err );

		// not we will clean-up the not matching log files if the users needs this
		// (this is a feature that allows snapshot backup restores w/o cleaning the
		// existing log files before restore)
		if ( !m_fHardRestore && m_fDeleteOutOfRangeLogs )
			{
			Call ( ErrLGDeleteOutOfRangeLogFiles( pfsapi ) );
			}

		//	capture the result of this operation
		errAfterRedo = err;

		// switch from a finished log file to a new one if necessary
#ifdef UNLIMITED_DB		
		const BOOL	fLGFlags	= fLGLogAttachments;
#else		
		const BOOL	fLGFlags	= 0;
#endif		
		Call( ErrLGISwitchToNewLogFile( pfsapi, fLGFlags ) );

		// allow flush thread to do flushing now.
		m_critLGFlush.Enter();
		m_critLGBuf.Enter();
		m_fNewLogRecordAdded = fTrue;
		m_critLGBuf.Leave();
		m_critLGFlush.Leave();

		/*  close and reopen log file in R/W mode
		/**/
		m_critLGFlush.Enter();
		delete m_pfapiLog;
		m_pfapiLog = NULL;
		err = pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog );
		m_critLGFlush.Leave();
		Call( err );

		//  switch to undo mode

		m_fRecoveringMode = fRecoveringUndo;

//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//		if ( m_cbSec != m_cbSecVolume )
//			{
//			if ( m_fLastLRIsShutdown || m_fAfterEndAllSessions )
//				{
//				Call( ErrERRCheck( JET_errLogSectorSizeMismatchDatabasesConsistent ) );
//				}
//			else
//				{
//				Call( ErrERRCheck( JET_errLogSectorSizeMismatch ) );
//				}
//			}

		Assert( !m_fAfterEndAllSessions || !m_fLastLRIsShutdown );
		if ( !m_fAfterEndAllSessions )
			{
			//	DbList must have been loaded bb now
			//	UNDONE: Is it possible to have the
			//	RcvUndo as the first log record in
			//	a log file (eg. crash after creating
			//	log file, but before anything but
			//	the header can be flushed?)
			Enforce( !m_fNeedInitialDbList );

			if ( !m_fLastLRIsShutdown )
				{
				//	write a RecoveryUndo record to indicate start to undo
				//	this corresponds to the RecoveryQuit record that
				//	will be written out in LGRIEndAllSessions()
				CallR( ErrLGRecoveryUndo( this ) );
				m_lgposRecoveryUndo = m_lgposLogRec;
				}

			Call( ErrLGRIEndAllSessions(
						pfsapi,
						fTrue,
						&pcheckpoint->checkpoint.le_lgposCheckpoint,
						pcheckpoint->rgbAttach ) );
			m_fAfterEndAllSessions = fTrue;

#ifdef DEBUG
			m_lgposRedoShutDownMarkGlobal = lgposMin;
#endif
			}
		//	At the end of hard recovery we have to regenerate the
		//	checkpoint file even if we had a clean shutdown in the logs
		//	Ignore any error, because in the worst case, we just end
		//	up rescanning all the log files only to find out nothing
		//	needs to be redone.
		else if ( m_fHardRestore )
			{
			/*      enable checkpoint updates */
			m_fLGFMPLoaded = fTrue;
			(VOID)ErrLGUpdateCheckpointFile( pfsapi, fFalse );
			/*      stop checkpoint updates */
			m_fLGFMPLoaded = fFalse;
            }
		
		Assert( m_pfapiLog );

		// ensure that everything hits the disk
		Call( ErrLGWaitAllFlushed( pfsapi ) );

		//	check the current generation

		Assert( lGenerationMax < lGenerationMaxDuringRecovery );
		if ( m_plgfilehdr->lgfilehdr.le_lGeneration >= lGenerationMax )
			{

			//	the current generation is beyond the last acceptable non-recovery generation
			//		(e.g. we have moved into the reserved generations which are between 
			//		 lGenerationMax and lGenerationMaxDuringRecovery)

			Assert( m_plgfilehdr->lgfilehdr.le_lGeneration <= lGenerationMaxDuringRecovery );

			//	do not allow any more generations -- user must wipe logs and restart at generation 1

			Call( ErrERRCheck( JET_errLogSequenceEndDatabasesConsistent ) );
			}
		}

HandleError:
	//	we are no longer using the recovery logfile size

	m_pinst->m_fUseRecoveryLogFileSize = fFalse;

	//	set flag to suppress logging
	//
	m_fRecovering = fFalse;
	m_fRecoveringMode = fRecoveringNone;

	//	there are 4 errors to consolidate here: err, errBeforeRedo, errRedo, errAfterRedo
	//	precedence is as follows: (most) err, errBeforeRedo, errRedo, errAfterRedo (least)

	if ( err == JET_errSuccess )
		{
		if ( errBeforeRedo == JET_errSuccess )
			{
			if ( errRedo == JET_errSuccess )
				err = errAfterRedo;
			else
				err = errRedo;
			}
		else
			err = errBeforeRedo;
		}


	if ( err >= JET_errSuccess )
		{
		//	verify the log sector size

		Assert( m_plgfilehdr != NULL );
		Assert( m_cbSec == m_plgfilehdr->lgfilehdr.le_cbSec );
		Assert( m_cbSec == m_cbSecVolume || err < 0 );

		//	verify the log file size

		const LONG lLogFileSizeHeader = LONG( ( QWORD( m_plgfilehdr->lgfilehdr.le_csecLGFile ) * 
								   			  m_plgfilehdr->lgfilehdr.le_cbSec ) / 1024 );

		if ( !m_pinst->m_fSetLogFileSize )
			{

			//	the user never set the log file size, so we will set it on their behalf

			m_pinst->m_fSetLogFileSize = fTrue;
			m_pinst->m_lLogFileSize = lLogFileSizeHeader;
			Assert( m_csecLGFile == m_plgfilehdr->lgfilehdr.le_csecLGFile );
			Assert( m_cbSec == m_plgfilehdr->lgfilehdr.le_cbSec );
			Assert( m_csecHeader == sizeof( LGFILEHDR ) / m_cbSec );
			}

		//	the user chose a specific log file size, so we must enforce it

		else if ( m_pinst->m_lLogFileSize != lLogFileSizeHeader )
			{

			//	the logfile size doesn't match

			if ( !m_pinst->m_fCleanupMismatchedLogFiles )
				{

				//	we are not allowed to cleanup the mismatched logfiles

				Error( ErrERRCheck( JET_errLogFileSizeMismatchDatabasesConsistent ), ReturnError );
				}

			//	we can cleanup the old logs/checkpoint and start a new sequence
			//
			//	if we succeed, we will return wrnCleanedUpMismatchedFiles and the user will be at gen 1
			//	if we fail, the user will be forced to delete the remaining logs/checkpoint by hand

			CallJ( ErrLGRICleanupMismatchedLogFiles( pfsapi ), ReturnError );

			//	we should have gotten this warning after successfully cleaning up the logs/checkpoint

			Assert( wrnCleanedUpMismatchedFiles == err );
			}
		}

ReturnError:

	Assert( !m_pinst->m_fUseRecoveryLogFileSize );

	return err;
	}

#ifdef ESENT

struct DBINFO {
	char * szLogfilePath;
	char * szSystemPath;
	char * szBaseName;
};

const char 	szUser[]		= "user";
const char	szPassword[]	= "";

const char	szJetInit[]		= "JetInit@4";
const char	szJetTerm2[]	= "JetTerm2@8";
const char	szJetSetSystemParameter[] = "JetSetSystemParameter@20";

typedef JET_ERR (__stdcall FNJETINIT)( JET_INSTANCE *pinstance );               
typedef JET_ERR (__stdcall FNJETTERM2)( JET_INSTANCE instance, JET_GRBIT grbit );
typedef JET_ERR (__stdcall FNJETSETSYSTEMPARAMETER)(                          
                                        JET_INSTANCE *pinstance,              
                                        JET_SESID sesid,                      
                                        unsigned long paramid,                
                                        unsigned long lParam,                 
                                        const char *sz );                      
                                                                              
typedef FNJETINIT *PFNJETINIT;                                                
typedef FNJETTERM2 *PFNJETTERM2;                                              
typedef FNJETSETSYSTEMPARAMETER *PFNJETSETSYSTEMPARAMETER;                    

//  ================================================================
JET_ERR ErrLGRecoverUsingDifferentDLL(
	const DBINFO * const rgdbinfo,
	const int cdbinfo,
	const char * const szLibrary,
	const CPRINTF * pfnprintf )
//  ================================================================
	{
	JET_ERR 		err;
	JET_ERR 		errT;
	JET_INSTANCE 	instance = 0;
	LIBRARY 		library = 0;

	if( !FUtilLoadLibrary( szLibrary, &library, fGlobalEseutil ) )
		{
		const CHAR *rgszT[1];
		rgszT[0] = szLibrary;
		UtilReportEvent( eventError, GENERAL_CATEGORY, FILE_NOT_FOUND_ERROR_ID, 1, rgszT );
		Call( ErrERRCheck( JET_errCallbackNotResolved ) );
		}
	
	PFNJETINIT					pfnjetinit;
	PFNJETTERM2					pfnjetterm2;
	PFNJETSETSYSTEMPARAMETER	pfnjetsetsystemparameter;

	if( NULL == ( pfnjetinit = (PFNJETINIT)PfnUtilGetProcAddress( library, szJetInit ) ) )
		{
		const CHAR *rgszT[2];
		rgszT[0] = szJetInit;
		rgszT[1] = szLibrary;
		UtilReportEvent( eventError, GENERAL_CATEGORY, FUNCTION_NOT_FOUND_ERROR_ID, 2, rgszT );		
		Call( ErrERRCheck( JET_errCallbackNotResolved ) );
		}

	if( NULL == ( pfnjetterm2 = (PFNJETTERM2)PfnUtilGetProcAddress( library, szJetTerm2 ) ) )
		{
		const CHAR *rgszT[2];
		rgszT[0] = szJetTerm2;
		rgszT[1] = szLibrary;
		UtilReportEvent( eventError, GENERAL_CATEGORY, FUNCTION_NOT_FOUND_ERROR_ID, 2, rgszT );		
		Call( ErrERRCheck( JET_errCallbackNotResolved ) );
		}

	if( NULL == ( pfnjetsetsystemparameter = (PFNJETSETSYSTEMPARAMETER)PfnUtilGetProcAddress( library, szJetSetSystemParameter ) ) )
		{
		const CHAR *rgszT[2];
		rgszT[0] = szJetSetSystemParameter;
		rgszT[1] = szLibrary;
		UtilReportEvent( eventError, GENERAL_CATEGORY, FUNCTION_NOT_FOUND_ERROR_ID, 2, rgszT );		
		Call( ErrERRCheck( JET_errCallbackNotResolved ) );
		}

	int idbinfo;
	for( idbinfo = 0; idbinfo < cdbinfo; idbinfo++ )
		{
		(*pfnprintf)( "Recovering using %s (LogfilePath: %s, SystemPath: %s)\r\n",
					szLibrary,
					rgdbinfo[idbinfo].szLogfilePath,
					rgdbinfo[idbinfo].szSystemPath );

		Call( (*pfnjetsetsystemparameter)( &instance, 0, JET_paramDatabasePageSize, g_cbPage, NULL ) );
		Call( (*pfnjetsetsystemparameter)( &instance, 0, JET_paramRecovery, 0, "on" ) );
		Call( (*pfnjetsetsystemparameter)( &instance, 0, JET_paramLogFilePath, 0, rgdbinfo[idbinfo].szLogfilePath ) );
		Call( (*pfnjetsetsystemparameter)( &instance, 0, JET_paramSystemPath, 0, rgdbinfo[idbinfo].szSystemPath ) );
		Call( (*pfnjetsetsystemparameter)( &instance, 0, JET_paramBaseName, 0, rgdbinfo[idbinfo].szBaseName ) );

		err = (*pfnjetinit)( &instance );
		errT = (*pfnjetterm2)( instance, JET_bitTermComplete );
		if( errT >= 0 )
			{
			errT = err;
			}
		Call( err );
		}

HandleError:
	UtilFreeLibrary( library );
	return err;
	}

#endif	//	ESENT


//
//  Soft start tries to start the system from current directory.
//  The database maybe in one of the following state:
//  1) no log files.
//  2) database was shut down normally.
//  3) database was rolled back abruptly.
//  In case 1, a new log file is generated.
//  In case 2, the last log file is opened.
//  In case 3, soft redo is incurred.
//  At the end of the function, it a proper szJetLog must exists.
//
ERR LOG::ErrLGSoftStart( IFileSystemAPI *const pfsapi, BOOL fNewCheckpointFile, BOOL *pfJetLogGeneratedDuringSoftStart )
	{
	ERR					err;
	BOOL				fCloseNormally;
	BOOL				fSoftRecovery = fFalse;
	CHAR				szFNameT[IFileSystemAPI::cchPathMax];
	CHAR				szT[IFileSystemAPI::cchPathMax];
	CHAR   				szPathJetChkLog[IFileSystemAPI::cchPathMax];
	LGFILEHDR			*plgfilehdrCurrent = NULL;
	LGFILEHDR			*plgfilehdrT = NULL;
	CHECKPOINT			*pcheckpointT = NULL;
	LONG				lgenT;
	ULONG				cbSecVolumeSave;
	BOOL				fCreatedReserveLogs = fFalse;
	LONG				lLogBuffersSaved = m_pinst->m_lLogBuffers;

	*pfJetLogGeneratedDuringSoftStart = fFalse;
	m_fAbruptEnd = fFalse;

	//	disable the sector-size checks

	Assert( m_cbSecVolume != ~(ULONG)0 );
	Assert( m_cbSec == m_cbSecVolume );
	cbSecVolumeSave = m_cbSecVolume;
//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//	m_cbSecVolume = ~(ULONG)0;

	//	use the right log file size for recovery

	Assert( m_pinst->m_fUseRecoveryLogFileSize == fFalse );
	m_pinst->m_fUseRecoveryLogFileSize = fTrue;

	//	set m_szLogCurrent
	//
	m_szLogCurrent = m_szLogFilePath;

	//	If the m_fDeleteOldLogs set, then check if it is consistent.
	//	If so, then delete the logs and continue as no log exists before.
	if ( m_fDeleteOldLogs )
		{
		Assert( !m_pfapiLog );
		
		if ( ( err = ErrLGOpenJetLog( pfsapi ) ) == JET_errSuccess )
			{
			err = ErrLGReadFileHdr( m_pfapiLog, m_plgfilehdr, fCheckLogID );
			delete m_pfapiLog;
			m_pfapiLog = NULL;
			}

		if ( err == JET_errBadLogVersion )
			{
#ifdef ESENT
#ifndef _WIN64	//	no upgrade path from 32-bit to 64-bit

			const char * const szOldDLL = "ESENT97.DLL";
			
			DBINFO dbinfo;
			dbinfo.szLogfilePath 	= m_szLogFilePath;;
			dbinfo.szSystemPath		= m_pinst->m_szSystemPath;
			dbinfo.szBaseName		= m_pinst->m_plog->m_szBaseName;

#ifdef DEBUG
			Call( ErrLGRecoverUsingDifferentDLL( &dbinfo, 1, szOldDLL, CPRINTFSTDOUT::PcprintfInstance() ) );		
#else
			Call( ErrLGRecoverUsingDifferentDLL( &dbinfo, 1, szOldDLL, CPRINTFNULL::PcprintfInstance() ) );		
#endif

#endif	//	!_WIN64
#endif	//	ESENT
			
			//	Delete all the logs

			LONG lGen, lGenLast;
			CHAR rgchFName[IFileSystemAPI::cchPathMax];
			CHAR szPath[IFileSystemAPI::cchPathMax];
			
			(void) ErrLGIGetGenerationRange( pfsapi, m_szLogCurrent, &lGen, &lGenLast );

			//	Delete jetxxxx.log

			// start deleting only if we found something (lGen > 0)
			for ( ; lGen > 0 && lGen <= lGenLast; lGen++ )
				{
				LGSzFromLogId( rgchFName, lGen );
				strcpy( szPath, m_szLogCurrent );
				strcat( szPath, rgchFName );
				strcat( szPath, szLogExt );
				(VOID)pfsapi->ErrFileDelete( szPath );
				}

			//	Delete jet.log, jettemp.log
			
			strcpy( szPath, m_szLogCurrent );
			strcat( szPath, m_szJetLog );
			(VOID)pfsapi->ErrFileDelete( szPath );

			strcpy( szPath, m_szLogCurrent );
			strcat( szPath, m_szJetTmpLog );
			(VOID)pfsapi->ErrFileDelete( szPath );
			}

		}
		
	//	CONSIDER: for tight check, we may check if all log files are
	//	CONSIDER: continuous by checking the generation number and
	//	CONSIDER: previous gen's creatiion date.

	//	try to open current log file to decide the status of log files.
	//
	err = ErrLGOpenJetLog( pfsapi );
	if ( err < 0 )
		{
		if ( JET_errFileNotFound != err )
			{

			//	we were unable to open edb.log or edbtmp.log
			//	also, the error doesn't reveal whether or not edb.log and edbtmp.log even exist
			//	we'll treat the error as a critical failure during file-open -- we can not proceed with recovery

			goto HandleError;
			}

		//	neither szJetLog nor szJetTmpLog exist. If no old generation
		//	files exists, gen a new logfile at generation 1.
		//
		CallR ( ErrLGIGetGenerationRange( pfsapi, m_szLogCurrent, NULL, &lgenT ) );
		if ( lgenT != 0 )
			{
			if ( !m_fReplayingReplicatedLogFiles )
				{
				//	if edbxxxxx.log exist but no edb.log, return error.
				//
				LGReportError( LOG_OPEN_FILE_ERROR_ID, JET_errFileNotFound );
				return ErrERRCheck( JET_errMissingLogFile );
				}

			//	Open the last generation and replay the logs

			LGSzFromLogId( szFNameT, lgenT );
			LGMakeLogName( m_szLogName, szFNameT );
			err = pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog );
			if ( err < 0 )
				{
				LGReportError( LOG_OPEN_FILE_ERROR_ID, err );
				goto HandleError;
				}
			goto CheckLogs;
			}
		else if ( fGlobalEseutil )
			{
			//	if running from ESEUTIL, never create new log stream
			LGReportError( LOG_OPEN_FILE_ERROR_ID, JET_errFileNotFound );
			return ErrERRCheck( JET_errMissingLogFile );
			}

		//	Delete the leftover checkpoint file before creating new gen 1 log file
		
		LGFullNameCheckpoint( pfsapi, szPathJetChkLog );
		(VOID)pfsapi->ErrFileDelete( szPathJetChkLog );

		//	use the right log file size for generating the new log file

		m_pinst->m_fUseRecoveryLogFileSize = fFalse;

		//	restore the volume sector size for creating the new log file

//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//		Assert( m_cbSecVolume == ~(ULONG)0 );
		m_cbSecVolume = cbSecVolumeSave;
		m_cbSec = m_cbSecVolume;
		m_csecHeader = sizeof( LGFILEHDR ) / m_cbSec;
		m_csecLGFile = CsecLGIFromSize( m_pinst->m_lLogFileSize );

		//	NOTE: no need to force the log buffer size here -- we won't be recovering, and
		//		  we won't fill up the current buffer (filling up the buffer is a problem
		//		  because there could be more than 2 active logs in it if it were too large)

		m_critLGFlush.Enter();
		
		if ( ( err = ErrLGNewLogFile( pfsapi, 0, fLGOldLogNotExists ) ) < 0 ) // generation 0 + 1 	
			{
			m_critLGFlush.Leave();
			goto HandleError;
			}
		
		m_critLGBuf.Enter();
		UtilMemCpy( m_plgfilehdr, m_plgfilehdrT, sizeof( LGFILEHDR ) );
		m_isecWrite = m_csecHeader;
		m_critLGBuf.Leave();
		
		m_critLGFlush.Leave();

		//	set flag for initialization
		//
		*pfJetLogGeneratedDuringSoftStart = fTrue;

		Assert( m_plgfilehdr->lgfilehdr.le_lGeneration == 1 );

		// XXX
		// Must fix these Assert()'s.
		//Assert( m_pbLastMSFlush == m_pbLGBufMin );
		//Assert( m_lgposLastMSFlush.lGeneration == 1 );
		}
	else
		{
CheckLogs:
		//	read current log file header
		//
		Call( ErrLGReadFileHdr( m_pfapiLog, m_plgfilehdr, fCheckLogID ) );

		//	re-initialize log buffers according to check pt env
		//
		Call( ErrLGInitLogBuffers( m_plgfilehdr->lgfilehdr.dbms_param.le_lLogBuffers ) );

		//	restore the volume sector size for ErrLGCheckReadLastLogRecordFF

		m_cbSecVolume = cbSecVolumeSave;

		//	verify and patch the current log file

		err = ErrLGCheckReadLastLogRecordFF( pfsapi, &fCloseNormally );

//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//		//	reset the volume sector size
//
//		m_cbSecVolume = ~(ULONG)0;

		//	eat errors about corruption -- we will go up to the point of corruption 
		//		and then return the right error in ErrLGRRedo()

		if ( err == JET_errSuccess || FErrIsLogCorruption( err ) )
			{
			err = JET_errSuccess;
			}
		else
			{
			Assert( err < 0 );
			Call( err );
			}

		delete m_pfapiLog;
		m_pfapiLog = NULL;

		//	If the edb.log was not closed normally or the checkpoint file was
		//	missing and new one is created, then do soft recovery.
		 
		if ( !fCloseNormally || fNewCheckpointFile )
			{
			BOOL		fOpenFile = fFalse;

			//	always redo from beginning of a log generation.
			//	This is needed such that the attach info will be matching
			//	the with the with the redo point. Note that the attach info
			//	is not necessarily consistent with the checkpoint.
			//
			if ( plgfilehdrT == NULL )
				{
				plgfilehdrT = (LGFILEHDR *)PvOSMemoryPageAlloc( sizeof(LGFILEHDR), NULL );
				if  ( plgfilehdrT == NULL )
					{
					err = ErrERRCheck( JET_errOutOfMemory );
					goto HandleError;
					}
				}

			if ( pcheckpointT == NULL )
				{
				pcheckpointT = (CHECKPOINT *)PvOSMemoryPageAlloc( sizeof(CHECKPOINT), NULL );
				if  ( pcheckpointT == NULL )
					{
					err = ErrERRCheck( JET_errOutOfMemory );
					goto HandleError;
					}
				}
			
			//  did not terminate normally and need to redo from checkpoint
			//
			LGFullNameCheckpoint( pfsapi, szPathJetChkLog );

			if ( fNewCheckpointFile )
				{
				//	Delete the newly created empty checkpoint file.
				//	Let redo recreate one.
				 
				(VOID)pfsapi->ErrFileDelete( szPathJetChkLog );
				goto DoNotUseCheckpointFile;
				}

			//	if checkpoint could not be read, then revert to redoing
			//	log from first log record in first log generation file.
			//
			err = ErrLGReadCheckpoint( pfsapi, szPathJetChkLog, pcheckpointT, fFalse );
			if ( err >= 0 )
				{
				m_logtimeFullBackup = pcheckpointT->checkpoint.logtimeFullBackup;
				m_lgposFullBackup = pcheckpointT->checkpoint.le_lgposFullBackup;
				m_logtimeIncBackup = pcheckpointT->checkpoint.logtimeIncBackup;
				m_lgposIncBackup = pcheckpointT->checkpoint.le_lgposIncBackup;
				
				if ( (LONG) m_plgfilehdr->lgfilehdr.le_lGeneration == (LONG) pcheckpointT->checkpoint.le_lgposCheckpoint.le_lGeneration )
					{
					err = ErrLGOpenJetLog( pfsapi );
					if ( JET_errFileNotFound == err )
						{
						//	all other errors will be reported in ErrLGOpenJetLog()
						LGReportError( LOG_OPEN_FILE_ERROR_ID, JET_errFileNotFound );
						}
					}
				else
					{
					LGSzFromLogId( szFNameT, pcheckpointT->checkpoint.le_lgposCheckpoint.le_lGeneration );
					strcpy( szT, m_szLogFilePath );
					strcat( szT, szFNameT );
					strcat( szT, szLogExt );
					err = pfsapi->ErrFileOpen( szT, &m_pfapiLog, fTrue );
					if ( err < 0 )
						{
						CHAR s[20];
						const UINT csz = 2;
						const CHAR *rgsz[csz];
						_itoa( err, s, 10 );
						rgsz[0] = szT;
						rgsz[1] = s;
						UtilReportEvent( 
							eventError, 
							LOGGING_RECOVERY_CATEGORY, 
							LOG_OPEN_FILE_ERROR_ID, 
							csz, 
							rgsz, 
							0, 
							NULL,
							m_pinst );
						}
					}
				//	read log file header
				//
				if ( err >= 0 )
					{
					fOpenFile = fTrue;
					err = ErrLGReadFileHdr( m_pfapiLog, plgfilehdrT, fCheckLogID );
					if ( err >= 0 )
						{
						plgfilehdrCurrent = plgfilehdrT;
						}
					}

				if ( JET_errFileNotFound == err )
					{
					err = ErrERRCheck( JET_errMissingLogFile );
					}
				}
			else
				{
DoNotUseCheckpointFile:
				(void) ErrLGIGetGenerationRange( pfsapi, m_szLogFilePath, &lgenT, NULL );
				if ( lgenT == 0 )
					{
					plgfilehdrCurrent = m_plgfilehdr;
					err = JET_errSuccess;
					}
				else
					{
					LGSzFromLogId( szFNameT, lgenT );
					strcpy( szT, m_szLogFilePath );
					strcat( szT, szFNameT );
					strcat( szT, szLogExt );
					err = pfsapi->ErrFileOpen( szT, &m_pfapiLog, fTrue );
					//	read log file header
					//
					if ( err >= 0 )
						{
						fOpenFile = fTrue;
						err = ErrLGReadFileHdr( m_pfapiLog, plgfilehdrT, fCheckLogID );
						if ( err >= 0 )
							{
							plgfilehdrCurrent = plgfilehdrT;
							}
						}
					else
						{
						CHAR s[20];
						const UINT csz = 2;
						const CHAR *rgsz[csz];
						_itoa( err, s, 10 );
						rgsz[0] = szT;
						rgsz[1] = s;
						UtilReportEvent( 
							eventError, 
							LOGGING_RECOVERY_CATEGORY, 
							LOG_OPEN_FILE_ERROR_ID, 
							csz, 
							rgsz,
							0,
							NULL,
							m_pinst );
						}
					}
				}

			if ( err >= 0 )
				{
				//	set up checkpoint

				//	Make the checkpoint point to the start of this log generation so that
				//	we replay all attachment related log records.
				pcheckpointT->checkpoint.dbms_param = plgfilehdrCurrent->lgfilehdr.dbms_param;
				pcheckpointT->checkpoint.le_lgposCheckpoint.le_lGeneration = plgfilehdrCurrent->lgfilehdr.le_lGeneration;
				pcheckpointT->checkpoint.le_lgposCheckpoint.le_isec = (WORD) m_csecHeader;
				pcheckpointT->checkpoint.le_lgposCheckpoint.le_ib = 0;
				UtilMemCpy( pcheckpointT->rgbAttach, plgfilehdrCurrent->rgbAttach, cbAttach );
				}
				
			if ( fOpenFile )
				{
				delete m_pfapiLog;
				m_pfapiLog = NULL;
				}

			Call( err );

			//	set log path to current directory
			//
			Assert( m_szLogCurrent == m_szLogFilePath );

			//	create the reserve logs

			Assert( m_pinst->m_fUseRecoveryLogFileSize );
			Assert( CsecLGIFromSize( m_pinst->m_lLogFileSizeDuringRecovery ) == m_csecLGFile );
			Assert( !fCreatedReserveLogs );
			m_critLGResFiles.Enter();
			m_ls = lsNormal;
			err = ErrLGICreateReserveLogFiles( pfsapi, fTrue );
			m_critLGResFiles.Leave();
			Call( err );
			fCreatedReserveLogs = fTrue;

			UtilReportEvent( eventInformation, LOGGING_RECOVERY_CATEGORY, 
				START_REDO_ID, 0, NULL, 0, NULL, m_pinst );
			fSoftRecovery = fTrue;
				
			//	redo from last checkpoint
			//
			m_fAbruptEnd = fFalse;
			m_errGlobalRedoError = JET_errSuccess;
			Call( ErrLGRRedo( pfsapi, pcheckpointT, NULL ) )

			if ( wrnCleanedUpMismatchedFiles == err )
				{

				//	special warning from ErrLGRedo indicating that we cleaned up (deleted) old log files
				//		and the old checkpoint file because the log files had a different size than we 
				//		wanted and the user set JET_paramCleanupMismatchedLogFiles 
				//	after the cleanup, we created edb.log using the new log file size requested by the user
				//	we do all this nonsense because the DS doesn't want to do it themselves

				Assert( m_pinst->m_fCleanupMismatchedLogFiles );

				//	we created a new log file (at the end of ErrLGRRedo)

				*pfJetLogGeneratedDuringSoftStart = fTrue;
				}
			else
				{
				CallS( err );	//	no other warnings expected
				}

			//	we should be using the right log file size now

			Assert( m_pinst->m_fUseRecoveryLogFileSize == fFalse );

			//	sector-size checking should now be on

			Assert( m_cbSecVolume != ~(ULONG)0 );
			Assert( m_cbSec == m_cbSecVolume );

			m_critLGFlush.Enter();
			delete m_pfapiLog;
			m_pfapiLog = NULL;
			m_critLGFlush.Leave();

			if ( fGlobalRepair && m_errGlobalRedoError != JET_errSuccess )
				{
				Call( ErrERRCheck( JET_errRecoveredWithErrors ) );
				}

			UtilReportEvent( eventInformation, LOGGING_RECOVERY_CATEGORY, 
				STOP_REDO_ID, 0, NULL, 0, NULL, m_pinst );
			}
		else
			{

			//	we did not need to run recovery

			//	do not use the recovery log file size anymore

			m_pinst->m_fUseRecoveryLogFileSize = fFalse;

			//	restore the volume sector size

//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//			Assert( m_cbSecVolume == ~(ULONG)0 );
			m_cbSecVolume = cbSecVolumeSave;
			m_cbSec = m_cbSecVolume;
			m_csecHeader = sizeof( LGFILEHDR ) / m_cbSec;

			//	setup the log file size

			if ( !m_pinst->m_fSetLogFileSize )
				{

				//	the user never specified a log-file size, but edb.log exists
				//	set it to the size of edb.log on the user's behalf

				m_pinst->m_fSetLogFileSize = fTrue;
				Assert( 0 != m_pinst->m_lLogFileSizeDuringRecovery );
				m_pinst->m_lLogFileSize = m_pinst->m_lLogFileSizeDuringRecovery;
				}

			//	the user chose a specific log file size, so we must enforce it

			else if ( m_pinst->m_lLogFileSize != m_pinst->m_lLogFileSizeDuringRecovery )
				{

				//	the logfile size doesn't match

				if ( !m_pinst->m_fCleanupMismatchedLogFiles )
					{

					//	we are not allowed to cleanup the mismatched logfiles

					Error( ErrERRCheck( JET_errLogFileSizeMismatchDatabasesConsistent ), HandleError );
					}

				//	we can cleanup the old logs/checkpoint and start a new sequence
				//
				//	if we succeed, we will return wrnCleanedUpMismatchedFiles and the user will be at gen 1
				//	if we fail, the user will be forced to delete the remaining logs/checkpoint by hand

				Call( ErrLGRICleanupMismatchedLogFiles( pfsapi ) );

				//	we should have gotten this warning after successfully cleaning up the logs/checkpoint

				Assert( wrnCleanedUpMismatchedFiles == err );

				//	we created a new log file, so we should clean it up if we fail 
				//	(leaves us with an empty log set which is ok because we are 100% recovered)

				*pfJetLogGeneratedDuringSoftStart = fTrue;

				//	close the log file (code below expects it to be closed)

				m_critLGFlush.Enter();
				delete m_pfapiLog;
				m_pfapiLog = NULL;
				m_critLGFlush.Leave();
				}

			//	extract the size of the log in sectors (some codepaths don't set this, so we should do it now)

			m_csecLGFile = CsecLGIFromSize( m_pinst->m_lLogFileSize );
			}
		}

	//	we should now be using the right log file size

	Assert( m_pinst->m_fUseRecoveryLogFileSize == fFalse );

	//	sector-size checking should now be on

	Assert( m_cbSecVolume != ~(ULONG)0 );
	Assert( m_cbSec == m_cbSecVolume );

	if ( !fCreatedReserveLogs )
		{

		//	create the reserve logs

		Assert( m_szLogCurrent == m_szLogFilePath );
		m_critLGResFiles.Enter();
		m_ls = lsNormal;
		err = ErrLGICreateReserveLogFiles( pfsapi, fTrue );
		m_critLGResFiles.Leave();
		Call( err );
		fCreatedReserveLogs = fTrue;
		}

	//	at this point, we have a szJetLog file, reopen the log files
	//
	m_fAbruptEnd = fFalse;

	//	disabled flushing while we reinit the log buffers and check the last log file

	m_critLGFlush.Enter();
	m_critLGBuf.Enter();
	m_fNewLogRecordAdded = fFalse;
	m_critLGBuf.Leave();
	m_critLGFlush.Leave();

	//	re-initialize the buffer manager with user settings
	//
#ifdef AFOXMAN_FIX_148537

	//	NOTE: we MUST force the number of log buffers <= log file size
	//		  due to issues with the log buffer holding more than 2 log files

	Assert( m_csecLGFile == CsecLGIFromSize( m_pinst->m_lLogFileSize ) );

	UINT	csecMin;
	UINT	csecMax;

	Assert( 0 == OSMemoryPageReserveGranularity() % m_cbSec );
	csecMin = OSMemoryPageReserveGranularity() / m_cbSec;
	csecMax = CsecUtilAllocGranularityAlign( m_csecLGFile, m_cbSec );
	if ( csecMax > m_csecLGFile )
		{
		Assert( csecMax >= 2 * ( OSMemoryPageReserveGranularity() / m_cbSec ) );
		Assert( csecMax - ( OSMemoryPageReserveGranularity() / m_cbSec ) <= m_csecLGFile );
		csecMax -= OSMemoryPageReserveGranularity() / m_cbSec;
		}
	Assert( csecMax > 0 );
	Assert( CsecUtilAllocGranularityAlign( csecMax, m_cbSec ) == csecMax );
	Assert( csecMax <= m_csecLGFile );
	Assert( csecMin <= csecMax );

	UINT	csecBuf;

	csecBuf = CsecUtilAllocGranularityAlign( lLogBuffersSaved, m_cbSec );
	if ( csecBuf < csecMin )
		{
		csecBuf = csecMin;
		}
	else if ( csecBuf > csecMax )
		{
		csecBuf = csecMax;
		}
	Assert( csecBuf > 0 );
	Assert( csecBuf <= m_csecLGFile );
	Assert( CsecUtilAllocGranularityAlign( csecBuf, m_cbSec ) == csecBuf );

	m_pinst->m_lLogBuffers = csecBuf;
	Call( ErrLGInitLogBuffers( m_pinst->m_lLogBuffers ) );
#else	//	!AFOXMAN_FIX_148537
	Call( ErrLGInitLogBuffers( lLogBuffersSaved ) );
#endif	//	AFOXMAN_FIX_148537

	//  reopen the log file
	//
	LGMakeLogName( m_szLogName, (CHAR *)m_szJet );
	err = pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog, fTrue );
	if ( err < 0 )
		{
		LGReportError( LOG_OPEN_FILE_ERROR_ID, err );
		goto HandleError;
		}
	err = ErrLGReadFileHdr( m_pfapiLog, m_plgfilehdr, fCheckLogID );
	if ( err == JET_errLogFileSizeMismatch )
		{
		err = ErrERRCheck( JET_errLogFileSizeMismatchDatabasesConsistent );
		}
	else if ( err == JET_errLogSectorSizeMismatch )
		{
//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
Assert( fFalse );
		err = ErrERRCheck( JET_errLogSectorSizeMismatchDatabasesConsistent );
		}
	Call( err );

	//	set up log variables properly

	Call( ErrLGCheckReadLastLogRecordFF( pfsapi, &fCloseNormally ) );
	CallS( err );
	err = ErrLGISwitchToNewLogFile( pfsapi, 0 );
	if ( err == JET_errLogFileSizeMismatch )
		{
		err = ErrERRCheck( JET_errLogFileSizeMismatchDatabasesConsistent );
		}
	else if ( err == JET_errLogSectorSizeMismatch )
		{
//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
Assert( fFalse );
		err = ErrERRCheck( JET_errLogSectorSizeMismatchDatabasesConsistent );
		}
	else if ( err == JET_errLogSequenceEnd )
		{
		err = ErrERRCheck( JET_errLogSequenceEndDatabasesConsistent );
		}
	Call( err );
	if ( !fCloseNormally && !(*pfJetLogGeneratedDuringSoftStart ) )
		{
		Assert( fCloseNormally );
		//	Unknown reason to fail to open for logging, most likely
		//	the file got locked.
		Call( ErrERRCheck( JET_errLogWriteFail ) );
		}

	//	check for log-sequence-end

	if ( m_fLogSequenceEnd )
		{
		Assert( m_plgfilehdr->lgfilehdr.le_lGeneration >= lGenerationMax );
		Error( ErrERRCheck( JET_errLogSequenceEndDatabasesConsistent ), HandleError );
		}
	else
		{
		Assert( m_plgfilehdr->lgfilehdr.le_lGeneration < lGenerationMax );
		}

	delete m_pfapiLog;
	m_pfapiLog = NULL;
	err = pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog );
	if ( err < 0 )
		{
		LGReportError( LOG_OPEN_FILE_ERROR_ID, err );
		goto HandleError;
		}

	//	should be set properly
	//
	Assert( m_isecWrite != 0 );

	//  m_pbEntry and m_pbWrite were set for next record in LocateLastLogRecord
	//
	Assert( m_pbWrite == PbSecAligned(m_pbWrite) );
	Assert( m_pbWrite <= m_pbEntry );
	Assert( m_pbEntry <= m_pbWrite + m_cbSec );

#ifdef	AFOXMAN_FIX_148537

	//	verify that the log buffer size <= log file size

	Assert( m_csecLGBuf <= m_csecLGFile );

#else	//	!AFOXMAN_FIX_148537
#endif	//	AFOXMAN_FIX_148537

	Assert( m_fRecovering == fFalse );
 	Assert( m_fHardRestore == fFalse );

 	m_fNewLogRecordAdded = fTrue;

HandleError:
	if ( err < 0 )
		{
		Assert( m_fHardRestore == fFalse );

		delete m_pfapiLog;
		m_pfapiLog = NULL;

		if ( fSoftRecovery )
			{
			UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, RESTORE_DATABASE_FAIL_ID, err );
			}
		}

	OSMemoryPageFree( plgfilehdrT );

	OSMemoryPageFree( pcheckpointT );

	m_pinst->m_fUseRecoveryLogFileSize = fFalse;
	m_cbSecVolume = cbSecVolumeSave;

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_log\logread.cxx ===
#include "std.hxx"


#if defined( DEBUG ) || !defined( RTM )

//	all cases except !DEBUG && RTM

#ifndef LOGPATCH_UNIT_TEST

//	enabling this generates logpatch.txt
//	it contains trace information for ErrLGCheckReadLastLogRecordFF

#define ENABLE_LOGPATCH_TRACE	

#endif	//	!LOGPATCH_UNIT_TEST
#endif	//	!DEBUG || RTM



VOID LOG::GetLgposOfPbNext(LGPOS *plgpos)
	{
	Assert( m_pbNext != pbNil );
	BYTE	* pb	= PbSecAligned(m_pbNext);
	INT		ib		= ULONG( m_pbNext - pb );
	INT		isec;

	if ( pb > m_pbRead )
		isec = ULONG( m_pbRead + SIZE_T( m_csecLGBuf * m_cbSec ) - pb ) / m_cbSec;
	else
		isec = ULONG( m_pbRead - pb ) / m_cbSec;

	isec = m_isecRead - isec;

	plgpos->isec		= (USHORT)isec;
	plgpos->ib			= (USHORT)ib;
	plgpos->lGeneration	= m_plgfilehdr->lgfilehdr.le_lGeneration;
	}

// Convert pb in log buffer to LGPOS *only* when we're
// actively reading the log file. Do *NOT* use when we're writing
// to the log file.

VOID LOG::GetLgposDuringReading(
	const BYTE * const pb,
	LGPOS * const plgpos
	) const
	{
	Assert( pbNil != pb );
	Assert( pNil != plgpos );
	Assert( pb >= m_pbLGBufMin && pb < m_pbLGBufMax );
	
	const BYTE	* const pbAligned	= PbSecAligned( pb );
	const INT	ib					= ULONG( pb - pbAligned );
	INT			isec;

	// Compute how many sectors from the end of the log buffer we're at.
	// m_pbRead is the end of data in the log buffer.
	// This first case is for wrapping around in the log buffer.
	if ( pbAligned > m_pbRead )
		isec = ULONG( m_pbRead + SIZE_T( m_csecLGBuf * m_cbSec ) - pbAligned ) / m_cbSec;
	else
		isec = ULONG( m_pbRead - pbAligned ) / m_cbSec;

	// m_isecRead is the next sector to pull in from disk.
	isec = m_isecRead - isec;

	plgpos->isec		= (USHORT)isec;
	plgpos->ib			= (USHORT)ib;
	plgpos->lGeneration = m_plgfilehdr->lgfilehdr.le_lGeneration;
	}

#ifdef DEBUG

/* calculate the lgpos of the LR */
void LOG::PrintLgposReadLR ( VOID )
	{
	LGPOS lgpos;

	GetLgposOfPbNext(&lgpos);
	DBGprintf(">%06X,%04X,%04X",
			LONG(m_plgfilehdr->lgfilehdr.le_lGeneration),
			lgpos.isec, lgpos.ib);
	}

#endif

/*  open a generation file on CURRENT directory
/**/
ERR LOG::ErrLGOpenLogGenerationFile(	IFileSystemAPI *const	pfsapi, 
										LONG 						lGeneration, 
										IFileAPI **const 		ppfapi )
	{
	CHAR	szFNameT[IFileSystemAPI::cchPathMax];

	LGSzFromLogId ( szFNameT, lGeneration );
	LGMakeLogName( m_szLogName, szFNameT );

	return pfsapi->ErrFileOpen( m_szLogName, ppfapi, fTrue );
	}


/*  open the redo point log file which must be in current directory.
/**/
ERR LOG::ErrLGRIOpenRedoLogFile( IFileSystemAPI *const pfsapi, LGPOS *plgposRedoFrom, INT *pfStatus )
	{
	ERR		err;
	BOOL	fJetLog = fFalse;

	/*	try to open the redo from file as a normal generation log file
	/**/
	err = ErrLGOpenLogGenerationFile( pfsapi, plgposRedoFrom->lGeneration, &m_pfapiLog );
	if( err < 0 )
		{
		if ( JET_errFileNotFound == err )
			{
			//	gen doesn't exist, so see if redo point is in szJetLog.
			err = ErrLGOpenJetLog( pfsapi );
			if ( err < 0 )
				{
				//	szJetLog is not available either
				if ( JET_errFileNotFound == err )
					{
					//	should be nearly impossible, because we've previously validated
					//	the existence of szJetLog (one possibility may be someone
					//	manually deleted it after we validated it)
					Assert( fFalse );

					//	all other errors will be reported in ErrLGOpenJetLog()
					LGReportError( LOG_OPEN_FILE_ERROR_ID, JET_errFileNotFound );
					}

				*pfStatus = fNoProperLogFile;
				return JET_errSuccess;
				}

			fJetLog = fTrue;
			}
		else
			{
			LGReportError( LOG_OPEN_FILE_ERROR_ID, err );
			return err;
			}
		}

	/*	read the log file header to verify generation number
	/**/
	CallR( ErrLGReadFileHdr( m_pfapiLog, m_plgfilehdr, fCheckLogID ) );

	m_lgposLastRec.isec = 0;
	if ( fJetLog )
		{
		//	scan the log for the end record

		BOOL fCloseNormally;
		err = ErrLGCheckReadLastLogRecordFF( pfsapi, &fCloseNormally );
		if ( err == JET_errSuccess || FErrIsLogCorruption( err ) )
			{
			//	eat errors about corruption
			
			err = JET_errSuccess;
			}
		else
			{
			Assert( err < 0 );
			CallR( err );
			}

		// doesn't matter if we setup log buffer for writing,
		// because it'll get blown away in a moment.
		}

	// XXX
	// At this point, if m_lgposLastRec.isec == 0, that means
	// we want to read all of the log records in the file that
	// we just opened up. If m_lgposLastRec.isec != 0, that means
	// that this is the last log file and we only want to read
	// up to a certain amount.
		
	/*	the following checks are necessary if the szJetLog is opened
	/**/
	if( m_plgfilehdr->lgfilehdr.le_lGeneration == plgposRedoFrom->lGeneration)
		{
		*pfStatus = fRedoLogFile;
		}
	else if ( m_plgfilehdr->lgfilehdr.le_lGeneration == plgposRedoFrom->lGeneration + 1 )
		{
		/*  this file starts next generation, set start position for redo
		/**/
		plgposRedoFrom->lGeneration++;
		plgposRedoFrom->isec = (WORD) m_csecHeader;
		plgposRedoFrom->ib	 = 0;

		*pfStatus = fRedoLogFile;
		}
	else
		{
		/*	log generation gap is found.  Current szJetLog can not be
		/*  continuation of backed up logfile.  Close current logfile
		/*	and return error flag.
		/**/
		delete m_pfapiLog;
		m_pfapiLog = NULL;

		*pfStatus = fNoProperLogFile;
		}

	Assert( err >= 0 );
	return err;
	}

LogReader::LogReader()
	{
	m_plog					= pNil;

	m_fReadSectorBySector	= fFalse;

	m_isecStart				= 0;
	m_csec					= 0;
	m_isec					= 0;
	
	m_csecSavedLGBuf		= 0;
	m_isecCorrupted			= 0;

	m_szLogName[0]			= 0;

#ifdef DEBUG
	m_fLrstateSet			= fFalse;
#endif	//	DEBUG
	}
	
LogReader::~LogReader()
	{
	Assert( pNil == m_plog );
	}

BOOL LogReader::FInit()
	{
	return BOOL( pNil != m_plog );
	}

// Resize the log buffers to requested size, hook up with LOG object

ERR LogReader::ErrLReaderInit( LOG * const plog, UINT csecBufSize )
	{
	ERR err;

	Assert( pNil == m_plog );
	Assert( pNil != plog );
	Assert( csecBufSize > 0 );

	//	setup members

	m_fReadSectorBySector	= fFalse;

	m_isecStart				= 0;
	m_csec					= 0;
	m_isec					= 0;

	m_csecSavedLGBuf		= plog->m_csecLGBuf;
	m_isecCorrupted			= 0;

	m_szLogName[0]			= 0;

	//	allocate log buffers

	CallR( plog->ErrLGInitLogBuffers( csecBufSize ) );

	//	make "none" of log buffer used. Note that it is
	//	an impossible state for every single byte to be
	//	unused, so this work around is needed.

	plog->m_pbWrite			= plog->m_pbLGBufMin;
	plog->m_pbEntry			= plog->m_pbWrite + 1;

	//	the log reader is now initialized

	m_plog					= plog;

	return JET_errSuccess;
	}

// Resize log buffers to original size

ERR LogReader::ErrLReaderTerm()
	{
	ERR err = JET_errSuccess;

	if ( m_plog )
		{

		//	term the log buffers

		err = m_plog->ErrLGInitLogBuffers( m_csecSavedLGBuf );

		//	reset the buffer pointers

		m_plog->m_pbWrite = m_plog->m_pbLGBufMin;
		m_plog->m_pbEntry = m_plog->m_pbWrite + 1;
		}

	//	the log reader is now uninitialized

	m_plog			= pNil;

	m_szLogName[0]	= 0;

	return err;
	}


//	this is like calling Term followed by Init without deallocating and reallocating the log buffers
//	it just resets the internal pointers to invalidate the log buffer data and force a fresh read from disk

VOID LogReader::Reset()
	{
	Assert( FInit() );

	//	invalidate buffers for log-flush code

	m_plog->m_pbWrite = m_plog->m_pbLGBufMin;
	m_plog->m_pbEntry = m_plog->m_pbWrite + 1;

	//	reset state

	m_fReadSectorBySector	= fFalse;

	m_isecStart				= 0;
	m_csec					= 0;
	m_isec					= 0;

	m_isecCorrupted			= 0;
	}


// Make sure that our buffer reflects the current log file.

ERR LogReader::ErrEnsureLogFile()
	{
	Assert( FInit() );

	// ensure that we're going to be giving the user the right log file.

	if ( 0 == UtilCmpFileName( m_plog->m_szLogName, this->m_szLogName ) )
		{
		// yup, got the right file already
		}
	else
		{
		// wrong file
		strcpy( this->m_szLogName, m_plog->m_szLogName );
		// setup so next ErrEnsureSector() will pull in from the right file.
		m_fReadSectorBySector = fFalse;
		m_isecStart = 0;
		m_csec = 0;
		m_isec = 0;
		m_isecCorrupted = 0;
		m_plog->m_pbWrite = m_plog->m_pbLGBufMin;
		m_plog->m_pbEntry = m_plog->m_pbWrite + 1;
#ifdef DEBUG
		m_fLrstateSet = fFalse;
#endif
		}
	return JET_errSuccess;
	}

// Ensure that the data from the log file starting at sector isec for csec
// sectors is in the log buffer (at a minimum). The addr of the data is
// returned in ppb.

ERR LogReader::ErrEnsureSector(
	UINT	isec,
	UINT	csec,
	BYTE**	ppb
	)
	{
	ERR err = JET_errSuccess;

	Assert( FInit() );
	Assert( isec >= m_plog->m_csecHeader );
	Assert( csec > 0 );
	
	// Set this now to pbNil, in case we return an error.
	// We want to know if someone's using *ppb without checking for
	// an error first.
	*ppb = pbNil;

	// We only have it if we have the same log file that the user has open now
	if ( isec >= m_isecStart && isec + csec <= m_isecStart + m_csec )
		{
		// already have it in the buffer.
		*ppb = m_plog->m_pbLGBufMin +
			( m_isec + ( isec - m_isecStart ) ) * m_plog->m_cbSec;
		m_lrstate.m_isec = isec;
		m_lrstate.m_csec = csec;
#ifdef DEBUG
		m_fLrstateSet = fTrue;
#endif
		return JET_errSuccess;
		}

	// If log buffer isn't big enough to fit the sectors user
	// wants, we must enlarge
	if ( m_plog->m_csecLGBuf < csec )
		{
		Call( m_plog->ErrLGInitLogBuffers( csec ) );
		m_plog->m_pbWrite = m_plog->m_pbLGBufMin;
		m_plog->m_pbEntry = m_plog->m_pbWrite + 1;
		}

LReadSectorBySector:

	// read in the data
	if ( m_fReadSectorBySector )
		{
		// we've got 0 sectors stored in the log buffer
		m_csec = 0;
		// the first sector in the buffer is the user requested one.
		m_isecStart = isec;
		// sectors start at beginning of buffer
		m_isec = 0;
		for ( UINT ib = isec * m_plog->m_cbSec;
			m_csec < csec;
			ib += m_plog->m_cbSec, m_csec++ )
			{
			err = m_plog->m_pfapiLog->ErrIORead(	ib, 
													m_plog->m_cbSec, 
													m_plog->m_pbLGBufMin + ( m_csec * m_plog->m_cbSec ) );
			if ( err < 0 )
				{
				if ( 0 != m_isecCorrupted )
					{
					// We found a corrupted sector in the log file. This
					// is unexpected and an error.
					Call( ErrERRCheck( err ) );
					}
				m_isecCorrupted = m_isecStart + m_csec;
				// treat bad sector read as zero filled sector.
				// Hopefully the next sector will be a shadow sector.
				memset( m_plog->m_pbLGBufMin + m_csec * m_plog->m_cbSec, 0,
					m_plog->m_cbSec );
				}
			}
		}
	else
		{
		QWORD	qwSize;
		Call( m_plog->m_pfapiLog->ErrSize( &qwSize ) );
		UINT	csecLeftInFile	= UINT( ( qwSize - ( QWORD( isec ) * m_plog->m_cbSec ) ) / m_plog->m_cbSec );
		// user should never request more than what's in the log file
		Assert( csec <= csecLeftInFile );
		// We don't want to read more than the space we have in the log buffer
		// and not more than what's left in the log file.
		UINT	csecRead		= min( csecLeftInFile, m_plog->m_csecLGBuf );
		// Of the user requested, we'd like to read more, if we have space
		// in the log buffer and if the file has that space.
		csecRead = max( csecRead, csec );

		// if we have an error doing a huge read, try going sector by
		// sector in the case of the corrupted sector that is causing
		// this to give an error.

		//	read the log in 64k chunks to avoid NT quota problems 
		//	(quota issues are most likely due to the number of pages locked down for the read)

		const DWORD	cbReadMax	= 64 * 1024;
		QWORD		ib			= QWORD( isec ) * m_plog->m_cbSec;
		DWORD		cb			= csecRead * m_plog->m_cbSec;
		BYTE		*pb			= m_plog->m_pbLGBufMin;

		while ( cb )
			{

			//	decide how much to read

			const DWORD cbRead = min( cb, cbReadMax );

			//	issue the read (fall back to sector-by-sector reads at the first sign of trouble)

			err = m_plog->m_pfapiLog->ErrIORead( ib, cbRead, pb );
			if ( err < 0 )
				{
				m_fReadSectorBySector = fTrue;
				goto LReadSectorBySector;
				}

			//	update the read counters

			ib += cbRead;
			cb -= cbRead;
			pb += cbRead;

			//	verify that we don't exceed the log buffer

			Assert( ( cb > 0 && pb < m_plog->m_pbLGBufMax ) || ( 0 == cb && pb <= m_plog->m_pbLGBufMax ) );
			}

		// data starts at beginning of log buffer
		m_isec = 0;
		// the first sector is what the user requested
		m_isecStart = isec;
		// this is how many sectors we have in the buffer
		m_csec = csecRead;
		}
		
	m_plog->m_pbWrite = m_plog->m_pbLGBufMin;
	m_plog->m_pbEntry = m_plog->m_pbWrite + m_csec * m_plog->m_cbSec;
	if ( m_plog->m_pbEntry == m_plog->m_pbLGBufMax )
		{
		m_plog->m_pbEntry = m_plog->m_pbLGBufMin;
		}

	// if we get here, we just read in the stuff the user wanted
	// into the beginning of the log file.
	*ppb = m_plog->m_pbLGBufMin;
	m_lrstate.m_isec = isec;
	m_lrstate.m_csec = csec;
#ifdef DEBUG
	m_fLrstateSet = fTrue;
#endif

HandleError:

	return err;
	}

// If a client modified the log file on disk, we want our buffer to reflect that
// change. Copy a modified sector from a user buffer (perhaps the log buffer itself),
// into the log buffer.

VOID LogReader::SectorModified(
	const UINT isec,
	const BYTE* const pb
	)
	{
	Assert( FInit() );
	Assert( isec >= m_plog->m_csecHeader );
	Assert( pbNil != pb );
	
	// If we have the sector in memory, update our in memory copy
	// so that we'll be consistent with what's on the disk.
	if ( isec >= m_isecStart && isec + 1 <= m_isecStart + m_csec )
		{
		BYTE* const	pbDest = m_plog->m_pbLGBufMin + ( m_isec + ( isec - m_isecStart ) ) * m_plog->m_cbSec;
		if ( pbDest != pb )
			{
			UtilMemCpy( pbDest, pb, m_plog->m_cbSec );
			}
		}
	}

BYTE* LogReader::PbGetEndOfData()
	{
	Assert( FInit() );
	BYTE*	pb = m_plog->m_pbLGBufMin + ( m_isec + m_csec ) * m_plog->m_cbSec;
	Assert( pb >= m_plog->m_pbLGBufMin && pb <= m_plog->m_pbLGBufMax );
	return pb;
	}
	
UINT LogReader::IsecGetNextReadSector()
	{
	Assert( FInit() );
	return m_isecStart + m_csec;
	}

ERR
LogReader::ErrSaveState(
	LRSTATE* const plrstate
	) const
	{
	// An internal state must have been reached before
	Assert( m_fLrstateSet );
	Assert( pNil != plrstate );
	*plrstate = m_lrstate;
	return JET_errSuccess;
	}
	
ERR
LogReader::ErrRestoreState(
	const LRSTATE* const plrstate,
	BYTE** const ppb
	)
	{
	// m_lrstate would have had to be set before for us to
	// call restore now
	Assert( m_fLrstateSet );
	Assert( pNil != plrstate );
	return ErrEnsureSector( plrstate->m_isec, plrstate->m_csec, ppb );
	}

//	verifies the supposedly valid LRCHECKSUM record 
//	if there is a short checksum (bUseShortChecksum == bShortChecksumOn),
//		then we verify the whole sector with the short checksum value -- which in turn verifies the 
//		bUseShortChecksum byte
//	if there was not a short checksum, the short checksum value is ignored
//	from this point, other heuristics are employed to see if the pointers in the LRCHECKSUM record look good
//		enough to use
//
//	THIS FUNCTION DOES NOT GUARANTEE ANYTHING ABOUT THE RANGE OF THE LRCHECKSUM RECORD!
//	while it MAY verify the first sector of the range using the short checksum, it does not guarantee the rest
//		of the data
//
//	NOTE: this assumes the entire sector containing the LRCHECKSUM record is in memory

#ifdef DEBUG
LOCAL BOOL g_fLRCKValidationTrap = fFalse;
#endif

BOOL LOG::FValidLRCKRecord(
	// LRCHECKSUM to validate
	const LRCHECKSUM * const plrck,
	// LGPOS of this record
	const LGPOS	* const plgpos
	)
	{
	LGPOS	lgpos;
	QWORD	qwSize = 0;
	ULONG	cbRange = 0;
	ERR		err = JET_errSuccess;
	UINT	ib = 0;
	BOOL	fMultisector = fFalse;
	
	Assert( pNil != plrck );

	//	verify the type as lrtypChecksum
	
	if ( lrtypChecksum != plrck->lrtyp )
		{
		Assert( !g_fLRCKValidationTrap );
		return fFalse;
		}

	//	is the short checksum in use?

	if ( plrck->bUseShortChecksum == bShortChecksumOn )
		{
		
		//	verify the short checksum
	
		if ( !FValidLRCKShortChecksum( plrck, plgpos->lGeneration ) )
			{
			Assert( !g_fLRCKValidationTrap );
			return fFalse;
			}

		//	since there was a short checksum, this must be a multi-sector flush

		fMultisector = fTrue;
		}
	else if ( plrck->bUseShortChecksum == bShortChecksumOff )
		{

		//	this verifies that the bUseShortChecksum byte was set to a known value and stayed that way

		if ( plrck->le_ulShortChecksum != 0 )
			{
			Assert( !g_fLRCKValidationTrap );
			return fFalse;
			}

		//	since there was no short checksum, this must be a single-sector flush
		
		fMultisector = fFalse;
		}
	else
		{

		//	bUseShortChecksum is corrupt

		Assert( !g_fLRCKValidationTrap );
		return fFalse;
		}

	//	the backward range cannot exceed the length of a full sector (minus the size of the LRCHECKSUM record)

	if ( plrck->le_cbBackwards > ( m_cbSec - sizeof( LRCHECKSUM ) ) )
		{
		Assert( !g_fLRCKValidationTrap );
		return fFalse;
		}
		
	//	the backward pointer must land exactly on the start of the sector OR be 0

	const BYTE* const pbRegionStart = reinterpret_cast< const BYTE* >( plrck ) - plrck->le_cbBackwards;
	if ( PbSecAligned( const_cast< BYTE* >( pbRegionStart ) ) != pbRegionStart &&
		0 != plrck->le_cbBackwards )
		{
		Assert( !g_fLRCKValidationTrap );
		return fFalse;
		}

	//	the forward range cannot exceed the length of the file

	lgpos = *plgpos;
	AddLgpos( &lgpos, sizeof( LRCHECKSUM ) + plrck->le_cbForwards );
	Call( m_pfapiLog->ErrSize( &qwSize ) );
	Assert( ( qwSize % (QWORD)m_cbSec ) == 0 );
	if ( ( ( (QWORD)lgpos.isec * (QWORD)m_cbSec ) + (QWORD)lgpos.ib ) > qwSize )
		{
		//	if this assert happens, it means that the short checksum value was tested and came out OK
		//	thus, the sector with data (in which plrck resides) must be OK
		//	however, the forward pointer in plrck stretched beyond the end of the file???
		//	this can happen 1 of 2 ways:
		//		we set it up wrong (most likely)
		//		it was mangled in such a way that it passed the checksum (practically impossible)
		AssertSz( !fMultisector, "We have a verified short checksum value and the forward pointer is still wrong!" );

		Assert( !g_fLRCKValidationTrap );
		return fFalse;
		}

	//	calculate the offset of the LRCHECKSUM record from the nearest sector boundary in memory

	ib = ULONG( reinterpret_cast< const BYTE* >( plrck ) - PbSecAligned( reinterpret_cast< const BYTE* >( plrck ) ) );
	Assert( ib == plgpos->ib );

	//	the backwards pointer in the LRCHECKSUM record must be either equal to ib or 0

	if ( plrck->le_cbBackwards != 0 && plrck->le_cbBackwards != ib )
		{

		//	the backward pointer is wrong

		Assert( !g_fLRCKValidationTrap );
		return fFalse;
		}

	//	calculate the range using the backward pointer instead of 'ib'
	//	NOTE: le_cbBackwards can be 0 here making this range calculation fall short of the real thing; 
	//		  having the range too short doesn't matter here because we only do tests if we see that
	//		  the range is a multi-sector range; nothing happens if we decide that this is a single-sector 
	//		  range (e.g. being too short makes it appear < 1 sector)

	cbRange = plrck->le_cbBackwards + sizeof( LRCHECKSUM ) + plrck->le_cbForwards;
	if ( cbRange > m_cbSec )
		{
		
		//	the range covers multiple sectors

		//	we should have a short checksum if this happens (causing fMultisector == fTrue)

		if ( !fMultisector )
			{
			Assert( !g_fLRCKValidationTrap );
			return fFalse;
			}

		//	also, multi-sector flushes must have a range that is sector-granular so that the forward
		//		pointer goes right up to the end of the last sector in the range
		
		if ( ( cbRange % m_cbSec ) != 0 )
			{

			//	the only way we could get a range that is not sector granular is when the 
			//		backward pointer is 0

			if ( plrck->le_cbBackwards != 0 )
				{

				//	woops -- the backward pointer is not what we expect
				
				Assert( !g_fLRCKValidationTrap );
				return fFalse;
				}
			}
		}


	//	re-test the range using the offset of the plrck pointer's alignment rather than the 
	//		backward pointer because the backward pointer could be 0

	cbRange = ib + sizeof( LRCHECKSUM ) + plrck->le_cbForwards;
	if ( cbRange > m_cbSec )
		{

		//	the range covers multiple sectors

		//	we should have a short checksum if this happens (causing fMultisector == fTrue)

		if ( !fMultisector )
			{
			Assert( !g_fLRCKValidationTrap );
			return fFalse;
			}

		//	also, multi-sector flushes must have a range that is sector-granular so that the forward
		//		pointer goes right up to the end of the last sector in the range
		
		if ( ( cbRange % m_cbSec ) != 0 )
			{

			//	woops, the range is not granular

			Assert( !g_fLRCKValidationTrap );
			return fFalse;
			}
		}
	else
		{

		//	the range is 1 sector or less 

		//	we should have no short checksum if this happens (causing fMultisector == fFalse)

		if ( fMultisector )
			{
			
			//	oops, we have a short checksum on a single-sector range

			Assert( !g_fLRCKValidationTrap );
			return fFalse;
			}
		}


	//	test the next pointer

	if ( plrck->le_cbNext != 0 )
		{

		//	there are other LRCHECKSUM records after this one

		//	the range must be atleast 1 sector long and must land on a sector-granular boundary

		if ( cbRange < m_cbSec || ( cbRange % m_cbSec ) != 0 )
			{
			Assert( !g_fLRCKValidationTrap );
			return fFalse;
			}

		//	calculate the position of the next LRCHECKSUM record
		
		lgpos = *plgpos;
		AddLgpos( &lgpos, sizeof( LRCHECKSUM ) + plrck->le_cbNext );

		//	see if the next pointer lands in the sector after the range of this LRCHECKSUM record
		//
		//	NOTE: this should imply that it does not reach the end of the file since earlier we
		//		  made sure the range was less than the end of the file:
		//			next < range, range < EOF; therefore, next < EOF
		//
		//	NOTE: cbRange was previously set

		if ( lgpos.isec != plgpos->isec + ( cbRange / m_cbSec ) )
			{

			//	it lands somewhere else (before or after)

			Assert( !g_fLRCKValidationTrap );
			return fFalse;
			}


		/*******
		//	see if it reaches beyond the end of the file
		
		if ( QWORD( lgpos.isec ) * m_cbSec + lgpos.ib > ( qwSize - sizeof( LRCHECKSUM ) ) )
			{
			return fFalse;
			// the LRCHECKSUM is bad because it's next pointer points to
			// past the end of the log file.
			// Note that plrckNext->cbNext can be zero if it's the last LRCHECKSUM
			// in the log file.
			}
		*******/
		}

	return fTrue;

HandleError:

	//	this is the weird case where IFileAPI::ErrSize() returns an error??? should never happen...

	return fFalse;
	}

// Checks if an LRCHECKSUM on a particular sector is a valid shadow sector.

BOOL LOG::FValidLRCKShadow(
	const LRCHECKSUM * const plrck,
	const LGPOS * const plgpos,
	const LONG lGeneration
	)
	{

	//	validate the LRCHECKSUM record
	
	if ( !FValidLRCKRecord( plrck, plgpos ) )
		{
		Assert( !g_fLRCKValidationTrap );
		return fFalse;
		}

	//	we should not have a short checksum value

	if ( plrck->bUseShortChecksum != bShortChecksumOff )
		{
		Assert( !g_fLRCKValidationTrap );
		return fFalse;
		}

	//	we should not have another LRCHECKSUM record after this one

	if ( plrck->le_cbNext != 0 )
		{
		Assert( !g_fLRCKValidationTrap );
		return fFalse;
		}

	//	verify the range checksum

	if ( UlComputeShadowChecksum( UlComputeChecksum( plrck, (ULONG32)lGeneration ) ) != plrck->le_ulChecksum )
		{
		Assert( !g_fLRCKValidationTrap );
		return fFalse;
		}

	return fTrue;
	}


// Checks if an LRCHECKSUM on a particular sector is a valid shadow sector without looking at cbNext

BOOL LOG::FValidLRCKShadowWithoutCheckingCBNext(
	const LRCHECKSUM * const plrck,
	const LGPOS * const plgpos,
	const LONG lGeneration
	)
	{

	//	validate the LRCHECKSUM record
	
	if ( !FValidLRCKRecord( plrck, plgpos ) )
		{
		Assert( !g_fLRCKValidationTrap );
		return fFalse;
		}

	//	we should not have a short checksum value

	if ( plrck->bUseShortChecksum != bShortChecksumOff )
		{
		Assert( !g_fLRCKValidationTrap );
		return fFalse;
		}

	//	verify the range checksum

	if ( UlComputeShadowChecksum( UlComputeChecksum( plrck, (ULONG32)lGeneration ) ) != plrck->le_ulChecksum )
		{
		Assert( !g_fLRCKValidationTrap );
		return fFalse;
		}

	return fTrue;
	}


// Determines if an LRCHECKSUM on a sector has a valid short checksum.

BOOL LOG::FValidLRCKShortChecksum(
	const LRCHECKSUM * const plrck,
	const LONG lGeneration
	)
	{

	//	assume the caller has checked to see if we even have a short checksum

	Assert( plrck->bUseShortChecksum == bShortChecksumOn );

	//	compute the checksum
	
	if ( UlComputeShortChecksum( plrck, (ULONG32)lGeneration ) != plrck->le_ulShortChecksum )
		{
		Assert( !g_fLRCKValidationTrap );
		return fFalse;
		}
		
	return fTrue;
	}


// Once we know the structure of an LRCHECKSUM record is valid, we need
// to verify the validity of the region of data covered by the LRCHECKSUM.

BOOL LOG::FValidLRCKRange(
	const LRCHECKSUM * const plrck,
	const LONG lGeneration
	)
	{

	// If the sector is a shadow sector, the checksum won't match
	// because a shadow sector has ulShadowSectorChecksum added to its
	// checksum.
	if ( UlComputeChecksum( plrck, (ULONG32)lGeneration ) != plrck->le_ulChecksum )
		{
		Assert( !g_fLRCKValidationTrap );
		return fFalse;
		// the LRCHECKSUM is bad because it's checksum doesn't match
		}

	return fTrue;

	}


//	verify the LRCK record

void LOG::AssertValidLRCKRecord(
	const LRCHECKSUM * const plrck,
	const LGPOS	* const plgpos )
	{
#ifdef DEBUG
	const BOOL fValid = FValidLRCKRecord( plrck, plgpos );
	Assert( fValid );
#endif	//	DEBUG
	}


//	verify the current LRCK range

void LOG::AssertValidLRCKRange(
		const LRCHECKSUM * const plrck,
		const LONG lGeneration )
	{
#ifdef DEBUG

	//	we can directly assert this condition because it will never fail unless the checksum is actually bad

	Assert( FValidLRCKRange( plrck, lGeneration ) );
#endif	//	DEBUG
	}


//	verify the current LRCK record in DBG or RTL

void LOG::AssertRTLValidLRCKRecord(
		const LRCHECKSUM * const plrck,
		const LGPOS	* const plgpos )
	{
	const BOOL fValid = FValidLRCKRecord( plrck, plgpos );
	AssertRTL( fValid );
	}


//	verify the current LRCK range in DBG or RTL

void LOG::AssertRTLValidLRCKRange(
		const LRCHECKSUM * const plrck,
		const LONG lGeneration )
	{

	//	we can directly assert this condition because it will never fail unless the checksum is actually bad

	AssertRTL( FValidLRCKRange( plrck, lGeneration ) );
	}


//	verify the current LRCK shadow in DBG or RTL

void LOG::AssertRTLValidLRCKShadow(
		const LRCHECKSUM * const plrck,
		const LGPOS * const plgpos,
		const LONG lGeneration )
	{
	const BOOL fValid = FValidLRCKShadow( plrck, plgpos, lGeneration );
	AssertRTL( fValid );
	}


//	verify that the current LRCK range is INVALID

void LOG::AssertInvalidLRCKRange(
		const LRCHECKSUM * const plrck,
		const LONG lGeneration )
	{

	//	we can directly assert this condition because it will never fail unless the checksum is actually bad

	AssertRTL( !FValidLRCKRange( plrck, lGeneration ) );
	}






#ifdef ENABLE_LOGPATCH_TRACE

//	helper for writing to the log-patch text file in ErrLGCheckReadLastLogRecordFF

INLINE BOOL FLGILogPatchDate( const char* pszPath, CPRINTFFILE **const ppcprintf )
	{
	CPRINTFFILE	*pcprintf = *ppcprintf;
	DATETIME	datetime;

	if ( !pcprintf )
		{

		//	allocate a new trace file object

		pcprintf = new CPRINTFFILE( pszPath );
		if ( !pcprintf )
			{
			return fFalse;
			}
		*ppcprintf = pcprintf;

		//	start the trace file with a standard header

		(*pcprintf)( "==============================================================================\r\n" );
		(*pcprintf)( "ErrLGCheckReadLastLogRecordFF trace-log generated by ESE.DLL\r\n" );
		(*pcprintf)( "Do NOT delete this unless you know what you are doing...\r\n" );
		(*pcprintf)( "\r\n" );
		}

	UtilGetCurrentDateTime( &datetime );
	(*pcprintf)( "%02d:%02d:%02d %02d/%02d/%02d: ", 
				datetime.hour,
				datetime.minute,
				datetime.second,
				datetime.month,
				datetime.day,
				datetime.year );

	return fTrue;
	}

#endif	//	ENABLE_LOGPATCH_TRACE


#ifdef LOGPATCH_UNIT_TEST

//	run the following flush sequence: partial --> full --> partial

enum EIOFAILURE
	{
	iofNone			= 0,
	iofClean		= 1,//	clean		-- crash after I/O completes
//	iofTornSmall	= 2,//	torn		-- last sector is torn (anything other than last sector being torn implies
//	iofTornLarge	= 3,//										that later sectors were never written and degrades
						//										to an incomplete-I/O case)
	iofIncomplete1	= 2,//	incomplete1	-- 1 sector was not flushed
	iofIncomplete2	= 3,//	incomplete2	-- 2 sectors were not flushed
	iofMax			= 4
	};


//	mapping array to determine the maximum number of I/Os the current flush will have
//
//		prevflush:	0 = partial, 1 = full
//		curflush:	0 = partial, 1 = full
//		flushsize:	0..3 (only used when curflush == full)

const ULONG g_cIO[2][2][4]		= 		//	[prevflush][curflush][flushsize][io]
	{
		//	prevflush = partial
		{
			//	curflush = partial
			{
				1 + 1,	//	flushsize = <ignored>, partial sector + shadow
				1 + 1,	//	flushsize = <ignored>, partial sector + shadow
				1 + 1,	//	flushsize = <ignored>, partial sector + shadow
				1 + 1	//	flushsize = <ignored>, partial sector + shadow
			},
			//	curflush = full
			{
				1,		//	flushsize = 0(+1) -- implicit +1, flush full sector
				1 + 1,	//	flushsize = 1(+1) -- implicit +1, flush first full sector without touching shadow, flush the rest
				1 + 1,	//	flushsize = 2(+1) -- implicit +1, flush first full sector without touching shadow, flush the rest
				1 + 1	//	flushsize = 3(+1) -- implicit +1, flush first full sector without touching shadow, flush the rest
			}
		},
		//	prevflush = full
		{
			//	curflush = partial
			{
				1 + 1,	//	flushsize = <ignored>, partial sector + shadow
				1 + 1,	//	flushsize = <ignored>, partial sector + shadow
				1 + 1,	//	flushsize = <ignored>, partial sector + shadow
				1 + 1	//	flushsize = <ignored>, partial sector + shadow
			},
			//	curflush = full
			{
				1,		//	flushsize = 0(+1) -- implicit +1, flush all sectors
				1,		//	flushsize = 1(+1) -- implicit +1, flush all sectors
				1,		//	flushsize = 2(+1) -- implicit +1, flush all sectors
				1		//	flushsize = 3(+1) -- implicit +1, flush all sectors
			}
		}
	};


//	mapping array to determine the maximum level of failure given the following params:
//
//		prevflush:	0 = partial, 1 = full
//		curflush:	0 = partial, 1 = full
//		flushsize:	0..3 (only used when curflush == full)
//		io:			0..1 (1 is ignored when prevflush == curflush == full)

const ULONG	g_ciof[2][2][4][2]	= 		//	[prevflush][curflush][flushsize][io]
	{
		//	prevflush = partial
		{	
			//	curflush = partial
			{	
				//	flushsize = <ignored>
				{	
					//	I/O = 0, 1
					iofClean + 1,//iofTornLarge + 1,
					iofClean + 1,//iofTornLarge + 1 
				},
				//	flushsize = <ignored>
				{	
					//	I/O = 0, 1
					iofClean + 1,//iofTornLarge + 1,
					iofClean + 1,//iofTornLarge + 1 
				},	
				//	flushsize = <ignored>
				{	
					//	I/O = 0, 1
					iofClean + 1,//iofTornLarge + 1,
					iofClean + 1,//iofTornLarge + 1 
				},	
				//	flushsize = <ignored>
				{	
					//	I/O = 0, 1
					iofClean + 1,//iofTornLarge + 1,
					iofClean + 1,//iofTornLarge + 1 
				}
			},
			//	curflush = full
			{
				//	flushsize = 0(+1) -- implicit +1
				{
					//	I/O = 0, 1
					iofClean + 1,//iofTornLarge + 1, 
					iofClean + 1,//iofTornLarge + 1 
				},
				//	flushsize = 1(+1) -- implicit +1
				{
					//	I/O = 0, 1
					iofClean + 1,//iofTornLarge + 1, 
					iofClean + 1,//iofTornLarge + 1 
				},
				//	flushsize = 2(+1) -- implicit +1
				{
					//	I/O = 0, 1
					iofClean + 1,//iofTornLarge + 1, 
					iofIncomplete1 + 1
				},
				//	flushsize = 3(+1) -- implicit +1
				{
					//	I/O = 0, 1
					iofClean + 1,//iofTornLarge + 1, 
					iofIncomplete2 + 1
				}
			}
		},
		//	prevflush = full
		{
			//	curflush = partial
			{
				//	flushsize = <ignored>
				{	
					//	I/O = 0, 1
					iofClean + 1,//iofTornLarge + 1,
					iofClean + 1,//iofTornLarge + 1 
				},
				//	flushsize = <ignored>
				{	
					//	I/O = 0, 1
					iofClean + 1,//iofTornLarge + 1,
					iofClean + 1,//iofTornLarge + 1 
				},	
				//	flushsize = <ignored>
				{	
					//	I/O = 0, 1
					iofClean + 1,//iofTornLarge + 1,
					iofClean + 1,//iofTornLarge + 1 
				},	
				//	flushsize = <ignored>
				{	
					//	I/O = 0, 1
					iofClean + 1,//iofTornLarge + 1,
					iofClean + 1,//iofTornLarge + 1 
				}
			},
			//	curflush = full
			{
				//	flushsize = 0(+1) -- implicit +1
				{ 
					//	I/O = 0, 1<ignored>
					iofClean + 1,//iofTornLarge + 1, 
					iofNone
				},
				//	flushsize = 1(+1) -- implicit +1
				{ 
					//	I/O = 0, 1<ignored>
					iofIncomplete1 + 1, 
					iofNone
				},
				//	flushsize = 2(+1) -- implicit +1
				{ 
					//	I/O = 0, 1<ignored>
					iofIncomplete2 + 1, 
					iofNone
				},
				//	flushsize = 3(+1) -- implicit +1
				{ 
					//	I/O = 0, 1<ignored>
					iofIncomplete2 + 1, 
					iofNone
				},
			}
		}
	};


//	array of different cases (determines coverage of this test)
//
//		prevflush:	0 = partial, 1 = full
//		curflush:	0 = partial, 1 = full
//		flushsize:	0..3 (only used when curflush == full)
//		io:			0..1 (1 is ignored when prevflush == curflush == full)
//		failure:	0..3 (EIOFAILURE - 1)

ULONG g_cCoverage[2][2][4][2][5];



//	convert the current flush iteration to array indices

void TestLogPatchIGetArrayIndices(	const ULONG		iPartial0,
									const ULONG 	iFull0,
									const ULONG		iPartial1,
									const ULONG		iFull1,
									const ULONG		iPartial2,
									ULONG* const	piFlushPrev,
									ULONG* const	piFlushCur,
									ULONG* const	pcsecFlush )
	{
	const ULONG	iFlushPartial	= 0;
	const ULONG	iFlushFull		= 1;

	if ( 0 == iFull0 )
		{
		AssertRTL( iPartial0 > 0 );

		AssertRTL( 0 == iPartial1 );
		AssertRTL( 0 == iFull1 );
		AssertRTL( 0 == iPartial2 );

		*piFlushPrev	= iFlushPartial;
		*piFlushCur		= iFlushPartial;
		*pcsecFlush		= 1;

		return;
		}

	if ( 0 == iFull1 )
		{
		AssertRTL( 0 == iPartial2 );

		if ( iPartial1 > 1 )		//	2 partial flushes
			{
			*piFlushPrev	= iFlushPartial;	
			*piFlushCur		= iFlushPartial;
			*pcsecFlush		= 1;
			}
		else if ( 1 == iPartial1 )	//	1 full followed by 1 partial
			{
			*piFlushPrev	= iFlushFull;
			*piFlushCur		= iFlushPartial;
			*pcsecFlush		= 1;
			}
		else						//	1 partial followed by 1 full (partial was from log-file creation)
			{
			*piFlushPrev	= iFlushPartial;
			*piFlushCur		= iFlushFull;
			*pcsecFlush		= iFull0;
			}

		return;
		}
		
	if ( iPartial2 > 1 )		//	2 partial flushes
		{
		*piFlushPrev	= iFlushPartial;	
		*piFlushCur		= iFlushPartial;
		*pcsecFlush		= 1;
		}
	else if ( 1 == iPartial2 )	//	1 full followed by 1 partial
		{
		*piFlushPrev	= iFlushFull;
		*piFlushCur		= iFlushPartial;
		*pcsecFlush		= 1;
		}
	else						//	1 ??? followed by 1 full (full comes from iFull0 != 0)
		{
		*piFlushPrev	= ( iPartial1 > 0 ) ? iFlushPartial : iFlushFull;
		*piFlushCur		= iFlushFull;
		*pcsecFlush		= iFull1;
		}
	}




BOOL		g_fEnableFlushCheck = fFalse;	//	enable/disable log-flush checking
BOOL		g_fFlushIsPartial;				//	true --> flush should be partial, false --> flush should be full
ULONG		g_csecFlushSize;				//	when g_fFlushIsPartial == false, this is the number of full sectors we expect to flush

BOOL		g_fEnableFlushFailure = fFalse;	//	enable/disable log-flush failures
ULONG 		g_iIO;							//	I/O that should fail
EIOFAILURE	g_iof;							//	method of failure



extern LONG LTestLogPatchIStandardRand();



//	setup a region of buffer to be flushed

void TestLogPatchISetupFlushBuffer( BYTE* const pb, const ULONG cb )
	{
	BYTE	*pbNextRecord;
	ULONG	cbRemaining;

	pbNextRecord = pb;
	for ( cbRemaining = 0; cbRemaining < cb; cbRemaining++ )
		{
		pbNextRecord[cbRemaining] = BYTE( LTestLogPatchIStandardRand() & 0xFF );
		}

	while ( fTrue )
		{
		if ( cbRemaining < sizeof( LRBEGIN ) )
			{
			memset( pbNextRecord, lrtypNOP, cbRemaining );
			return;
			}

		if ( cbRemaining >= sizeof( LRREPLACE ) )
			{
			LRREPLACE* const	plrreplace	=	(LRREPLACE*)pbNextRecord;
			const ULONG			cbReplace	= 	cbRemaining > sizeof( LRREPLACE ) ?
												LTestLogPatchIStandardRand() % ( cbRemaining - sizeof( LRREPLACE ) ) : 0;
			plrreplace->lrtyp = lrtypReplace;
			plrreplace->SetCb( USHORT( cbReplace ) );

			cbRemaining		-= sizeof( LRREPLACE ) + cbReplace;
			pbNextRecord	+= sizeof( LRREPLACE ) + cbReplace;
			}
		else if ( cbRemaining >= sizeof( LRCOMMIT0 ) )
			{
			LRCOMMIT0* const plrcommit0 = (LRCOMMIT0*)pbNextRecord;

			plrcommit0->lrtyp = lrtypCommit0;

			cbRemaining		-= sizeof( LRCOMMIT0 );
			pbNextRecord	+= sizeof( LRCOMMIT0 );
			}
		else
			{
			LRBEGIN* const plrbegin = (LRBEGIN*)pbNextRecord;

			plrbegin->lrtyp = lrtypBegin;

			cbRemaining		-= sizeof( LRBEGIN );
			pbNextRecord	+= sizeof( LRBEGIN );
			}
		}
	}
									



//	do a partial flush

void TestLogPatchIFlushPartial( INST* const pinst, LOG* const plog )
	{
	ERR		err;
	ULONG	cbRemaining;
	ULONG	cb;
	BYTE	rgb[512];
	DATA	rgdata[1];
	LGPOS	lgpos;
	BYTE	*pbWriteBefore;
	ULONG	isecWriteBefore;

	pbWriteBefore = plog->m_pbWrite;
	isecWriteBefore = plog->m_isecWrite;

	//	determine how many bytes we have left in the current sector

	AssertRTL( plog->m_pbWrite == plog->PbSecAligned( plog->m_pbEntry ) );
	cbRemaining = 512 - ( ULONG_PTR( plog->m_pbEntry ) % 512 );

	//	use between 1% and 50% of those bytes

	cb = 1 + LTestLogPatchIStandardRand() % ( cbRemaining / 2 );

	//	setup the log record buffer

	TestLogPatchISetupFlushBuffer( rgb, cb );

	//	setup the flush-check params

	AssertRTL( g_fEnableFlushCheck );
	g_fFlushIsPartial = fTrue;

	//	log the "log record"

	rgdata[0].SetPv( rgb );
	rgdata[0].SetCb( cb );
	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, &lgpos );
	AssertRTL( JET_errSuccess == err );

	//	flush the log

	err = plog->ErrLGFlushLog( pinst->m_pfsapi, fFalse );
	if ( g_fEnableFlushFailure )
		{
		AssertRTL( err < JET_errSuccess );
		}
	else
		{
		AssertRTL( JET_errSuccess == err );
		AssertRTL( plog->m_pbWrite == pbWriteBefore );
		AssertRTL( plog->m_isecWrite == isecWriteBefore );
		}
	}


//	do a full flush

void TestLogPatchIFlushFull( INST* const pinst, LOG* const plog, const ULONG 
csecFlushSize )
	{
	ERR		err;
	ULONG	cbRemaining;
	ULONG	cb;
	BYTE	rgb[4 * 512];
	DATA	rgdata[1];
	LGPOS	lgpos;
	BYTE	*pbWriteBefore;
	ULONG	isecWriteBefore;

	Enforce( csecFlushSize <= 4 );

	pbWriteBefore = plog->m_pbWrite;
	isecWriteBefore = plog->m_isecWrite;

	//	determine how many bytes we have left in the current sector

	AssertRTL( plog->m_pbWrite == plog->PbSecAligned( plog->m_pbEntry ) );
	cbRemaining = 512 - ( ULONG_PTR( plog->m_pbEntry ) % 512 );

	//	use enough space to fill up the desired number of sectors

	cb = cbRemaining + ( ( csecFlushSize - 1 ) * 512 );

	//	setup the log record buffer with NOPs

	TestLogPatchISetupFlushBuffer( rgb, cb );

	//	setup the flush-check params

	AssertRTL( g_fEnableFlushCheck );
	g_fFlushIsPartial	= fFalse;
	g_csecFlushSize		= csecFlushSize;

	//	log the "log record"

	rgdata[0].SetPv( rgb );
	rgdata[0].SetCb( cb );
	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, &lgpos );
	AssertRTL( JET_errSuccess == err );

	//	flush the log

	err = plog->ErrLGFlushLog( pinst->m_pfsapi, fFalse );
	if ( g_fEnableFlushFailure )
		{
		AssertRTL( err < JET_errSuccess );
		}
	else
		{
		AssertRTL( JET_errSuccess == err );
		AssertRTL( plog->m_pbWrite != pbWriteBefore );	//	shouldn't be equal since we flush at most 4 sectors
		AssertRTL( plog->m_isecWrite > isecWriteBefore );
		}
	}


//	verify the log after patching it

void TestLogPatchIVerify(	LOG* const			plog,
							const ULONG			iFull0,
							const ULONG			iPartial1,
							const ULONG			iFull1,
							const ULONG			iPartial2,
							const ULONG			iIO,
							const EIOFAILURE	iof )
	{
	ERR			err;
	ULONG		csecData;
	ULONG		cLRCK;
	LogReader	lread;
	BYTE		*pbEnsure;
	ULONG		isec;
	ULONG		iLRCK;
	LGPOS		lgpos;
	LRCHECKSUM	*plrck;
	ULONG		csecPattern;

	//	calculate the expected condition of the log

	if ( 0 == iFull0 )			//	last flush is partial, prev-last flush is partial (from iPartial0 > 0 or from new log file)
		{
		csecData	= 1 + 1;	//	includes shadow sector
		cLRCK		= 1;		//	we have 1 LRCK because we'll recover the torn sector using the previous shadow sector
		}
	else if ( 0 == iFull1 )
		{
		if ( iPartial1 > 0 )	//	last flush is partial, prev-last flush is partial OR
			{					//	last flush is partial, prev-last flush is full
			csecData	= iFull0 + 1 + 1;	//	includes shadow sector
			cLRCK		= 2;
			}
		else					//	last flush is full, prev-last flush is partial   (either from iPartial0 or from new log file)
			{
			if ( 0 == iIO )
				{
				//if ( iofClean == iof )
				AssertRTL( iofClean == iof );
					{
					if ( 1 == iFull0 )	//	full-sector flush will NOT overwrite the shadow from the prev flush
						{
						csecData	= iFull0 + 1 + 1;	//	full sector followed by new partial flush (created by patch code)
						cLRCK		= 2;
						}
					else
						{
						csecData	= 1 + 1;	//	first sector of full flush followed by old shadow (we know prev flush was partial)
						cLRCK		= 1;
						}
					}
				//else
				//	{
				//	AssertRTL( iofTornSmall == iof || iofTornLarge == iof );
				//
				//	csecData	= 1 + 1;	//	includes shadow sector used to recover previous partial flush
				//	cLRCK		= 1;
				//	}
				}
			else
				{
				AssertRTL( 1 == iIO );

				if ( iofClean == iof )
					{
					csecData	= iFull0 + 1 + 1;	//	includes partial flush (w/shadow) that gets created by the patch code
					cLRCK		= 2;
					}
				else
					{
					AssertRTL(	//iofTornSmall == iof		|| iofTornLarge == iof || 
								iofIncomplete1 == iof	|| iofIncomplete2 == iof );

					csecData	= 1 + 1;	//	includes shadow sector that gets created by the patch code after shrinking the LRCK
					cLRCK		= 1;
					}
				}
			}
		}
	else	//	last flush may be full; prev-last flush may be full
		{
		if ( iPartial2 > 0 )		//	last flush is partial, prev-last flush is partial OR
			{						//	last flush is partial, prev-last flush is full
			csecData	= iFull0 + iFull1 + 1 + 1;	//	includes shadow sector
			cLRCK		= 3;
			}
		else if ( iPartial1 > 0 )	//	last flush is full, prev-last flush is partial
			{
			if ( 0 == iIO )
				{
				//if ( iofClean == iof )
				AssertRTL( iofClean == iof );
					{
					if ( 1 == iFull1 )
						{
						csecData	= iFull0 + iFull1 + 1 + 1;	//	full followed by new partial (created by log patch code)
						cLRCK		= 3;
						}
					else
						{
						csecData	= iFull0 + 1 + 1;	//	first sector of full flush followed by old shadow (we know prev flush was partial)
						cLRCK		= 2;
						}
					}
				//else
				//	{
				//	AssertRTL( iofTornSmall == iof || iofTornLarge == iof );
				//
				//	csecData	= iFull0 + 1 + 1;	//	includes shadow sector used to recover previous partial flush
				//	cLRCK		= 2;
				//	}
				}
			else
				{
				AssertRTL( 1 == iIO );

				if ( iofClean == iof )
					{
					csecData	= iFull0 + iFull1 + 1 + 1;	//	includes partial flush (w/shadow) that gets created by the patch code
					cLRCK		= 3;
					}
				else
					{
					AssertRTL(	//iofTornSmall == iof		|| iofTornLarge == iof || 
								iofIncomplete1 == iof	|| iofIncomplete2 == iof );

					csecData	= iFull0 + 1 + 1;	//	includes shadow sector that gets created by the patch code after shrinking the LRCK
					cLRCK		= 2;
					}
				}
			}
		else						//	last flush is full, prev-last flush is full
			{
			AssertRTL( 0 == iIO );

			if ( iofClean == iof )
				{
				csecData	= iFull0 + iFull1 + 1 + 1;	//	includes partial flush (w/shadow) that gets created by the patch code
				cLRCK		= 3;
				}
			else
				{
				AssertRTL(	//iofTornSmall == iof		|| iofTornLarge == iof || 
							iofIncomplete1 == iof	|| iofIncomplete2 == iof );


				csecData	= iFull0 + 1 + 1;	//	includes partial flush (w/shadow) that gets created by the patch code
				cLRCK		= 2;
				}
			}
		}

	//	allocate a buffer for reading the log

	AssertRTL( !plog->m_plread );
	plog->m_plread = &lread;

	err = lread.ErrLReaderInit( plog, ( 5 * 1024 * 1024 ) / 512 );
	AssertRTL( JET_errSuccess == err );
	err = lread.ErrEnsureLogFile();
	AssertRTL( JET_errSuccess == err );

	//	read in the data portion of the log (should be successful)

	err = lread.ErrEnsureSector( 8, csecData, &pbEnsure );
	AssertRTL( JET_errSuccess == err );

	//	verify that the pattern is NOT in the data portion

	for ( isec = 0; isec < csecData; isec++ )
		{
		if ( 0 == memcmp( pbEnsure + isec * 512, rgbLogExtendPattern, 512 ) )
			{
			AssertSzRTL( fFalse, "The log-extend pattern was found in the data portion of log file!" );
			}
		}

	//	verify the checksums

	const BOOL fOldRecovering = plog->m_fRecovering;
	plog->m_fRecovering = fTrue;

	iLRCK = 0;
	lgpos.ib = 0;
	lgpos.isec = 8;
	lgpos.lGeneration = 1;
	while ( fTrue )
		{

		//	verify the checksum

		plrck = (LRCHECKSUM*)( pbEnsure + ( ( lgpos.isec - 8 ) * 512 ) + lgpos.ib );

		plog->AssertRTLValidLRCKRecord( plrck, &lgpos );
		plog->AssertRTLValidLRCKRange( plrck, lgpos.lGeneration );

		//	move next

		iLRCK++;
		if ( iLRCK >= cLRCK )
			{
			AssertRTL( 0 == plrck->le_cbNext );
			break;
			}
		AssertRTL( plrck->le_cbNext > 0 );
		plog->AddLgpos( &lgpos, sizeof( LRCHECKSUM ) + plrck->le_cbNext );
		}

	//	verify the shadow of the last partial sector

	plrck = (LRCHECKSUM*)( (BYTE*)plrck + 512 );
	plog->AssertRTLValidLRCKShadow( plrck, &lgpos, lgpos.lGeneration ) );

	//	verify that we are in the last sector of the data portion of the log

	AssertRTL( ( ULONG_PTR( plrck ) & ~511 ) + 512 == ULONG_PTR( pbEnsure ) + ( csecData * 512 ) );

	//	verify the data

	iLRCK = 0;
	lgpos.ib = 0;
	lgpos.isec = 8;
	lgpos.lGeneration = 1;
	while ( fTrue )
		{
		LR *plr;

		plr = (LR*)( pbEnsure + ( ( lgpos.isec - 8 ) * 512 ) + lgpos.ib );

		AssertRTL(	lrtypNOP == plr->lrtyp ||
					lrtypBegin == plr->lrtyp ||
					lrtypCommit0 == plr->lrtyp ||
					lrtypReplace == plr->lrtyp ||
					lrtypChecksum == plr->lrtyp );

		if ( lrtypChecksum == plr->lrtyp )
			{
			iLRCK++;
			if ( iLRCK >= cLRCK )
				{
				break;
				}
			}

		plog->AddLgpos( &lgpos, CbLGSizeOfRec( plr ) );
		}


	plog->m_fRecovering = fFalse;

	//	read in the pattern portion of the log (should be successful)

	csecPattern = ( ( 5 * 1024 * 1024 ) / 512 ) - ( 8 + csecData );
	err = lread.ErrEnsureSector( 8 + csecData, csecPattern, &pbEnsure );
	AssertRTL( JET_errSuccess == err );

	//	verify that we have the pattern after the last sector of data

	for ( isec = 0; isec < csecPattern; isec++ )
		{
		AssertRTL( 0 == memcmp( pbEnsure + ( isec * 512 ), rgbLogExtendPattern, 512 ) );
		}

	//	cleanup memory

	err = lread.ErrLReaderTerm();
	AssertRTL( JET_errSuccess == err );

	plog->m_plread = NULL;
	}


//	test one log-flush failure case

void TestLogPatchITest(	INST* const			pinst,
						LOG* const			plog,
						const ULONG			iPartial0,
						const ULONG			iFull0,
						const ULONG			iPartial1,
						const ULONG			iFull1,
						const ULONG			iPartial2,
						const ULONG			iIO,
						const EIOFAILURE	iof )
	{
	ERR		err;
	ULONG	iLoop;

	//	create a new log file (in memory)

	delete plog->m_pfapiLog;
	plog->m_pfapiLog = NULL;

	plog->m_lgposLastLogRec = lgposMin;
	plog->m_lgposMaxFlushPoint = lgposMin;
	plog->LGMakeLogName( plog->m_szLogName, plog->m_szJet );

	plog->m_critLGFlush.Enter();
	err = plog->ErrLGNewLogFile( pinst->m_pfsapi, 0, fLGOldLogNotExists );
	AssertRTL( JET_errSuccess == err );
	plog->m_critLGFlush.Leave();

	memcpy( plog->m_plgfilehdr, plog->m_plgfilehdrT, sizeof( LGFILEHDR ) );
	plog->m_isecWrite = 8;
	plog->m_pbLGFileEnd = pbNil;
	plog->m_isecLGFileEnd = 0;

	//	enable the flush-check mechanism

	g_fEnableFlushCheck = fTrue;

	//	first partial flush sequence

	if ( iPartial0 > 0 )
		{

		//	determine if this is the last flush sequence
		
		const BOOL fLast = ( 0 == iFull0 ) ? fTrue : fFalse;

		for ( iLoop = 0; iLoop < iPartial0 - 1; iLoop++ )
			{
			TestLogPatchIFlushPartial( pinst, plog );	//	do a partial flush
			}

		if ( fLast )
			{
			g_fEnableFlushFailure	= fTrue;	//	enable the flush-failure mechanism
			g_iIO					= iIO;
			g_iof					= iof;
			}

		TestLogPatchIFlushPartial( pinst, plog );		//	do the last flush

		if ( fLast )
			{
			goto DoneFlushing;
			}
		}

	//	first full flush sequence

	if ( iFull0 > 0 )
		{

		//	determine if this is the last flush sequence

		const BOOL fLast = ( 0 == iPartial1 && 0 == iFull1 ) ? fTrue : fFalse;

		if ( fLast )
			{
			g_fEnableFlushFailure	= fTrue;	//	enable the flush-failure mechanism
			g_iIO					= iIO;
			g_iof					= iof;
			}

		TestLogPatchIFlushFull( pinst, plog, iFull0 );	//	do the flush

		if ( fLast )
			{
			goto DoneFlushing;
			}
		}

	//	second partial flush sequence

	if ( iPartial1 > 0 )
		{

		//	determine if this is the last flush sequence
		
		const BOOL fLast = ( 0 == iFull1 ) ? fTrue : fFalse;

		for ( iLoop = 0; iLoop < iPartial1 - 1; iLoop++ )	
			{
			TestLogPatchIFlushPartial( pinst, plog );	//	do a partial flush
			}

		if ( fLast )
			{
			g_fEnableFlushFailure	= fTrue;	//	enable the flush-failure mechanism
			g_iIO					= iIO;
			g_iof					= iof;
			}

		TestLogPatchIFlushPartial( pinst, plog );		//	do the last flush

		if ( fLast )
			{
			goto DoneFlushing;
			}
		}

	//	second full flush sequence

	if ( iFull1 > 0 )
		{

		//	determine if this is the last flush sequence

		const BOOL fLast = ( 0 == iPartial2 ) ? fTrue : fFalse;

		if ( fLast )
			{
			g_fEnableFlushFailure	= fTrue;	//	enable the flush-failure mechanism
			g_iIO					= iIO;
			g_iof					= iof;
			}

		TestLogPatchIFlushFull( pinst, plog, iFull1 );	//	do the flush

		if ( fLast )
			{
			goto DoneFlushing;
			}
		}

	//	third partial flush sequence

	for ( iLoop = 0; iLoop < iPartial2 - 1; iLoop++ )
		{
		TestLogPatchIFlushPartial( pinst, plog );		//	do the flush
		}

	g_fEnableFlushFailure	= fTrue;			//	enable the flush-failure mechanism
	g_iIO					= iIO;
	g_iof					= iof;

	TestLogPatchIFlushPartial( pinst, plog );			//	do the last flush

DoneFlushing:

	//	disable the flush-failure mechanism

	g_fEnableFlushFailure = fFalse;

	//	disable the flush-check mechanism

	g_fEnableFlushCheck = fFalse;

	//	patch the log

	BOOL fCloseNormally;
	Call( plog->ErrLGCheckReadLastLogRecordFF( pinst->m_pfsapi, &fCloseNormally, fFalse, NULL ) );
	AssertRTL( !fCloseNormally );

	//	verify the log

	TestLogPatchIVerify(	plog,
							iFull0,
							iPartial1,
							iFull1,
							iPartial2,
							iIO,
							iof );

	return;

HandleError:
	AssertRTL( JET_errSuccess == err );
	}



//#define TEST_LOG_LEVEL 0		//	partial
//#define TEST_LOG_LEVEL 1		//	partial -> full -> partial
#define TEST_LOG_LEVEL 2		//	partial -> full -> partial -> full -> partial




//
//#error some of these cases may be interpreted as corruption -- 
//		should we ignore some cases that we know will be corruption?
//		(e.g. I think almost all torn-sector cases will have this problem)
//		(also, I think this will happen with some of the full->full flush cases)
//




//	test the log-patch code

void TestLogPatch( INST* const pinst )
	{
	LOG* const	plog = pinst->m_plog;

	ULONG 		iPartial0;
	ULONG		iFull0;
	ULONG		iPartial1;
	ULONG		iFull1;
	ULONG		iPartial2;

#if TEST_LOG_LEVEL == 0
	const ULONG	iPartial0Min	= 1;
	const ULONG	iPartial0Max	= 10;
	const ULONG iFull0Min		= 0;
	const ULONG iFull0Max		= 0;
	const ULONG	iPartial1Min	= 0;
	const ULONG	iPartial1Max	= 0;
	const ULONG iFull1Min		= 0;
	const ULONG iFull1Max		= 0;
	const ULONG	iPartial2Min	= 0;
	const ULONG	iPartial2Max	= 0;
	const ULONG citerTotal		= iPartial0Max - iPartial0Min;
#elif TEST_LOG_LEVEL == 1
	const ULONG	iPartial0Min	= 0;
	const ULONG	iPartial0Max	= 10;
	const ULONG iFull0Min		= 1;
	const ULONG iFull0Max		= 4;
	const ULONG	iPartial1Min	= 0;
	const ULONG	iPartial1Max	= 10;
	const ULONG iFull1Min		= 0;
	const ULONG iFull1Max		= 0;
	const ULONG	iPartial2Min	= 0;
	const ULONG	iPartial2Max	= 0;
	const ULONG citerTotal		=	( iPartial0Max - iPartial0Min ) *
									( iFull0Max - iFull0Min ) *
									( iPartial1Max - iPartial1Min );
#elif TEST_LOG_LEVEL == 2
	const ULONG	iPartial0Min	= 0;
	const ULONG	iPartial0Max	= 10;
	const ULONG iFull0Min		= 1;
	const ULONG iFull0Max		= 4;
	const ULONG	iPartial1Min	= 0;
	const ULONG	iPartial1Max	= 10;
	const ULONG iFull1Min		= 1;
	const ULONG iFull1Max		= 4;
	const ULONG	iPartial2Min	= 0;
	const ULONG	iPartial2Max	= 10;
	const ULONG citerTotal		=	( iPartial0Max - iPartial0Min ) *
									( iFull0Max - iFull0Min ) *
									( iPartial1Max - iPartial1Min ) *
									( iFull1Max - iFull1Min ) *
									( iPartial2Max - iPartial2Min );
#else
#error Invalid value for TEST_LOG_LEVEL
#endif	//	TEST_LOG_LEVEL

	ULONG		iFlushPrev;
	ULONG		iFlushCur;
	ULONG		csecFlush;

	ULONG		iIO;

	EIOFAILURE	iof;

	//	reset the coverage map

	memset( (void*)&g_cCoverage, 0, sizeof( g_cCoverage ) );

	//	fixup the current log path for ErrLGNewLogFile()

	plog->m_szLogCurrent = plog->m_szLogFilePath;
	strcpy( plog->m_szLogFilePath, ".\\" );
	plog->m_isecWrite = 8;
	plog->m_fNewLogRecordAdded = fTrue;

	//	iterate over all possible combinations of the flush sequence

	iPartial0	= iPartial0Min;
	iFull0		= iFull0Min;
	iPartial1	= iPartial1Min;
	iFull1		= iFull1Min;
	iPartial2	= iPartial2Min;

	printf( "\n" );
	printf( "testing the log-patch code\n" );
	printf( "     iPartial0 = %d..%d\n", iPartial0Min, iPartial0Max );
	printf( "     iFull0    = %d..%d\n", iFull0Min, iFull0Max );
	printf( "     iPartial1 = %d..%d\n", iPartial1Min, iPartial1Max );
	printf( "     iFull1    = %d..%d\n", iFull1Min, iFull1Max );
	printf( "     iPartial2 = %d..%d\n", iPartial2Min, iPartial2Max );
	printf( "  ---------------------\n" );
	printf( "     SUB-TOTAL = %d state sequences\n", citerTotal );
	printf( "  ---------------------\n" );
	printf( "      max I/Os = 2\n" );
	printf( "  max failures = 3\n" );
	printf( "  ---------------------\n" );
	printf( "  APPROX TOTAL = %d failure cases (will actually be slightly less than this)\n", citerTotal * 2 * 3 );
	printf( "\n" );

	while ( fTrue )
		{
		AssertRTL( 0 != iPartial0 + iFull0 + iPartial1 + iFull1 + iPartial2 );

		if ( iPartial0Min == iPartial0 )
			{
			printf( "iPartial0=%d..%d", iPartial0Min, iPartial0Max );
			if ( 0 != iFull0 )
				{
				printf( ",iFull0=%d,iPartial1=%d", iFull0, iPartial1 );
				if ( 0 != iFull1 )
					{
					printf( ",iFull1=%d,iPartial2=%d", iFull1, iPartial2 );
					}
				}
			printf( "\n" );
			}

		//	convert this flush sequence to array indices

		TestLogPatchIGetArrayIndices(	iPartial0, 
										iFull0, 
										iPartial1, 
										iFull1, 
										iPartial2, 
										&iFlushPrev, 
										&iFlushCur, 
										&csecFlush );
		AssertRTL( csecFlush >= 1 );
		AssertRTL( csecFlush <= 4 );

		//	extract the maximum number of I/Os for this iteration

		const ULONG cIOMax = g_cIO[iFlushPrev][iFlushCur][csecFlush-1];
		AssertRTL( cIOMax <= 2 );

		for ( iIO = 0; iIO < cIOMax; iIO++ )
			{

			//	extract the maximum level of I/O failure

			const ULONG	ciofMax = g_ciof[iFlushPrev][iFlushCur][csecFlush-1][iIO];
			AssertRTL( ciofMax > iofNone );
			AssertRTL( ciofMax <= iofMax );

			for ( iof = iofClean; iof < ciofMax; iof = EIOFAILURE( ULONG_PTR( iof ) + 1 ) )
				{

				//	run the current test

				TestLogPatchITest(	pinst,
									plog,
									iPartial0,
									iFull0,
									iPartial1,
									iFull1,
									iPartial2,
									iIO,
									iof );

				//	remember that we got coverage of this case

				g_cCoverage[iFlushPrev][iFlushCur][csecFlush-1][iIO][iof-1]++;
				}
			}

		//	advance the loop counters

		if ( iPartial0 >= iPartial0Max )
			{
			iPartial0 = iPartial0Min;
			if ( iFull0 >= iFull0Max )
				{
				iFull0 = iFull0Min;
				if ( iPartial1 >= iPartial1Max )
					{
					iPartial1 = iPartial1Min;
					if ( iFull1 >= iFull1Max )
						{
						iFull1 = iFull1Min;
						if ( iPartial2 >= iPartial2Max )
							{
							break;
							}
						else
							{
							iPartial2++;
							}
						}
					else
						{
						iFull1++;
						}
					}
				else
					{
					iPartial1++;
					}
				}
			else
				{
				iFull0++;
				}
			}
		else
			{
			iPartial0++;
			}
		}

	printf( "\n" );

	//	display test coverage

	printf( "\nTest coverage map:\n\n" );
	for ( iFlushPrev = 0; iFlushPrev < 2; iFlushPrev++ )
		{
		for ( iFlushCur = 0; iFlushCur < 2; iFlushCur++ )
			{
			char szSequence[30];

			sprintf( szSequence, "%s,%s", ( 0 == iFlushPrev ) ? "partial" : "full", ( 0 == iFlushCur  ) ? "partial" : "full" );

			//printf( "sequence         sectors  I/O | clean  tornsmall  tornlarge  incomp1  incomp2\n" );
			//printf( "---------------  -------  --- | =====  =========  =========  =======  =======\n" );

			printf( "sequence         sectors  I/O | clean  incomp1  incomp2\n" );
			printf( "---------------  -------  --- | =====  =======  =======\n" );

			//printf( "%-15s        1    0 | %5d  %9d  %9d  %7d  %7d\n",
			printf( "%-15s        1    0 | %5d  %7d  %7d\n",
					szSequence,
					g_cCoverage[iFlushPrev][iFlushCur][0][0][0],
					g_cCoverage[iFlushPrev][iFlushCur][0][0][1],
					g_cCoverage[iFlushPrev][iFlushCur][0][0][2] );
					//g_cCoverage[iFlushPrev][iFlushCur][0][0][3],
					//g_cCoverage[iFlushPrev][iFlushCur][0][0][4] );
			//printf( "%-15s        1    1 | %5d  %9d  %9d  %7d  %7d\n",
			printf( "%-15s        1    1 | %5d  %7d  %7d\n",
					szSequence,
					g_cCoverage[iFlushPrev][iFlushCur][0][1][0],
					g_cCoverage[iFlushPrev][iFlushCur][0][1][1],
					g_cCoverage[iFlushPrev][iFlushCur][0][1][2] );
					//g_cCoverage[iFlushPrev][iFlushCur][0][1][3],
					//g_cCoverage[iFlushPrev][iFlushCur][0][1][4] );

			//printf( "%-15s        2    0 | %5d  %9d  %9d  %7d  %7d\n",
			printf( "%-15s        2    0 | %5d  %7d  %7d\n",
					szSequence,
					g_cCoverage[iFlushPrev][iFlushCur][1][0][0],
					g_cCoverage[iFlushPrev][iFlushCur][1][0][1],
					g_cCoverage[iFlushPrev][iFlushCur][1][0][2] );
					//g_cCoverage[iFlushPrev][iFlushCur][1][0][3],
					//g_cCoverage[iFlushPrev][iFlushCur][1][0][4] );
			//printf( "%-15s        2    1 | %5d  %9d  %9d  %7d  %7d\n",
			printf( "%-15s        2    1 | %5d  %7d  %7d\n",
					szSequence,
					g_cCoverage[iFlushPrev][iFlushCur][1][1][0],
					g_cCoverage[iFlushPrev][iFlushCur][1][1][1],
					g_cCoverage[iFlushPrev][iFlushCur][1][1][2] );
					//g_cCoverage[iFlushPrev][iFlushCur][1][1][3],
					//g_cCoverage[iFlushPrev][iFlushCur][1][1][4] );

			//printf( "%-15s        3    0 | %5d  %9d  %9d  %7d  %7d\n",
			printf( "%-15s        3    0 | %5d  %7d  %7d\n",
					szSequence,
					g_cCoverage[iFlushPrev][iFlushCur][2][0][0],
					g_cCoverage[iFlushPrev][iFlushCur][2][0][1],
					g_cCoverage[iFlushPrev][iFlushCur][2][0][2] );
					//g_cCoverage[iFlushPrev][iFlushCur][2][0][3],
					//g_cCoverage[iFlushPrev][iFlushCur][2][0][4] );
			//printf( "%-15s        3    1 | %5d  %9d  %9d  %7d  %7d\n",
			printf( "%-15s        3    1 | %5d  %7d  %7d\n",
					szSequence,
					g_cCoverage[iFlushPrev][iFlushCur][2][1][0],
					g_cCoverage[iFlushPrev][iFlushCur][2][1][1],
					g_cCoverage[iFlushPrev][iFlushCur][2][1][2] );
					//g_cCoverage[iFlushPrev][iFlushCur][2][1][3],
					//g_cCoverage[iFlushPrev][iFlushCur][2][1][4] );

			//printf( "%-15s        4    0 | %5d  %9d  %9d  %7d  %7d\n",
			printf( "%-15s        4    0 | %5d  %7d  %7d\n",
					szSequence,
					g_cCoverage[iFlushPrev][iFlushCur][3][0][0],
					g_cCoverage[iFlushPrev][iFlushCur][3][0][1],
					g_cCoverage[iFlushPrev][iFlushCur][3][0][2] );
					//g_cCoverage[iFlushPrev][iFlushCur][3][0][3],
					//g_cCoverage[iFlushPrev][iFlushCur][3][0][4] );
			//printf( "%-15s        4    1 | %5d  %9d  %9d  %7d  %7d\n",
			printf( "%-15s        4    1 | %5d  %7d  %7d\n",
					szSequence,
					g_cCoverage[iFlushPrev][iFlushCur][3][1][0],
					g_cCoverage[iFlushPrev][iFlushCur][3][1][1],
					g_cCoverage[iFlushPrev][iFlushCur][3][1][2] );
					//g_cCoverage[iFlushPrev][iFlushCur][3][1][3],
					//g_cCoverage[iFlushPrev][iFlushCur][3][1][4] );
			}
		}

	AssertSzRTL( fFalse, "TestLogPatch() is complete -- you may want to break in with the debugger to verify internal state" );
	}


#endif	//	LOGPATCH_UNIT_TEST


//	check the log, searching for the last log record and seeing whether or not it is a term record
//	this will patch any damange to the log as well (when it can)

// Implicit output parameters:
//		m_pbLastChecksum
//		m_fAbruptEnd	(UNDONE)
//		m_pbWrite
//		m_isecWrite
//		m_pbEntry

// At the end of this function, we should have done any necessary fix-ups
// to the log file. i.e. writing a shadow sector that didn't get written,
// writing over a corrupted regular data sector.

ERR LOG::ErrLGCheckReadLastLogRecordFF(	IFileSystemAPI *const	pfsapi, 
										BOOL 					*pfCloseNormally, 
										const BOOL 				fReadOnly,
										BOOL					*pfIsPatchable )
	{
	ERR 			err;
	LRCHECKSUM		*plrck;
	LGPOS			lgposCurrent;
	LGPOS			lgposLast;
	LGPOS			lgposEnd;
	LGPOS			lgposNext;
	BYTE			*pbEnsure;
	BYTE			*pbLastSector;
	BYTE			*pbLastChecksum;
	UINT			isecLastSector;
	ULONG			isecPatternFill;
	ULONG			csecPatternFill;
	LogReader		*plread;
	BOOL			fGotQuit;
	BOOL			fCreatedLogReader;
	BOOL			fLogToNextLogFile;
	BOOL			fDoScan;
	BOOL			fOldRecovering;
	RECOVERING_MODE fOldRecoveringMode;
	BOOL			fRecordOkRangeBad;
	LGPOS			lgposScan;
	BOOL			fJetLog;
	BOOL			fTookJump;
	BOOL			fSingleSectorTornWrite;
	BOOL			fSkipScanAndApplyPatch;
	ULONG			cbChecksum;
#ifdef ENABLE_LOGPATCH_TRACE
	CPRINTFFILE		*pcprintfLogPatch = NULL;
	CHAR			szLogPatchPath[ IFileSystemAPI::cchPathMax ];
#endif	//	ENABLE_LOGPATCH_TRACE
//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//	BOOL			fWriteOnSectorSizeMismatch;

	//	we must have an initialized volume sector size

	Assert( m_cbSecVolume != ~(ULONG)0 );
	Assert( m_cbSecVolume % 512 == 0 );

	//	we should not be probing for a torn-write unless we are dumping logs

	Assert( !pfIsPatchable || m_fDumppingLogs );

	//	initialize variables

	err							= JET_errSuccess;	//	assume success
	plrck 						= pNil;				//	LRCHECKSUM class pointer
	lgposCurrent.ib				= 0;				//	what we are looking at right now
	lgposCurrent.isec			= USHORT( m_csecHeader );
	lgposCurrent.lGeneration	= m_plgfilehdr->lgfilehdr.le_lGeneration;
	lgposLast.ib				= 0;				//	the last LRCHECKSUM we saw 
	lgposLast.isec				= 0;
	lgposLast.lGeneration		= m_plgfilehdr->lgfilehdr.le_lGeneration;
	lgposEnd.ib					= 0;				//	position after the end of logical data
	lgposEnd.isec				= 0;
	lgposEnd.lGeneration		= m_plgfilehdr->lgfilehdr.le_lGeneration;
	pbEnsure 					= pbNil;			//	start of data we're looking at in the log buffer
	pbLastSector				= pbNil;			//	separate page with copy of last sector of log data
	pbLastChecksum				= pbNil;			//	offset of the LRCHECKSUM within pbLastSector
	isecLastSector				= m_csecHeader;		//	sector offset within log file of data in pbLastSector
	isecPatternFill				= 0;				//	sector to start rewriting the logfile extend pattern
	csecPatternFill				= 0;				//	number of sectors of logfile extent pattern to rewrite
	plread						= pNil;				//	LogReader class pointer
	fDoScan						= fFalse;			//	perform a scan for corruption/torn-write
	fGotQuit					= fFalse;			//	found lrtypQuit or lrtypTerm? ("clean-log" flag)
	fCreatedLogReader			= fFalse;			//	did we allocate a LogReader or are we sharing one?
	fLogToNextLogFile			= fFalse;			//	should we start a new gen. or continue the old one?
	fRecordOkRangeBad			= fFalse;			//	true when the LRCK recors is OK in itself, but its 
													//		range has a bad checksum value
	lgposScan.ib				= 0;				//	position from which to scan for corruption/torn-writes
	lgposScan.isec				= 0;
	lgposScan.lGeneration		= m_plgfilehdr->lgfilehdr.le_lGeneration;
	fTookJump					= fFalse;
	fSingleSectorTornWrite		= fFalse;			//	set when we have a single-sector torn-write
	fSkipScanAndApplyPatch		= fFalse;			//	see where this is set for details about it
	cbChecksum					= 0;				//	number of bytes involved in the last bad checksum
//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//	fWriteOnSectorSizeMismatch	= fFalse;			//	tried to write to the log using a different sector size

#ifdef ENABLE_LOGPATCH_TRACE

	//	compute the path for the trace log

	{
	CHAR	szFolder[ IFileSystemAPI::cchPathMax ];
	CHAR	szT[ IFileSystemAPI::cchPathMax ];

	if (	pfsapi->ErrPathParse( m_szLogName, szFolder, szT, szT ) < JET_errSuccess ||
			pfsapi->ErrPathBuild( szFolder, "LOGPATCH", "TXT", szLogPatchPath ) < JET_errSuccess )
		{
		OSSTRCopyA( szLogPatchPath, "LOGPATCH.TXT" );
		}
	}
#endif	//	ENABLE_LOGPATCH_TRACE

	if ( pfIsPatchable )
		{
		*pfIsPatchable = fFalse;
		}

	//	mark the end of data for redo time

	m_lgposLastRec = lgposCurrent;

	//	lock the log-flush thread

	m_critLGFlush.Enter();

	//	are we looking at edb.log?

	{
		CHAR szT[IFileSystemAPI::cchPathMax], szFNameT[IFileSystemAPI::cchPathMax];

		CallS( pfsapi->ErrPathParse( m_szLogName, szT, szFNameT, szT ) );
		fJetLog = ( UtilCmpFileName( szFNameT, m_szJet ) == 0 );
	}

	//	save the old state

	fOldRecovering = m_fRecovering;
	fOldRecoveringMode = m_fRecoveringMode;

	// doing what we're doing here is similar to recovery in redo mode.
	// Quell UlComputeChecksum()'s checking to see if we're in m_critLGBuf

	m_fRecovering = fTrue;
	m_fRecoveringMode = fRecoveringRedo;

	//	allocate a LogReader class (coming from dump code) or share the existing one (coming from redo code)

	if ( pNil != m_plread )
		{

		//	someone has a log reader setup already 
		//		(must be the recovery code before redoing operations -- not the dump code)
		//		(see ErrLGRRedo(); the first call to this function)

		//	this should only be done by recovery

		Assert( fOldRecovering );

		//	we should not be in read/write mode

		Assert( !fReadOnly );

		plread = m_plread;
		fCreatedLogReader = fFalse;

		//	reset it so we get fresh data from disk

		plread->Reset();

#ifdef DEBUG

		//	make sure the log buffer is large enough for the whole file

		Assert( m_pfapiLog );
		QWORD	cbSize;
		Call( m_pfapiLog->ErrSize( &cbSize ) );

		Assert( m_cbSec > 0 );
		Assert( ( cbSize % m_cbSec ) == 0 );
		UINT	csecSize;
		csecSize = UINT( cbSize / m_cbSec );
		Assert( csecSize > m_csecHeader );

#ifdef AFOXMAN_FIX_148537
		Assert( m_csecLGBuf >= csecSize );
#else	//	!AFOXMAN_FIX_148537
		Assert( m_csecLGBuf <= csecSize );
#endif	//	AFOXMAN_FIX_148537
#endif	//	DEBUG
		}
	else
		{

		//	no one has allocated a log reader yet 
		//		(must be either the recovery code after redoing operation, or the dump code)
		//		(after redo ==> see ErrLGRRedo(); the second call to this function)
		//		(dump code ==> see dump.cxx)

		//	create a log reader

		plread = new LogReader();
		if ( pNil == plread )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		fCreatedLogReader = fTrue;

		//	get the size of the log in sectors

		Assert( m_pfapiLog );
		QWORD	cbSize;
		Call( m_pfapiLog->ErrSize( &cbSize ) );

		Assert( m_cbSec > 0 );
		Assert( ( cbSize % m_cbSec ) == 0 );
		UINT	csecSize;
		csecSize = UINT( cbSize / m_cbSec );
		Assert( csecSize > m_csecHeader );

		//	initialize the log reader

		Call( plread->ErrLReaderInit( this, csecSize ) );
		}

	//	assume the result will not be a cleanly shutdown log generation
	//	   (e.g. we expect not to find an lrtypTerm or lrtypQuit record)

	Assert( pfCloseNormally );
	*pfCloseNormally = fFalse;

#ifndef LOGPATCH_UNIT_TEST

	//	re-open the log in read/write mode if requested by the caller

	Assert( m_pfapiLog );
	if ( !fReadOnly )
		{
		delete m_pfapiLog;
		m_pfapiLog = NULL;
		Assert( NULL != m_szLogName );
		Assert( '\0' != m_szLogName[ 0 ] );
		Call( pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog ) );
		}

#endif	//	!LOGPATCH_UNIT_TEST

	//	make sure we have the right log file

	Call( plread->ErrEnsureLogFile() );

	//	allocate memory for pbLastSector
	
	pbLastSector = reinterpret_cast< BYTE* >( PvOSMemoryHeapAlloc( m_cbSec ) );
	if ( pbNil == pbLastSector )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	// XXX
	// gross temp hack so that entire log buffer is considered in use,
	// so Assert()s don't fire off like crazy, especially in UlComputeChecksum().
	//
	//	??? what is Spencer's comment (above) referring to ???

	//	loop forever while scanning this log generation

	forever
		{

		//	read the first sector and point to the LRCHECKSUM record

		Call( plread->ErrEnsureSector( lgposCurrent.isec, 1, &pbEnsure ) );
		plrck = reinterpret_cast< LRCHECKSUM* >( pbEnsure + lgposCurrent.ib );

		//	we are about to check data in the sector containing the LRCHECKSUM record
		//	we may checksum the whole sector, or we may just verify the LRCHECKSUM record itself through heuristics

		cbChecksum = m_cbSec;

		//	check the validity of the LRCHECKSUM (does not verify the checksum value!)

		if ( !FValidLRCKRecord( plrck, &lgposCurrent ) )
			{

#ifdef ENABLE_LOGPATCH_TRACE
			if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
				{
				ULONG _ibdumpT_;

				(*pcprintfLogPatch)( "invalid LRCK record in logfile %s\r\n", m_szLogName );

				(*pcprintfLogPatch)( "\r\n\tdumping state of ErrLGCheckReadLastLogRecordFF:\r\n" );
				(*pcprintfLogPatch)( "\t\terr                    = %d \r\n", err );
				(*pcprintfLogPatch)( "\t\tlgposCurrent           = {0x%x,0x%x,0x%x}\r\n", lgposCurrent.lGeneration, lgposCurrent.isec, lgposCurrent.ib );
				(*pcprintfLogPatch)( "\t\tlgposLast              = {0x%x,0x%x,0x%x}\r\n", lgposLast.lGeneration, lgposLast.isec, lgposLast.ib  );
				(*pcprintfLogPatch)( "\t\tlgposEnd               = {0x%x,0x%x,0x%x}\r\n", lgposEnd.lGeneration, lgposEnd.isec, lgposEnd.ib );
				(*pcprintfLogPatch)( "\t\tisecLastSector         = %d\r\n", isecLastSector );
				(*pcprintfLogPatch)( "\t\tisecPatternFill        = 0x%x\r\n", isecPatternFill );
				(*pcprintfLogPatch)( "\t\tcsecPatternFill        = 0x%x\r\n", csecPatternFill );
				(*pcprintfLogPatch)( "\t\tfGotQuit               = %s\r\n", ( fGotQuit ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tfCreatedLogReader      = %s\r\n", ( fCreatedLogReader ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tfLogToNextLogFile      = %s\r\n", ( fLogToNextLogFile ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tfDoScan                = %s\r\n", ( fDoScan ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tfOldRecovering         = %s\r\n", ( fOldRecovering ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tfOldRecoveringMode     = %d\r\n", fOldRecoveringMode );
				(*pcprintfLogPatch)( "\t\tfRecordOkRangeBad      = %s\r\n", ( fRecordOkRangeBad ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tlgposScan              = {0x%x,0x%x,0x%x}\r\n", lgposScan.lGeneration, lgposScan.isec, lgposScan.ib );
				(*pcprintfLogPatch)( "\t\tfJetLog                = %s\r\n", ( fJetLog ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tfTookJump              = %s\r\n", ( fTookJump ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tfSingleSectorTornWrite = %s\r\n", ( fSingleSectorTornWrite ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tfSkipScanAndApplyPatch = %s\r\n", ( fSkipScanAndApplyPatch ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tcbChecksum             = 0x%x\r\n", cbChecksum );

				(*pcprintfLogPatch)( "\r\n\tdumping partial state of LOG:\r\n" );
				(*pcprintfLogPatch)( "\t\tLOG::m_fRecovering     = %s\r\n", ( m_fRecovering ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tLOG::m_fRecoveringMode = %d\r\n", m_fRecoveringMode );
				(*pcprintfLogPatch)( "\t\tLOG::m_fHardRestore    = %s\r\n", ( m_fHardRestore ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tLOG::m_fRestoreMode    = %d\r\n", m_fRestoreMode );
				(*pcprintfLogPatch)( "\t\tLOG::m_csecLGFile      = 0x%08x\r\n", m_csecLGFile );
				(*pcprintfLogPatch)( "\t\tLOG::m_csecLGBuf       = 0x%08x\r\n", m_csecLGBuf );
				(*pcprintfLogPatch)( "\t\tLOG::m_csecHeader      = %d\r\n", m_csecHeader );
				(*pcprintfLogPatch)( "\t\tLOG::m_cbSec           = %d\r\n", m_cbSec );
				(*pcprintfLogPatch)( "\t\tLOG::m_cbSecVolume     = %d\r\n", m_cbSecVolume );
				(*pcprintfLogPatch)( "\t\tLOG::m_pbLGBufMin      = 0x%0*I64x\r\n", sizeof( char* ) * 2, QWORD( m_pbLGBufMin ) );
				(*pcprintfLogPatch)( "\t\tLOG::m_pbLGBufMax      = 0x%0*I64x\r\n", sizeof( char* ) * 2, QWORD( m_pbLGBufMax ) );
				(*pcprintfLogPatch)( "\t\tLOG::m_pbWrite         = 0x%0*I64x\r\n", sizeof( char* ) * 2, QWORD( m_pbWrite ) );
				(*pcprintfLogPatch)( "\t\tLOG::m_pbEntry         = 0x%0*I64x: 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\r\n", sizeof( char* ) * 2, QWORD( m_pbEntry ), m_pbEntry[0], m_pbEntry[1], m_pbEntry[2], m_pbEntry[3], m_pbEntry[4], m_pbEntry[5], m_pbEntry[6], m_pbEntry[7] );
				(*pcprintfLogPatch)( "\t\tLOG::m_isecWrite       = 0x%08x\r\n", m_isecWrite );

				(*pcprintfLogPatch)( "\r\n\tdumping data:\r\n" );

				(*pcprintfLogPatch)( "\t\tplrck (0x%0*I64x)\r\n", sizeof( char* ) * 2, QWORD( plrck ) );
				(*pcprintfLogPatch)( "\t\t  cbBackwards       = 0x%08x\r\n", plrck->le_cbBackwards );
				(*pcprintfLogPatch)( "\t\t  cbForwards        = 0x%08x\r\n", plrck->le_cbForwards );
				(*pcprintfLogPatch)( "\t\t  cbNext            = 0x%08x\r\n", plrck->le_cbNext );
				(*pcprintfLogPatch)( "\t\t  ulChecksum        = 0x%08x\r\n", plrck->le_ulChecksum );
				(*pcprintfLogPatch)( "\t\t  ulShortChecksum   = 0x%08x\r\n", plrck->le_ulShortChecksum );
				(*pcprintfLogPatch)( "\t\t  bUseShortChecksum = %s (0x%02x)\r\n", 
									( bShortChecksumOn == plrck->bUseShortChecksum ?
									  "Yes" : 
									  ( bShortChecksumOff == plrck->bUseShortChecksum ?
									    "No" : "???" ) ),
									BYTE( plrck->bUseShortChecksum ) );

				(*pcprintfLogPatch)( "\t\tpbEnsure (0x%0*I64x)\r\n", sizeof( char* ) * 2, QWORD( pbEnsure ) );

				_ibdumpT_ = 0;
				while ( _ibdumpT_ < m_cbSec )
					{
					(*pcprintfLogPatch)( "\t\t0x%04x: %02x %02x %02x %02x %02x %02x %02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\r\n",
										_ibdumpT_,
										pbEnsure[_ibdumpT_+0],  pbEnsure[_ibdumpT_+1],  pbEnsure[_ibdumpT_+2],  pbEnsure[_ibdumpT_+3],
										pbEnsure[_ibdumpT_+4],  pbEnsure[_ibdumpT_+5],  pbEnsure[_ibdumpT_+6],  pbEnsure[_ibdumpT_+7],
										pbEnsure[_ibdumpT_+8],  pbEnsure[_ibdumpT_+9],  pbEnsure[_ibdumpT_+10], pbEnsure[_ibdumpT_+11],
										pbEnsure[_ibdumpT_+12], pbEnsure[_ibdumpT_+13], pbEnsure[_ibdumpT_+14], pbEnsure[_ibdumpT_+15] );
					_ibdumpT_ += 16;
					Assert( _ibdumpT_ <= m_cbSec );
					}

				(*pcprintfLogPatch)( "\t\tpbLastSector (0x%0*I64x)\r\n", sizeof( char* ) * 2, QWORD( pbLastSector ) );

				_ibdumpT_ = 0;
				while ( _ibdumpT_ < m_cbSec )
					{
					(*pcprintfLogPatch)( "\t\t0x%04x: %02x %02x %02x %02x %02x %02x %02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\r\n",
										_ibdumpT_,
										pbLastSector[_ibdumpT_+0],  pbLastSector[_ibdumpT_+1],  pbLastSector[_ibdumpT_+2],  pbLastSector[_ibdumpT_+3],
										pbLastSector[_ibdumpT_+4],  pbLastSector[_ibdumpT_+5],  pbLastSector[_ibdumpT_+6],  pbLastSector[_ibdumpT_+7],
										pbLastSector[_ibdumpT_+8],  pbLastSector[_ibdumpT_+9],  pbLastSector[_ibdumpT_+10], pbLastSector[_ibdumpT_+11],
										pbLastSector[_ibdumpT_+12], pbLastSector[_ibdumpT_+13], pbLastSector[_ibdumpT_+14], pbLastSector[_ibdumpT_+15] );
					_ibdumpT_ += 16;
					Assert( _ibdumpT_ <= m_cbSec );
					}

				if ( pbLastChecksum )
					{
					LRCHECKSUM *_plrckT_ = (LRCHECKSUM *)pbLastChecksum;

					(*pcprintfLogPatch)( "\t\tpbLastChecksum (0x%0*I64x)\r\n", sizeof( char* ) * 2, QWORD( _plrckT_ ) );
					(*pcprintfLogPatch)( "\t\t  cbBackwards       = 0x%08x\r\n", _plrckT_->le_cbBackwards );
					(*pcprintfLogPatch)( "\t\t  cbForwards        = 0x%08x\r\n", _plrckT_->le_cbForwards );
					(*pcprintfLogPatch)( "\t\t  cbNext            = 0x%08x\r\n", _plrckT_->le_cbNext );
					(*pcprintfLogPatch)( "\t\t  ulChecksum        = 0x%08x\r\n", _plrckT_->le_ulChecksum );
					(*pcprintfLogPatch)( "\t\t  ulShortChecksum   = 0x%08x\r\n", _plrckT_->le_ulShortChecksum );
					(*pcprintfLogPatch)( "\t\t  bUseShortChecksum = %s (0x%02x)\r\n", 
										( bShortChecksumOn == _plrckT_->bUseShortChecksum ?
										  "Yes" : 
										  ( bShortChecksumOff == _plrckT_->bUseShortChecksum ?
										    "No" : "???" ) ),
										BYTE( _plrckT_->bUseShortChecksum ) );
					}
				else
					{
					(*pcprintfLogPatch)( "\t\tpbLastChecksum (null)\r\n" );
					}

				(*pcprintfLogPatch)( "\r\n" );
				}
#endif	//	ENABLE_LOGPATCH_TRACE

			//	remember that we got here by not having a valid record
			
			fTookJump = fFalse;

RecoverWithShadow:

			//	the LRCHECKSUM is invalid; revert to the shadow sector (if there is one)

			//	read the shadow sector and point to the LRCHECKSUM record
			
			Call( plread->ErrEnsureSector( lgposCurrent.isec + 1, 1, &pbEnsure ) );
			plrck = reinterpret_cast< LRCHECKSUM* >( pbEnsure + lgposCurrent.ib );

			//	check the validity of the shadowed LRCHECKSUM including the checksum value
			//		(we can verify the checksum value here because we know the data doesn't go
			//		 past the end of the shadow sector -- thus, we don't need to bring in more data)

			if ( !FValidLRCKShadow( plrck, &lgposCurrent, m_plgfilehdr->lgfilehdr.le_lGeneration ) )
				{
#ifdef ENABLE_LOGPATCH_TRACE
				if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
					{
					(*pcprintfLogPatch)( "invalid shadow in sector 0x%x (%d)\r\n", 
										lgposCurrent.isec + 1,
										lgposCurrent.isec + 1 );

					(*pcprintfLogPatch)( "\t\tpbEnsure (0x%0*I64x)\r\n", sizeof( char* ) * 2, QWORD( pbEnsure ) );

					ULONG _ibdumpT_ = 0;
					while ( _ibdumpT_ < m_cbSec )
						{
						(*pcprintfLogPatch)( "\t\t0x%04x: %02x %02x %02x %02x %02x %02x %02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\r\n",
											_ibdumpT_,
											pbEnsure[_ibdumpT_+0],  pbEnsure[_ibdumpT_+1],  pbEnsure[_ibdumpT_+2],  pbEnsure[_ibdumpT_+3],
											pbEnsure[_ibdumpT_+4],  pbEnsure[_ibdumpT_+5],  pbEnsure[_ibdumpT_+6],  pbEnsure[_ibdumpT_+7],
											pbEnsure[_ibdumpT_+8],  pbEnsure[_ibdumpT_+9],  pbEnsure[_ibdumpT_+10], pbEnsure[_ibdumpT_+11],
											pbEnsure[_ibdumpT_+12], pbEnsure[_ibdumpT_+13], pbEnsure[_ibdumpT_+14], pbEnsure[_ibdumpT_+15] );
						_ibdumpT_ += 16;
						Assert( _ibdumpT_ <= m_cbSec );
						}
					}
#endif	//	ENABLE_LOGPATCH_TRACE

				//	the shadowed LRCHECKSUM is also invalid

				//	one special case exists where we can still be ok in this situation:
				//		if the last LRCHECKSUM range (which was validated previously) covers 1 sector,
				//		and it was the last flush because we terminated abruptly, the disk would
				//		contain that last LRCHECKSUM record with a shadowed copy of it, followed by 
				//		the log-extend pattern; this is a TORN-WRITE case, but the shadow is getting
				//		in the way and making it hard for us to see things clearly

				//	we must have an invalid LRCHECKSUM record and the last sector must be 1 away 
				//		from the current sector

				if ( !fTookJump && lgposCurrent.isec == lgposLast.isec + 1 )
					{

					//	make sure we have a valid lgposLast -- we should

					Assert( lgposLast.isec >= m_csecHeader && lgposLast.isec < ( m_csecLGFile - 1 ) );
					
					//	load data from the previous sector and the current sector

					Call( plread->ErrEnsureSector( lgposLast.isec, 2, &pbEnsure ) );

					//	set the LRCHECKSUM pointer

					plrck = (LRCHECKSUM *)( pbEnsure + lgposLast.ib );

					//	make sure things are as they should be

					AssertValidLRCKRecord( plrck, &lgposLast );
					AssertValidLRCKRange( plrck, lgposLast.lGeneration );
					Assert( plrck->bUseShortChecksum == bShortChecksumOff );
					Assert( plrck->le_cbNext != 0 );
					Assert( lgposLast.ib + sizeof( LRCHECKSUM ) + plrck->le_cbForwards == m_cbSec );

					//	move to the supposedly shadowed LRCHECKSUM record

					plrck = (LRCHECKSUM *)( pbEnsure + m_cbSec + lgposLast.ib );

					//	see if this is in fact a valid shadow sector (use the special shadow validation)

					if ( FValidLRCKShadowWithoutCheckingCBNext( plrck, &lgposLast, lgposLast.lGeneration ) )
						{
#ifdef ENABLE_LOGPATCH_TRACE
						if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
							{
							(*pcprintfLogPatch)( "special case!\r\n" );
							(*pcprintfLogPatch)( "\tlgposCurrent is NOT pointing to the next LRCHECKSUM record because we crashed before we could write it\r\n" );
							(*pcprintfLogPatch)( "\tinstead, it is pointing to a shadow of the >>LAST<< LRCHECKSUM record (lgposLast)\r\n" );
							}
#endif	//	ENABLE_LOGPATCH_TRACE

						//	indeed we are looking at a shadow sector! this means we have torn-write
						//	set things up for a special scan to make sure we do have the pattern everywhere

						//	this should only happen in edb.log -- all other logs should be clean or corrupt
						//		(they should never have a torn-write)

						Assert( fJetLog );

						//	setup for a scan

						fDoScan = fTrue;

						//	mark the end of data as the start of the shadow sector

						lgposEnd.isec = lgposCurrent.isec;
						lgposEnd.ib = 0;

						//	prepare a special scan which starts after the shadow sector

						lgposScan = lgposEnd;
						AddLgpos( &lgposScan, m_cbSec );

						//	mark the end of data for redo time

						m_lgposLastRec = lgposEnd;

						//	prepare pbLastSector with data for the next flush which will occur after we
						//		exit the "forever" loop

						//	copy the last LRCHECKSUM record 
				
						UtilMemCpy( pbLastSector, pbEnsure, m_cbSec );

						//	set the pointers to the copy of the sector with the LRCHECKSUM record
				
						pbLastChecksum = pbLastSector + lgposLast.ib;
						isecLastSector = lgposLast.isec;

						//	remember that this has the potential to be a single-sector torn-write

						fSingleSectorTornWrite = fTrue;

						//	terminate the "forever" loop

						break;
						}
					}


				//	we need to do a scan to determine what kind of damage occurred

				fDoScan = fTrue;

				//	NOTE: since we haven't found a good LRCHECKSUM record, 
				//		lgposLast remains pointing to the last good LRCHECKSUM record we found 
				//		(unless we haven't seen even one, in which case lgposLast.isec == 0)

				//	set lgposEnd to indicate that the garbage to scan starts at the current sector, offset 0

				lgposEnd.isec = lgposCurrent.isec;
				lgposEnd.ib = 0;

				//	start the scan at lgposEnd

				lgposScan = lgposEnd;
				
				//	mark the end of data for redo time

				m_lgposLastRec = lgposEnd;

				//	prepare pbLastSector with data for the next flush which will occur after we
				//		exit the "forever" loop

				pbLastChecksum = pbLastSector + lgposCurrent.ib;

//
//	LEAVE THE OLD DATA THERE! DO NOT FILL THE SPACE WITH THE PATTERN!
//
//				// fill with known value, so if we ever use the filled data we'll know it (hopefully)
//
//				Assert( cbLogExtendPattern > lgposCurrent.ib );
//				Assert( rgbLogExtendPattern );
//				memcpy( pbLastSector, rgbLogExtendPattern, lgposCurrent.ib );

				//	prepare the new LRCHECKSUM record
				
				plrck = reinterpret_cast< LRCHECKSUM* >( pbLastChecksum );
				memset( pbLastChecksum, 0, sizeof( LRCHECKSUM ) );
				plrck->lrtyp = lrtypChecksum;
				plrck->bUseShortChecksum = bShortChecksumOff;

				//	NOTE: we leave the backward pointer set to 0 to cover the case where the head of
				//			  a partial log record was written in the last sector, but the tail of that
				//			  record was never written safely to this sector (we just filled the space
				//			  where the tail was with log-extend pattern)
				//		  the partial log record will be ignored when we scan record by record later on
				//			  in this function
				
				isecLastSector = lgposCurrent.isec;

				//	terminate the "forever" loop

				break;
				}

#ifdef ENABLE_LOGPATCH_TRACE
			if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
				{
				(*pcprintfLogPatch)( "shadow is OK -- we will patch with it (unless we are in read-only mode)\r\n" );

				(*pcprintfLogPatch)( "\r\n\t\tpbEnsure (0x%0*I64x)\r\n", sizeof( char* ) * 2, QWORD( pbEnsure ) );

				ULONG _ibdumpT_ = 0;
				while ( _ibdumpT_ < m_cbSec )
					{
					(*pcprintfLogPatch)( "\t\t0x%04x: %02x %02x %02x %02x %02x %02x %02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\r\n",
										_ibdumpT_,
										pbEnsure[_ibdumpT_+0],  pbEnsure[_ibdumpT_+1],  pbEnsure[_ibdumpT_+2],  pbEnsure[_ibdumpT_+3],
										pbEnsure[_ibdumpT_+4],  pbEnsure[_ibdumpT_+5],  pbEnsure[_ibdumpT_+6],  pbEnsure[_ibdumpT_+7],
										pbEnsure[_ibdumpT_+8],  pbEnsure[_ibdumpT_+9],  pbEnsure[_ibdumpT_+10], pbEnsure[_ibdumpT_+11],
										pbEnsure[_ibdumpT_+12], pbEnsure[_ibdumpT_+13], pbEnsure[_ibdumpT_+14], pbEnsure[_ibdumpT_+15] );
					_ibdumpT_ += 16;
					Assert( _ibdumpT_ <= m_cbSec );
					}
				}
#endif	//	ENABLE_LOGPATCH_TRACE
				
			//	the shadowed LRCHECKSUM is valid and has a good checksum value

			//	this means we are definitely at the end of the log, and we can repair the corruption
			//		using the shadow sector (make repairs quietly except for an event-log message)
			//
			//	NOTE: it doesn't matter which recovery mode we are in or which log file we are dealing
			//		  with -- shadow sectors can ALWAYS be patched!

			Assert( plrck->le_cbNext == 0 );
			Assert( ( plrck->le_cbBackwards + sizeof( LRCHECKSUM ) + plrck->le_cbForwards ) <= m_cbSec );

			//	if we are in read-only mode, we cannot patch anything (dump code uses this mode)

			if ( fReadOnly )
				{

				//	try to make sure this really is the dump code

				Assert( fOldRecovering && fOldRecoveringMode == fRecoveringNone );
				Assert( !m_fHardRestore );
				Assert( fCreatedLogReader );

				//	mark the end of data for redo time

				m_lgposLastRec = lgposCurrent;
				m_lgposLastRec.ib = 0;
				
				if ( pfIsPatchable )
					{

					//	the caller wants to know if the log is patchable
					//	by returning TRUE, we imply that the log is damaged so we don't need to return 
					//		an error as well

					*pfIsPatchable = fTrue;
					err = JET_errSuccess;
					goto HandleError;
					}
				else
					{
					//  report log file corruption to the event log

					const QWORD		ibOffset	= QWORD( lgposCurrent.isec ) * QWORD( m_cbSec );
					const DWORD		cbLength	= cbChecksum;
					
					const _TCHAR*	rgpsz[ 4 ];
					DWORD			irgpsz		= 0;
					_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
					_TCHAR			szOffset[ 64 ];
					_TCHAR			szLength[ 64 ];
					_TCHAR			szError[ 64 ];

					if ( m_pfapiLog->ErrPath( szAbsPath ) < JET_errSuccess )
						{
						OSSTRCopy( szAbsPath, _T( "<< cannot get filepath >>" ) );
						}
					_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibOffset, ibOffset );
					_stprintf( szLength, _T( "%u (0x%08x)" ), cbLength, cbLength );
					_stprintf( szError, _T( "%i (0x%08x)" ), JET_errLogFileCorrupt, JET_errLogFileCorrupt );

					rgpsz[ irgpsz++ ]	= szAbsPath;
					rgpsz[ irgpsz++ ]	= szOffset;
					rgpsz[ irgpsz++ ]	= szLength;
					rgpsz[ irgpsz++ ]	= szError;


					UtilReportEvent(	eventError,
										LOGGING_RECOVERY_CATEGORY,
										LOG_RANGE_CHECKSUM_MISMATCH_ID,
										irgpsz,
										rgpsz );
										
					//	return corruption

					Call( ErrERRCheck( JET_errLogFileCorrupt ) );
					}
				}

			//	do not scan since we are going to repair the corruption

			fDoScan = fFalse;

			//	send the event-log message

			const ULONG	csz = 1;
			const CHAR 	*rgpsz[csz] = { m_szLogName };
				
			UtilReportEvent(	eventWarning,
								LOGGING_RECOVERY_CATEGORY, 
								LOG_USING_SHADOW_SECTOR_ID, 
								csz, 
								rgpsz );

			//	before patching the original LRCHECKSUM record with the shadowed LRCHECKSUM record,
			//		recalculate the checksum value since shadowed checksum values are different

			plrck->le_ulChecksum = UlComputeChecksum( plrck, m_plgfilehdr->lgfilehdr.le_lGeneration );

			//	patch the original LRCHECKSUM record

//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
Assert( m_cbSec == m_cbSecVolume );
//			if ( m_cbSec == m_cbSecVolume )
//				{
				CallJ( m_pfapiLog->ErrIOWrite( m_cbSec * QWORD( lgposCurrent.isec ), m_cbSec, pbEnsure ), LHandleErrorWrite );
				plread->SectorModified( lgposCurrent.isec, pbEnsure );
//				}
//			else
//				{
//				fWriteOnSectorSizeMismatch = fTrue;
//				}

			//	check for data after the LRCHECKSUM (at most, it will run to the end of the sector)

			if ( plrck->le_cbForwards == 0 )
				{

				//	no forward data was found
				//
				//	in this case, we want to search for the lrtypTerm and/or lrtypRecoveryQuit 
				//		log records up to and including the current LRCHECKSUM record
				//		(e.g. the forward range of the last LRCHECKSUM and the backward 
				//			  range of this LRCHECKSUM)
				
				//	to make the search work, we must setup lgposLast and lgposEnd: 
				//		we leave lgposLast (the last valid LRCHECKSUM we found) pointing at the 
				//			previous LRCHECKSUM even though we just patched and made valid
				//			the current LRCHECKSUM at lgposCurrent
				//		we set lgposEnd (the point to stop searching) to the position 
				//			immediately after this LRCHECKSUM since this LRCHECKSUM had no
				//			forward data

				lgposEnd = lgposCurrent;
				AddLgpos( &lgposEnd, sizeof( LRCHECKSUM ) );
				}
			else
				{

				//	forward data was found
				//
				//	in this case, we want to search for the lrtypTerm and/or lrtypRecoveryQuit 
				//		log records within the backward data of the patched LRCHECKSUM

				//	set lgposLast (the last valid LRCHECKSUM record) to the current LRCHECKSUM
					
				lgposLast = lgposCurrent;

				//	set lgposEnd (the point after the last good data) to the first byte after
				//		the forward range of this LRCHECKSUM

				lgposEnd = lgposCurrent;
				Assert( plrck->le_cbBackwards == lgposCurrent.ib || 0 == plrck->le_cbBackwards );
				AddLgpos( &lgposEnd, sizeof( LRCHECKSUM ) + plrck->le_cbForwards );
				}

			//	mark the end of data for redo time

			m_lgposLastRec = lgposEnd;

			//	prepare pbLastSector with data for the next flush which will occur after we
			//		exit the "forever" loop

			//	copy the patched shadow sector (contains the real LRCHECKSUM at this point)
				
			UtilMemCpy( pbLastSector, pbEnsure, m_cbSec );

			//	set the pointers to the copy of the sector with the patched LRCHECKSUM
				
			pbLastChecksum = pbLastSector + lgposCurrent.ib;
			isecLastSector = lgposCurrent.isec;	

			//	terminate the "forever" loop

			break;
			}


		//	at this point, the LRCHECKSUM record is definitely valid
		//	however, we still need to verify the checksum value over its range

		//	load the rest of the data in the range of this LRCHECKSUM

		Call( plread->ErrEnsureSector( lgposCurrent.isec, ( ( lgposCurrent.ib +
			sizeof( LRCHECKSUM ) + plrck->le_cbForwards - 1 ) / m_cbSec ) + 1,
			&pbEnsure ) );

		//	adjust the pointer to the current LRCHECKSUM record 
		//		(it may have moved when reading in new sectors in ErrEnsureSector )
		
		plrck = reinterpret_cast< LRCHECKSUM* >( pbEnsure + lgposCurrent.ib );

		//	we are about to check data in the range of the LRCHECKSUM record

		cbChecksum = lgposCurrent.ib + sizeof( LRCHECKSUM ) + plrck->le_cbForwards;

		//	verify the checksum value

		if ( !FValidLRCKRange( plrck, m_plgfilehdr->lgfilehdr.le_lGeneration ) )
			{

#ifdef ENABLE_LOGPATCH_TRACE
			if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
				{
				ULONG _ibdumpT_;

				(*pcprintfLogPatch)( "invalid LRCK range in logfile %s\r\n", m_szLogName );

				(*pcprintfLogPatch)( "\r\n\tdumping state of ErrLGCheckReadLastLogRecordFF:\r\n" );
				(*pcprintfLogPatch)( "\t\terr                    = %d \r\n", err );
				(*pcprintfLogPatch)( "\t\tlgposCurrent           = {0x%x,0x%x,0x%x}\r\n", lgposCurrent.lGeneration, lgposCurrent.isec, lgposCurrent.ib );
				(*pcprintfLogPatch)( "\t\tlgposLast              = {0x%x,0x%x,0x%x}\r\n", lgposLast.lGeneration, lgposLast.isec, lgposLast.ib  );
				(*pcprintfLogPatch)( "\t\tlgposEnd               = {0x%x,0x%x,0x%x}\r\n", lgposEnd.lGeneration, lgposEnd.isec, lgposEnd.ib );
				(*pcprintfLogPatch)( "\t\tisecLastSector         = %d\r\n", isecLastSector );
				(*pcprintfLogPatch)( "\t\tisecPatternFill        = 0x%x\r\n", isecPatternFill );
				(*pcprintfLogPatch)( "\t\tcsecPatternFill        = 0x%x\r\n", csecPatternFill );
				(*pcprintfLogPatch)( "\t\tfGotQuit               = %s\r\n", ( fGotQuit ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tfCreatedLogReader      = %s\r\n", ( fCreatedLogReader ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tfLogToNextLogFile      = %s\r\n", ( fLogToNextLogFile ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tfDoScan                = %s\r\n", ( fDoScan ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tfOldRecovering         = %s\r\n", ( fOldRecovering ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tfOldRecoveringMode     = %d\r\n", fOldRecoveringMode );
				(*pcprintfLogPatch)( "\t\tfRecordOkRangeBad      = %s\r\n", ( fRecordOkRangeBad ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tlgposScan              = {0x%x,0x%x,0x%x}\r\n", lgposScan.lGeneration, lgposScan.isec, lgposScan.ib );
				(*pcprintfLogPatch)( "\t\tfJetLog                = %s\r\n", ( fJetLog ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tfTookJump              = %s\r\n", ( fTookJump ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tfSingleSectorTornWrite = %s\r\n", ( fSingleSectorTornWrite ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tfSkipScanAndApplyPatch = %s\r\n", ( fSkipScanAndApplyPatch ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tcbChecksum             = 0x%x\r\n", cbChecksum );

				(*pcprintfLogPatch)( "\r\n\tdumping partial state of LOG:\r\n" );
				(*pcprintfLogPatch)( "\t\tLOG::m_fRecovering     = %s\r\n", ( m_fRecovering ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tLOG::m_fRecoveringMode = %d\r\n", m_fRecoveringMode );
				(*pcprintfLogPatch)( "\t\tLOG::m_fHardRestore    = %s\r\n", ( m_fHardRestore ? "TRUE" : "FALSE" ) );
				(*pcprintfLogPatch)( "\t\tLOG::m_fRestoreMode    = %d\r\n", m_fRestoreMode );
				(*pcprintfLogPatch)( "\t\tLOG::m_csecLGFile      = 0x%08x\r\n", m_csecLGFile );
				(*pcprintfLogPatch)( "\t\tLOG::m_csecLGBuf       = 0x%08x\r\n", m_csecLGBuf );
				(*pcprintfLogPatch)( "\t\tLOG::m_csecHeader      = %d\r\n", m_csecHeader );
				(*pcprintfLogPatch)( "\t\tLOG::m_cbSec           = %d\r\n", m_cbSec );
				(*pcprintfLogPatch)( "\t\tLOG::m_cbSecVolume     = %d\r\n", m_cbSecVolume );
				(*pcprintfLogPatch)( "\t\tLOG::m_pbLGBufMin      = 0x%0*I64x\r\n", sizeof( char* ) * 2, QWORD( m_pbLGBufMin ) );
				(*pcprintfLogPatch)( "\t\tLOG::m_pbLGBufMax      = 0x%0*I64x\r\n", sizeof( char* ) * 2, QWORD( m_pbLGBufMax ) );
				(*pcprintfLogPatch)( "\t\tLOG::m_pbWrite         = 0x%0*I64x\r\n", sizeof( char* ) * 2, QWORD( m_pbWrite ) );
				(*pcprintfLogPatch)( "\t\tLOG::m_pbEntry         = 0x%0*I64x: 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\r\n", sizeof( char* ) * 2, QWORD( m_pbEntry ), m_pbEntry[0], m_pbEntry[1], m_pbEntry[2], m_pbEntry[3], m_pbEntry[4], m_pbEntry[5], m_pbEntry[6], m_pbEntry[7] );
				(*pcprintfLogPatch)( "\t\tLOG::m_isecWrite       = 0x%08x\r\n", m_isecWrite );

				(*pcprintfLogPatch)( "\r\n\tdumping data:\r\n" );

				(*pcprintfLogPatch)( "\t\tplrck (0x%0*I64x)\r\n", sizeof( char* ) * 2, QWORD( plrck ) );
				(*pcprintfLogPatch)( "\t\t  cbBackwards       = 0x%08x\r\n", plrck->le_cbBackwards );
				(*pcprintfLogPatch)( "\t\t  cbForwards        = 0x%08x\r\n", plrck->le_cbForwards );
				(*pcprintfLogPatch)( "\t\t  cbNext            = 0x%08x\r\n", plrck->le_cbNext );
				(*pcprintfLogPatch)( "\t\t  ulChecksum        = 0x%08x\r\n", plrck->le_ulChecksum );
				(*pcprintfLogPatch)( "\t\t  ulShortChecksum   = 0x%08x\r\n", plrck->le_ulShortChecksum );
				(*pcprintfLogPatch)( "\t\t  bUseShortChecksum = %s (0x%02x)\r\n", 
									( bShortChecksumOn == plrck->bUseShortChecksum ?
									  "Yes" : 
									  ( bShortChecksumOff == plrck->bUseShortChecksum ?
									    "No" : "???" ) ),
									BYTE( plrck->bUseShortChecksum ) );

				(*pcprintfLogPatch)( "\t\tpbEnsure (0x%0*I64x)\r\n", sizeof( char* ) * 2, QWORD( pbEnsure ) );

				_ibdumpT_ = 0;
				while ( _ibdumpT_ < m_cbSec )
					{
					(*pcprintfLogPatch)( "\t\t0x%04x: %02x %02x %02x %02x %02x %02x %02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\r\n",
										_ibdumpT_,
										pbEnsure[_ibdumpT_+0],  pbEnsure[_ibdumpT_+1],  pbEnsure[_ibdumpT_+2],  pbEnsure[_ibdumpT_+3],
										pbEnsure[_ibdumpT_+4],  pbEnsure[_ibdumpT_+5],  pbEnsure[_ibdumpT_+6],  pbEnsure[_ibdumpT_+7],
										pbEnsure[_ibdumpT_+8],  pbEnsure[_ibdumpT_+9],  pbEnsure[_ibdumpT_+10], pbEnsure[_ibdumpT_+11],
										pbEnsure[_ibdumpT_+12], pbEnsure[_ibdumpT_+13], pbEnsure[_ibdumpT_+14], pbEnsure[_ibdumpT_+15] );
					_ibdumpT_ += 16;
					Assert( _ibdumpT_ <= m_cbSec );
					}

				(*pcprintfLogPatch)( "\t\tpbLastSector (0x%0*I64x)\r\n", sizeof( char* ) * 2, QWORD( pbLastSector ) );

				_ibdumpT_ = 0;
				while ( _ibdumpT_ < m_cbSec )
					{
					(*pcprintfLogPatch)( "\t\t0x%04x: %02x %02x %02x %02x %02x %02x %02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\r\n",
										_ibdumpT_,
										pbLastSector[_ibdumpT_+0],  pbLastSector[_ibdumpT_+1],  pbLastSector[_ibdumpT_+2],  pbLastSector[_ibdumpT_+3],
										pbLastSector[_ibdumpT_+4],  pbLastSector[_ibdumpT_+5],  pbLastSector[_ibdumpT_+6],  pbLastSector[_ibdumpT_+7],
										pbLastSector[_ibdumpT_+8],  pbLastSector[_ibdumpT_+9],  pbLastSector[_ibdumpT_+10], pbLastSector[_ibdumpT_+11],
										pbLastSector[_ibdumpT_+12], pbLastSector[_ibdumpT_+13], pbLastSector[_ibdumpT_+14], pbLastSector[_ibdumpT_+15] );
					_ibdumpT_ += 16;
					Assert( _ibdumpT_ <= m_cbSec );
					}

				if ( pbLastChecksum )
					{
					LRCHECKSUM *_plrckT_ = (LRCHECKSUM *)pbLastChecksum;

					(*pcprintfLogPatch)( "\t\tpbLastChecksum (0x%0*I64x)\r\n", sizeof( char* ) * 2, QWORD( _plrckT_ ) );
					(*pcprintfLogPatch)( "\t\t  cbBackwards       = 0x%08x\r\n", _plrckT_->le_cbBackwards );
					(*pcprintfLogPatch)( "\t\t  cbForwards        = 0x%08x\r\n", _plrckT_->le_cbForwards );
					(*pcprintfLogPatch)( "\t\t  cbNext            = 0x%08x\r\n", _plrckT_->le_cbNext );
					(*pcprintfLogPatch)( "\t\t  ulChecksum        = 0x%08x\r\n", _plrckT_->le_ulChecksum );
					(*pcprintfLogPatch)( "\t\t  ulShortChecksum   = 0x%08x\r\n", _plrckT_->le_ulShortChecksum );
					(*pcprintfLogPatch)( "\t\t  bUseShortChecksum = %s (0x%02x)\r\n", 
										( bShortChecksumOn == _plrckT_->bUseShortChecksum ?
										  "Yes" : 
										  ( bShortChecksumOff == _plrckT_->bUseShortChecksum ?
										    "No" : "???" ) ),
										BYTE( _plrckT_->bUseShortChecksum ) );
					}
				else
					{
					(*pcprintfLogPatch)( "\t\tpbLastChecksum (null)\r\n" );
					}

				(*pcprintfLogPatch)( "\r\n" );
				}
#endif	//	ENABLE_LOGPATCH_TRACE
			
			//	the checksum over the entire range of the LRCHECKSUM record is wrong

			//	do we have a short checksum?

			if ( plrck->bUseShortChecksum == bShortChecksumOn )
				{

				//	we have a short checksum, so we know that the first sector is valid and that the range
				//		of this LRCHECKSUM record is a multi-sector range

				//	we are either in the middle of the log file (most likely), or we are at the end of a
				//		generation whose last flush was a multisector flush (unlikely -- special case)

				//	in either case, this may really be the end of the log data!
				//		middle of log case: just say the power went out as we were flushing and the first few
				//		  (cbNext != 0)		sectors went to disk (including the LRCHECKSUM), but the rest did not
				//							make it; that would make it look like we are in the middle of the log
				//							when we are really at the end of it
				//		end of log case:    we already know we were at the end of the log!
				//		  (cbNext == 0)

				//	to see if this is the real end of the log, we must scan through data after the "forward" 
				//		range of the current LRCHECKSUM record (lgposCurrent) all the way through to the end 
				//		of the log file
				//	
				//	if we find nothing but the log pattern, we can recover up this point and say that this is 
				//		as far as we can safely go -- the last little bit of data is an incomplete fragment of 
				//		our last flush during whatever caused us to crash, and as far as we are concerned,
				//		it is a casualty of the crash!
				//	if we do find something besides the log pattern, then we know there is some other log data
				//		out there, and we cannot safely say that we have restored as much information as possible

				//	set the flag to perform the corruption/torn-write scan

				fDoScan = fTrue;

				//	set lgposLast to the current LRCHECKSUM record

				lgposLast = lgposCurrent;

				//	set lgposEnd to indicate that the end of good data is the end of the current sector
			
				lgposEnd.isec = lgposCurrent.isec;
				lgposEnd.ib = 0;
				AddLgpos( &lgposEnd, m_cbSec );

				//	mark the end of data for redo time

				m_lgposLastRec = lgposEnd;

				//	start the scan at the end of the data in the range of this LRCHECKSUM record

				lgposScan = lgposCurrent;
				AddLgpos( &lgposScan, sizeof( LRCHECKSUM ) + plrck->le_cbForwards );
				
				//	this should be sector-aligned since it was a multi-sector flush
			
				Assert( lgposScan.ib == 0 );

				//	flag to defer adjusting the forward pointer until later
				//		(also indicates that the flush was a multi-sector range with a bad sector
				//		 somewhere past the first sector)

				fRecordOkRangeBad = fTrue;

				//	NOTE: leave pbLastSector alone for now -- see the comment below to know when it gets updated
			
				//	NOTE: if the corruption is fixable, 
				//			  le_cbForwards will be properly adjusted after the fixup to include data from only
				//				  the current sector
				//			  the fixed up sector will be copied to pbLastSector
				//
				//			  << other thing happen and we eventually get to the cleanup code >>
				//
				//			  the cleanup code will take the last sector and put it onto the log buffers 
				//				  as a single sector marked for the start of the next flush

				//	terminate the "forever" loop

				break;
				}

			//	we do not have a short checksum

			//	make sure the bUseShortChecksum flag is definitely set to OFF
			
			Assert( plrck->bUseShortChecksum == bShortChecksumOff );

			//	SPECIAL CASE: the log may look like this
			//
			//	 /---\  /---\ /---\  /---\
			//	|----|--|----|----|--|----|------------
			//	|???(LRCK)???|???(LRCK)???|  pattern 
			//	|-------|----|-------|----|------------
			//          \--------/   \->NULL
			//
			//	 last sector    shadow(old)
			//
			//
			//	NOTE: the cbNext ptr in "last sector" happens to point to the LRCK in the shadow sector
			//
			//	how do we get to this case?
			//		"last sector" was flushed and shadowed, and we crashed before the next flush could occur
			//	where are our ptrs?
			//		lgposLast is pointing to the checksum in "last sector"
			//		lgposCurrent is pointing to the checksum in "shadow" which has just failed the range checksum

			//	make sure the range of the current sector (SPECIAL CASE or not) is at most 1 sector long

			Assert( lgposCurrent.ib + sizeof( LRCHECKSUM ) + plrck->le_cbForwards <= m_cbSec );

			//	see if we are experiencing the SPECIAL CASE (lgposLast.ib will match lgposCurrent.ib)
			//	NOTE: lgposLast may not be set if we are on the first LRCK record

			if (	lgposLast.isec >= m_csecHeader &&
					lgposLast.isec == lgposCurrent.isec - 1 &&
					lgposLast.ib == lgposCurrent.ib )
				{

				//	read both "last sector" and "shadow" (right now, we only have "shadow")

				Call( plread->ErrEnsureSector( lgposLast.isec, 2, &pbEnsure ) );
				plrck = reinterpret_cast< LRCHECKSUM* >( pbEnsure + lgposCurrent.ib );

				//	see if the "shadow" sector is a real shadow

				if ( FValidLRCKShadow(	reinterpret_cast< LRCHECKSUM* >( pbEnsure + m_cbSec + lgposCurrent.ib ), 
										&lgposCurrent, m_plgfilehdr->lgfilehdr.le_lGeneration ) )
					{
#ifdef ENABLE_LOGPATCH_TRACE
					if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
						{
						(*pcprintfLogPatch)( "special case!\r\n" );
						(*pcprintfLogPatch)( "\twe crashed during a multi-sector flush which was replacing a single-sector shadowed flush\r\n" );
						(*pcprintfLogPatch)( "\tthe crash occurred AFTER writing the first sector but BEFORE writing sectors 2-N\r\n" );

						LRCHECKSUM *_plrckT_ = (LRCHECKSUM *)( pbEnsure + m_cbSec + lgposCurrent.ib );

						(*pcprintfLogPatch)( "\r\n\tplrck (0x%0*I64x)\r\n", sizeof( char* ) * 2, QWORD( _plrckT_ ) );
						(*pcprintfLogPatch)( "\t  cbBackwards       = 0x%08x\r\n", _plrckT_->le_cbBackwards );
						(*pcprintfLogPatch)( "\t  cbForwards        = 0x%08x\r\n", _plrckT_->le_cbForwards );
						(*pcprintfLogPatch)( "\t  cbNext            = 0x%08x\r\n", _plrckT_->le_cbNext );
						(*pcprintfLogPatch)( "\t  ulChecksum        = 0x%08x\r\n", _plrckT_->le_ulChecksum );
						(*pcprintfLogPatch)( "\t  ulShortChecksum   = 0x%08x\r\n", _plrckT_->le_ulShortChecksum );
						(*pcprintfLogPatch)( "\t  bUseShortChecksum = %s (0x%02x)\r\n", 
											( bShortChecksumOn == _plrckT_->bUseShortChecksum ?
											  "Yes" : 
											  ( bShortChecksumOff == _plrckT_->bUseShortChecksum ?
											    "No" : "???" ) ),
											BYTE( _plrckT_->bUseShortChecksum ) );
						(*pcprintfLogPatch)( "\tpbEnsure (0x%0*I64x) -- 2 sectors\r\n", sizeof( char* ) * 2, QWORD( pbEnsure ) );

						ULONG _ibdumpT_ = 0;
						while ( _ibdumpT_ < 2 * m_cbSec )
							{
							(*pcprintfLogPatch)( "\t0x%04x: %02x %02x %02x %02x %02x %02x %02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\r\n",
												_ibdumpT_,
												pbEnsure[_ibdumpT_+0],  pbEnsure[_ibdumpT_+1],  pbEnsure[_ibdumpT_+2],  pbEnsure[_ibdumpT_+3],
												pbEnsure[_ibdumpT_+4],  pbEnsure[_ibdumpT_+5],  pbEnsure[_ibdumpT_+6],  pbEnsure[_ibdumpT_+7],
												pbEnsure[_ibdumpT_+8],  pbEnsure[_ibdumpT_+9],  pbEnsure[_ibdumpT_+10], pbEnsure[_ibdumpT_+11],
												pbEnsure[_ibdumpT_+12], pbEnsure[_ibdumpT_+13], pbEnsure[_ibdumpT_+14], pbEnsure[_ibdumpT_+15] );
							_ibdumpT_ += 16;
							Assert( _ibdumpT_ <= 2 * m_cbSec );
							}
						}
#endif	//	ENABLE_LOGPATCH_TRACE

					//	enter the scan code, but skip the scan itself 

					fDoScan = fTrue;
					fSkipScanAndApplyPatch = fTrue;

					//	setup lgposScan's generation (the rest of it is not used)
					
					lgposScan.lGeneration = lgposLast.lGeneration;

					//	the end ptr is the start of the shadow sector

					lgposEnd.ib				= 0;
					lgposEnd.isec			= lgposCurrent.isec;
					lgposEnd.lGeneration	= lgposCurrent.lGeneration;

					//	mark the end of data for redo time

					m_lgposLastRec = lgposEnd;

					//	prepare the patch buffer ptrs

					pbLastChecksum = pbLastSector + lgposCurrent.ib;
					isecLastSector = lgposCurrent.isec;

					//	fill with known value, so if we ever use the filled data we'll know it (hopefully)

					Assert( cbLogExtendPattern > m_cbSec );
					Assert( rgbLogExtendPattern );
					memcpy( pbLastSector, rgbLogExtendPattern, m_cbSec );

					//	prepare the new LRCHECKSUM record

					plrck = reinterpret_cast< LRCHECKSUM* >( pbLastChecksum );
					memset( pbLastChecksum, 0, sizeof( LRCHECKSUM ) );
					plrck->lrtyp = lrtypChecksum;
					plrck->bUseShortChecksum = bShortChecksumOff;

					//	NOTE: we leave the backward pointer set to 0 to cover the case where the head of
					//			  a partial log record was written in the last sector, but the tail of that
					//			  record was never written safely to this sector (we just filled the space
					//			  where the tail was with log-extend pattern)
					//		  the partial log record will be ignored when we scan record by record later on
					//			  in this function
				
					//	terminate the "forever" loop

					break;					
					}

				//	"shadow" was not a shadow sector

				//	this case must be a standard case of corruption/torn-write and should run through the
				//		regular channels (continue on)
				
				}

			//	since the short checksum is off, the range is limited to the first sector only, and the
			//		data in that range is invalid
			//	it also means we should have a shadow sector making this the end of the log

			//	jump to the code that attempts to recover using the shadow sector

			fTookJump = fTrue;
			goto RecoverWithShadow;				
			}

		//	at this point, the LRCHECKSUM record and its range are completely valid

#ifdef LOGPATCH_UNIT_TEST
			{
			ULONG _ibT;
			ULONG _cbT;

			if ( lgposCurrent.ib + sizeof( LRCHECKSUM ) + plrck->le_cbForwards > m_cbSec )
				{
				_ibT = m_cbSec;
				_cbT = lgposCurrent.ib + sizeof( LRCHECKSUM ) + plrck->le_cbForwards;
				AssertRTL( 0 == _cbT % m_cbSec );
				while ( _ibT < _cbT )
					{
					AssertRTL( 0 != memcmp( pbEnsure + _ibT, rgbLogExtendPattern, m_cbSec ) );
					_ibT += m_cbSec;
					}
				}
			}
#endif	//	LOGPATCH_UNIT_TEST

		//	is this the last LRCHECKSUM record?

		if ( plrck->le_cbNext == 0 )
			{
			BOOL fIsMultiSector;

			//	this is the last LRCHECKSUM record in the log file

			//	since the LRCHECKSUM record is valid, we won't need a scan for any corruption

			fDoScan = fFalse;

			//	see if this LRCHECKSUM record is a multi-sector flush (it has a short checksum)
			//		(remember that logs can end in either single-sector or multi-sector flushes)

			fIsMultiSector = ( plrck->bUseShortChecksum == bShortChecksumOn );

			//	if this was a single-sector flush, we need to create a shadow sector now (even if one
			//		already exists); this ensures that if the flush at the end of this function goes
			//		bad, we can get back the data we lost
			//	NOTE: only do this for edb.log!

			if ( !fIsMultiSector && fJetLog )
				{

				//	this was a single-sector flush; create the shadow sector now
				
				Assert( PbSecAligned( reinterpret_cast< const BYTE* >( plrck ) ) == pbEnsure );
				const ULONG ulNormalChecksum = plrck->le_ulChecksum;

				//	the checksum value in the LRCHECKSUM record should match the re-calculated checksum

				Assert( ulNormalChecksum == UlComputeChecksum( plrck, (ULONG32)m_plgfilehdr->lgfilehdr.le_lGeneration ) );

				//	get the shadow checksum value
			
				plrck->le_ulChecksum = UlComputeShadowChecksum( ulNormalChecksum );

				//	write the shadow sector
			
				if ( !fReadOnly )
					{
//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
Assert( m_cbSec == m_cbSecVolume );
//					if ( m_cbSec == m_cbSecVolume )
//						{
						CallJ( m_pfapiLog->ErrIOWrite( m_cbSec * QWORD( lgposCurrent.isec + 1 ), m_cbSec, pbEnsure ), LHandleErrorWrite );
//						}
//					else
//						{
//						fWriteOnSectorSizeMismatch = fTrue;
//						}
					}

				//	mark the sector as modified
				
				plread->SectorModified( lgposCurrent.isec + 1, pbEnsure );

				//	fix the checksum value in the original LRCHECKSUM record
			
				plrck->le_ulChecksum = ulNormalChecksum;
				}

			//	does this LRCHECKSUM record have a "forward" range? (may be single- or multi- sector)

			if ( plrck->le_cbForwards == 0 )
				{

				//	no forward data was found

				//	this flush should have been a single-sector flush

				Assert( !fIsMultiSector );

				//	in this case, we want to search for the lrtypTerm and/or lrtypRecoveryQuit 
				//		log records up to and including the current LRCHECKSUM record
				//		(e.g. the forward range of the last LRCHECKSUM and the backward 
				//			  range of this LRCHECKSUM)
				
				//	to make the search work, we must setup lgposLast and lgposEnd: 
				//		we leave lgposLast (the last valid LRCHECKSUM we found) pointing at the 
				//			previous LRCHECKSUM even though we know the current LRCHECKSUM is ok
				//			because we want to start scanning from the last LRCHECKSUM record
				//		we set lgposEnd (the point to stop searching) to the position 
				//			immediately after this LRCHECKSUM since this LRCHECKSUM had no
				//			forward data

				lgposEnd = lgposCurrent;
				AddLgpos( &lgposEnd, sizeof( LRCHECKSUM ) );

				//	prepare pbLastSector with data for the next flush which will occur after we
				//		exit the "forever" loop

				//	copy the sector with the LRCHECKSUM record
				
				UtilMemCpy( pbLastSector, pbEnsure, m_cbSec );

				//	set the pointers to the copy of the LRCHECKSUM record
				
				pbLastChecksum = pbLastSector + lgposCurrent.ib;
				isecLastSector = lgposCurrent.isec;
				}
			else
				{

				//	forward data was found
				//
				//	in this case, we want to search for the lrtypTerm and/or lrtypRecoveryQuit 
				//		log records within the forward data of the LRCHECKSUM record

				//	set lgposLast (the last valid LRCHECKSUM record) to the current LRCHECKSUM record
					
				lgposLast = lgposCurrent;

				//	set lgposEnd (the point after the last good data) to the first byte after
				//		the forward range of this LRCHECKSUM

				lgposEnd = lgposCurrent;
				Assert( plrck->le_cbBackwards == lgposCurrent.ib || 0 == plrck->le_cbBackwards );
				AddLgpos( &lgposEnd, sizeof( LRCHECKSUM ) + plrck->le_cbForwards );

				//	was this flush a multi-sector flush?
			
				if ( fIsMultiSector )
					{

					//	this happens when the last flush is was multi-sector flush, which in turn happens when:
					//		backup/restore request a new generation and we happen to be doing a multi-sector flush
					//			because we are under high load
					//		we are at the end of the log file, we need to flush N sectors where N is the exact
					//			amount of sectors left in the log file, and there is no room for another 
					//			LRCHECKSUM record at the end of the (N-1)th sector
					//			
					//	naturally, we want to continue using the log file (just like any other case) after the
					//		last good data; however, we cannot because we would need to safely re-write the 
					//		LRCHECKSUM with an updated cbNext pointer
					//	that is not SAFELY possible without a shadow sector to back us up in case we fail
					//
					//	but do we even really want to re-claim the empty space in the current generation? NO!
					//		in the case of backup/restore, that generation is OVER and needs to stay that way
					//			so that the database remains in the state we expect it to be in when we are
					//			trying to restore it
					//		in the end of log case, there is no space to reclaim anyway!
					//
					//	conclusion --> these cases, however rare they may be, are fine and SHOULD behave the way
					//				   that they do

					//	since we can't use this generation, set the flag to start a new one

					//	NOTE: we can only start a new generation after edb.log!

					if ( fJetLog )
						{
						fLogToNextLogFile = fTrue;
						}
					}
				else
					{

					//	the last flush was a single-sector flush

					//	prepare pbLastSector with data for the next flush which will occur after we
					//		exit the "forever" loop

					//	copy the sector with the LRCHECKSUM record

					UtilMemCpy( pbLastSector, pbEnsure, m_cbSec );

					//	set the pointers to the copy of the LRCHECKSUM record
				
					pbLastChecksum = pbLastSector + lgposCurrent.ib;
					isecLastSector = lgposCurrent.isec;	
					}
				}

			//	mark the end of data for redo time

			m_lgposLastRec = lgposEnd;

			//	terminate the "forever" loop

			break;
			}


		//	move to the next LRCHECKSUM record

		//	set lgposLast (the last good LRCHECKSUM record) to the current LRCHECKSUM record

		lgposLast = lgposCurrent;

		//	set lgposCurrent to point to the supposed next LRCHECKSUM record (could be garbage)

		Assert( lgposCurrent.ib == plrck->le_cbBackwards || 0 == plrck->le_cbBackwards );
		AddLgpos( &lgposCurrent, sizeof( LRCHECKSUM ) + plrck->le_cbNext );

		//	mark the end of data for redo time

		m_lgposLastRec = lgposCurrent;
		m_lgposLastRec.ib = 0;
		}	//	bottom of "forever" loop

	//	we have now finished scanning the chain of LRCHECKSUM records

	//	did we find ANY records at all (including LRCHECKSUM records)?
	
	if ( lgposEnd.isec == m_csecHeader && 0 == lgposEnd.ib )
		{
		
		//	the beginning of the log file was also the end; this indicates corruption because 
		//		every log file must start with an LRCHECKSUM record

		//	this should not be a single-sector torn-write

		Assert( !fSingleSectorTornWrite );

		//	we should already be prepared to scan for the cause of the corruption

		Assert( fDoScan );

		//	the end position should be set to the current position

		Assert( CmpLgpos( &lgposCurrent, &lgposEnd ) == 0 );

		//	the last position should not have been touched since it was initialized

		Assert( lgposLast.isec == 0 && lgposLast.ib == 0 );

		//	fix lgposLast to be lgposCurrent (we created an empty LRCHECKSUM record here)

		lgposLast = lgposCurrent;

		//	pbLastChecksum should be set to the start of the sector

		Assert( pbLastChecksum == pbLastSector );

		//	isecLastSector should be set to the current sector

		Assert( isecLastSector == lgposCurrent.isec );
		}
	else if ( lgposLast.isec == 0 )
		{

		//	the end of the log was NOT the beginning; HOWEVER, lgposLast was never set
		//
		//	this indicates that only 1 good LRCHECKSUM record exists and it is at the beginning of
		//		the log file; if we had found a second good LRCHECKSUM record, we would have set
		//		lgposLast to the location of the first good LRCHECKSUM record
		//
		//	we may or may not be setup to scan for corruption, so we are limited in the checking we can do
		//		(we might even be corruption free if there is only 1 LRCHECKSUM in the log!)

		//	adjust lgposLast for the record-to-record search for the lrtypTerm and/or lrtypRecoveryQuit records
				
		lgposLast.isec = USHORT( m_csecHeader );
		Assert( lgposLast.ib == 0 );
		
		//	double check that lgposEnd is atleast 1 full LRCHECKSUM record ahead of lgposLast

		Assert( lgposEnd.isec > lgposLast.isec || 
				( lgposEnd.isec == lgposLast.isec && lgposEnd.ib >= ( lgposLast.ib + sizeof( LRCHECKSUM ) ) ) );
		}

	//	lgposCurrent, lgposLast, and lgposEnd should now be setup properly

	Assert( CmpLgpos( &lgposLast, &lgposCurrent ) <= 0 );	//	lgposLast <= lgposCurrent
	//	bad assert -- in the first failure case (invalid RECORD and invalid SHADOW),
	//		lgposCurrent will be greater than lgposEnd (or equal to it) because lgposCurrent will
	//		point directly to the location of the bad LRCHECKSUM record
	//Assert( CmpLgpos( &lgposCurrent, &lgposEnd ) <= 0 );	//	lgposCurrent <= lgposEnd

	//	scan for corruption

	if ( fDoScan )
		{
#ifdef ENABLE_LOGPATCH_TRACE
		if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
			{
			ULONG _ibdumpT_;

			(*pcprintfLogPatch)( "scanning logfile %s for a torn-write or for corruption\r\n", m_szLogName );

			(*pcprintfLogPatch)( "\r\n\tdumping state of ErrLGCheckReadLastLogRecordFF:\r\n" );
			(*pcprintfLogPatch)( "\t\terr                    = %d \r\n", err );
			(*pcprintfLogPatch)( "\t\tlgposCurrent           = {0x%x,0x%x,0x%x}\r\n", lgposCurrent.lGeneration, lgposCurrent.isec, lgposCurrent.ib );
			(*pcprintfLogPatch)( "\t\tlgposLast              = {0x%x,0x%x,0x%x}\r\n", lgposLast.lGeneration, lgposLast.isec, lgposLast.ib  );
			(*pcprintfLogPatch)( "\t\tlgposEnd               = {0x%x,0x%x,0x%x}\r\n", lgposEnd.lGeneration, lgposEnd.isec, lgposEnd.ib );
			(*pcprintfLogPatch)( "\t\tisecLastSector         = %d\r\n", isecLastSector );
			(*pcprintfLogPatch)( "\t\tisecPatternFill        = 0x%x\r\n", isecPatternFill );
			(*pcprintfLogPatch)( "\t\tcsecPatternFill        = 0x%x\r\n", csecPatternFill );
			(*pcprintfLogPatch)( "\t\tfGotQuit               = %s\r\n", ( fGotQuit ? "TRUE" : "FALSE" ) );
			(*pcprintfLogPatch)( "\t\tfCreatedLogReader      = %s\r\n", ( fCreatedLogReader ? "TRUE" : "FALSE" ) );
			(*pcprintfLogPatch)( "\t\tfLogToNextLogFile      = %s\r\n", ( fLogToNextLogFile ? "TRUE" : "FALSE" ) );
			(*pcprintfLogPatch)( "\t\tfDoScan                = %s\r\n", ( fDoScan ? "TRUE" : "FALSE" ) );
			(*pcprintfLogPatch)( "\t\tfOldRecovering         = %s\r\n", ( fOldRecovering ? "TRUE" : "FALSE" ) );
			(*pcprintfLogPatch)( "\t\tfOldRecoveringMode     = %d\r\n", fOldRecoveringMode );
			(*pcprintfLogPatch)( "\t\tfRecordOkRangeBad      = %s\r\n", ( fRecordOkRangeBad ? "TRUE" : "FALSE" ) );
			(*pcprintfLogPatch)( "\t\tlgposScan              = {0x%x,0x%x,0x%x}\r\n", lgposScan.lGeneration, lgposScan.isec, lgposScan.ib );
			(*pcprintfLogPatch)( "\t\tfJetLog                = %s\r\n", ( fJetLog ? "TRUE" : "FALSE" ) );
			(*pcprintfLogPatch)( "\t\tfTookJump              = %s\r\n", ( fTookJump ? "TRUE" : "FALSE" ) );
			(*pcprintfLogPatch)( "\t\tfSingleSectorTornWrite = %s\r\n", ( fSingleSectorTornWrite ? "TRUE" : "FALSE" ) );
			(*pcprintfLogPatch)( "\t\tfSkipScanAndApplyPatch = %s\r\n", ( fSkipScanAndApplyPatch ? "TRUE" : "FALSE" ) );
			(*pcprintfLogPatch)( "\t\tcbChecksum             = 0x%x\r\n", cbChecksum );

			(*pcprintfLogPatch)( "\r\n\tdumping partial state of LOG:\r\n" );
			(*pcprintfLogPatch)( "\t\tLOG::m_fRecovering     = %s\r\n", ( m_fRecovering ? "TRUE" : "FALSE" ) );
			(*pcprintfLogPatch)( "\t\tLOG::m_fRecoveringMode = %d\r\n", m_fRecoveringMode );
			(*pcprintfLogPatch)( "\t\tLOG::m_fHardRestore    = %s\r\n", ( m_fHardRestore ? "TRUE" : "FALSE" ) );
			(*pcprintfLogPatch)( "\t\tLOG::m_fRestoreMode    = %d\r\n", m_fRestoreMode );
			(*pcprintfLogPatch)( "\t\tLOG::m_csecLGFile      = 0x%08x\r\n", m_csecLGFile );
			(*pcprintfLogPatch)( "\t\tLOG::m_csecLGBuf       = 0x%08x\r\n", m_csecLGBuf );
			(*pcprintfLogPatch)( "\t\tLOG::m_csecHeader      = %d\r\n", m_csecHeader );
			(*pcprintfLogPatch)( "\t\tLOG::m_cbSec           = %d\r\n", m_cbSec );
			(*pcprintfLogPatch)( "\t\tLOG::m_cbSecVolume     = %d\r\n", m_cbSecVolume );
			(*pcprintfLogPatch)( "\t\tLOG::m_pbLGBufMin      = 0x%0*I64x\r\n", sizeof( char* ) * 2, QWORD( m_pbLGBufMin ) );
			(*pcprintfLogPatch)( "\t\tLOG::m_pbLGBufMax      = 0x%0*I64x\r\n", sizeof( char* ) * 2, QWORD( m_pbLGBufMax ) );
			(*pcprintfLogPatch)( "\t\tLOG::m_pbWrite         = 0x%0*I64x\r\n", sizeof( char* ) * 2, QWORD( m_pbWrite ) );
			(*pcprintfLogPatch)( "\t\tLOG::m_pbEntry         = 0x%0*I64x: 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\r\n", sizeof( char* ) * 2, QWORD( m_pbEntry ), m_pbEntry[0], m_pbEntry[1], m_pbEntry[2], m_pbEntry[3], m_pbEntry[4], m_pbEntry[5], m_pbEntry[6], m_pbEntry[7] );
			(*pcprintfLogPatch)( "\t\tLOG::m_isecWrite       = 0x%08x\r\n", m_isecWrite );

			(*pcprintfLogPatch)( "\r\n\tdumping data:\r\n" );

			(*pcprintfLogPatch)( "\t\tplrck (0x%0*I64x)\r\n", sizeof( char* ) * 2, QWORD( plrck ) );
			(*pcprintfLogPatch)( "\t\t  cbBackwards       = 0x%08x\r\n", plrck->le_cbBackwards );
			(*pcprintfLogPatch)( "\t\t  cbForwards        = 0x%08x\r\n", plrck->le_cbForwards );
			(*pcprintfLogPatch)( "\t\t  cbNext            = 0x%08x\r\n", plrck->le_cbNext );
			(*pcprintfLogPatch)( "\t\t  ulChecksum        = 0x%08x\r\n", plrck->le_ulChecksum );
			(*pcprintfLogPatch)( "\t\t  ulShortChecksum   = 0x%08x\r\n", plrck->le_ulShortChecksum );
			(*pcprintfLogPatch)( "\t\t  bUseShortChecksum = %s (0x%02x)\r\n", 
								( bShortChecksumOn == plrck->bUseShortChecksum ?
								  "Yes" : 
								  ( bShortChecksumOff == plrck->bUseShortChecksum ?
								    "No" : "???" ) ),
								BYTE( plrck->bUseShortChecksum ) );
			(*pcprintfLogPatch)( "\t\tpbEnsure (0x%0*I64x)\r\n", sizeof( char* ) * 2, QWORD( pbEnsure ) );

			_ibdumpT_ = 0;
			while ( _ibdumpT_ < m_cbSec )
				{
				(*pcprintfLogPatch)( "\t\t0x%04x: %02x %02x %02x %02x %02x %02x %02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\r\n",
									_ibdumpT_,
									pbEnsure[_ibdumpT_+0],  pbEnsure[_ibdumpT_+1],  pbEnsure[_ibdumpT_+2],  pbEnsure[_ibdumpT_+3],
									pbEnsure[_ibdumpT_+4],  pbEnsure[_ibdumpT_+5],  pbEnsure[_ibdumpT_+6],  pbEnsure[_ibdumpT_+7],
									pbEnsure[_ibdumpT_+8],  pbEnsure[_ibdumpT_+9],  pbEnsure[_ibdumpT_+10], pbEnsure[_ibdumpT_+11],
									pbEnsure[_ibdumpT_+12], pbEnsure[_ibdumpT_+13], pbEnsure[_ibdumpT_+14], pbEnsure[_ibdumpT_+15] );
				_ibdumpT_ += 16;
				Assert( _ibdumpT_ <= m_cbSec );
				}

			(*pcprintfLogPatch)( "\t\tpbLastSector (0x%0*I64x)\r\n", sizeof( char* ) * 2, QWORD( pbLastSector ) );

			_ibdumpT_ = 0;
			while ( _ibdumpT_ < m_cbSec )
				{
				(*pcprintfLogPatch)( "\t\t0x%04x: %02x %02x %02x %02x %02x %02x %02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\r\n",
									_ibdumpT_,
									pbLastSector[_ibdumpT_+0],  pbLastSector[_ibdumpT_+1],  pbLastSector[_ibdumpT_+2],  pbLastSector[_ibdumpT_+3],
									pbLastSector[_ibdumpT_+4],  pbLastSector[_ibdumpT_+5],  pbLastSector[_ibdumpT_+6],  pbLastSector[_ibdumpT_+7],
									pbLastSector[_ibdumpT_+8],  pbLastSector[_ibdumpT_+9],  pbLastSector[_ibdumpT_+10], pbLastSector[_ibdumpT_+11],
									pbLastSector[_ibdumpT_+12], pbLastSector[_ibdumpT_+13], pbLastSector[_ibdumpT_+14], pbLastSector[_ibdumpT_+15] );
				_ibdumpT_ += 16;
				Assert( _ibdumpT_ <= m_cbSec );
				}

			if ( pbLastChecksum )
				{
				LRCHECKSUM *_plrckT_ = (LRCHECKSUM *)pbLastChecksum;

				(*pcprintfLogPatch)( "\t\tpbLastChecksum (0x%0*I64x)\r\n", sizeof( char* ) * 2, QWORD( _plrckT_ ) );
				(*pcprintfLogPatch)( "\t\t  cbBackwards       = 0x%08x\r\n", _plrckT_->le_cbBackwards );
				(*pcprintfLogPatch)( "\t\t  cbForwards        = 0x%08x\r\n", _plrckT_->le_cbForwards );
				(*pcprintfLogPatch)( "\t\t  cbNext            = 0x%08x\r\n", _plrckT_->le_cbNext );
				(*pcprintfLogPatch)( "\t\t  ulChecksum        = 0x%08x\r\n", _plrckT_->le_ulChecksum );
				(*pcprintfLogPatch)( "\t\t  ulShortChecksum   = 0x%08x\r\n", _plrckT_->le_ulShortChecksum );
				(*pcprintfLogPatch)( "\t\t  bUseShortChecksum = %s (0x%02x)\r\n", 
									( bShortChecksumOn == _plrckT_->bUseShortChecksum ?
									  "Yes" : 
									  ( bShortChecksumOff == _plrckT_->bUseShortChecksum ?
									    "No" : "???" ) ),
									BYTE( _plrckT_->bUseShortChecksum ) );
				}
			else
				{
				(*pcprintfLogPatch)( "\t\tpbLastChecksum (null)\r\n" );
				}

			(*pcprintfLogPatch)( "\r\n" );
			}
#endif	//	ENABLE_LOGPATCH_TRACE

		//	an inconsistency has occurred somewhere in the physical logging structures and/or log data

		//	NOTE: we can only patch torn writes in edb.log; all other patching must be done offline!

		//	we are either in the middle of the log file (most likely), or we are at the end of a 
		//		generation whose last flush was a multisector flush (unlikely -- special case)

		//	in either case, this may really be the end of the log data!
		//		middle of log case: just say the power went out as we were flushing and the first few
		//		  (cbNext != 0)		sectors went to disk (including the LRCHECKSUM), but the rest did not
		//							make it; that would make it look like we are in the middle of the log
		//							when we are really at the end of it
		//		end of log case:    we already know we were at the end of the log!
		//		  (cbNext == 0)

		//	to see if this is the real end of the log, we must scan through data after the "forward" range 
		//		of the current LRCHECKSUM record (lgposCurrent) all the way through to the end of the log
		//
		//	if we find nothing but the log pattern, we know this was the last data in the log 
		//		(we can recover up this point and say that this is as far as we can safely go)
		//	if we do find something besides the log pattern, then we know there is some other log data
		//		out there, and we cannot safely say that this is the end of the log

		//	after examinig the different cases of corruption, it turns out that there are 2 cases where
		//		we actaully have a torn-write for sure; they are listed below:
		//
		//
		//	in the first case, we have an LRCHECKSUM record covering a range of 1 or more full sectors
		//		(the #'s represent a gap of sector ranging from none to infinity); the range is clean
		//		meaning that all checksums are correct and all data is valid; the next pointer of the 
		//		LRCHECKSUM record points into the pattern which runs to the end of the log file
		//	this is the typical situation when we abruptly get a TerminateProcess() or suffer a power
		//		outage -- there is absolutely no chance to flush anything, and we had no idea it was
		//		coming in the first place
		//	NOTE: when the LRCHECKSUM record covers only 1 sector, that sector will have been shadowed
		//		  immediately after it -- there is a special case to handle this situation
		//
		//     /---\  /--- # ---\
		//	--|----|--|--- # ----|---------------------------
		//    |...(LRCK).. # ....| pattern 
		//	--|-----|----- # ----|---------------------------
		//          \----- # --------/
		//
		//
		//	in the second case, we have an LRCHECKSUM record covering a range of 2 or more full sectors
		//		(the #'s represent a gap of sectors ranging from 1 to infinity); the short checksum
		//		range is clean (it checks out OK and the data in the first sector is OK), but the long
		//		checksum range is dirty (some bits are wrong in one or more of the sectors after the
		//		first sector); notice that atleast one of the sectors exclusive to the long checksum 
		//		range contains the pattern; the next pointer is aimed properly, but points at the 
		//		the pattern instead of the next LRCHECKSUM record
		//	this is a more rare case; since we find the pattern within the flush, we assume that the 
		//		disk never finished the IO request we made when we were flushing the data; we base
		//		this on the fact that there was no data after this, so this must be the end -- finding
		//		the pattern within the flush helps to confirm that this is an incomplete IO and not a
		//		case of real corruption
		//
		//     /---\  /--- # --------------\
		//	--|----|--|--- # --|-------|----|---------------------------
		//    |...(LRCK).. # ..|pattern|....| pattern 
		//	--|-----|----- # --|-------|----|---------------------------
		//          \----- # -------------------/
		//
		//	NOTE: case #2 could occur when we crash in between I/Os while trying to overwrite the
		//		  shadow sector; the disk will contain the NEW first sector, the OLD shadow sector,
		//		  and the pattern; IF THE RANGE ONLY COVERS 2 SECTORS, WE WILL NOT SEE THE PATTERN
		//		  IN THE RANGE -- ONLY THE SHADOW SECTOR WILL BE IN THE RANGE! so, we need to realize 
		//		  this case and check for the shadow-sector instead of the pattern within the range
		//	we should see 2 things in this case: the shadow sector should be a valid shadow sector, and 
		//		  the log records in the newly flushed first sector and the old shadow sector should
		//		  match exactly (the shadow sector will have less than or equal to the number of
		//		  log records in the new sector); the LRCHECKSUM records from each sector should not match
		//

		BYTE 		*pbEnsureScan	= NULL;
		BYTE		*pbScan			= NULL;
		ULONG		csecScan		= 0;
		BOOL		fFoundPattern	= fTrue;	//	assume we will find a torn write
		BOOL		fIsTornWrite	= fTrue;	//	assume we will find a torn write
		CHAR 		szSector[30];
		CHAR		szCorruption[30];
		const CHAR*	rgpsz[3]		= { m_szLogName, szSector, szCorruption };

		const QWORD	ibOffset		= QWORD( lgposCurrent.isec ) * QWORD( m_cbSec );
		const DWORD	cbLength		= cbChecksum;

		//	prepare the event-log messages

		sprintf( szSector, "%d:%d", lgposCurrent.isec, lgposCurrent.ib );
		szCorruption[0] = 0;

		//	skip the scan if we are coming from a special-case above (see code for details)

		if ( fSkipScanAndApplyPatch )
			goto ApplyPatch;

		//	make sure lgposScan was set

		Assert( lgposScan.isec > 0 );

		//	we should be sector-aligned

		Assert( lgposScan.ib == 0 );

		//	we should be at or past the end of the good data

		Assert( CmpLgpos( &lgposEnd, &lgposScan ) <= 0 );

		//	determine if there is any data to scan through
		
		if ( lgposScan.isec >= ( m_csecLGFile - 1 ) )
			{
			
			//	we are at the file size limits of the log file meaning there is nothing left to scan

			//	since there isn't any data left to look through, we must be at the end of the log; that 
			//		means that we definitely have a torn-write

			//	we should NEVER EVER point past the end of the log file

			Assert( lgposScan.isec <= ( m_csecLGFile - 1 ) );

			//	leave fFoundPattern set to fTrue

			//	skip the scanning loop

			goto SkipScan;
			}

		//	pull in the data we need to scan 
		//	(including the extra sector we reserve for the final shadow sector)

		csecScan = m_csecLGFile - lgposScan.isec;
		Call( plread->ErrEnsureSector( lgposScan.isec, csecScan, &pbEnsureScan ) );

		//	scan sector by sector looking for the log-extend pattern

		Assert( cbLogExtendPattern >= m_cbSec );
		pbScan = pbEnsureScan;
		while ( fFoundPattern && csecScan )
			{

			//	does the entire sector match the log-extend pattern?
				
			if ( memcmp( pbScan, rgbLogExtendPattern, m_cbSec ) != 0 )
				{
				//	no; this is not a torn write
					
				fFoundPattern = fFalse;
				fIsTornWrite = fFalse;

				//	stop scanning

				break;
				}
				
			//	advance the scan counters

			pbScan += m_cbSec;
			csecScan--;
			}

		//	assume that finding the pattern means we have a torn-write

		fIsTornWrite = fFoundPattern;

#ifdef ENABLE_LOGPATCH_TRACE
		if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
			{
			(*pcprintfLogPatch)( "pattern scan complete -- fFoundPattern = %s\r\n", ( fFoundPattern ? "TRUE" : "FALSE" ) );
			}
#endif	//	ENABLE_LOGPATCH_TRACE

		//	what about case #2 (see comments above) where we must also search for the pattern
		//		within the range of the LRCHECKSUM record itself? this is just to be sure that
		//		the reason the long checksum failed was in fact due to finding the pattern...
		//	NOTE: if the range is only 2 sectors and we crashed in the middle of trying to
		//		  overwrite the previous shadow sector, the range will contain only the shadow
		//		  sector (when the range is 3 or more sectors, it should contain atleast 1 sector
		//		  with the pattern if it is a torn-write case)

		if ( fFoundPattern && fRecordOkRangeBad )
			{
			BYTE		*pbScanT		= NULL;
			BYTE		*pbEnsureScanT	= NULL;
			ULONG		csecScanT		= 0;
			LRCHECKSUM	*plrckT			= NULL;

#ifdef ENABLE_LOGPATCH_TRACE
			if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
				{
				(*pcprintfLogPatch)( "special case!\r\n" );
				(*pcprintfLogPatch)( "\trecall that we had previously detected a bad LRCK range\r\n" );
				(*pcprintfLogPatch)( "\twe now suspect that this BAD-ness is the result of an incomplete I/O because fFoundPattern=TRUE\r\n" );
				}
#endif	//	ENABLE_LOGPATCH_TRACE

			Assert( !fSingleSectorTornWrite );

			//	read the sector with the LRCHECKSUM record
				
			Call( plread->ErrEnsureSector( lgposCurrent.isec, 1, &pbEnsureScanT ) );
			plrck = reinterpret_cast< LRCHECKSUM* >( pbEnsureScanT + lgposCurrent.ib );
			AssertValidLRCKRecord( plrck, &lgposCurrent );

			//	calculate the number of sectors in its range
			
			csecScanT = ( ( lgposCurrent.ib + sizeof( LRCHECKSUM ) + plrck->le_cbForwards - 1 ) / m_cbSec ) + 1;
			Assert( csecScanT > 1 );

			//	read the entire range

			Call( plread->ErrEnsureSector( lgposCurrent.isec, csecScanT, &pbEnsureScanT ) );
			plrck = reinterpret_cast< LRCHECKSUM* >( pbEnsureScanT + lgposCurrent.ib );
			AssertValidLRCKRecord( plrck, &lgposCurrent );
			AssertInvalidLRCKRange( plrck, lgposCurrent.lGeneration );

			if ( csecScanT == 2 )
				{

				//	this is the special case where we only have 2 sectors; the second sector could be
				//		an old shadow sector, it could be the pattern, or it could be corruption;
				//
				//	if it is an old shadow sector, we must have failed while trying to safely overwrite it
				//		using 2 I/Os (never made it to the second I/O) making this a torn-write case
				//	if we find the pattern, we must have been in the middle of a single I/O and crashed
				//		leaving "holes" of the pattern throughout the range of this LRCHECKSUM record
				//		making this a torn-write case
				//	if we find corruption, we cannot have a torn-write

				plrckT = (LRCHECKSUM *)( (BYTE *)plrck + m_cbSec );
				if ( FValidLRCKShadowWithoutCheckingCBNext( plrckT, &lgposCurrent, lgposCurrent.lGeneration ) )
					{

					//	this should only happen in edb.log -- all other logs should be clean or corrupt
					//		(they should never have a torn-write)

					Assert( fJetLog );

					//	the log records in the shadow sector must match the log records in the new sector

					if ( memcmp( pbEnsureScanT, 
								 pbEnsureScanT + m_cbSec, 
								 (BYTE *)plrck - pbEnsureScanT ) == 0 &&
						 memcmp( (BYTE *)plrck + sizeof( LRCHECKSUM ),
						 		 (BYTE *)plrckT + sizeof( LRCHECKSUM ),
						 		 plrckT->le_cbForwards ) == 0 )
						{

						//	make sure the LRCHECKSUM pointers are correct

						Assert( plrckT->le_cbForwards <= plrck->le_cbForwards );
						
						// type cast explicitly for CISCO compiler
						Assert( (ULONG32)plrckT->le_cbBackwards == (ULONG32)plrck->le_cbBackwards );

						//	we are now sure that we have a torn-write

						Assert( fIsTornWrite );
						}
					else
						{

						//	this is not a torn-write because the log records do not match? this should
						//		never happen -- especially if we have determined that the shadow sector
						//		is valid! it seems to suggest that the shadow-sector validation is bad

						AssertTracking();

						//	this is not a torn-write

						fIsTornWrite = fFalse;
						}
					}
				else if ( memcmp( pbEnsureScanT + m_cbSec, rgbLogExtendPattern, m_cbSec ) == 0 )
					{

					//	the sector we are looking at is not a shadow-sector, but it does contain the 
					//		pattern meaning we issued 1 I/O but that I/O never completed; this is 
					//		a torn-write case

					Assert( fIsTornWrite );
					}
				else
					{

					//	the sector we are looking at is neither an old shadow or the pattern; it must
					//		be corruption

					fIsTornWrite = fFalse;
					}
				}
			else
				{

				//	we have more than 2 sectors to scan
				//	we can either find the pattern in 1 of the sectors making this case a torn-write, OR
				//		we won't find anything making this case corruption

				//	scan the sectors within the range of the LRCHECKSUM record
				//	if we find the log-extend pattern in just one sector, we know that the corruption
				//		was caused by that sector and not real corruption

				csecScanT--;
				pbScanT = pbEnsureScanT + m_cbSec;
				while ( csecScanT )
					{

					//	see if we have atleast 1 sector with the log-extend pattern

					if ( memcmp( pbScanT, rgbLogExtendPattern, m_cbSec ) == 0 )
						{
							
						//	we have one! this has to be a torn-write

						Assert( fIsTornWrite );		//	this should be previously set

						break;
						}

					csecScanT--;
					pbScanT += m_cbSec;
					}

				//	did we find the pattern?

				if ( !csecScanT )
					{

					//	no; this is not a torn-write

					fIsTornWrite = fFalse;
					}
				}
			}

SkipScan:

		//	if a torn-write was detected, we may have a single-sector torn-write

		fSingleSectorTornWrite = fSingleSectorTornWrite && fIsTornWrite;

#ifdef ENABLE_LOGPATCH_TRACE
		if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
			{
			(*pcprintfLogPatch)( "torn-write detection complete\r\n" );
			(*pcprintfLogPatch)( "\tfIsTornWrite           = %s\r\n", ( fIsTornWrite ? "TRUE" : "FALSE" ) );
			(*pcprintfLogPatch)( "\tfSingleSectorTornWrite = %s\r\n", ( fSingleSectorTornWrite ? "TRUE" : "FALSE" ) );
			}
#endif	//	ENABLE_LOGPATCH_TRACE

		if ( fIsTornWrite )
			{

			//	we have a torn-write

			Assert( csecScan == 0 );

			//	we should have found the log-extend pattern

			Assert( fFoundPattern );

ApplyPatch:
			//	what recovery mode are we in?

			if ( m_fHardRestore )
				{

				//	we are in hard-recovery mode

				if ( lgposScan.lGeneration <= m_lGenHighRestore )
					{
#ifdef ENABLE_LOGPATCH_TRACE
					if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
						{
						(*pcprintfLogPatch)( "failed to patch torn-write because we are dealing with a logfile in the backup set\r\n" );
						}
#endif	//	ENABLE_LOGPATCH_TRACE

					//  report log file corruption to the event log

					const _TCHAR*	rgpszT[ 4 ];
					DWORD			irgpsz		= 0;
					_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
					_TCHAR			szOffset[ 64 ];
					_TCHAR			szLength[ 64 ];
					_TCHAR			szError[ 64 ];

					if ( m_pfapiLog->ErrPath( szAbsPath ) < JET_errSuccess )
						{
						OSSTRCopy( szAbsPath, _T( "<< cannot get filepath >>" ) );
						}
					_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibOffset, ibOffset );
					_stprintf( szLength, _T( "%u (0x%08x)" ), cbLength, cbLength );
					_stprintf( szError, _T( "%i (0x%08x)" ), JET_errLogTornWriteDuringHardRestore, JET_errLogTornWriteDuringHardRestore );

					rgpszT[ irgpsz++ ]	= szAbsPath;
					rgpszT[ irgpsz++ ]	= szOffset;
					rgpszT[ irgpsz++ ]	= szLength;
					rgpszT[ irgpsz++ ]	= szError;

					UtilReportEvent(	eventError,
										LOGGING_RECOVERY_CATEGORY,
										LOG_RANGE_CHECKSUM_MISMATCH_ID,
										irgpsz,
										rgpszT );
										
					//	this generation is part of a backup set -- we must fail

					Assert( lgposScan.lGeneration >= m_lGenLowRestore );
					UtilReportEvent(	eventError, 
										LOGGING_RECOVERY_CATEGORY, 
										LOG_TORN_WRITE_DURING_HARD_RESTORE_ID, 
										2, 
										rgpsz );

					Call( ErrERRCheck( JET_errLogTornWriteDuringHardRestore ) );
					}

				//	the current log generation is not part of the backup-set
				//	we can only patch edb.log -- all other generations require offline patching
				//		because generations after the bad one need to be deleted

				//	only report an error message when we cannot patch the log file

				if ( !fJetLog || fReadOnly )
					{
#ifdef ENABLE_LOGPATCH_TRACE
					if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
						{
						(*pcprintfLogPatch)( "failed to patch torn-write because %s\r\n",
											( !fJetLog ? "fJetLog==FALSE" : "we are in read-only mode" ) );
						}
#endif	//	ENABLE_LOGPATCH_TRACE

					//  report log file corruption to the event log

					const _TCHAR*	rgpszT[ 4 ];
					DWORD			irgpsz		= 0;
					_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
					_TCHAR			szOffset[ 64 ];
					_TCHAR			szLength[ 64 ];
					_TCHAR			szError[ 64 ];

					if ( m_pfapiLog->ErrPath( szAbsPath ) < JET_errSuccess )
						{
						OSSTRCopy( szAbsPath, _T( "<< cannot get filepath >>" ) );
						}
					_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibOffset, ibOffset );
					_stprintf( szLength, _T( "%u (0x%08x)" ), cbLength, cbLength );
					_stprintf( szError, _T( "%i (0x%08x)" ), JET_errLogTornWriteDuringHardRecovery, JET_errLogTornWriteDuringHardRecovery );

					rgpszT[ irgpsz++ ]	= szAbsPath;
					rgpszT[ irgpsz++ ]	= szOffset;
					rgpszT[ irgpsz++ ]	= szLength;
					rgpszT[ irgpsz++ ]	= szError;

					UtilReportEvent(	eventError,
										LOGGING_RECOVERY_CATEGORY,
										LOG_RANGE_CHECKSUM_MISMATCH_ID,
										irgpsz,
										rgpszT );

					UtilReportEvent(	eventError,
										LOGGING_RECOVERY_CATEGORY, 
										LOG_TORN_WRITE_DURING_HARD_RECOVERY_ID, 
										2, 
										rgpsz );

					Call( ErrERRCheck( JET_errLogTornWriteDuringHardRecovery ) );
					}

				CallS( err );
				}
			else if ( fJetLog && !fReadOnly )
				{

				//	we are in soft-recovery mode

				//UtilReportEvent(	eventWarning,
				//					LOGGING_RECOVERY_CATEGORY, 
				//					LOG_TORN_WRITE_DURING_SOFT_RECOVERY_ID, 
				//					2, 
				//					rgpsz );

				CallS( err );
				}
			else
				{

				//	we are not in edb.log OR we are in read-only mode

				if ( fJetLog )
					{

					//	we are in edb.log, so we can theoretically patch the torn-write

					if ( pfIsPatchable )
						{

						//	the caller wants to know if the log is patchable
						//	by returning TRUE, we imply that the log is damaged so we don't need to return 
						//		an error as well

						*pfIsPatchable = fTrue;
						err = JET_errSuccess;
						goto HandleError;
						}
					}

#ifdef ENABLE_LOGPATCH_TRACE
				if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
					{
					(*pcprintfLogPatch)( "failed to patch torn-write because %s\r\n",
										 fJetLog ? "we are in read-only mode" : "we are not in the last log file (e.g. edb.log)" );
					}
#endif	//	ENABLE_LOGPATCH_TRACE

				//  report log file corruption to the event log

				const _TCHAR*	rgpsz[ 4 ];
				DWORD			irgpsz		= 0;
				_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
				_TCHAR			szOffset[ 64 ];
				_TCHAR			szLength[ 64 ];
				_TCHAR			szError[ 64 ];

				if ( m_pfapiLog->ErrPath( szAbsPath ) < JET_errSuccess )
					{
					OSSTRCopy( szAbsPath, _T( "<< cannot get filepath >>" ) );
					}
				_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibOffset, ibOffset );
				_stprintf( szLength, _T( "%u (0x%08x)" ), cbLength, cbLength );
				_stprintf( szError, _T( "%i (0x%08x)" ), JET_errLogFileCorrupt, JET_errLogFileCorrupt );

				rgpsz[ irgpsz++ ]	= szAbsPath;
				rgpsz[ irgpsz++ ]	= szOffset;
				rgpsz[ irgpsz++ ]	= szLength;
				rgpsz[ irgpsz++ ]	= szError;

				UtilReportEvent(	eventError,
									LOGGING_RECOVERY_CATEGORY,
									LOG_RANGE_CHECKSUM_MISMATCH_ID,
									irgpsz,
									rgpsz );

				//	return corruption

				Call( ErrERRCheck( JET_errLogFileCorrupt ) );
				}
			}
		else
			{

			//	we have corruption

			if ( csecScan == 0 )
				{

				//	we found the pattern outside the forward range, but not inside it
				//	thus, the corruption was inside the forward range

				Assert( fRecordOkRangeBad );
				sprintf( szCorruption, "%d", lgposCurrent.isec + 1 );
				}
			else
				{

				//	we did not find the pattern
				//	the corruption must be after the forward range

				Assert( pbScan == PbSecAligned( pbScan ) );
				Assert( pbEnsureScan == PbSecAligned( pbEnsureScan ) );
				sprintf( szCorruption, "%d", lgposScan.isec + ( ( pbScan - pbEnsureScan ) / m_cbSec ) );
				}
				
			//	what recovery mode are we in?

			if ( m_fHardRestore )
				{
				//	we are in hard-recovery mode

				if ( lgposScan.lGeneration <= m_lGenHighRestore )
					{
#ifdef ENABLE_LOGPATCH_TRACE
					if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
						{
						(*pcprintfLogPatch)( "corruption detected during hard restore (this log is in the backup set)\r\n" );
						}
#endif	//	ENABLE_LOGPATCH_TRACE

					//  report log file corruption to the event log

					const _TCHAR*	rgpszT[ 4 ];
					DWORD			irgpsz		= 0;
					_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
					_TCHAR			szOffset[ 64 ];
					_TCHAR			szLength[ 64 ];
					_TCHAR			szError[ 64 ];

					if ( m_pfapiLog->ErrPath( szAbsPath ) < JET_errSuccess )
						{
						OSSTRCopy( szAbsPath, _T( "<< cannot get filepath >>" ) );
						}
					_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibOffset, ibOffset );
					_stprintf( szLength, _T( "%u (0x%08x)" ), cbLength, cbLength );
					_stprintf( szError, _T( "%i (0x%08x)" ), JET_errLogCorruptDuringHardRestore, JET_errLogCorruptDuringHardRestore );

					rgpszT[ irgpsz++ ]	= szAbsPath;
					rgpszT[ irgpsz++ ]	= szOffset;
					rgpszT[ irgpsz++ ]	= szLength;
					rgpszT[ irgpsz++ ]	= szError;

					UtilReportEvent(	eventError,
										LOGGING_RECOVERY_CATEGORY,
										LOG_RANGE_CHECKSUM_MISMATCH_ID,
										irgpsz,
										rgpszT );

					//	this generation is part of a backup set -- we must fail

					Assert( lgposScan.lGeneration >= m_lGenLowRestore );
					UtilReportEvent(	eventError, 
										LOGGING_RECOVERY_CATEGORY, 
										LOG_CORRUPTION_DURING_HARD_RESTORE_ID, 
										3, 
										rgpsz );

					Call( ErrERRCheck( JET_errLogCorruptDuringHardRestore ) );
					}

#ifdef ENABLE_LOGPATCH_TRACE
					if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
						{
						(*pcprintfLogPatch)( "corruption detected during hard recovery\r\n" );
						}
#endif	//	ENABLE_LOGPATCH_TRACE

				//  report log file corruption to the event log

				const _TCHAR*	rgpszT[ 4 ];
				DWORD			irgpsz		= 0;
				_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
				_TCHAR			szOffset[ 64 ];
				_TCHAR			szLength[ 64 ];
				_TCHAR			szError[ 64 ];

				if ( m_pfapiLog->ErrPath( szAbsPath ) < JET_errSuccess )
					{
					OSSTRCopy( szAbsPath, _T( "<< cannot get filepath >>" ) );
					}
				_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibOffset, ibOffset );
				_stprintf( szLength, _T( "%u (0x%08x)" ), cbLength, cbLength );
				_stprintf( szError, _T( "%i (0x%08x)" ), JET_errLogCorruptDuringHardRecovery, JET_errLogCorruptDuringHardRecovery );

				rgpszT[ irgpsz++ ]	= szAbsPath;
				rgpszT[ irgpsz++ ]	= szOffset;
				rgpszT[ irgpsz++ ]	= szLength;
				rgpszT[ irgpsz++ ]	= szError;

				UtilReportEvent(	eventError,
									LOGGING_RECOVERY_CATEGORY,
									LOG_RANGE_CHECKSUM_MISMATCH_ID,
									irgpsz,
									rgpszT );

				//	the current log generation is not part of the backup-set

				UtilReportEvent(	eventError,
									LOGGING_RECOVERY_CATEGORY, 
									LOG_CORRUPTION_DURING_HARD_RECOVERY_ID, 
									3, 
									rgpsz );
						
				Call( ErrERRCheck( JET_errLogCorruptDuringHardRecovery ) );
				}
			else if ( !fReadOnly )
				{

#ifdef ENABLE_LOGPATCH_TRACE
				if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
					{
					(*pcprintfLogPatch)( "corruption detected during soft recovery\r\n" );
					}
#endif	//	ENABLE_LOGPATCH_TRACE

				//  report log file corruption to the event log

				const _TCHAR*	rgpszT[ 4 ];
				DWORD			irgpsz		= 0;
				_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
				_TCHAR			szOffset[ 64 ];
				_TCHAR			szLength[ 64 ];
				_TCHAR			szError[ 64 ];

				if ( m_pfapiLog->ErrPath( szAbsPath ) < JET_errSuccess )
					{
					OSSTRCopy( szAbsPath, _T( "<< cannot get filepath >>" ) );
					}
				_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibOffset, ibOffset );
				_stprintf( szLength, _T( "%u (0x%08x)" ), cbLength, cbLength );
				_stprintf( szError, _T( "%i (0x%08x)" ), JET_errLogFileCorrupt, JET_errLogFileCorrupt );

				rgpszT[ irgpsz++ ]	= szAbsPath;
				rgpszT[ irgpsz++ ]	= szOffset;
				rgpszT[ irgpsz++ ]	= szLength;
				rgpszT[ irgpsz++ ]	= szError;

				UtilReportEvent(	eventError,
									LOGGING_RECOVERY_CATEGORY,
									LOG_RANGE_CHECKSUM_MISMATCH_ID,
									irgpsz,
									rgpszT );

				//	we are in soft-recovery mode

				UtilReportEvent(	eventError,
									LOGGING_RECOVERY_CATEGORY, 
									LOG_CORRUPTION_DURING_SOFT_RECOVERY_ID, 
									3, 
									rgpsz );

				Call( ErrERRCheck( JET_errLogFileCorrupt ) );
				}
			else
				{
#ifdef ENABLE_LOGPATCH_TRACE
				if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
					{
					(*pcprintfLogPatch)( "corruption detected\r\n" );
					}
#endif	//	ENABLE_LOGPATCH_TRACE

				//	we are in the dump code

				//	try to make sure this really is the dump code

				Assert( fOldRecovering && fOldRecoveringMode == fRecoveringNone );
				Assert( !m_fHardRestore );
				Assert( fCreatedLogReader );

				//  report log file corruption to the event log

				const _TCHAR*	rgpsz[ 4 ];
				DWORD			irgpsz		= 0;
				_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
				_TCHAR			szOffset[ 64 ];
				_TCHAR			szLength[ 64 ];
				_TCHAR			szError[ 64 ];

				if ( m_pfapiLog->ErrPath( szAbsPath ) < JET_errSuccess )
					{
					OSSTRCopy( szAbsPath, _T( "<< cannot get filepath >>" ) );
					}
				_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibOffset, ibOffset );
				_stprintf( szLength, _T( "%u (0x%08x)" ), cbLength, cbLength );
				_stprintf( szError, _T( "%i (0x%08x)" ), JET_errLogFileCorrupt, JET_errLogFileCorrupt );

				rgpsz[ irgpsz++ ]	= szAbsPath;
				rgpsz[ irgpsz++ ]	= szOffset;
				rgpsz[ irgpsz++ ]	= szLength;
				rgpsz[ irgpsz++ ]	= szError;

				UtilReportEvent(	eventError,
									LOGGING_RECOVERY_CATEGORY,
									LOG_RANGE_CHECKSUM_MISMATCH_ID,
									irgpsz,
									rgpsz );
				
				//	return corruption

				Call( ErrERRCheck( JET_errLogFileCorrupt ) );
				}
			}
		}
	else
		{

		//	we did not need to scan for a torn-write or corruption
		//	however, we should scan the rest of the log to make sure we only see the pattern
		//	(if we find anything, we must assume that the log is corrupt [probably due to an I/O not making it out to disk])

		ULONG		isecScan;
		ULONG		csecScan		= 0;
		BYTE 		*pbEnsureScan	= NULL;
		BYTE		*pbScan			= NULL;
		BOOL		fFoundPattern	= fTrue;	//	assume we will find a torn write
		CHAR 		szSector[30];
		CHAR		szCorruption[30];
		const CHAR*	rgpsz[3]		= { m_szLogName, szSector, szCorruption };

		//	prepare the event-log messages

		OSSTRCopyA( szSector, "END" );
		szCorruption[0] = 0;

		//	we should NEVER EVER point past the end of the log file

		Assert( lgposEnd.isec <= ( m_csecLGFile - 1 ) );

		//	get the starting sector for the scan

		isecScan = lgposEnd.isec;
		if ( lgposEnd.ib )
			{
			isecScan++;					//	round up to the next sector
			}
		isecScan++;						//	skip the shadow sector
	
		//	determine if there is any data to scan through
		
		if ( isecScan < m_csecLGFile )
			{

			//	read in the data we need to scan 
			//	(including the extra sector we reserve for the final shadow sector)

			Call( plread->ErrEnsureSector( isecScan, m_csecLGFile - isecScan, &pbEnsureScan ) );

			//	scan sector by sector looking for the log-extend pattern

			Assert( cbLogExtendPattern >= m_cbSec );
			pbScan = pbEnsureScan;
			csecScan = 0;
			while ( isecScan + csecScan < m_csecLGFile )
				{

				//	does the entire sector match the log-extend pattern?
					
				if ( memcmp( pbScan, rgbLogExtendPattern, m_cbSec ) != 0 )
					{

					//	no; this is not a torn write

					fFoundPattern = fFalse;
					break;
					}
					
				//	advance the scan counters

				pbScan += m_cbSec;
				csecScan++;
				}

			if ( !fFoundPattern )
				{

				//	we didn't find the pattern -- the log file must be corrupt!

				sprintf( szCorruption, "%d (0x%08X)", isecScan + csecScan, isecScan + csecScan );

				//	this should only happen to edb.log

				Assert( fJetLog );

				if ( m_fHardRestore )
					{

					//	we are in hard-recovery mode

					if ( lgposScan.lGeneration <= m_lGenHighRestore )
						{
#ifdef ENABLE_LOGPATCH_TRACE
						if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
							{
							(*pcprintfLogPatch)( "corruption detected during hard restore (this log is in the backup set) -- data was found after the end of the log!\r\n" );
							}
#endif	//	ENABLE_LOGPATCH_TRACE

						//  report log file corruption to the event log

						Assert( lgposScan.lGeneration >= m_lGenLowRestore );
						UtilReportEvent(	eventError, 
											LOGGING_RECOVERY_CATEGORY, 
											LOG_CORRUPTION_DURING_HARD_RESTORE_ID, 
											3, 
											rgpsz );

						Call( ErrERRCheck( JET_errLogCorruptDuringHardRestore ) );
						}

#ifdef ENABLE_LOGPATCH_TRACE
					if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
						{
						(*pcprintfLogPatch)( "corruption detected during hard recovery -- data was found after the end of the log!\r\n" );
						}
#endif	//	ENABLE_LOGPATCH_TRACE

					//  report log file corruption to the event log

					UtilReportEvent(	eventError,
										LOGGING_RECOVERY_CATEGORY, 
										LOG_CORRUPTION_DURING_HARD_RECOVERY_ID, 
										3, 
										rgpsz );
							
					Call( ErrERRCheck( JET_errLogCorruptDuringHardRecovery ) );
					}
				else if ( !fReadOnly )
					{
#ifdef ENABLE_LOGPATCH_TRACE
					if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
						{
						(*pcprintfLogPatch)( "corruption detected during soft recovery -- data was found after the end of the log!\r\n" );
						}
#endif	//	ENABLE_LOGPATCH_TRACE

					//  report log file corruption to the event log

					UtilReportEvent(	eventError,
										LOGGING_RECOVERY_CATEGORY, 
										LOG_CORRUPTION_DURING_SOFT_RECOVERY_ID, 
										3, 
										rgpsz );

					Call( ErrERRCheck( JET_errLogFileCorrupt ) );
					}
				else
					{
#ifdef ENABLE_LOGPATCH_TRACE
					if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
						{
						(*pcprintfLogPatch)( "corruption detected -- data was found after the end of the log!\r\n" );
						}
#endif	//	ENABLE_LOGPATCH_TRACE

					//	we are in the dump code

					//	try to make sure this really is the dump code

					Assert( fOldRecovering && fOldRecoveringMode == fRecoveringNone );
					Assert( !m_fHardRestore );
					Assert( fCreatedLogReader );

					Call( ErrERRCheck( JET_errLogFileCorrupt ) );
					}
				}
			}
		else
			{
			
			//	there is nothing to scan because we are at the end of the log file

			//	nop
			}
		}

	//	the log should be completely valid or atleast fixable by now
	//		lgposLast is the last LRCHECKSUM record we verified and now trust
	//		lgposEnd is the absolute end of good data (this marks the area we are going to
	//			chop off and treat as garbage -- it include any corrupt data we don't trust)
	//
	//	start searching the last range of log records for markings of a graceful exit:
	//		lrtypTerm, lrtypRecoveryQuit log records are what we want
	//		lrtypNOP, lrtypChecksum records have no effect and are ignored
	//		all other log records indicate a non-graceful exit
	//
	//	NOTE: since we trust the data we are scanning (because we verified it with the checksum),
	//		  we assume that every log record will be recognizable

	//	start at the first record after the last good LRCHECKSUM record

	lgposCurrent = lgposLast;
	AddLgpos( &lgposCurrent, sizeof( LRCHECKSUM ) );

	//	read in the LRCHECKSUM record

	Call( plread->ErrEnsureSector( lgposLast.isec, 1, &pbEnsure ) );
	plrck = (LRCHECKSUM *)( pbEnsure + lgposLast.ib );
	AssertValidLRCKRecord( plrck, &lgposLast );

	//	get the sector position of the next LRCHECKSUM record (if there is one)
	//
	//	we will use this in the record-to-record scan to determine when we have crossed over
	//		into the backward range of the next LRCHECKSUM record; more specifically, it will
	//		be important when the backward range of the next LRCHECKSUM record is zero even
	//		though there is space there (e.g. not covered by a checksum record)
	//	SPECIAL CASE: when fSkipScanAndApplyPatch is set, we need to bypass using lgposNext
	//					even though it SHOULD work out (not point in testing unfriendly waters)

	lgposNext = lgposMin;
	if ( plrck->le_cbNext != 0 && !fSkipScanAndApplyPatch )
		{

		//	point to the next LRCHECKSUM record 
		
		lgposNext = lgposLast;
		AddLgpos( &lgposNext, sizeof( LRCHECKSUM ) + plrck->le_cbNext );
		Assert( lgposNext.isec > lgposLast.isec );

		//	bring in the next LRCHECKSUM record

		Call( plread->ErrEnsureSector( lgposNext.isec, 1, &pbEnsure ) );
		plrck = (LRCHECKSUM *)( pbEnsure + lgposNext.ib );

		//	if the LRCHECKSUM is invalid or the backward range covers all data, 
		//		then we won't need to use lgposNext

		if ( !FValidLRCKRecord( plrck, &lgposNext ) || plrck->le_cbBackwards == lgposNext.ib )
			{
			lgposNext.isec = 0;
			}
		else
			{

			//	there is no need to validate the range to verify the data in the LRCHECKSUM record's
			//		backward range; look at the cases where we could have a valid record and an invalid range:
			//			- multi-sector LRCHECKSUM with a short checksum
			//			- single-sector LRCHECKSUM with no short checksum
			//
			//		in the case of the short checksum, the validation of the LRCHECKSUM record's backward
			//			range is the short checksum itself
			//		in the case of not having a short checksum, we must be looking at:
			//			- a valid range
			//			- an invalid range that was fixed by patching with the shadow sector
			//			***> there is no chance of a torn-write because that would mean the next LRCHECKSUM 
			//				 pointer would be aimed at the pattern, and FValidLRCKRecord would have failed
			//			***> there is no chance of corruption because that would have already been detected
			//				 and handled by dispatching an error
			
			Assert( plrck->le_cbBackwards == 0 );

//
//	NOT ANY MORE -- WE LEAVE THE OLD DATA THERE FOR DEBUGGING PURPOSES
//
//			//	the area before the LRCHECKSUM record should be the pattern
//			
//			Assert( memcmp( pbEnsure, rgbLogExtendPattern, lgposNext.ib ) == 0 );
			}
		}

	//	if the end of data is before this LRCHECKSUM, then we won't need to use lgposNext
		
	if ( CmpLgpos( &lgposNext, &lgposEnd ) >= 0 )
		{		
		lgposNext.isec = 0;
		}

#ifdef ENABLE_LOGPATCH_TRACE
	if ( pcprintfLogPatch && FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
		{
		(*pcprintfLogPatch)( "scanning the log records in the last LRCK range\r\n" );
		(*pcprintfLogPatch)( "\tlgposCurrent = {0x%x,0x%x,0x%x}\r\n", lgposCurrent.lGeneration, lgposCurrent.isec, lgposCurrent.ib );
		(*pcprintfLogPatch)( "\tlgposEnd     = {0x%x,0x%x,0x%x}\r\n", lgposEnd.lGeneration, lgposEnd.isec, lgposEnd.ib );
		(*pcprintfLogPatch)( "\tlgposNext    = {0x%x,0x%x,0x%x}\r\n", lgposNext.lGeneration, lgposNext.isec, lgposNext.ib  );
		}
#endif	//	ENABLE_LOGPATCH_TRACE

	//	loop forever

	forever
		{
		BYTE	*pb;
		UINT	cIteration, cb;
		LGPOS	lgposEndOfRec;

		//	bring in an entire log record in three passes
		//		first, bring in the byte for the LRTYP
		//		second, bring in the FIXED portion of the record
		//		third, bring in the entire record

RestartIterations:

		//	have we passed the end of the good data area?
		
		if ( CmpLgpos( &lgposCurrent, &lgposEnd ) >= 0 )
			{
			
			//	yes; stop looping

			goto DoneRecordScan;
			}


		for ( cIteration = 0; cIteration < 3; cIteration++ )
			{
			if ( cIteration == 0 )
				{
				cb = sizeof( LRTYP );
				Assert( sizeof( LRTYP ) == 1 );
				}
			else if ( cIteration == 1 )
				{
				cb = CbLGFixedSizeOfRec( reinterpret_cast< const LR * >( pb ) );
				}
			else
				{
				Assert( cIteration == 2 );
				cb = CbLGSizeOfRec( reinterpret_cast< const LR * >( pb ) );
				}

			//	point to the end of the data we want

			lgposEndOfRec = lgposCurrent;
			AddLgpos( &lgposEndOfRec, cb );

			//	have we passed the end of the good data area?
			
			if ( CmpLgpos( &lgposEndOfRec, &lgposEnd ) > 0 )
				{
				
				//	yes; stop looping

				goto DoneRecordScan;
				}

			//	see if we have crossed over into the area before the next LRCHECKSUM record which is
			//		not covered by the backward range

			if ( lgposNext.isec )
				{

				//	we should always land exactly on the sector with the next LRCHECKSUM record
				//		(we can't shoot past it -- otherwise, we would have overwritten it)
				
				Assert( lgposEndOfRec.isec <= lgposNext.isec );

				//	see if we are in the same sector
				
				if ( lgposEndOfRec.isec == lgposNext.isec )
					{

					//	we are pointing into the area before the next LRCHECKSUM record
					//	this area is not be covered by the backward range, so we need to do a fixup
					//		on lgposCurrent by moving it to the LRCHECKSUM record itself
					
					lgposCurrent = lgposNext;

					//	do not let this run again

					lgposNext.isec = 0;

					//	restart the iterations
					
					goto RestartIterations;
					}
				}

			//	read the data we need for this iteration

			Assert( cb > 0 );
			Call( plread->ErrEnsureSector( lgposCurrent.isec, ( lgposCurrent.ib + cb - 1 ) / m_cbSec + 1, &pbEnsure ) );

			//	set a pointer to it's record type information (1 byte)

			pb = pbEnsure + lgposCurrent.ib;

			//	make sure we recognize the log record

			Assert( *pb >= 0 && *pb < lrtypMax );
			}


		//	we now have a complete log record

		Assert( *pb >= 0 && *pb < lrtypMax );
		Assert( cb == CbLGSizeOfRec( (LR *)pb ) );
		
		//	check the type

		if ( *pb == lrtypTerm || *pb == lrtypTerm2 || *pb == lrtypRecoveryQuit || *pb == lrtypRecoveryQuit2 )
			{
			//	these types indicate a clean exit
			
			fGotQuit = fTrue;
			}
		else if ( *pb == lrtypNOP )
			{
			//	NOPs are ignored and have no influence on the fGotQuit flag
			}
		else if ( *pb == lrtypChecksum )
			{
			
			//	LRCKECUSMs are ignored and have no influence on the fGotQuit flag

			//	remember an LRCHECKSUM record as good if we see one

			lgposLast = lgposCurrent;

			//	this should only happen in the case where we have no corruption and no forward range
			//		in the current LRCHECKSUM

			//	we shouldn't have scanned for corruption

			Assert( !fDoScan );

			//	we should find this record right before we hit the end of data

#ifdef DEBUG
			LGPOS lgposT = lgposLast;
			AddLgpos( &lgposT, sizeof( LRCHECKSUM ) );
			Assert( CmpLgpos( &lgposT, &lgposEnd ) == 0 );
#endif
			}
		else
			{

			//	we cannot assume a clean exit since the last record we saw was not a Term or a Recovery-Quit

			fGotQuit = fFalse;
			}

		//	set the current log position to the next log record

		lgposCurrent = lgposEndOfRec;
		}

DoneRecordScan:

	if ( fRecordOkRangeBad )
		{

		//	we need to do a fixup in the case where we successfully verified the sector with the LRCHECKSUM 
		//		record (using the short checksum value) but could not verify the other sectors in the range 
		//		of the LRCHECKSUM record (using the long checksum)
		//
		//	the problem is that the "forward" pointer reaches past the sector boundary of the good sector
		//		(which is holding the LRCHECKSUM record), and, in doing so, it covers bad data
		//
		//	the fix is to shorten the "forward" pointer to include only the good data (up to lgposCurrent)
		//		and update the corrupt area in the log file with this new LRCHECKSUM record

		Assert( !fSingleSectorTornWrite );
		Assert( fDoScan );		//	we should have seen corruption or a torn-write

		//	load the sector with the last good LRCHECKSUM record

		Call( plread->ErrEnsureSector( lgposLast.isec, 1, &pbEnsure ) );
		plrck = reinterpret_cast< LRCHECKSUM* >( pbEnsure + lgposLast.ib );

		AssertValidLRCKRecord( plrck, &lgposLast );		//	it should be valid
		Assert( plrck->bUseShortChecksum == bShortChecksumOn );	//	it should be a multi-sector range
		Assert( plrck->le_cbBackwards == ( (BYTE *)plrck - PbSecAligned( (BYTE *)plrck ) ) );

		//	calculate the byte offset (this may have wrapped around to 0 when we were scanning record-to-record)

		const UINT ib = ( lgposCurrent.ib > 0 ) ? lgposCurrent.ib : m_cbSec;

		//	the current position should be at or past the point in the current sector immediately
		//	following the backward range and the LRCHECKSUM record itself
		//		(lgposCurrent should point at the first bad log record)

		Assert( ib >= plrck->le_cbBackwards + sizeof( LRCHECKSUM ) );

		//	remember that we must overwrite the part of the LRCHECKSUM range that we are "chopping off"

		Assert( 0 == ( lgposLast.ib + sizeof( LRCHECKSUM ) + plrck->le_cbForwards ) % m_cbSec );
		const ULONG csecRange = ( lgposLast.ib + sizeof( LRCHECKSUM ) + plrck->le_cbForwards ) / m_cbSec;
		if ( csecRange > 2 )
			{
			isecPatternFill = lgposLast.isec + 2;	//	skip the sector we are patching and its shadow
			csecPatternFill = csecRange - 2;
			}
		else
			{

			//	the range should only encompass 2 sectors
			
			//	we don't need to rewrite the logfile pattern because those 2 sectors will be overwritten
			//	when we write the patched sector and its shadow

			Assert( 2 == csecRange );
			}

		//	adjust the "forward" pointer

		plrck->le_cbForwards = ib - ( plrck->le_cbBackwards + sizeof( LRCHECKSUM ) );

		//	there is no data after this LRCHECKSUM record

		plrck->le_cbNext = 0;

		//	copy the last sector into pbLastSector for the next flush

		UtilMemCpy( pbLastSector, pbEnsure, m_cbSec );

		//	prepare pbLastChecksum and isecLastWrite for the next flush

		pbLastChecksum = pbLastSector + plrck->le_cbBackwards;
		isecLastSector = lgposLast.isec;
		}

	//	we have now completed scanning the last range of log records covered by the
	//		last good LRCHECKSUM record and we know if a graceful exit was previously made (fGotQuit)

	//	set the graceful exit flag for the user

	Assert( pfCloseNormally );
	*pfCloseNormally = fGotQuit;

	//	set m_lgposLastRec to the lesser of lgposCurrent or lgposEnd for REDO time 
	//		(the REDO engine will not exceed this log position)
	//	in most cases, lgposCurrent will be less than lgposEnd and will point to the first BAD log record
	//	in the rare case where we don't have a single good LRCHECKSUM record, lgposCurrent will point past
	//		lgposEnd due to the way we initialized it before entering the search-loop

	if ( CmpLgpos( &lgposCurrent, &lgposEnd ) <= 0 )
		{
		m_lgposLastRec = lgposCurrent;
		}
	else
		{
		m_lgposLastRec = lgposEnd;
		}

#ifdef ENABLE_LOGPATCH_TRACE
	if ( pcprintfLogPatch && FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
		{
		(*pcprintfLogPatch)( "finished scanning the last LRCK range\r\n" );
		(*pcprintfLogPatch)( "\tfGotQuit            = %s\r\n", ( fGotQuit ? "TRUE" : "FALSE" ) );
		(*pcprintfLogPatch)( "\tLOG::m_lgposLastRec = {0x%x,0x%x,0x%x}\r\n", m_lgposLastRec.lGeneration, m_lgposLastRec.isec, m_lgposLastRec.ib );
		}
#endif	//	ENABLE_LOGPATCH_TRACE

	//	if this is a single-sector torn-write case, we need to patch the forward/next pointers

	if ( fSingleSectorTornWrite )
		{

		//	the first bad log record should be in the same sector as the checksum record
		//		OR should be aligned perfectly with the start of the next sector

		Assert( ( m_lgposLastRec.isec == lgposLast.isec && CmpLgpos( &lgposLast, &m_lgposLastRec ) < 0 ) ||
				( m_lgposLastRec.isec == lgposLast.isec + 1 && m_lgposLastRec.ib == 0 ) );

		//	point to the LRCHECKSUM record within the copy of the last sector

		Assert( pbLastChecksum != pbNil );
		plrck = (LRCHECKSUM *)pbLastChecksum;

		//	reset the pointers

		const UINT ibT = ( m_lgposLastRec.ib == 0 ) ? m_cbSec : m_lgposLastRec.ib;
		Assert( ibT >= lgposLast.ib + sizeof( LRCHECKSUM ) );
		plrck->le_cbForwards = ibT - ( lgposLast.ib + sizeof( LRCHECKSUM ) );
		plrck->le_cbNext = 0;
		}

	//	skip the write-error handler

	goto HandleError;


LHandleErrorWrite:

/********
//	when we fail to fixup the log file, is it a read or a write?
//	LGReportError( LOG_READ_ERROR_ID, err );
//	goto HandleError;
*********/

	//	report log-file write failures to the event log
	LGReportError( LOG_WRITE_ERROR_ID, err );


HandleError:

	//	handle errors and exit the function

	//	cleanup the LogReader class 

	if ( fCreatedLogReader )
		{
		ERR errT = JET_errSuccess;

		if ( plread->FInit() )
			{

			//	terminate the log reader

			errT = plread->ErrLReaderTerm();
			}
		
		//	delete the log reader

		delete plread;
		plread = NULL;

		//	fire off the error trap if necessary

		if ( errT != JET_errSuccess )
			{
			errT = ErrERRCheck( errT );
			}

		//	return the error code if no other error code yet exists

		if ( err == JET_errSuccess )
			{
			err = errT;
			}
		}
	else if ( NULL != plread )
		{

		//	we never created the log reader, so we can't destroy it because other users may have pointers to it
		//	instead, we just invalidate its data pointers forcing it go to disk the next time someone does a read

		plread->Reset();
		}

	//	if things went well, we can patch the current log before returning
	//		(we can only do this if we are in read/write mode and the log is edb.log)

	if ( err >= 0 && !fReadOnly && fJetLog )
		{

		//	we are not expecting any warnings here

		CallS( err );

		//	do we need to make a new log file?

		if ( fLogToNextLogFile )
			{

			//	since the log creation is deferred, we must setup the buffers here and let the log
			//		flush thread pick up on them later; however, if we didn't create the log reader,
			//		we will lose the contents of our buffers later when the log reader is terminated
			//	thus, we shouldn't bother doing anything until we own the log reader ourselves
			
			if ( fCreatedLogReader ) 
				{

				//	the last sector should not be setup

				Assert( pbLastChecksum == pbNil );

				//	the last LRCHECKSUM record should be completely clean

				Assert( !fRecordOkRangeBad );

				//	we should not have scanned for corruption

				Assert( !fDoScan );

				//	lock the log pointers

				m_critLGBuf.Enter();

				//	the first sector to write is the first sector in the next log file

				m_isecWrite					= m_csecHeader;

				//	the write pointer and the last-checksum pointer both start at the beginning of 
				//		the log buffer

				m_pbWrite					= m_pbLGBufMin;
				m_pbLastChecksum 			= m_pbLGBufMin;

				//	the entry pointer is the area in the log buffer immediately following the  
				//		newly-created LRCHECKSUM record

				m_pbEntry					= m_pbLastChecksum + sizeof( LRCHECKSUM );

				//	setup the beginning of the new log generation with a single LRCHECKSUM record; 
				//		put it at the start of the log buffers

				Assert( pbNil != m_pbLGBufMin );
				memset( m_pbLGBufMin, 0, sizeof( LRCHECKSUM ) );
				plrck = reinterpret_cast< LRCHECKSUM* >( m_pbLastChecksum );
				plrck->lrtyp = lrtypChecksum;

				//	the next flush should go all the way up to (but not including) the newly-created 
				//		LRCHECKSUM record

				m_lgposToFlush.isec 		= USHORT( m_isecWrite );
				m_lgposToFlush.lGeneration 	= m_plgfilehdr->lgfilehdr.le_lGeneration + 1;
				m_lgposToFlush.ib 			= 0;

				//	the maximum flush position is the next flush position

				m_lgposMaxFlushPoint 		= m_lgposToFlush;

				//	setup the rest of the LRCHECKSUM record

				plrck->bUseShortChecksum = bShortChecksumOff;
				plrck->le_ulShortChecksum = 0;
				plrck->le_ulChecksum = UlComputeChecksum( plrck, m_lgposToFlush.lGeneration );

				//	make sure the LRCHECKSUM record is valid

				AssertValidLRCKRecord( plrck, &m_lgposToFlush );
				AssertValidLRCKRange( plrck, m_lgposToFlush.lGeneration );

#ifdef ENABLE_LOGPATCH_TRACE
				if ( FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
					{
					(*pcprintfLogPatch)( "forcing a new log generation because fLogToNextLogFile=TRUE\r\n" );
					}
#endif	//	ENABLE_LOGPATCH_TRACE

				//	unlock the log pointers

				m_critLGBuf.Leave();
				}
			}
		else if ( pbLastSector != pbNil )
			{
			BYTE	*pbEndOfData, *pbWrite;
			INT		isecWrite;

			//	we need to patch the last sector of the current log

			//	lock the log pointers

			m_critLGBuf.Enter();

			//	transfer the copy of the last sector into the log buffers

			Assert( pbNil != m_pbLGBufMin );
			UtilMemCpy( m_pbLGBufMin, pbLastSector, m_cbSec );

			//	calculate the distance of the backward pointer 

			const UINT cbBackwards 		= ULONG( pbLastChecksum - pbLastSector );

			//	set the last LRCHECKSUM record pointer to the LRECHECKSUM record within the log buffer

			m_pbLastChecksum 			= m_pbLGBufMin + cbBackwards;

			//	get a pointer to the copy of the last LRCHECKSUM record
			
			plrck = reinterpret_cast< LRCHECKSUM* >( m_pbLastChecksum );

			//	the first sector to write was previously determined

			Assert( isecLastSector >= m_csecHeader && isecLastSector <= ( m_csecLGFile - 1 ) );

			m_isecWrite 				= isecLastSector;

			//	the write pointer is the beginning of the area we just copied into the log buffers
			//		from pbLastSector (it will all need to be flushed again when the LRCHECKSUM record
			//		is updated with a new cbNext, checksum value, etc...)

			m_pbWrite 					= m_pbLGBufMin;

			//	set the entry pointer to the area after the forward range of the LRCHECKSUM record
			
			m_pbEntry 					= m_pbLastChecksum + sizeof( LRCHECKSUM ) + plrck->le_cbForwards;

			//	the next flush position is the area after the existing validated range of 
			//		the LRCHECKSUM record

			m_lgposToFlush.isec 		= USHORT( m_isecWrite );
			m_lgposToFlush.lGeneration 	= m_plgfilehdr->lgfilehdr.le_lGeneration;
			m_lgposToFlush.ib 			= 0;
			AddLgpos( &m_lgposToFlush, cbBackwards + sizeof( LRCHECKSUM ) + plrck->le_cbForwards );

			//	the maximum flush position is the next flush position

			m_lgposMaxFlushPoint 		= m_lgposToFlush;

			//	setup the rest of the LRCHECKSUM record

			plrck->bUseShortChecksum = bShortChecksumOff;
			plrck->le_ulShortChecksum = 0;
			plrck->le_ulChecksum = UlComputeChecksum( plrck, m_plgfilehdr->lgfilehdr.le_lGeneration );

			//	make sure the fix to the log is good

#ifdef DEBUG
			LGPOS lgposChecksum;
			lgposChecksum.ib			= (USHORT)cbBackwards;
			lgposChecksum.isec			= (USHORT)m_isecWrite;
			lgposChecksum.lGeneration	= m_plgfilehdr->lgfilehdr.le_lGeneration;
			AssertValidLRCKRecord( (LRCHECKSUM *)m_pbLastChecksum, &lgposChecksum );
			AssertValidLRCKRange( (LRCHECKSUM *)m_pbLastChecksum, lgposChecksum.lGeneration );
#endif									  

			//	capture the data pointers

			pbEndOfData 				= m_pbEntry;
			pbWrite 					= m_pbWrite;
			isecWrite 					= m_isecWrite;

#ifdef ENABLE_LOGPATCH_TRACE
			if ( pcprintfLogPatch && FLGILogPatchDate( szLogPatchPath, &pcprintfLogPatch ) )
				{
				(*pcprintfLogPatch)( "!!DANGER WILL ROBINSON!! we are about to PATCH the last LRCHECKSUM range\r\n" );

				(*pcprintfLogPatch)( "\tisecPatternFill           = 0x%x\r\n", isecPatternFill );
				(*pcprintfLogPatch)( "\tcsecPatternFill           = 0x%x\r\n", csecPatternFill );
				(*pcprintfLogPatch)( "\tLOG::m_isecWrite          = 0x%08x\r\n", m_isecWrite );
				(*pcprintfLogPatch)( "\t\tLOG::m_pbWrite         = 0x%0*I64x\r\n", sizeof( char* ) * 2, QWORD( m_pbWrite ) );
				(*pcprintfLogPatch)( "\t\tLOG::m_pbEntry         = 0x%0*I64x\r\n", sizeof( char* ) * 2, QWORD( m_pbEntry ) );
				(*pcprintfLogPatch)( "\tLOG::m_lgposToFlush       = {0x%x,0x%x,0x%x}\r\n", m_lgposToFlush.lGeneration, m_lgposToFlush.isec, m_lgposToFlush.ib );
				(*pcprintfLogPatch)( "\tLOG::m_lgposMaxFlushPoint = {0x%x,0x%x,0x%x}\r\n", m_lgposMaxFlushPoint.lGeneration, m_lgposMaxFlushPoint.isec, m_lgposMaxFlushPoint.ib );
				(*pcprintfLogPatch)( "\t\tLOG::m_pbLGBufMin (0x%0*I64x)\r\n", sizeof( char* ) * 2, QWORD( m_pbLGBufMin ) );

				ULONG _ibdumpT_ = 0;
				while ( _ibdumpT_ < m_cbSec )
					{
					(*pcprintfLogPatch)( "\t0x%04x: %02x %02x %02x %02x %02x %02x %02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\r\n",
										_ibdumpT_,
										m_pbLGBufMin[_ibdumpT_+0],  m_pbLGBufMin[_ibdumpT_+1],  m_pbLGBufMin[_ibdumpT_+2],  m_pbLGBufMin[_ibdumpT_+3],
										m_pbLGBufMin[_ibdumpT_+4],  m_pbLGBufMin[_ibdumpT_+5],  m_pbLGBufMin[_ibdumpT_+6],  m_pbLGBufMin[_ibdumpT_+7],
										m_pbLGBufMin[_ibdumpT_+8],  m_pbLGBufMin[_ibdumpT_+9],  m_pbLGBufMin[_ibdumpT_+10], m_pbLGBufMin[_ibdumpT_+11],
										m_pbLGBufMin[_ibdumpT_+12], m_pbLGBufMin[_ibdumpT_+13], m_pbLGBufMin[_ibdumpT_+14], m_pbLGBufMin[_ibdumpT_+15] );
					_ibdumpT_ += 16;
					Assert( _ibdumpT_ <= m_cbSec );
					}

				LRCHECKSUM *_plrckT_ = (LRCHECKSUM *)m_pbLastChecksum;

				(*pcprintfLogPatch)( "\tLOG::m_pbLastChecksum (0x%0*I64x)\r\n", sizeof( char* ) * 2, QWORD( _plrckT_ ) );
				(*pcprintfLogPatch)( "\t  cbBackwards       = 0x%08x\r\n", _plrckT_->le_cbBackwards );
				(*pcprintfLogPatch)( "\t  cbForwards        = 0x%08x\r\n", _plrckT_->le_cbForwards );
				(*pcprintfLogPatch)( "\t  cbNext            = 0x%08x\r\n", _plrckT_->le_cbNext );
				(*pcprintfLogPatch)( "\t  ulChecksum        = 0x%08x\r\n", _plrckT_->le_ulChecksum );
				(*pcprintfLogPatch)( "\t  ulShortChecksum   = 0x%08x\r\n", _plrckT_->le_ulShortChecksum );
				(*pcprintfLogPatch)( "\t  bUseShortChecksum = %s (0x%02x)\r\n", 
									( bShortChecksumOn == _plrckT_->bUseShortChecksum ?
									  "Yes" : 
									  ( bShortChecksumOff == _plrckT_->bUseShortChecksum ?
									    "No" : "???" ) ),
									BYTE( _plrckT_->bUseShortChecksum ) );
				}
#endif	//	ENABLE_LOGPATCH_TRACE

			//	unlock the log pointers

			m_critLGBuf.Leave();

			//	flush the fixup to the log right now

//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
Assert( m_cbSec == m_cbSecVolume );
//			if ( m_cbSec == m_cbSecVolume )
//				{
				if ( 0 != csecPatternFill )
					{
					ULONG csecPatternFillT;
					ULONG csecT;

					//	we are chopping off some partial data to patch a torn-write

					Assert( isecPatternFill >= m_csecHeader );
					Assert( isecPatternFill < m_csecLGFile - 1 );
					Assert( isecPatternFill + csecPatternFill <= m_csecLGFile - 1 );
					Assert( fRecordOkRangeBad );

					//	rewrite the logfile pattern to "erase" the partial data

					csecPatternFillT = 0;
					while ( csecPatternFillT < csecPatternFill )
						{

						//	compute the size of the next write

						csecT = min( csecPatternFill - csecPatternFillT, cbLogExtendPattern / m_cbSec );

						//	do the write

						Assert( isecPatternFill + csecPatternFillT + csecT <= m_csecLGFile - 1 );
						err = m_pfapiLog->ErrIOWrite(	( isecPatternFill + csecPatternFillT ) * m_cbSec,
														csecT * m_cbSec,
														rgbLogExtendPattern );
						if ( err < JET_errSuccess )
							{
							LGReportError( LOG_FLUSH_WRITE_5_ERROR_ID, err );
							m_fLGNoMoreLogWrite = fTrue;
							break;
							}

						//	advance the counters

						csecPatternFillT += csecT;
						}
					}

				if ( err >= JET_errSuccess )
					{

					//	flush the sector and shadow it

					err = ErrLGIWritePartialSector( pbEndOfData, isecWrite, pbWrite );
					}
//				}
//			else
//				{
//				fWriteOnSectorSizeMismatch = fTrue;
//				}
			}
		}

//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//	if ( err >= 0 && fWriteOnSectorSizeMismatch )
//		{
//
//		//	we tried to write to this log file, but our sector size was wrong
//
//		//	return a general sector-size mismatch error to indicate that the databases are
//		//		not necessarily consistent
//
//		err = ErrERRCheck( JET_errLogSectorSizeMismatch );
//		}

#ifndef LOGPATCH_UNIT_TEST

	//	re-open the log file in read-only mode
	
	if ( !fReadOnly )
		{
		ERR errT;

		//	is the file open?  close it
		
		delete m_pfapiLog;
		m_pfapiLog = NULL;

		//	check the name of the file

		Assert( NULL != m_szLogName );
		Assert( '\0' != m_szLogName[ 0 ] );

		//	open the file again

		errT = pfsapi->ErrFileOpen( m_szLogName, &m_pfapiLog, fTrue );

		//	fire off the error trap if necessary

		if ( errT != JET_errSuccess )
			{
			errT = ErrERRCheck( errT );
			}

		//	return the error code if no other error code yet exists

		if ( err == JET_errSuccess )
			{
			err = errT;
			}
		}

#endif	//	!LOGPATCH_UNIT_TEST

	//	free the memory holding the copy of the last sector
			
	OSMemoryHeapFree( pbLastSector );

	//	restore the old state

	m_fRecovering = fOldRecovering;
	m_fRecoveringMode = fOldRecoveringMode;

	//	leave the log-flush critical section

	m_critLGFlush.Leave();

#ifdef ENABLE_LOGPATCH_TRACE

	//	close the output file

	if ( pcprintfLogPatch )
		{
		delete pcprintfLogPatch;
		}
#endif	//	ENABLE_LOGPATCH_TRACE

	//	return any error code we have
	
	return err;
	}


/*
 *  Read first record pointed by plgposFirst.
 *  Initialize m_isecRead, m_pbRead, and m_pbNext.
 *	The first redo record must be within the good portion
 *	of the log file.
 */

//  VC21:  optimizations disabled due to code-gen bug with /Ox
#pragma optimize( "agw", off )
//	Above comment is referring to ErrLGLocateFirstRedoLogRec(), not the
//	FASTFLUSH version, which has never been tried with opt. on.

const UINT cPagesPrereadInitial = 512;
const UINT cPagesPrereadThreshold = 256;
const UINT cPagesPrereadAmount = 256;

ERR LOG::ErrLGLocateFirstRedoLogRecFF
	(
	LE_LGPOS	*ple_lgposRedo,	
	BYTE		**ppbLR			
	)
	{
	ERR			err				= JET_errSuccess;
	LGPOS		lgposCurrent	= { 0, USHORT( m_csecHeader ), m_plgfilehdr->lgfilehdr.le_lGeneration };
	LRCHECKSUM	* plrck			= pNil;
	BYTE		* pbEnsure		= pbNil;	// start of data we're looking at in buffer
	BYTE		* pb			= pbNil;
	LogReader	* plread		= m_plread;
	UINT		cb				= 0;
	BOOL		fValid			= fFalse;

	m_critLGFlush.Enter();

	//	m_lgposLastRec should be set

	Assert( m_lgposLastRec.isec >= m_csecHeader && 
			( m_lgposLastRec.isec < ( m_csecLGFile - 1 ) || 
			  ( m_lgposLastRec.isec == ( m_csecLGFile - 1 ) && m_lgposLastRec.ib == 0 ) ) &&
			m_lgposLastRec.lGeneration == m_plgfilehdr->lgfilehdr.le_lGeneration );

	//	see if we got corruption at the start of the log file
	//		if we have atleast sizeof( LRCHECKSUM ) bytes, we can read the first record which is an
	//		LRCHECKSUM record
	LGPOS lgposHack;
	lgposHack.ib			= sizeof( LRCHECKSUM );
	lgposHack.isec			= USHORT( m_csecHeader );
	lgposHack.lGeneration	= m_plgfilehdr->lgfilehdr.le_lGeneration;
	if ( CmpLgpos( &m_lgposLastRec, &lgposHack ) < 0 )
		{
		//	lgposHack was past the stopping point
		Call( errLGNoMoreRecords );
		}

	*ppbLR = pbNil;
	m_pbNext = pbNil;
	m_pbRead = pbNil;
	m_isecRead = 0;
	m_pbLastChecksum = pbNil;
	m_lgposLastChecksum = lgposMin;

	Assert( pNil != plread );
	
	// This is lazy version of ErrLGLocateFirstRedoLogRec() that will only
	// start from the beginning of the log file.
	Assert( ple_lgposRedo->le_isec == m_csecHeader );
	Assert( ple_lgposRedo->le_ib == 0 );

	m_lgposLastChecksum.lGeneration	= m_plgfilehdr->lgfilehdr.le_lGeneration;
	m_lgposLastChecksum.isec		= USHORT( m_csecHeader );
	m_lgposLastChecksum.ib			= 0;

	// make sure we've got the right log file loaded up
	Call( plread->ErrEnsureLogFile() );

	// read in start of log file
	Call( plread->ErrEnsureSector( lgposCurrent.isec, 1, &pbEnsure ) );
	m_pbLastChecksum = pbEnsure + lgposCurrent.ib;
	plrck = reinterpret_cast< LRCHECKSUM* >( m_pbLastChecksum );

	fValid = FValidLRCKRecord( plrck, &lgposCurrent );

	//	the LRCHECKSUM should always be valid because ErrLGCheckReadLastLogRecordFF will have patched
	//		any and all corruption
	//	just in case...

	if ( !fValid )
		{
		AssertSz( fFalse, "Unexpected invalid LRCK record!" );
		//	start of log file was corrupted
		Call( ErrERRCheck( JET_errLogFileCorrupt ) );
		}

	// Pull in sectors that are part of the range
	Call( plread->ErrEnsureSector( lgposCurrent.isec, ( ( lgposCurrent.ib +
		sizeof( LRCHECKSUM ) + plrck->le_cbForwards - 1 ) / m_cbSec ) + 1,
		&pbEnsure ) );
	m_pbLastChecksum = pbEnsure + lgposCurrent.ib;
	plrck = reinterpret_cast< LRCHECKSUM* >( m_pbLastChecksum );

	fValid = FValidLRCKRange( plrck, m_plgfilehdr->lgfilehdr.le_lGeneration );

	//	the LRCHECKSUM should always be valid because ErrLGCheckReadLastLogRecordFF will have patched
	//		any and all corruption 
	//	just in case...

	if ( !fValid )
		{
		AssertSz( fFalse, "Unexpected invalid LRCK range!" );
		
		//	in a multi-sector flush, it is possible for us to be pointing to an LRCHECKSUM record with 
		//		a corrupt range yet still be able to use the data in the first sector because we
		//		verified it with the short checksum

		if ( plrck->bUseShortChecksum != bShortChecksumOn )
			{

			//	no short checksum -- return corruption

			Call( ErrERRCheck( JET_errLogFileCorrupt ) );
			}

		//	verify that the end of data marker is either already at the end of the current sector
		//		or it is a little before the end (e.g. it is at the start of the last log record in
		//		the sector and that log record stretches over into the next sector)

		Assert( ( m_lgposLastRec.isec == m_csecHeader && m_lgposLastRec.ib >= sizeof( LRCHECKSUM ) ) ||
				( m_lgposLastRec.isec == m_csecHeader + 1 && m_lgposLastRec.ib == 0 ) );
		}

	// we've got a range in the buffer and it's valid, so let's return
	// the LRCK to the clients.

	// LRCK is start of the file, so it must be there
	Assert( sizeof( LRCHECKSUM ) == CbLGFixedSizeOfRec( reinterpret_cast< const LR* >( pbEnsure ) ) );
	Assert( sizeof( LRCHECKSUM ) == CbLGSizeOfRec( reinterpret_cast< const LR* >( pbEnsure ) ) );

	//	setup return variables

	pb = pbEnsure;
	m_pbRead = plread->PbGetEndOfData();
	m_isecRead = plread->IsecGetNextReadSector();
	*ppbLR = m_pbNext = pb;
	
	//	we should have success at this point

	CallS( err );

	// convert m_pbNext & m_pbLastChecksum to LGPOS for preread.
	// Database preread for this log file starts at the same point
	// as the normal log record processing.
	Call( plread->ErrSaveState( &m_lrstatePreread ) );
	GetLgposDuringReading( m_pbNext, &m_lgposPbNextPreread );
	GetLgposDuringReading( m_pbLastChecksum, &m_lgposLastChecksumPreread );

	// Preread is enabled for this log file.
	m_fPreread = fTrue;
	m_cPageRefsConsumed = 0;

#ifdef DEBUG

	if ( getenv( "PREREAD_INITIAL" ) )
		{
		m_cPagesPrereadInitial = atoi( getenv( "PREREAD_INITIAL" ) );
		}
	else
		{
		m_cPagesPrereadInitial = cPagesPrereadInitial;
		}

	if ( getenv( "PREREAD_THRESH" ) )
		{
		m_cPagesPrereadThreshold = atoi( getenv( "PREREAD_THRESH" ) );
		}
	else
		{
		m_cPagesPrereadThreshold = cPagesPrereadThreshold;
		}

	if ( getenv( "PREREAD_AMOUNT" ) )
		{
		m_cPagesPrereadAmount = atoi( getenv( "PREREAD_AMOUNT" ) );
		}
	else
		{
		m_cPagesPrereadAmount = cPagesPrereadAmount;
		}

#else	//	!DEBUG

	m_cPagesPrereadInitial = cPagesPrereadInitial;
	m_cPagesPrereadThreshold = cPagesPrereadThreshold;
	m_cPagesPrereadAmount = cPagesPrereadAmount;

#endif	//	DEBUG

HandleError:

	//	did we get corruption?

	if ( err == JET_errLogFileCorrupt )
		{

		//	what recovery mode are we in?

		if ( m_fHardRestore )
			{

			//	we are in hard-recovery mode

			if ( m_plgfilehdr->lgfilehdr.le_lGeneration <= m_lGenHighRestore )
				{

				//	this generation is part of a backup set
				//	we must fail

				Assert( m_plgfilehdr->lgfilehdr.le_lGeneration >= m_lGenLowRestore );
				err = ErrERRCheck( JET_errLogCorruptDuringHardRestore );
				}
			else
				{

				//	the current log generation is not part of the backup-set
				//	we can patch the log and continue safely

				err = ErrERRCheck( JET_errLogCorruptDuringHardRecovery );
				}
			}
		else
			{

			//	we are in soft-recovery mode -- keep the original error JET_errLogFileCorrupt

			}
		}

	m_critLGFlush.Leave();

	// Do not preread if we had any kind of error
	// or if we're dumping the log
	if ( JET_errSuccess == err && ! m_fDumppingLogs )
		{
		// preread initial pages
		if ( m_cPagesPrereadInitial < m_cPagesPrereadThreshold )
			{
			// next preread will occur once initial page refs have been passed
			m_cPageRefsConsumed = m_cPagesPrereadThreshold - m_cPagesPrereadInitial;
			}
		else
			{
			m_cPageRefsConsumed = 0;
			}
		err = ErrLGIPrereadPages( m_cPagesPrereadInitial );
		}

	return err;
	}


#pragma optimize( "", on )

//	reads/verifies the next LRCHECKSUM record so we can get a complete log record that stretches across
//		two LRCHECKSUM ranges
//	reading the entire LRCHECKSUM range into memory ensures that we have the full log record
//		(the full log record can only use the backward range anyway)
//	
//	lgposNextRec is the start of the log record which stretches across the LRCHECKSUM boundary

//	Implicit input parameters:
//		m_plread
//			To read in the next CK
//		m_pbLastChecksum
//			The current CK record on input, so we can find the next one
//		m_lgposLastChecksum
//			LGPOS of the current CK record on input, so we can compute location of next
//		m_pbNext
//			Points to earliest record to keep in buffer. Nothing before will
//			be in buffer after we return.

ERR LOG::ErrLGIGetNextChecksumFF
	( 
	// LGPOS of next record we want to return to caller.
	// LGPOS of m_pbNext.
	LGPOS 		*plgposNextRec, 
	// Points to start of next record we want to return to caller (UNUSED!!!).
	BYTE 		**ppbLR
	)
	{
	ERR				err = JET_errSuccess;
	// plrck shadows m_pbLastChecksum so we don't have to cast all over.
	LRCHECKSUM*&	plrck = reinterpret_cast< LRCHECKSUM*& >( m_pbLastChecksum );
	LGPOS			lgposNextChecksum;
	UINT			csec;
	BYTE			*pbEnsure;
	LogReader 		*plread = m_plread; 


	//	m_lgposLastRec should be set

	Assert( m_lgposLastRec.isec >= m_csecHeader );
	Assert( m_lgposLastRec.isec < ( m_csecLGFile - 1 ) || 
			( m_lgposLastRec.isec == ( m_csecLGFile - 1 ) && m_lgposLastRec.ib == 0 ) );
	Assert( m_lgposLastRec.lGeneration == m_plgfilehdr->lgfilehdr.le_lGeneration );

	//	validate input params

	Assert( plread != pNil );
	Assert( plgposNextRec->isec >= m_csecHeader );
	Assert( plgposNextRec->isec < ( m_csecLGFile - 1 ) );
	Assert( ppbLR != pNil );
#ifdef DEBUG
	{
	//	check m_pbNext
	LGPOS lgposPbNext;
	GetLgposOfPbNext( &lgposPbNext );
	Assert( CmpLgpos( &lgposPbNext, plgposNextRec ) == 0 );
	}
#endif

	Assert( m_pbLastChecksum != pbNil );
	
	//	is there another LRCHECKSUM record to read?

	if ( plrck->le_cbNext == 0 )
		{

		//	this is the last LRCHECKSUM record meaning we have a partial record whose starting half is 
		//		hanging over the end of the current LRCHECKSUM and whose ending half is ???
		//	the only conclusion is that this must be corruption 

		//	set the end of data marker to this log record (we should never move forwards)

		Assert( CmpLgpos( &m_lgposLastRec, plgposNextRec ) >= 0 );
		m_lgposLastRec = *plgposNextRec;

		//	return the error for corruption

		CallR( ErrERRCheck( JET_errLogFileCorrupt ) );
		}

	//	calculate the log position of the next LRCHECKSUM record

	lgposNextChecksum = m_lgposLastChecksum;
	AddLgpos( &lgposNextChecksum, sizeof( LRCHECKSUM ) + plrck->le_cbNext );

		//	is the next LRCHECKSUM record beyond the end of data pointer?

		//	we must be able to read up to and including the LRCHECKSUM record

		{
		LGPOS lgposEndOfNextChecksumRec = lgposNextChecksum;
		AddLgpos( &lgposEndOfNextChecksumRec, sizeof( LRCHECKSUM ) );

		//	will we pass the end of good data?
			
		if ( CmpLgpos( &lgposEndOfNextChecksumRec, &m_lgposLastRec ) > 0 )
			{

			//	we cannot safely read this LRCHECKSUM record

			CallR( ErrERRCheck( errLGNoMoreRecords ) );
			}
		}

	//	calculate the number of sectors from the log record we want to the next LRCHECKSUM record

	csec = lgposNextChecksum.isec + 1 - plgposNextRec->isec;
	Assert( csec > 0 );

	//	read from the first sector of the next log record to the first sector of the next LRCHECKSUM record

	CallR( plread->ErrEnsureSector( plgposNextRec->isec, csec, &pbEnsure ) );

	//	now that we have the next LRCHECKSUM record, setup our markers

	m_pbLastChecksum = pbEnsure + ( ( csec - 1 ) * m_cbSec ) + lgposNextChecksum.ib;
	m_lgposLastChecksum = lgposNextChecksum;

	//	reset the pointer to the next log record (it may have moved due to ErrEnsureSector)

	m_pbNext = pbEnsure + plgposNextRec->ib;

	//	validate the next LRCHECKSUM record
	//	NOTE: this should never fail because we pre-scan and patch each log file before this is called!
	
	const BOOL fValidRecord = FValidLRCKRecord( plrck, &m_lgposLastChecksum );

	//	just in case...

	if ( !fValidRecord )
		{
		AssertSz( fFalse, "Unexpected invalid LRCK record!" );

		//	the LRCHECKSUM record is invalid -- we must fail because we cannot read the entire log record

		//	set the end of data marker to the log position of the record we are trying to read in
		//	that way, we shouldn't even try to read it next time -- we certainly shouldn't trust it at all

		m_lgposLastRec = *plgposNextRec;

		//	return the standard corruption error (ErrLGGetNextRecFF will parse this into the right error code)

		CallR( ErrERRCheck( JET_errLogFileCorrupt ) );
		}

	//	now that we have the new LRCHECKSUM record and it looks good, read the entire range in and validate it

	//	move lgposNextChecksum to the end of the forward range of the LRCHECKSUM record
	//		(lgposNextChecksumEnd should either be farther along in the same sector, or on the boundary
	//		 of a later sector)

	AddLgpos( &lgposNextChecksum, sizeof( LRCHECKSUM ) + plrck->le_cbForwards );
	Assert( ( lgposNextChecksum.isec == m_lgposLastChecksum.isec && 
			  lgposNextChecksum.ib   >  m_lgposLastChecksum.ib ) ||
			( lgposNextChecksum.isec >  m_lgposLastChecksum.isec && 
			  lgposNextChecksum.ib   == 0 ) );

	//	calculate the number of sectors we need for the log record and the new LRCHECKSUM range

	csec = lgposNextChecksum.isec - m_lgposLastChecksum.isec;

	if ( csec > 0 )
		{

		//	read from the first sector of the next log record to the end of the LRCHECKSUM range

		CallR( plread->ErrEnsureSector( plgposNextRec->isec, csec, &pbEnsure ) );

		//	now that we have the next LRCHECKSUM record, setup our markers

		m_pbLastChecksum = pbEnsure + ( ( m_lgposLastChecksum.isec - plgposNextRec->isec ) * m_cbSec ) + m_lgposLastChecksum.ib;

		//	reset the pointer to the next log record (it may have moved due to ErrEnsureSector)

		m_pbNext = pbEnsure + plgposNextRec->ib;
		}

	//	validate the LRCHECKSUM range

	const BOOL fValidRange = FValidLRCKRange( plrck, m_lgposLastChecksum.lGeneration );
	if ( !fValidRange )
		{

		//	the LRCHECKSUM range is invalid, but all is not lost!

		//	set the end of data marker to start at the sector with the LRCHECKSUM record

		m_lgposLastRec.ib = 0;
		m_lgposLastRec.isec = m_lgposLastChecksum.isec;
		m_lgposLastRec.lGeneration = m_plgfilehdr->lgfilehdr.le_lGeneration;

		//	if we have a short checksum, that means that the sector with the LRCHECKSUM record is salvagable
		//		(but the rest are not)

		if ( plrck->bUseShortChecksum == bShortChecksumOn )
			{

			//	advance the end of data pointer past the salvagable sector
			
			m_lgposLastRec.isec++;
			Assert( m_lgposLastRec.isec < ( m_csecLGFile - 1 ) );

			//	since the first sector of the range is valid, we trust the pointers in the LRCHECKSUM record
			//	the backward pointer could be 0 if we had patched this sector in a previous crash
			//	the forward/next pointers may or may not point ahead to data (in this example they do)
			//
			//	so, we need to realize that even though we trust the data in the backward range which should
			//		be the rest of X, there may be no backward range to trust making Y the next record
			//	also, we need to realize that Y could stretch into the corruption we just found; however,
			//		that case will be handled after we recurse back into ErrLGGetNextRecFF and realize that
			//		log record Y does not end before m_lgposLastRec and is therefore useless as well
			//
			//              0  /---------------\
			//	----|-------|--|------|--------|------
			//	  (X|DADADA(LRCK)(YYYY| doodoo | ???
			//	----|--------|--------|--------|------
			//				 \--------------------/

			//	see if we do in fact need to handle the special "no backward range" case
			
			if ( plrck->le_cbBackwards != m_lgposLastChecksum.ib )
				goto NoBackwardRange;
			}

		//	return the standard corruption error (ErrLGGetNextRecFF will parse this into the right error code)

		CallR( ErrERRCheck( JET_errLogFileCorrupt ) );
		}

	//	what about when the backward range of the LRCHECKSUM doesn't cover the log record we want to read in?
	//
	//	this indicates that in a previous crash, we sensed that the LRCHECKSUM record or range was invalid, and
	//		we patched it by chopping it off (including the entire sector it was in)
	//
	//	a new LRCHECKSUM record was created with a backward range of 0 to indicate that the data in the 
	//		area before the LRCHECKSUM record is not to be trusted; in fact, we fill it with a known pattern
	//
	//	thus, the log record that is hanging between the two LRCHECKSUM ranges is not usable
	//
	//	the next record we are able to replay is the LRCHECKSUM record we just read in
	//
	//	since we already recovered from the last crash (e.g. we made the special LRCHECKSUM record with no
	//		backward range), there SHOULD be a series of undo operations following the LRCHECKSUM record;
	//		(there is no concrete way to tell -- we could have crashed exactly after a commit to level 0)
	//		these will be replayed first, then any other operations will be replayed as well

	if ( plrck->le_cbBackwards != m_lgposLastChecksum.ib )
		{

		//	if this is the last LRCHECKSUM record, we set m_lgposLastRec to the end of the forward range

		if ( plrck->le_cbNext == 0 )
			{
			m_lgposLastRec = lgposNextChecksum;
			}

NoBackwardRange:

		//	the backwards pointer should be 0

		Assert( plrck->le_cbBackwards == 0 );

//
//	THE PATTERN IS NO LONGER PUT HERE SO THAT WE HAVE THE OLD DATA IF WE NEED IT (DEBUGGING PURPOSES)
//
//		//	look for the known pattern 
//
//		Assert( memcmp( PbSecAligned( m_pbLastChecksum ), rgbLogExtendPattern, m_lgposLastChecksum.ib ) == 0 );

		//	point to the LRCHECKSUM record as the next log record

		m_pbNext = m_pbLastChecksum;
		}

	//	we now have the next LRCHECKSUM range in memory and validated

	//	return success

	CallS( err );
	return err;
	}

//  ================================================================
LOCAL VOID InsertPageIntoRgpgno( PGNO rgpgno[], INT * const pipgno, const INT cpgnoMax, const PGNO pgno )
//  ================================================================
	{
	Assert( NULL != rgpgno );
	Assert( NULL != pipgno );
	Assert( 0 <= *pipgno );
	Assert( cpgnoMax >= 0 );

	// Removes consecutive duplicates and invalid page numbers
	if( pgno != rgpgno[(*pipgno)-1]
		&& *pipgno < cpgnoMax
		&& pgnoNull != pgno )
		{
		rgpgno[(*pipgno)++] = pgno;
		}
	}

//	Implicit output parameters
//		m_pbNext
//	via ErrLGIReadMS
//		m_pbLastMSFlush		// emulated with lastChecksum
//		m_lgposLastMSFlush	// emulated with lastChecksum
//		m_pbRead
//		m_pbNext
//		m_isecRead
//	via LGISearchLastSector
//		m_pbEntry		// not emulated
//		m_lgposLastRec	// emulated

ERR LOG::ErrLGGetNextRecFF( BYTE **ppbLR )
	{
	ERR			err;
	UINT		cbAvail, cbNeed, cIteration;
	LRCHECKSUM	*plrck;
	LGPOS		lgposPbNext, lgposPbNextNew, lgposChecksumEnd;
	BOOL		fDidRead;

	//	initialize variables

	err 		= JET_errSuccess;
	fDidRead	= fFalse;

	//	lock the flush information

	Assert( m_critLGFlush.FNotOwner() );
	m_critLGFlush.Enter();

	//	m_lgposLastRec should be set

	Assert( m_lgposLastRec.isec >= m_csecHeader && 
			( m_lgposLastRec.isec < ( m_csecLGFile - 1 ) || 
			  ( m_lgposLastRec.isec == ( m_csecLGFile - 1 ) && m_lgposLastRec.ib == 0 ) ) &&
			m_lgposLastRec.lGeneration == m_plgfilehdr->lgfilehdr.le_lGeneration );

	//	we should have a LogReader created for us

	Assert( m_plread != pNil );

	//	m_pbNext points to the log record we just replayed
	//	get that log position

	Assert( m_pbNext != pbNil );
	GetLgposOfPbNext( &lgposPbNextNew );

	//	save this log position for future reference

	lgposPbNext = lgposPbNextNew;

	//	make sure we don't exceed the end of the replay data

	//	since we already replayed the data at m_pbNext, we should be able to assert that m_pbNext is not
	//		past the end of usable data (if it is, we replayed unusable data -- e.g. GARBAGE)

	AssertSz( ( CmpLgpos( &lgposPbNextNew, &m_lgposLastRec ) < 0 ), 
			  "We somehow managed to replay garbage, and now, when we are moving past the garbage we just played, we are detecting it for the first time!?! Woops..." );

	//	just in case

	if ( CmpLgpos( &lgposPbNextNew, &m_lgposLastRec ) >= 0 )
		{

		//	this is a serious problem -- we replayed data that was not trusted
		//	the database may be really messed up at this point (I'm surprised the REDO code actually worked)
		//
		//	there is no way to get out of this; we'll have to trust UNDO to try and rectify things
		//		(unless the garbage we replayed happened to be a commit to level 0)
		//
		//	the only thing we can do is stop the REDO code by returning that there are no more log records
			
		Call( ErrERRCheck( errLGNoMoreRecords ) );
		}

	//	get the size of both the fixed and variable length portions of the current log record

	cbNeed = CbLGSizeOfRec( reinterpret_cast< const LR* >( m_pbNext ) );
	Assert( cbNeed > 0 );

	//	advance m_pbNext past the current log record and on to the next log record

	m_pbNext += cbNeed;

	//	m_pbNext should never suffer from wrap-around (it will always be in the first mapping of the buffers)
	
	Assert( m_pbNext > m_pbLGBufMin && m_pbNext < m_pbLGBufMax );
	
	//	get the log position of the next log record (we will be replaying this next if its ok to replay it)

	GetLgposOfPbNext( &lgposPbNextNew );

	//	the new record should be at a greater log position than the old record

	Assert( CmpLgpos( &lgposPbNextNew, &lgposPbNext ) > 0 );

	//	in fact, the difference in the log positions should be exactly equal to the the size of the old record

	Assert( CbOffsetLgpos( lgposPbNextNew, lgposPbNext ) == QWORD( cbNeed ) );

	//	see if this was the last log record

	if ( CmpLgpos( &lgposPbNextNew, &m_lgposLastRec ) >= 0 )
		{
		Call( ErrERRCheck( errLGNoMoreRecords ) );
		}

	//	set the pointer to the current LRCHECKSUM record

	Assert( m_pbLastChecksum != pbNil );
	plrck = (LRCHECKSUM *)m_pbLastChecksum;

	//	calculate the end of the current LRCHECKSUM record

	lgposChecksumEnd = m_lgposLastChecksum;
	AddLgpos( &lgposChecksumEnd, sizeof( LRCHECKSUM ) + plrck->le_cbForwards );

	//	calculate the available space in the current LRCHECKSUM range so we can see how much data we have 
	//		in memory vs. how much data we need to bring in (from the next LRCHECKSUM record) 

	Assert( CmpLgpos( &lgposChecksumEnd, &lgposPbNextNew ) >= 0 );
	cbAvail = (UINT)CbOffsetLgpos( lgposChecksumEnd, lgposPbNextNew );

	//	move lgposPbNext up to lgposPbNextNew

	lgposPbNext = lgposPbNextNew;

	//	we now have m_pbNext pointing to the next log record (some/all of it might be missing)
	//
	//	we need to bring in the entire log record (fixed and variable length portions) with regard to possible
	//		corruption, and return to the replay code so the record can be redone
	//
	//	do this in 3 iterations:
	//		first, read in the LRTYP
	//		second, using the LRTYP, read in the fixed portion
	//		third, using the fixed portion, read in the variable portion

	for ( cIteration = 0; cIteration < 3; cIteration++ )
		{

		//	decide how much to read for each iteration
		
		if ( cIteration == 0 )
			{
		
			//	stage 1 -- bring in the LRTYP (should be 1 byte)

			Assert( sizeof( LRTYP ) == 1 );
			cbNeed = sizeof( LRTYP );
			}
		else if ( cIteration == 1 )
			{

			//	stage 2 -- bring in the fixed portion using the LRTYP

			cbNeed = CbLGFixedSizeOfRec( reinterpret_cast< const LR * >( m_pbNext ) );
			}
		else
			{

			//	stage 3 -- bring in the dynamic portion using the fixed portion
			
			Assert( cIteration == 2 );
			cbNeed = CbLGSizeOfRec( reinterpret_cast< const LR * >( m_pbNext ) );
			}

		//	advance lgposPbNextNew to include the data we need

		lgposPbNextNew = lgposPbNext;
		AddLgpos( &lgposPbNextNew, cbNeed );

		//	make sure we don't exceed the end of the replay data

		if ( CmpLgpos( &lgposPbNextNew, &m_lgposLastRec ) > 0 )
			{
			Call( ErrERRCheck( errLGNoMoreRecords ) );
			}

		//	do we have the data we need?

		if ( cbAvail < cbNeed )
			{

			//	no; we need the next LRCHECKSUM range

			//	we should only be doing 1 read per iteration of this function

			Assert( !fDidRead );

			//	do the read

			err = ErrLGIGetNextChecksumFF( &lgposPbNext, ppbLR );
			fDidRead = fTrue;

			//	m_pbNext may have moved because the log record we wanted was partially covered by the next
			//		LRCHECKSUM's backward range and that LRCHECKSUM had no backward range
			//	we need to refresh our currency on m_pbNext to determine exactly what happened

			//	m_pbNext should never suffer from wrap-around (it will always be in the first mapping of the buffers)
	
			Assert( m_pbNext > m_pbLGBufMin && m_pbNext < m_pbLGBufMax );

			//	get the new log position m_pbNext

			GetLgposOfPbNext( &lgposPbNextNew );

			//	m_pbNext should not have moved backwards

			Assert( CmpLgpos( &lgposPbNextNew, &lgposPbNext ) >= 0 );

			//	did m_pbNext move?

			if ( CmpLgpos( &lgposPbNextNew, &lgposPbNext ) > 0 )
				{

				//	yes, meaning that the LRCHECKSUM range we read in had no backward range, so we skipped
				//		to the next good record

				//	this should be a successful case

				CallS( err );

				//	return the log record

				goto HandleError;
				}

			//	did we get corruption?

			if ( err == JET_errLogFileCorrupt )
				{

				//	there was corruption in the next LRCHECKSUM range
				//	this should NEVER happen because ErrLGCheckReadLastLogRecordFF should have patched this up!

				//	m_lgposLastRec should point to the end of the last LRCHECKSUM's range or the end of the first
				//		sector in the new LRCHECKSUM we just read

				Assert( CmpLgpos( &m_lgposLastRec, &lgposChecksumEnd ) == 0 ||
						( m_lgposLastRec.ib == lgposChecksumEnd.ib &&
						  m_lgposLastRec.isec == lgposChecksumEnd.isec + 1 &&
						  m_lgposLastRec.lGeneration == lgposChecksumEnd.lGeneration ) );

				//	did we get any data anyway? we may have if we had a valid short checksum; m_lgposLastRec will be
				//		one full sector past lgposChecksumEnd if we did get more data
			
				AddLgpos( &lgposChecksumEnd, m_cbSec );
				if ( CmpLgpos( &m_lgposLastRec, &lgposChecksumEnd ) == 0 )
					{

					//	we got more data
				
					//	it should be enough for the whole log record because we should have atleast gotten up to
					//		and including the LRCHECKSUM (meaning the entire backward range) and the missing 
					//		portion of the log record must be in the backward range

					err = JET_errSuccess;
					goto GotMoreData;
					}

				//	we did not get any more data; handle the corruption error

				Call( err );
				}
			else if ( err != JET_errSuccess )
				{

				//	another error occurred -- it could be errLGNoMoreRecords (we do not expect warnings)

				Assert( err < 0 );
				Call( err );
				}

GotMoreData:
			//	we have enough data to continue

			//	since we read a new LRCHECKSUM range, we need to refresh some of our internal variables
		
			//	set the pointer to the next LRCHECKSUM record

			Assert( m_pbLastChecksum != pbNil );
			plrck = (LRCHECKSUM *)m_pbLastChecksum;

			//	if lgposChecksumEnd was not setup for the new LRCHECKSUM record, set it up now
			//		(it may have been set to the end of the first sector in the case of corruption)

			if ( CmpLgpos( &lgposChecksumEnd, &m_lgposLastChecksum ) <= 0 )
				{
				lgposChecksumEnd = m_lgposLastChecksum;
				AddLgpos( &lgposChecksumEnd, sizeof( LRCHECKSUM ) + plrck->le_cbForwards );
				}

			//	recalculate the amount of available space as the number of bytes from the current
			//		log record to the start of the newly read LRCHECKSUM record
			
			cbAvail = (UINT)CbOffsetLgpos( m_lgposLastChecksum, lgposPbNextNew );

			//	if cbAvail == 0, then the next log record must be the new LRCHECKSUM record because
			//		we calculated cbAvail as the number of bytes BEFORE the LRCHECKSUM record
			//		(e.g. there is nothing before the LRCHECLSUM record to get)

			if ( cbAvail == 0 )
				{

				//	we must be looking at an LRCHECKSUM record

				Assert( *m_pbNext == lrtypChecksum );

				//	we should be on the first iteration because we shouldn't have had a partial
				//		LRCHECKSUM record hanging over the edge of a sector; it would have been
				//		sector aligned using lrtypNOP records

				Assert( cIteration == 0 );

				//	m_pbNext should be sector-aligned 

				Assert( lgposPbNext.ib == 0 );
				Assert( m_pbNext == PbSecAligned( m_pbNext ) );

				//	set cbAvail to be the size of the LRCHECKSUM record

				cbAvail = sizeof( LRCHECKSUM );
				}
				
			//	we should now have the data we need

			Assert( cbAvail >= cbNeed );
			}

		//	iteration complete -- loop back for next pass
		}

	//	we now have the log record in memory and validated

	Assert( cIteration == 3 );

	//	we should also have enough data to cover the entire log record

	Assert( cbAvail >= CbLGSizeOfRec( reinterpret_cast< const LR * >( m_pbNext ) ) );

	//	we should have no errors or warnings at this point

	CallS( err );

HandleError:

	//	setup the pointers in all cases (error or success)

	*ppbLR = m_pbNext;
	m_pbRead = m_plread->PbGetEndOfData();
	m_isecRead = m_plread->IsecGetNextReadSector();

	//	did we get corruption? we NEVER should because ErrLGCheckReadLastLogRecordFF patches it first!

	if ( err == JET_errLogFileCorrupt )
		{

		//	what recovery mode are we in?

		if ( m_fHardRestore )
			{

			//	we are in hard-recovery mode

			if ( m_plgfilehdr->lgfilehdr.le_lGeneration <= m_lGenHighRestore )
				{

				//	this generation is part of a backup set

				Assert( m_plgfilehdr->lgfilehdr.le_lGeneration >= m_lGenLowRestore );
				err = ErrERRCheck( JET_errLogCorruptDuringHardRestore );
				}
			else
				{

				//	the current log generation is not part of the backup-set

				err = ErrERRCheck( JET_errLogCorruptDuringHardRecovery );
				}
			}
		else
			{

			//	we are in soft-recovery mode or in the dump code
			//	keep the original error JET_errLogFileCorrupt

			}
		}

	m_critLGFlush.Leave();
	
	return err;
	}

//	If it's time to preread more database pages, they will be
//	preread, otherwise do nothing.

ERR
LOG::ErrLGIPrereadCheck()
	{
	if ( m_fPreread )
		{
		if ( m_cPageRefsConsumed >= m_cPagesPrereadThreshold )
			{
			m_cPageRefsConsumed = 0;
			return ErrLGIPrereadPages( m_cPagesPrereadAmount );
			}
		}
	return JET_errSuccess;
	}

//	Look forward in log records and ask buffer manager to preread pages


ERR
LOG::ErrLGIPrereadExecute(
	const UINT cPagesToPreread
	)
	{
	const LR *	plr = pNil;
	ERR			err = JET_errSuccess;
	const INT	ipgnoMax = cPagesToPreread + 1;
	UINT		cPagesReferenced = 0;

	// page array structure:
	// [pgnoNull] [cPagesToPreread number of pages] [pgnoNull]
	
	PGNO * 	rgrgpgno[cdbidMax];
	INT 	rgipgno[cdbidMax];

	rgrgpgno[ 0 ] = pNil;
	
	rgrgpgno[0] = (PGNO*) PvOSMemoryHeapAlloc( cdbidMax * (ipgnoMax + 1) * sizeof(PGNO) );
	if ( !rgrgpgno[0] )
		{
		// Upper layer can hide this however they want
		return JET_errOutOfMemory;
		}

	INT	idbid;
	for( idbid = 0; idbid < cdbidMax; ++idbid )
		{
		rgrgpgno[idbid] = rgrgpgno[0] + idbid * (ipgnoMax + 1);
		rgrgpgno[idbid][0] = pgnoNull;
		rgipgno[idbid] = 1;
		}

	// Notice that we remove consecutive duplicates (and pgnoNull) from our preread
	// list, but that we count duplicates and null's to keep our bookkeeping simple.

	while ( ( JET_errSuccess == ( err = ErrLGGetNextRecFF( (BYTE **) &plr ) ) ) &&
		cPagesReferenced < cPagesToPreread )
		{
		switch( plr->lrtyp )
			{
			case lrtypInsert:
			case lrtypFlagInsert:
			case lrtypFlagInsertAndReplaceData:
			case lrtypReplace:
			case lrtypReplaceD:
			case lrtypFlagDelete:
			case lrtypDelete:
			case lrtypDelta:
			case lrtypSLVSpace:
			case lrtypSetExternalHeader:
				{
				const LRPAGE_ * const plrpage = (LRPAGE_ *)plr;
				const PGNO pgno = plrpage->le_pgno;
				const INT idbid = plrpage->dbid - 1;
				if( idbid >= cdbidMax )
					break;

				const INT cPages = rgipgno[idbid];
					
				InsertPageIntoRgpgno( rgrgpgno[idbid], rgipgno+idbid, ipgnoMax, pgno );

				cPagesReferenced += rgipgno[idbid] - cPages;
				}
				break;

			case lrtypSplit:
				{
				const LRSPLIT * const plrsplit = (LRSPLIT *)plr;
				const INT idbid = plrsplit->dbid - 1;
				if( idbid >= cdbidMax )
					break;

				const INT cPages = rgipgno[idbid];

				InsertPageIntoRgpgno( rgrgpgno[idbid], rgipgno+idbid, ipgnoMax, plrsplit->le_pgno );
				InsertPageIntoRgpgno( rgrgpgno[idbid], rgipgno+idbid, ipgnoMax, plrsplit->le_pgnoNew );
				InsertPageIntoRgpgno( rgrgpgno[idbid], rgipgno+idbid, ipgnoMax, plrsplit->le_pgnoParent );
				InsertPageIntoRgpgno( rgrgpgno[idbid], rgipgno+idbid, ipgnoMax, plrsplit->le_pgnoRight );

				cPagesReferenced += rgipgno[idbid] - cPages;
				}
				break;
				
			case lrtypMerge:
				{
				const LRMERGE * const plrmerge = (LRMERGE *)plr;	
				const INT idbid = plrmerge->dbid - 1;
				if( idbid >= cdbidMax )
					break;

				const INT cPages = rgipgno[idbid];

				InsertPageIntoRgpgno( rgrgpgno[idbid], rgipgno+idbid, ipgnoMax, plrmerge->le_pgno );
				InsertPageIntoRgpgno( rgrgpgno[idbid], rgipgno+idbid, ipgnoMax, plrmerge->le_pgnoRight );
				InsertPageIntoRgpgno( rgrgpgno[idbid], rgipgno+idbid, ipgnoMax, plrmerge->le_pgnoLeft );
				InsertPageIntoRgpgno( rgrgpgno[idbid], rgipgno+idbid, ipgnoMax, plrmerge->le_pgnoParent );

				cPagesReferenced += rgipgno[idbid] - cPages;
				}
				break;

			default:
				break;
			}

		}

	if ( JET_errSuccess == err || errLGNoMoreRecords == err )
		{		
		for( idbid = 0; idbid < cdbidMax; ++idbid )
			{
			IFMP ifmp = m_pinst->m_mpdbidifmp[idbid + 1];
			if ( ifmp < ifmpMax && FIODatabaseOpen( ifmp ) )
				{
				Assert( rgipgno[idbid] <= ipgnoMax );
				rgrgpgno[idbid][(rgipgno[idbid])++] = pgnoNull;
				BFPrereadPageList( ifmp, rgrgpgno[idbid] + 1 );
				}
			}
		}
		
	if ( rgrgpgno[ 0 ] )
		{
		::OSMemoryHeapFree( rgrgpgno[ 0 ] );
		}

	return err;
	}

//	Setup state to look forward in log for page references

ERR
LOG::ErrLGIPrereadPages(
	// Number of pages to preread ahead
	UINT	cPagesToPreread
	)
	{
	ERR		err = JET_errSuccess;
	LRSTATE	lrstateNormal;
	BYTE*	pbEnsure = pbNil;

	// ================ Save normal log reading state ===================== //
	// These two will be used to retore m_pbNext and m_pbLastChecksum later
	LGPOS	lgposPbNextSaved;
	GetLgposOfPbNext( &lgposPbNextSaved );
	LGPOS	lgposLastChecksumSaved = m_lgposLastChecksum;
	// m_pbRead and m_isecRead do not need to be saved. They'll simply
	// be copied from m_plread at the end.

	err = m_plread->ErrSaveState( &lrstateNormal );
	if ( JET_errSuccess != err )
		{
		// Assume state is still fine.
		// Don't try to preread again
		m_fPreread = fFalse;
		return JET_errSuccess;
		}

	// ================ Restore to prereading state ======================= //
	// Return the LogReader to the state of the last preread. This will
	// ensure that the last CK that we were prereading in is available,
	// and that ErrLGIGetNextChecksumFF will be able to deal with it
	// sensibly.
	// state includes isec and csec from last call to ErrEnsureSector
	err = m_plread->ErrRestoreState( &m_lrstatePreread, &pbEnsure );
	if ( JET_errSuccess != err )
		{
		// non-fatal
		err = JET_errSuccess;
		m_fPreread = fFalse;
		goto LRestoreNormal;
		}	
	// Following necessary so GetLgpos{DuringReading,OfPbNext}() works (!)
	m_pbRead = m_plread->PbGetEndOfData();
	m_isecRead = m_plread->IsecGetNextReadSector();
	
	Assert( pbNil != pbEnsure );

	Assert( m_lgposPbNextPreread.isec >= m_lrstatePreread.m_isec );
	m_pbNext = pbEnsure + m_cbSec * ( m_lgposPbNextPreread.isec - m_lrstatePreread.m_isec ) +
		m_lgposPbNextPreread.ib;
	Assert( m_pbNext >= m_pbLGBufMin && m_pbNext < m_pbLGBufMax );
	
	Assert( m_lgposLastChecksumPreread.isec >= m_lrstatePreread.m_isec );
	m_pbLastChecksum = pbEnsure +
		m_cbSec * ( m_lgposLastChecksumPreread.isec - m_lrstatePreread.m_isec ) +
		m_lgposLastChecksumPreread.ib;
	Assert( m_pbLastChecksum >= m_pbLGBufMin && m_pbLastChecksum < m_pbLGBufMax );

	m_lgposLastChecksum = m_lgposLastChecksumPreread;

	// =========== Do actual prereading ================================== //

		{
		err = ErrLGIPrereadExecute( cPagesToPreread );
		if ( err )
			{
			err = JET_errSuccess;
			// If any error occurs (including no more log records)
			// don't ever again try to preread this file again.
			// This is re-enabled in FirstRedoLogRec which will
			// open up the next log file.
			m_fPreread = fFalse;
			}
		}

	// =========== Save prereading state ================================= //

	err = m_plread->ErrSaveState( &m_lrstatePreread );
	if ( JET_errSuccess != err )
		{
		// non-fatal
		err = JET_errSuccess;
		m_fPreread = fFalse;
		goto LRestoreNormal;
		}	
	GetLgposDuringReading( m_pbNext, &m_lgposPbNextPreread );
	GetLgposDuringReading( m_pbLastChecksum, &m_lgposLastChecksumPreread );
#ifdef DEBUG
		{
		LGPOS lgposT;
		GetLgposOfPbNext( &lgposT );
		Assert( CmpLgpos( &lgposT, &m_lgposPbNextPreread ) == 0 );
		}
#endif

	// =========== Restore to normal log reading state =================== //
LRestoreNormal:
	// Need to restore LogReader to state on entry, so
	// that normal GetNextRec code will find the records it
	// expects. This is fatal if we can't restore the state to what
	// normal reading expects.
	err = m_plread->ErrRestoreState( &lrstateNormal, &pbEnsure );
	if ( JET_errSuccess != err )
		{
		m_fPreread = fFalse;
		return err;
		}

	// set m_pbNext and m_pbLastChecksum based on saved
	// m_pb{Next,LastChecksum} and pbEnsure from ErrEnsureSector().
	Assert( lgposPbNextSaved.isec >= lrstateNormal.m_isec );
	m_pbNext = pbEnsure + m_cbSec * ( lgposPbNextSaved.isec - lrstateNormal.m_isec ) +
		lgposPbNextSaved.ib;
	Assert( m_pbNext >= m_pbLGBufMin && m_pbNext < m_pbLGBufMax );
	
	Assert( lgposLastChecksumSaved.isec >= lrstateNormal.m_isec );
	m_pbLastChecksum = pbEnsure +
		m_cbSec * ( lgposLastChecksumSaved.isec - lrstateNormal.m_isec ) +
		lgposLastChecksumSaved.ib;
	Assert( m_pbLastChecksum >= m_pbLGBufMin && m_pbLastChecksum < m_pbLGBufMax );

	m_lgposLastChecksum = lgposLastChecksumSaved;
	
	m_pbRead = m_plread->PbGetEndOfData();
	m_isecRead = m_plread->IsecGetNextReadSector();

	return err;
	}
	

//+------------------------------------------------------------------------
//
//	CbLGSizeOfRec
//	=======================================================================
//
//	ERR CbLGSizeOfRec( plgrec )
//
//	Returns the length of a log record.
//
//	PARAMETER	plgrec	pointer to log record
//
//	RETURNS		size of log record in bytes
//
//-------------------------------------------------------------------------
typedef struct {
	int cb;
	BOOL fDebugOnly;
	} LRD;		/* log record descriptor */


const LRD mplrtyplrd[ ] = {
	{	/* 	0 	NOP      */			sizeof( LRTYP ),				0	},
	{	/* 	1 	Init	 */			sizeof( LRINIT ),				0	},
	{	/* 	2 	Term     */			sizeof( LRTERMREC ),			0	},
	{	/* 	3 	MS       */			sizeof( LRMS ),					0	},
	{	/* 	4 	Fill     */			sizeof( LRTYP ),				0	},

	{	/* 	5 	Begin    */			sizeof( LRBEGIN ),				0	},
	{	/*	6 	Commit   */			sizeof( LRCOMMIT ),				0	},
	{	/*	7 	Rollback */			sizeof( LRROLLBACK ),			0	},
	{	/* 	8 	Begin0   */			sizeof( LRBEGIN0 ),				0	},
	{	/*	9  	Commit0  */			sizeof( LRCOMMIT0 ),			0	},
	{	/*	10	Refresh	 */			sizeof( LRREFRESH ),			0	},
	{	/* 	11 	McrBegin */			sizeof( LRMACROBEGIN ),			0	},
	{	/* 	12 	McrCmmt  */			sizeof( LRMACROEND ),			0	},
	{	/* 	13 	McrAbort */			sizeof( LRMACROEND ),			0	},
		
	{	/*	14 	CreateDB */			0,								0	},
	{	/* 	15 	AttachDB */			0,								0	},
	{	/*	16	DetachDB */			0,								0	},

	{	/*  17  RcvrUndo */			sizeof( LRRECOVERYUNDO ),		0	},
	{	/*  18  RcvrQuit */			sizeof( LRTERMREC ),			0	},
	{	/*  19  FullBkUp */			0,								0	},
	{	/*  20  IncBkUp  */			0,								0	},

	{	/*  21  JetOp    */			sizeof( LRJETOP ),				1	},
	{	/*	22 	Trace    */			0,								1	},
		
	{	/* 	23 	ShutDown */			sizeof( LRSHUTDOWNMARK ),		0	},

	{	/*	24	Create ME FDP  */	sizeof( LRCREATEMEFDP ),		0	},
	{	/*	25	Create SE FDP  */	sizeof( LRCREATESEFDP ),		0	},
	{	/*	26	Convert FDP    */ 	sizeof( LRCONVERTFDP ),			0	},

	{	/*	27	Split    */			0,								0	},
	{	/*	28	Merge	 */			0,								0	},

	{	/* 	29	Insert	 */			0,								0	},
	{	/*	30	FlagInsert */		0,								0	},
	{	/*	31	FlagInsertAndReplaceData */		
									0,								0	},
	
	{	/* 	32	FDelete  */			sizeof( LRFLAGDELETE ),			0	},
	{	/* 	33	Replace  */			0,								0	},
	{	/* 	34	ReplaceD */			0,								0	},

	{	/*	35	Delete  */			sizeof( LRDELETE ),				0	},
	{	/*	36	UndoInfo */			0,								0	},
	
	{	/*	37	Delta	 */			0,								0	},

	{	/*	38	SetExtHeader */		0,								0	},
	{	/*	39	Undo     */			0,								0	},

	{	/*	40	SLVPageAppend */	0,								0	},
	{	/*	41	SLVSpace */			0,								0	},
	{	/*	42	Checksum */			sizeof( LRCHECKSUM ),			0	},
	{	/*	43	SLVPageMove */		sizeof( LRSLVPAGEMOVE ),		0	},
	{	/*	44	ForceDetachDB */	0,								0	},
	{	/*	45	ExtRestore */		0,								0	},
	{	/*  46	Backup */			0,								0	},
	{   /*	47	UpgradeDB */		0,								0 	},
	{	/*	48	EmptyTree */		0,								0	},
	{	/*	49	Init2 */			sizeof( LRINIT2 ),				0	},
	{	/*	50	Term2 */			sizeof( LRTERMREC2 ),			0	},
	{	/*	51	RecoveryUndo */		sizeof( LRRECOVERYUNDO2 ),		0	},
	{	/*	52	RecoveryQuit */		sizeof( LRTERMREC2 ),			0	},
	{	/*	53	BeginDT */			sizeof( LRBEGINDT ),			0	},
	{	/*	54	PrepCommit */		0,								0	},
	{	/*	55	PrepRollback */		0,								0	},
	{	/*	56	DbList */			0,								0	},

	};


#ifdef DEBUG
BOOL FLGDebugLogRec( LR *plr )
	{
	return mplrtyplrd[plr->lrtyp].fDebugOnly;
	}
#endif


//	For CbLGSizeOfRec() to work properly with FASTFLUSH, CbLGSizeOfRec()
//	must only use the fixed fields of log records to calculate their size.

INT CbLGSizeOfRec( const LR *plr )
	{
	INT		cb;

	Assert( plr->lrtyp < lrtypMax );

	if ( ( cb = mplrtyplrd[plr->lrtyp].cb ) != 0 )
		return cb;

	switch ( plr->lrtyp )
		{
	case lrtypFullBackup:
	case lrtypIncBackup:
		{
		LRLOGRESTORE *plrlogrestore = (LRLOGRESTORE *) plr;
		return sizeof(LRLOGRESTORE) + plrlogrestore->le_cbPath;
		}
	case lrtypBackup:
		{
		LRLOGBACKUP *plrlogbackup = (LRLOGBACKUP *) plr;
		return sizeof(LRLOGBACKUP) + plrlogbackup->le_cbPath;
		}

	case lrtypCreateDB:
		{
		LRCREATEDB *plrcreatedb = (LRCREATEDB *)plr;
		Assert( plrcreatedb->CbPath() != 0 );
		return sizeof(LRCREATEDB) + plrcreatedb->CbPath();
		}
	case lrtypAttachDB:
		{
		LRATTACHDB *plrattachdb = (LRATTACHDB *)plr;
		Assert( plrattachdb->CbPath() != 0 );
		return sizeof(LRATTACHDB) + plrattachdb->CbPath();
		}
	case lrtypDetachDB:
		{
		LRDETACHDB *plrdetachdb = (LRDETACHDB *)plr;
		Assert( plrdetachdb->CbPath() != 0 );
		return sizeof( LRDETACHDB ) + plrdetachdb->CbPath();
		}
	case lrtypDbList:
		{
		LRDBLIST* const	plrdblist	= (LRDBLIST *)plr;
		return sizeof(LRDBLIST) + plrdblist->CbAttachInfo();
		}

	case lrtypSplit:
		{
		LRSPLIT *plrsplit = (LRSPLIT *) plr;
		return sizeof( LRSPLIT ) + 
				plrsplit->le_cbKeyParent +
				plrsplit->le_cbPrefixSplitOld + 
				plrsplit->le_cbPrefixSplitNew;
		}
	case lrtypMerge:
		{
		LRMERGE *plrmerge = (LRMERGE *) plr;
		return sizeof( LRMERGE ) + plrmerge->le_cbKeyParentSep;
		}

	case lrtypEmptyTree:
		{
		LREMPTYTREE *plremptytree = (LREMPTYTREE *)plr;
		return sizeof(LREMPTYTREE) + plremptytree->CbEmptyPageList();
		}

	case lrtypDelta:
		{
		LRDELTA	*plrdelta = (LRDELTA *) plr;
		return sizeof( LRDELTA ) + 
			   plrdelta->CbBookmarkKey() + plrdelta->CbBookmarkData();
		}
		
	case lrtypInsert:
		{
		LRINSERT *plrinsert = (LRINSERT *) plr;
		return	sizeof(LRINSERT) +
				plrinsert->CbSuffix() + plrinsert->CbPrefix() + plrinsert->CbData();
		}
		
	case lrtypFlagInsert:
		{
		LRFLAGINSERT	*plrflaginsert = (LRFLAGINSERT *) plr;
		return 	sizeof(LRFLAGINSERT) +
				plrflaginsert->CbKey() + plrflaginsert->CbData();
		}
		
	case lrtypFlagInsertAndReplaceData:
		{
		LRFLAGINSERTANDREPLACEDATA *plrfiard = (LRFLAGINSERTANDREPLACEDATA *) plr;
		return sizeof(LRFLAGINSERTANDREPLACEDATA) + plrfiard->CbKey() + plrfiard->CbData();
		}
		
	case lrtypReplace:
	case lrtypReplaceD:
		{
		LRREPLACE *plrreplace = (LRREPLACE *) plr;
		return sizeof(LRREPLACE) + plrreplace->Cb();
		}
		
	case lrtypUndoInfo:
		{
		LRUNDOINFO *plrdbi = (LRUNDOINFO *) plr;
		return sizeof( LRUNDOINFO ) + plrdbi->le_cbData +
			   plrdbi->CbBookmarkKey() +
			   plrdbi->CbBookmarkData();
		}

	case lrtypUndo:
		{
		LRUNDO	*plrundo = (LRUNDO *) plr;

		return sizeof( LRUNDO ) +
			   plrundo->CbBookmarkKey() +
			   plrundo->CbBookmarkData();
		}
		
	case lrtypTrace:
		{
		LRTRACE *plrtrace = (LRTRACE *) plr;
		return sizeof(LRTRACE) + plrtrace->le_cb;
		}
		
	case lrtypSetExternalHeader:
		{
		LRSETEXTERNALHEADER *plrsetextheader = (LRSETEXTERNALHEADER *) plr;
		return sizeof(LRSETEXTERNALHEADER) + plrsetextheader->CbData();
		}
		
	case lrtypSLVPageAppend:
		{
		LRSLVPAGEAPPEND *plrSLVPageAppend = (LRSLVPAGEAPPEND *) plr;
		return sizeof(LRSLVPAGEAPPEND) + ( plrSLVPageAppend->FDataLogged() ? (DWORD) plrSLVPageAppend->le_cbData : 0 );
		}

	case lrtypSLVSpace:
		{
		const LRSLVSPACE * const plrslvspace = (LRSLVSPACE *) plr;
		return sizeof( LRSLVSPACE ) + 
			   plrslvspace->le_cbBookmarkKey + plrslvspace->le_cbBookmarkData;
		}

	case lrtypExtRestore:
		{
		LREXTRESTORE *plrextrestore = (LREXTRESTORE *) plr;
		return	sizeof(LREXTRESTORE) + 	plrextrestore->CbInfo();
		}

	case lrtypForceDetachDB:
		{
		LRFORCEDETACHDB *plrfdetachdb = (LRFORCEDETACHDB *)plr;
		Assert( plrfdetachdb->CbPath() != 0 );
		return sizeof( LRFORCEDETACHDB ) + plrfdetachdb->CbPath();
		}

	case lrtypPrepCommit:
		{
		const LRPREPCOMMIT	* const plrprepcommit	= (LRPREPCOMMIT *)plr;
		return sizeof(LRPREPCOMMIT) + plrprepcommit->le_cbData;
		}

	default:
		Assert( fFalse );
		return 0;
		}
	}

// mplrtypn
//
// Maps an lrtyp to the size of the fixed structure.
// 

// Notice that we do not specify a size for this array. This is so we can
// catch developers that add a new lrtyp, but forget to modify this array
// by Assert( ( sizeof( mplrtypn ) / sizeof( mplrtypn[ 0 ] ) ) == lrtypMax )

const INT mplrtypn[ ] =
	{
	sizeof( LRNOP ),
	sizeof( LRINIT ),
	sizeof( LRTERMREC ),
	sizeof( LRMS ),
	sizeof( LRTYP ),	// lrtypEnd
	sizeof( LRBEGIN ),
	sizeof( LRCOMMIT ),
	sizeof( LRROLLBACK ),
	sizeof( LRBEGIN0 ),
	sizeof( LRCOMMIT0 ),
	sizeof( LRREFRESH ),
	sizeof( LRMACROBEGIN ),
	sizeof( LRMACROEND ),
	sizeof( LRMACROEND ),	// lrtypMacroAbort
	sizeof( LRCREATEDB ),
	sizeof( LRATTACHDB ),
	sizeof( LRDETACHDB ),
	sizeof( LRRECOVERYUNDO ),
	sizeof( LRTERMREC ),	// lrtypRecoveryQuit
	sizeof( LRLOGRESTORE ),	// lrtypFullBackup
	sizeof( LRLOGRESTORE ),	// lrtypIncBackup
	sizeof( LRJETOP ),
	sizeof( LRTRACE ),
	sizeof( LRSHUTDOWNMARK ),
	sizeof( LRCREATEMEFDP ),
	sizeof( LRCREATESEFDP ),
	sizeof( LRCONVERTFDP ),
	sizeof( LRSPLIT ),
	sizeof( LRMERGE ),
	sizeof( LRINSERT ),
	sizeof( LRFLAGINSERT ),
	sizeof( LRFLAGINSERTANDREPLACEDATA ),
	sizeof( LRFLAGDELETE ),
	sizeof( LRREPLACE ),
	sizeof( LRREPLACE ),	// lrtypReplaceD
	sizeof( LRDELETE ),
	sizeof( LRUNDOINFO ),
	sizeof( LRDELTA ),
	sizeof( LRSETEXTERNALHEADER ),
	sizeof( LRUNDO ),
	sizeof( LRSLVPAGEAPPEND ),
	sizeof( LRSLVSPACE ),
	sizeof( LRCHECKSUM ),
	sizeof( LRSLVPAGEMOVE ),
	sizeof( LRFORCEDETACHDB ),
	sizeof( LREXTRESTORE ),
	sizeof( LRLOGBACKUP ),	// lrtypBackup
	0,
	sizeof( LREMPTYTREE ),
	sizeof( LRINIT2 ),
	sizeof( LRTERMREC2 ),
	sizeof( LRRECOVERYUNDO2 ),
	sizeof( LRTERMREC2 ),
	sizeof( LRBEGINDT ),
	sizeof( LRPREPCOMMIT ),
	sizeof( LRPREPROLLBACK ),
	sizeof( LRDBLIST ),
	};

INT CbLGFixedSizeOfRec( const LR * const plr )
	{
	// Should only be passed valid lrtyp's.
	// If this fires, be sure to check the mlrtypn array above and lrtypMax
	Assert( plr->lrtyp < lrtypMax );

	return mplrtypn[ plr->lrtyp ];
	}

#ifdef DEBUG

VOID AssertLRSizesConsistent()
	{
	// If this fires, someone added a new lrtyp (hence, increased lrtypMax),
	// but they didn't modify mplrtypn[] above, or they didn't set lrtypMax properly.
	Assert( ( sizeof( mplrtypn ) / sizeof( mplrtypn[ 0 ] ) ) == lrtypMax );
	// If this fires, someone added a new lrtyp (hence, increased lrtypMax),
	// but they didn't modify mplrtyplrd[] far above, or they didn't set lrtypMax properly.
	Assert( ( sizeof( mplrtyplrd ) / sizeof( mplrtyplrd[ 0 ] ) ) == lrtypMax );

	// Verify that fixed sizes in mplrtyplrd[] are the same as in mplrtypn[].
	for ( LRTYP iLrtyp = 0; iLrtyp < lrtypMax; iLrtyp++ )
		{
		if ( 0 != mplrtyplrd[ iLrtyp ].cb )
			{
			Assert( mplrtyplrd[ iLrtyp ].cb == mplrtypn[ iLrtyp ] );
			}
		}

	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_cat.cxx ===
const CHAR	szMSO[]					= "MSysObjects";
const CHAR	szMSOShadow[]			= "MSysObjectsShadow";
const CHAR	szMSOIdIndex[]			= "Id";
const CHAR	szMSONameIndex[]		= "Name";
const CHAR	szMSORootObjectsIndex[]	= "RootObjects";

const CHAR	szLVRoot[]				= "LV";
const ULONG cbLVRoot				= sizeof(szLVRoot) - 1;

const CHAR	szTableCallback[]		= "CB";
const ULONG cbTableCallback			= sizeof(szTableCallback) - 1;


struct CDESC							// Column Description
	{
	CHAR	  			*szColName;		// column name
	COLUMNID			columnid;		// hard-coded fid
	JET_COLTYP			coltyp; 		// column type
	JET_GRBIT			grbit;			// flag bits
	};

struct IDESC							// Index Description
	{
	CHAR				*szIdxName;		// index name
	CHAR				*szIdxKeys;		// key string
	JET_GRBIT			grbit;			// flag bits
	};



LOCAL const CDESC	rgcdescMSO[]	=
	{
	//	cluster system objects by table - all related table objects have
	//	the same clustering id, which will be the object id of the table
	"ObjidTable", 		fidMSO_ObjidTable,		JET_coltypLong, 	   	JET_bitColumnNotNULL, 

	//	see SYSOBJ for valid types
	"Type",				fidMSO_Type,			JET_coltypShort,		JET_bitColumnNotNULL,

	//	object id for tables/indexes/LV, columnid for columns
	"Id",				fidMSO_Id,				JET_coltypLong,			JET_bitColumnNotNULL,

	//	table/column/index/LV name
	"Name",					fidMSO_Name,				JET_coltypText,			JET_bitColumnNotNULL,

	//	column type for columns, pgnoFDP for tables/indexes/LV
	"ColtypOrPgnoFDP",		fidMSO_Coltyp,				JET_coltypLong,			JET_bitColumnNotNULL,
	
	//	density for tables/indexes/LV, column length for columns
	"SpaceUsage",			fidMSO_SpaceUsage,			JET_coltypLong,			JET_bitColumnNotNULL,
	
	"Flags",				fidMSO_Flags,				JET_coltypLong,			JET_bitColumnNotNULL,

	//	initial pages for table/LV, code page for columns, localeid for indexes
	"PagesOrLocale",		fidMSO_Pages,				JET_coltypLong,			JET_bitColumnNotNULL,

	//	unused by columns
	"Stats",				fidMSO_Stats,				JET_coltypBinary,		NO_GRBIT,


	//	set TableFlag to TRUE for tables, NULL otherwise
	"RootFlag",				fidMSO_RootFlag,			JET_coltypBit,			NO_GRBIT,

	//  name of the template table for table, callback name for callbacks and columns
	"TemplateTable",		fidMSO_TemplateTable,		JET_coltypText,			NO_GRBIT,
//	"Callback",				fidMSO_Callback,			JET_coltypText,			NO_GRBIT,

	//	COLUMN-specific items
	"RecordOffset",			fidMSO_RecordOffset,		JET_coltypShort,		NO_GRBIT,
	"DefaultValue",			fidMSO_DefaultValue,		JET_coltypBinary,		NO_GRBIT,

	//	INDEX-specific items
	//	max. # of fields in a key is (size of coltypBinary)/(size of JET_COLUMNID) = 255/8 = 31
	"KeyFldIDs",			fidMSO_KeyFldIDs,			JET_coltypBinary,		NO_GRBIT,
	"VarSegMac",		  	fidMSO_VarSegMac,			JET_coltypBinary,		NO_GRBIT,
	"ConditionalColumns",	fidMSO_ConditionalColumns,	JET_coltypBinary,		NO_GRBIT,
	"LCMapFlags",			fidMSO_LCMapFlags,			JET_coltypLong,			NO_GRBIT,
	"TupleLimits",			fidMSO_TupleLimits,			JET_coltypBinary,		NO_GRBIT,

	//  CALLBACK-related items
	//  These are used by columns with callbacks (user-defined default values)
	//  Added in database version 0x620,3
	"CallbackData",			fidMSO_CallbackData,		JET_coltypLongBinary,	JET_bitColumnTagged,
	"CallbackDependencies",	fidMSO_CallbackDependencies,JET_coltypLongBinary,	JET_bitColumnTagged,
	};

LOCAL const ULONG	cColumnsMSO		= sizeof(rgcdescMSO)/sizeof(CDESC);


LOCAL const IDESC	rgidescMSO[]	=
	{
	(CHAR *)szMSOIdIndex, 			"+ObjidTable\0+Type\0+Id\0", 	JET_bitIndexPrimary|JET_bitIndexDisallowNull,
	(CHAR *)szMSONameIndex, 		"+ObjidTable\0+Type\0+Name\0",	JET_bitIndexUnique|JET_bitIndexDisallowNull,

	//	This index is only used to filter out duplicate table names (all root objects
	//	object -- currently only tables -- have the RootFlag field set, all non-root
	//	objects don't set it)
	(CHAR *)szMSORootObjectsIndex,	"+RootFlag\0+Name\0",			JET_bitIndexUnique|JET_bitIndexIgnoreFirstNull
	};

LOCAL const ULONG	cIndexesMSO		= sizeof(rgidescMSO)/sizeof(IDESC);


LOCAL const ULONG	cbMaxDeletedColumnStubName	= 32;
LOCAL const CHAR	szDeletedColumnStubPrefix[]	= "JetStub_";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_log\logutil.cxx ===
#include "std.hxx"

#include <stdarg.h>
#include <io.h>

#define szTemp	"temp"

//	Forward declaration

VOID LGMakeName( IFileSystemAPI *const pfsapi, CHAR *szName, const CHAR *szPath, const CHAR *szFName, const CHAR *szExt );


extern VOID	ITDBGSetConstants( INST * pinst = NULL);

ERR ISAMAPI ErrIsamBeginExternalBackup( JET_INSTANCE jinst, JET_GRBIT grbit );
ERR ISAMAPI ErrIsamGetAttachInfo( JET_INSTANCE jinst, VOID *pv, ULONG cbMax, ULONG *pcbActual );
ERR ISAMAPI ErrIsamOpenFile( JET_INSTANCE jinst,  const CHAR *szFileName,
	JET_HANDLE	*phfFile, ULONG *pulFileSizeLow, ULONG *pulFileSizeHigh );
ERR ISAMAPI ErrIsamReadFile( JET_INSTANCE jinst, JET_HANDLE hfFile, VOID *pv, ULONG cbMax, ULONG *pcbActual );
ERR ISAMAPI ErrIsamCloseFile( JET_INSTANCE jinst,  JET_HANDLE hfFile );
ERR ISAMAPI ErrIsamGetLogInfo( JET_INSTANCE jinst,  VOID *pv, ULONG cbMax, ULONG *pcbActual, JET_LOGINFO *pLogInfo );
ERR ISAMAPI ErrIsamTruncateLog(  JET_INSTANCE jinst );
ERR ISAMAPI ErrIsamEndExternalBackup(  JET_INSTANCE jinst, JET_GRBIT grbit );

#ifdef ELIMINATE_PATCH_FILE
#else
VOID LGIClosePatchFile( FMP *pfmp );
#endif


#ifdef ELIMINATE_PATCH_FILE

ERR ErrLGCheckDBFiles( INST *pinst, IFileSystemAPI *const pfsapi, RSTMAP * pDbMapEntry, CHAR *szPatch, int genLow, int genHigh, LGPOS *plgposSnapshotRestore = NULL )
	{
	ERR err;
	DBFILEHDR_FIX *pdbfilehdrDb;
	PATCHHDR *	ppatchHdr;
	SIGNATURE *psignLog = &(pinst->m_plog->m_signLog);
	
	Assert ( pDbMapEntry );
	const CHAR * szDatabase = pDbMapEntry->szNewDatabaseName;
	
	BOOL fFromSnapshotBackup = fFalse;
	unsigned long ulGenHighFound = 0;
	unsigned long ulGenLowFound = 0;

	Assert ( NULL == szPatch );

	/*	check if dbfilehdr of database and patchfile are the same.
	/**/
	pdbfilehdrDb = (DBFILEHDR_FIX *)PvOSMemoryPageAlloc( g_cbPage, NULL );
	if ( pdbfilehdrDb == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	err = ErrUtilReadShadowedHeader(	pfsapi, 
										szDatabase, 
										(BYTE*)pdbfilehdrDb, 
										g_cbPage, 
										OffsetOf( DBFILEHDR_FIX, le_cbPageSize ) );
	if ( err < 0 )
		{
		if ( err == JET_errDiskIO )
			err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto EndOfCheckHeader2;
		}

	// fill in the RSTMAP the found database signature 
	pDbMapEntry->fSLVFile = (attribSLV == pdbfilehdrDb->le_attrib);
	memcpy ( &pDbMapEntry->signDatabase, &pdbfilehdrDb->signDb , sizeof(SIGNATURE) );
	
	// check here if it is an SLV file
	// if so, exit with a specific error
	if ( attribSLV == pdbfilehdrDb->le_attrib )
		{
		err = ErrERRCheck( wrnSLVDatabaseHeader );
		goto EndOfCheckHeader2;		
		}

	// should be a db header or patch file header
	if ( attribDb != pdbfilehdrDb->le_attrib )
		{
		Assert ( fFalse );
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto EndOfCheckHeader2;				
		}
			
	fFromSnapshotBackup = ( CmpLgpos ( &(pdbfilehdrDb->bkinfoSnapshotCur.le_lgposMark), &lgposMin ) > 0 );

	if ( plgposSnapshotRestore )
		{
		*plgposSnapshotRestore = pdbfilehdrDb->bkinfoSnapshotCur.le_lgposMark;
		}

	// with snapshot backup, we don't use a patch file
	// exit with no error
	if ( fFromSnapshotBackup )
		{
		Assert ( plgposSnapshotRestore );
		err = JET_errSuccess; 

		if ( memcmp( &pdbfilehdrDb->signLog, psignLog, sizeof( SIGNATURE ) ) != 0 )
			{
			const UINT csz = 1;
			const CHAR *rgszT[csz];

			rgszT[0] = szDatabase;

			// UNDONE: change event message and error
			UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
				DATABASE_PATCH_FILE_MISMATCH_ERROR_ID, csz, rgszT, 0, NULL, pinst);
			CallJ ( ErrERRCheck( JET_errDatabasePatchFileMismatch ), EndOfCheckHeader2 );
			}
			
		ulGenHighFound = pdbfilehdrDb->bkinfoSnapshotCur.le_genHigh;
		ulGenLowFound = pdbfilehdrDb->bkinfoSnapshotCur.le_genLow;

		goto EndOfCheckLogRange;
		}
		
	ppatchHdr = (PATCHHDR *)PvOSMemoryPageAlloc( g_cbPage, NULL );
	if ( ppatchHdr == NULL )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto EndOfCheckHeader2;
		}

	Assert ( pdbfilehdrDb->bkinfoFullCur.le_genLow );
	
	// if we have already the trailer moved to the header
	// we are good to go
	if ( pdbfilehdrDb->bkinfoFullCur.le_genHigh )
		{
		ulGenHighFound = pdbfilehdrDb->bkinfoFullCur.le_genHigh;
		ulGenLowFound = pdbfilehdrDb->bkinfoFullCur.le_genLow;
		goto EndOfCheckLogRange;
		}

	//	the patch file is always on the OS file-system
	CallJ ( pinst->m_plog->ErrLGBKReadAndCheckDBTrailer(pfsapi, szDatabase, (BYTE*)ppatchHdr ), EndOfCheckHeader);
		
	if ( memcmp( &pdbfilehdrDb->signDb, &ppatchHdr->signDb, sizeof( SIGNATURE ) ) != 0 ||
		 memcmp( &pdbfilehdrDb->signLog, psignLog, sizeof( SIGNATURE ) ) != 0 ||
		 memcmp( &ppatchHdr->signLog, psignLog, sizeof( SIGNATURE ) ) != 0 ||
		 CmpLgpos( &pdbfilehdrDb->bkinfoFullCur.le_lgposMark,
				   &ppatchHdr->bkinfo.le_lgposMark ) != 0 )
		{
		const UINT csz = 1;
		const CHAR *rgszT[csz];
		
		rgszT[0] = szDatabase;
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					DATABASE_PATCH_FILE_MISMATCH_ERROR_ID, csz, rgszT, 0, NULL, pinst );
		CallJ ( ErrERRCheck( JET_errDatabasePatchFileMismatch ), EndOfCheckHeader);
		}
	else
		{
		ulGenHighFound = ppatchHdr->bkinfo.le_genHigh;
		ulGenLowFound = ppatchHdr->bkinfo.le_genLow;
		}


EndOfCheckLogRange:
	if ( ulGenLowFound < (ULONG) genLow )
		{
		/*	It should start at most from bkinfoFullCur.genLow
		 */
		CHAR	szT1[IFileSystemAPI::cchPathMax];
		CHAR	szT2[IFileSystemAPI::cchPathMax];		
		const CHAR *rgszT[] = { szT1, szT2 };

		// use szPatch as this should be the path of the log files as well
		pinst->m_plog->LGFullLogNameFromLogId(pfsapi, szT1, genLow, szPatch);
		pinst->m_plog->LGFullLogNameFromLogId(pfsapi, szT2, ulGenLowFound, szPatch);
 		 		
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					STARTING_RESTORE_LOG_TOO_HIGH_ERROR_ID, 2, rgszT, 0, NULL, pinst );
		err = ErrERRCheck( JET_errStartingRestoreLogTooHigh );
		}

	else if ( ulGenHighFound > (ULONG) genHigh )
		{
		/*	It should be at least from bkinfoFullCur.genHigh
		 */
		CHAR	szT1[IFileSystemAPI::cchPathMax];
		CHAR	szT2[IFileSystemAPI::cchPathMax];		
		const CHAR *rgszT[] = { szT1, szT2 };

		// use szPatch as this should be the path of the log files as well
		pinst->m_plog->LGFullLogNameFromLogId(pfsapi, szT1, genHigh, szPatch);
		pinst->m_plog->LGFullLogNameFromLogId(pfsapi, szT2, ulGenHighFound, szPatch);	
 		
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					ENDING_RESTORE_LOG_TOO_LOW_ERROR_ID, 2, rgszT, 0, NULL, pinst );
		err = ErrERRCheck( JET_errEndingRestoreLogTooLow );
		}

	// we can update the database header and we don't need the trailer
	Assert ( ulGenLowFound == pdbfilehdrDb->bkinfoFullCur.le_genLow);
	Assert ( ulGenHighFound <= genHigh);

	// we update genMax with the max that we restored,
	// mot just with was in the header file
	pdbfilehdrDb->bkinfoFullCur.le_genHigh = genHigh;
	CallJ( ErrUtilWriteShadowedHeader(	pfsapi, 
										szDatabase, 
										fTrue,
										(BYTE *)pdbfilehdrDb, 
										g_cbPage ), EndOfCheckHeader );		 

	
EndOfCheckHeader:	
	OSMemoryPageFree( ppatchHdr );

EndOfCheckHeader2:	
	OSMemoryPageFree( pdbfilehdrDb );

	return err;
	}

#else	//	ELIMINATE_PATCH_FILE

ERR ErrLGCheckDBFiles( INST *pinst, IFileSystemAPI *const pfsapi, RSTMAP * pDbMapEntry, CHAR *szPatch, int genLow, int genHigh, LGPOS *plgposSnapshotRestore = NULL )
	{
	ERR err;
	DBFILEHDR_FIX *pdbfilehdrDb;
	DBFILEHDR_FIX *pdbfilehdrPatch;
	SIGNATURE *psignLog = &(pinst->m_plog->m_signLog);

	Assert ( pDbMapEntry );
	const CHAR * szDatabase = pDbMapEntry->szNewDatabaseName;
	
	BOOL fFromSnapshotBackup = fFalse;
	unsigned long ulGenHighFound = 0;
	unsigned long ulGenLowFound = 0;
	
	/*	check if dbfilehdr of database and patchfile are the same.
	/**/
	pdbfilehdrDb = (DBFILEHDR_FIX * )PvOSMemoryPageAlloc( g_cbPage, NULL );
	if ( pdbfilehdrDb == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	err = ErrUtilReadShadowedHeader(	pfsapi,
										szDatabase,
										(BYTE*)pdbfilehdrDb,
										g_cbPage,
										OffsetOf( DBFILEHDR_FIX, le_cbPageSize ) );
	if ( err < 0 )
		{
		if ( err == JET_errDiskIO )
			err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto EndOfCheckHeader2;
		}

	// fill in the RSTMAP the found database signature
	pDbMapEntry->fSLVFile = (attribSLV == pdbfilehdrDb->le_attrib);
	memcpy ( &pDbMapEntry->signDatabase, &pdbfilehdrDb->signDb , sizeof(SIGNATURE) );
	
	// check here if it is an SLV file
	// if so, exit with a specific error
	if ( attribSLV == pdbfilehdrDb->le_attrib )
		{
		err = ErrERRCheck( wrnSLVDatabaseHeader );
		goto EndOfCheckHeader2;		
		}

	// should be a db header or patch file header
	if ( attribDb != pdbfilehdrDb->le_attrib )
		{
		Assert ( fFalse );
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto EndOfCheckHeader2;				
		}
			
	fFromSnapshotBackup = ( CmpLgpos ( &(pdbfilehdrDb->bkinfoSnapshotCur.le_lgposMark), &lgposMin ) > 0 );

	if ( plgposSnapshotRestore )
		{
		*plgposSnapshotRestore = pdbfilehdrDb->bkinfoSnapshotCur.le_lgposMark;
		}

	// with snapshot backup, we don't use a patch file
	// exit with no error
	if ( fFromSnapshotBackup )
		{
		Assert ( plgposSnapshotRestore );
		err = JET_errSuccess;

		if (  memcmp( &pdbfilehdrDb->signLog, psignLog, sizeof( SIGNATURE ) ) != 0 )
			{
			const UINT csz = 1;
			const CHAR *rgszT[csz];

			rgszT[0] = szDatabase;

			// UNDONE: change event message and error
			UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
				DATABASE_PATCH_FILE_MISMATCH_ERROR_ID, csz, rgszT, 0, NULL, pinst);
			CallJ ( ErrERRCheck( JET_errDatabasePatchFileMismatch ), EndOfCheckHeader2 );
			}
			
		ulGenHighFound = pdbfilehdrDb->bkinfoSnapshotCur.le_genHigh;
		ulGenLowFound = pdbfilehdrDb->bkinfoSnapshotCur.le_genLow;

		goto EndOfCheckLogRange;
		}
		
	pdbfilehdrPatch = (DBFILEHDR_FIX * )PvOSMemoryPageAlloc( g_cbPage, NULL );
	if ( pdbfilehdrPatch == NULL )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto EndOfCheckHeader2;
		}

	err = ErrUtilReadShadowedHeader(	pinst->m_pfsapi, 
										szPatch, 
										(BYTE*)pdbfilehdrPatch, 
										g_cbPage );
	if ( err < 0 )
		{
		if ( err == JET_errDiskIO )
			err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto EndOfCheckHeader;
		}

	if ( memcmp( &pdbfilehdrDb->signDb, &pdbfilehdrPatch->signDb, sizeof( SIGNATURE ) ) != 0 ||
		 memcmp( &pdbfilehdrDb->signLog, psignLog, sizeof( SIGNATURE ) ) != 0 ||
		 memcmp( &pdbfilehdrPatch->signLog, psignLog, sizeof( SIGNATURE ) ) != 0 ||
		 CmpLgpos( &pdbfilehdrDb->bkinfoFullCur.le_lgposMark,
				   &pdbfilehdrPatch->bkinfoFullCur.le_lgposMark ) != 0 )
		{
		const UINT csz = 1;
		const CHAR *rgszT[csz];
		
		rgszT[0] = szDatabase;
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					DATABASE_PATCH_FILE_MISMATCH_ERROR_ID, csz, rgszT, 0, NULL, pinst );
		CallJ ( ErrERRCheck( JET_errDatabasePatchFileMismatch ), EndOfCheckHeader);
		}
	else
		{
		ulGenHighFound = pdbfilehdrPatch->bkinfoFullCur.le_genHigh;
		ulGenLowFound = pdbfilehdrPatch->bkinfoFullCur.le_genLow;
		}
		
EndOfCheckLogRange:
	if ( ulGenLowFound < (ULONG) genLow )
		{
		/*	It should start at most from bkinfoFullCur.genLow
		 */
		CHAR	szT1[IFileSystemAPI::cchPathMax];
		CHAR	szT2[IFileSystemAPI::cchPathMax];		
		const CHAR *rgszT[] = { szT1, szT2 };

		// use szPatch as this should be the path of the log files as well
		pinst->m_plog->LGFullLogNameFromLogId(pfsapi, szT1, genLow, szPatch);
		pinst->m_plog->LGFullLogNameFromLogId(pfsapi, szT2, ulGenLowFound, szPatch);
 		 		
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					STARTING_RESTORE_LOG_TOO_HIGH_ERROR_ID, 2, rgszT, 0, NULL, pinst );
		err = ErrERRCheck( JET_errStartingRestoreLogTooHigh );
		}

	else if ( ulGenHighFound > (ULONG) genHigh )
		{
		/*	It should be at least from bkinfoFullCur.genHigh
		 */
		CHAR	szT1[IFileSystemAPI::cchPathMax];
		CHAR	szT2[IFileSystemAPI::cchPathMax];		
		const CHAR *rgszT[] = { szT1, szT2 };

		// use szPatch as this should be the path of the log files as well
		pinst->m_plog->LGFullLogNameFromLogId(pfsapi, szT1, genHigh, szPatch);
		pinst->m_plog->LGFullLogNameFromLogId(pfsapi, szT2, ulGenHighFound, szPatch);	
 		
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					ENDING_RESTORE_LOG_TOO_LOW_ERROR_ID, 2, rgszT, 0, NULL, pinst );
		err = ErrERRCheck( JET_errEndingRestoreLogTooLow );
		}
		
EndOfCheckHeader:	
	OSMemoryPageFree( pdbfilehdrPatch );
EndOfCheckHeader2:	
	OSMemoryPageFree( pdbfilehdrDb );

	return err;
	}

#endif	//	ELIMINATE_PATCH_FILE


LOCAL ERR LOG::ErrLGRSTOpenLogFile(	IFileSystemAPI *const	pfsapi,
									CHAR 						*szLogPath,
									INT 						gen,
									IFileAPI **const		ppfapi )
	{
	CHAR   		rgchFName[IFileSystemAPI::cchPathMax];
	CHAR		szPath[IFileSystemAPI::cchPathMax];

	strcpy( szPath, szLogPath );

	if ( gen == 0 )
		strcat( szPath, m_szJetLog );
	else
		{
		LGSzFromLogId( rgchFName, gen );
		strcat( szPath, rgchFName );
		strcat( szPath, szLogExt );
		}

	return pfsapi->ErrFileOpen( szPath, ppfapi );
	}


#define fLGRSTIncludeJetLog	fTrue
#define fLGRSTNotIncludeJetLog fFalse
LOCAL VOID LOG::LGRSTDeleteLogs( IFileSystemAPI *const pfsapi, CHAR *szLog, INT genLow, INT genHigh, BOOL fIncludeJetLog )
	{
	INT  gen;
	CHAR rgchFName[IFileSystemAPI::cchPathMax];
	CHAR szPath[IFileSystemAPI::cchPathMax];

	for ( gen = genLow; gen <= genHigh; gen++ )
		{
		LGSzFromLogId( rgchFName, gen );
		strcpy( szPath, szLog );
		strcat( szPath, rgchFName );
		strcat( szPath, szLogExt );
		CallSx( pfsapi->ErrFileDelete( szPath ), JET_errFileNotFound );
		}

	if ( fIncludeJetLog )
		{
		strcpy( szPath, szLog );
		strcat( szPath, m_szJetLog );
		CallSx( pfsapi->ErrFileDelete( szPath ), JET_errFileNotFound );
		}
	}

	
ERR LOG::ErrLGRSTCheckSignaturesLogSequence(
	IFileSystemAPI *const pfsapi,
	char *szRestorePath,
	char *szLogFilePath,
	INT	genLow,
	INT	genHigh,
	char *szTargetInstanceFilePath,
	INT	genHighTarget )
	{
	ERR				err = JET_errSuccess;
	LONG			gen;
	LONG			genLowT;
	LONG			genHighT;
	IFileAPI	*pfapiT = NULL;
	LGFILEHDR		*plgfilehdrT = NULL;
	LGFILEHDR		*plgfilehdrCur[2] = { NULL, NULL };
	LGFILEHDR		*plgfilehdrLow = NULL;
	LGFILEHDR		*plgfilehdrHigh = NULL;
	INT				ilgfilehdrAvail = 0;
	INT				ilgfilehdrCur;
	INT				ilgfilehdrPrv;
	BOOL			fReadyToCheckContiguity;
//	ERR				wrn = JET_errSuccess;

	BOOL fTargetInstanceCheck = fFalse;
	CHAR * szLogFilePathCheck = NULL;

	plgfilehdrT = (LGFILEHDR *)PvOSMemoryPageAlloc( sizeof(LGFILEHDR) * 4, NULL );
	if ( plgfilehdrT == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	plgfilehdrCur[0] = plgfilehdrT;
	plgfilehdrCur[1] = plgfilehdrT + 1;
	plgfilehdrLow = plgfilehdrT + 2;
	plgfilehdrHigh = plgfilehdrT + 3;

	/*	starting from lowest generation of the restored path.
	 *	Check the given logs are all correct and contiguous
	 */
	for ( gen = genLow; gen <= genHigh; gen++ )
		{
		ilgfilehdrCur = ilgfilehdrAvail++ % 2;
		ilgfilehdrPrv = ilgfilehdrAvail % 2;

		Call( ErrLGRSTOpenLogFile( pfsapi, szRestorePath, gen, &pfapiT ) );
		Call( ErrLGReadFileHdr( pfapiT, plgfilehdrCur[ ilgfilehdrCur ], fCheckLogID ) );
		delete pfapiT;
		pfapiT = NULL;

		if ( gen == genLow )
			{
			UtilMemCpy( plgfilehdrLow, plgfilehdrCur[ ilgfilehdrCur ], sizeof( LGFILEHDR ) );
			}

		if ( gen == genHigh )
			{
			UtilMemCpy( plgfilehdrHigh, plgfilehdrCur[ ilgfilehdrCur ], sizeof( LGFILEHDR ) );
			}

		if ( gen > genLow )
			{			
			if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.signLog,
						 &plgfilehdrCur[ ilgfilehdrPrv ]->lgfilehdr.signLog,
						 sizeof( SIGNATURE ) ) != 0 )
				{
				CHAR szT[IFileSystemAPI::cchPathMax];
				const UINT	csz = 1;
				const CHAR *rgszT[csz];
				rgszT[0] = szT;

				LGFullLogNameFromLogId(pfsapi, szT, gen, szRestorePath);
				
				UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					RESTORE_LOG_FILE_HAS_BAD_SIGNATURE_ERROR_ID, csz, rgszT, 0, NULL, m_pinst );
				Call( ErrERRCheck( JET_errGivenLogFileHasBadSignature ) );
				}
			if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.tmPrevGen,
						 &plgfilehdrCur[ ilgfilehdrPrv ]->lgfilehdr.tmCreate,
						 sizeof( LOGTIME ) ) != 0 )
				{
				CHAR szT[20];
				const UINT	csz = 1;
				const CHAR *rgszT[csz];
				_itoa( gen, szT, 16 );
				rgszT[0] = szT;
				UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					RESTORE_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID, csz, rgszT, 0, NULL, m_pinst );
				Call( ErrERRCheck( JET_errGivenLogFileIsNotContiguous ) );
				}
			}
		}

	if ( gen <= genHigh )
		{
		// I can't see how this path can be taken after the loop ...
		Assert ( 0 );
		
		CHAR szT[IFileSystemAPI::cchPathMax];
		const UINT	csz = 1;
		const CHAR *rgszT[csz];		
		rgszT[0] = szT;

		LGFullLogNameFromLogId(pfsapi, szT, gen, szRestorePath);
		
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
				RESTORE_LOG_FILE_MISSING_ERROR_ID, csz, rgszT, 0, NULL, m_pinst );
		Call( ErrERRCheck( JET_errMissingRestoreLogFiles ) );
		}

	// we are going to check the log sequence from the backup set ()
	// and szLogFilePath or szTargetInstanceFilePath (if used)

	if ( szTargetInstanceFilePath )
		{
		Assert ( genHighTarget );
		fTargetInstanceCheck = fTrue;
		szLogFilePathCheck = szTargetInstanceFilePath;
		}
	else
		{
		Assert ( ! fTargetInstanceCheck );
		szLogFilePathCheck = szLogFilePath;
		}

	Assert ( szLogFilePathCheck );
	
	/*	if Restore path and log path is different, delete all the unrelated log files
	 *	in the restore log path.
	 */
	{
	CHAR  	szFullLogPath[IFileSystemAPI::cchPathMax];
	CHAR  	szFullLogFilePathCheck[IFileSystemAPI::cchPathMax];

	CallS( pfsapi->ErrPathComplete( szRestorePath, szFullLogPath ) );
	CallS( pfsapi->ErrPathComplete( szLogFilePathCheck, szFullLogFilePathCheck ) );

#ifdef DEBUG
	// TargetInstance, the TargetInstance should be different the the recover instance directory
	if ( szTargetInstanceFilePath )
		{
		Assert ( szLogFilePathCheck == szTargetInstanceFilePath );
		
		CallS ( pfsapi->ErrPathComplete( szLogFilePath, szFullLogPath ) );
		Assert ( UtilCmpFileName( szFullLogPath, szFullLogFilePathCheck ) );
		}
#endif // DEBUG

	CallS( pfsapi->ErrPathComplete( szRestorePath, szFullLogPath ) );
		
	if ( UtilCmpFileName( szFullLogPath, szFullLogFilePathCheck ) != 0 &&
		( JET_errSuccess == ErrLGIGetGenerationRange( pfsapi, szRestorePath, &genLowT, &genHighT ) ) )
		{
		LGRSTDeleteLogs( pfsapi, szRestorePath, genLowT, genLow - 1, fLGRSTNotIncludeJetLog );
		LGRSTDeleteLogs( pfsapi, szRestorePath, genHigh + 1, genHighT, fLGRSTIncludeJetLog );
		}
	}
	
	/*	Check the log directory. Make sure all the log files has the same signature.
	 */
	Call ( ErrLGIGetGenerationRange( pfsapi, szLogFilePathCheck, &genLowT, &genHighT ) );

	if ( fTargetInstanceCheck )
		{
		Assert ( genHighTarget );
		Assert ( genHighT >= genHighTarget );
		Assert ( genLowT <= genHighTarget );
		

		if ( genHighT < genHighTarget || genLowT > genHighTarget || 0 == genLowT )
			{
			//	Someone delete the logs since last time we checked the
			//	restore log files.

			Assert(0);
			CHAR szT[IFileSystemAPI::cchPathMax];
			const UINT	csz = 1;
			const CHAR *rgszT[csz];		
			rgszT[0] = szT;

			LGFullLogNameFromLogId(pfsapi, szT, genHighTarget, szLogFilePathCheck);
			
			UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					RESTORE_LOG_FILE_MISSING_ERROR_ID, csz, rgszT, 0, NULL, m_pinst );
			Call( ErrERRCheck( JET_errMissingRestoreLogFiles ) );
			}
			
		// set the max log to check to genHighTarget
		genHighT = genHighTarget;
		}
		
	/*	genHighT + 1 implies JetLog file (edb.log).
	 */
	if ( genLowT > genHigh )
		fReadyToCheckContiguity = fTrue;
	else
		fReadyToCheckContiguity = fFalse;

	for ( gen = genLowT; gen <= (fTargetInstanceCheck?genHighT:genHighT + 1); gen++ )
		{
		if ( gen == 0 )
			{
			
			Assert ( !fTargetInstanceCheck );
			
			/*	A special case. Check if JETLog(edb.log) exist?
			 */
			if ( ErrLGRSTOpenLogFile( pfsapi, szLogFilePathCheck, 0, &pfapiT ) < 0 )
				break;

			/*	Set break condition. Also set condition to check if
			 *	the log is contiguous from the restore logs ( genHigh + 1 )
			 */
			gen = genHigh + 1;
			genHighT = genHigh;
			Assert( gen == genHighT + 1 );
			}
		else
			{
			if ( gen == genHighT + 1 )
				{
				Assert ( !fTargetInstanceCheck );
				
				/*	A special case. Check if JETLog(edb.log) exist?
				 */
				if ( ErrLGRSTOpenLogFile( pfsapi, szLogFilePathCheck, 0, &pfapiT ) < 0 )
					break;
				}
			else
				{
				err = ErrLGRSTOpenLogFile( pfsapi, szLogFilePathCheck, gen, &pfapiT );
				if ( err == JET_errFileNotFound )
					{
					// The expected log generation is missing...
					CHAR szT[IFileSystemAPI::cchPathMax];
					const UINT	csz = 1;
					const CHAR *rgszT[csz];

					LGFullLogNameFromLogId(pfsapi, szT, gen, szLogFilePathCheck);
						
					rgszT[0] = szT;
					if ( gen <= genHigh )
						{
						if ( _stricmp( szRestorePath, szLogFilePathCheck ) != 0 )
							{
							//	skip all the logs that can be found in
							//	szRestorePath. Continue from genHigh+1
							gen = genHigh;
							continue;
							}

						//	Someone delete the logs since last time we checked the
						//	restore log files.

						Assert(0);
						UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
								RESTORE_LOG_FILE_MISSING_ERROR_ID, csz, rgszT, 0, NULL, m_pinst );
						Call( ErrERRCheck( JET_errMissingRestoreLogFiles ) );
						}
					else
						{
						UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
							CURRENT_LOG_FILE_MISSING_ERROR_ID, csz, rgszT, 0, NULL, m_pinst );
						err = ErrERRCheck( JET_errMissingCurrentLogFiles );
						}
					}
				Call( err );
				}
			}


		ilgfilehdrCur = ilgfilehdrAvail++ % 2;
		ilgfilehdrPrv = ilgfilehdrAvail % 2;

		Call( ErrLGReadFileHdr( pfapiT, plgfilehdrCur[ ilgfilehdrCur ], fNoCheckLogID ) );
		delete pfapiT;
		pfapiT = NULL;

		if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.signLog,
					 &plgfilehdrHigh->lgfilehdr.signLog,
					 sizeof( SIGNATURE ) ) != 0 )
			{
			INT genCurrent;
			char szT1[20];
			const UINT	csz = 1;
			const char *rgszT[csz];
			rgszT[0] = szT1;

			if ( gen < genLow )
				{
				genCurrent = genLow - 1;
				}
			else if ( gen <= genHigh )
				{
				genCurrent = gen;
				}
			else
				{
				genCurrent = genHighT + 1;	// to break out the loop
				}
				
			if ( gen == genHighT + 1 || 0 == gen )
				{
				sprintf( szT1, "%s.log", m_szBaseName );
				}
			else
				{
				sprintf( szT1, "%s%05X.log", m_szBaseName, gen );
				}
				
			UtilReportEvent( eventWarning, LOGGING_RECOVERY_CATEGORY,
					EXISTING_LOG_FILE_HAS_BAD_SIGNATURE_ERROR_ID_2, csz, rgszT, 0, NULL, m_pinst );

			err = ErrERRCheck( JET_errExistingLogFileHasBadSignature );
			gen = genCurrent;
			fReadyToCheckContiguity = fFalse;
			continue;
			}

		if ( fReadyToCheckContiguity )
			{
			if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.tmPrevGen,
						 &plgfilehdrCur[ ilgfilehdrPrv ]->lgfilehdr.tmCreate,
						 sizeof( LOGTIME ) ) != 0 )
				{
				CHAR szT1[20];
				CHAR szT2[20];
				const UINT	csz = 2;
				const CHAR *rgszT[csz];
				LONG genCur = plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.le_lGeneration;
				LONG genPrv = plgfilehdrCur[ ilgfilehdrPrv ]->lgfilehdr.le_lGeneration;

//				wrn = ErrERRCheck( JET_wrnExistingLogFileIsNotContiguous );
				err = ErrERRCheck( JET_errExistingLogFileIsNotContiguous );

				if ( genPrv == genHighT + 1 || 0 == genPrv )
					{
					sprintf( szT1, "%s.log", m_szBaseName );
					}
				else
					{
					sprintf( szT1, "%s%05X.log", m_szBaseName, genPrv );
					}

				if ( genCur == genHighT + 1 || 0 == genCur )
					{
					sprintf( szT2, "%s.log", m_szBaseName );
					}
				else
					{
					sprintf( szT2, "%s%05X.log", m_szBaseName, genCur );
					}
				rgszT[0] = szT1;
				rgszT[1] = szT2;
				UtilReportEvent( eventWarning, LOGGING_RECOVERY_CATEGORY,
					EXISTING_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID_2, csz, rgszT, 0, NULL, m_pinst );

				if ( gen < genLow )
					{
					continue;
					}
				else if ( gen <= genHigh )
					{
					gen = genHigh;
					continue;
					}
				else
					{
					break;
					}
				}
			}

		if ( gen == genLow - 1 )
			{
			/*	make sure it and the restore log are contiguous. If not, then delete
			 *	all the logs up to genLow - 1.
			 */
			if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.tmCreate,
						 &plgfilehdrLow->lgfilehdr.tmPrevGen,
						 sizeof( LOGTIME ) ) != 0 )
				{
				CHAR szT1[20];
				CHAR szT2[20];
				const UINT csz = 2;
				const CHAR *rgszT[csz];
				LONG genCur = plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.le_lGeneration;
				LONG genPrv = plgfilehdrLow->lgfilehdr.le_lGeneration;

				if ( genPrv == genHighT + 1 || 0 == genPrv )
					{
					sprintf( szT1, "%s.log", m_szBaseName );
					}
				else
					{
					sprintf( szT1, "%s%05X.log", m_szBaseName, genPrv );
					}

				if ( genCur == genHighT + 1 || 0 == genCur )
					{
					sprintf( szT2, "%s.log", m_szBaseName );
					}
				else
					{
					sprintf( szT2, "%s%05X.log", m_szBaseName, genCur );
					}
					
				rgszT[0] = szT1;
				rgszT[1] = szT2;
				UtilReportEvent( eventWarning, LOGGING_RECOVERY_CATEGORY,
					EXISTING_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID_2, csz, rgszT, 0, NULL, m_pinst );
				
				err = ErrERRCheck( JET_errExistingLogFileIsNotContiguous );
				fReadyToCheckContiguity = fFalse;
				continue;
				}
			}

		if ( gen == genLow )
			{
			/*	make sure it and the restore log are the same. If not, then delete
			 *	all the logs up to genHigh.
			 */
			if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.tmCreate,
						 &plgfilehdrLow->lgfilehdr.tmCreate,
						 sizeof( LOGTIME ) ) != 0 )
				{
				CHAR szT1[20];
				CHAR szT2[20];
				const UINT csz = 2;
				const CHAR *rgszT[csz];
				LONG genCur = plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.le_lGeneration;
				LONG genPrv = plgfilehdrLow->lgfilehdr.le_lGeneration;

				if ( genPrv == genHighT + 1 || 0 == genPrv )
					{
					sprintf( szT1, "%s.log", m_szBaseName );
					}
				else
					{
					sprintf( szT1, "%s%05X.log", m_szBaseName, genPrv );
					}

				if ( genCur == genHighT + 1 || 0 == genCur )
					{
					sprintf( szT2, "%s.log", m_szBaseName );
					}
				else
					{
					sprintf( szT2, "%s%05X.log", m_szBaseName, genCur );
					}
	
				rgszT[0] = szT1;
				rgszT[1] = szT2;
				UtilReportEvent( eventWarning, LOGGING_RECOVERY_CATEGORY,
					EXISTING_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID_2, csz, rgszT, 0, NULL, m_pinst );

				err = ErrERRCheck( JET_errExistingLogFileIsNotContiguous );

				Assert( _stricmp( szRestorePath, szLogFilePathCheck ) != 0 );
				gen = genHigh;
				continue;
				}
			}

		if ( gen == genHigh + 1 )
			{
			/*	make sure it and the restore log are contiguous. If not, then delete
			 *	all the logs higher than genHigh.
			 */
			if ( memcmp( &plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.tmPrevGen,
						 &plgfilehdrHigh->lgfilehdr.tmCreate,
						 sizeof( LOGTIME ) ) != 0 )
				{
				CHAR szT1[20];
				CHAR szT2[20];
				const UINT csz = 2;
				const CHAR *rgszT[csz];
				LONG genCur = plgfilehdrCur[ ilgfilehdrCur ]->lgfilehdr.le_lGeneration;
				LONG genPrv = plgfilehdrHigh->lgfilehdr.le_lGeneration;

				if ( genPrv == genHighT + 1 || 0 == genPrv )
					{
					sprintf( szT1, "%s.log", m_szBaseName );
					}
				else
					{
					sprintf( szT1, "%s%05X.log", m_szBaseName, genPrv );
					}

				if ( genCur == genHighT + 1 || 0 == genCur )
					{
					sprintf( szT2, "%s.log", m_szBaseName );
					}
				else
					{
					sprintf( szT2, "%s%05X.log", m_szBaseName, genCur );
					}
					
				rgszT[0] = szT1;
				rgszT[1] = szT2;
				UtilReportEvent( eventWarning, LOGGING_RECOVERY_CATEGORY,
					EXISTING_LOG_FILE_NOT_CONTIGUOUS_ERROR_ID_2, csz, rgszT, 0, NULL, m_pinst );

				err = ErrERRCheck( JET_errExistingLogFileIsNotContiguous );
				break;
				}
			}
		
		fReadyToCheckContiguity = fTrue;
		}

HandleError:
//	if ( err == JET_errSuccess )
//		err = wrn;

	// if we have a TargetInstance, map the error codes for bad log files to JET_errBadRestoreTargetInstance
	if ( fTargetInstanceCheck &&
		( JET_errMissingCurrentLogFiles == err || JET_errExistingLogFileIsNotContiguous == err || JET_errExistingLogFileHasBadSignature == err ) )
		{
		err = ErrERRCheck ( JET_errBadRestoreTargetInstance );
		}
	
	delete pfapiT;
	
	OSMemoryPageFree( plgfilehdrT );

	return err;
	}


/*	caller has to make sure szDir has enough space for appending "*"
/**/
LOCAL ERR ErrLGDeleteAllFiles( IFileSystemAPI *const pfsapi, CHAR *szDir )
	{
	ERR				err		= JET_errSuccess;
	IFileFindAPI*	pffapi	= NULL;
	BOOL			fAddDelimiter;

	Assert( strlen( szDir ) + 1 + 1 < IFileSystemAPI::cchPathMax );

	//  iterate over all files in this directory

	fAddDelimiter = !FOSSTRTrailingPathDelimiterA( szDir );
	if ( fAddDelimiter )
		{
		OSSTRAppendPathDelimiterA( szDir, fFalse );
		}
	strcat( szDir, "*" );
	Call( pfsapi->ErrFileFind( szDir, &pffapi ) );
	if ( fAddDelimiter )
		{
		szDir[ strlen( szDir ) - 2 ] = '\0';
		}
	else
		{
		szDir[ strlen( szDir ) - 1 ] = '\0';
		}

	while ( ( err = pffapi->ErrNext() ) == JET_errSuccess )
		{
		CHAR szFileName[IFileSystemAPI::cchPathMax];
		char szDirT[IFileSystemAPI::cchPathMax];
		char szFileT[IFileSystemAPI::cchPathMax];
		char szExtT[IFileSystemAPI::cchPathMax];
		char szFileNameT[IFileSystemAPI::cchPathMax];

		Call( pffapi->ErrPath( szFileName ) );
		Call( pfsapi->ErrPathParse( szFileName, szDirT, szFileT, szExtT ) );
		szDirT[0] = 0;
		Call( pfsapi->ErrPathBuild( szDirT, szFileT, szExtT, szFileNameT ) );
		
		/* not . , and .. and not temp
		/**/
		if (	strcmp( szFileNameT, "." ) &&
				strcmp( szFileNameT, ".." ) &&
				UtilCmpFileName( szFileNameT, szTemp ) )
			{
			err = pfsapi->ErrFileDelete( szFileName );
			if ( err != JET_errSuccess )
				{
				Call( ErrERRCheck( JET_errDeleteBackupFileFail ) );
				}
			}
		}
	Call( err == JET_errFileNotFound ? JET_errSuccess : err );

	err = JET_errSuccess;

HandleError:
	/*	assert restored szDir
	/**/
	Assert( szDir[strlen(szDir)] != '*' );

	delete pffapi;

	return err;
	}


/*	caller has to make sure szDir has enough space for appending "*"
/**/
LOCAL ERR ErrLGCheckDir( IFileSystemAPI *const pfsapi, CHAR *szDir, CHAR *szSearch )
	{
	ERR				err		= JET_errSuccess;
	IFileFindAPI*	pffapi	= NULL;
	BOOL			fAddDelimiter;

	Assert( strlen( szDir ) + 1 + 1 < IFileSystemAPI::cchPathMax );

	//  iterate over all files in this directory

	fAddDelimiter = !FOSSTRTrailingPathDelimiterA( szDir );
	if ( fAddDelimiter )
		{
		OSSTRAppendPathDelimiter( szDir, fFalse );
		}
	strcat( szDir, "*" );
	Call( pfsapi->ErrFileFind( szDir, &pffapi ) );
	if ( fAddDelimiter )
		{
		szDir[ strlen( szDir ) - 2 ] = '\0';
		}
	else
		{
		szDir[ strlen( szDir ) - 1 ] = '\0';
		}

	while ( ( err = pffapi->ErrNext() ) == JET_errSuccess )
		{
		CHAR szFileName[IFileSystemAPI::cchPathMax];
		char szDirT[IFileSystemAPI::cchPathMax];
		char szFileT[IFileSystemAPI::cchPathMax];
		char szExtT[IFileSystemAPI::cchPathMax];
		char szFileNameT[IFileSystemAPI::cchPathMax];

		Call( pffapi->ErrPath( szFileName ) );
		Call( pfsapi->ErrPathParse( szFileName, szDirT, szFileT, szExtT ) );
		szDirT[0] = 0;
		Call( pfsapi->ErrPathBuild( szDirT, szFileT, szExtT, szFileNameT ) );
		
		/* not . , and .. and not szSearch
		/**/
		if (	strcmp( szFileNameT, "." ) &&
				strcmp( szFileNameT, ".." ) &&
				( !szSearch || !UtilCmpFileName( szFileNameT, szSearch ) ) )
			{
			Call( ErrERRCheck( JET_errBackupDirectoryNotEmpty ) );
			}
		}
	Call( err == JET_errFileNotFound ? JET_errSuccess : err );

	err = JET_errSuccess;

HandleError:
	/*	assert restored szDir
	/**/
	Assert( szDir[strlen(szDir)] != '*' );

	delete pffapi;

	return err;
	}


//	padding to add to account for log files
#define cBackupStatusPadding	0.05

/*	calculates initial backup size, and accounts for
/*	database growth during backup.
/**/
LOCAL VOID LGGetBackupSize( INST *pinst, FMP *pfmpNextToBackup, ULONG cPagesSoFar, ULONG *pcExpectedPages )
	{
	DBID	dbid;
	ULONG	cNewExpected;
	ULONG	cPagesLeft		= pfmpNextToBackup->PgnoMost();

	Assert( cPagesLeft > 0 );

	//	calculate sizes of databases to be backed up after this one
	for ( dbid = DBID( pfmpNextToBackup->Dbid() + 1 ); dbid < dbidMax; dbid++ )
		{
		const IFMP	ifmpT	= pinst->m_mpdbidifmp[dbid];
		if ( ifmpT >= ifmpMax )
			continue;
			
		const FMP	*pfmpT	= &rgfmp[ifmpT];
		if ( !pfmpT->FInUse() || !pfmpT->FLogOn() )
			continue;

		cPagesLeft += ULONG( pfmpT->PgnoLast() );
		}

	cNewExpected = cPagesSoFar + cPagesLeft;
	cNewExpected += (ULONG)( cBackupStatusPadding * cNewExpected );

	Assert( cNewExpected >= *pcExpectedPages );

	/*	check if grown since our last determination of backup size
	/**/
	if ( cNewExpected > *pcExpectedPages )
		*pcExpectedPages = cNewExpected;
	}



/*  backup read completion function
/**/
struct LGBK_ARGS
	{
	volatile ERR			err;
	volatile long*			pacRead;
	CAutoResetSignal*		pasigDone;
	BOOL					fCheckPagesOffset;
	};
	
void LGBKReadPagesCompleted(	const ERR err,
								IFileAPI *const pfapi,
								const QWORD ibOffset,
								const DWORD cbData,
								const BYTE* const pbData,
								LGBK_ARGS* const plgbkargs )
	{
	/*  we are not already in an error state
	/**/
	if ( plgbkargs->err >= 0 )
		{
		/*  there was an error on this read
		/**/
		if ( err < 0 )
			{
			/*  return the error
			/**/
			plgbkargs->err = err;
			}

		/*  there was no error
		/**/
		else
			{
			/*  verify the chunk's pages
			/**/
			for ( DWORD ib = 0; ib < cbData && plgbkargs->err >= 0; ib += g_cbPage )
				{
				ERR			errVerify	= JET_errSuccess;
				MessageId	msgid;
				DWORD		dwExpected;
				DWORD		dwActual;
				CPAGE		cpage;

				cpage.LoadPage( (void*)( pbData + ib ) );
				const ULONG ulChecksumExpected	= *( (LittleEndian<DWORD>*) ( pbData + ib ) );
				const ULONG ulChecksumActual	= UlUtilChecksum( pbData + ib, g_cbPage );

				/*  the checksum is invalid
				/**/
				if ( ulChecksumExpected != ulChecksumActual )
					{
					/*  the page is initialized
					/**/
					if ( cpage.Pgno() != pgnoNull || !plgbkargs->fCheckPagesOffset )
						{
						/*  read verification failure
						/**/
						errVerify	= ErrERRCheck( JET_errReadVerifyFailure );
						msgid		= (	plgbkargs->fCheckPagesOffset ?
											DATABASE_PAGE_CHECKSUM_MISMATCH_ID :
											PATCH_PAGE_CHECKSUM_MISMATCH_ID );
						dwExpected	= ulChecksumExpected;
						dwActual	= ulChecksumActual;
						}
					}

				/*  the checksum is valid and the page is initialized but has a bad
				/*  page number
				/**/
				else if (	cpage.Pgno() != pgnoNull &&
							plgbkargs->fCheckPagesOffset &&
							cpage.Pgno() != PgnoOfOffset( ibOffset + ib ) )
					{
					/*  read verification failure
					/**/
					errVerify	= ErrERRCheck( JET_errReadVerifyFailure );
					msgid		= DATABASE_PAGE_NUMBER_MISMATCH_ID;
					dwExpected	= PgnoOfOffset( ibOffset + ib );
					dwActual	= cpage.Pgno();
					}

				cpage.UnloadPage();

				//  there was a verification error

				if ( errVerify < JET_errSuccess )
					{
					//  fail the backup of this file with the error

					plgbkargs->err = errVerify;

					//  log the error
					
					const _TCHAR*	rgpsz[ 6 ];
					DWORD			irgpsz		= 0;
					_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
					_TCHAR			szOffset[ 64 ];
					_TCHAR			szLength[ 64 ];
					_TCHAR			szError[ 64 ];
					_TCHAR			szExpected[ 64 ];
					_TCHAR			szActual[ 64 ];

					CallS( pfapi->ErrPath( szAbsPath ) );
					_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibOffset + ib, ibOffset + ib );
					_stprintf( szLength, _T( "%u (0x%08x)" ), g_cbPage, g_cbPage );
					_stprintf( szError, _T( "%i (0x%08x)" ), errVerify, errVerify );
					_stprintf( szExpected, _T( "%u (0x%08x)" ), dwExpected, dwExpected );
					_stprintf( szActual, _T( "%u (0x%08x)" ), dwActual, dwActual );
			
					rgpsz[ irgpsz++ ]	= szAbsPath;
					rgpsz[ irgpsz++ ]	= szOffset;
					rgpsz[ irgpsz++ ]	= szLength;
					rgpsz[ irgpsz++ ]	= szError;
					rgpsz[ irgpsz++ ]	= szExpected;
					rgpsz[ irgpsz++ ]	= szActual;

					UtilReportEvent(	eventError,
										LOGGING_RECOVERY_CATEGORY,
										msgid,
										irgpsz,
										rgpsz );
					}
				}
			}
		}

	/*  we are the last outstanding read
	/**/
	if ( !AtomicDecrement( (long*)plgbkargs->pacRead ) )
		{
		/*  signal the issuer thread that all reads are done
		/**/
		plgbkargs->pasigDone->Set();
		}
	}

/*	read cpage into buffer ppageMin for backup.
 */

ERR LOG::ErrLGReadPages(
	IFileAPI *pfapi,
	BYTE *pbData,
	LONG pgnoStart,
	LONG pgnoEnd,
	BOOL fCheckPagesOffset )
	{
	ERR		err		= JET_errSuccess;
	/*  copy pages in aligned chunks of pages using groups of async reads
	/**/
	extern long g_cpgBackupChunk;
	
	PGNO pgnoMax = pgnoEnd + 1;

	volatile long acRead = 0;
	CAutoResetSignal asigDone( CSyncBasicInfo( _T( "ErrLGBKReadPages::asigDone" ) ) );

	LGBK_ARGS lgbkargs;
	lgbkargs.err = JET_errSuccess;
	lgbkargs.pacRead = &acRead;
	lgbkargs.pasigDone = &asigDone;
	lgbkargs.fCheckPagesOffset = fCheckPagesOffset;

	DWORD cReadIssue;
	cReadIssue = 0;
	PGNO pgno1, pgno2;
	for ( pgno1 = pgnoStart,
		  pgno2 = min( ( ( pgnoStart + cpgDBReserved - 1 ) / g_cpgBackupChunk + 1 ) * g_cpgBackupChunk - cpgDBReserved + 1, pgnoMax );
		  pgno1 < pgnoMax && lgbkargs.err >= 0;
		  pgno1 = pgno2,
		  pgno2 = min( pgno1 + g_cpgBackupChunk, pgnoMax ) )
		{
		/*  issue a read for the current aligned chunk of pages
		/**/
		QWORD ibOffset;
		ibOffset = OffsetOfPgno( pgno1 );

		DWORD cbData;
		cbData = ( pgno2 - pgno1 ) * g_cbPage;
		
		err = pfapi->ErrIORead(	ibOffset,
								cbData,
								pbData,
								IFileAPI::PfnIOComplete( LGBKReadPagesCompleted ),
								DWORD_PTR( &lgbkargs ) );
		if ( err < 0 && lgbkargs.err >= 0 )
			{
			lgbkargs.err = err;
			}
		pbData += cbData;

		cReadIssue++;
		
		}

	/*  wait for all issued reads to complete
	/**/
	if ( AtomicExchangeAdd( (long*)&acRead, cReadIssue ) + cReadIssue != 0 )
		{
		CallS( pfapi->ErrIOIssue() );
		asigDone.Wait();
		}

	/*  get the error code from the reads
	/**/
	err = ( err < 0 ? err : lgbkargs.err );
	return err;
	}
	
ERR LOG::ErrLGBKReadPages(
	IFMP ifmp,
	VOID *pvPageMin,
	INT	cpage,
	INT	*pcbActual
#ifdef DEBUG
	,BYTE	*pbLGDBGPageList
#endif
	)
	{
	ERR		err = JET_errSuccess;
	INT		cpageT;
	INT		ipageT;
	FMP		*pfmp = &rgfmp[ifmp];

	/*  determine if we are scrubbing the database
	/**/
	BOOL fScrub = m_fScrubDB;

	// we add a final page, the former patch file header
	BOOL fRoomForFinalHeaderPage = fFalse;

	/*  we are scrubbing the database
	/**/
	if ( fScrub )
		{
		/*  we are scrubbing the first page of the database
		/**/
		if ( rgfmp[ ifmp ].PgnoCopyMost() == 0 )
			{
			/*  init the scrub
			/**/
			const CHAR * rgszT[1];
			INT isz = 0;

			Assert( NULL == m_pscrubdb );
			m_pscrubdb = new SCRUBDB( ifmp );
			if( NULL == m_pscrubdb )
				{
				CallR( ErrERRCheck( JET_errOutOfMemory ) );
				}

			CallR( m_pscrubdb->ErrInit( m_ppibBackup, CUtilProcessProcessor() ) );

			m_ulSecsStartScrub = UlUtilGetSeconds();
			m_dbtimeLastScrubNew = rgfmp[ifmp].DbtimeLast();

			rgszT[isz++] = rgfmp[ifmp].SzDatabaseName();
			Assert( isz <= sizeof( rgszT ) / sizeof( rgszT[0] ) );
		
			UtilReportEvent( eventInformation, DATABASE_ZEROING_CATEGORY, DATABASE_ZEROING_STARTED_ID, isz, rgszT );
			}
		}

	/*	assume that database will be read in sets of cpage
	/*	pages.  Preread next cpage pages while the current
	/*	cpage pages are being read, and copied to caller
	/*	buffer.
	/*
	/*	preread next next cpage pages.  These pages should
	/*	be read while the next cpage pages are written to
	/*	the backup datababase file.
	/**/

	/*	read pages, which may have been preread, up to cpage but
	/*	not beyond last page at time of initiating backup.
	/**/
	Assert( pfmp->PgnoMost() >= pfmp->PgnoCopyMost() );
	cpageT = min( cpage, (INT)( pfmp->PgnoMost() - pfmp->PgnoCopyMost() ) );
	*pcbActual = 0;
	ipageT = 0;

#ifdef ELIMINATE_PATCH_FILE
	// we check if we have space for the last page
	fRoomForFinalHeaderPage =  ( cpageT < cpage );
#endif // ELIMINATE_PATCH_FILE

	/*  if we have no more pages to read, we're done
	/**/
	if ( cpageT == 0
		&& ( !fRoomForFinalHeaderPage || pfmp->FCopiedPatchHeader() ) )
		{
		Assert( pfmp->PgnoMost() == pfmp->PgnoCopyMost() );
		return JET_errSuccess;
		}

	if ( pfmp->PgnoCopyMost() == 0 )
		{
#ifdef ELIMINATE_PATCH_FILE

		UtilMemCpy( (BYTE *)pvPageMin, pfmp->Pdbfilehdr(), g_cbPage );
		DBFILEHDR *pdbfilehdr = (DBFILEHDR*)pvPageMin;
		BKINFO *pbkinfo = &pdbfilehdr->bkinfoFullCur;
		pbkinfo->le_lgposMark = m_lgposFullBackupMark;
		pbkinfo->logtimeMark = m_logtimeFullBackupMark;
		pbkinfo->le_genLow = m_lgenCopyMic;
		Assert( pbkinfo->le_genLow != 0 );
		Assert( pbkinfo->le_genHigh == 0 );

		pdbfilehdr->le_ulChecksum = UlUtilChecksum( (BYTE *)pdbfilehdr, g_cbPage );
		UtilMemCpy( (BYTE *) pvPageMin + g_cbPage, pdbfilehdr, g_cbPage );

#else // ELIMINATE_PATCH_FILE

		/* Copy header
		 */
		DBFILEHDR *pdbfilehdr = pfmp->Ppatchhdr();
		memcpy( pdbfilehdr, pfmp->Pdbfilehdr(), g_cbPage );
		BKINFO *pbkinfo = &pdbfilehdr->bkinfoFullCur;
		pbkinfo->le_lgposMark = m_lgposFullBackupMark;
		pbkinfo->logtimeMark = m_logtimeFullBackupMark;
		pbkinfo->le_genLow = m_lgenCopyMic;
		Assert( pbkinfo->le_genLow != 0 );
		Assert( pbkinfo->le_genHigh == 0 );

		pdbfilehdr->le_ulChecksum = UlUtilChecksum( (BYTE *)pdbfilehdr, g_cbPage );
		UtilMemCpy( (BYTE *)pvPageMin, pdbfilehdr, g_cbPage );
		UtilMemCpy( (BYTE *) pvPageMin + g_cbPage, pdbfilehdr, g_cbPage );

#endif // ELIMINATE_PATCH_FILE

		/*	we use first 2 pages buffer
		 */
		*pcbActual += g_cbPage * 2;
		ipageT += 2;
		Assert( 2 == cpgDBReserved );
		Assert( cpage >= ipageT );
		}

	const PGNO	pgnoStart	= pfmp->PgnoCopyMost() + 1;
	const PGNO	pgnoEnd		= pfmp->PgnoCopyMost() + ( cpageT - ipageT );

	if ( pgnoStart <= pgnoEnd  )
		{
		//	engage range lock for the region to copy	
		CallR( pfmp->ErrRangeLock( pgnoStart, pgnoEnd ) );

		// we will revert this on error after the RangeUnlock
		pfmp->SetPgnoCopyMost( pgnoEnd );
		}
	else
		{
		Assert( fRoomForFinalHeaderPage );
		}

	//  we will retry failed reads during backup in the hope of saving the
	//  backup set

	const TICK	tickStart	= TickOSTimeCurrent();
	const TICK	tickBackoff	= 100;
	const int	cRetry		= 16;

	int			iRetry		= 0;

#ifdef ELIMINATE_PATCH_FILE
	// if we have just the last page, avoid the loop
	// and the range locking part
	if ( pgnoStart > pgnoEnd )
		{
		Assert( fRoomForFinalHeaderPage );
		goto CopyFinalHeaderPage;
		}
#endif

	do
		{
		err = ErrLGReadPages( pfmp->Pfapi(), (BYTE *)pvPageMin + ( ipageT << g_shfCbPage ), pgnoStart, pgnoEnd, fTrue );

		if ( err < JET_errSuccess )
			{
			if ( iRetry < cRetry )
				{
				UtilSleep( ( iRetry + 1 ) * tickBackoff );
				}
			}
		else
			{
			if ( iRetry > 0 )
				{
				const _TCHAR*	rgpsz[ 5 ];
				DWORD			irgpsz		= 0;
				_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
				_TCHAR			szOffset[ 64 ];
				_TCHAR			szLength[ 64 ];
				_TCHAR			szFailures[ 64 ];
				_TCHAR			szElapsed[ 64 ];

				CallS( pfmp->Pfapi()->ErrPath( szAbsPath ) );
				_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), OffsetOfPgno( pgnoStart ), OffsetOfPgno( pgnoStart ) );
				_stprintf( szLength, _T( "%u (0x%08x)" ), ( pgnoEnd - pgnoStart + 1 ) * g_cbPage, ( pgnoEnd - pgnoStart + 1 ) * g_cbPage );
				_stprintf( szFailures, _T( "%i" ), iRetry );
				_stprintf( szElapsed, _T( "%g" ), ( TickOSTimeCurrent() - tickStart ) / 1000.0 );
		
				rgpsz[ irgpsz++ ]	= szAbsPath;
				rgpsz[ irgpsz++ ]	= szOffset;
				rgpsz[ irgpsz++ ]	= szLength;
				rgpsz[ irgpsz++ ]	= szFailures;
				rgpsz[ irgpsz++ ]	= szElapsed;

				UtilReportEvent(	eventError,
									LOGGING_RECOVERY_CATEGORY,
									TRANSIENT_READ_ERROR_DETECTED_ID,
									irgpsz,
									rgpsz );
				}
			}
		}
	while ( iRetry++ < cRetry && err < JET_errSuccess );

	/*  we are scrubbing the database and there was no error reading the pages
	/**/
	if ( fScrub && err >= JET_errSuccess )
		{
		/*  load all pages from the backup region into the cache so that they
		/*  can be scrubbed, skipping any uninitialized pages
		/**/
		PGNO pgnoScrubStart = 0xFFFFFFFF;
		PGNO pgnoScrubEnd	= 0x00000000;
		
		for ( PGNO pgno = pgnoStart; pgno <= pgnoEnd; pgno++ )
			{
			/*  get the raw page data
			/**/
			void* pv = (BYTE *)pvPageMin + ( pgno - pgnoStart + ipageT ) * g_cbPage;

			/*  get the pgno of this page from the page data
			/**/
			CPAGE cpage;
			cpage.LoadPage( pv );
			PGNO pgnoData = cpage.Pgno();
			cpage.UnloadPage();

			/*  this page is initialized
			/**/
			if ( pgnoData != pgnoNull )
				{
				/*  load this page data into the cache if not already cached
				/**/
				BFLatch bfl;
				if ( ErrBFWriteLatchPage( &bfl, ifmp, pgno, BFLatchFlags( bflfNoCached | bflfNew ) ) >= JET_errSuccess )
					{
					BFDirty( &bfl );
					UtilMemCpy( bfl.pv, pv, g_cbPage );
					BFWriteUnlatch( &bfl );
					}

				/*  we need to scrub this page eventually
				/**/
				pgnoScrubStart	= min( pgnoScrubStart, pgno );
				pgnoScrubEnd	= max( pgnoScrubEnd, pgno );
				}

			/*  this page is not initialized or we are on the last page
			/**/
			if ( pgnoData == pgnoNull || pgno == pgnoEnd )
				{
				/*  we have pages to scrub
				/**/
				if ( pgnoScrubStart <= pgnoScrubEnd )
					{
					/*  scrub these pages
					/**/
					err = m_pscrubdb->ErrScrubPages( pgnoScrubStart, pgnoScrubEnd - pgnoScrubStart + 1 );

					/*  reset scrub range
					/**/
					pgnoScrubStart	= 0xFFFFFFFF;
					pgnoScrubEnd	= 0x00000000;
					}
				}
			}

		/*  all pages had better be scrubbed!
		/**/
		Assert( pgnoScrubStart == 0xFFFFFFFF );
		Assert( pgnoScrubEnd == 0x00000000 );
		}

	if ( err < JET_errSuccess )
		{
		Assert ( pgnoStart > 0 );
		// we need to revert CopyMost on error
		pfmp->SetPgnoCopyMost( pgnoStart - 1 );
		}

	/*  disengage range lock for the region copied
	/**/
	pfmp->RangeUnlock( pgnoStart, pgnoEnd );

	Call( err );

	/*  update the read data count
	/**/
	*pcbActual += g_cbPage * ( cpageT - ipageT );

#ifdef ELIMINATE_PATCH_FILE
CopyFinalHeaderPage:
	if ( fRoomForFinalHeaderPage )
		{
		LGBKMakeDbTrailer( ifmp, (BYTE *)pvPageMin + *pcbActual);
		*pcbActual += g_cbPage;
		}
#endif

#ifdef DEBUG
	for ( PGNO pgnoCur = pfmp->PgnoCopyMost() - ( cpageT - ipageT ) + 1;
		ipageT < cpageT;
		ipageT++, pgnoCur++ )
		{
		if ( m_fDBGTraceBR > 1 && pbLGDBGPageList )
			{
			CPAGE cpage;
			cpage.LoadPage( (BYTE*) pvPageMin + g_cbPage * ipageT );
			sprintf(	reinterpret_cast<CHAR *>( pbLGDBGPageList ),
						"(%ld, %l64d) ",
						pgnoCur,
						cpage.Dbtime() );
			cpage.UnloadPage();
			pbLGDBGPageList += strlen( reinterpret_cast<CHAR *>( pbLGDBGPageList ) );
			}
		}
#endif

HandleError:
	if ( err < JET_errSuccess )
		{
		*pcbActual = 0;
		}

	/*  we just scrubbed the last page in the database
	/**/
	if ( fScrub && rgfmp[ ifmp ].PgnoCopyMost() == rgfmp[ ifmp ].PgnoMost() )
		{
		/*  term the scrub
		/**/
		err = m_pscrubdb->ErrTerm();
		
		const ULONG_PTR ulSecFinished 	= UlUtilGetSeconds();
		const ULONG_PTR ulSecs 			= ulSecFinished - m_ulSecsStartScrub;

		const CHAR * rgszT[16];
		INT isz = 0;

		CHAR	szSeconds[16];
		CHAR	szErr[16];
		CHAR	szPages[16];
		CHAR	szBlankPages[16];
		CHAR	szUnchangedPages[16];
		CHAR	szUnusedPages[16];
		CHAR	szUsedPages[16];
		CHAR	szDeletedRecordsZeroed[16];
		CHAR	szOrphanedLV[16];

	
		sprintf( szSeconds, "%"FMTSZ3264"d", ulSecs );
		sprintf( szErr, "%d", err );
		sprintf( szPages, "%d", m_pscrubdb->Scrubstats().cpgSeen );
		sprintf( szBlankPages, "%d", m_pscrubdb->Scrubstats().cpgUnused );
		sprintf( szUnchangedPages, "%d", m_pscrubdb->Scrubstats().cpgUnchanged );
		sprintf( szUnusedPages, "%d", m_pscrubdb->Scrubstats().cpgZeroed );
		sprintf( szUsedPages, "%d", m_pscrubdb->Scrubstats().cpgUsed );
		sprintf( szDeletedRecordsZeroed, "%d", m_pscrubdb->Scrubstats().cFlagDeletedNodesZeroed );
		sprintf( szOrphanedLV, "%d", m_pscrubdb->Scrubstats().cOrphanedLV );

		rgszT[isz++] = rgfmp[ifmp].SzDatabaseName();
		rgszT[isz++] = szSeconds;
		rgszT[isz++] = szErr;
		rgszT[isz++] = szPages;
		rgszT[isz++] = szBlankPages;
		rgszT[isz++] = szUnchangedPages;
		rgszT[isz++] = szUnusedPages;
		rgszT[isz++] = szUsedPages;
		rgszT[isz++] = szDeletedRecordsZeroed;
		rgszT[isz++] = szOrphanedLV;
		
		Assert( isz <= sizeof( rgszT ) / sizeof( rgszT[0] ) );
		UtilReportEvent( eventInformation, DATABASE_ZEROING_CATEGORY, DATABASE_ZEROING_STOPPED_ID, isz, rgszT );

		delete m_pscrubdb;
		m_pscrubdb = NULL;

		rgfmp[ifmp].SetDbtimeLastScrub( m_dbtimeLastScrubNew );
		LOGTIME logtimeScrub;
		LGIGetDateTime( &logtimeScrub );	
		rgfmp[ifmp].SetLogtimeScrub( logtimeScrub );
		}

	return err;
	}


/*	begin new log file and compute log backup parameters:
 *		m_lgenCopyMac = m_plgfilehdr->lGeneration;
 *		m_lgenCopyMic = fFullBackup ? set befor database copy : m_lgenDeleteMic.
 *		m_lgenDeleteMic = first generation in m_szLogFilePath
 *		m_lgenDeleteMac = current checkpoint, which may be several gen less than m_lgenCopyMac
 */
ERR LOG::ErrLGBKPrepareLogFiles(
	IFileSystemAPI *const	pfsapi,
	JET_GRBIT					grbit,
	CHAR						*szLogFilePath,
	CHAR						*szPathJetChkLog,
	CHAR						*szBackupPath )
	{
	ERR			err;
	CHECKPOINT	*pcheckpointT = NULL;
	LGPOS		lgposRecT;

	const BOOL	fFullBackup = ( 0 == grbit );
	const BOOL	fIncrementalBackup = ( JET_bitBackupIncremental == grbit );
	const BOOL	fSnapshotBackup = ( JET_bitBackupSnapshot == grbit );

	Assert ( 0 == grbit || JET_bitBackupIncremental == grbit || JET_bitBackupSnapshot == grbit );

	if ( fFullBackup )
		{
		CallR( ErrLGFullBackup( this, "", &lgposRecT ) );
		m_lgposFullBackup = lgposRecT;
		LGIGetDateTime( &m_logtimeFullBackup );
		}
	else if ( fIncrementalBackup )
		{
		CallR( ErrLGIncBackup( this, "", &lgposRecT ) );
		m_lgposIncBackup = lgposRecT;
		LGIGetDateTime( &m_logtimeIncBackup );
		}
	else
		{
		Assert ( fSnapshotBackup );
		// on snapshot we log at begin backup time
		Assert ( 0 != CmpLgpos ( &m_lgposSnapshotStart, &lgposMin) );

		// if SnapshotStart wasn't done, error out at this point
		for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			IFMP 	ifmp = m_pinst->m_mpdbidifmp[ dbid ];
			if ( ifmp >= ifmpMax )
				continue;

			FMP *pfmp = &rgfmp[ifmp];

			if ( pfmp->FInUse()
				&& pfmp->FLogOn()
				&& pfmp->FAttached()
				&& !pfmp->FInBackupSession()
				&& pfmp->FDuringSnapshot() )
					{
					CallR ( ErrERRCheck ( JET_errInvalidBackupSequence ) );
					}
			}

		// we log the end of snapshot as the db backup should be done by now
		CallR( ErrLGSnapshotStopBackup( this, &lgposRecT ) );
		m_lgposFullBackup = lgposRecT;
		LGIGetDateTime( &m_logtimeFullBackup );
		}


	while ( lgposRecT.lGeneration > m_plgfilehdr->lgfilehdr.le_lGeneration )
		{
		if ( m_fLGNoMoreLogWrite )
			{
			return( ErrERRCheck( JET_errLogWriteFail ) );
			}
		UtilSleep( cmsecWaitGeneric );
		}

	m_fBackupBeginNewLogFile = fTrue;

	/*	compute m_lgenCopyMac:
	/*	copy all log files up to but not including current log file
	/**/
	m_critLGFlush.Enter();
	Assert( m_lgenCopyMac == 0 );
	m_lgenCopyMac = m_plgfilehdr->lgfilehdr.le_lGeneration;
	Assert( m_lgenCopyMac != 0 );
	m_critLGFlush.Leave();
	Call( err );
			
	/*	set m_lgenDeleteMic
	/*	to first log file generation number.
	/**/
	Assert( m_lgenDeleteMic == 0 );
	Call ( ErrLGIGetGenerationRange( pfsapi, szLogFilePath, &m_lgenDeleteMic, NULL ) );
	if ( 0 == m_lgenDeleteMic )
		{
		Call ( ErrERRCheck( JET_errFileNotFound ) );
		}
	Assert( m_lgenDeleteMic != 0 );

	if ( fIncrementalBackup && szBackupPath )
		{
		LONG lgenT;
		/*	validate incremental backup against previous
		/*	full and incremenal backup.
		/**/
		Call ( ErrLGIGetGenerationRange( pfsapi, szBackupPath, NULL, &lgenT ) );
		if ( m_lgenDeleteMic > lgenT + 1 )
			{
			Call( ErrERRCheck( JET_errInvalidLogSequence ) );
			}
		}

	if ( fIncrementalBackup )
		{
		Call ( ErrLGCheckLogsForIncrementalBackup( m_lgenDeleteMic ) );
		}
	
	/*	set m_lgenDeleteMac to checkpoint log file
	/**/
	pcheckpointT = (CHECKPOINT *) PvOSMemoryPageAlloc( sizeof(CHECKPOINT), NULL );
	if ( pcheckpointT == NULL )
		CallR( ErrERRCheck( JET_errOutOfMemory ) );
	
	LGFullNameCheckpoint( pfsapi, szPathJetChkLog );
	Call( ErrLGReadCheckpoint( pfsapi, szPathJetChkLog, pcheckpointT, fFalse ) );
	Assert( m_lgenDeleteMac == 0 );
	m_lgenDeleteMac = pcheckpointT->checkpoint.le_lgposCheckpoint.le_lGeneration;
	Assert( m_lgenDeleteMac <= m_lgenCopyMac );

	// calculate delete range the databases considering the
	// databases that were not involved in the backup process
	//
	if ( fFullBackup || fSnapshotBackup )
		{
		for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			IFMP 	ifmp = m_pinst->m_mpdbidifmp[ dbid ];
			if ( ifmp >= ifmpMax )
				continue;

			FMP *pfmp = &rgfmp[ifmp];


			if ( pfmp->FInUse()
				&& pfmp->FLogOn()
				&& pfmp->FAttached()
				&& !pfmp->FInBackupSession() )
				{		
				Assert( !pfmp->FSkippedAttach() );
				Assert( !pfmp->FDeferredAttach() );

				ULONG genLastFullBackupForDb = (ULONG) pfmp->Pdbfilehdr()->bkinfoFullPrev.le_genHigh;
				ULONG genLastIncBackupForDb = (ULONG) pfmp->Pdbfilehdr()->bkinfoIncPrev.le_genHigh;
				
//				m_lgenDeleteMac = min ( m_lgenDeleteMac, max( genLastFullBackupForDb, genLastIncBackupForDb ) );			
				// see bug 148811: if one database not in this full backup has a differential backup
				// (which shows as an incremental for JET), we will truncate the logs. We don't want this
				// (the log truncation must be done using a full or incremental backup)
				m_lgenDeleteMac = min ( m_lgenDeleteMac, genLastFullBackupForDb );			
				}
			}
		m_lgenDeleteMic = min( m_lgenDeleteMac, m_lgenDeleteMic );
		}	
	Assert( m_lgenDeleteMac <= m_lgenCopyMac );

	/*	compute m_lgenCopyMic
	/**/
	if ( fFullBackup || fSnapshotBackup)
		{
		/*	m_lgenCopyMic set before database copy
		/**/
		Assert( m_lgenCopyMic != 0 );
		}
	else
		{
		Assert ( fIncrementalBackup );
		/*	copy all files that are deleted for incremental backup
		/**/
		Assert( m_lgenDeleteMic != 0 );
		m_lgenCopyMic = m_lgenDeleteMic;
		}
		
	Assert ( m_lgenDeleteMic <= m_lgenDeleteMac );
	Assert ( m_lgenCopyMic <= m_lgenCopyMac );

	// report start backup of log file
		{
		CHAR 			szFullLogNameCopyMic[IFileSystemAPI::cchPathMax];
		CHAR 			szFullLogNameCopyMac[IFileSystemAPI::cchPathMax];
		CHAR 			szFullLogFilePath[IFileSystemAPI::cchPathMax];
		CHAR 			szFNameT[IFileSystemAPI::cchPathMax];
		const CHAR *	rgszT[]			= { szFullLogNameCopyMic, szFullLogNameCopyMac };			
		const INT		cbFillBuffer	= 128;
		CHAR			szTrace[cbFillBuffer + 1];

		if ( JET_errSuccess > m_pinst->m_pfsapi->ErrPathComplete( m_szLogFilePath, szFullLogFilePath ) )
			{
			strcpy( szFullLogFilePath, "" );
			}

		LGSzFromLogId( szFNameT, m_lgenCopyMic );
		LGMakeName(
			m_pinst->m_pfsapi,
			szFullLogNameCopyMic,
			szFullLogFilePath,
			szFNameT,
			(CHAR *)szLogExt );

		Assert ( m_lgenCopyMic < m_lgenCopyMac );
		LGSzFromLogId( szFNameT, m_lgenCopyMac - 1 );
		LGMakeName(
			m_pinst->m_pfsapi,
			szFullLogNameCopyMac,
			szFullLogFilePath,
			szFNameT,
			(CHAR *)szLogExt );

		UtilReportEvent(
			eventInformation,
			LOGGING_RECOVERY_CATEGORY,
			BACKUP_LOG_FILES_START,
			2,
			rgszT,
			0,
			NULL,
			m_pinst );

		szTrace[ cbFillBuffer ] = '\0';
		_snprintf(
			szTrace,
			cbFillBuffer,
			"BACKUP PREPARE LOGS (copy 0x%05X-0x%05X, delete 0x%05X-0x%05X)",
			m_lgenCopyMic,
			m_lgenCopyMac - 1,
			m_lgenDeleteMic,
			m_lgenDeleteMac );
		Call( ErrLGTrace( m_ppibBackup, szTrace ) );
		}

HandleError:
	// UNDONE: if this function failed, we should stop the backup
	// not relay on the backup client behaviour and on or on the
	// fact that the code in log copy/truncate part will deal with
	// the state in which the backup is.
	
	OSMemoryPageFree( pcheckpointT );
	return err;
	}
	

ERR ErrLGCheckIncrementalBackup( INST *pinst )
	{
	DBID dbid;
	BKINFO *pbkinfo;
	
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP ifmp = pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;
		
		FMP	*pfmp = &rgfmp[ifmp];
		
		/*	make sure all the attached DB are qaulified for incremental backup.
		 */
		if ( pfmp->FAttached() )
			{
			Assert( pfmp->Pdbfilehdr() );
			Assert( !pfmp->FSkippedAttach() );
			Assert( !pfmp->FDeferredAttach() );
			pbkinfo = &pfmp->Pdbfilehdr()->bkinfoFullPrev;
			if ( pbkinfo->le_genLow == 0 )
				{
				const UINT	csz	= 1;
				const char	*rgszT[csz];
				rgszT[0] = pfmp->SzDatabaseName();
				UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
					DATABASE_MISS_FULL_BACKUP_ERROR_ID, csz, rgszT, 0, NULL, pinst );
				return ErrERRCheck( JET_errMissingFullBackup );
				}
			}
		}
	return JET_errSuccess;
	}
	

ERR LOG::ErrLGCheckLogsForIncrementalBackup( LONG lGenMinExisting )
	{
	DBID dbid;
	ERR			err = JET_errSuccess;
	
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP ifmp = m_pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;
		
		FMP	*pfmp = &rgfmp[ifmp];
		
		if ( pfmp->FAttached() )
			{
			Assert( pfmp->Pdbfilehdr() );
			Assert( !pfmp->FSkippedAttach() );
			Assert( !pfmp->FDeferredAttach() );

			LONG lGenMaxBackup = max ( 	pfmp->Pdbfilehdr()->bkinfoFullPrev.le_genHigh,
										pfmp->Pdbfilehdr()->bkinfoIncPrev.le_genHigh );
			
			if ( lGenMinExisting > lGenMaxBackup  + 1 )
				{
				const UINT 		csz = 1;
				const CHAR *	rgszT[csz];
				CHAR 			szFullLogName[IFileSystemAPI::cchPathMax];
				CHAR 			szFullLogFilePath[IFileSystemAPI::cchPathMax];
				CHAR 			szFNameT[IFileSystemAPI::cchPathMax];
				
				rgszT[0] = szFullLogName;
				
				CallR( m_pinst->m_pfsapi->ErrPathComplete( m_szLogFilePath, szFullLogFilePath ) );
				
				LGSzFromLogId( szFNameT, lGenMaxBackup + 1 );
				LGMakeName( m_pinst->m_pfsapi, szFullLogName, szFullLogFilePath, szFNameT, (CHAR *)szLogExt );
				
				UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
						BACKUP_LOG_FILE_MISSING_ERROR_ID, csz, rgszT, 0, NULL, m_pinst );
						
				return ErrERRCheck( JET_errMissingFileToBackup );
				}				
			}
		}
	return JET_errSuccess;
	}


/*	copies database files and logfile generations starting at checkpoint
 *  record to directory specified by the environment variable BACKUP.
 *  No flushing or switching of log generations is involved.
 *  The Backup call may be issued at any time, and does not interfere
 *  with the normal functioning of the system - nothing gets locked.
 *
 *  The database page is copied page by page in page sequence number. If
 *  a copied page is dirtied after it is copied, the page has to be
 *  recopied again. A flag is indicated if a database is being copied. If
 *  BufMan is writing a dirtied page and the page is copied, then BufMan
 *  has to copy the dirtied page to both the backup copy and the current
 *  database.
 *
 *  If the copy is later used to Restore without a subsequent log file, the
 *  restored database will be consistent and will include any transaction
 *  committed prior to backing up the very last log record; if there is a
 *  subsequent log file, that file will be used during Restore as a
 *  continuation of the backed-up log file.
 *
 *	PARAMETERS
 *
 *	RETURNS
 *		JET_errSuccess, or the following error codes:
 *			JET_errNoBackupDirectory
 *			JET_errFailCopyDatabase
 *			JET_errFailCopyLogFile
 *
 */
ERR ISAMAPI ErrIsamBackup( JET_INSTANCE jinst, const CHAR *szBackup, JET_GRBIT grbit, JET_PFNSTATUS pfnStatus )
	{
	INST * const	pinst	= (INST *)jinst;
	return pinst->m_plog->ErrLGBackup( pinst->m_pfsapi, szBackup, grbit, pfnStatus );
	}
	
ERR ErrLGIRemoveTempDir( IFileSystemAPI *const pfsapi, char *szT, char *szBackupPath, const char *szTempDir )
	{
	ERR err;
	
  	strcpy( szT, szBackupPath );
	strcat( szT, szTempDir );
	CallR( ErrLGDeleteAllFiles( pfsapi, szT ) );
  	strcpy( szT, szBackupPath );
	strcat( szT, szTempDir );
	err = pfsapi->ErrFolderRemove( szT );
	return err == JET_errInvalidPath ? JET_errSuccess : err;
	}
	
#define	cpageBackupBufferMost	256

#define JET_INVALID_HANDLE 	JET_HANDLE(-1)
ERR LOG::ErrLGBackupCopyFile( IFileSystemAPI *const pfsapi, const CHAR *szFileName, const CHAR *szBackup,  JET_PFNSTATUS pfnStatus, const BOOL fOverwriteExisting	 )
	{
	ERR				err 				= JET_errSuccess;
	JET_HANDLE		hfFile 				= JET_INVALID_HANDLE;
	QWORD 			qwFileSize 			= 0;
	QWORD 			ibOffset 			= 0;
	
	DWORD 			cbBuffer 			= cpageBackupBufferMost * g_cbPage;
	VOID * 			pvBuffer 			= NULL;
	IFileAPI *		pfapiBackupDest 	= NULL;

	// UNDONE: keep status

	{
	ULONG			ulFileSizeLow 		= 0;
	ULONG			ulFileSizeHigh 		= 0;
	CallR( ErrLGBKOpenFile( pfsapi, szFileName, &hfFile, &ulFileSizeLow, &ulFileSizeHigh, m_fBackupFull ) );
	qwFileSize = ( QWORD(ulFileSizeHigh) << 32) + QWORD(ulFileSizeLow);
	if ( 0 == ulFileSizeHigh )
		{
		cbBuffer = min( cbBuffer, ulFileSizeLow);
		}
	}

	
	pvBuffer = PvOSMemoryPageAlloc( cbBuffer, NULL );
	if ( pvBuffer == NULL )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	{
	CHAR	szDirT[ IFileSystemAPI::cchPathMax ];
	CHAR	szExtT[ IFileSystemAPI::cchPathMax ];
	CHAR	szFNameT[ IFileSystemAPI::cchPathMax ];
	CHAR	szBackupDest[ IFileSystemAPI::cchPathMax ];
	CHAR	szBackupPath[IFileSystemAPI::cchPathMax];

	CallS( pfsapi->ErrPathParse( szFileName, szDirT, szFNameT, szExtT ) );

	/*	backup directory
	/**/
	strcpy( szBackupPath, szBackup );
	OSSTRAppendPathDelimiter( szBackupPath, fTrue );

	LGMakeName( m_pinst->m_pfsapi, szBackupDest, szBackupPath, szFNameT, (CHAR *) szExtT );	

	Call( pfsapi->ErrFileCreate( szBackupDest, &pfapiBackupDest, fFalse, fFalse, fOverwriteExisting ) );
	}

	Assert ( pfapiBackupDest );

	while ( qwFileSize )
		{
		ULONG cbActual;

		if ( m_pinst->m_fTermInProgress )
			{
			Call ( ErrERRCheck( JET_errTermInProgress ) );
			}
		
		Call ( ErrLGBKReadFile( pfsapi, hfFile, pvBuffer, cbBuffer, &cbActual ));

		Call( pfapiBackupDest->ErrIOWrite( ibOffset, cbActual, (BYTE*)pvBuffer ) );
		
		ibOffset += QWORD(cbActual);
		qwFileSize -= QWORD(cbActual);
		}

	Assert ( JET_INVALID_HANDLE != hfFile );
	Call ( ErrLGBKCloseFile( hfFile ) );
	hfFile = JET_INVALID_HANDLE;
	Assert ( JET_errSuccess == err );

HandleError:

	if ( NULL != pvBuffer )
		{
		OSMemoryPageFree( pvBuffer );
		pvBuffer = NULL;		
		}
		
	if ( NULL != pfapiBackupDest )
		{
		delete pfapiBackupDest;
		pfapiBackupDest = NULL;
		}
		
	if ( JET_INVALID_HANDLE != hfFile )
		{
		(void) ErrLGBKCloseFile( hfFile );
		hfFile = JET_INVALID_HANDLE;
		}
	return err;	
	}

ERR LOG::ErrLGBackupPrepareDirectory( IFileSystemAPI *const pfsapi, const CHAR *szBackup, CHAR *szBackupPath, JET_GRBIT grbit )
	{
	ERR				err 			= JET_errSuccess;
	const BOOL		fFullBackup 	= !( grbit & JET_bitBackupIncremental );
	const BOOL		fBackupAtomic 	= ( grbit & JET_bitBackupAtomic );
	
	CHAR			szT[IFileSystemAPI::cchPathMax];
	CHAR			szFrom[IFileSystemAPI::cchPathMax];

	/*	backup directory
	/**/
	strcpy( szBackupPath, szBackup );
	OSSTRAppendPathDelimiter( szBackupPath, fTrue );
	if ( m_pinst->m_fCreatePathIfNotExist )
		{
		Call( ErrUtilCreatePathIfNotExist( pfsapi, szBackupPath, NULL ) );
		}

	/*	reconsist atomic backup directory
	/*	1)	if temp directory, delete temp directory
	/**/
	Call( ErrLGIRemoveTempDir( pfsapi, szT, szBackupPath, szTempDir ) );

	if ( fBackupAtomic )
		{
		/*	2)	if old and new directories, delete old directory
		/*	3)	if new directory, move new to old
		/*
		/*	Now we should have an empty direcotry, or a directory with
		/*	an old subdirectory with a valid backup.
		/*
		/*	4) make a temporary directory for the current backup.
		/**/
		err = ErrLGCheckDir( pfsapi, szBackupPath, (CHAR *)szAtomicNew );
		if ( err == JET_errBackupDirectoryNotEmpty )
			{
	  		strcpy( szT, szBackupPath );
			strcat( szT, szAtomicOld );
			OSSTRAppendPathDelimiter( szT, fTrue );
			Call( ErrLGDeleteAllFiles( pfsapi, szT ) );
	  		strcpy( szT, szBackupPath );
			strcat( szT, szAtomicOld );
			err = pfsapi->ErrFolderRemove( szT );
			Call( err == JET_errInvalidPath ? JET_errSuccess : err );

			strcpy( szFrom, szBackupPath );
			strcat( szFrom, (CHAR *)szAtomicNew );
			Call( pfsapi->ErrFileMove( szFrom, szT ) );
			}

		/*	if incremental, set backup directory to szAtomicOld
		/*	else create and set to szTempDir
		/**/
		if ( !fFullBackup )
			{
			/*	backup to old directory
			/**/
			strcat( szBackupPath, szAtomicOld );
			OSSTRAppendPathDelimiter( szBackupPath, fTrue );
			}
		else
			{
			strcpy( szT, szBackupPath );
			strcat( szT, szTempDir );
			err = pfsapi->ErrFolderCreate( szT );
			if ( err < 0 )
				{
				Call( ErrERRCheck( JET_errMakeBackupDirectoryFail ) );
				}

			/*	backup to temp directory
			/**/
			strcat( szBackupPath, szTempDir );
			}
		}
	else
		{
		if ( !fFullBackup )
			{
			/*	check for non-atomic backup directory empty
			/**/
			Call( ErrLGCheckDir( pfsapi, szBackupPath, (CHAR *)szAtomicNew ) );
			Call( ErrLGCheckDir( pfsapi, szBackupPath, (CHAR *)szAtomicOld ) );
			}
		else
			{
			/*	check for backup directory empty
			/**/
			Call( ErrLGCheckDir( pfsapi, szBackupPath, NULL ) );
			}
		}
		
	HandleError:
		return err;
		}


ERR LOG::ErrLGBackupPromoteDirectory( IFileSystemAPI *const pfsapi, const CHAR *szBackup,  CHAR *szBackupPath, JET_GRBIT grbit )
	{
	ERR				err 			= JET_errSuccess;
	const BOOL		fFullBackup 	= !( grbit & JET_bitBackupIncremental );
	const BOOL		fBackupAtomic 	= ( grbit & JET_bitBackupAtomic );
	
	//	for full backup, graduate temp backup to new backup and delete old backup.
	
	if ( !fBackupAtomic || !fFullBackup )
		return JET_errSuccess;

	CHAR			szFrom[IFileSystemAPI::cchPathMax];
	CHAR			szT[IFileSystemAPI::cchPathMax];
		
  	strcpy( szFrom, szBackupPath );

	/*	reset backup path
	/**/
	szBackupPath[strlen(szBackupPath) - strlen(szTempDir)] = '\0';

	strcpy( szT, szBackupPath );
	strcat( szT, (CHAR *)szAtomicNew );
	err = pfsapi->ErrFileMove( szFrom, szT );
	if ( JET_errFileNotFound == err )
		{
		err = JET_errSuccess;
		}
	Call( err );

	strcpy( szT, szBackupPath );
	strcat( szT, szAtomicOld );
	OSSTRAppendPathDelimiter( szT, fTrue );
	Call( ErrLGDeleteAllFiles( pfsapi, szT ) );
	strcpy( szT, szBackupPath );
	strcat( szT, szAtomicOld );
	
	err = pfsapi->ErrFolderRemove( szT );
	
	if ( JET_errInvalidPath == err )
		{
		err = JET_errSuccess;
		}
		
	HandleError:
		return err;
	}

ERR LOG::ErrLGBackupCleanupDirectory( IFileSystemAPI *const pfsapi, const CHAR *szBackup, CHAR *szBackupPath )
	{
	ERR			err = JET_errSuccess;

	if ( szBackup && szBackup[0] )
		{
		CHAR	szT[IFileSystemAPI::cchPathMax];
		
		strcpy( szBackupPath, szBackup );
		OSSTRAppendPathDelimiter( szBackupPath, fTrue );
		CallS( ErrLGIRemoveTempDir( pfsapi, szT, szBackupPath, szTempDir ) );
		}

	return err;
	}
		
ERR LOG::ErrLGBackup( IFileSystemAPI *const pfsapi, const CHAR *szBackup, JET_GRBIT grbit, JET_PFNSTATUS pfnStatus )
	{
	ERR			err = JET_errSuccess;

	BOOL		fFullBackup = !( grbit & JET_bitBackupIncremental );
	BOOL		fBackupAtomic = ( grbit & JET_bitBackupAtomic );

	ULONG		cPagesSoFar = 0;
	ULONG		cExpectedPages = 0;
	JET_SNPROG	snprog;
	BOOL		fShowStatus = fFalse;

	CHAR		szBackupPath[IFileSystemAPI::cchPathMax];

	unsigned long 			cInstanceInfo 	= 0;
	JET_INSTANCE_INFO * 	aInstanceInfo 	= NULL;
	JET_INSTANCE_INFO * 	pInstanceInfo 	= NULL;
	CHAR * 					szNames 		= NULL;

	if ( m_fLogDisabled )
		{
		return ErrERRCheck( JET_errLoggingDisabled );
		}

	if ( m_fLGNoMoreLogWrite )
		{
		Assert( fFalse );
		return ErrERRCheck( JET_errLogWriteFail );
		}

	if ( !fFullBackup && m_fLGCircularLogging )
		{
		return ErrERRCheck( JET_errInvalidBackup );
		}

	CallR( ErrLGBKBeginExternalBackup( pfsapi, ( fFullBackup ? 0 : JET_bitBackupIncremental ) ) );
	Assert ( m_fBackupInProgress );

	/*	if NULL backup directory then just delete log files
	/**/
	if ( szBackup == NULL || szBackup[0] == '\0' )
		{
		goto DeleteLogs;
		}

	Call ( ErrLGBackupPrepareDirectory( pfsapi, szBackup, szBackupPath, grbit ) );	
	if ( !fFullBackup )
		{
		goto CopyLogFiles;
		}

	/*	full backup
	/**/
	Assert( fFullBackup );

	/*	initialize status
	/**/
	if ( fShowStatus = (pfnStatus != NULL) )
		{
		snprog.cbStruct = sizeof(JET_SNPROG);
		snprog.cunitDone = 0;
		snprog.cunitTotal = 100;

		/*	status callback
		/**/
		(*pfnStatus)(0, JET_snpBackup, JET_sntBegin, &snprog);
		}
		
	Call ( ErrIsamGetInstanceInfo( &cInstanceInfo, &aInstanceInfo ) );

	// find the instance and backup all database file: edb + stm
	{
	pInstanceInfo = NULL;
	for ( unsigned long iInstanceInfo = 0; iInstanceInfo < cInstanceInfo && !pInstanceInfo; iInstanceInfo++)
		{
		if ( aInstanceInfo[iInstanceInfo].hInstanceId == (JET_INSTANCE)m_pinst )
			{
			pInstanceInfo = aInstanceInfo + iInstanceInfo;
			}
		}
	// we should find at least the instance in which we are running
	AssertRTL ( pInstanceInfo );

	for ( ULONG_PTR iDatabase = 0; iDatabase < pInstanceInfo->cDatabases; iDatabase++)
		{
		Assert ( pInstanceInfo->szDatabaseFileName );
		Assert ( pInstanceInfo->szDatabaseFileName[iDatabase] );
		Call ( ErrLGBackupCopyFile( pfsapi, pInstanceInfo->szDatabaseFileName[iDatabase], szBackupPath, pfnStatus ) );		

		Assert ( pInstanceInfo->szDatabaseSLVFileName );
		if ( pInstanceInfo->szDatabaseSLVFileName[iDatabase] )
			{
			Call ( ErrLGBackupCopyFile( pfsapi, pInstanceInfo->szDatabaseSLVFileName[iDatabase], szBackupPath, pfnStatus ) );		
			}
		}
	}
	/*	successful copy of all the databases */

CopyLogFiles:
	{
	ULONG 			cbNames;
	
	Call ( ErrLGBKGetLogInfo( pfsapi, NULL, 0, &cbNames, NULL, fFullBackup ) );	
	szNames = (CHAR *)PvOSMemoryPageAlloc( cbNames, NULL );
	if ( szNames == NULL )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	Call ( ErrLGBKGetLogInfo( pfsapi, szNames, cbNames, NULL, NULL, fFullBackup ) );	
	Assert ( szNames );
	}

	// now backup all files (patch and logs) in szNames
	CHAR *szNamesWalking;
	szNamesWalking = szNames;
	while ( *szNamesWalking )
		{
		Call ( ErrLGBackupCopyFile( pfsapi, szNamesWalking, szBackupPath, pfnStatus, fTrue ) );
		szNamesWalking += strlen( szNamesWalking ) + 1;
		}

	Call ( ErrLGBackupPromoteDirectory( pfsapi, szBackup, szBackupPath, grbit ) );

DeleteLogs:	
	Assert( err == JET_errSuccess );
	Call ( ErrLGBKTruncateLog(pfsapi) );

	/*	complete status update
	/**/
	if ( fShowStatus )
		{
		Assert( snprog.cbStruct == sizeof(snprog) && snprog.cunitTotal == 100 );
		snprog.cunitDone = 100;
		(*pfnStatus)(0, JET_snpBackup, JET_sntComplete, &snprog);
		}

HandleError:

	{
	ERR errT;
	errT = ErrIsamEndExternalBackup( (JET_INSTANCE)m_pinst, ( JET_errSuccess <= err )?JET_bitBackupEndNormal:JET_bitBackupEndAbort );
	if ( JET_errSuccess <= err )
		{
		err = errT;
		}		
	}
	
	if ( aInstanceInfo )
		{
		JetFreeBuffer( (char *)aInstanceInfo );
		aInstanceInfo = NULL;
		}

	if ( szNames )
		{
		OSMemoryPageFree( szNames );
		szNames = NULL;		
		}

	CallS ( ErrLGBackupCleanupDirectory( pfsapi, szBackup, szBackupPath ) );
		
	return err;	
	}


/*
 *	Restores databases from database backups and log generations.  Redoes
 *	log from latest checkpoint record. After the backed-up logfile is
 *  Restored, the initialization process continues with Redo of the current
 *  logfile as long as the generation numbers are contiguous. There must be a
 *  log file szJetLog in the backup directory, else the Restore process fails.
 *
 *	GLOBAL PARAMETERS
 *		m_szRestorePath (IN) 	pathname of the directory with backed-up files.
 *		lgposRedoFrom(OUT)	is the position (generation, logsec, displacement)
 *							of the last saved log record; Redo of the
 *							current logfile will continue from this point.
 *
 *	RETURNS
 *		JET_errSuccess, or error code from failing routine, or one
 *				of the following "local" errors:
 *				-AfterInitialization
 *				-errFailRestoreDatabase
 *				-errNoRestoredDatabases
 *				-errMissingJetLog
 *  FAILS ON
 *		missing szJetLog or System.mdb on backup directory
 *		noncontiguous log generation
 *
 *  SIDE EFFECTS:
 *		All databases may be changed.
 *
 *  COMMENTS
 *		this call is executed during the normal first JetInit call,
 *  	if the environment variable RESTORE is set. Subsequent to
 *		the successful execution of Restore,
 *		system operation continues normally.
 */
VOID LOG::LGRSTFreeRstmap( VOID )
	{
	if ( NULL != m_rgrstmap )
		{
		RSTMAP *prstmapCur = m_rgrstmap;
		RSTMAP *prstmapMax = m_rgrstmap + m_irstmapMac;
		
		while ( prstmapCur < prstmapMax )
			{
			if ( prstmapCur->szDatabaseName )
				OSMemoryHeapFree( prstmapCur->szDatabaseName );
			if ( prstmapCur->szNewDatabaseName )
				OSMemoryHeapFree( prstmapCur->szNewDatabaseName );
			if ( prstmapCur->szGenericName )
				OSMemoryHeapFree( prstmapCur->szGenericName );
#ifdef ELIMINATE_PATCH_FILE
#else
			if ( prstmapCur->szPatchPath )
				OSMemoryHeapFree( prstmapCur->szPatchPath );
#endif

			prstmapCur++;
			}
		OSMemoryHeapFree( m_rgrstmap );
		m_rgrstmap = NULL;
		}

	m_irstmapMac = 0;
	}
	
	
/*	initialize log path, restore log path, and check its continuity
/**/
ERR LOG::ErrLGRSTInitPath( IFileSystemAPI *const pfsapi, CHAR *szBackupPath, CHAR *szNewLogPath, CHAR *szRestorePath, CHAR *szLogDirPath )
	{
	ERR err;
	
	CallR( pfsapi->ErrPathComplete( szBackupPath == NULL ? "." : szBackupPath, szRestorePath ) );
	OSSTRAppendPathDelimiter( szRestorePath, fTrue );

	m_szLogCurrent = szRestorePath;

	CallR( pfsapi->ErrPathComplete( szNewLogPath, szLogDirPath ) );
	OSSTRAppendPathDelimiter( szLogDirPath, fTrue );

	return JET_errSuccess;
	}


/*	log restore checkpoint setup
/**/
ERR LOG::ErrLGRSTSetupCheckpoint( IFileSystemAPI *const pfsapi, LONG lgenLow, LONG lgenHigh, CHAR *szCurCheckpoint )
	{
	ERR			err;
	CHAR		szFNameT[IFileSystemAPI::cchPathMax];
	CHAR		szT[IFileSystemAPI::cchPathMax];
	LGPOS		lgposCheckpoint;

	//	UNDONE:	optimize to start at backup checkpoint

	/*	Set up *checkpoint* and related *system parameters*.
	 *	Read checkpoint file in backup directory. If does not exist, make checkpoint
	 *	as the oldest log files. Also set dbms_paramT as the parameter for the redo
	 *	point.
	 */

	/*  redo backeup logfiles beginning with first gen log file.
	/**/
	LGSzFromLogId( szFNameT, lgenLow );
	strcpy( szT, m_szRestorePath );
	strcat( szT, szFNameT );
	strcat( szT, szLogExt );
	Assert( strlen( szT ) <= sizeof( szT ) - 1 );
	Call( pfsapi->ErrFileOpen( szT, &m_pfapiLog ) );

	/*	read log file header
	/**/
	Call( ErrLGReadFileHdr( m_pfapiLog, m_plgfilehdr, fCheckLogID ) );
	m_pcheckpoint->checkpoint.dbms_param = m_plgfilehdr->lgfilehdr.dbms_param;

	lgposCheckpoint.lGeneration = lgenLow;
	lgposCheckpoint.isec = (WORD) m_csecHeader;
	lgposCheckpoint.ib = 0;
	m_pcheckpoint->checkpoint.le_lgposCheckpoint = lgposCheckpoint;

	Assert( sizeof( m_pcheckpoint->rgbAttach ) == cbAttach );
	UtilMemCpy( m_pcheckpoint->rgbAttach, m_plgfilehdr->rgbAttach, cbAttach );

	/*	delete the old checkpoint file
	/**/
	if ( szCurCheckpoint )
		{
		strcpy( szT, szCurCheckpoint );
		OSSTRAppendPathDelimiter( szT, fTrue );
		strcat( szT, m_szJet );
		strcat( szT, szChkExt );

		Assert ( NULL == m_pcheckpointDeleted );

		m_pcheckpointDeleted = (CHECKPOINT *) PvOSMemoryPageAlloc( sizeof( CHECKPOINT ), NULL );
		if ( NULL == m_pcheckpointDeleted )
			Call ( ErrERRCheck( JET_errOutOfMemory ) );
		
		err = ErrLGReadCheckpoint( pfsapi, szT, m_pcheckpointDeleted, fFalse );
		if ( err < JET_errSuccess )
			{
			OSMemoryPageFree ( (void *) m_pcheckpointDeleted );
			m_pcheckpointDeleted = NULL;
			
			if ( JET_errCheckpointFileNotFound == err )
				{
				err = JET_errSuccess;
				}
			else
				{
				Call ( err );
				}
			}
			

		CallSx(  pfsapi->ErrFileDelete( szT ), JET_errFileNotFound );

		strcpy( m_pinst->m_szSystemPath, szCurCheckpoint );
		}
	
HandleError:
	delete m_pfapiLog;
	m_pfapiLog = NULL;

	return err;
	}


/*	for log restore to build restore map RSTMAP
/**/
ERR LOG::ErrLGRSTBuildRstmapForRestore( VOID )
	{
	ERR				err			= JET_errSuccess;
	INT				irstmap		= 0;
	INT				irstmapMac	= 0;
	RSTMAP*			rgrstmap	= NULL;
	RSTMAP*			prstmap;
	CHAR			szSearch[IFileSystemAPI::cchPathMax];
	CHAR			szFileName[IFileSystemAPI::cchPathMax];
	CHAR			szFile[IFileSystemAPI::cchPathMax];
	CHAR			szT[IFileSystemAPI::cchPathMax];
	IFileFindAPI*	pffapi		= NULL;

	/*	build rstmap, scan all *.pat files and build RSTMAP
	 *	build generic name for search the destination. If szDest is null, then
	 *	keep szNewDatabase Null so that it can be copied backup to szOldDatabaseName.
	 */
	Assert( FOSSTRTrailingPathDelimiter( m_szRestorePath ) );
	Assert( strlen( m_szRestorePath ) + strlen( "*" ) + strlen( szPatExt ) + 1 < IFileSystemAPI::cchPathMax );

	strcpy( szSearch, m_szRestorePath );
	strcat( szSearch, "*" );
	strcat( szSearch, szPatExt );

	//	patch files are always on the OS file-system

	Call( m_pinst->m_pfsapi->ErrFileFind( szSearch, &pffapi ) );
	while ( ( err = pffapi->ErrNext() ) == JET_errSuccess )
		{
		/*	run out of rstmap entries, allocate more
		/**/
		if ( irstmap + 1 >= irstmapMac )
			{
			prstmap = static_cast<RSTMAP *>( PvOSMemoryHeapAlloc( sizeof(RSTMAP) * ( irstmap + 8 ) ) );
			if ( prstmap == NULL )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			memset( prstmap + irstmap, 0, sizeof( RSTMAP ) * 8 );
			if ( rgrstmap != NULL )
				{
				UtilMemCpy( prstmap, rgrstmap, sizeof(RSTMAP) * irstmap );
				OSMemoryHeapFree( rgrstmap );
				}
			rgrstmap = prstmap;
			irstmapMac += 8;
			}

		/*	keep resource db null for non-external restore.
		 *	Store generic name ( szFileName without .pat extention )
		 */
		Call( pffapi->ErrPath( szFileName ) );
		Call( m_pinst->m_pfsapi->ErrPathParse( szFileName, szT, szFile, szT ) );
		prstmap = rgrstmap + irstmap;
		if ( (prstmap->szGenericName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( szFile ) + 1 ) ) ) == NULL )
			Call( ErrERRCheck( JET_errOutOfMemory ) );
		strcpy( prstmap->szGenericName, szFile );
		prstmap->fSLVFile = fFalse;
		irstmap++;

		// fill an entry for the SLV file. If it will be missing, it's ok, we ignore the entry
		prstmap = rgrstmap + irstmap;
		if ( (prstmap->szGenericName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( szFile ) + 1 ) ) ) == NULL )
			Call( ErrERRCheck( JET_errOutOfMemory ) );
		strcpy( prstmap->szGenericName, szFile );
		prstmap->fSLVFile = fTrue;
		irstmap++;
		
		}
	Call( err == JET_errFileNotFound ? JET_errSuccess : err );

	m_irstmapMac = irstmap;
	m_rgrstmap = rgrstmap;

	delete pffapi;
	return JET_errSuccess;

HandleError:
	while ( rgrstmap && --irstmap >= 0 )
		{
		OSMemoryHeapFree( rgrstmap[ irstmap ].szGenericName );
		}
	OSMemoryHeapFree( rgrstmap );
	delete pffapi;
	return err;
	}


ERR ErrLGIPatchPage( PIB *ppib, PGNO pgno, IFMP ifmp, PATCH *ppatch )
	{
	ERR				err		= JET_errSuccess;
	BFLatch			bfl;
	IFileSystemAPI*	pfsapi	= PinstFromPpib( ppib )->m_pfsapi;
	CPAGE			cpage;

	Assert( NULL != rgfmp[ifmp].PfapiPatch() );

	//  write latch a new page to receive the patch page

	CallR( ErrBFWriteLatchPage( &bfl, ifmp, pgno, bflfNew ) );

	//  read the new page data in from the patch file

	QWORD ibOffset;
	ibOffset = OffsetOfPgno( ppatch->ipage + 1 );

	Call( rgfmp[ifmp].PfapiPatch()->ErrIORead( ibOffset, g_cbPage, (BYTE*)bfl.pv ) );
	cpage.LoadPage( bfl.pv );

	ULONG ulChecksumExpected;
	ULONG ulChecksumActual;
	ulChecksumExpected	= *( (LittleEndian<DWORD>*)bfl.pv );
	ulChecksumActual	= UlUtilChecksum( (BYTE*)bfl.pv, g_cbPage );
	
	if ( ulChecksumExpected != ulChecksumActual || pgno != cpage.Pgno() )
		{
		const _TCHAR*	rgpsz[ 6 ];
		DWORD			irgpsz		= 0;
		_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szOffset[ 64 ];
		_TCHAR			szLength[ 64 ];
		_TCHAR			szError[ 64 ];

		CallS( rgfmp[ifmp].PfapiPatch()->ErrPath( szAbsPath ) );
		_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibOffset, ibOffset );
		_stprintf( szLength, _T( "%u (0x%08x)" ), g_cbPage, g_cbPage );
		_stprintf( szError, _T( "%i (0x%08x)" ), JET_errReadVerifyFailure, JET_errReadVerifyFailure );

		rgpsz[ irgpsz++ ]	= szAbsPath;
		rgpsz[ irgpsz++ ]	= szOffset;
		rgpsz[ irgpsz++ ]	= szLength;
		rgpsz[ irgpsz++ ]	= szError;

		if ( pgno != cpage.Pgno() )
			{
			char	szPgnoExpected[ 64 ];
			char	szPgnoActual[ 64 ];

			sprintf( szPgnoExpected, "%u (0x%08x)", pgno, pgno );
			sprintf( szPgnoActual, "%u (0x%08x)", cpage.Pgno(), cpage.Pgno() );
	
			rgpsz[ irgpsz++ ]	= szPgnoExpected;
			rgpsz[ irgpsz++ ]	= szPgnoActual;

			UtilReportEvent(	eventError,
								LOGGING_RECOVERY_CATEGORY,
								PATCH_PAGE_NUMBER_MISMATCH_ID,
								irgpsz,
								rgpsz );
			}
		else
			{
			char	szChecksumExpected[ 64 ];
			char	szChecksumActual[ 64 ];

			sprintf( szChecksumExpected, "%u (0x%08x)", ulChecksumExpected, ulChecksumExpected );
			sprintf( szChecksumActual, "%u (0x%08x)", ulChecksumActual, ulChecksumActual );
	
			rgpsz[ irgpsz++ ]	= szChecksumExpected;
			rgpsz[ irgpsz++ ]	= szChecksumActual;

			UtilReportEvent(	eventError,
								LOGGING_RECOVERY_CATEGORY,
								PATCH_PAGE_CHECKSUM_MISMATCH_ID,
								irgpsz,
								rgpsz );
			}

		Call( ErrERRCheck( JET_errReadVerifyFailure ) );
		}
	BFDirty( &bfl );

HandleError:
	cpage.UnloadPage();
	BFWriteUnlatch( &bfl );
	return err;
	}


#ifdef ELIMINATE_PATCH_FILE
#else
VOID LOG::LGRSTPatchTerm()
	{
	INT	ippatchlst;

	if ( m_rgppatchlst == NULL )
		return;

	for ( ippatchlst = 0; ippatchlst < cppatchlstHash; ippatchlst++ )
		{
		PATCHLST	*ppatchlst = m_rgppatchlst[ippatchlst];

		while( ppatchlst != NULL )
			{
			PATCHLST	*ppatchlstNext = ppatchlst->ppatchlst;
			PATCH		*ppatch = ppatchlst->ppatch;

			while( ppatch != NULL )
				{
				PATCH *ppatchNext = ppatch->ppatch;

				OSMemoryHeapFree( ppatch );
				ppatch = ppatchNext;
				}

			OSMemoryHeapFree( ppatchlst );
			ppatchlst = ppatchlstNext;
			}
		}

	Assert( m_rgppatchlst != NULL );
	OSMemoryHeapFree( m_rgppatchlst );
	m_rgppatchlst = NULL;

	return;
	}
#endif	//	ELIMINATE_PATCH_FILE


#define cRestoreStatusPadding	0.10	// Padding to add to account for DB copy.

ERR LOG::ErrLGGetDestDatabaseName(
	IFileSystemAPI *const pfsapi,
	const CHAR *szDatabaseName,
	INT *pirstmap,
	LGSTATUSINFO *plgstat,
	const CHAR *szDatabaseNameIfSLV )
	{
	ERR		err;
	CHAR	szDirT[IFileSystemAPI::cchPathMax];
	CHAR	szFNameT[IFileSystemAPI::cchPathMax];
	CHAR	szExtT[IFileSystemAPI::cchPathMax];
	CHAR	szRestoreT[IFileSystemAPI::cchPathMax];
	CHAR	szT[IFileSystemAPI::cchPathMax];
	CHAR	*szNewDatabaseName;
	INT		irstmap;

	Assert( szDatabaseName );

	irstmap = IrstmapLGGetRstMapEntry( szDatabaseName, szDatabaseNameIfSLV );
	*pirstmap = irstmap;
	
	if ( irstmap < 0 )
		{
		return( ErrERRCheck( JET_errFileNotFound ) );
		}
#ifdef ELIMINATE_PATCH_FILE
	else if ( m_rgrstmap[irstmap].fDestDBReady )
		return JET_errSuccess;
#else
	else if ( m_rgrstmap[irstmap].fPatchSetup || m_rgrstmap[irstmap].fDestDBReady )
		return JET_errSuccess;
#endif

	/*	check if there is any database in the restore directory.
	 *	Make sure szFNameT is big enough to hold both name and extention.
	 */
	CallS( pfsapi->ErrPathParse( szDatabaseName, szDirT, szFNameT, szExtT ) );
	strcat( szFNameT, szExtT );

	/* make sure szRestoreT has enogh trailing space for the following function to use.
	 */
	strcpy( szRestoreT, m_szRestorePath );
	if ( ErrLGCheckDir( pfsapi, szRestoreT, szFNameT ) != JET_errBackupDirectoryNotEmpty )
		return( ErrERRCheck( JET_errFileNotFound ) );

	/*	goto next block, copy it back to working directory for recovery
	 */
	if ( m_fExternalRestore )
		{
		Assert( _stricmp( m_rgrstmap[irstmap].szDatabaseName, szDatabaseName ) == 0 );
		Assert( irstmap < m_irstmapMac );
		
		szNewDatabaseName = m_rgrstmap[irstmap].szNewDatabaseName;
		}
	else
		{
		CHAR		*szSrcDatabaseName;
		CHAR		szFullPathT[IFileSystemAPI::cchPathMax];

		/*	store source path in rstmap
		/**/
		if ( ( szSrcDatabaseName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( szDatabaseName ) + 1 ) ) ) == NULL )
			return ErrERRCheck( JET_errOutOfMemory );
		strcpy( szSrcDatabaseName, szDatabaseName );
		m_rgrstmap[irstmap].szDatabaseName = szSrcDatabaseName;

		/*	store restore path in rstmap
		/**/
		if ( m_szNewDestination[0] != '\0' )
			{
			if ( ( szNewDatabaseName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( m_szNewDestination ) + strlen( szFNameT ) + 1 ) ) ) == NULL )
				return ErrERRCheck( JET_errOutOfMemory );
			strcpy( szNewDatabaseName, m_szNewDestination );
			strcat( szNewDatabaseName, szFNameT );
			}
		else
			{
			if ( ( szNewDatabaseName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( szDatabaseName ) + 1 ) ) ) == NULL )
				return ErrERRCheck( JET_errOutOfMemory );
			strcpy( szNewDatabaseName, szDatabaseName );
			}
		m_rgrstmap[irstmap].szNewDatabaseName = szNewDatabaseName;

		/*	copy database if not external restore.
		 *	make database names and copy the database.
		 */
		CallS( pfsapi->ErrPathParse( szDatabaseName, szDirT, szFNameT, szExtT ) );
		strcpy( szT, m_szRestorePath );
		strcat( szT, szFNameT );

		if ( szExtT[0] != '\0' )
			{
			strcat( szT, szExtT );
			}

		CallR( ErrUtilPathExists( pfsapi, szT, szFullPathT ) );

		if ( _stricmp( szFullPathT, szNewDatabaseName ) != 0 )
			{
			CallR( pfsapi->ErrFileCopy( szT, szNewDatabaseName, fTrue ) );
 			}
			
#ifdef ELIMINATE_PATCH_FILE
		Assert( m_fSignLogSet );
		CallR( ErrLGCheckDBFiles( m_pinst, pfsapi, m_rgrstmap + irstmap, NULL, m_lGenLowRestore, m_lGenHighRestore ) );
#else
		LGIGetPatchName( m_pinst->m_pfsapi, szFullPathT, szNewDatabaseName, m_szRestorePath );
		Assert( m_fSignLogSet );
		CallR( ErrLGCheckDBFiles( m_pinst, pfsapi, m_rgrstmap + irstmap, szFullPathT, m_lGenLowRestore, m_lGenHighRestore ) );
#endif

		Assert( FLGRSTCheckDuplicateSignature( ) );		
		}

	/*	make patch name prepare to patch the database.
	/**/

#ifdef ELIMINATE_PATCH_FILE
#else
	CHAR	*sz;

	LGIGetPatchName( m_pinst->m_pfsapi, szT, szNewDatabaseName, m_szRestorePath );

	/*	store patch path in rstmap
	/**/
	if ( ( sz = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( szT ) + 1 ) ) ) == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	strcpy( sz, szT );
	m_rgrstmap[irstmap].szPatchPath = sz;
#endif

	m_rgrstmap[irstmap].fDestDBReady = fTrue;
	*pirstmap = irstmap;

	if ( plgstat != NULL )
		{
		JET_SNPROG	*psnprog = &plgstat->snprog;
		ULONG		cPercentSoFar;
		ULONG		cDBCopyEstimate;

		cDBCopyEstimate = max((ULONG)(plgstat->cGensExpected * cRestoreStatusPadding / m_irstmapMac), 1);
		plgstat->cGensExpected += cDBCopyEstimate;
		plgstat->cGensSoFar += cDBCopyEstimate;

		cPercentSoFar = (ULONG)( ( cDBCopyEstimate * 100 ) / plgstat->cGensExpected );
		Assert( cPercentSoFar > 0  &&  cPercentSoFar < 100 );
		Assert( cPercentSoFar <= ( cDBCopyEstimate * 100) / plgstat->cGensExpected );

		if ( cPercentSoFar > psnprog->cunitDone )
			{
			Assert( psnprog->cbStruct == sizeof(JET_SNPROG)  &&
					psnprog->cunitTotal == 100 );
			psnprog->cunitDone = cPercentSoFar;
			( *( plgstat->pfnStatus ) )( 0, JET_snpRestore, JET_sntProgress, psnprog );
			}
		}

	return JET_errSuccess;
	}


#ifdef ELIMINATE_PATCH_FILE
#else
/*	set new db path according to the passed rstmap
/**/
ERR LOG::ErrLGRSTPatchInit( VOID )
	{
	/*	set up a patch hash table and fill it up with the patch file
	/**/
	INT cbT = sizeof( PATCHLST * ) * cppatchlstHash;

	if ( ( m_rgppatchlst = (PATCHLST **) PvOSMemoryHeapAlloc( cbT ) ) == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	memset( m_rgppatchlst, 0, cbT );
	return JET_errSuccess;
	}
#endif


VOID LOG::LGIRSTPrepareCallback(
	IFileSystemAPI *const	pfsapi,
	LGSTATUSINFO				*plgstat,
	LONG						lgenHigh,
	LONG						lgenLow,
	JET_PFNSTATUS				pfn
	)
	{
	/*	get last generation in log dir directory.  Compare with last generation
	/*	in restore directory.  Take the higher.
	/**/
	if ( m_szLogFilePath && *m_szLogFilePath != '\0' )
		{
		LONG	lgenHighT;
		CHAR	szFNameT[IFileSystemAPI::cchPathMax];

		/*	check if it is needed to continue the log files in current
		/*	log working directory.
		/**/
		(void)ErrLGIGetGenerationRange( pfsapi, m_szLogFilePath, NULL, &lgenHighT );

		/*	check if edb.log exist, if it is, then add one more generation.
		/**/
		strcpy( szFNameT, m_szLogFilePath );
		strcat( szFNameT, m_szJetLog );
			
		if ( ErrUtilPathExists( pfsapi, szFNameT ) == JET_errSuccess )
			{
			lgenHighT++;
			}

		lgenHigh = max( lgenHigh, lgenHighT );

		Assert( lgenHigh >= m_pcheckpoint->checkpoint.le_lgposCheckpoint.le_lGeneration );
		}

	plgstat->cGensSoFar = 0;
	plgstat->cGensExpected = lgenHigh - lgenLow + 1;

	/*	If the number of generations is less than about 67%, then count sectors,
	/*	otherwise, just count generations.  We set the threshold at 67% because
	/*	this equates to about 1.5% per generation.  Any percentage higher than
	/*	this (meaning fewer generations) and we count sectors.  Any percentage
	/*	lower than this (meaning more generations) and we just count generations.
	/**/
	plgstat->fCountingSectors = (plgstat->cGensExpected <
			(ULONG)((100 - (cRestoreStatusPadding * 100)) * 2/3));

	/*	Granularity of status callback is 1%.
	/*	Assume we callback after every generation.  If there are 67
	/*	callbacks, this equates to 1.5% per generation.  This seems like a
	/*	good cutoff value.  So, if there are 67 callbacks or more, count
	/*	generations.  Otherwise, count bytes per generation.
	/**/
	plgstat->pfnStatus = pfn;
	plgstat->snprog.cbStruct = sizeof(JET_SNPROG);
	plgstat->snprog.cunitDone = 0;
	plgstat->snprog.cunitTotal = 100;

	(*(plgstat->pfnStatus))(0, JET_snpRestore, JET_sntBegin, &plgstat->snprog);
	}
		
ERR LOG::ErrLGRestore( IFileSystemAPI *const pfsapi, CHAR *szBackup, CHAR *szDest, JET_PFNSTATUS pfn )
	{
	ERR					err;
	CHAR				szBackupPath[IFileSystemAPI::cchPathMax];
	CHAR				szLogDirPath[cbFilenameMost + 1];
	BOOL				fLogDisabledSav;
	LONG				lgenLow;
	LONG				lgenHigh;
	LGSTATUSINFO		lgstat;
	LGSTATUSINFO		*plgstat = NULL;
	const CHAR			*rgszT[2];
	INT					irstmap;
	BOOL				fNewCheckpointFile;
	ULONG				cbSecVolumeSave;
	BOOL				fGlobalRepairSave = fGlobalRepair;

	Assert( !fGlobalRepair );

	if ( _stricmp( m_szRecovery, "repair" ) == 0 )
		{
		// If m_szRecovery is exactly "repair", then enable logging.  If anything
		// follows "repair", then disable logging.
		fGlobalRepair = fTrue;
		}

	strcpy( szBackupPath, szBackup );

	Assert( m_pinst->m_fSTInit == fSTInitDone || m_pinst->m_fSTInit == fSTInitNotDone );
	if ( m_pinst->m_fSTInit == fSTInitDone )
		{
		Error( ErrERRCheck( JET_errAfterInitialization ), ResetGlobalRepair );
		}

	if ( szDest )
		{
		if ( m_pinst->m_fCreatePathIfNotExist )
			{
			CHAR szT[IFileSystemAPI::cchPathMax];

			strcpy( szT, szDest );
			OSSTRAppendPathDelimiter( szT, fTrue );
			CallJ( ErrUtilCreatePathIfNotExist( pfsapi, szT, m_szNewDestination ), ResetGlobalRepair );
			}
		else
			{
			CallJ( pfsapi->ErrPathComplete( szDest, m_szNewDestination ), ResetGlobalRepair );
			OSSTRAppendPathDelimiter( m_szNewDestination, fTrue );
			}
		}
	else
		m_szNewDestination[0] = '\0';

	m_fSignLogSet = fFalse;

	//	disable the sector-size checks

//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//	---** TEMPORARY FIX **---
{
	CHAR rgchFullName[IFileSystemAPI::cchPathMax];
	if ( pfsapi->ErrPathComplete( m_szLogFilePath, rgchFullName ) == JET_errInvalidPath )
		{
		const CHAR	*szPathT[1] = { m_szLogFilePath };
		UtilReportEvent(
			eventError,
			LOGGING_RECOVERY_CATEGORY,
			FILE_NOT_FOUND_ERROR_ID,
			1, szPathT );
		CallJ( ErrERRCheck( JET_errFileNotFound ), ResetGlobalRepair );
		}

	CallJ( pfsapi->ErrFileAtomicWriteSize( rgchFullName, (DWORD*)&m_cbSecVolume ), ResetGlobalRepair );
}

	cbSecVolumeSave = m_cbSecVolume;
//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//	m_cbSecVolume = ~(ULONG)0;

	//	use the right log file size for restore

	Assert( m_pinst->m_fUseRecoveryLogFileSize == fFalse );
	m_pinst->m_fUseRecoveryLogFileSize = fTrue;

	CallJ( ErrLGRSTInitPath( pfsapi, szBackupPath, m_szLogFilePath, m_szRestorePath, szLogDirPath ), ReturnError );
	CallJ ( ErrLGIGetGenerationRange( pfsapi, m_szRestorePath, &lgenLow, &lgenHigh ), ReturnError );
	Assert( ( lgenLow > 0 && lgenHigh >= lgenLow ) || ( 0 == lgenLow && 0 == lgenHigh ) );

	if ( 0 == lgenLow || 0 == lgenHigh )
		{
	
		//	we didn't find anything in the given restore path
		//	check the szAtomicNew subdirectory (what the hell is this?)

		OSSTRAppendPathDelimiter( szBackupPath, fTrue );
		err = ErrLGCheckDir( pfsapi, szBackupPath, (CHAR *)szAtomicNew );
		if ( err == JET_errBackupDirectoryNotEmpty )
			{
			strcat( szBackupPath, (CHAR *)szAtomicNew );
			CallJ( ErrLGRSTInitPath( pfsapi, szBackupPath, m_szLogFilePath, m_szRestorePath, szLogDirPath ), ReturnError );
			CallJ ( ErrLGIGetGenerationRange( pfsapi, m_szRestorePath, &lgenLow, &lgenHigh ), ReturnError );
			Assert( ( lgenLow > 0 && lgenHigh >= lgenLow ) || ( 0 == lgenLow && 0 == lgenHigh ) );
			}
		CallJ( err, ReturnError );
		}

	if ( 0 == lgenLow || 0 == lgenHigh )
		{

		//	we didn't find anything in the NEW restore path
		//	check the szAtomicOld subdirectory (what the hell is this?)

		OSSTRAppendPathDelimiter( szBackupPath, fTrue );
		err = ErrLGCheckDir( pfsapi, szBackupPath, (CHAR *) szAtomicOld );
 		if ( err == JET_errBackupDirectoryNotEmpty )
			{
			strcat( szBackupPath, szAtomicOld );
			CallJ( ErrLGRSTInitPath( pfsapi, szBackupPath, m_szLogFilePath, m_szRestorePath, szLogDirPath ), ReturnError );
			CallJ ( ErrLGIGetGenerationRange( pfsapi, m_szRestorePath, &lgenLow, &lgenHigh ), ReturnError );
			Assert( ( lgenLow > 0 && lgenHigh >= lgenLow ) || ( 0 == lgenLow && 0 == lgenHigh ) );
			}
		CallJ( err, ReturnError );
		}

	if ( 0 == lgenLow || 0 == lgenHigh )
		{

		//	we didn't find any log file anywhere -- error out

		Error( ErrERRCheck( JET_errFileNotFound ), ReturnError );
		}

	Assert( lgenLow > 0 );
	Assert( lgenHigh >= lgenLow );
	CallJ( ErrLGRSTCheckSignaturesLogSequence( pfsapi, m_szRestorePath, szLogDirPath, lgenLow, lgenHigh, NULL, 0 ), ReturnError );

	Assert( strlen( m_szRestorePath ) < sizeof( m_szRestorePath ) - 1 );
	Assert( strlen( szLogDirPath ) < sizeof( szLogDirPath ) - 1 );
	Assert( m_szLogCurrent == m_szRestorePath );

//	CallR( FMP::ErrFMPInit() );

	fLogDisabledSav = m_fLogDisabled;
	m_fHardRestore = fTrue;
	m_fRestoreMode = fRestorePatch;
	m_fLogDisabled = fFalse;
	m_fAbruptEnd = fFalse;

	/*  initialize log manager and set working log file path
	/**/
	CallJ( ErrLGInit( pfsapi, &fNewCheckpointFile ), TermFMP );

	rgszT[0] = m_szRestorePath;
	rgszT[1] = szLogDirPath;
	UtilReportEvent( eventInformation, LOGGING_RECOVERY_CATEGORY, START_RESTORE_ID, 2, rgszT );

	/*	all saved log generation files, database backups
	/*	must be in m_szRestorePath.
	/**/
	Call( ErrLGRSTSetupCheckpoint( pfsapi, lgenLow, lgenHigh, NULL ) );
		
	m_lGenLowRestore = lgenLow;
	m_lGenHighRestore = lgenHigh;

	/*	prepare for callbacks
	/**/
	if ( pfn != NULL )
		{
		plgstat = &lgstat;
		LGIRSTPrepareCallback( pfsapi, plgstat, lgenHigh, lgenLow, pfn );
		}
	Assert( m_szLogCurrent == m_szRestorePath );

	Call( ErrLGRSTBuildRstmapForRestore( ) );

	/*	make sure all the patch files have enough logs to replay
	/**/
	for ( irstmap = 0; irstmap < m_irstmapMac; irstmap++ )
		{
		/*	Open patch file and check its minimum requirement for full backup.
		 */
		CHAR *szNewDatabaseName = m_rgrstmap[irstmap].szNewDatabaseName;

		if ( !szNewDatabaseName )
			continue;
			
#ifdef ELIMINATE_PATCH_FILE
		Assert( m_fSignLogSet );
		err = ErrLGCheckDBFiles( m_pinst, pfsapi, m_rgrstmap + irstmap, NULL, lgenLow, lgenHigh );
#else
		CHAR	szRestPath[ IFileSystemAPI::cchPathMax ];
		LGIGetPatchName( m_pinst->m_pfsapi, szRestPath, szNewDatabaseName, m_szRestorePath );
		
		Assert( m_fSignLogSet );
		err = ErrLGCheckDBFiles( m_pinst, pfsapi, m_rgrstmap + irstmap, szRestPath, lgenLow, lgenHigh );
#endif

		// we don't check streaming file header during backup
		// UNDONE: maybe it is possible to check this, now that there are supposed to be in sync
		if ( wrnSLVDatabaseHeader == err )
			{
			err = JET_errSuccess;
			continue;
			}
			
		Call( err );
		}

	// check that there are no databases with same signature
	Assert ( FLGRSTCheckDuplicateSignature( ) );

	/*	adjust fmp according to the restore map.
	/**/
	Assert( m_fExternalRestore == fFalse );

#ifdef ELIMINATE_PATCH_FILE
#else
	Call( ErrLGRSTPatchInit( ) );
#endif

	/*	do redo according to the checkpoint, dbms_params, and rgbAttach
	/*	set in checkpointGlobal.
	/**/
	Assert( m_szLogCurrent == m_szRestorePath );
	m_errGlobalRedoError = JET_errSuccess;
	Call( ErrLGRRedo( pfsapi, m_pcheckpoint, plgstat ) );

	//	we should be using the right log file size now
	
	Assert( m_pinst->m_fUseRecoveryLogFileSize == fFalse );

	//	sector-size checking should now be on

	Assert( m_cbSecVolume != ~(ULONG)0 );
	Assert( m_cbSecVolume == m_cbSec );

	//	update saved copy
	
	cbSecVolumeSave = m_cbSecVolume;

	if ( plgstat )
		{
		lgstat.snprog.cunitDone = lgstat.snprog.cunitTotal;		//lint !e644
		(*lgstat.pfnStatus)( 0, JET_snpRestore, JET_sntComplete, &lgstat.snprog );
		}

HandleError:

#ifdef ELIMINATE_PATCH_FILE
#else
		//  UNDONE: if the DetachDb was redone during recover (the soft recover part)
		// we don't have the dbid in m_mpdbidifmp and we don't delete the patch
		// file for it. TODO: delete the patch file in ResetFMP
		// anyway, DELETE_PATCH_FILES is dot define so we don't delete those patch files
		// at this level but only in ESEBACK2, on restore without error
		{
		/*	delete .pat files
		/**/
		for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			IFMP ifmp = m_pinst->m_mpdbidifmp[ dbid ];
			if ( ifmp >= ifmpMax )
				continue;
			
			FMP *pfmpT = &rgfmp[ifmp];

			if ( pfmpT->SzPatchPath() )
				{
				delete pfmpT->PfapiPatch();
				pfmpT->SetPfapiPatch( NULL );
#ifdef DELETE_PATCH_FILES
				CallSx( m_pinst->m_pfsapi->ErrFileDelete( pfmpT->SzPatchPath() ), JET_errFileNotFound );
#endif
				OSMemoryHeapFree( pfmpT->SzPatchPath() );
				pfmpT->SetSzPatchPath( NULL );
				}
			}
		}

	/*	delete the patch hash table
	/**/
	LGRSTPatchTerm();

#endif	//	ELIMINATE_PATCH_FILE

	/*	delete restore map
	/**/

	CallSx( m_pinst->m_pfsapi->ErrFileDelete( (CHAR *)szRestoreMap ), JET_errFileNotFound );

	LGRSTFreeRstmap( );

	if ( err < 0  &&  m_pinst->m_fSTInit != fSTInitNotDone )
		{
		Assert( m_pinst->m_fSTInit == fSTInitDone );
		CallS( m_pinst->ErrINSTTerm( termtypeError ) );
		}

//	CallS( ErrLGTerm( pfsapi, err >= JET_errSuccess ) );
	CallS( ErrLGTerm( pfsapi, fFalse ) );

TermFMP:	
//	FMP::Term( );

	m_fHardRestore = fFalse;
	Assert ( fSnapshotNone == m_fSnapshotMode || fSnapshotAfter == m_fSnapshotMode );
	m_fSnapshotMode = fSnapshotNone;
	m_lgposSnapshotStart = lgposMin;
	
	Assert( fRestorePatch == m_fRestoreMode || fRestoreRedo == m_fRestoreMode );
	m_fRestoreMode = fRecoveringNone;

	/*	reset initialization state
	/**/
	m_pinst->m_fSTInit = err >= JET_errSuccess ? fSTInitNotDone : fSTInitFailed;

	if ( err != JET_errSuccess && !FErrIsLogCorruption( err ) )
		{
		UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, RESTORE_DATABASE_FAIL_ID, err );
		}
	else
		{
		if ( fGlobalRepair && m_errGlobalRedoError != JET_errSuccess )
			err = ErrERRCheck( JET_errRecoveredWithErrors );
		}
	UtilReportEvent( eventInformation, LOGGING_RECOVERY_CATEGORY, STOP_RESTORE_ID, 0, NULL );

	m_fSignLogSet = fFalse;

	m_fLogDisabled = fLogDisabledSav;

ReturnError:
	m_cbSecVolume = cbSecVolumeSave;
	m_pinst->m_fUseRecoveryLogFileSize = fFalse;

ResetGlobalRepair:
	fGlobalRepair = fGlobalRepairSave;
	return err;
	}

ERR ISAMAPI ErrIsamRestore( JET_INSTANCE jinst, CHAR *szBackup, CHAR *szDest, JET_PFNSTATUS pfn )
	{
	ERR			err;
	DBMS_PARAM	dbms_param;
//	LGBF_PARAM	lgbf_param;
	INST		*pinst = (INST *)jinst;
	
	//	Save the configuration
	
	pinst->SaveDBMSParams( &dbms_param );
//	LGSaveBFParams( &lgbf_param );
	
	err = pinst->m_plog->ErrLGRestore( pinst->m_pfsapi, szBackup, szDest, pfn );
	
	pinst->RestoreDBMSParams( &dbms_param );
//	LGRestoreBFParams( &lgbf_param );

	//	Uninitialize the global variables, if not released yet.
	
	Assert( pinst );
	
	return err;
	}


#ifdef DEBUG
VOID DBGBRTrace( CHAR *sz )
	{
	DBGprintf( "%s", sz );
	}
#endif


#ifdef ELIMINATE_PATCH_FILE
#else

//	build in-memory structure for restore to use. The structure
//	is to keep track of the patch pages in the patch file and can
//	be quickly searched when needed during restore.

ERR LOG::ErrLGPatchDatabase(
	IFileSystemAPI *const pfsapi,
	IFMP ifmp,
	DBID dbid )
	{
	ERR				err = JET_errSuccess;
	IFileAPI		*pfapiDatabase = NULL;
	IFileAPI		*pfapiPatch = NULL;
	PGNO			pgnoT;
	BYTE			*pbPageCache = NULL;
	PGNO			pgnoMost;
	INT				ipage;
	CPAGE			cpage;

	CHAR			*szDatabase = rgfmp[ifmp].SzDatabaseName();
	Assert ( szDatabase );
	
	const INT 		irstmap = IrstmapSearchNewName( szDatabase ) ;
	Assert ( 0 <= irstmap );
	
	CHAR			*szPatch = m_rgrstmap[irstmap].szPatchPath;


	// on snapshot restore, we don't have a patch file
	if ( fSnapshotNone != m_fSnapshotMode )
		{
		return JET_errSuccess;
		}
		
	//	open the patch file

	Assert( NULL != szPatch );
	err = m_pinst->m_pfsapi->ErrFileOpen( szPatch, &pfapiPatch, fTrue );
	if ( JET_errFileNotFound == err )
		{
		//	patch file should always exist
		err = ErrERRCheck( JET_errPatchFileMissing );
		}
	CallR( err );

#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];

		sprintf( sz, "     Apply patch file %s\n", szPatch );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif

	QWORD cbPatchFile;
	// just opened the file, so the file size must be correctly buffered
	Call( pfapiPatch->ErrSize( &cbPatchFile ) );

	QWORD ibPatchFile;
	ibPatchFile = QWORD( cpgDBReserved ) * g_cbPage;

#ifdef ELIMINATE_PAGE_PATCHING
	if ( ibPatchFile != cbPatchFile )
		{
		//	should be impossible
		EnforceSz( fFalse, "Patching no longer supported." );
		Call( ErrERRCheck( JET_errBadPatchPage ) );
		}
#endif

	//	allocate a page

	pbPageCache = (BYTE *)PvOSMemoryPageAlloc( g_cbPage*cpageBackupBufferMost, NULL );
	if ( pbPageCache == NULL )
		Call( ErrERRCheck( JET_errOutOfMemory ) );

	//	Cache first run of pages
	QWORD ibCacheEnd;
	ibCacheEnd = min( g_cbPage*cpageBackupBufferMost, cbPatchFile );
	Assert( ibCacheEnd >= 0 );
	Call( ErrLGReadPages( pfapiPatch, pbPageCache + ibPatchFile, PgnoOfOffset( ibPatchFile ), PgnoOfOffset( ibCacheEnd ) - 1, fFalse ) );
		
	//	open database file

	Call( pfsapi->ErrFileOpen( szDatabase, &pfapiDatabase ) );

	//	find out database size.

	QWORD cbDatabaseFile;
	Call( pfapiDatabase->ErrSize( &cbDatabaseFile ) );
	if ( cbDatabaseFile == 0 || cbDatabaseFile % g_cbPage != 0 )
		{
		const UINT	csz = 1;
		const CHAR *rgszT[csz];
		
		rgszT[0] = szDatabase;
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
			BAD_BACKUP_DATABASE_SIZE, csz, rgszT, 0, NULL, m_pinst );
		Call( ErrERRCheck( JET_errBadBackupDatabaseSize ) );
		}

	// Subtract cpgDBReserved to compensate for adding it on in ErrIsamOpenFile().

	pgnoMost = (ULONG)( cbDatabaseFile / g_cbPage ) - cpgDBReserved;

	//	read each patch file page and write it to
	//	database file according to page number.

	ipage = -1;
	while ( ibPatchFile < cbPatchFile )
		{
		PATCHLST **pppatchlst;
		PATCH	**pppatch;
		PATCH	*ppatch;

		if ( ibPatchFile == ibCacheEnd )
			{
			Assert( cbPatchFile > ibCacheEnd );
			Assert( 0 == (ibCacheEnd % cpageBackupBufferMost*g_cbPage) );
			ibCacheEnd += cpageBackupBufferMost*g_cbPage;
			if ( ibCacheEnd > cbPatchFile )
				{
				ibCacheEnd = cbPatchFile;
				}
			Call( ErrLGReadPages( pfapiPatch, pbPageCache, PgnoOfOffset( ibPatchFile ), PgnoOfOffset( ibCacheEnd ) - 1, fFalse ) );
			}
		else
			{
			Assert( ibPatchFile < ibCacheEnd );
			}

		cpage.LoadPage( pbPageCache + ( ibPatchFile % ( g_cbPage * cpageBackupBufferMost ) ) );

		ibPatchFile += g_cbPage;
		ipage++;

		pgnoT = cpage.Pgno();

		//	If the patched page is greater than the backup database
		//	size, then we need to grow the database size at least
		//	the patched db size.

		if ( pgnoT > pgnoMost )
			{
			//	pgnoT + 1 to get to the end of page

			cbDatabaseFile = OffsetOfPgno( pgnoT + 1 );
			
			//	need to grow the database size
			Assert( PinstFromIfmp( ifmp )->FRecovering() );
			Call( pfapiDatabase->ErrSetSize( cbDatabaseFile ) );

			//	set new database size

			pgnoMost = pgnoT;
			}
		
		pppatchlst = &m_rgppatchlst[ IppatchlstHash( pgnoT, dbid ) ];

		//	Find the corresponding hash entry for patch list. If not found
		//	allocate an entry and put into the hash table.

		while ( *pppatchlst != NULL &&
				( (*pppatchlst)->pgno != pgnoT ||
				  (*pppatchlst)->dbid != dbid ) )
			pppatchlst = &(*pppatchlst)->ppatchlst;

		if ( *pppatchlst == NULL )
			{
			//	Not found, allocate an entry.

			PATCHLST *ppatchlst;
			
			if ( ( ppatchlst = static_cast<PATCHLST *>( PvOSMemoryHeapAlloc( sizeof( PATCHLST ) ) ) ) == NULL )
				Call( ErrERRCheck( JET_errOutOfMemory ) );
			ppatchlst->ppatch = NULL;
			ppatchlst->dbid = dbid;
			ppatchlst->pgno	= pgnoT;
			ppatchlst->ppatchlst = *pppatchlst;
			*pppatchlst = ppatchlst;
			}

		//	For the given patch list, put the patch into the list in time order.

		pppatch = &(*pppatchlst)->ppatch;
		while ( *pppatch != NULL && (*pppatch)->dbtime < cpage.Dbtime() )
			pppatch = &(*pppatch)->ppatch;

		if ( ( ppatch = static_cast<PATCH *>( PvOSMemoryHeapAlloc( sizeof( PATCH ) ) ) ) == NULL )
			Call( ErrERRCheck( JET_errOutOfMemory ) );

		ppatch->dbtime = cpage.Dbtime();
		ppatch->ipage = ipage;

		//	Hook it up to the patch list

		ppatch->ppatch = *pppatch;
		*pppatch = ppatch;

		cpage.UnloadPage();
		}
	Assert( err == JET_errSuccess );

	//	Store the patch file name

	{
	CHAR *szT = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( szPatch ) + 1 ) );
	if ( szT == NULL )
		Call( ErrERRCheck( JET_errOutOfMemory ) );
	strcpy( szT, szPatch );
	if ( rgfmp[ifmp].SzPatchPath() != NULL )
		OSMemoryHeapFree( rgfmp[ifmp].SzPatchPath() );
	rgfmp[ifmp].SetSzPatchPath( szT );
	rgfmp[ifmp].SetPfapiPatch( pfapiPatch );
	}

	m_rgrstmap[irstmap].fPatchSetup = fTrue;

HandleError:

	if ( pbPageCache )
		{
		cpage.UnloadPage();
		OSMemoryPageFree( pbPageCache );
		}
	
	//	close database file

	delete pfapiDatabase;

	//	close patch file

	if ( err < JET_errSuccess )
		{
		delete pfapiPatch;
		}

	return err;
	}

#endif	//	ELIMINATE_PATCH_FILE

	
/***********************************************************
/********************* EXTERNAL BACKUP *********************/

ERR ISAMAPI ErrIsamBeginExternalBackup( JET_INSTANCE jinst, JET_GRBIT grbit )
	{
	INST *pinst = (INST *)jinst;
	return pinst->m_plog->ErrLGBKBeginExternalBackup( pinst->m_pfsapi, grbit );
	}
	
ERR LOG::ErrLGBKBeginExternalBackup( IFileSystemAPI *const pfsapi, JET_GRBIT grbit )
	{
	ERR			err = JET_errSuccess;
	CHECKPOINT	*pcheckpointT = NULL;
	CHAR 	  	szPathJetChkLog[IFileSystemAPI::cchPathMax];

	const BOOL	fFullBackup = ( 0 == grbit );
	const BOOL	fIncrementalBackup = ( JET_bitBackupIncremental == grbit );
	const BOOL	fSnapshotBackup = ( JET_bitBackupSnapshot == grbit );

#ifdef DEBUG
	if ( m_fDBGTraceBR )
		DBGBRTrace("** Begin BeginExternalBackup - ");
#endif

	if ( m_fLogDisabled )
		{
		return ErrERRCheck( JET_errLoggingDisabled );
		}

	if ( m_fRecovering || m_fLGNoMoreLogWrite )
		{
		Assert( fFalse );
		return ErrERRCheck( JET_errLogWriteFail );
		}

	/*	grbit may be 0 or JET_bitBackupIncremental or JET_bitBackupSnapshot
	/**/
	if ( ! ( ( grbit == JET_bitBackupIncremental ) || ( grbit == JET_bitBackupSnapshot ) || ( 0 == grbit ) ) )
		{
		return ErrERRCheck( JET_errInvalidGrbit );
		}

	Assert ( 0 == grbit || JET_bitBackupIncremental == grbit || JET_bitBackupSnapshot == grbit );

	Assert( m_ppibBackup != ppibNil );

	if ( fIncrementalBackup && m_fLGCircularLogging )
		{
		return ErrERRCheck( JET_errInvalidBackup );
		}

	m_critBackupInProgress.Enter();
	
	if ( m_fBackupInProgress )
		{
		m_critBackupInProgress.Leave();
		return ErrERRCheck( JET_errBackupInProgress );
		}
	
	//	flush the cache so that we will have less pages to patch.

	for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid ++ )
		{
		if ( m_pinst->m_mpdbidifmp[ dbid ] < ifmpMax )
			{
			//	terminate OLDSLV on this database

			CallSx( ErrOLDDefragment( m_pinst->m_mpdbidifmp[ dbid ], NULL, NULL, NULL, NULL, JET_bitDefragmentSLVBatchStop ), JET_wrnDefragNotRunning );
			
			CallJ( ErrBFFlush( m_pinst->m_mpdbidifmp[ dbid ], fFalse ), LeaveBackupInProgress );
			CallJ( ErrBFFlush( m_pinst->m_mpdbidifmp[ dbid ] | ifmpSLV, fFalse ), LeaveBackupInProgress );
			}
		}

	Assert ( backupStateNotStarted == m_fBackupStatus);

	m_lgenCopyMic = 0;
	m_lgenCopyMac = 0;
	m_lgenDeleteMic = 0;
	m_lgenDeleteMac = 0;

	m_fBackupInProgress = fTrue;
	m_critBackupInProgress.Leave();

	if ( fIncrementalBackup )
		{
		m_fBackupStatus = backupStateLogsAndPatchs;
		}
	else
		{
		Assert ( fFullBackup || fSnapshotBackup );
		m_fBackupStatus = backupStateDatabases;
		}
	
	//	make sure no detach/attach going. If there are, let them continue and finish.

CheckDbs:
	BOOL fDetachAttach;

	fDetachAttach = fFalse;
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP ifmp = m_pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;
		if ( ( fDetachAttach = rgfmp[ifmp].CrefWriteLatch() != 0 ) != fFalse )
			break;
		}

	if ( fDetachAttach )
		{
		UtilSleep( cmsecWaitGeneric );
		goto CheckDbs;
		}

	// FULL: clean the "involved" in backup flag for all databases in a full backup. We mark the
	// databases as involved in the backup process during JetOpenFile for the database file
	// INCREMENTAL: set the "involved" in backup flag for all databases in a incremental backup
	// because in this case the database file is not used and, in fact, all the daatbases are
	// contained in the log files.
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP ifmp = m_pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;

		// on Incremental, all the databases are part of the backup
		// on Full, we mark the Db as part of the backup only on JetOpenFile on it
		// on Snapshot we mark the Db as part of the backup on SnapshotStart
		if ( fIncrementalBackup )
			{
			rgfmp[ifmp].SetInBackupSession();
			}
		else
			{
			rgfmp[ifmp].ResetInBackupSession();
			}
		}

	if ( fIncrementalBackup )
		{

//	UNDONE: need to do tight checking to make sure there was a full backup before and
//	UNDONE: the logs after that full backup are still available.
		//	The UNDONE it is not done by ErrLGCheckLogsForIncrementalBackup later on.
	
		Call( ErrLGCheckIncrementalBackup( m_pinst ) )
		}
	else
		{
		Assert ( fFullBackup || fSnapshotBackup ) ;
		m_critLGBuf.Enter();
		m_lgposFullBackupMark = m_lgposLogRec;
		m_critLGBuf.Leave();
		LGIGetDateTime( &m_logtimeFullBackupMark );
		}
	
	Assert( m_ppibBackup != ppibNil );

	//	reset global copy/delete generation variables

	m_fBackupBeginNewLogFile = fFalse;

	/*	if incremental backup set copy/delete mic and mac variables,
	/*	else backup is full and set copy/delete mic and delete mac.
	/*	Copy mac will be computed after database copy is complete.
	/**/
	if ( fIncrementalBackup )
		{
#ifdef DEBUG
		if ( m_fDBGTraceBR )
			DBGBRTrace( "Incremental Backup.\n" );
#endif
		UtilReportEvent( eventInformation, LOGGING_RECOVERY_CATEGORY,
				START_INCREMENTAL_BACKUP_INSTANCE_ID, 0, NULL, 0, NULL, m_pinst );
		m_fBackupFull = fFalse;
		m_fBackupSnapshot = fFalse;

		/*	if all database are allowed to do incremental backup? Check bkinfo prev.
		 */
		}
	else
		{
		Assert ( fFullBackup || fSnapshotBackup ) ;
#ifdef DEBUG
		if ( m_fDBGTraceBR )
			DBGBRTrace( fFullBackup?"Full Backup.\n":"Snapshot Backup.\n");
#endif
		UtilReportEvent(
			eventInformation,
			LOGGING_RECOVERY_CATEGORY,
			fFullBackup?START_FULL_BACKUP_INSTANCE_ID:START_SNAPSHOT_BACKUP_INSTANCE_ID,
			0,
			NULL,
			0,
			NULL,
			m_pinst );
		m_fBackupFull = fFullBackup;
		m_fBackupSnapshot = fSnapshotBackup;

		Assert ( m_fBackupSnapshot ^ m_fBackupFull );
		
		pcheckpointT = (CHECKPOINT *) PvOSMemoryPageAlloc( sizeof(CHECKPOINT), NULL );
		if ( pcheckpointT == NULL )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		LGFullNameCheckpoint( pfsapi, szPathJetChkLog );

		// This call should only return an error on hardware failure.
		err = ErrLGReadCheckpoint( pfsapi, szPathJetChkLog, pcheckpointT, fFalse );
		Assert( JET_errSuccess == err
			|| JET_errCheckpointCorrupt == err
			|| JET_errCheckpointFileNotFound == err );
		Call( err );

		m_lgenCopyMic = pcheckpointT->checkpoint.le_lgposCheckpoint.le_lGeneration;
		Assert( m_lgenCopyMic != 0 );
		}

	{
	const int cbFillBuffer = 128;
	char szTrace[cbFillBuffer + 1];
	szTrace[ cbFillBuffer ] = '\0';
	_snprintf( szTrace, cbFillBuffer, "EXT BACKUP START (chk 0x%05X, grbit %d)", m_lgenCopyMic, grbit );
	(void) ErrLGTrace( m_ppibBackup, szTrace);
	}

	// we need to log the operation here for snapshot as we need the
	// log position during db snapshot (to mark the db header)
	if ( m_fBackupSnapshot )
		{
		LGPOS lgposRecT;
		CallR( ErrLGSnapshotStartBackup( this, &lgposRecT ) );
		m_lgposSnapshotStart = lgposRecT;
		}
		
HandleError:
	if ( pcheckpointT != NULL )
		{
		OSMemoryPageFree( pcheckpointT );
		}

#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];

		sprintf( sz, "   End BeginExternalBackup (%d).\n", err );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif

	if ( err < 0 )
		{
		m_fBackupInProgress = fFalse;
		m_fBackupStatus = backupStateNotStarted;
		}

	return err;

LeaveBackupInProgress:

	m_critBackupInProgress.Leave();
	return err;
	}


ERR ISAMAPI ErrIsamGetAttachInfo( JET_INSTANCE jinst, VOID *pv, ULONG cbMax, ULONG *pcbActual )
	{
	INST * pinst = (INST *)jinst;
	return pinst->m_plog->ErrLGBKGetAttachInfo( pinst->m_pfsapi, pv, cbMax, pcbActual );
	}

ERR LOG::ErrLGBKGetAttachInfo( IFileSystemAPI *const pfsapi, VOID *pv, ULONG cbMax, ULONG *pcbActual )
	{
	ERR		err = JET_errSuccess;
	DBID	dbid;
	ULONG	cbActual;
	CHAR	*pch = NULL;
	CHAR	*pchT;

	if ( !m_fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}

	// no snapshot backup using the old backup API
	Assert ( !m_fBackupSnapshot );
	
	/*	should not get attach info if not performing full backup
	/**/
	if ( !m_fBackupFull )
		{
		return ErrERRCheck( JET_errInvalidBackupSequence );
		}

#ifdef DEBUG
	if ( m_fDBGTraceBR )
		DBGBRTrace( "** Begin GetAttachInfo.\n" );
#endif

	/*	compute cbActual, for each database name with NULL terminator
	/*	and with terminator of super string.
	/**/
	cbActual = 0;
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP 	ifmp = m_pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;

		FMP		*pfmp = &rgfmp[ifmp];
		if ( pfmp->FInUse()
			&& pfmp->FLogOn()
			&& pfmp->FAttached() )
			{
			Assert( !pfmp->FSkippedAttach() );
			Assert( !pfmp->FDeferredAttach() );

			cbActual += (ULONG) strlen( pfmp->SzDatabaseName() ) + 1;
			if ( pfmp->FSLVAttached() )
				{
				Assert ( pfmp->SzSLVName() );
				Assert ( strlen ( pfmp->SzSLVName() ) != 1 );
				cbActual += (ULONG) strlen( pfmp->SzSLVName() ) + 1;				
				}
			}
		}
	cbActual += 1;

	pch = static_cast<CHAR *>( PvOSMemoryHeapAlloc( cbActual ) );
	if ( pch == NULL )
		{
		Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
		}

	pchT = pch;
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP 	ifmp = m_pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;

		FMP		*pfmp = &rgfmp[ifmp];

		if ( pfmp->FInUse()
			&& pfmp->FLogOn()
			&& pfmp->FAttached() )
			{
			Assert( !pfmp->FSkippedAttach() );
			Assert( !pfmp->FDeferredAttach() );

			Assert( pchT + strlen( pfmp->SzDatabaseName() ) + 1 < pchT + cbActual );
			strcpy( pchT, pfmp->SzDatabaseName() );
			pchT += strlen( pfmp->SzDatabaseName() );
			Assert( *pchT == 0 );
			pchT++;
			if ( pfmp->FSLVAttached() )
				{
				Assert ( pfmp->SzSLVName() );
				Assert ( strlen ( pfmp->SzSLVName() ) != 1 );
				
				CHAR	* szSLVPath = pfmp->SzSLVName();
				
				Assert( pchT + strlen( szSLVPath ) + 1 < pchT + cbActual );
				strcpy( pchT, szSLVPath );
				pchT += strlen( szSLVPath );
				Assert( *pchT == 0 );
				pchT++;
				}
			}
		}
	Assert( pchT == pch + cbActual - 1 );
	*pchT = 0;

	/*	return cbActual
	/**/
	if ( pcbActual != NULL )
		{
		*pcbActual = cbActual;
		}

	/*	return data
	/**/
	if ( pv != NULL )
		UtilMemCpy( pv, pch, min( cbMax, cbActual ) );

HandleError:
	/*	free buffer
	/**/
	if ( pch != NULL )
		{
		OSMemoryHeapFree( pch );
		pch = NULL;
		}

#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];
		CHAR *pch;

		if ( err >= 0 )
			{
			sprintf( sz, "   Attach Info with cbActual = %d and cbMax = %d :\n", cbActual, cbMax );
			Assert( strlen( sz ) <= sizeof( sz ) - 1 );
			DBGBRTrace( sz );

			if ( pv != NULL )
				{
				pch = static_cast<CHAR *>( pv );

				do {
					if ( strlen( pch ) != 0 )
						{
						sprintf( sz, "     %s\n", pch );
						Assert( strlen( sz ) <= sizeof( sz ) - 1 );
						DBGBRTrace( sz );
						pch += strlen( pch );
						}
					pch++;
					} while ( *pch );
				}
			}

		sprintf( sz, "   End GetAttachInfo (%d).\n", err );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif
		
	if ( err < 0 )
		{
		CallS( ErrLGBKIExternalBackupCleanUp( pfsapi, err ) );
		Assert( !m_fBackupInProgress );
		}

	return err;
	}


// ********************** LOG CHECKSUM VERIFICATION ********************* //

class LOGVERIFIER;  //  TODO:  rewrite this class.  this is some of the worst C++ I've ever seen

// ======================= Abstract class to describe a state of verifying the log

class VERIFYSTATE
	{
public:
	virtual ERR ErrVerify( LOGVERIFIER* pLogVerifier, const BYTE* pb, ULONG cb ) = 0;
protected:
	VOID ChangeState( LOGVERIFIER* pLogVerifier, VERIFYSTATE* pVerifyState );
	VOID SetCompleted( LOGVERIFIER* pLogVerifier );
	};

// ======================== Verify a log file header =====================

class VERIFYHEADER : public VERIFYSTATE
	{
public:
	virtual ERR ErrVerify( LOGVERIFIER* pLogVerifier, const BYTE* pb, ULONG cb );
	};

// ======================== Verify runs of LRCHECKSUM regions =================

class VERIFYCHECKSUM : public VERIFYSTATE
	{
public:
	VERIFYCHECKSUM( ULONG ibLRCK, ULONG32 lGeneration );
	virtual ERR ErrVerify( LOGVERIFIER* pLogVerifier, const BYTE* pb, ULONG cb );
	ERR ErrVerifyLRCKStart( LOGVERIFIER* pLogVerifier, const BYTE* pb, ULONG cb );
	ERR ErrVerifyLRCKContinue( LOGVERIFIER* pLogVerifier, const BYTE* pb, ULONG cb );
	ERR ErrCheckLRCKEnd( LOGVERIFIER* pLogVerifier );

private:
	enum STATE
		{
		state_Start,
		state_Continue
		};

	ULONG						m_cbSeen;	// index of byte after last byte we've been passed in ErrVerify
	ULONG						m_ibLRCK;	// index of m_lrck
	ULONG						m_ibChecksumIncremental;	// index of byte after last byte checksummed
	LOG::CHECKSUMINCREMENTAL	m_ck;		// state of incremental checksumming into next block
	LRCHECKSUM					m_lrck;		// copy of current LRCHECKSUM we're verifying
	STATE						m_state;	// need to continue checksumming bytes in next block?
	ULONG32						m_lGeneration;	// gen # of log file
	};

// ===================== Log verification interface ===========================

class LOGVERIFIER
	{
public:
	LOGVERIFIER( IFileAPI* const pfapi, ERR* const pErr );
	~LOGVERIFIER();
	
	ERR	ErrVerify( const BYTE* pb, ULONG cb );

	BOOL	FCompleted() const;

	IFileAPI* Pfapi() const { return m_pfapi; }
	
private:
	// API for VERIFYSTATEs to change state of log verification
	friend class VERIFYSTATE;
	VOID	ChangeState( VERIFYSTATE* pVerifyState );
	VOID	SetCompleted();

private:
	// Member variables
	IFileAPI* const	m_pfapi;
	VERIFYSTATE*	m_pVerifyState;
	};

// This code is Source Insight-enhanced

#define VERIFYHEADER_CODE
#define VERIFYCHECKSUM_CODE
#define VERIFYSTATE_CODE
#define LOGVERIFIER_CODE


#ifdef VERIFYHEADER_CODE

ERR
VERIFYHEADER::ErrVerify( LOGVERIFIER* const pLogVerifier, const BYTE* const pb, const ULONG cb )
	{
	ERR	err = JET_errSuccess;

	Assert( pNil != pLogVerifier );
	Assert( pNil != pb );
	Assert( cb >= sizeof( LGFILEHDR ) );

	const LGFILEHDR* const plgfilehdr = reinterpret_cast< const LGFILEHDR* >( pb );
	if ( ::UlUtilChecksum( reinterpret_cast< const BYTE* >( plgfilehdr ), sizeof( LGFILEHDR ) ) !=
		plgfilehdr->lgfilehdr.le_ulChecksum )
		{
		const _TCHAR*	rgpsz[ 4 ];
		DWORD			irgpsz		= 0;
		_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szOffset[ 64 ];
		_TCHAR			szLength[ 64 ];
		_TCHAR			szError[ 64 ];

		CallS( pLogVerifier->Pfapi()->ErrPath( szAbsPath ) );
		_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), QWORD( 0 ), QWORD( 0 ) );
		_stprintf( szLength, _T( "%u (0x%08x)" ), sizeof( LGFILEHDR ), sizeof( LGFILEHDR ) );
		_stprintf( szError, _T( "%i (0x%08x)" ), JET_errLogReadVerifyFailure, JET_errLogReadVerifyFailure );

		rgpsz[ irgpsz++ ]	= szAbsPath;
		rgpsz[ irgpsz++ ]	= szOffset;
		rgpsz[ irgpsz++ ]	= szLength;
		rgpsz[ irgpsz++ ]	= szError;

		UtilReportEvent(	eventError,
							LOGGING_RECOVERY_CATEGORY,
							LOG_RANGE_CHECKSUM_MISMATCH_ID,
							irgpsz,
							rgpsz );

		return ErrERRCheck( JET_errLogReadVerifyFailure );
		}

	VERIFYCHECKSUM* const pVerifyChecksum = new VERIFYCHECKSUM( sizeof( LGFILEHDR ), plgfilehdr->lgfilehdr.le_lGeneration );
	if ( pNil == pVerifyChecksum )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	ChangeState( pLogVerifier, pVerifyChecksum );
	delete this;
	Call( pLogVerifier->ErrVerify( pb + sizeof( LGFILEHDR ), cb - sizeof( LGFILEHDR ) ) );

HandleError:
	return err;
	}

#endif

#ifdef VERIFYCHECKSUM_CODE

VERIFYCHECKSUM::VERIFYCHECKSUM
	(
	ULONG	ibLRCK,			// index of LRCK in the log file
	ULONG32	lGeneration		// gen # of log file
	)
	: m_ibLRCK( ibLRCK ), m_ibChecksumIncremental( ibLRCK + sizeof( LRCHECKSUM ) ), m_cbSeen( ibLRCK ),
	m_state( state_Start ), m_lGeneration( lGeneration )
	{
	memset( &m_lrck, 0, sizeof( m_lrck ) );
	}

ERR
VERIFYCHECKSUM::ErrCheckLRCKEnd( LOGVERIFIER* const pLogVerifier )
	{
	// compute end of forward region
	const ULONG ibEndOfForward = m_ibLRCK + sizeof( m_lrck ) + m_lrck.le_cbForwards;

	Assert( ibEndOfForward >= m_ibChecksumIncremental );
	if ( ibEndOfForward == m_ibChecksumIncremental )
		{
		// done checksumming forward region & everything else
		if ( m_lrck.le_ulChecksum != m_ck.EndChecksum() )
			{
			return ErrERRCheck( JET_errLogReadVerifyFailure );
			}
		if ( 0 == m_lrck.le_cbNext )
			{
			// no next LRCK region, thus we've gone through entire log file and verified every byte
			SetCompleted( pLogVerifier );
			delete this;
			}
		else
			{
			// setup for next LRCHECKSUM
			// next LRCK could be in next block, or it could be in this block
			m_ibLRCK += sizeof( LRCHECKSUM ) + m_lrck.le_cbNext;
			m_ibChecksumIncremental = m_ibLRCK + sizeof( LRCHECKSUM );
			m_state = state_Start;
			}
		}
	else
		{
		// more data to checksum in next block, so setup continue state
		m_state = state_Continue;
		}
	return JET_errSuccess;
	}

ERR
VERIFYCHECKSUM::ErrVerifyLRCKContinue( LOGVERIFIER* const pLogVerifier, const BYTE* const pb, const ULONG cb )
	{
	// if we checksummed from beginning of this block (which is m_ibChecksumIncremental) to
	// however far the forwards pointer goes
	const ULONG ibEndOfForwards = m_ibLRCK + sizeof( m_lrck ) + m_lrck.le_cbForwards;
	Assert( ibEndOfForwards > m_ibChecksumIncremental );
	const ULONG cbMaxForwards = ibEndOfForwards - m_ibChecksumIncremental;
	const BYTE* const pbMax = pb + min( cb, cbMaxForwards );
	
	if ( ( pbMax < pb ) ||
		( pbMax > pb + cb ) )
		{
		// max out of buffer
		return ErrERRCheck( JET_errLogReadVerifyFailure );
		}
	m_ck.ChecksumBytes( pb, pbMax );
	m_ibChecksumIncremental += ULONG( pbMax - pb );

	return ErrCheckLRCKEnd( pLogVerifier );
	}

// Note: pb != plrck necessarily because an LRCK can be placed anywhere in a sector,
// thus anywhere on a data block.
// pb defined to be beginning of block that we have access to
// plrck defined to be beginning of LRCK in the block we have access to.
// plrck is within the block.
//
//	This function is based on LOG::UlComputeChecksum, so be sure these are in sync.

ERR
VERIFYCHECKSUM::ErrVerifyLRCKStart( LOGVERIFIER* const pLogVerifier, const BYTE* const pb, const ULONG cb )
	{
	ULONG32 ulChecksum = ulLRCKChecksumSeed;
	
	// distance from LRCK in this block to beginning of block
	Assert( m_ibLRCK >= m_cbSeen );
	const LRCHECKSUM* const plrck = reinterpret_cast< const LRCHECKSUM* >( pb + ( m_ibLRCK - m_cbSeen ) );

	// LRCK must be within the buffer
	if ( ( reinterpret_cast< const BYTE* >( plrck ) < pb ) ||
		( reinterpret_cast< const BYTE* >( plrck ) + sizeof( *plrck ) > cb + pb ) )
		{
		return ErrERRCheck( JET_errLogReadVerifyFailure );
		}

	// copy
	m_lrck = *plrck;
	
	// checksum backward region
		{
		const BYTE* const pbMin = reinterpret_cast< const BYTE* >( plrck ) - plrck->le_cbBackwards;
		if ( ( pbMin < pb ) ||
			( pbMin >= cb + pb ) )
			{
			// le_cbBackwards was corrupt if it is outside of buffer
			return ErrERRCheck( JET_errLogReadVerifyFailure );
			}
		const BYTE* const pbMax = reinterpret_cast< const BYTE* >( plrck );
		ulChecksum = LOG::UlChecksumBytes( pbMin, pbMax, ulChecksum );
		}

	// checksum various other attributes of LRCHECKSUM
	
	ulChecksum ^= plrck->le_cbBackwards;
	ulChecksum ^= plrck->le_cbForwards;
	ulChecksum ^= plrck->le_cbNext;
	
	ulChecksum ^= (ULONG32) plrck->bUseShortChecksum;

	ulChecksum ^= m_lGeneration;

	// prepare to start checksumming forward region which may extend into other blocks
	m_ck.BeginChecksum( ulChecksum );

	// end of bytes incrementally checksummed so far
	m_ibChecksumIncremental = m_ibLRCK + sizeof( *plrck );
	
	// checksum forward region
		{
		const BYTE* const pbMin = reinterpret_cast< const BYTE* >( plrck ) + sizeof( *plrck );
		const BYTE* const pbMaxForwards = pbMin + plrck->le_cbForwards;
		const BYTE* const pbMaxBlock = pb + cb;
		const BYTE* const pbMax = min( pbMaxForwards, pbMaxBlock );

		if ( ( pbMin < pb ) ||
			( pbMin > pb + cb ) )
			{
			// min out of buffer
			return ErrERRCheck( JET_errLogReadVerifyFailure );
			}
		if ( ( pbMax < pb ) ||
			( pbMax > pb + cb ) )
			{
			// max out of buffer
			return ErrERRCheck( JET_errLogReadVerifyFailure );
			}
		if ( pbMax < pbMin )
			{
			// psychotic pointers -- avoid access violation here
			return ErrERRCheck( JET_errLogReadVerifyFailure );
			}
		m_ck.ChecksumBytes( pbMin, pbMax );
		m_ibChecksumIncremental += ULONG( pbMax - pbMin );
		}
		
	return ErrCheckLRCKEnd( pLogVerifier );
	}

ERR
VERIFYCHECKSUM::ErrVerify( LOGVERIFIER* const pLogVerifier, const BYTE* const pb, const ULONG cb )
	{
	ERR err = JET_errSuccess;
	
	Assert( pNil != pb );
	Assert( cb > 0 );
	Assert( pNil != pLogVerifier );

	do
		{
		switch ( m_state )
			{
			case state_Start:
				Call( ErrVerifyLRCKStart( pLogVerifier, pb, cb ) );
				break;
				
			case state_Continue:
				Call( ErrVerifyLRCKContinue( pLogVerifier, pb, cb ) );
				break;

			default:
				Assert( fFalse );
				break;
			}
		}
	while ( ( ! pLogVerifier->FCompleted() ) && ( m_ibLRCK < m_cbSeen + cb ) && ( state_Continue != m_state ) );
	// while there's more in the log file to check and the next LRCK is in this block

	if ( ! pLogVerifier->FCompleted() )
		{
		// Next LRCK to checkout should be in next block
		Assert( ( state_Continue == m_state ) || ( m_ibLRCK >= m_cbSeen + cb ) );

		m_cbSeen += cb;
		}

HandleError:
	if ( err == JET_errLogReadVerifyFailure )
		{
		QWORD			ibOffset	= m_ibLRCK - m_lrck.le_cbBackwards;
		DWORD			cbLength	= m_lrck.le_cbBackwards + sizeof( LRCHECKSUM ) + m_lrck.le_cbForwards;
		
		const _TCHAR*	rgpsz[ 4 ];
		DWORD			irgpsz		= 0;
		_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szOffset[ 64 ];
		_TCHAR			szLength[ 64 ];
		_TCHAR			szError[ 64 ];

		CallS( pLogVerifier->Pfapi()->ErrPath( szAbsPath ) );
		_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibOffset, ibOffset );
		_stprintf( szLength, _T( "%u (0x%08x)" ), cbLength, cbLength );
		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );

		rgpsz[ irgpsz++ ]	= szAbsPath;
		rgpsz[ irgpsz++ ]	= szOffset;
		rgpsz[ irgpsz++ ]	= szLength;
		rgpsz[ irgpsz++ ]	= szError;

		UtilReportEvent(	eventError,
							LOGGING_RECOVERY_CATEGORY,
							LOG_RANGE_CHECKSUM_MISMATCH_ID,
							irgpsz,
							rgpsz );
		}
	return err;
	}

#endif

	
#ifdef LOGVERIFIER_CODE

LOGVERIFIER::LOGVERIFIER( IFileAPI* const pfapi, ERR* const pErr )
	:	m_pfapi( pfapi ),
		m_pVerifyState( pNil )
	{
	VERIFYHEADER* const pVerifyHeader = new VERIFYHEADER;
	if ( pNil == pVerifyHeader )
		{
		*pErr = ErrERRCheck( JET_errOutOfMemory );
		return;
		}
	ChangeState( pVerifyHeader );
	*pErr = JET_errSuccess;
	}

LOGVERIFIER::~LOGVERIFIER()
	{
	delete m_pVerifyState;
	}

INLINE VOID
LOGVERIFIER::ChangeState( VERIFYSTATE* const pVerifyState )
	{
	Assert( pVerifyState != pNil );
	m_pVerifyState = pVerifyState;
	}

INLINE ERR
LOGVERIFIER::ErrVerify( const BYTE* const pb, const ULONG cb )
	{
	if ( FCompleted() )
		{
		return JET_errSuccess;
		}
	else
		{
		Assert( pNil != m_pVerifyState );
		Assert( pNil != pb );
		return m_pVerifyState->ErrVerify( this, pb, cb );
		}
	}

INLINE BOOL
LOGVERIFIER::FCompleted() const
	{
	return pNil == m_pVerifyState;
	}

INLINE VOID
LOGVERIFIER::SetCompleted()
	{
	m_pVerifyState = pNil;
	}
#endif

#ifdef VERIFYSTATE_CODE

INLINE VOID
VERIFYSTATE::ChangeState( LOGVERIFIER* const pLogVerifier, VERIFYSTATE* const pVerifyState )
	{
	Assert( pNil != pLogVerifier );
	Assert( pNil != pVerifyState );
	pLogVerifier->ChangeState( pVerifyState );
	}

INLINE VOID
VERIFYSTATE::SetCompleted( LOGVERIFIER* const pLogVerifier )
	{
	Assert( pNil != pLogVerifier );
	pLogVerifier->SetCompleted();
	}
	
#endif

//	Abstract base class to describe class to process chunks of data during file read processing

class ChunkProcessor
	{
public:
	virtual ERR ErrProcessChunk( const DWORD ichunk ) = 0;
	};


class ANYORDERCOMPLETION
	{
public:
	ANYORDERCOMPLETION( const DWORD cChunks, ERR* const pErr )
		: m_asigDone( CSyncBasicInfo( _T( "ANYORDERCOMPLETION::m_asigDone" ) ) ),
		m_err( JET_errSuccess ),
		m_cOutstandingChunks( 0 ),
		m_cIssuedChunks( 0 )
		{
		*pErr = JET_errSuccess;
		}

	//	During your issue process, you may not want to continue issuing if
	//	we've already reached an error state.
	
	INLINE BOOL	FContinueIssuing() const
		{
		return m_err >= 0;
		}

	//	Call you know a chunk will complete in the future.
	
	INLINE VOID	Issue()
		{
		// not done atomically, since same thread doing Issue()'s should do WaitForAll()
		++m_cIssuedChunks;
		}

	class DoNothing
		{
	public:
		INLINE VOID BeforeWaitProcess()
			{
			}
		};

	//	Wait for all the outstanding chunks to complete and be processed, returning
	//	any error from any chunk processing.

	ERR ErrWaitForAll()
		{
		return ErrWaitForAll( DoNothing() );
		}

	template< class T >
	ERR	ErrWaitForAll( T& pfnBeforeWait )
		{
		if ( 0 != AtomicExchangeAdd( &m_cOutstandingChunks, m_cIssuedChunks ) + m_cIssuedChunks )
			{
			//	May want to do additional processing before we sleep.
			pfnBeforeWait.BeforeWaitProcess();
			m_asigDone.Wait();
			}
		else
			{
			//	Asynch. events all completed and we were last to increment negative value to zero,
			//	which means signal is already set and we don't even need to check it.

			// Assert( m_asigDone.FIsSet() );	// Synch-God where are you?!
			}
		const ERR err = m_err;
		return err;
		}

	VOID	Completion( const DWORD ichunk, ChunkProcessor& cp, const ERR errCompletion );

	INLINE VOID	Completion( const DWORD ichunkCompleted, ChunkProcessor& cp )
		{
		Completion( ichunkCompleted, cp, JET_errSuccess );
		}
		
private:
	CAutoResetSignal	m_asigDone;			// Set when all completions have finished.
	volatile ERR		m_err;				// any error returned from completion function
	long				m_cOutstandingChunks;	// Number of issued chunks whose completion functions haven't been called
	long				m_cIssuedChunks;
	};



VOID
ANYORDERCOMPLETION::Completion( const DWORD ichunk, ChunkProcessor& cp, const ERR errCompletion )
	{
	if ( m_err < 0 )
		{
		// already have an error, so do not call anymore ChunkCompletion functions
		goto HandleError;
		}

	if ( errCompletion < 0 )
		{
		//	If someone beats us, that's fine because there's no real order anyway.
		(VOID) AtomicCompareExchange( (long*) &m_err, JET_errSuccess, errCompletion );
		goto HandleError;
		}

		{
		const ERR err = cp.ErrProcessChunk( ichunk );
									
		if ( JET_errSuccess != err )
			{
			(VOID) AtomicCompareExchange( (long*) &m_err, JET_errSuccess, err );
			}
		}
		
HandleError:
	if ( 0 == AtomicDecrement( &m_cOutstandingChunks ) )
		{
		m_asigDone.Set();
		}
	}
		
// To be used in situations of asynchronous completion of many "chunks" where
// completion functions need to be called in order of issue
// even if order of actual completion doesn't match order of issue.
//
// i.e.
// Issue Order: 0, 1, 2
// Actual Completion Order: 1, 2, 0
// Completion Order Maintained by this API: 0, 1, 2
//
// A "completion" is defined as the completion function being called
// for a chunk.
//
// CONSIDER: may want to redesign interface to allow clients to set when
// we go into a non-issue state, instead of being JET_err* based.
//

class INORDERCOMPLETION
	{
public:
	INORDERCOMPLETION( const DWORD cChunks, ERR* const pErr )
		: m_asigDone( CSyncBasicInfo( _T( "INORDERCOMPLETION::m_asigDone" ) ) ),
		m_ichunkNext( 0 ),
		m_crit( CLockBasicInfo( CSyncBasicInfo( _T( "INORDERCOMPLETION::m_crit" ) ), 0, 0 ) ),
		m_rgfCompleted( new bool[ cChunks ] ),
		m_cfCompleted( cChunks ),
		m_err( JET_errSuccess ),
		m_cOutstandingChunks( 0 ),
		m_cIssuedChunks( 0 )
		{
		Assert( cChunks > 0 );
		Assert( pNil != pErr );
		
		if ( NULL == m_rgfCompleted )
			{
			*pErr = ErrERRCheck( JET_errOutOfMemory );
			return;
			}

		memset( m_rgfCompleted, 0, sizeof( bool ) * cChunks );

		*pErr = JET_errSuccess;
		}

	~INORDERCOMPLETION()
		{
		Assert( 0 == m_cOutstandingChunks );
		delete[] m_rgfCompleted;
		}

	//	During your issue process, you may not want to continue issuing if
	//	we've already reached an error state.
	
	INLINE BOOL	FContinueIssuing() const
		{
		return m_err >= 0;
		}

	//	Call you know a chunk will complete in the future.
	
	INLINE VOID	Issue()
		{
		Assert( m_cIssuedChunks < m_cfCompleted );
		// not done atomically, since same thread doing Issue()'s should do WaitForAll()
		++m_cIssuedChunks;
		}

	class DoNothing
		{
	public:
		INLINE VOID BeforeWaitProcess()
			{
			}
		};

	//	Wait for all the outstanding chunks to complete and be processed, returning
	//	any error from any chunk processing.

	ERR ErrWaitForAll()
		{
		return ErrWaitForAll( DoNothing() );
		}

	template< class T >
	ERR	ErrWaitForAll( T& pfnBeforeWait )
		{
		if ( 0 != AtomicExchangeAdd( &m_cOutstandingChunks, m_cIssuedChunks ) + m_cIssuedChunks )
			{
			//	May want to do additional processing before we sleep.
			pfnBeforeWait.BeforeWaitProcess();
			m_asigDone.Wait();
			}
		else
			{
			//	Asynch. events all completed and we were last to increment negative value to zero,
			//	which means signal is already set and we don't even need to check it.

			// Assert( m_asigDone.FIsSet() );	// Synch-God where are you?!
			}
		const ERR err = m_err;
		return err;
		}

	VOID Completion( const DWORD ichunkCompleted, ChunkProcessor& cp, const ERR errCompletion );

	//	Call when ichunkCompleted has completed asynchronously successfully
	//	pfnChunkCompletion is functor to be called on any chunks that have
	//	completed now, if linear ordering is satisfied (in other words, the functor
	//	may not be called when you call Completion()).
	
	INLINE VOID	Completion( const DWORD ichunkCompleted, ChunkProcessor& cp )
		{
		Completion( ichunkCompleted, cp, JET_errSuccess );
		}

private:
	CAutoResetSignal	m_asigDone;			// Set when all completions have finished.
	DWORD				m_ichunkNext;		// next chunk that we should complete to maintain proper order
	CCriticalSection	m_crit;				
	bool* const			m_rgfCompleted;		// flag set when a chunk completes
	const DWORD			m_cfCompleted;		// number of elements of m_rgfCompleted
	volatile ERR		m_err;				// any error returned from completion function
	long				m_cOutstandingChunks;	// Number of issued chunks whose completion functions haven't been called
	long				m_cIssuedChunks;
	};

VOID
INORDERCOMPLETION::Completion( const DWORD ichunkCompleted, ChunkProcessor& cp, const ERR errCompletion )
	{
	Assert( m_crit.FNotOwner() );
	m_crit.Enter();
	
	if ( m_err < 0 )
		{
		// already have an error, so do not call anymore ChunkCompletion functions
		goto HandleError;
		}

	if ( errCompletion < 0 )
		{
		m_err = errCompletion;
		goto HandleError;
		}

	Assert( ichunkCompleted < m_cfCompleted );
	m_rgfCompleted[ ichunkCompleted ] = fTrue;		// mark us as completed

	if ( ichunkCompleted == m_ichunkNext )
		{
		// if it's our turn, process forward as far as possible
		Assert( m_crit.FOwner() );
		m_crit.Leave();	// leave crit during processing

		DWORD ichunk = ichunkCompleted;		// start with our chunk and continue as far as possible
LProcessForwardChunks:
		for ( ; ichunk < m_cfCompleted; ++ichunk )
			{
			// look forward in completion status array
			if ( m_rgfCompleted[ ichunk ] )
				{
				const ERR err = cp.ErrProcessChunk( ichunk );
									
				if ( JET_errSuccess != err )
					{
					Assert( m_crit.FNotOwner() );
					m_crit.Enter();
					if ( m_err >= 0 )
						{
						// don't blow away a previous error
						m_err = err;
						}
					goto HandleError;
					}
				}
			else
				{
				// chunk has not completed, so we'll set it as the next to execute
				break;
				}
			}
		// try to set ichunkNext to the next one that should be processed
		m_crit.Enter();
		if ( ( ichunk < m_cfCompleted ) && ( m_rgfCompleted[ ichunk ] ) )
			{
			// the one we were going to mark as next has already completed & exited, so
			// we must handle it now
			m_crit.Leave();
			goto LProcessForwardChunks;
			}
		else
			{
			// the one we're going to mark next has not yet completed. If it's going to complete
			// once we leave this critical section, it will execute next.

			m_ichunkNext = ichunk;
			}
		}
		
HandleError:
	Assert( m_crit.FOwner() );
	m_crit.Leave();
	if ( 0 == AtomicDecrement( &m_cOutstandingChunks ) )
		{
		m_asigDone.Set();
		}
	}

//	Abstract base class to describe object with member function to handle FileRead completion
//	for different file types.

class FileReadCompletor
	{
public:
	virtual VOID FileReadCompletion(
		const ERR err,
		const QWORD ibOffset,
		const DWORD	cbData,
		const BYTE* const pbData ) = 0;
	};

//	Specify interfaces to read files of different types

class FileReadInterface
	{
public:
	virtual ERR FileRead( const QWORD ib, const DWORD cb, BYTE* const pb, FileReadCompletor* pfrc ) = 0;
	virtual VOID IssueIOs() = 0;
	virtual ERR ErrPath( _TCHAR* const szAbsPath ) = 0;
	};

//	FileReadInterface to read files of type: IFileAPI

class OSFILEREAD : public FileReadInterface
	{
public:
	INLINE OSFILEREAD( IFileAPI *const pfapi )
		: m_pfapi( pfapi )
		{
		Assert( pfapi );
		}
		
	ERR	FileRead( const QWORD ib, const DWORD cb, BYTE* const pb, FileReadCompletor* pfrc )
		{
		Assert( cb > 0 );
		Assert( pb );
		Assert( pfrc );
		ERR err = m_pfapi->ErrIORead( ib, cb, pb, FileReadIOCompletion, DWORD_PTR( pfrc ) );
		Call( err );
		
	HandleError:
		return err;
		}

	VOID	IssueIOs()
		{
		CallS( m_pfapi->ErrIOIssue() );
		}

	ERR ErrPath( _TCHAR* const szAbsPath )
		{
		return m_pfapi->ErrPath( szAbsPath );
		}

private:
	static VOID FileReadIOCompletion(
		const ERR			errIO,
		IFileAPI *const	pfapi,
		const QWORD			ibOffset,
		const DWORD			cbData,
		const BYTE* const	pbData,
		const DWORD_PTR		dwCompletionKey
		)
		{
		FileReadCompletor* const	pfrc = reinterpret_cast< FileReadCompletor* const >( dwCompletionKey );
		Assert( pfrc );
		pfrc->FileReadCompletion( errIO, ibOffset, cbData, pbData );
		}

private:
	IFileAPI *m_pfapi;
	};

//	Helper class that will start issuing IOs on a FileReadInterface when BeforeWaitProcess() is called.

class ISSUEIOS
	{
public:
	INLINE ISSUEIOS( FileReadInterface& fri )
		: m_fri( fri )
		{
		}

	INLINE VOID BeforeWaitProcess()
		{
		m_fri.IssueIOs();
		}
	
private:
	FileReadInterface&	m_fri;
	};

template< class CompletionConstraint >
class FileReadProcessor : public FileReadCompletor
	{
public:
	// public interface to FileReadProcessor
	static ERR
	ErrFileReadAndProcess(
		FileReadInterface&	fri,			// how to read file
		const QWORD			ibFile,			// what portion of file to read
		const DWORD			cbBlock,		// how much data to read -- never causes us to read past end of file
		BYTE* const			pbBlock,		// where to put file data
		const DWORD			cbIO,			// size of IO
		ChunkProcessor&		cp );			// how to process data in order

private:
	FileReadProcessor( const BYTE* const pbBlock, const DWORD cbBlock, const DWORD cbIO, CompletionConstraint& ioc, ChunkProcessor& cp )
		: m_pbBlock( pbBlock ), m_cbBlock( cbBlock ), m_cbIO( cbIO ), m_ioc( ioc ), m_cp( cp )
		{
		Assert( pbBlock );
		Assert( cbBlock > 0 );
		Assert( cbIO > 0 );
		}
		
	~FileReadProcessor()
		{
		}

	//	Asynchronous FileRead completion.
	//	Dispatch to INORDERCOMPLETION who will execute ChunkProcessor in proper order
	
	virtual VOID FileReadCompletion
		(
		const ERR			err,
		const QWORD			ibOffset,
		const DWORD			cbData,
		const BYTE* const	pbData
		)
		{
		Assert( pbData );
		Assert( m_pbBlock );
		Assert( pbData >= m_pbBlock );
		Assert( m_cbIO > 0 );
		Assert( 0 == ( ( pbData - m_pbBlock ) % m_cbIO ) );
		const DWORD ichunkCompleted = DWORD( pbData - m_pbBlock ) / m_cbIO;

		m_ioc.Completion( ichunkCompleted, m_cp, err );
		}

private:
	const BYTE* const		m_pbBlock;		// beginning of block of memory where all data will be brought in
	const DWORD				m_cbBlock;		// size of entire block
	const DWORD				m_cbIO;
	CompletionConstraint&	m_ioc;
	ChunkProcessor&			m_cp;
	};


//	VC5 generates code for every template usage, so let's preempt that

ERR
ErrFileReadAndProcessAnyOrder(
	FileReadInterface&	fri,			// how to read file
	const QWORD			ibFile,			// what portion of file to read
	const DWORD			cbBlock,		// how much data to read -- never causes us to read past end of file
	BYTE* const			pbBlock,		// where to put file data
	const DWORD			cbIO,			// size of IO
	ChunkProcessor&		cp )			// how to process data in order
	{
	return FileReadProcessor< ANYORDERCOMPLETION >::ErrFileReadAndProcess( fri, ibFile, cbBlock, pbBlock, cbIO, cp );
	}

template< class CompletionConstraint >
ERR
FileReadProcessor< CompletionConstraint >::ErrFileReadAndProcess(
	FileReadInterface&	fri,			// how to read file
	const QWORD			ibFile,			// what portion of file to read
	const DWORD			cbBlock,		// how much data to read -- never causes us to read past end of file
	BYTE* const			pbBlock,		// where to put file data
	const DWORD			cbIO,			// size of IO
	ChunkProcessor&		cp )			// how to process data in order
	{
	ERR	err = JET_errSuccess;

	//  we will retry failed reads during backup in the hope of saving the
	//  backup set

	const TICK	tickStart	= TickOSTimeCurrent();
	const TICK	tickBackoff	= 100;
	const int	cRetry		= 16;

	int			iRetry		= 0;
	
	do
		{
		err = JET_errSuccess;
		
		// algorithm for issuing as many IOs as possible to FileReadInterface and processing each IO
		// with ChunkProcessor with any ordering constraint as specified by the template parameter.

		Assert( cbBlock > 0 );
		Assert( pbBlock );
		Assert( cbIO > 0 );
				
		const DWORD	cIOs = 1 + ( cbBlock - 1 ) / cbIO;	// number of IOs we'll try to kick off
		CompletionConstraint	ioc( cIOs, &err );
		Call( err );

			{
			FileReadProcessor	frio( pbBlock, cbBlock, cbIO, ioc, cp );

			for ( DWORD iIO = 0;
				( iIO < cIOs ) && ( err >= 0 ) && ioc.FContinueIssuing();
				++iIO )
				{
				const DWORD cbBefore = iIO * cbIO;
				const DWORD cb = min( cbIO, cbBlock - cbBefore );

				err = fri.FileRead( ibFile + cbBefore, cb, pbBlock + cbBefore, &frio );

				if ( err >= 0 )
					{
					ioc.Issue();
					}
				}

			// need to ensure IOs have been issued if we're indeed going to wait
			const ERR errWait = ioc.ErrWaitForAll( ISSUEIOS( fri ) );

			Call( err );		// Die on original error, if exists
			Call( errWait );	// Die on wait error, if exists
			}

	HandleError:
		if ( err < JET_errSuccess )
			{
			if ( iRetry < cRetry )
				{
				UtilSleep( ( iRetry + 1 ) * tickBackoff );
				}
			}
		else
			{
			if ( iRetry > 0 )
				{
				const _TCHAR*	rgpsz[ 5 ];
				DWORD			irgpsz		= 0;
				_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
				_TCHAR			szOffset[ 64 ];
				_TCHAR			szLength[ 64 ];
				_TCHAR			szFailures[ 64 ];
				_TCHAR			szElapsed[ 64 ];

				CallS( fri.ErrPath( szAbsPath ) );
				_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibFile, ibFile );
				_stprintf( szLength, _T( "%u (0x%08x)" ), cbBlock, cbBlock );
				_stprintf( szFailures, _T( "%i" ), iRetry );
				_stprintf( szElapsed, _T( "%g" ), ( TickOSTimeCurrent() - tickStart ) / 1000.0 );
		
				rgpsz[ irgpsz++ ]	= szAbsPath;
				rgpsz[ irgpsz++ ]	= szOffset;
				rgpsz[ irgpsz++ ]	= szLength;
				rgpsz[ irgpsz++ ]	= szFailures;
				rgpsz[ irgpsz++ ]	= szElapsed;

				UtilReportEvent(	eventError,
									LOGGING_RECOVERY_CATEGORY,
									TRANSIENT_READ_ERROR_DETECTED_ID,
									irgpsz,
									rgpsz );
				}
			}
		}
	while ( iRetry++ < cRetry && err < JET_errSuccess );

	return err;
	}

//	Bridge between LOGVERIFIER and ChunkProcessor interface

class LogChunkVerifier : public ChunkProcessor
	{
public:
	LogChunkVerifier( LOGVERIFIER* pLogVerifier, const BYTE* const pbBlock, const DWORD cbBlock, const DWORD cbChunk )
		: m_pLogVerifier( pLogVerifier ), m_pbBlock( pbBlock ), m_cbBlock( cbBlock ), m_cbChunk( cbChunk )
		{
		Assert( pLogVerifier );
		Assert( pbBlock );
		Assert( cbBlock > 0 );
		Assert( cbChunk > 0 );
		}

	ERR ErrProcessChunk( const DWORD ichunk )
		{
		Assert( m_cbChunk > 0 );
		// bytes before our chunk
		const DWORD cbBefore = ichunk * m_cbChunk;
		Assert( m_pbBlock );
		const BYTE* const pb = m_pbBlock + cbBefore;
		Assert( m_cbBlock > cbBefore );
		// ensure that we properly size last chunk which may be less than m_cbChunk
		const DWORD cb = min( m_cbChunk, m_cbBlock - cbBefore );
		
		Assert( cb > 0 );
		Assert( m_pLogVerifier );
		return m_pLogVerifier->ErrVerify( pb, cb );
		}

private:
	LOGVERIFIER* const	m_pLogVerifier;
	const BYTE* const	m_pbBlock;
	const DWORD			m_cbBlock;
	const DWORD			m_cbChunk;
	};

//	Bridge between SLVVERIFIER and ChunkProcessor interface

class SLVChunkVerifier : public ChunkProcessor
	{
public:
	SLVChunkVerifier
		(
		const SLVVERIFIER* const pSLVVerifier,	// Verifier we'll use
		const BYTE* const pb,				// start of the big block with the many chunks
		const DWORD cb,						// size of entire block
		const DWORD cbChunk,				// size of each chunk in the block (last chunk may be smaller than this)
		IFileAPI* const	pfapi,				// SLV file
		const QWORD ibFile					// what portion of the SLV file are we looking at?
		)
		: m_pSLVVerifier( pSLVVerifier ), m_pb( pb ), m_cbBlock( cb ), m_cbChunk( cbChunk ), m_pfapi( pfapi ), m_ib( ibFile )
		{
		Assert( pSLVVerifier );
		Assert( pb );
		Assert( cb > 0 );
		Assert( cbChunk > 0 );
		Assert( pfapi );
		}
		
	// for each chunk of size m_cbChunk (or less in the case of the last chunk) inside of [ m_pb, m_pb + SLVPAGE_SIZE * cpg ]
	// where each chunk contains up to ( m_cbChunk / SLVPAGE_SIZE ) # of pages
	
	ERR	ErrProcessChunk( const DWORD ichunk )
		{
		Assert( m_cbChunk > 0 );
		// bytes before our chunk
		const DWORD cbBefore = ichunk * m_cbChunk;
		Assert( m_pb );
		const BYTE* const pb = m_pb + cbBefore;
		Assert( m_cbBlock > cbBefore );
		// ensure that we properly size last chunk which may be less than m_cbChunk
		const DWORD cb = min( m_cbChunk, m_cbBlock - cbBefore );
		const QWORD ib = m_ib + cbBefore;
		
		// call into SLVVERIFIER
		Assert( m_pSLVVerifier );
		return m_pSLVVerifier->ErrVerify(
			pb,											// SLV page data starts here
			cb,												// for this many pages.
			ib		// SLV page number for first page in pbChunk
			);
		}
		
private:
	const SLVVERIFIER* const	m_pSLVVerifier;
	const BYTE* const			m_pb;
	const DWORD					m_cbBlock;
	const DWORD					m_cbChunk;
	IFileAPI* const				m_pfapi;
	const QWORD					m_ib;
	};

class PatchChunkVerifier : public ChunkProcessor
	{
public:
	PatchChunkVerifier
		(
		const BYTE* const pb,				// start of the read block
		const DWORD cb,						// size of entire block
		const DWORD cbChunk,				// size of each chunk in the block (last chunk may be smaller than this)
		IFileAPI* const	pfapi,				// patch file
		const QWORD ibFile					// what portion of the patch file are we looking at?
		)
		: m_pb( pb ), m_cb( cb ), m_cbChunk( cbChunk ), m_pfapi( pfapi ), m_ib( ibFile )
		{
		Assert( pb );
		Assert( cb > 0 );
		Assert( cbChunk > 0 );
		Assert( pfapi );
		}
//	virtual ERR ErrProcessChunk( const DWORD ichunk ) = 0;
	ERR	ErrProcessChunk( const DWORD ichunk )
		{
		ERR		err			= JET_errSuccess;
		
		//  get parameters for the chunk to process
		
		size_t	ibStart		= ichunk * m_cbChunk;
		size_t	ibEnd		= ibStart + min( m_cbChunk, m_cb - ibStart );

		QWORD	ibOffset	= m_ib + ibStart;

		//  process each page of this chunk

		size_t ib;
		for ( ib = ibStart; ib < ibEnd; ib += g_cbPage, ibOffset += g_cbPage )
			{
			//  get page

			const BYTE* pbPage = m_pb + ib;
			
			//  check page

			const ULONG	ulChecksumExpected	= *( (LittleEndian<DWORD>*)pbPage );
			const ULONG	ulChecksumActual	= UlUtilChecksum( pbPage, g_cbPage );

			//  if the checksum doesn't match then we have failed verification
			
			if ( ulChecksumExpected != ulChecksumActual )
				{
				const _TCHAR*	rgpsz[ 6 ];
				DWORD			irgpsz		= 0;
				_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
				_TCHAR			szOffset[ 64 ];
				_TCHAR			szLength[ 64 ];
				_TCHAR			szError[ 64 ];
				_TCHAR			szChecksumExpected[ 64 ];
				_TCHAR			szChecksumActual[ 64 ];

				CallS( m_pfapi->ErrPath( szAbsPath ) );
				_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibOffset, ibOffset );
				_stprintf( szLength, _T( "%u (0x%08x)" ), g_cbPage, g_cbPage );
				_stprintf( szError, _T( "%i (0x%08x)" ), JET_errReadVerifyFailure, JET_errReadVerifyFailure );
				_stprintf( szChecksumExpected, _T( "%u (0x%08x)" ), ulChecksumExpected, ulChecksumExpected );
				_stprintf( szChecksumActual, _T( "%u (0x%08x)" ), ulChecksumActual, ulChecksumActual );

				rgpsz[ irgpsz++ ]	= szAbsPath;
				rgpsz[ irgpsz++ ]	= szOffset;
				rgpsz[ irgpsz++ ]	= szLength;
				rgpsz[ irgpsz++ ]	= szError;
				rgpsz[ irgpsz++ ]	= szChecksumExpected;
				rgpsz[ irgpsz++ ]	= szChecksumActual;

				UtilReportEvent(	eventError,
									LOGGING_RECOVERY_CATEGORY,
									PATCH_PAGE_CHECKSUM_MISMATCH_ID,
									irgpsz,
									rgpsz );

				Call( ErrERRCheck( JET_errReadVerifyFailure ) );
				}
			}

		//  this chunk verified
		
		return JET_errSuccess;
		
	HandleError:
		return err;
		}
		
private:
	const BYTE* const			m_pb;
	const DWORD					m_cb;
	const DWORD					m_cbChunk;
	IFileAPI* const				m_pfapi;
	const QWORD					m_ib;
	};


//	====================================================
//	Spin off IOs of optimal size to fill buffer.
//	As IOs complete, if its chunk in the buffer is the next to checksum,
//	checksum that along with any other chunks forward in the buffer that
//	have also completed. If it's not the chunk's turn to checksum, simply
//	make a note that it should be checksummed later (it will be checksummed
//	by the chunk who's turn comes up next).
//	====================================================
	

// *********************************************************** END log verification stuff

ERR ISAMAPI ErrIsamOpenFile(
	JET_INSTANCE jinst,
	const CHAR *szFileName,
	JET_HANDLE		*phfFile,
	ULONG			*pulFileSizeLow,
	ULONG			*pulFileSizeHigh )
	{
	INST *pinst = (INST *)jinst;
	return pinst->m_plog->ErrLGBKOpenFile( pinst->m_pfsapi, szFileName, phfFile, pulFileSizeLow, pulFileSizeHigh, fFalse );
	}
	
ERR LOG::ErrLGBKOpenFile(
	IFileSystemAPI *const	pfsapi,
	const CHAR					*szFileName,
	JET_HANDLE					*phfFile,
	ULONG						*pulFileSizeLow,
	ULONG						*pulFileSizeHigh,
	const BOOL					fIncludePatch )
	{
	ERR		err;
	INT		irhf;
	IFMP	ifmpT;
	CHAR	szDirT[IFileSystemAPI::cchPathMax];
	CHAR	szFNameT[IFileSystemAPI::cchPathMax];
	CHAR	szExtT[IFileSystemAPI::cchPathMax];
	
	if ( !m_fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}

	if ( NULL == szFileName || 0 == *szFileName )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	/*	allocate rhf from rhf array.
	/**/
	if ( m_crhfMac < crhfMax )
		{
		irhf = m_crhfMac;
		m_crhfMac++;
		}
	else
		{
		Assert( m_crhfMac == crhfMax );
		for ( irhf = 0; irhf < crhfMax; irhf++ )
			{
			if ( !m_rgrhf[irhf].fInUse )
				{
				break;
				}
			}
		}
	if ( irhf == crhfMax )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
		
	Assert( irhf < m_crhfMac );

	CallR ( pfsapi->ErrPathComplete( szFileName, szFNameT ) );

	m_rgrhf[irhf].fInUse		= fTrue;
	m_rgrhf[irhf].fDatabase		= fFalse;
	m_rgrhf[irhf].fIsLog		= fFalse;
	m_rgrhf[irhf].pLogVerifier	= pNil;
	m_rgrhf[irhf].pSLVVerifier	= pNil;
	m_rgrhf[irhf].pfapi			= NULL;
	m_rgrhf[irhf].fIsSLVFile	= fFalse;
	m_rgrhf[irhf].ifmp			= ifmpMax;
	m_rgrhf[irhf].ib			= 0;
	m_rgrhf[irhf].cb			= 0;
	m_rgrhf[irhf].szFileName 	= NULL;


	Assert ( strlen(szFNameT) > 0 );
	m_rgrhf[irhf].szFileName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( sizeof(CHAR ) * ( 1 + strlen(szFNameT) ) ) );
	if ( NULL == m_rgrhf[irhf].szFileName )
		{
		m_rgrhf[irhf].fInUse = fFalse;
		CallR ( ErrERRCheck( JET_errOutOfMemory ) );
		}
	strcpy( m_rgrhf[irhf].szFileName, szFNameT );
	
	Assert ( backupStateLogsAndPatchs == m_fBackupStatus || backupStateDatabases == m_fBackupStatus );

	if ( m_fBackupSnapshot )
		{
		if ( backupStateDatabases == m_fBackupStatus )
			{
			return ErrERRCheck( JET_errInvalidBackupSequence );
			}
			
		Assert( !m_rgrhf[irhf].pfapi );
	   	m_rgrhf[irhf].fDatabase = fFalse;
	   	
		goto readLogOrPatch;
		}

	err = ErrDBOpenDatabase( m_ppibBackup, (CHAR *)szFileName, &ifmpT, 0 );
	Assert( err < 0 || err == JET_errSuccess || err == JET_wrnFileOpenReadOnly );
	if ( err < 0 && err != JET_errDatabaseNotFound )
		{
		goto HandleError;
		}
	if ( err == JET_errSuccess || err == JET_wrnFileOpenReadOnly )
		{
		PATCH_HEADER_PAGE *ppatchhdr;

		/*	should not open database if not performing full backup
		/**/
		if ( !m_fBackupFull )
			{
			Assert ( backupStateLogsAndPatchs == m_fBackupStatus );			
			CallS( ErrDBCloseDatabase( m_ppibBackup, ifmpT, 0 ) );
			Call ( ErrERRCheck( JET_errInvalidBackupSequence ) );
			}

		/*	should not open database if we are during log copy phase
		/**/
		if ( backupStateDatabases != m_fBackupStatus )
			{
			// it looks like it is called after ErrLGBKGetLogInfo
			Assert ( m_fBackupBeginNewLogFile );
			CallS( ErrDBCloseDatabase( m_ppibBackup, ifmpT, 0 ) );	
			Call ( ErrERRCheck( JET_errInvalidBackupSequence ) );
			}

		Assert( !m_rgrhf[irhf].pfapi );
	   	m_rgrhf[irhf].fDatabase = fTrue;
	   	m_rgrhf[irhf].ifmp = ifmpT;

		FMP		*pfmpT = &rgfmp[ifmpT];

		/*	database should be loggable or would not have been
		/*	given out for backup purposes.
		/**/
		Assert( pfmpT->FLogOn() );

		if ( fIncludePatch )
			{
			/*	create a local patch file
			/**/

			/*	patch file should be in database directory during backup. In log directory during
			 *	restore.
			 */

			CHAR  	szPatch[IFileSystemAPI::cchPathMax];

			LGIGetPatchName( m_pinst->m_pfsapi, szPatch, pfmpT->SzDatabaseName() );

#ifdef ELIMINATE_PATCH_FILE
			IFileAPI *pfapiPatch;
			Call( m_pinst->m_pfsapi->ErrFileCreate( szPatch, &pfapiPatch, fFalse, fFalse, fTrue ) );
			delete pfapiPatch;
#else
			pfmpT->ResetCpagePatch();

			/*	avoid aliasing of patch file pages by deleting
			/*	preexisting patch file if present
			/**/
			err = m_pinst->m_pfsapi->ErrFileDelete( szPatch );

			if ( err < 0 && err != JET_errFileNotFound )
				{
				goto HandleError;
				}
			Assert( pfmpT->CPatchIO() == 0 );
			IFileAPI *pfapiPatch;
			Call( m_pinst->m_pfsapi->ErrFileCreate( szPatch, &pfapiPatch ) );
			pfmpT->SetPfapiPatch( pfapiPatch );
			pfmpT->SetErrPatch( JET_errSuccess );
			Call( pfapiPatch->ErrSetSize( QWORD( cpgDBReserved ) * g_cbPage ) );
#endif	//	ELIMINATE_PATCH_FILE
			}

		Assert( pfmpT->PgnoCopyMost() == 0 );

		//	set backup database file size to current database file size
		//	(this simultaneously enables FBFIPatch())

		pfmpT->CritLatch().Enter();

		m_rgrhf[irhf].cb = pfmpT->CbFileSize();
		pfmpT->SetPgnoMost( pfmpT->PgnoLast() );
		pfmpT->ResetFCopiedPatchHeader();

		//	set the returned file size.
		// Must add on cpgDBReserved to accurately inform backup of file size

		m_rgrhf[irhf].cb += g_cbPage * cpgDBReserved;

#ifdef ELIMINATE_PATCH_FILE
		// we add the additional header added at the end
		// to replace information stored in the patch file header
		m_rgrhf[irhf].cb += g_cbPage;
#endif // ELIMINATE_PATCH_FILE

		pfmpT->CritLatch().Leave();
		
		//	setup patch file header for copy.

		if ( !( ppatchhdr = (PATCH_HEADER_PAGE *)PvOSMemoryPageAlloc( g_cbPage, NULL ) ) )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		pfmpT->SetPpatchhdr( ppatchhdr );

		// mark database as involved in an external backup
		pfmpT->SetInBackupSession();

#ifdef DEBUG
		if ( m_fDBGTraceBR )
			{
			const int cbFillBuffer = 128;
			char szTrace[cbFillBuffer + 1];
			szTrace[ cbFillBuffer ] = '\0';
			_snprintf( szTrace, cbFillBuffer, "START COPY DB %ld", pfmpT->PgnoMost() );
			CallS( ErrLGTrace( ppibNil, szTrace ) );

			m_cbDBGCopied = pfmpT->PgnoMost() * g_cbPage;
			}
#endif
		}
	else
		{
		Assert( err == JET_errDatabaseNotFound );
		Assert( !m_rgrhf[irhf].pfapi );
	   	m_rgrhf[irhf].fDatabase = fFalse;

		err = ErrDBOpenDatabaseBySLV( pfsapi, m_ppibBackup, (CHAR *)szFileName, &ifmpT );
		Assert ( JET_errSuccess >= err || JET_wrnFileOpenReadOnly == err );
		
		if ( backupStateDatabases == m_fBackupStatus )
			{
			// we are in backup databases mode but database file (edb or slv)
			// is not found in the FMP's.
			
			// UNDONE: we return JET_errDatabaseNotFound at this point
			// maybe we shell return something like "database unmounted" ...
			Call( err );

			Assert ( JET_errSuccess == err || JET_wrnFileOpenReadOnly == err );
			err = JET_errSuccess;

			FMP::AssertVALIDIFMP( ifmpT );

			m_rgrhf[irhf].fIsSLVFile = fTrue;
			m_rgrhf[irhf].ifmp = ifmpT;

			m_rgrhf[irhf].pSLVVerifier = new SLVVERIFIER( m_rgrhf[irhf].ifmp, &err );
			if ( ! m_rgrhf[irhf].pSLVVerifier )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			Call( err );
			
			/*  get the current size of the streaming file
			/**/
			Assert( rgfmp[ifmpT].PfapiSLV() );

			// wait until the STM extending process is done
			rgfmp[ifmpT].RwlSLVSpace().EnterAsReader();
			m_rgrhf[irhf].cb = rgfmp[ifmpT].CbTrueSLVFileSize();
			rgfmp[ifmpT].RwlSLVSpace().LeaveAsReader();
			
			}
		else
			{
readLogOrPatch:
			Assert ( backupStateLogsAndPatchs == m_fBackupStatus );

			// we backup just patch and log files at this point

			// UNDONE: check the format of the file (extension, etc.)

			Assert( !m_rgrhf[irhf].fDatabase );
			Assert( !m_rgrhf[irhf].fIsSLVFile );

			//	first try opening the file from the regular file-system

			IFileSystemAPI *pfsapiT = pfsapi;
			Assert( pfsapi == m_pinst->m_pfsapi );
			err = pfsapiT->ErrFileOpen( szFileName, &m_rgrhf[irhf].pfapi, fTrue );

			//	CONSIDER: Instead of checking extension, read in header to see if it's
			//	a valid log file header, else try to see if it's a valid patch file,
			//	else die because it's not a correct file that we recognize.
			//	Better yet, check if it's a log file first, since we open more log files
			//	than anything.

			CallS( pfsapiT->ErrPathParse( szFileName, szDirT, szFNameT, szExtT ) );
			m_rgrhf[irhf].fIsLog = ( UtilCmpFileName( szExtT, szLogExt ) == 0 );
				

			if ( JET_errFileNotFound == err )
				{
				const char * rgszT[] = { szFileName };

				UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
						BACKUP_LOG_FILE_MISSING_ERROR_ID, 1, rgszT, 0, NULL, m_pinst );
						
				err = ErrERRCheck( JET_errMissingFileToBackup );
				}
			Call( err );

			if ( m_rgrhf[irhf].fIsLog )
				{
				m_rgrhf[irhf].pLogVerifier = new LOGVERIFIER( m_rgrhf[irhf].pfapi, &err );
				if ( pNil == m_rgrhf[irhf].pLogVerifier )
					{
					Call( ErrERRCheck( JET_errOutOfMemory ) );
					}
				Call( err );
				}
			
			/*	get file size
			/**/
			// just opened the file, so the file size must be correctly buffered
			Call( m_rgrhf[irhf].pfapi->ErrSize( &m_rgrhf[irhf].cb ) );
			Assert( m_rgrhf[irhf].cb > 0 );			
			}
			
#ifdef DEBUG
		if ( m_fDBGTraceBR )
			m_cbDBGCopied = DWORD( m_rgrhf[irhf].cb );
#endif
		}
		
	*phfFile = (JET_HANDLE)irhf;
	{
	QWORDX cbFile;
	cbFile.SetQw( m_rgrhf[irhf].cb );
	*pulFileSizeLow = cbFile.DwLow();
	*pulFileSizeHigh = cbFile.DwHigh();
	}
	err = JET_errSuccess;


	// report start backup of file (report only EDB and STM)
	if ( m_rgrhf[irhf].fDatabase || m_rgrhf[irhf].fIsSLVFile )
		{
		char szSize[32];
		
		Assert ( m_rgrhf[irhf].szFileName );
		
		const char * rgszT[] = { m_rgrhf[irhf].szFileName, szSize };			

		if ( m_rgrhf[irhf].cb > QWORD(1024 * 1024) )
			{
			sprintf( szSize, "%I64u Mb", m_rgrhf[irhf].cb / QWORD(1024 * 1024) );
			}
		else
			{
			sprintf( szSize, "%I64u Kb", m_rgrhf[irhf].cb / QWORD(1024) );
			}
		
		UtilReportEvent( eventInformation, LOGGING_RECOVERY_CATEGORY, BACKUP_FILE_START, 2, rgszT, 0, NULL, m_pinst );

		{
		const int cbFillBuffer = 64 + IFileSystemAPI::cchPathMax;
		char szTrace[cbFillBuffer + 1];
		szTrace[ cbFillBuffer ] = '\0';
		_snprintf( szTrace, cbFillBuffer, "Start backup file %s, size %s", m_rgrhf[irhf].szFileName, szSize );
		(void) ErrLGTrace( m_ppibBackup, szTrace);
		}
		
		}	
	
HandleError:

#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];
	
		sprintf( sz, "** OpenFile (%d) %s of size %ld.\n", err, szFileName, m_cbDBGCopied );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		m_cbDBGCopied = 0;
		}
#endif

	if ( err < 0 )
		{
		// if they try to backup a unmounted database or we get an error on one database
		// we will not stop the backup
		// on all other errors (logs, patch files) we stop the backup of the instance
		if ( backupStateDatabases == m_fBackupStatus )
			{
			char szError[32];
			Assert ( m_rgrhf[irhf].szFileName );
			const char * rgszT[] = { szError, m_rgrhf[irhf].szFileName };			
			
			sprintf( szError, "%d", err );

			if ( m_rgrhf[irhf].ifmp < ifmpMax )
				{
				FMP * pfmpT = rgfmp + m_rgrhf[irhf].ifmp;
				Assert ( pfmpT );
				pfmpT->ResetInBackupSession();

				if ( pfmpT->Ppatchhdr() )
					{
					OSMemoryPageFree( pfmpT->Ppatchhdr() );
					pfmpT->SetPpatchhdr( NULL );
					}

				if ( fIncludePatch )
					{
					CHAR	szPatch[IFileSystemAPI::cchPathMax];

					// delete the created patch file
					// (we might be during STM file Open so, szPatch might not we set)

					//	UNDONE: Does this work?? If patch file was created, there might
					//	be a handle open on the file, in which case deletion will fail

					LGIGetPatchName( m_pinst->m_pfsapi, szPatch, rgfmp[ m_rgrhf[irhf].ifmp ].SzDatabaseName()  );
					ERR errAux;
					errAux = m_pinst->m_pfsapi->ErrFileDelete( szPatch );
					if ( JET_errFileNotFound == errAux )
						{
						errAux = JET_errSuccess;
						}
					CallSRFS( errAux, ( JET_errFileAccessDenied, 0 ) );
					}
				}

			UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,	BACKUP_ERROR_FOR_ONE_DATABASE, 2, rgszT );

			Assert( m_fBackupInProgress );
						
			/*	release file handle resource on error
			/**/
			Assert ( m_rgrhf[irhf].szFileName );
			OSMemoryHeapFree( m_rgrhf[irhf].szFileName );
			m_rgrhf[irhf].szFileName = NULL;	
			
			m_rgrhf[irhf].fInUse = fFalse;		
			}
		else
			{

			/*	release file handle resource on error
			/**/
			Assert ( m_rgrhf[irhf].szFileName );
			OSMemoryHeapFree( m_rgrhf[irhf].szFileName );
			m_rgrhf[irhf].szFileName = NULL;	
			
			m_rgrhf[irhf].fInUse = fFalse;		
			
			CallS( ErrLGBKIExternalBackupCleanUp( pfsapi, err ) );
			Assert( !m_fBackupInProgress );
			}
		}

	return err;
	}


ERR ISAMAPI ErrIsamReadFile( JET_INSTANCE jinst, JET_HANDLE hfFile, VOID *pv, ULONG cbMax, ULONG *pcbActual )
	{
	INST *pinst = (INST *)jinst;
	return pinst->m_plog->ErrLGBKReadFile( pinst->m_pfsapi, hfFile, pv, cbMax, pcbActual );
	}
	
ERR LOG::ErrLGBKReadFile(	IFileSystemAPI *const	pfsapi,
							JET_HANDLE					hfFile,
							VOID 						*pv,
							ULONG 						cbMax,
							ULONG 						*pcbActual )
	{
	ERR		err = JET_errSuccess;
	INT		irhf = (INT)hfFile;
	INT		cpage;
	VOID	*pvPageMin;
	FMP		*pfmpT;
	INT		cbActual = 0;

#ifdef DEBUG
	CHAR	*szLGDBGPageList = NULL;
#endif

	BOOL 	fInTransaction 	= fFalse;

	if ( !m_fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}

	if ( !m_rgrhf[irhf].fDatabase )
		{
		Assert ( ( backupStateLogsAndPatchs == m_fBackupStatus && !m_rgrhf[irhf].fIsSLVFile ) ||
				( backupStateDatabases == m_fBackupStatus && m_rgrhf[irhf].fIsSLVFile ) );
				
		// adding support for checksum
		// we need to impose page boundaries
		if ( ( cbMax % SLVPAGE_SIZE ) != 0 )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}			

		if ( 0 == cbMax || ( cbMax / SLVPAGE_SIZE < cpgDBReserved && 0 == m_rgrhf[irhf].ib ) )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}


		if ( ( cbMax % g_cbPage ) != 0 )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}			

		if ( cbMax / g_cbPage < cpgDBReserved && 0 == m_rgrhf[irhf].ib )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
				
		DWORD 		cbToRead 		= DWORD( min( m_rgrhf[irhf].cb - m_rgrhf[irhf].ib, cbMax ) );

		Assert ( 0 == ( cbToRead % SLVPAGE_SIZE ) );

		Assert ( 0 == ( cbToRead % g_cbPage ) );

		Assert ( 0 == m_ppibBackup->level );
		Call ( ErrDIRBeginTransaction( m_ppibBackup, NO_GRBIT ) );
		fInTransaction = fTrue;
		Assert ( 1 == m_ppibBackup->level );

		if ( cbToRead > 0 )
			{
			BYTE* const pb = reinterpret_cast< BYTE* const >( pv );
			const DWORD cbOptimal = 64 * 1024;

			// should be db page size multiple
			Assert ( 0 == ( cbOptimal % g_cbPage ) );
			
			if ( m_rgrhf[irhf].fIsLog )
				{
				Call( FileReadProcessor< INORDERCOMPLETION >::ErrFileReadAndProcess( OSFILEREAD( m_rgrhf[irhf].pfapi ),
					m_rgrhf[irhf].ib, cbToRead, pb, cbOptimal,
					LogChunkVerifier( m_rgrhf[irhf].pLogVerifier, pb, cbToRead, cbOptimal ) ) );
				}
			else if ( m_rgrhf[irhf].fIsSLVFile )
				{
				Call( m_rgrhf[irhf].pSLVVerifier->ErrGrabChecksums( m_rgrhf[irhf].ib, cbToRead, m_ppibBackup ) );

				FMP::AssertVALIDIFMP( m_rgrhf[irhf].ifmp );
				
				// standard file read API
				
				err = ErrFileReadAndProcessAnyOrder(	OSFILEREAD( rgfmp[ m_rgrhf[ irhf ].ifmp ].PfapiSLV() ),
														m_rgrhf[irhf].ib,
														cbToRead,
														pb,
														cbOptimal,
														SLVChunkVerifier(	m_rgrhf[irhf].pSLVVerifier,
																			pb,
																			cbToRead,
																			cbOptimal,
																			rgfmp[ m_rgrhf[ irhf ].ifmp ].PfapiSLV(),
																			m_rgrhf[irhf].ib ) );

				if ( err < 0 )
					{
					// delete SLVVerifier now so it'll DIRClose now, instead of trying to DIRClose
					// it later after it's already been closed (but we can't tell).
					//
					// yes, this looks kind of gross
					delete m_rgrhf[irhf].pSLVVerifier;
					m_rgrhf[irhf].pSLVVerifier = pNil;
					Call( err );
					}
					
				Call( m_rgrhf[irhf].pSLVVerifier->ErrDropChecksums() );
				}
			else
				{

				//	should be a patch file (patch files ALWAYS sit on the OS file-system)

				Call( ErrFileReadAndProcessAnyOrder( OSFILEREAD(  m_rgrhf[irhf].pfapi ),
					m_rgrhf[irhf].ib, cbToRead, pb, cbOptimal,
					PatchChunkVerifier( pb, cbToRead, cbOptimal, m_rgrhf[irhf].pfapi, m_rgrhf[irhf].ib ) ) );
				}
			}	// cbToRead > 0

		Assert ( 1 == m_ppibBackup->level );

		Call( ErrDIRCommitTransaction( m_ppibBackup, NO_GRBIT ) );
		fInTransaction = fFalse;
		Assert ( 0 == m_ppibBackup->level );
		
		m_rgrhf[irhf].ib += cbToRead;
		if ( pcbActual )
			{
			*pcbActual = cbToRead;
			}

		Assert( m_rgrhf[irhf].ib <= m_rgrhf[irhf].cb );
		if ( m_rgrhf[irhf].ib == m_rgrhf[irhf].cb && m_rgrhf[irhf].fIsLog )
			{
			// this is the last call to JetReadFile() that will return data.
			// If log verification isn't completed yet, we should return an error
			// now, instead of waiting for the JetCloseFile(), which clients
			// are likely to ignore the return code from.
			Assert( m_rgrhf[irhf].pLogVerifier );
			if ( ! m_rgrhf[irhf].pLogVerifier->FCompleted() )
				{
				// If log verification hasn't completed, which means it still
				// expects more data to checksum (i.e. bad LRCK), log file is hosed.
				Call( ErrERRCheck( JET_errLogReadVerifyFailure ) );
				}
			}

#ifdef DEBUG
		if ( m_fDBGTraceBR )
			m_cbDBGCopied += min( cbMax, *pcbActual );
#endif
		}
	else
		{
		Assert ( backupStateDatabases == m_fBackupStatus );
		FMP::AssertVALIDIFMP( m_rgrhf[irhf].ifmp );
		
		pfmpT = &rgfmp[ m_rgrhf[irhf].ifmp ];

		if ( ( cbMax % g_cbPage ) != 0 )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}

		cpage = cbMax / g_cbPage;

		// we need to read at least 2 pages for the database header
		if ( 0 == cpage || (cpage < cpgDBReserved && 0 == pfmpT->PgnoCopyMost() ) )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}

#ifdef DEBUG
	if ( m_fDBGTraceBR > 1 )
		{
		szLGDBGPageList = static_cast<CHAR *>( PvOSMemoryHeapAlloc( cpage * 20 ) );
		if ( szLGDBGPageList )
			{
			szLGDBGPageList[0] = '\0';
			}
		}
#endif

		// check database as involved in an external backup
		Assert ( pfmpT->FInBackupSession() );
		
		if ( cpage > 0 )
			{
			pvPageMin = pv;

			/*	read next cpageBackupBuffer pages
			/**/
#ifdef DEBUG
			Call( ErrLGBKReadPages(
				m_rgrhf[irhf].ifmp,
				pvPageMin,
				cpage,
				&cbActual,
				(BYTE *)szLGDBGPageList ) );
			
			if ( m_fDBGTraceBR )
				m_cbDBGCopied += cbActual;

			/*	if less then 16 M (4k * 4k),
			 *	then put an artificial wait.
			 */
#ifdef ELIMINATE_PATCH_FILE
#else
			if ( pfmpT->PgnoMost() <= 4096 )
				UtilSleep( rand() % 1000 );
#endif			

#else	//	DEBUG
			Call( ErrLGBKReadPages(
				m_rgrhf[irhf].ifmp,
				pvPageMin,
				cpage,
				&cbActual ) );
#endif	//	DEBUG

			// set the data read (used just to check at the end if all was read.
			m_rgrhf[irhf].ib += cbActual;
#ifdef ELIMINATE_PATCH_FILE
			Assert( (m_rgrhf[irhf].ib / g_cbPage) == (rgfmp[ m_rgrhf[irhf].ifmp ].PgnoCopyMost() + cpgDBReserved )
					|| ( (rgfmp[ m_rgrhf[irhf].ifmp ].PgnoCopyMost() == rgfmp[ m_rgrhf[irhf].ifmp ].PgnoMost() ) 
						&& (m_rgrhf[irhf].ib / g_cbPage) == (rgfmp[ m_rgrhf[irhf].ifmp ].PgnoCopyMost() + cpgDBReserved + 1) ) );
#else // ELIMINATE_PATCH_FILE
			Assert( (m_rgrhf[irhf].ib / g_cbPage) == (rgfmp[ m_rgrhf[irhf].ifmp ].PgnoCopyMost() + cpgDBReserved ) );
#endif // ELIMINATE_PATCH_FILE
			}

		if ( pcbActual )
			{
			*pcbActual = cbActual;
			}
		}

HandleError:

	if ( fInTransaction )
		{
		CallSx ( ErrDIRRollback( m_ppibBackup ), JET_errRollbackError );
		fInTransaction = fFalse;
		}

#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];
	
		sprintf( sz, "** ReadFile (%d) ", err );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		if ( m_fDBGTraceBR > 1 )
			DBGBRTrace( szLGDBGPageList );		
		DBGBRTrace( "\n" );
		}
	if (szLGDBGPageList)
		{
		OSMemoryHeapFree( (void *)szLGDBGPageList );
		szLGDBGPageList = NULL;
		}
#endif
	
	if ( m_rgrhf[irhf].fDatabase && pfmpT->ErrPatch() < JET_errSuccess )		//lint !e644
		err = pfmpT->ErrPatch();

	if ( err < 0 )
		{
		char szError[32];
		Assert ( m_rgrhf[irhf].szFileName );
		
		const CHAR	* rgszT[] = { szError, m_rgrhf[irhf].szFileName };			

		sprintf( szError, "%d", err );						
		
		// if they try to backup a unmounted database or we get an error on one database
		// we will not stop the backup
		// on all other errors (logs, patch files) we stop the backup of the instance
		if ( backupStateDatabases == m_fBackupStatus )
			{	
			FMP::AssertVALIDIFMP( m_rgrhf[irhf].ifmp );
			
			FMP * pfmpT = rgfmp + m_rgrhf[irhf].ifmp;
			Assert ( pfmpT );
			Assert ( pfmpT->FInBackupSession() );
			pfmpT->ResetInBackupSession();

			if ( pfmpT->Ppatchhdr() )
				{
				OSMemoryPageFree( pfmpT->Ppatchhdr() );
				pfmpT->SetPpatchhdr( NULL );
				}
	
#ifdef ELIMINATE_PATCH_FILE
#else
			// delete the created patch file
			CHAR  	szPatch[IFileSystemAPI::cchPathMax];
			
			LGIGetPatchName( m_pinst->m_pfsapi, szPatch, pfmpT->SzDatabaseName()  );
#endif

			UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,	
				BACKUP_ERROR_FOR_ONE_DATABASE, 2, rgszT, 0, NULL, m_pinst );

			CallS( ErrLGBKCloseFile( hfFile ) );

#ifdef ELIMINATE_PATCH_FILE
#else
			// delete the patch now, that we closed the patch file
			CallSRFS( m_pinst->m_pfsapi->ErrFileDelete( szPatch ), ( JET_errFileAccessDenied, 0 ) );
#endif
			
			Assert( m_fBackupInProgress );
			}
		else
			{
			UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,	
				BACKUP_ERROR_READ_FILE, 2, rgszT, 0, NULL, m_pinst );
			
			CallS( ErrLGBKIExternalBackupCleanUp( pfsapi, err ) );
			Assert( !m_fBackupInProgress );
			}
		}

	return err;
	}


#ifdef ELIMINATE_PATCH_FILE
#else
VOID LGIClosePatchFile( FMP *pfmp )
	{
	IFileAPI *pfapiT = pfmp->PfapiPatch();
	
	for (;;)
		{
		pfmp->CritLatch().Enter();
		
		if ( pfmp->CPatchIO() )
			{
			pfmp->CritLatch().Leave();
			UtilSleep( 1 );
			continue;
			}
		else
			{
			/*	no need for buffer manager to make extra copy from now on
			/**/
			pfmp->SetPgnoMost( 0 );
			pfmp->SetPgnoCopyMost( 0 );
			pfmp->ResetFCopiedPatchHeader();
			pfmp->SetPfapiPatch( NULL );
			pfmp->CritLatch().Leave();
			break;
			}
		}

	delete pfapiT;
	}
#endif	//	ELIMINATE_PATCH_FILE


ERR ISAMAPI ErrIsamCloseFile( JET_INSTANCE jinst,  JET_HANDLE hfFile )
	{
	INST *pinst = (INST*) jinst;
	return pinst->m_plog->ErrLGBKCloseFile( hfFile );
	}
	
ERR LOG::ErrLGBKCloseFile( JET_HANDLE hfFile )
	{
	INT		irhf = (INT)hfFile;
	IFMP	ifmpT = ifmpMax;

	if ( !m_fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}

	if ( irhf < 0 ||
		irhf >= m_crhfMac ||
		!m_rgrhf[irhf].fInUse )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	/*	check if handle if for database file or non-database file.
	/*	if handle is for database file, then terminate patch file
	/*	support and release recovery handle for file.
	/*
	/*	if handle is for non-database file, then close file handle
	/*	and release recovery handle for file.
	/**/
	if ( m_rgrhf[irhf].fDatabase )
		{
		Assert( backupStateDatabases == m_fBackupStatus );
		Assert( !m_rgrhf[irhf].pfapi );
		FMP::AssertVALIDIFMP( m_rgrhf[irhf].ifmp );
		
		ifmpT = m_rgrhf[irhf].ifmp;

#ifdef ELIMINATE_PATCH_FILE
		rgfmp[ifmpT].SetPgnoMost( 0 );
		rgfmp[ifmpT].SetPgnoCopyMost( 0 );
		rgfmp[ifmpT].ResetFCopiedPatchHeader();
#else
		LGIClosePatchFile( &rgfmp[ifmpT] );
#endif

		// Assert no longer valid as we reset this flag defore
		// calling CloseFile in ReadFile on error
		
		// check database as involved in an external backup
		// Assert ( rgfmp[ifmpT].FInBackupSession() );		

#ifdef DEBUG
		if ( m_fDBGTraceBR )
			{
			const int cbFillBuffer = 64;
			char szTrace[cbFillBuffer + 1];
			szTrace[ cbFillBuffer ] = '\0';
			_snprintf( szTrace, cbFillBuffer, "STOP COPY DB" );
			CallS( ErrLGTrace( ppibNil, szTrace ) );
			}
#endif

		// if the scrub object is left because they haven't read
		// all the pages from the db, hence we haven't stopped 
		// the scrubbing at the end of the ReadFile phase
		if( m_pscrubdb )
			{
			CallS( m_pscrubdb->ErrTerm() );	// may fail with JET_errOutOfMemory. what to do?
			delete m_pscrubdb;
			m_pscrubdb = NULL;
			}

		CallS( ErrDBCloseDatabase( m_ppibBackup, ifmpT, 0 ) );
		}
	else
		{
		Assert ( ( backupStateLogsAndPatchs == m_fBackupStatus && !m_rgrhf[irhf].fIsSLVFile ) ||
				( backupStateDatabases == m_fBackupStatus && m_rgrhf[irhf].fIsSLVFile ) );
				
		if ( m_rgrhf[irhf].fIsSLVFile )
			{			
			delete m_rgrhf[irhf].pSLVVerifier;
			m_rgrhf[irhf].pSLVVerifier = pNil;

			CallS( ErrDBCloseDatabaseBySLV( m_ppibBackup, m_rgrhf[irhf].ifmp ) );

			Assert( !m_rgrhf[irhf].pfapi );
			}
		else
			{
			delete m_rgrhf[irhf].pfapi;
			m_rgrhf[irhf].pfapi = NULL;
			}
			
		if ( m_rgrhf[irhf].fIsLog )
			{
			delete m_rgrhf[irhf].pLogVerifier;
			m_rgrhf[irhf].pLogVerifier = pNil;
			}
		}

	// report end backup of file
		{
		char szSizeRead[32];
		char szSizeAll[32];
		
		Assert ( m_rgrhf[irhf].szFileName );
		
		const char * rgszT[] = { m_rgrhf[irhf].szFileName, szSizeRead, szSizeAll };			

		if ( m_rgrhf[irhf].ib == m_rgrhf[irhf].cb )
			{
			// if all file read, report just EDB ans STM files
			if ( m_rgrhf[irhf].fDatabase || m_rgrhf[irhf].fIsSLVFile )
				{
				UtilReportEvent( eventInformation, LOGGING_RECOVERY_CATEGORY, BACKUP_FILE_STOP_OK, 1, rgszT, 0, NULL, m_pinst );
				}
			}
		else
		// if not all file was read, issue a warning
			{
			sprintf( szSizeRead, "%I64u", m_rgrhf[irhf].ib );
			sprintf( szSizeAll, "%I64u", m_rgrhf[irhf].cb );
			
			UtilReportEvent( eventInformation, LOGGING_RECOVERY_CATEGORY, BACKUP_FILE_STOP_BEFORE_END, 3, rgszT, 0, NULL, m_pinst );
			}

		if ( m_rgrhf[irhf].fDatabase || m_rgrhf[irhf].fIsSLVFile )
			{
			const int cbFillBuffer = 64 + IFileSystemAPI::cchPathMax;
			char szTrace[cbFillBuffer + 1];
			szTrace[ cbFillBuffer ] = '\0';
			_snprintf( szTrace, cbFillBuffer, "Stop backup file %s", m_rgrhf[irhf].szFileName );
			(void) ErrLGTrace( m_ppibBackup, szTrace);
			}
		
		}	

	OSMemoryHeapFree( m_rgrhf[irhf].szFileName );
	
	/*	reset backup file handle and free
	/**/
	Assert( m_rgrhf[irhf].fInUse );
	
	m_rgrhf[irhf].fInUse			= fFalse;
	m_rgrhf[irhf].fDatabase			= fFalse;
	m_rgrhf[irhf].fIsLog			= fFalse;
	m_rgrhf[irhf].pLogVerifier		= pNil;
	m_rgrhf[irhf].pSLVVerifier		= pNil;
	m_rgrhf[irhf].pfapi				= NULL;
	m_rgrhf[irhf].fIsSLVFile		= fFalse;
	m_rgrhf[irhf].ifmp				= ifmpMax;
	m_rgrhf[irhf].ib				= 0;
	m_rgrhf[irhf].cb				= 0;
	m_rgrhf[irhf].szFileName 		= NULL;

#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];
		
		sprintf( sz, "** CloseFile (%d) - %ld Bytes.\n", 0, m_cbDBGCopied );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif
	
	return JET_errSuccess;
	}

ERR LOG::ErrLGBKIPrepareLogInfo(	IFileSystemAPI *const 	pfsapi )
	{
	ERR		err = JET_errSuccess;
	INT		irhf;
	CHAR	szPathJetChkLog[IFileSystemAPI::cchPathMax];

	if ( !m_fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}

	/*	all backup files must be closed
	/**/
	for ( irhf = 0; irhf < m_crhfMac; irhf++ )
		{
		if ( m_rgrhf[irhf].fInUse )
			{
			return ErrERRCheck( JET_errInvalidBackupSequence );
			}
		}

	Assert ( backupStateDatabases == m_fBackupStatus || backupStateLogsAndPatchs == m_fBackupStatus );


	/*	begin new log file and compute log backup parameters
	/**/
	if ( !m_fBackupBeginNewLogFile )
		{
		Call( ErrLGBKPrepareLogFiles(
			pfsapi,
			m_fBackupFull ?0: (m_fBackupSnapshot? JET_bitBackupSnapshot:JET_bitBackupIncremental ),
			m_szLogFilePath,
			szPathJetChkLog,
			NULL ) );
		}
		
HandleError:
	return err;
	}
	
ERR LOG::ErrLGBKIGetLogInfo(	IFileSystemAPI *const 	pfsapi,
								const ULONG					ulGenLow,
								const ULONG					ulGenHigh,
								const BOOL					fIncludePatch,
								VOID 						*pv,
								ULONG 						cbMax,
								ULONG 						*pcbActual,
								JET_LOGINFO 				*pLogInfo )
	{
	ERR			err = JET_errSuccess;
	LONG		lT;
	CHAR		*pch = NULL;
	CHAR		*pchT;
	ULONG		cbActual;
	CHAR		szDirT[IFileSystemAPI::cchPathMax];
	CHAR		szFNameT[IFileSystemAPI::cchPathMax];
	CHAR		szExtT[IFileSystemAPI::cchPathMax];
	CHAR  		szT[IFileSystemAPI::cchPathMax];
	CHAR  		szFullLogFilePath[IFileSystemAPI::cchPathMax];

	/*	make full path from log file path, including trailing back slash
	/**/
	CallR( pfsapi->ErrPathComplete( m_szLogFilePath, szFullLogFilePath ) );
	
#ifdef DEBUG
	if ( m_fDBGTraceBR )
		DBGBRTrace("** Begin GetLogInfo.\n" );
#endif

	Assert( FOSSTRTrailingPathDelimiter( szFullLogFilePath ) ||
			strlen( szFullLogFilePath ) + 1 + 1 <= sizeof( szFullLogFilePath ) );
	OSSTRAppendPathDelimiter( szFullLogFilePath, fTrue );

	Assert ( m_fBackupBeginNewLogFile );
	
	/*	get cbActual for log file and patch files.
	/**/
	cbActual = 0;

	CallS( pfsapi->ErrPathParse( szFullLogFilePath, szDirT, szFNameT, szExtT ) );
	for ( lT = ulGenLow; lT < ulGenHigh; lT++ )
		{
		LGSzFromLogId( szFNameT, lT );
		LGMakeName( pfsapi, szT, szDirT, szFNameT, (CHAR *)szLogExt );
		cbActual += (ULONG) strlen( szT ) + 1;
		}

	if ( fIncludePatch )
		{
		/*	put all the patch file info
		/**/
		for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			IFMP 	ifmp = m_pinst->m_mpdbidifmp[ dbid ];
			if ( ifmp >= ifmpMax )
				continue;

			FMP *	pfmp = &rgfmp[ifmp];

			if ( pfmp->FInUse()
//				&& pfmp->CpagePatch() > 0
				&& pfmp->FAttached()
				&& pfmp->FInBackupSession() )
				{
				Assert( !pfmp->FSkippedAttach() );
				Assert( !pfmp->FDeferredAttach() );

				/*	database with patch file must be loggable
				/**/

				Assert( pfmp->FLogOn() );
				LGIGetPatchName( m_pinst->m_pfsapi, szT, pfmp->SzDatabaseName() );
				cbActual += (ULONG) strlen( szT ) + 1;
				}
			}
		}
	cbActual++;

	pch = static_cast<CHAR *>( PvOSMemoryHeapAlloc( cbActual ) );
	if ( pch == NULL )
		{
		Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
		}

	/*	return list of log files and patch files
	/**/
	pchT = pch;

	CallS( pfsapi->ErrPathParse( szFullLogFilePath, szDirT, szFNameT, szExtT ) );
	for ( lT = ulGenLow; lT < ulGenHigh; lT++ )
		{
		LGSzFromLogId( szFNameT, lT );
		LGMakeName( pfsapi, szT, szDirT, szFNameT, (CHAR *)szLogExt );
		Assert( pchT + strlen( szT ) + 1 < pchT + cbActual );
		strcpy( pchT, szT );
		pchT += strlen( szT );
		Assert( *pchT == 0 );
		pchT++;
		}

	// on snapshot we don't have patch file
	if ( fIncludePatch )
		{
		/*	copy all the patch file info
		/**/
		for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
			{
			IFMP 	ifmp = m_pinst->m_mpdbidifmp[ dbid ];
			if ( ifmp >= ifmpMax )
				continue;

			FMP *	pfmp = &rgfmp[ifmp];

			if ( pfmp->FInUse()
				&& pfmp->FAttached()
				&& pfmp->FInBackupSession() )
				{
				Assert( !pfmp->FSkippedAttach() );
				Assert( !pfmp->FDeferredAttach() );

				LGIGetPatchName( m_pinst->m_pfsapi, szT, pfmp->SzDatabaseName() );
				Assert( pchT + strlen( szT ) + 1 < pchT + cbActual );
				strcpy( pchT, szT );
				pchT += strlen( szT );
				Assert( *pchT == 0 );
				pchT++;

				/*	Write out patch file header.
				 */
				DBFILEHDR_FIX *	const	pdbfilehdr	= (DBFILEHDR_FIX *)pfmp->Ppatchhdr();
				Assert( NULL != pdbfilehdr );

#ifdef ELIMINATE_PATCH_FILE
#else
				memcpy( pdbfilehdr, pfmp->Pdbfilehdr(), g_cbPage );

				BKINFO * const			pbkinfo		= &pdbfilehdr->bkinfoFullCur;
				pbkinfo->le_lgposMark = m_lgposFullBackupMark;
				pbkinfo->logtimeMark = m_logtimeFullBackupMark;
				pbkinfo->le_genLow = m_lgenCopyMic;
				pbkinfo->le_genHigh = m_lgenCopyMac - 1;
#endif

				Call( ErrUtilWriteShadowedHeader( m_pinst->m_pfsapi, szT, fFalse, (BYTE*)pdbfilehdr, g_cbPage ) );
				}
			}
		}
	Assert( pchT == pch + cbActual - 1 );
	*pchT = 0;

	/*	return cbActual
	/**/
	if ( pcbActual != NULL )
		{
		*pcbActual = cbActual;
		}

	/*	return data
	/**/
	if ( pv != NULL )
		UtilMemCpy( pv, pch, min( cbMax, cbActual ) );

HandleError:

	if ( pch != NULL )
		{
		OSMemoryHeapFree( pch );
		pch = NULL;
		}
	
#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];
		CHAR *pch;

		if ( err >= 0 )
			{
			sprintf( sz, "   Log Info with cbActual = %d and cbMax = %d :\n", cbActual, cbMax );
			Assert( strlen( sz ) <= sizeof( sz ) - 1 );
			DBGBRTrace( sz );

			if ( pv != NULL )
				{
				pch = static_cast<CHAR *>( pv );

				do {
					if ( strlen( pch ) != 0 )
						{
						sprintf( sz, "     %s\n", pch );
						Assert( strlen( sz ) <= sizeof( sz ) - 1 );
						DBGBRTrace( sz );
						pch += strlen( pch );
						}
					pch++;
					} while ( *pch );
				}
			}

		sprintf( sz, "   End GetLogInfo (%d).\n", err );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif

	if ( err < 0 )
		{
		CallS( ErrLGBKIExternalBackupCleanUp( pfsapi, err ) );
		Assert( !m_fBackupInProgress );
		}
	else
		{
		if ( NULL != pLogInfo )
			{
			Assert ( pLogInfo->cbSize == sizeof( JET_LOGINFO ) );
			
			pLogInfo->ulGenLow = ulGenLow;
			pLogInfo->ulGenHigh = ulGenHigh - 1;
			Assert ( JET_BASE_NAME_LENGTH == strlen( m_szBaseName ) );
			strcpy( pLogInfo->szBaseName, m_szBaseName );
			}
			
		Assert ( backupStateDatabases == m_fBackupStatus || backupStateLogsAndPatchs == m_fBackupStatus );
		// switch to the LogAndPatch status
		m_fBackupStatus = backupStateLogsAndPatchs;
		}
	return err;
	}


ERR ISAMAPI ErrIsamGetLogInfo( JET_INSTANCE jinst,  VOID *pv, ULONG cbMax, ULONG *pcbActual, JET_LOGINFO *pLogInfo )
	{
	INST *pinst = (INST *)jinst;
	return pinst->m_plog->ErrLGBKGetLogInfo( pinst->m_pfsapi, pv, cbMax, pcbActual, pLogInfo, fFalse );
	}
	
ERR LOG::ErrLGBKGetLogInfo(	IFileSystemAPI *const 	pfsapi,
							VOID 						*pv,
							ULONG 						cbMax,
							ULONG 						*pcbActual,
							JET_LOGINFO 				*pLogInfo,
							const BOOL					fIncludePatch )
	{
	ERR		err = JET_errSuccess;

	CallR ( ErrLGBKIPrepareLogInfo( pfsapi ) );

	Assert ( m_lgenCopyMic );
	Assert ( m_lgenCopyMac );
	Assert ( m_lgenCopyMic <= m_lgenCopyMac );
	return ErrLGBKIGetLogInfo( pfsapi, m_lgenCopyMic, m_lgenCopyMac, fIncludePatch, pv, cbMax, pcbActual, pLogInfo );
	}

	
ERR ISAMAPI ErrIsamGetTruncateLogInfo( JET_INSTANCE jinst,  VOID *pv, ULONG cbMax, ULONG *pcbActual )
	{
	INST *pinst = (INST *)jinst;
	return pinst->m_plog->ErrLGBKGetTruncateLogInfo( pinst->m_pfsapi, pv, cbMax, pcbActual );
	}

ERR LOG::ErrLGBKGetTruncateLogInfo(	IFileSystemAPI *const 	pfsapi,
									VOID 						*pv,
									ULONG 						cbMax,
									ULONG 						*pcbActual )
	{
	ERR		err = JET_errSuccess;

	CallR ( ErrLGBKIPrepareLogInfo( pfsapi ) );

	Assert ( m_lgenDeleteMic <= m_lgenDeleteMac );
	
	return ErrLGBKIGetLogInfo( pfsapi, m_lgenDeleteMic, m_lgenDeleteMac, fFalse, pv, cbMax, pcbActual, NULL);	
	}


ERR ISAMAPI ErrIsamTruncateLog( JET_INSTANCE jinst )
	{
	INST *pinst = (INST *)jinst;
	return pinst->m_plog->ErrLGBKTruncateLog( pinst->m_pfsapi );
	}
	
ERR LOG::ErrLGBKTruncateLog( IFileSystemAPI *const pfsapi )
	{
	ERR		err = JET_errSuccess;
	LONG	lT;
	CHAR	szFNameT[IFileSystemAPI::cchPathMax];
	CHAR	szDeleteFile[IFileSystemAPI::cchPathMax];
	LONG 	cDeleted = 0;

	if ( !m_fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}

	// if nothing to delete
	if ( m_lgenDeleteMic >= m_lgenDeleteMac )
		{		
		UtilReportEvent( eventInformation, LOGGING_RECOVERY_CATEGORY, BACKUP_NO_TRUNCATE_LOG_FILES, 0, NULL, 0, NULL, m_pinst );
		goto HandleError;
		}	

	// report the deletion range
		{
		CHAR 			szFullLogNameDeleteMic[IFileSystemAPI::cchPathMax];
		CHAR 			szFullLogNameDeleteMac[IFileSystemAPI::cchPathMax];
		const char * 	rgszT[] = { szFullLogNameDeleteMic, szFullLogNameDeleteMac };			
		CHAR 			szFullPathName[IFileSystemAPI::cchPathMax];
		
		if ( JET_errSuccess > m_pinst->m_pfsapi->ErrPathComplete( m_szLogFilePath, szFullPathName ) )
			{
			strcpy( szFullPathName, "" );
			}
				

		LGSzFromLogId( szFNameT, m_lgenDeleteMic );
		LGMakeName( m_pinst->m_pfsapi, szFullLogNameDeleteMic, szFullPathName, szFNameT, (CHAR *)szLogExt );

		Assert( m_lgenDeleteMic < m_lgenDeleteMac );
		LGSzFromLogId( szFNameT, m_lgenDeleteMac - 1);
		LGMakeName( m_pinst->m_pfsapi, szFullLogNameDeleteMac, szFullPathName, szFNameT, (CHAR *)szLogExt );
				
		UtilReportEvent( eventInformation, LOGGING_RECOVERY_CATEGORY, BACKUP_TRUNCATE_LOG_FILES, 2, rgszT, 0, NULL, m_pinst );
		}	
	
	/*	delete logs.  Note that log files must be deleted in
	/*	increasing number order.
	/**/
	
	for ( lT = m_lgenDeleteMic; lT < m_lgenDeleteMac; lT++ )
		{
		LGSzFromLogId( szFNameT, lT );
		LGMakeName( pfsapi, szDeleteFile, m_szLogFilePath, szFNameT, (CHAR *)szLogExt );
		err = pfsapi->ErrFileDelete( szDeleteFile );
		if ( err != JET_errSuccess )
			{
			/*	must maintain a continuous log file sequence,
			/*	No need to clean up (reset m_fBackupInProgress etc) if fails.
			/**/
			break;
			}
		cDeleted++;
		}


HandleError:
	
#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];
	
		sprintf( sz, "** TruncateLog (%d) %d - %d.\n", err, m_lgenDeleteMic, m_lgenDeleteMac );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif

		{
		const int cbFillBuffer = 128;
		char szTrace[cbFillBuffer + 1];
		szTrace[ cbFillBuffer ] = '\0';
		_snprintf( szTrace, cbFillBuffer, "Truncate %d logs starting with 0x%05X (error %d)", cDeleted, m_lgenDeleteMic, err );
		Call ( ErrLGTrace( m_ppibBackup, szTrace) );
		}

	return err;
	}


ERR ISAMAPI ErrIsamEndExternalBackup(  JET_INSTANCE jinst, JET_GRBIT grbit )
	{
	INST *pinst = (INST *)jinst;

	Assert ( grbit == JET_bitBackupEndNormal || grbit == JET_bitBackupEndAbort );

	ERR err;
	if ( JET_bitBackupEndNormal == grbit )
		{
		err = JET_errSuccess;
		}
	else
		{
		err = ErrERRCheck( errBackupAbortByCaller );
		}
	return pinst->m_plog->ErrLGBKIExternalBackupCleanUp( pinst->m_pfsapi, err );
	}


ERR LOG::ErrLGBKIExternalBackupCleanUp( IFileSystemAPI *const pfsapi, ERR error )
	{
	BOOL	fNormal = ( error == JET_errSuccess );
	ERR 	err;
	DBID	dbid;

	/*  determine if we are scrubbing the database
	/**/
	BOOL fScrub = m_fScrubDB;


	if ( !m_fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}

	// if backup client calls BackupEnd without error
	// before logs are read, force the backup as "with error"
	if ( fNormal && m_fBackupStatus == backupStateDatabases )
		{
		fNormal = fFalse;
		error = ErrERRCheck( errBackupAbortByCaller );
		}

	/*	delete patch files, if present, for all databases.
	/**/
	//	first close the patch file if needed
	for ( INT irhf = 0; irhf < crhfMax; ++irhf )
		{
		if ( m_rgrhf[irhf].fInUse && m_rgrhf[irhf].pfapi )
			{
			Assert ( !m_rgrhf[irhf].fIsSLVFile );
			Assert ( !m_rgrhf[irhf].fDatabase );
			delete m_rgrhf[irhf].pfapi;
			m_rgrhf[irhf].pfapi = NULL;
			}					
		}

	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP 	ifmp = m_pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;

		FMP *pfmp = &rgfmp[ifmp];


		if ( pfmp->FInUse()
			&& pfmp->FLogOn()
			&& pfmp->FAttached()
			&& pfmp->FInBackupSession() )
			{			
			Assert( !pfmp->FSkippedAttach() );
			Assert( !pfmp->FDeferredAttach() );


			// on snapshot, sync flush the header
			// UNDONE: we still have a problem if we crash between stop snapshot log record and writing the header
			// or if we fail writing it
		 	if ( pfmp->FDuringSnapshot() )
		 		{
			 	CallS ( pfmp->ErrSnapshotStop( pfsapi ) );
			 	CallS ( ErrDBCloseDatabase( m_ppibBackup, ifmp, 0 ) );
				}

			// only full backup is using patch files
			if ( m_fBackupFull )
				{
#ifdef ELIMINATE_PATCH_FILE
				pfmp->SetPgnoMost( 0 );
				pfmp->SetPgnoCopyMost( 0 );
				pfmp->ResetFCopiedPatchHeader();
#else
				CHAR  	szT[ IFileSystemAPI::cchPathMax ];

				LGIGetPatchName( m_pinst->m_pfsapi, szT, pfmp->SzDatabaseName()  );
				if ( pfmp->PfapiPatch() )
					{
					LGIClosePatchFile( pfmp );
					Assert( !pfmp->PfapiPatch() );
					}
				ERR errAux;
				errAux = m_pinst->m_pfsapi->ErrFileDelete( szT );
				if ( JET_errFileNotFound == errAux )
					{
					errAux = JET_errSuccess;
					}
				CallSRFS( errAux, ( JET_errFileAccessDenied, 0 ) );
#endif	//	ELIMINATE_PATCH_FILE
				}

			m_critCheckpoint.Enter();
			
			if ( fNormal )
				{
				if ( m_fBackupFull )
					{
					/*	set up database file header accordingly.
					 */
					Assert( pfmp->Ppatchhdr() );

					PATCH_HEADER_PAGE * ppatchHdr = pfmp->Ppatchhdr();

#ifdef ELIMINATE_PATCH_FILE
					pfmp->Pdbfilehdr()->bkinfoFullPrev = ppatchHdr->bkinfo;

					// in the patch trailier, genMax is what is needed
					// we don't know that the backup set has more than this, up to m_lgenCopyMac - 1
					// so we update the db header with this
					Assert( pfmp->Pdbfilehdr()->bkinfoFullPrev.le_genLow );
					Assert( pfmp->Pdbfilehdr()->bkinfoFullPrev.le_genHigh <=  m_lgenCopyMac - 1 );
					pfmp->Pdbfilehdr()->bkinfoFullPrev.le_genHigh =  m_lgenCopyMac - 1;
#else
					pfmp->Pdbfilehdr()->bkinfoFullPrev = ppatchHdr->bkinfoFullCur;
#endif

					Assert(	pfmp->Pdbfilehdr()->bkinfoFullCur.le_genLow == 0 );
					memset( &pfmp->Pdbfilehdr()->bkinfoIncPrev, 0, sizeof( BKINFO ) );

					// clean the snapshot info after a normal full backup
					memset( &(pfmp->Pdbfilehdr()->bkinfoSnapshotCur), 0, sizeof( BKINFO ) );
					}
				else  if ( m_fBackupSnapshot )
				 	{					
					Assert( !pfmp->Ppatchhdr() );					
					Assert( pfmp->Pdbfilehdr() );	

					BKINFO * pbkinfo;
					
					pbkinfo = &(pfmp->Pdbfilehdr()->bkinfoFullPrev);
					pbkinfo->le_lgposMark = m_lgposFullBackupMark;
					pbkinfo->logtimeMark = m_logtimeFullBackupMark;
					pbkinfo->le_genLow = m_lgenCopyMic;
					pbkinfo->le_genHigh = m_lgenCopyMac - 1;

					Assert(	pfmp->Pdbfilehdr()->bkinfoFullCur.le_genLow == 0 );
					memset( &pfmp->Pdbfilehdr()->bkinfoIncPrev, 0, sizeof( BKINFO ) );

					}
				else
					{
					pfmp->Pdbfilehdr()->bkinfoIncPrev.le_lgposMark = m_lgposIncBackup;
					pfmp->Pdbfilehdr()->bkinfoIncPrev.logtimeMark = m_logtimeIncBackup;					
					pfmp->Pdbfilehdr()->bkinfoIncPrev.le_genLow = m_lgenCopyMic;
					pfmp->Pdbfilehdr()->bkinfoIncPrev.le_genHigh = m_lgenCopyMac - 1;
					}
				}
				
			m_critCheckpoint.Leave();

			if ( pfmp->Ppatchhdr() )
				{
				OSMemoryPageFree( pfmp->Ppatchhdr() );
				pfmp->SetPpatchhdr( NULL );
				}

			// try to start SLV scrub task
			if ( fScrub && fNormal && pfmp->FSLVAttached() && ( m_fBackupFull || m_fBackupSnapshot ) )
				{
				ERR errPostScrubSLV = JET_errSuccess;

				FMP::AssertVALIDIFMP( ifmp );
				
				SCRUBSLVTASK * pSCRUBSLVTASK = new SCRUBSLVTASK( ifmp );

				if( NULL == pSCRUBSLVTASK )
					{
					errPostScrubSLV = ErrERRCheck( JET_errOutOfMemory );
					}
				else
					{
					errPostScrubSLV = m_pinst->Taskmgr().ErrTMPost( TASK::DispatchGP, pSCRUBSLVTASK );
					if ( errPostScrubSLV < JET_errSuccess )
						{
						delete pSCRUBSLVTASK;
						}
					}
					
				// UNDONE: eventlog error but continue
				
				}
				
			pfmp->ResetInBackupSession();
			Assert ( !pfmp->FDuringSnapshot() );
			
			}
		Assert( ! pfmp->FInBackupSession() );
		}


	/*	clean up rhf entries.
	 */
	
		{
		for ( INT irhf = 0; irhf < crhfMax; ++irhf )
			{
			if ( m_rgrhf[irhf].fInUse )
				{
				if ( m_rgrhf[irhf].fDatabase )
					{
					const IFMP ifmp = m_rgrhf[irhf].ifmp;
					FMP::AssertVALIDIFMP( ifmp );
					// patch file already been closed
					Assert( !rgfmp[ ifmp ].PfapiPatch() );
					CallS( ErrDBCloseDatabase( m_ppibBackup, ifmp, 0 ) );
					}
				else if ( m_rgrhf[irhf].fIsSLVFile )
					{
					delete m_rgrhf[irhf].pSLVVerifier;
					m_rgrhf[irhf].pSLVVerifier = pNil;

					CallS( ErrDBCloseDatabaseBySLV( m_ppibBackup, m_rgrhf[irhf].ifmp ) );
					}

				// we close those files defore deleting the patch files
				Assert( NULL == m_rgrhf[irhf].pfapi );
					
				if ( m_rgrhf[irhf].fIsLog )
					{
					delete m_rgrhf[irhf].pLogVerifier;
					m_rgrhf[irhf].pLogVerifier = pNil;
					}
				m_rgrhf[irhf].fInUse = fFalse;

				OSMemoryHeapFree ( m_rgrhf[irhf].szFileName );
				m_rgrhf[irhf].szFileName = NULL;

				}
			}
		}
	

	/*	Log error event
	 */
	if ( error == JET_errSuccess )
		{
		UtilReportEvent( eventInformation, LOGGING_RECOVERY_CATEGORY, 	
			STOP_BACKUP_INSTANCE_ID, 0, NULL, 0, NULL, m_pinst );

		// write the db header so that the info we updated is written.
		// otherwise a crash before other db header updates
		// may result in backup information lost.

		ERR		errUpdate;
		BOOL	fSkippedAttachDetach;
		LOGTIME tmEmpty;
		memset( &tmEmpty, 0, sizeof(LOGTIME) );
		
		m_critCheckpoint.Enter();
		errUpdate = ErrLGIUpdateGenRequired( pfsapi, 0, 0, tmEmpty, &fSkippedAttachDetach );
		m_critCheckpoint.Leave();

		// on error, report a Warning and continue as the backup is OK from it's point of view.
		if ( errUpdate < JET_errSuccess )
			{
			char	sz1T[32];
			const char	*rgszT[1];
		
			sprintf( sz1T, "%d", errUpdate );
			rgszT[0] = sz1T;
			
			UtilReportEvent( eventWarning, LOGGING_RECOVERY_CATEGORY, BACKUP_ERROR_INFO_UPDATE, 1, rgszT, 0 , NULL, m_pinst );
			}
		else
			{
			Assert( !fSkippedAttachDetach );
			}		
		}
	// special messages for frequent error cases
	else if ( errBackupAbortByCaller == error )
		{
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
			STOP_BACKUP_ERROR_ABORT_BY_CALLER_INSTANCE_ID, 0, NULL, 0, NULL, m_pinst );		
		}
	else
		{	
		char	sz1T[32];
		const UINT	csz	= 1;
		const char	*rgszT[csz];
		
		sprintf( sz1T, "%d", error );
		rgszT[0] = sz1T;
		
		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY,
			STOP_BACKUP_ERROR_INSTANCE_ID, csz, rgszT, 0, NULL, m_pinst );
		}

	if( m_fScrubDB && m_pscrubdb )
		{
		CallS( m_pscrubdb->ErrTerm() );	// may fail with JET_errOutOfMemory. what to do?
		delete m_pscrubdb;
		m_pscrubdb = NULL;
		}


	m_fBackupInProgress = fFalse;
	m_fBackupStatus = backupStateNotStarted;
	m_fBackupSnapshot = fFalse;

	err = JET_errSuccess;				

	{
	const int cbFillBuffer = 64;
	char szTrace[cbFillBuffer + 1];
	szTrace[ cbFillBuffer ] = '\0';
	_snprintf( szTrace, cbFillBuffer, "EXT BACKUP STOP (err %d)", err );
	(void) ErrLGTrace( m_ppibBackup, szTrace);
	}
	
#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];
	
		sprintf( sz, "** EndExternalBackup (%d).\n", err );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );
		}
#endif
	
	return err;
	}


ERR LOG::ErrLGRSTBuildRstmapForSoftRecovery( const JET_RSTMAP * const rgjrstmap, const int cjrstmap )
	{
	ERR			err;
	INT			irstmapMac = 0;
	INT			irstmap = 0;
	RSTMAP		*rgrstmap;

	if ( ( rgrstmap = static_cast<RSTMAP *>( PvOSMemoryHeapAlloc( sizeof(RSTMAP) * cjrstmap ) ) ) == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	memset( rgrstmap, 0, sizeof( RSTMAP ) * cjrstmap );

	for ( irstmap = 0; irstmap < cjrstmap; irstmap++ )
		{
		const JET_RSTMAP * const pjrstmap 	= rgjrstmap + irstmap;
		RSTMAP * const prstmap 				= rgrstmap + irstmap;
		
		if ( (prstmap->szDatabaseName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( pjrstmap->szDatabaseName ) + 1 ) ) ) == NULL )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		strcpy( prstmap->szDatabaseName, pjrstmap->szDatabaseName );

		if ( (prstmap->szNewDatabaseName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( pjrstmap->szNewDatabaseName ) + 1 ) ) ) == NULL )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		strcpy( prstmap->szNewDatabaseName, pjrstmap->szNewDatabaseName );

		prstmap->fDestDBReady 	= fTrue;

#ifdef ELIMINATE_PATCH_FILE
#else
		prstmap->szPatchPath	= NULL;
#endif
		}

	m_irstmapMac 	= irstmap;
	m_rgrstmap 		= rgrstmap;

	return JET_errSuccess;

HandleError:
	Assert( rgrstmap != NULL );
	LGRSTFreeRstmap( );
	
	Assert( m_irstmapMac == 0 );
	Assert( m_rgrstmap == NULL );
	
	return err;
	}

BOOL LOG::FLGRSTCheckDuplicateSignature(  )
	{
	//ERR LOG::ErrReplaceRstMapEntry( const CHAR *szName, SIGNATURE * pDbSignature, const BOOL fSLVFile )
	INT  irstmap;
	
	for ( irstmap = 0; irstmap < m_irstmapMac; irstmap++ )
		{
		INT  irstmapSearch;

		if ( !m_rgrstmap[irstmap].szDatabaseName )
			continue;
			
		for ( irstmapSearch = irstmap + 1; irstmapSearch < m_irstmapMac; irstmapSearch++ )
			{
			if ( !m_rgrstmap[irstmap].szNewDatabaseName )
				continue;
				
			if ( 0 == memcmp( 	&m_rgrstmap[irstmap].signDatabase,
								&m_rgrstmap[irstmapSearch].signDatabase,
								sizeof(SIGNATURE) ) &&
				m_rgrstmap[irstmap].fSLVFile == m_rgrstmap[irstmapSearch].fSLVFile )
				{
				return fFalse;
				}
			}
		}

	return fTrue;
	}

ERR LOG::ErrLGRSTBuildRstmapForExternalRestore( JET_RSTMAP *rgjrstmap, int cjrstmap )
	{
	ERR			err;
	INT			irstmapMac = 0;
	INT			irstmap = 0;
	RSTMAP		*rgrstmap;
	RSTMAP		*prstmap;
	JET_RSTMAP	*pjrstmap;

	if ( ( rgrstmap = static_cast<RSTMAP *>( PvOSMemoryHeapAlloc( sizeof(RSTMAP) * cjrstmap ) ) ) == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	memset( rgrstmap, 0, sizeof( RSTMAP ) * cjrstmap );

	for ( irstmap = 0; irstmap < cjrstmap; irstmap++ )
		{
		pjrstmap = rgjrstmap + irstmap;
		prstmap = rgrstmap + irstmap;
		if ( (prstmap->szDatabaseName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( pjrstmap->szDatabaseName ) + 1 ) ) ) == NULL )
			Call( ErrERRCheck( JET_errOutOfMemory ) );
		strcpy( prstmap->szDatabaseName, pjrstmap->szDatabaseName );

		if ( (prstmap->szNewDatabaseName = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( pjrstmap->szNewDatabaseName ) + 1 ) ) ) == NULL )
			Call( ErrERRCheck( JET_errOutOfMemory ) );
		strcpy( prstmap->szNewDatabaseName, pjrstmap->szNewDatabaseName );

		/*	make patch name prepare to patch the database.
		/**/

#ifdef ELIMINATE_PATCH_FILE
#else
		//	patch files are always on the OS file-system
		_TCHAR szT[ IFileSystemAPI::cchPathMax ];

		LGIGetPatchName( m_pinst->m_pfsapi, szT, pjrstmap->szDatabaseName, m_szRestorePath );

		if ( ( prstmap->szPatchPath = static_cast<CHAR *>( PvOSMemoryHeapAlloc( strlen( szT ) + 1 ) ) ) == NULL )
			return ErrERRCheck( JET_errOutOfMemory );
		strcpy( prstmap->szPatchPath, szT );
#endif

		prstmap->fDestDBReady = fTrue;
		}

	m_irstmapMac = irstmap;
	m_rgrstmap = rgrstmap;

	return JET_errSuccess;

HandleError:
	Assert( rgrstmap != NULL );
	LGRSTFreeRstmap( );
	
	Assert( m_irstmapMac == 0 );
	Assert( m_rgrstmap == NULL );
	
	return err;
	}


ERR ISAMAPI ErrIsamExternalRestore(
	JET_INSTANCE jinst,
	CHAR *szCheckpointFilePath,
	CHAR *szNewLogPath,
	JET_RSTMAP *rgjrstmap,
	int cjrstmap,
	CHAR *szBackupLogPath,
	LONG lgenLow,
	LONG lgenHigh,
	JET_PFNSTATUS pfn )
	{
	ERR err;
	INST *pinst = (INST *)jinst;

//	Assert( szNewLogPath );
	Assert( rgjrstmap );
	Assert( szBackupLogPath );
//	Assert( lgenLow );
//	Assert( lgenHigh );

#ifdef DEBUG
	ITDBGSetConstants( pinst );
#endif

	Assert( pinst->m_fSTInit == fSTInitDone || pinst->m_fSTInit == fSTInitNotDone );
	if ( pinst->m_fSTInit == fSTInitDone )
		{
		return ErrERRCheck( JET_errAfterInitialization );
		}

	LOG *plog = pinst->m_plog;
		
	err = plog->ErrLGRSTExternalRestore(	pinst->m_pfsapi,
											szCheckpointFilePath,
											szNewLogPath,
											rgjrstmap,
											cjrstmap,
											szBackupLogPath,
											lgenLow,
											lgenHigh,
											pfn );
	
	return err;
	}

	
ERR LOG::ErrLGRSTExternalRestore(	IFileSystemAPI *const	pfsapi,
									CHAR 						*szCheckpointFilePath,
									CHAR 						*szNewLogPath,
									JET_RSTMAP 					*rgjrstmap,
									int 						cjrstmap,
									CHAR 						*szBackupLogPath,
									LONG 						lgenLow,
									LONG 						lgenHigh,
									JET_PFNSTATUS 				pfn )
	{
	ERR					err;
	BOOL				fLogDisabledSav;
	DBMS_PARAM			dbms_param;
//	LGBF_PARAM			lgbf_param;
	LGSTATUSINFO		lgstat;
	LGSTATUSINFO		*plgstat = NULL;
	const CHAR			*rgszT[2];
	INT					irstmap;
	BOOL				fNewCheckpointFile;
	ULONG				cbSecVolumeSave;

	BOOL fSnapshotFlagComputed = fFalse;

	//	create paths now if they do not exist
		{
		INST * pinst = m_pinst;
		
		//	make sure the temp path does NOT have a trailing '\' and the log/sys paths do

		Assert( !FOSSTRTrailingPathDelimiter( pinst->m_szTempDatabase ) );
		Assert( FOSSTRTrailingPathDelimiter( pinst->m_szSystemPath ) );
		Assert( FOSSTRTrailingPathDelimiter( m_szLogFilePath ) );

		//	create paths

		CallR( ErrUtilCreatePathIfNotExist( pinst->m_pfsapi, pinst->m_szTempDatabase, NULL ) );
		CallR( ErrUtilCreatePathIfNotExist( pinst->m_pfsapi, pinst->m_szSystemPath, NULL ) );
		CallR( ErrUtilCreatePathIfNotExist( pinst->m_pfsapi, m_szLogFilePath, NULL ) );
		}

	//	Start the restore work
	
	m_fSignLogSet = fFalse;

	/*	set restore path
	/**/			
	CallR( ErrLGRSTInitPath( pfsapi, szBackupLogPath, szNewLogPath, m_szRestorePath, m_szLogFilePath ) );
	Assert( strlen( m_szRestorePath ) < sizeof( m_szRestorePath ) - 1 );
	Assert( strlen( m_szLogFilePath ) < IFileSystemAPI::cchPathMax );
	Assert( m_szLogCurrent == m_szRestorePath );

	//	disable the sector-size checks

//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//	---** TEMPORARY FIX **---
{
	CHAR rgchFullName[IFileSystemAPI::cchPathMax];
	if ( pfsapi->ErrPathComplete( m_szLogFilePath, rgchFullName ) == JET_errInvalidPath )
		{
		const CHAR	*szPathT[1] = { m_szLogFilePath };
		UtilReportEvent(
			eventError,
			LOGGING_RECOVERY_CATEGORY,
			FILE_NOT_FOUND_ERROR_ID,
			1, szPathT );
		return ErrERRCheck( JET_errFileNotFound );
		}

	CallR( pfsapi->ErrFileAtomicWriteSize( rgchFullName, (DWORD*)&m_cbSecVolume ) );
}
	cbSecVolumeSave = m_cbSecVolume;
//
//	SEARCH-STRING: SecSizeMismatchFixMe
//
//	m_cbSecVolume = ~(ULONG)0;

	//	use the proper log file size for recovery

	Assert( m_pinst->m_fUseRecoveryLogFileSize == fFalse );
	m_pinst->m_fUseRecoveryLogFileSize = fTrue;

	/*	check log signature and database signatures
	/**/

	Assert ( 0 == m_lGenHighTargetInstance || m_szTargetInstanceLogPath[0] );

	//	check log signature and database signatures
	if ( m_lGenHighTargetInstance )
		{
		CallJ( ErrLGRSTCheckSignaturesLogSequence(
			pfsapi, m_szRestorePath, m_szLogFilePath, lgenLow, lgenHigh, m_szTargetInstanceLogPath, m_lGenHighTargetInstance ), ReturnError );
		}
	else
		{
		CallJ( ErrLGRSTCheckSignaturesLogSequence(
			pfsapi, m_szRestorePath, m_szLogFilePath, lgenLow, lgenHigh, NULL, 0 ), ReturnError );
		}

	fLogDisabledSav = m_fLogDisabled;
	m_pinst->SaveDBMSParams( &dbms_param );
//	LGSaveBFParams( &lgbf_param );

	m_fHardRestore = fTrue;
	m_fRestoreMode = fRestorePatch;
	m_fLogDisabled = fFalse;
	m_fAbruptEnd = fFalse;

	CallJ( ErrLGRSTBuildRstmapForExternalRestore( rgjrstmap, cjrstmap ), TermResetGlobals );

	/*	make sure all the patch files have enough logs to replay
	/**/

	for ( irstmap = 0; irstmap < m_irstmapMac; irstmap++ )
		{		
		/*	open patch file and check its minimum requirement for full backup,
		/*  skipping any SLV streaming files we see
		/**/
		CHAR *szDatabaseName = m_rgrstmap[irstmap].szDatabaseName;
		CHAR *szNewDatabaseName = m_rgrstmap[irstmap].szNewDatabaseName;

		LGPOS lgposSnapshotDb = lgposMin;
		Assert( m_fSignLogSet );

#ifdef ELIMINATE_PATCH_FILE
		err = ErrLGCheckDBFiles( m_pinst, pfsapi, m_rgrstmap + irstmap, NULL, lgenLow, lgenHigh, &lgposSnapshotDb );
#else
        _TCHAR szT[ IFileSystemAPI::cchPathMax ];

		//	patch files are always on the OS file-system
		LGIGetPatchName( pfsapi, szT, szDatabaseName, m_szRestorePath );

		err = ErrLGCheckDBFiles( m_pinst, pfsapi, m_rgrstmap + irstmap, szT, lgenLow, lgenHigh, &lgposSnapshotDb );
#endif

		// we don't check streaming file header during backup
		// UNDONE: maybe it is possible to check this, not that there are supposed to be in sync
		if ( wrnSLVDatabaseHeader == err )
			{
			err = JET_errSuccess;
			continue;
			}
			
		CallJ( err, TermFreeRstmap );

		// we have to check the all dbs do have the same lgposSnapshotStart
		// or none of those are from Snapshot backup set
		if ( !fSnapshotFlagComputed )
			{
			Assert ( CmpLgpos ( &m_lgposSnapshotStart, &lgposMin) == 0 );
			Assert ( fSnapshotNone == m_fSnapshotMode );
			
			if ( CmpLgpos ( &lgposSnapshotDb, &lgposMin) > 0 )
				{
				m_fSnapshotMode = fSnapshotBefore;
				m_lgposSnapshotStart = lgposSnapshotDb;
				}
			}

		// the lgposSnapshotStart must be the same for all db's (set or lgposMin)
		if ( CmpLgpos ( &lgposSnapshotDb, &m_lgposSnapshotStart) != 0 )
			{
			// UNDONE: define a new error
			CallJ ( ErrERRCheck ( JET_errDatabasesNotFromSameSnapshot ), TermFreeRstmap );
			}				
		fSnapshotFlagComputed = fTrue;
		}

	// check that there are no databases with same signature
	Assert ( FLGRSTCheckDuplicateSignature( ) );

//	CallJ( FMP::ErrFMPInit(), TermFreeRstmap );

	//  initialize log manager and set working log file path
	
	CallJ( ErrLGInit( pfsapi, &fNewCheckpointFile ), TermFMP );

	rgszT[0] = m_szRestorePath;
	rgszT[1] = m_szLogFilePath;
	UtilReportEvent( eventInformation, LOGGING_RECOVERY_CATEGORY, START_RESTORE_ID, 2, rgszT );

#ifdef DEBUG
	if ( m_fDBGTraceBR )
		{
		CHAR sz[256];
	
		sprintf( sz, "** Begin ExternalRestore:\n" );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );

		if ( szCheckpointFilePath )
			{
			sprintf( sz, "     CheckpointFilePath: %s\n", szCheckpointFilePath );
			Assert( strlen( sz ) <= sizeof( sz ) - 1 );
			DBGBRTrace( sz );
			}
		if ( szNewLogPath )
			{
			sprintf( sz, "     LogPath: %s\n", szNewLogPath );
			Assert( strlen( sz ) <= sizeof( sz ) - 1 );
			DBGBRTrace( sz );
			}
		if ( szBackupLogPath )
			{
			sprintf( sz, "     BackupLogPath: %s\n", szBackupLogPath );
			Assert( strlen( sz ) <= sizeof( sz ) - 1 );
			DBGBRTrace( sz );
			}
		sprintf( sz, "     Generation number: %d - %d\n", lgenLow, lgenHigh );
		Assert( strlen( sz ) <= sizeof( sz ) - 1 );
		DBGBRTrace( sz );

		if ( m_irstmapMac )
			{
			INT irstmap;

			for ( irstmap = 0; irstmap < m_irstmapMac; irstmap++ )
				{
				RSTMAP *prstmap = m_rgrstmap + irstmap;
			
				sprintf( sz, "     %s --> %s\n", prstmap->szDatabaseName, prstmap->szNewDatabaseName );
				Assert( strlen( sz ) <= sizeof( sz ) - 1 );
				DBGBRTrace( sz );
				}
			}	
		}
#endif

	/*	set up checkpoint file for restore
	/**/
	Call ( ErrLGIGetGenerationRange( pfsapi, m_szRestorePath,
			!lgenLow?&lgenLow:NULL,
			!lgenHigh?&lgenHigh:NULL ) );
	
	Call( ErrLGRSTSetupCheckpoint( pfsapi, lgenLow, lgenHigh, szCheckpointFilePath ) );

	m_lGenLowRestore = lgenLow;
	m_lGenHighRestore = lgenHigh;

	/*	prepare for callbacks
	/**/
	if ( pfn != NULL )
		{
		plgstat = &lgstat;
		LGIRSTPrepareCallback( pfsapi, plgstat, lgenHigh, lgenLow, pfn );
		}

	/*	adjust fmp according to the restore map
	/**/
	m_fExternalRestore = fTrue;

#ifdef ELIMINATE_PATCH_FILE
#else
	Call( ErrLGRSTPatchInit() );
#endif
	
	/*	do redo according to the checkpoint, dbms_params, and rgbAttach
	/*	set in checkpointGlobal.
	/**/
	Assert( m_szLogCurrent == m_szRestorePath );
	m_errGlobalRedoError = JET_errSuccess;
	Call( ErrLGRRedo( pfsapi, m_pcheckpoint, plgstat ) );

	//	we should be using the right log file size by now

	Assert( m_pinst->m_fUseRecoveryLogFileSize == fFalse );

	//	sector-size checking should now be on

	Assert( m_cbSecVolume != ~(ULONG)0 );
	Assert( m_cbSecVolume == m_cbSec );

	//	update saved copy
	
	cbSecVolumeSave = m_cbSecVolume;

	/*	same as going to shut down, Make all attached databases consistent
	/**/
	if ( plgstat )
		{
		/*	top off the progress metre and wrap it up
		/**/
		lgstat.snprog.cunitDone = lgstat.snprog.cunitTotal;		//lint !e644
		(*lgstat.pfnStatus)(0, JET_snpRestore, JET_sntComplete, &lgstat.snprog);
		}
	
HandleError:

#ifdef ELIMINATE_PATCH_FILE
#else
		//  UNDONE: if the DetachDb was redone during recover (the soft recover part)
		// we don't have the dbid in m_mpdbidifmp and we don't delete the patch
		// file for it. TODO: delete the patch file in ResetFMP
		// anyway, DELETE_PATCH_FILES is dot define so we don't delete those patch files
		// at this level but only in ESEBACK2, on restore without error
		/*	delete .pat files
		/**/
		{
		/*	delete .pat files
		/**/
		for ( DBID dbidT = dbidUserLeast; dbidT < dbidMax; dbidT++ )
			{
			IFMP 	ifmp = m_pinst->m_mpdbidifmp[ dbidT ];
			if ( ifmp >= ifmpMax )
				continue;

			FMP *pfmpT = &rgfmp[ ifmp ];

			if ( pfmpT->SzPatchPath() )
				{
				delete pfmpT->PfapiPatch();
				pfmpT->SetPfapiPatch( NULL );
#ifdef DELETE_PATCH_FILES
				CallSx( m_pinst->m_pfsapi->ErrFileDelete( pfmpT->SzPatchPath() ), JET_errFileNotFound );
#endif
				OSMemoryHeapFree( pfmpT->SzPatchPath() );
				pfmpT->SetSzPatchPath( NULL );
				}
			}
		}

	/*	delete the patch hash table
	/**/
	LGRSTPatchTerm();

#endif	//	ELIMINATE_PATCH_FILE

	/*	either error or terminated
	/**/
	Assert( err < 0 || m_pinst->m_fSTInit == fSTInitNotDone );
	if ( err < 0  &&  m_pinst->m_fSTInit != fSTInitNotDone )
		{
		Assert( m_pinst->m_fSTInit == fSTInitDone );
		CallS( m_pinst->ErrINSTTerm( termtypeError ) );
		}

//	CallS( ErrLGTerm( pfsapi, err >= JET_errSuccess ) );
	CallS( ErrLGTerm( pfsapi, fFalse ) );

	// on success, delete the files generated by this instance
	// (logs, chk, res1.log, res2.log)
	if ( err >= 0 )
		{
		CHAR	szFileName[IFileSystemAPI::cchPathMax];
		CHAR	szFullLogPath[IFileSystemAPI::cchPathMax];
		CHAR	szFullTargetPath[IFileSystemAPI::cchPathMax];
		
		// delete the log files generated
		// if those files are not in the target directory
		// (== is taget instacne is runnign)
		
		Assert ( 0 == m_lGenHighTargetInstance || m_szTargetInstanceLogPath[0] );
		Assert ( m_szLogFilePath );

		CallS( pfsapi->ErrPathComplete( m_szTargetInstanceLogPath, szFullTargetPath ) );		
		CallS( pfsapi->ErrPathComplete( m_szLogFilePath, szFullLogPath ) );		
				
		Assert ( 0 == m_lGenHighTargetInstance || (0 != UtilCmpFileName( szFullTargetPath, szFullLogPath ) ) );
		if ( m_lGenHighTargetInstance && ( 0 != UtilCmpFileName( szFullTargetPath, szFullLogPath ) ) )
			{
/*			LONG		genLowT;
			LONG		genHighT;
			
			Assert ( m_lGenHighTargetInstance );

			genLowT = m_lGenHighTargetInstance + 1;
			LGILastGeneration( pfsapi, m_szLogFilePath, &genHighT );
			// if only edb.log new generated, genHighT will be the max one from the
			// backup set (if in that directory)
			genHighT = max ( genHighT, genLowT);
			LGRSTDeleteLogs( pfsapi, m_szLogFilePath, genLowT, genHighT, fLGRSTIncludeJetLog );		

			LGFullNameCheckpoint( pfsapi, szFileName );
			CallSx( pfsapi->ErrFileDelete( szFileName ), JET_errFileNotFound );				
*/
			LGMakeLogName( szFileName, szLogRes1 );
			CallSx( pfsapi->ErrFileDelete( szFileName ), JET_errFileNotFound );
			LGMakeLogName( szFileName, szLogRes2 );
			CallSx( pfsapi->ErrFileDelete( szFileName ), JET_errFileNotFound );				
			}
		}
		
TermFMP:	
//	FMP::Term();
	
TermFreeRstmap:
	LGRSTFreeRstmap( );

TermResetGlobals:
	m_fHardRestore = fFalse;
	m_fRestoreMode = fRecoveringNone;
	m_fSnapshotMode = fSnapshotNone;
	m_lgposSnapshotStart = lgposMin;

	m_szTargetInstanceLogPath[0] = '\0';
	
	/*	reset initialization state
	/**/
	m_pinst->m_fSTInit = ( err >= 0 ) ? fSTInitNotDone : fSTInitFailed;

	if ( err != JET_errSuccess && !FErrIsLogCorruption( err ) )
		{
		UtilReportEventOfError( LOGGING_RECOVERY_CATEGORY, RESTORE_DATABASE_FAIL_ID, err );
		}
	else
		{
		if ( fGlobalRepair && m_errGlobalRedoError != JET_errSuccess )
			err = ErrERRCheck( JET_errRecoveredWithErrors );
		}
	UtilReportEvent( eventInformation, LOGGING_RECOVERY_CATEGORY, STOP_RESTORE_ID, 0, NULL );

	// signal the caller that we found a running instance
	// the caller (eseback2) will deal with the resulting logs
	// generated by the restore instance in  szNewLogPath
	if ( m_lGenHighTargetInstance && JET_errSuccess <= err )
		{
		err = ErrERRCheck( JET_wrnTargetInstanceRunning );
		}
	m_lGenHighTargetInstance = 0;


	m_fSignLogSet = fFalse;

	m_fLogDisabled = fLogDisabledSav;
	m_pinst->RestoreDBMSParams( &dbms_param );
//	LGRestoreBFParams( &lgbf_param );

	m_fExternalRestore = fFalse;

ReturnError:
	m_cbSecVolume = cbSecVolumeSave;
	m_pinst->m_fUseRecoveryLogFileSize = fFalse;
	return err;
	}


VOID LGMakeName( IFileSystemAPI *const pfsapi, CHAR *szName, const CHAR *szPath, const CHAR *szFName, const CHAR *szExt )
	{
	CHAR	szDirT[IFileSystemAPI::cchPathMax];
	CHAR	szFNameT[IFileSystemAPI::cchPathMax];
	CHAR	szExtT[IFileSystemAPI::cchPathMax];

	CallS( pfsapi->ErrPathParse( szPath, szDirT, szFNameT, szExtT ) );
	CallS( pfsapi->ErrPathBuild( szDirT, szFName, szExt, szName ) );
	}

VOID LOG::LGFullLogNameFromLogId( IFileSystemAPI *const pfsapi, CHAR *szFullLogFileName, LONG lGeneration, CHAR * szDirectory )
	{
	CHAR	szBaseName[IFileSystemAPI::cchPathMax];
	CHAR	szFullPath[IFileSystemAPI::cchPathMax];
		
	LGSzFromLogId( szBaseName, lGeneration );

	// we should always be able to get the full path as it should be the restore path
	// which is already checked in the calling context
	CallS( pfsapi->ErrPathComplete( szDirectory, szFullPath ) );
	
	LGMakeName( pfsapi, szFullLogFileName, szFullPath, szBaseName, (CHAR *)szLogExt );

	return;
	}

// build in szFindPath the patch file full name for a database
// in a certain directory. If directory is NULL, build in the
// database directory (patch file during backup)
VOID LOG::LGIGetPatchName( IFileSystemAPI *const pfsapi, CHAR *szPatch, const char * szDatabaseName, char * szDirectory )
	{
	Assert ( szDatabaseName );

	CHAR	szFNameT[ IFileSystemAPI::cchPathMax ];
	CHAR	szDirT[ IFileSystemAPI::cchPathMax ];
	CHAR	szExtT[ IFileSystemAPI::cchPathMax ];
	
	CallS( pfsapi->ErrPathParse( szDatabaseName, szDirT, szFNameT, szExtT ) );

	//	patch file is always on the OS file-system
	if ( szDirectory )
		// patch file in the specified directory
		// (m_szRestorePath during restore)
		{
		LGMakeName( m_pinst->m_pfsapi, szPatch, szDirectory, szFNameT, (CHAR *) szPatExt );	
		}
	else
		// patch file in the same directory with the database
		{
		LGMakeName( m_pinst->m_pfsapi, szPatch, szDirT, szFNameT, (CHAR *) szPatExt );	
		}
	}


// returns JET_errSuccess even if not found (then lgen will be 0)
//
ERR LOG::ErrLGIGetGenerationRange( IFileSystemAPI* const pfsapi, char* szFindPath, long* plgenLow, long* plgenHigh )
	{
	ERR				err			= JET_errSuccess;
	char			szFind[ IFileSystemAPI::cchPathMax ];
	char			szFileName[ IFileSystemAPI::cchPathMax ];
	IFileFindAPI*	pffapi		= NULL;

	long			lGenMax		= 0;
	long			lGenMin		= lGenerationMaxDuringRecovery + 1;
	
	Assert ( szFindPath );
	Assert ( pfsapi );
	/*	make search string "<search path> \ edb * .log\0"
	/**/
	Assert( strlen( szFindPath ) + 1 + strlen( m_szJet ) + strlen( "*" ) + strlen( szLogExt ) + 1 <= IFileSystemAPI::cchPathMax );
	
	strcpy( szFind, szFindPath );
	OSSTRAppendPathDelimiterA( szFind, fTrue );
	strcat( szFind, m_szJet );
	strcat( szFind, "*" );
	strcat( szFind, szLogExt );

	Call( pfsapi->ErrFileFind( szFind, &pffapi ) );
	while ( ( err = pffapi->ErrNext() ) == JET_errSuccess )
		{
		CHAR	szT[4];
		CHAR	szDirT[IFileSystemAPI::cchPathMax];
		CHAR	szFNameT[IFileSystemAPI::cchPathMax];
		CHAR	szExtT[IFileSystemAPI::cchPathMax];

		/*	get file name and extension
		/**/
		Call( pffapi->ErrPath( szFileName ) );
		Call( pfsapi->ErrPathParse( szFileName, szDirT, szFNameT, szExtT ) );

		/* if length of a numbered log file name and has log file extension
		/**/
		if ( strlen( szFNameT ) == 8 && UtilCmpFileName( szExtT, szLogExt ) == 0 )
			{
			UtilMemCpy( szT, szFNameT, 3 );
			szT[3] = '\0';

			/* if has not the current base name
			/**/
			if ( UtilCmpFileName( szT, m_szJet ) )
				{
				continue;
				}
			
			INT			ib;
			const INT	ibMax = 8;
			LONG		lGen = 0;

			for (ib = 3; ib < ibMax; ib++ )
				{
				BYTE	b = szFNameT[ib];

				if ( b >= '0' && b <= '9' )
					lGen = lGen * 16 + b - '0';
				else if ( b >= 'A' && b <= 'F' )
					lGen = lGen * 16 + b - 'A' + 10;
				else if ( b >= 'a' && b <= 'f' )
					lGen = lGen * 16 + b - 'a' + 10;
				else
					break;
				}
			
			if ( ib != ibMax )
				{
				continue;
				}
				
			lGenMax = max( lGenMax, lGen );
			lGenMin = min( lGenMin, lGen );
			
			}
		}
	Call( err == JET_errFileNotFound ? JET_errSuccess : err );

HandleError:
	
	delete pffapi;

	// JET_errFileNotFound is not an error, we return JET_errSuccess and (0,0) as range

	// on error, we return (0,0)
	if ( err < JET_errSuccess )
		{
		Assert ( JET_errFileNotFound != err );
		lGenMin = 0;
		lGenMax = 0;
		}
	
	// nothing found
	if ( lGenerationMaxDuringRecovery + 1 == lGenMin )
		{
		Assert ( JET_errSuccess == err );
		Assert( 0 == lGenMax );
		lGenMin = 0;
		}

	Assert( 0 <= lGenMin );
	Assert( 0 <= lGenMax );

	Assert( lGenMin <= lGenerationMaxDuringRecovery );
	Assert( lGenMax <= lGenerationMaxDuringRecovery );
	Assert( lGenMin <= lGenMax );

	if ( plgenLow )
		{
		*plgenLow = lGenMin;
		}
	
	if ( plgenHigh )
		{
		*plgenHigh = lGenMax;
		}

	return err;
	}

ERR ISAMAPI  ErrIsamSnapshotStart(	JET_INSTANCE 		instance,
									char * 				szDatabases,
									JET_GRBIT			grbit)
	{
	INST *pinst = (INST *)instance;
	return pinst->m_plog->ErrLGBKSnapshotStart( pinst->m_pfsapi, szDatabases, grbit );
	}
	
ERR LOG::ErrLGBKSnapshotStart(	IFileSystemAPI *const	pfsapi,
								char 						*szDatabases,
								JET_GRBIT					grbit )
	{
	char * 		szCurrentDatabase 	= szDatabases;
	ERR 		err 				= JET_errSuccess;
	BKINFO 		bkInfo;

	if ( !m_fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}
		
	if ( !m_fBackupSnapshot || backupStateDatabases != m_fBackupStatus )
		{
		return ErrERRCheck( JET_errInvalidBackupSequence );
		}

	if ( !szDatabases )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	Assert ( backupStateDatabases == m_fBackupStatus );
	Assert ( m_fBackupSnapshot );

	memset( &bkInfo, 0, sizeof( BKINFO ) );
	bkInfo.le_lgposMark = m_lgposSnapshotStart;
	bkInfo.logtimeMark = m_logtimeFullBackupMark;
	bkInfo.le_genLow = m_lgenCopyMic;

	// for each db ERR FMP::ErrSnapshotStart( pfsapi, lgposFullBackup )
	while ( szCurrentDatabase[0] )
		{
		IFMP ifmpT;
		
		Call ( ErrDBOpenDatabase( m_ppibBackup, (CHAR *)szCurrentDatabase, &ifmpT, 0 ) );
		Assert( err == JET_errSuccess || err == JET_wrnFileOpenReadOnly );

		Assert ( 0 != CmpLgpos( &m_lgposSnapshotStart, &lgposMin) );

		Call ( rgfmp[ifmpT].ErrSnapshotStart( pfsapi, &bkInfo ) );

		szCurrentDatabase += strlen( szCurrentDatabase );
		}

	Assert ( JET_errSuccess == err );

HandleError:

	// if we do have some DBs in snapshot session, we need to stop those
	if ( JET_errSuccess > err )
		{
		(void)ErrLGBKSnapshotStop( pfsapi, 0 );
		}
		
	return err;
	}

ERR ISAMAPI  ErrIsamSnapshotStop(	JET_INSTANCE 		instance,
									JET_GRBIT			grbit)
	{
	INST *pinst = (INST *)instance;
	return pinst->m_plog->ErrLGBKSnapshotStop( pinst->m_pfsapi, grbit );
	}

ERR LOG::ErrLGBKSnapshotStop( IFileSystemAPI *const pfsapi, JET_GRBIT grbit )
	{
	ERR 	err 				= JET_errSuccess;
	ERR 	errT 				= JET_errSuccess;

	if ( !m_fBackupInProgress )
		{
		return ErrERRCheck( JET_errNoBackup );
		}
		
	if ( !m_fBackupSnapshot || backupStateDatabases != m_fBackupStatus )
		{
		return ErrERRCheck( JET_errInvalidBackupSequence );
		}

	Assert ( backupStateDatabases == m_fBackupStatus );
	Assert ( m_fBackupSnapshot );

	for ( DBID dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP ifmp = m_pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;

		FMP * pfmp = rgfmp + ifmp;
		Assert ( pfmp );
		
		if ( !pfmp->FDuringSnapshot() )
			continue;

		// if we error for one DB, go for all DBs
		// and save the error
		errT = pfmp->ErrSnapshotStop( pfsapi );

		// we should have reset the flag even on error
		Assert ( !pfmp->FDuringSnapshot() );
		
		if ( JET_errSuccess <= err )
			{
			err = errT;
			}
		
		CallS ( ErrDBCloseDatabase( m_ppibBackup, ifmp, 0 ) );
		}
		
	// on error, stop the backup session, don't allow
	// JetGetLogInfo as we may failed to update the DB header and
	// logging StopSnapshot (in JetGetLogInfo) must not occure.
	if ( JET_errSuccess > err )
		{
		(void)ErrLGBKIExternalBackupCleanUp( pfsapi, err );
		}
		
	return err;
	}


#ifdef ELIMINATE_PATCH_FILE

VOID LOG::LGBKMakeDbTrailer(const IFMP ifmp, BYTE *pvPage)
	{
	FMP		*pfmp = &rgfmp[ifmp];

	PATCHHDR * const ppatchHdr = pfmp->Ppatchhdr();
	BKINFO * pbkinfo;

	Assert( pfmp->PgnoCopyMost() == pfmp->PgnoMost() );
	Assert( !pfmp->FCopiedPatchHeader() );

	memset( (void *)ppatchHdr, '\0', g_cbPage );
	
	pbkinfo = &ppatchHdr->bkinfo;
	pbkinfo->le_lgposMark = m_lgposFullBackupMark;
	pbkinfo->logtimeMark = m_logtimeFullBackupMark;
	pbkinfo->le_genLow = m_lgenCopyMic;

	UtilMemCpy( (BYTE*)&ppatchHdr->signDb, &pfmp->Pdbfilehdr()->signDb, sizeof(SIGNATURE) );
	UtilMemCpy( (BYTE*)&ppatchHdr->signLog, &pfmp->Pdbfilehdr()->signLog, sizeof(SIGNATURE) );

	m_critLGFlush.Enter();
	pbkinfo->le_genHigh = m_plgfilehdr->lgfilehdr.le_lGeneration;
	m_critLGFlush.Leave();

	Assert( pbkinfo->le_genLow != 0 );
	Assert( pbkinfo->le_genHigh != 0 );
	Assert ( pbkinfo->le_genHigh >= pbkinfo->le_genLow );
			
	ppatchHdr->m_hdrNormalPage.ulChecksumParity = UlUtilChecksum( (const BYTE*) ppatchHdr, g_cbPage );
	UtilMemCpy( (BYTE *)pvPage, ppatchHdr, g_cbPage );

	pfmp->SetFCopiedPatchHeader();
	}

ERR LOG::ErrLGBKReadDBTrailer(	IFileSystemAPI *const pfsapi, const _TCHAR*	szFileName, BYTE* pbTrailer, const DWORD	cbTrailer )
	{
	ERR			err 	= JET_errSuccess;
	IFileAPI * 	pfapi 	= NULL;
	QWORD 		cbSize 	= 0;
	
	CallR ( pfsapi->ErrFileOpen( szFileName, &pfapi, fTrue ) )

	Call ( pfapi->ErrSize( &cbSize ) );

	// we already read the headers
	Assert ( cbSize > QWORD ( cpgDBReserved ) * g_cbPage );

	// we need at least the patch page
	if ( cbSize < QWORD ( cpgDBReserved + 1 )  * g_cbPage )
		{
		Call ( ErrERRCheck( JET_errDatabaseCorrupted ) );
		}
	
	Call ( pfapi->ErrIORead( cbSize - QWORD(g_cbPage), cbTrailer, pbTrailer ) );

		
	Assert ( JET_errSuccess == err );
HandleError:

	if ( pfapi )
		{
		delete pfapi;
		pfapi = NULL;
		}

	if ( err == JET_errDiskIO )
		err = ErrERRCheck( JET_errDatabaseCorrupted );

	return err;
	}

ERR LOG::ErrLGBKReadAndCheckDBTrailer(IFileSystemAPI *const pfsapi, const _TCHAR* szFileName, BYTE * pbBuffer )
	{
	ERR			err 	= JET_errSuccess;
	PATCHHDR * ppatchHdr = (PATCHHDR *)pbBuffer;

	CallR ( ErrLGBKReadDBTrailer( pfsapi, szFileName, (BYTE*)ppatchHdr, g_cbPage ) );

	if ( ppatchHdr->m_hdrNormalPage.ulChecksumParity != UlUtilChecksum( (const BYTE*) ppatchHdr, g_cbPage )
		|| 0 != ppatchHdr->m_hdrNormalPage.pgnoThis )
		{
		//  the page has a verification failure
		CallR ( ErrERRCheck( JET_errReadVerifyFailure) );
		}
	
	return JET_errSuccess;
	}

#endif // ELIMINATE_PATCH_FILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_osu\configu.cxx ===
#include "osustd.hxx"


//  Persistent Configuration

#ifdef REGISTRY_OVERRIDE

//  system parameters

LOCAL const DWORD rgparam[] =
	{
	JET_paramSystemPath,
	JET_paramTempPath,
	JET_paramLogFilePath,
	JET_paramLogFileFailoverPath,
	JET_paramBaseName,
	JET_paramMaxSessions,
	JET_paramMaxOpenTables,
	JET_paramPreferredMaxOpenTables,
	JET_paramMaxCursors,
	JET_paramMaxVerPages,
	JET_paramGlobalMinVerPages,
	JET_paramPreferredVerPages,
	JET_paramMaxTemporaryTables,
	JET_paramLogFileSize,
	JET_paramLogBuffers,
	JET_paramLogCheckpointPeriod,
	JET_paramCommitDefault,
	JET_paramCircularLog,
	JET_paramDbExtensionSize,
	JET_paramPageTempDBMin,
	JET_paramPageFragment,
	JET_paramVersionStoreTaskQueueMax, 
	JET_paramCacheSizeMin,
	JET_paramCacheSizeMax,
	JET_paramCheckpointDepthMax,
	JET_paramLRUKCorrInterval,
	JET_paramLRUKHistoryMax,
	JET_paramLRUKPolicy,
	JET_paramLRUKTimeout,
	JET_paramStartFlushThreshold,
	JET_paramStopFlushThreshold,
	JET_paramExceptionAction,
	JET_paramEventLogCache,
	JET_paramRecovery,
	JET_paramEnableOnlineDefrag,
	JET_paramAssertAction,
	JET_paramRFS2IOsPermitted,
	JET_paramRFS2AllocsPermitted,
	JET_paramCheckFormatWhenOpenFail,
	JET_paramEnableIndexChecking,
	JET_paramEnableTempTableVersioning,
	JET_paramZeroDatabaseDuringBackup,
	JET_paramIgnoreLogVersion,
	JET_paramDeleteOldLogs,
	JET_paramEnableImprovedSeekShortcut,
	JET_paramBackupChunkSize,
	JET_paramBackupOutstandingReads,
	JET_paramCreatePathIfNotExist,
	JET_paramPageHintCacheSize,
	-1
	};

LOCAL const _TCHAR* const rglpszParam[] =
	{
	_T( "SystemPath" ),
	_T( "TempPath" ),
	_T( "LogFilePath" ),
	_T( "LogFileFailoverPath" ),
	_T( "BaseName" ),
	_T( "MaxSessions" ),
	_T( "MaxOpenTables" ),
	_T( "PreferredMaxOpenTables" ),
	_T( "MaxCursors" ),
	_T( "MaxVerPages" ),
	_T( "GlobalMinVerPages" ),
	_T( "PreferredVerPages" ),
	_T( "MaxTemporaryTables" ),
	_T( "LogFileSize" ),
	_T( "LogBuffers" ),
	_T( "LogCheckpointPeriod" ),
	_T( "CommitDefault" ),
	_T( "CircularLog" ),
	_T( "DbExtensionSize" ),
	_T( "PageTempDBMin" ),
	_T( "PageFragment" ),
	_T( "VERTasksPostMax" ),
	_T( "CacheSizeMin" ),
	_T( "CacheSizeMax" ),
	_T( "CheckpointDepthMax" ),
	_T( "LRUKCorrInterval" ),
	_T( "LRUKHistoryMax" ),
	_T( "LRUKPolicy" ),
	_T( "LRUKTimeout" ),
	_T( "StartFlushThreshold" ),
	_T( "StopFlushThreshold" ),
	_T( "ExceptionAction" ),
	_T( "EventLogCache" ),
	_T( "Recovery" ),
	_T( "EnableOnlineDefrag" ),
	_T( "AssertAction" ),
	_T( "RFS2IOsPermitted" ),
	_T( "RFS2AllocsPermitted" ),
	_T( "CheckFormatWhenOpenFail" ),
	_T( "EnableIndexChecking" ),
	_T( "EnableTempTableVersioning" ),
	_T( "ZeroDatabaseDuringBackup" ),
	_T( "IgnoreLogVersion" ),
	_T( "DeleteOldLogs" ),
	_T( "EnableImprovedSeekShortcut" ),
	_T( "BackupChunkSize" ),
	_T( "BackupOutstandingReads" ),
	_T( "CreatePathIfNotExist" ),
	_T( "PageHintCacheSize" ),
	NULL
	};

#endif  //  REGISTRY_OVERRIDE

//  loads all system parameter overrides

LOCAL const _TCHAR szParamRoot[] = _T( "System Parameter Overrides" ); 


extern "C"
	{
	JET_ERR JET_API ErrGetSystemParameter( JET_INSTANCE jinst, JET_SESID sesid, unsigned long paramid,
		ULONG_PTR *plParam, char  *sz, unsigned long cbMax);
	JET_ERR JET_API ErrSetSystemParameter( JET_INSTANCE jinst, JET_SESID sesid, unsigned long paramid,
		ULONG_PTR lParam, const char  *sz);
	}

	
void OSUConfigLoadParameterOverrides()
	{
#ifdef REGISTRY_OVERRIDE

	//  read all system parameters from the registry or create null entries if
	//  they do not exist
	
	for ( int iparam = 0; rglpszParam[iparam]; iparam++ )
		{
		_TCHAR szParam[512];
		if ( FOSConfigGet(	szParamRoot,
							rglpszParam[iparam],
							szParam,
							512 ) )
			{
			if ( szParam[0] )
				{
				ErrSetSystemParameter(	0,
										0,
										rgparam[iparam],
										_tcstoul( szParam, NULL, 0 ),
										szParam );
				}
			else
				{
/*				FOSConfigGet() will create the key if it doesn't exist				
				(void)FOSConfigSet(	szParamRoot,
									rglpszParam[iparam],
									szParam );
*/									
				}
			}
		else
			{
			//  UNDONE:  gripe in the event log that the value was too big
			}
		}
		
#endif  //  REGISTRY_OVERRIDE
	}

//  terminate config subsystem

void OSUConfigTerm()
	{
	//  nop
	}

//  init config subsystem

ERR ErrOSUConfigInit()
	{
	//  load configuration
	
	OSUConfigLoadParameterOverrides();

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_osu\eventu.cxx ===
#include "osustd.hxx"
#include "std.hxx"

#include <malloc.h>

void UtilReportEvent(
	const EEventType	type, 
	const CategoryId	catid, 
	const MessageId		msgid, 
	const DWORD			cString, 
	const _TCHAR*		rgpszString[], 
	const DWORD			cbRawData, 
	void*				pvRawData, 
	const INST*			pinst,
	const LONG			lEventLoggingLevel )
	{
	extern LONG			g_lEventLoggingLevel;
	extern BOOL			g_fNoInformationEvent;
	const LONG			levelMaxReportable		= ( NULL != pinst ?  pinst->m_lEventLoggingLevel : g_lEventLoggingLevel );
	const UINT			cAdditionalParam = 3;
	
	if ( lEventLoggingLevel > levelMaxReportable )
		{
		return;
	 	}
	else if ( eventInformation == type )
		{
		const BOOL	fIgnoreEvent	= ( NULL != pinst ? pinst->m_fNoInformationEvent : g_fNoInformationEvent );
		if ( fIgnoreEvent )
			return;
		}


	const _TCHAR**	rgpsz	= (const _TCHAR**)_alloca( sizeof( const _TCHAR* ) * ( cString + cAdditionalParam ) );

	//  validate IN args

    Assert( catid < MAC_CATEGORY );
    Assert( DWORD( WORD( catid ) ) == catid );
    Assert( DWORD( WORD( cString + 2 ) ) == cString + 2 );

    //  get event source and process ID strings
	
	if ( pinst && pinst->m_szEventSource && pinst->m_szEventSource[0] != 0 )
   		rgpsz[0] = pinst->m_szEventSource;
   	else if ( g_szEventSource[0] != 0 )
   		rgpsz[0] = g_szEventSource;
   	else
		rgpsz[0] = SzUtilProcessName();
 
	_TCHAR szPID[10];
	_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
	rgpsz[1] = szPID;

	_TCHAR szDisplayName[JET_cbFullNameMost + 3]; // 3 = sizof(": ") + 1
	/*
	IF 		m_szDisplayName exists
   	THEN 	display m_szDisplayName
   	ELSE IF 	m_szInstanceName exists
   		 THEN	display m_szInstanceName
   	ELSE	display nothing
	*/
	if ( pinst && pinst->m_szDisplayName ) 
		{
		_stprintf( szDisplayName, _T( "%s: " ), pinst->m_szDisplayName );
			}
	else if ( pinst && pinst->m_szInstanceName ) 
		{
		_stprintf( szDisplayName, _T( "%s: " ), pinst->m_szInstanceName );
		}
	else 
		{
		_tcscpy( szDisplayName, "" );
		}
	rgpsz[2] = szDisplayName;
		
	//  copy in remaining strings

	UtilMemCpy( &rgpsz[3], rgpszString, sizeof(const _TCHAR*) * cString );

	//	Get event source key in case we need to open the event source.

	const _TCHAR* szEventSourceKey;
	
	if ( pinst && pinst->m_szEventSourceKey && pinst->m_szEventSourceKey[0] != 0 )
   		szEventSourceKey = pinst->m_szEventSourceKey;
   	else if ( g_szEventSourceKey[0] != 0 )
   		szEventSourceKey = g_szEventSourceKey;
   	else
		szEventSourceKey = SzUtilImageVersionName();
 
	//  the event log isn't open
	
	OSEventReportEvent( szEventSourceKey, type, catid, msgid, 
						cString + cAdditionalParam, rgpsz, cbRawData, pvRawData );
			
	}


//	reports error event in the context of a category and optionally in the
//	context of a MessageId.  If the MessageId is 0, then a MessageId is chosen
//	based on the given error code.  If MessageId is !0, then the appropriate
//	event is reported

void UtilReportEventOfError( CategoryId catid, MessageId msgid, ERR err, const INST *pinst )
	{
	_TCHAR			szT[16];
	const _TCHAR	*rgszT[1];

	_stprintf( szT, _T( "%d" ), err );
	rgszT[0] = szT;

	Assert( 0 != msgid );
//	the following code is dead, as the
//	assert above affirms
//	if ( 0 == msgid && JET_errDiskFull == err )
//		{
//		msgid = DISK_FULL_ERROR_ID;
//		rgszT[0] = pinst->m_plog->m_szJetLog;
//		}

	UtilReportEvent( eventError, catid, msgid, 1, rgszT, 0, NULL, pinst );
	}


//  terminate event subsystem

void OSUEventTerm()
	{
	//  nop
	}


//  init event subsystem

ERR ErrOSUEventInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_osu\fileu.cxx ===
#include "osustd.hxx"


/********************
/* optimised version of UlUtilChecksum for calculating the
/* checksum on pages. we assume that the pagesize is a multiple
/* of 16 bytes, this is true for 4k and 8k pages.
/*
/* because it is a bottleneck we turn on the optimisations
/* even in debug 
/*
/**/
#pragma optimize( "agtw", on )

//  ================================================================
inline void CachePrefetch ( const void * const p )
//  ================================================================
	{
#ifdef _X86_
	  _asm
	  {
	   mov  eax,p
 
	   _emit 0x0f  // PrefetchNTA
	   _emit 0x18
	   _emit 0x00
	  }
#endif
	}

typedef DWORD (*PFNCHECKSUM)( const BYTE * const, const DWORD );

//  ================================================================
static DWORD DwChecksumESEBigEndian( const BYTE * const pb, const DWORD cb )
//  ================================================================
	{
	PFNCHECKSUM pfn = DwChecksumESEBigEndian;
	
	const DWORD	* pdw 			= (DWORD *)pb;
	INT cbT						= cb;
	
	DWORD	dwChecksum = ReverseBytesOnBE( 0x89abcdef ) ^ pdw[0];

	do
		{
		dwChecksum 	^= pdw[0]
					^ pdw[1]
					^ pdw[2]
					^ pdw[3]
					^ pdw[4]
					^ pdw[5]
					^ pdw[6]
					^ pdw[7];
		cbT -= 32;
		pdw += 8;
		} while ( cbT );

	dwChecksum = ReverseBytesOnBE( dwChecksum );

	return dwChecksum;
	}


//  ================================================================
static DWORD DwChecksumESEPrefetch( const BYTE * const pb, const DWORD cb )
//  ================================================================
	{
	PFNCHECKSUM pfn = DwChecksumESEPrefetch;
	
	const DWORD	* pdw 			= (DWORD *)pb;
	INT cbT						= cb;

	//	touching this memory puts the page in the processor TLB (needed
	//	for prefetch) and brings in the first cacheline (cacheline 0)
	
	DWORD	dwChecksum = 0x89abcdef ^ pdw[0];

	do
		{
		CachePrefetch ( pdw + 16 );	
		dwChecksum 	^= pdw[0]
					^ pdw[1]
					^ pdw[2]
					^ pdw[3]
					^ pdw[4]
					^ pdw[5]
					^ pdw[6]
					^ pdw[7];
		cbT -= 32;
		pdw += 8;
		} while ( cbT );

	return dwChecksum;
	}


//  ================================================================
static DWORD DwChecksumESENoPrefetch( const BYTE * const pb, const DWORD cb )
//  ================================================================
	{
	PFNCHECKSUM pfn = DwChecksumESENoPrefetch;
	
	const DWORD	* pdw 			= (DWORD *)pb;
	INT cbT						= cb;
	
	DWORD	dwChecksum = 0x89abcdef ^ pdw[0];

	do
		{
		dwChecksum 	^= pdw[0]
					^ pdw[1]
					^ pdw[2]
					^ pdw[3]
					^ pdw[4]
					^ pdw[5]
					^ pdw[6]
					^ pdw[7];
		cbT -= 32;
		pdw += 8;
		} while ( cbT );

	return dwChecksum;
	}


//  ================================================================
static DWORD DwChecksumESE64Bit( const BYTE * const pb, const DWORD cb )
//  ================================================================
	{
	const unsigned __int64	* pqw 	= (unsigned __int64 *)pb;
	unsigned __int64	qwChecksum	= 0;
	DWORD cbT						= cb;
	
	//	checksum the first four bytes twice to remove the checksum
	
	qwChecksum ^= pqw[0] & 0x00000000FFFFFFFF;
		
	do
		{
		qwChecksum ^= pqw[0];
		qwChecksum ^= pqw[1];
		qwChecksum ^= pqw[2];
		qwChecksum ^= pqw[3];
		cbT -= ( 4 * sizeof( unsigned __int64 ) );
		pqw += 4;
		} while ( cbT );

	const unsigned __int64 qwUpper = ( qwChecksum >> ( sizeof( DWORD ) * 8 ) );
	const unsigned __int64 qwLower = qwChecksum & 0x00000000FFFFFFFF;
	qwChecksum = qwUpper ^ qwLower;
	
	const DWORD ulChecksum = static_cast<DWORD>( qwChecksum ) ^ 0x89abcdef;
	return ulChecksum;
	}


//  ================================================================
DWORD UlUtilChecksum( const BYTE* pb, DWORD cb )
//  ================================================================
	{
	static PFNCHECKSUM pfnChecksumESE = NULL;
	
	if( NULL == pfnChecksumESE )
		{
		if( !fHostIsLittleEndian )
			{
			pfnChecksumESE = DwChecksumESEBigEndian;
			}
		else if( sizeof( DWORD_PTR ) == sizeof( DWORD ) * 2 )
			{
			pfnChecksumESE = DwChecksumESE64Bit;
			}
		else if( FHardwareCanPrefetch() )
			{
			pfnChecksumESE = DwChecksumESEPrefetch;
			}
		else
			{
			pfnChecksumESE = DwChecksumESENoPrefetch;
			}
		}
	return (*pfnChecksumESE)( pb, cb );
	}
#pragma optimize( "", on )


INLINE BOOL FValidCbPage( const ULONG cb )
	{
	return ( 0 == cb || cbPageDefault == cb || 2048 == cb || 8192 == cb );
	}

/****************************
/*	read shadowed header. The header is multiple sectors.
/*  Checksum must be the first 4 bytes of the header.
/**/

#define HEADER_OK	0
#define PRIMARY_BAD	1
#define SHADOW_BAD	2
#define	HEADER_BAD 	( PRIMARY_BAD | SHADOW_BAD )

ERR ErrUtilOnlyReadShadowedHeader(
	IFileSystemAPI	* const pfsapi,
	const _TCHAR	* szFileName,
	BYTE			* pbHeader,
	const DWORD		cbHeader,
	const ULONG		cbOffsetOfPageSize,
	INT				* pbHeaderDamaged,
	IFileAPI		* const pfapi )
	{
	ERR				err			= JET_errSuccess;
	IFileAPI		* pfapiT	= NULL;
	ERR				errT		= JET_errSuccess;
	BYTE			* pbT		= NULL;

	*pbHeaderDamaged = HEADER_OK;
	pbT = (BYTE*)PvOSMemoryHeapAlloc( cbHeader );
	if ( pbT == NULL )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	if ( !pfapi )
		{
		pfapiT = NULL;
		
		//  open the specified file

		Call( pfsapi->ErrFileOpen( szFileName, &pfapiT, fTrue ) );
		}
	else
		{
		pfapiT = pfapi;
		}

	//  read the primary copy of the header into the specified buffer

	err = pfapiT->ErrIORead( QWORD( 0 ), cbHeader, pbHeader );

	//  the primary copy of the header is damaged
	
	if ( err < 0 )
		{
		*pbHeaderDamaged |= PRIMARY_BAD;
		}
	else if ( UlUtilChecksum( pbHeader, cbHeader ) != DWORD( *( (LittleEndian<DWORD>*)pbHeader ) ) )
		{
		*pbHeaderDamaged |= PRIMARY_BAD;

		// checksum error in header
		// check if pagesize is wrong (if call is made with location of pagesize specified)
		if ( 0 != cbOffsetOfPageSize )
			{
			Assert( cbHeader > 0 );
			Assert( FValidCbPage( cbHeader ) );

			// requested size must "cover" the cbPageSize member in structure
			Assert( cbHeader >= cbOffsetOfPageSize + sizeof(ULONG));

			ULONG	cbPageSize 	= *( (UnalignedLittleEndian<ULONG> *)( pbHeader + cbOffsetOfPageSize ) );
			if ( FValidCbPage( cbPageSize ) )
				{
				if ( 0 == cbPageSize )
					{
					cbPageSize = cbPageDefault;
					}
				if ( cbPageSize != cbHeader )
					{
					Call( ErrERRCheck( JET_errPageSizeMismatch ) );
					}
				}
			}
		}

	errT = pfapiT->ErrIORead( QWORD( cbHeader ), cbHeader, pbT );

	if ( errT < 0 || UlUtilChecksum( pbT, cbHeader ) != *( (LittleEndian<DWORD>*) pbT ) )
		{
		*pbHeaderDamaged |= SHADOW_BAD;
		if ( errT >= 0 )
			{
			errT = ErrERRCheck( JET_errDiskIO );
			}
		}
	switch ( *pbHeaderDamaged )
		{
	case HEADER_OK:
		if ( memcmp( pbT, pbHeader, cbHeader ) != 0 )
			{
			*pbHeaderDamaged = PRIMARY_BAD;
			}
		else
			{
			break;
			}
	case PRIMARY_BAD:
		Assert( *pbHeaderDamaged == PRIMARY_BAD );
		memcpy( pbHeader, pbT, cbHeader );
		break;
	case SHADOW_BAD:
		Assert( *pbHeaderDamaged == SHADOW_BAD );
		break;
	case HEADER_BAD:
		Assert( *pbHeaderDamaged == HEADER_BAD );
		err = errT;
		break;
	default:
		Assert( fFalse );
		}

#ifdef NEVER
	if ( *pfPrimaryDamaged )
		{
		//  read the secondary copy of the header into the specified buffer
		err = pfapiT->ErrIORead( QWORD( cbHeader ), cbHeader, pbHeader );

		//  the secondary copy of the header is damaged
		
		if ( err >= 0 && UlUtilChecksum( pbHeader, cbHeader ) != *( (LittleEndian<DWORD>*) pbHeader ) )
			{
			//  we have failed to read the header
			err = ErrERRCheck( JET_errDiskIO );
			}
		}
#endif		
		
HandleError:
	if ( !pfapi )
		{
		delete pfapiT;
		}
	OSMemoryHeapFree( pbT );
	return err;
	}


/***************************
/* Read shadowed header
/*
/* PURPOSE: Read only access to file.
/*	It will not try to patch damaged
/*	primary page with secondary one if last is OK
/**/
ERR ErrUtilReadShadowedHeader(
	IFileSystemAPI	* const pfsapi,
	const _TCHAR	* szFileName,
	BYTE*			pbHeader,
	const DWORD		cbHeader,
	const ULONG		cbOffsetOfPageSize,
	IFileAPI 		* const pfapi )
	{
	ERR				err;
	INT				bHeaderDamaged;

	Call( ErrUtilOnlyReadShadowedHeader(	pfsapi, 
											szFileName, 
											pbHeader, 
											cbHeader, 
											cbOffsetOfPageSize, 
											&bHeaderDamaged, 
											pfapi ) );

	//	if succeed to read the page but primary page is damaged
	//	it wont be fixed anyway so put a message in event log, 
	//	because assumption that file is read only for this user
	if ( bHeaderDamaged )
		{
		Assert( bHeaderDamaged == PRIMARY_BAD || bHeaderDamaged == SHADOW_BAD );
		
		const _TCHAR	* rgszT[1] = { szFileName };
		UtilReportEvent(
			eventWarning,
			LOGGING_RECOVERY_CATEGORY,
			( PRIMARY_BAD == bHeaderDamaged ? PRIMARY_PAGE_READ_FAIL_ID : SHADOW_PAGE_READ_FAIL_ID ),
			1,
			rgszT );
		}
			
HandleError:
	return err;
	}
	

/***************************
/* Read shadowed header abd patch primary page if neccessary
/*
/* if primary page is corrupted and secondary is fine 
/* then patch the primary page with the secondary
/*
/* WARNING: Write access is neccessary
/**/
ERR ErrUtilReadAndFixShadowedHeader(
	IFileSystemAPI *const	pfsapi,
	const _TCHAR*				szFileName,
	BYTE*						pbHeader,
	const DWORD					cbHeader,
	const ULONG					cbOffsetOfPageSize,
	IFileAPI *const			pfapi )
	{
	ERR err;
	INT bHeaderDamaged;
	
	Call( ErrUtilOnlyReadShadowedHeader(	pfsapi, 
											szFileName, 
											pbHeader, 
											cbHeader, 
											cbOffsetOfPageSize, 
											&bHeaderDamaged, 
											pfapi ) );

	if ( bHeaderDamaged )
		{
		Assert( bHeaderDamaged == PRIMARY_BAD || bHeaderDamaged == SHADOW_BAD );
		// try to patch the bad page
		// and if do not succeed then put the warning in the event log

		IFileAPI	*pfapiT = NULL;

		if ( !pfapi )
			{
			
			//  open the specified file

			err = pfsapi->ErrFileOpen( szFileName, &pfapiT, fFalse );
			}
		else
			{
			//	file is already open 
			pfapiT = pfapi;
			err = JET_errSuccess;
			}
		if ( err >= 0 )
			{
			Assert( bHeaderDamaged == PRIMARY_BAD || bHeaderDamaged == SHADOW_BAD );
			err = pfapiT->ErrIOWrite( QWORD( (bHeaderDamaged == PRIMARY_BAD)?0: cbHeader ), cbHeader, pbHeader );
			}
		if ( err < 0 )
			{
			CHAR szT[12];
			const _TCHAR* rgszT[2] = { szFileName, szT };
			_itoa( err, szT, 10 );

			UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY, SHADOW_PAGE_WRITE_FAIL_ID, 2, rgszT );
			}
		if ( !pfapi )
			{
			//	we opened the file on behalf of the user, so we should now clean it up
			
			delete pfapiT;
			}
		}

HandleError:
	return err;
	}


ERR ErrUtilWriteShadowedHeader(	IFileSystemAPI *const	pfsapi, 
								const _TCHAR			*szFileName, 
								const BOOL				fAtomic,
								BYTE					*pbHeader, 
								const DWORD 			cbHeader, 
								IFileAPI *const			pfapi )
	{
	ERR err;
	IFileAPI *pfapiT;
	
	if ( !pfapi )
		{
		pfapiT = NULL;
		
		//  open the specified file

		err = pfsapi->ErrFileOpen( szFileName, &pfapiT );

		//  we could not open the file

		if ( JET_errFileNotFound == err )
			{
			//  create the specified file

			Call( pfsapi->ErrFileCreate( szFileName, &pfapiT, fAtomic ) );
			Call( pfapiT->ErrSetSize( 2 * QWORD( cbHeader ) ) );
			}
		Call( err );
		}
	else
		{
		pfapiT = pfapi;
		}

	//  compute the checksum of the header to write

	*( (LittleEndian<DWORD>*) pbHeader ) = UlUtilChecksum( pbHeader, cbHeader );
	
	//  write two copies of the header synchronously.  if one is corrupted,
	//  the other will be valid containing either the old or new header data

	Call( pfapiT->ErrIOWrite( QWORD( 0 ), cbHeader, pbHeader ) );
	Call( pfapiT->ErrIOWrite( QWORD( cbHeader ), cbHeader, pbHeader ) );

HandleError:
	if ( !pfapi )
		{
		delete pfapiT;
		}

	if ( err < 0 )
		{
		CHAR szT[12];
		const _TCHAR* rgszT[2] = { szFileName, szT };
		_itoa( err, szT, 10 );

		UtilReportEvent( eventError, LOGGING_RECOVERY_CATEGORY, SHADOW_PAGE_WRITE_FAIL_ID, 2, rgszT );
		}
		
	return err;
	}

ERR ErrUtilFullPathOfFile( IFileSystemAPI* const pfsapi, _TCHAR* const szPathOnly, const _TCHAR* const szFile )
	{
	ERR err;
	_TCHAR szAbsPath[IFileSystemAPI::cchPathMax];
	_TCHAR szDir[IFileSystemAPI::cchPathMax];
	_TCHAR szT[IFileSystemAPI::cchPathMax];

	CallR( pfsapi->ErrPathComplete( szFile, szAbsPath ) );

	CallR( pfsapi->ErrPathParse( szAbsPath, szDir, szT, szT ) );
	szT[0] = _T( '\0' );
	CallR( pfsapi->ErrPathBuild( szDir, szT, szT, szPathOnly ) );

	return JET_errSuccess;
	}



ERR ErrUtilCreatePathIfNotExist(	IFileSystemAPI *const	pfsapi,
									const _TCHAR 				*szPath,
								 	_TCHAR *const				szAbsPath )
	{
	ERR		err;
	CHAR 	szPathT[IFileSystemAPI::cchPathMax];
	CHAR	*psz, *pszT, *pszEnd, *pszMove;
	CHAR	ch;
	BOOL	fFileName = fFalse;

	//	copy the path, remove any trailing filename, 
	//		and point to the ending path-delimiter

	strcpy( szPathT, szPath );
	OSSTRCharPrev( szPathT, szPathT + strlen( szPathT ), &pszEnd );
	while ( *pszEnd != _T( bPathDelimiter ) && pszEnd >= szPathT )
		{
		fFileName = fTrue;
		OSSTRCharPrev( szPathT, pszEnd, &pszMove );
		if ( pszMove < pszEnd )
			{
			pszEnd = pszMove;
			}
		else
			{

			//	we cannot move backwards anymore

			Assert( pszMove == szPathT );

			//	there were no path delimiters which means we
			//		were given only a filename 

			//	resolve the path before returning

			err = pfsapi->ErrPathComplete( szPath, szAbsPath );
			CallS( err );
			
			return JET_errSuccess;
			}
		}
				
	Assert( *pszEnd == _T( bPathDelimiter ) );
	pszEnd[1] = _T( '\0' );

	//	loop until we find a directory that exists

	psz = pszEnd;
	do
		{

		//	try to validate the current path

		Assert( *psz == _T( bPathDelimiter ) );
		ch = psz[1];
		psz[1] = _T( '\0' );
		err = ErrUtilDirectoryValidate( pfsapi, szPathT );
		psz[1] = ch;
		if ( err == JET_errInvalidPath )
			{

			//	the path does not exist, so we will chop
			//	off a subdirectory and try to validate
			//	the parent

			OSSTRCharPrev( szPathT, psz, &pszT );
			while ( *pszT != _T( bPathDelimiter ) && pszT >= szPathT )
				{
				OSSTRCharPrev( szPathT, pszT, &pszMove );
				if ( pszMove < pszT )
					{
					pszT = pszMove;
					}
				else
					{

					//	we cannot move backwards anymore

					Assert( pszMove == szPathT );

					//	none of the directories in the path exist
					//	we need to start creating at this point
					//		from the outer-most directory

					goto BeginCreation;
					}
				}

			//	move the real path ptr
			
			psz = pszT;
			}
		else
			{

			//	we found an existing directory

			CallS( err );			
			}
		}
	while ( err == JET_errInvalidPath );

	//	loop until all directories are created

	while ( psz < pszEnd )
		{

		//	move forward to the next directory

		Assert( *psz == _T( bPathDelimiter ) );
		psz++;
		while ( *psz != _T( bPathDelimiter ) )
			{
#ifdef DEBUG
			OSSTRCharNext( psz, &pszMove );

			//	if this assert fires, it means we scanned to the end 
			//		of the path string and did not find a path
			//		delimiter; this should never happen because
			//		we append a path delimiter at the start of
			//		this function

			Assert( pszMove <= pszEnd );

			//	if this assert fires, the one before it should have
			//		fired as well; this means that we can no longer
			//		move to the next character because the string
			//		is completely exhausted
			
			Assert( pszMove > psz );

			//	move next

			psz = pszMove;
#else	//	!DEBUG
			OSSTRCharNext( psz, &psz );
#endif	//	DEBUG
			}

BeginCreation:

		Assert( psz <= pszEnd );
		Assert( *psz == _T( bPathDelimiter ) );

		//	bug 99941: make sure the name of the directory we
		//		need to create is not already in use by a file

		ch = psz[0];
		psz[0] = _T( '\0' );
		err = ErrUtilPathExists( pfsapi, szPathT );
		if ( err >= JET_errSuccess )
			{
			return ErrERRCheck( JET_errInvalidPath );
			}
		else if ( JET_errFileNotFound != err )
			{
			return err;		//	unexpected error
			}
		psz[0] = ch;

		//	create the directory

		ch = psz[1];
		psz[1] = _T( '\0' );
		CallR( pfsapi->ErrFolderCreate( szPathT ) );
		psz[1] = ch;
		}

	//	verify the new path and prepare the absolute path

	CallS( ErrUtilDirectoryValidate( pfsapi, szPathT, szAbsPath ) );
	if ( fFileName && szAbsPath )
		{
		OSSTRAppendPathDelimiter( szAbsPath, fTrue );

		//	copy the filename over to the absolute path as well

#ifdef DEBUG
		Assert( *pszEnd == _T( bPathDelimiter ) );
		Assert( pszEnd[1] == _T( '\0' ) );
		pszT = const_cast< _TCHAR * >( szPath ) + ( pszEnd - szPathT );
		Assert( *pszT == _T( bPathDelimiter ) );
		Assert( pszT[1] != _T( '\0' ) );
#endif	//	DEBUG
		strcpy( szAbsPath + strlen( szAbsPath ), szPath + ( pszEnd - szPathT ) + 1 );
		}

	return JET_errSuccess;
	}

//  tests if the given path exists.  the full path of the given path is
//  returned in szAbsPath if that path exists and szAbsPath is not NULL

ERR ErrUtilPathExists(	IFileSystemAPI* const	pfsapi,
						const _TCHAR* const		szPath,
						_TCHAR* const			szAbsPath )
	{
	ERR				err		= JET_errSuccess;
	IFileFindAPI*	pffapi	= NULL;

	Call( pfsapi->ErrFileFind( szPath, &pffapi ) );
	Call( pffapi->ErrNext() );
	if ( szAbsPath )
		{
		Call( pffapi->ErrPath( szAbsPath ) );
		}

	delete pffapi;
	return JET_errSuccess;

HandleError:
	delete pffapi;
	if ( szAbsPath )
		{
		_tcscpy( szAbsPath, _T( "" ) );
		}
	return err;
	}


ERR ErrUtilPathComplete(
	IFileSystemAPI	* const pfsapi,
	const _TCHAR	* const szPath,
	_TCHAR			* const szAbsPath,
	const BOOL		fPathMustExist )
	{
	ERR				err;
	CHAR			rgchName[IFileSystemAPI::cchPathMax];
	
	err = pfsapi->ErrPathComplete( szPath, rgchName );
	Assert( JET_errFileNotFound != err );
	Call( err );

	//	at this point we have a "well-formed" path
	//	do a FileFindExact to try an convert from an 8.3 equivalent to the full path
	//	BUT: if the file doesn't exist continue on for the temp database/SFS error-handling
	//	below
		
	err = ErrUtilPathExists( pfsapi, rgchName, szAbsPath );
	if( JET_errFileNotFound == err
		&& !fPathMustExist )
		{
		//	the file isn't there. we'll deal with this later :-)
		strcpy( szAbsPath, rgchName );
		err = JET_errSuccess;
		}
	Call( err );

HandleError:
	Assert( JET_errFileNotFound != err || fPathMustExist );
	return err;
	}

	


//  tests if the given path is read only

ERR ErrUtilPathReadOnly(	IFileSystemAPI* const	pfsapi,
							const _TCHAR* const		szPath,
							BOOL* const				pfReadOnly )
	{
	ERR				err		= JET_errSuccess;
	IFileFindAPI*	pffapi	= NULL;

	Call( pfsapi->ErrFileFind( szPath, &pffapi ) );
	Call( pffapi->ErrNext() );
	Call( pffapi->ErrIsReadOnly( pfReadOnly ) );

	delete pffapi;
	return JET_errSuccess;

HandleError:
	delete pffapi;
	*pfReadOnly = fFalse;
	return err;
	}

//	checks whether or not the specified directory exists
//	if not, JET_errInvalidPath will be returned.
//	if so, JET_errSuccess will be returned and szAbsPath
//	will contain the full path to the directory.

ERR ErrUtilDirectoryValidate(	IFileSystemAPI* const	pfsapi,
								const _TCHAR* const		szPath,
								_TCHAR* const			szAbsPath )
	{
	ERR		err			= JET_errSuccess;
	_TCHAR	szFolder[ IFileSystemAPI::cchPathMax ];
	_TCHAR	szT[ IFileSystemAPI::cchPathMax ];
	
	//  extract the folder from the path

	Call( pfsapi->ErrPathParse( szPath, szFolder, szT, szT ) );

	//  see if the path exists

	Call( ErrUtilPathExists( pfsapi, szFolder, szAbsPath ) );

	return JET_errSuccess;

HandleError:
	if ( JET_errFileNotFound == err )
		{
		err = ErrERRCheck( JET_errInvalidPath );
		}
	if ( szAbsPath )
		{
		_tcscpy( szAbsPath, _T( "" ) );
		}
	return err;
	}


//  log file extension pattern buffer

ULONG	cbLogExtendPattern;
BYTE*	rgbLogExtendPattern;

INLINE ERR ErrUtilIApplyLogExtendPattern(	IFileAPI *const pfapi,
											const QWORD qwSize,
											const QWORD ibFormatted = 0 )
	{
	ERR		err		= JET_errSuccess;
	QWORD	ib;
	QWORD	cbWrite;
	
	for ( ib = ibFormatted; ib < qwSize; ib += cbWrite )
		{
		//  compute the size of the current chunk to be written.  this will
		//  account for the fact that the extension area is not necessarily
		//  chunk aligned at its start or end

		cbWrite = min( cbLogExtendPattern - ib % cbLogExtendPattern, qwSize - ib );

		//  zero this portion of the file with a sync write.  we use single
		//  sync writes to extend the file because it is optimal on NT due
		//  to the way its file security works wrt file extension

		Call( pfapi->ErrIOWrite( ib, ULONG( cbWrite ), rgbLogExtendPattern ) );
		}

	return JET_errSuccess;

HandleError:
	return err;
	}


//	create a log file

ERR ErrUtilCreateLogFile(	IFileSystemAPI *const	pfsapi,
							const _TCHAR* const		szPath,
							IFileAPI **const		ppfapi,
							const QWORD				qwSize,
							const BOOL				fOverwriteExisting )
	{
	ERR err;

	//	verify input

	Assert( szPath );
	Assert( ppfapi );

	//	create the empty file

	CallR( pfsapi->ErrFileCreate( szPath, ppfapi, fFalse, fFalse, fOverwriteExisting ) );

	//	apply the pattern to it

	err = ErrUtilIApplyLogExtendPattern( *ppfapi, qwSize );
	if ( err < JET_errSuccess )
		{

		//	the operation has failed

		//	close the file

		delete *ppfapi;
		*ppfapi = NULL;

		//	delete the file
		//	it should be deletable, unless by some random act it was made read-only
		//		or opened by another process; in the failure case, we will leave 
		//		the malformed log file there, but it will be reformatted/resized
		//		before we actually use it -- in a sense, it will be "recreated"
		//		in-place

		ERR	errDelFile = pfsapi->ErrFileDelete( szPath );
#ifdef DEBUG
		if ( JET_errSuccess != errDelFile
			&& !FRFSFailureDetected( OSFileDelete ) )
			{
			CallS( errDelFile );
			}
#endif	//	DEBUG
		}

	return err;
	}


//	re-format an existing log file

ERR ErrUtilFormatLogFile( IFileAPI *const pfapi, const QWORD qwSize, const QWORD ibFormatted )
	{
	ERR 	err;
	QWORD	qwRealSize;

	//	apply the pattern to the log file
	//		(the file will expand if necessary)

	CallR( ErrUtilIApplyLogExtendPattern( pfapi, qwSize, ibFormatted ) );

	//	we may need to truncate the rest of the file

	CallR( pfapi->ErrSize( &qwRealSize ) );
	Assert( qwRealSize >= qwSize );
	if ( qwRealSize > qwSize )
		{

		//	do the truncation

		CallR( pfapi->ErrSetSize( qwSize ) );
		}

	return JET_errSuccess;
	}


COSMemoryMap osmmOSUFile;

//  init file subsystem

ERR ErrOSUFileInit()
	{
	ERR err = JET_errSuccess;

	//  reset all pointers

	rgbLogExtendPattern = NULL;

	//  init log file extension buffer

	if ( COSMemoryMap::FCanMultiMap() )
		{
		//  set all configuration defaults

		cbLogExtendPattern = 1 * 1024 * 1024;

		//  allocate log file extension buffer by allocating the smallest chunk of page
		//  store possible and remapping it consecutively in memory until we hit the
		//  desired chunk size

		//	init the memory map

		COSMemoryMap::ERR errOSMM;
		errOSMM = osmmOSUFile.ErrOSMMInit();
		if ( COSMemoryMap::errSuccess != errOSMM )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		//	allocate the pattern

		errOSMM = osmmOSUFile.ErrOSMMPatternAlloc(	OSMemoryPageReserveGranularity(), 
													cbLogExtendPattern, 
													(void**)&rgbLogExtendPattern );
		if ( COSMemoryMap::errSuccess != errOSMM )
			{
			AssertSz(	COSMemoryMap::errOutOfBackingStore == errOSMM ||
						COSMemoryMap::errOutOfAddressSpace == errOSMM ||
						COSMemoryMap::errOutOfMemory == errOSMM, 
						"unexpected error while allocating memory pattern" );
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		Assert( rgbLogExtendPattern );
		}
	else
		{
		//  set all configuration defaults

		cbLogExtendPattern = 64 * 1024;

		//  allocate the log file extension buffer

		if ( !( rgbLogExtendPattern = (BYTE*)PvOSMemoryPageAlloc( size_t( cbLogExtendPattern ), NULL ) ) )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		}

	ULONG ib;
	ULONG cb;

	cb = 512;	//	this must be EXACTLY 512 bytes (not 1 sector)

	Assert( bLOGUnusedFill == 0xDA );	//	don't let this change
	Assert( cbLogExtendPattern >= cb );
	Assert( 0 == ( cbLogExtendPattern % cb ) );

	//	make the unique 512 byte logfile pattern

	memset( rgbLogExtendPattern, bLOGUnusedFill, cb );
	for ( ib = 0; ib < cb; ib += 16 )
		{
		rgbLogExtendPattern[ib] = BYTE( bLOGUnusedFill + ib );
		}

	//	copy it until we fill the whole buffer

	for ( ib = cb; ib < cbLogExtendPattern; ib += cb )
		{
		memcpy( rgbLogExtendPattern + ib, rgbLogExtendPattern, cb );
		}

	return JET_errSuccess;

HandleError:
	OSUFileTerm();
	return err;
	}


//  terminate file subsystem

void OSUFileTerm()
	{
	if ( COSMemoryMap::FCanMultiMap() )
		{

		//  free log file extension buffer

		if ( rgbLogExtendPattern )
			{
			osmmOSUFile.OSMMPatternFree();
			rgbLogExtendPattern = NULL;
			}

		//	term the memory map

		osmmOSUFile.OSMMTerm();
		}
	else
		{
		//  free log file extension buffer

		if ( rgbLogExtendPattern )
			{
			OSMemoryPageFree( rgbLogExtendPattern );
			rgbLogExtendPattern = NULL;
			}
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_osu\osustd.cxx ===
#include "osustd.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_osu\osu.cxx ===
#include "osustd.hxx"


//  init OSU subsystem

const ERR ErrOSUInit()
	{
	ERR err;

	//  init the OS subsystem

	Call( ErrOSInit() );
	
	//  initialize all OSU subsystems in dependency order

	Call( ErrOSUTimeInit() );
	Call( ErrOSUConfigInit() );
	Call( ErrOSUEventInit() );
	Call( ErrOSUSyncInit() );
	Call( ErrOSUFileInit() );
	Call( ErrOSUNormInit() );

	return JET_errSuccess;

HandleError:
	OSUTerm();
	return err;
	}

//  terminate OSU subsystem

void OSUTerm()
	{
	//  terminate all OSU subsystems in reverse dependency order

	OSUNormTerm();
	OSUFileTerm();
	OSUSyncTerm();
	OSUEventTerm();
	OSUConfigTerm();
	OSUTimeTerm();

	//  term the OS subsystem

	OSTerm();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_osu\timeu.cxx ===
#include "osustd.hxx"


#include <math.h>
#define AFX_STATIC_DATA
#define AFX_STATIC
#define AFXAPI
#define DATE double
#define FALSE 0
#define TRUE 1

///////////////////////////////////////////////////////////////////////////////
//  BEGIN:  OLE DATE code copied from VC6\MFC\SRC\olevar.cpp
///////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// COleDateTime class HELPER definitions

// Verifies will fail if the needed buffer size is too large
#define MAX_TIME_BUFFER_SIZE    128         // matches that in timecore.cpp
#define MIN_DATE                (-657434L)  // about year 100
#define MAX_DATE                2958465L    // about year 9999

// Half a second, expressed in days
#define HALF_SECOND  (1.0/172800.0)

// One-based array of days in year at month start
AFX_STATIC_DATA int _afxMonthDays[13] =
	{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};

/////////////////////////////////////////////////////////////////////////////
// COleDateTime class HELPERS - implementation

AFX_STATIC BOOL AFXAPI _AfxOleDateFromTm(WORD wYear, WORD wMonth, WORD wDay,
	WORD wHour, WORD wMinute, WORD wSecond, DATE& dtDest)
{
	// Validate year and month (ignore day of week and milliseconds)
	if (wYear > 9999 || wMonth < 1 || wMonth > 12)
		return FALSE;

	//  Check for leap year and set the number of days in the month
	BOOL bLeapYear = ((wYear & 3) == 0) &&
		((wYear % 100) != 0 || (wYear % 400) == 0);

	int nDaysInMonth =
		_afxMonthDays[wMonth] - _afxMonthDays[wMonth-1] +
		((bLeapYear && wDay == 29 && wMonth == 2) ? 1 : 0);

	// Finish validating the date
	if (wDay < 1 || wDay > nDaysInMonth ||
		wHour > 23 || wMinute > 59 ||
		wSecond > 59)
	{
		return FALSE;
	}

	// Cache the date in days and time in fractional days
	long nDate;
	double dblTime;

	//It is a valid date; make Jan 1, 1AD be 1
	nDate = wYear*365L + wYear/4 - wYear/100 + wYear/400 +
		_afxMonthDays[wMonth-1] + wDay;

	//  If leap year and it's before March, subtract 1:
	if (wMonth <= 2 && bLeapYear)
		--nDate;

	//  Offset so that 12/30/1899 is 0
	nDate -= 693959L;

	dblTime = (((long)wHour * 3600L) +  // hrs in seconds
		((long)wMinute * 60L) +  // mins in seconds
		((long)wSecond)) / 86400.;

	dtDest = (double) nDate + ((nDate >= 0) ? dblTime : -dblTime);

	return TRUE;
}

AFX_STATIC BOOL AFXAPI _AfxTmFromOleDate(DATE dtSrc, struct tm& tmDest)
{
	// The legal range does not actually span year 0 to 9999.
	if (dtSrc > MAX_DATE || dtSrc < MIN_DATE) // about year 100 to about 9999
		return FALSE;

	long nDays;             // Number of days since Dec. 30, 1899
	long nDaysAbsolute;     // Number of days since 1/1/0
	long nSecsInDay;        // Time in seconds since midnight
	long nMinutesInDay;     // Minutes in day

	long n400Years;         // Number of 400 year increments since 1/1/0
	long n400Century;       // Century within 400 year block (0,1,2 or 3)
	long n4Years;           // Number of 4 year increments since 1/1/0
	long n4Day;             // Day within 4 year block
							//  (0 is 1/1/yr1, 1460 is 12/31/yr4)
	long n4Yr;              // Year within 4 year block (0,1,2 or 3)
	BOOL bLeap4 = TRUE;     // TRUE if 4 year block includes leap year

	double dblDate = dtSrc; // tempory serial date

	// If a valid date, then this conversion should not overflow
	nDays = (long)dblDate;

	// Round to the second
	dblDate += ((dtSrc > 0.0) ? HALF_SECOND : -HALF_SECOND);

	nDaysAbsolute = (long)dblDate + 693959L; // Add days from 1/1/0 to 12/30/1899

	dblDate = fabs(dblDate);
	nSecsInDay = (long)((dblDate - floor(dblDate)) * 86400.);

	// Calculate the day of week (sun=1, mon=2...)
	//   -1 because 1/1/0 is Sat.  +1 because we want 1-based
	tmDest.tm_wday = (int)((nDaysAbsolute - 1) % 7L) + 1;

	// Leap years every 4 yrs except centuries not multiples of 400.
	n400Years = (long)(nDaysAbsolute / 146097L);

	// Set nDaysAbsolute to day within 400-year block
	nDaysAbsolute %= 146097L;

	// -1 because first century has extra day
	n400Century = (long)((nDaysAbsolute - 1) / 36524L);

	// Non-leap century
	if (n400Century != 0)
	{
		// Set nDaysAbsolute to day within century
		nDaysAbsolute = (nDaysAbsolute - 1) % 36524L;

		// +1 because 1st 4 year increment has 1460 days
		n4Years = (long)((nDaysAbsolute + 1) / 1461L);

		if (n4Years != 0)
			n4Day = (long)((nDaysAbsolute + 1) % 1461L);
		else
		{
			bLeap4 = FALSE;
			n4Day = (long)nDaysAbsolute;
		}
	}
	else
	{
		// Leap century - not special case!
		n4Years = (long)(nDaysAbsolute / 1461L);
		n4Day = (long)(nDaysAbsolute % 1461L);
	}

	if (bLeap4)
	{
		// -1 because first year has 366 days
		n4Yr = (n4Day - 1) / 365;

		if (n4Yr != 0)
			n4Day = (n4Day - 1) % 365;
	}
	else
	{
		n4Yr = n4Day / 365;
		n4Day %= 365;
	}

	// n4Day is now 0-based day of year. Save 1-based day of year, year number
	tmDest.tm_yday = (int)n4Day + 1;
	tmDest.tm_year = n400Years * 400 + n400Century * 100 + n4Years * 4 + n4Yr;

	// Handle leap year: before, on, and after Feb. 29.
	if (n4Yr == 0 && bLeap4)
	{
		// Leap Year
		if (n4Day == 59)
		{
			/* Feb. 29 */
			tmDest.tm_mon = 2;
			tmDest.tm_mday = 29;
			goto DoTime;
		}

		// Pretend it's not a leap year for month/day comp.
		if (n4Day >= 60)
			--n4Day;
	}

	// Make n4DaY a 1-based day of non-leap year and compute
	//  month/day for everything but Feb. 29.
	++n4Day;

	// Month number always >= n/32, so save some loop time */
	for (tmDest.tm_mon = (n4Day >> 5) + 1;
		n4Day > _afxMonthDays[tmDest.tm_mon]; tmDest.tm_mon++);

	tmDest.tm_mday = (int)(n4Day - _afxMonthDays[tmDest.tm_mon-1]);

DoTime:
	if (nSecsInDay == 0)
		tmDest.tm_hour = tmDest.tm_min = tmDest.tm_sec = 0;
	else
	{
		tmDest.tm_sec = (int)nSecsInDay % 60L;
		nMinutesInDay = nSecsInDay / 60L;
		tmDest.tm_min = (int)nMinutesInDay % 60;
		tmDest.tm_hour = (int)nMinutesInDay / 60;
	}

	return TRUE;
}

AFX_STATIC void AFXAPI _AfxTmConvertToStandardFormat(struct tm& tmSrc)
{
	// Convert afx internal tm to format expected by runtimes (_tcsftime, etc)
	tmSrc.tm_year -= 1900;  // year is based on 1900
	tmSrc.tm_mon -= 1;      // month of year is 0-based
	tmSrc.tm_wday -= 1;     // day of week is 0-based
	tmSrc.tm_yday -= 1;     // day of year is 0-based
}

AFX_STATIC double AFXAPI _AfxDoubleFromDate(DATE dt)
{
	// No problem if positive
	if (dt >= 0)
		return dt;

	// If negative, must convert since negative dates not continuous
	// (examples: -1.25 to -.75, -1.50 to -.50, -1.75 to -.25)
	double temp = ceil(dt);
	return temp - (dt - temp);
}

AFX_STATIC DATE AFXAPI _AfxDateFromDouble(double dbl)
{
	// No problem if positive
	if (dbl >= 0)
		return dbl;

	// If negative, must convert since negative dates not continuous
	// (examples: -.75 to -1.25, -.50 to -1.50, -.25 to -1.75)
	double temp = floor(dbl); // dbl is now whole part
	return temp + (temp - dbl);
}

///////////////////////////////////////////////////////////////////////////////
//  END:  OLE DATE code copied from VC6\MFC\SRC\olevar.cpp
///////////////////////////////////////////////////////////////////////////////


//  returns the date and time in date serial format:  Date and time values
//  between the years 100 and 9999. Stored as a floating-point value. The
//  integer portion represents the number of days since December 30, 1899. The
//  fractional portion represents the number of seconds since midnight.

void UtilGetDateTime( DATESERIAL *pdt )
	{
	//  get the current date and time
	
	DATETIME dt;
	UtilGetCurrentDateTime( &dt );

	//  convert the date and time into a JET_DATESERIAL (a.k.a. OLE DATE)

	if ( !_AfxOleDateFromTm(	WORD( dt.year ),
								WORD( dt.month ),
								WORD( dt.day ),
								WORD( dt.hour ),
								WORD( dt.minute ),
								WORD( dt.second ),
								*pdt ) )
		{
		AssertSz( fFalse, "Invalid date:  Is it really 10000 A.D. already?" );
		}
	}


//  terminate time subsystem

void OSUTimeTerm()
	{
	//  nop
	}

//  init time subsystem

ERR ErrOSUTimeInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_osu\syncu.cxx ===
#include "osustd.hxx"


//  terminate sync subsystem

void OSUSyncTerm()
	{
	//  nop
	}

//  init sync subsystem

ERR ErrOSUSyncInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_osu\normu.cxx ===
#include "osustd.hxx"


#ifndef TO_UPPER_ONLY
#include "b71iseng.hxx"
#endif


ERR ErrUtilNormText(
	const char		*pbText,
	int				cbText,
	int				cbKeyBufLeft,
	char			*pbNorm,
	int				*pcbNorm )
	{
	ERR				err			= JET_errSuccess;

#ifdef TO_UPPER_ONLY

	Assert( cbText >= 0 );
	Assert( cbKeyBufLeft >= 0 );

	if ( cbKeyBufLeft > cbText )
		{
		memcpy( pbNorm, pbText, cbText );
		pbNorm[ cbText ] = 0;

		//To prevent normalizing text strings with embedded null-terminators
		Assert( cbText >= strlen( pbNorm ) );
		cbText = (int)strlen( pbNorm );

		_strupr( pbNorm );

		*pcbNorm	= cbText + 1;
		CallS( err );
		}
	else if ( cbKeyBufLeft > 0 )
		{
		int	cbTextToNormalise	= cbKeyBufLeft - 1;		//	make room for null-terminator

		memcpy( pbNorm, pbText, cbTextToNormalise );
		pbNorm[ cbTextToNormalise ] = 0;

		//To prevent normalizing text strings with embedded null-terminators
		Assert( cbTextToNormalise >= strlen( pbNorm ) );
		cbTextToNormalise = (int)strlen( pbNorm );

		_strupr( pbNorm );

		Assert( cbKeyBufLeft >= cbTextToNormalise + 1 );
		if ( cbKeyBufLeft == ( cbTextToNormalise + 1 )
			&& ( 0 != pbText[cbTextToNormalise] ) )
			{
			// no null-terminators are embedded inside the text string
			// and cbText >= cbKeyBufLeft
			pbNorm[ cbTextToNormalise ] = (CHAR)_toupper( pbText[ cbTextToNormalise ] );
			err	= ErrERRCheck( wrnFLDKeyTooBig );
			}
		else
			{
			//	embedded null-terminators caused us to halt normalisation
			//	before the end of the keyspace, so we still have
			//	keyspace left
			CallS( err );
			}

		*pcbNorm	= cbTextToNormalise + 1;
		}
	else
		{
		//	UNDONE: how come we don't return a warning when there
		//	is no keyspace left?
		*pcbNorm	= 0;
		CallS( err );
		}

#else

	char            *pbNormBegin = pbNorm;
	char            rgbAccent[ (KEY::cbKeyMax + 1) / 2 + 1 ];
	char            *pbAccent = rgbAccent;
	char            *pbBeyondKeyBufLeft = pbNorm + cbKeyBufLeft;
	const char      *pbBeyondText;
	const char      *pbTextLastChar = pbText + cbText - 1;
	char            bAccentTmp = 0;

	while ( *pbTextLastChar-- == ' ' )
		cbText--;

	/*	add one back to the pointer
	/**/
	pbTextLastChar++;

	Assert( pbTextLastChar == pbText + cbText - 1 );
	pbBeyondText = pbTextLastChar + 1;

	while ( pbText <  pbBeyondText && pbNorm < pbBeyondKeyBufLeft )
		{
		char	bTmp;

		/*	do a single to single char conversion
		/**/
		*pbNorm = bTmp = BGetTranslation(*pbText);

		if ( bTmp >= 250 )
			{
			/*	do a single to double char conversion
			/**/
			*pbNorm++ = BFirstByteForSingle(bTmp);
			if ( pbNorm < pbBeyondKeyBufLeft )
				*pbNorm = BSecondByteForSingle(bTmp);
			else
				break;

			/*	no need to do accent any more,
			/*	so break out of while loop
			/**/
			}

		pbNorm++;

		/*	at this point, pbText should point to the char for accent mapping
		/**/

		/*	do accent now
		/*	the side effect is to increment pbText
		/**/
		if ( bAccentTmp == 0 )
			{
			/*	first nibble of accent
			/**/
			bAccentTmp = (char)( BGetAccent( *pbText++ ) << 4 );
			Assert( bAccentTmp > 0 );
			}
		else
			{
			/*	already has first nibble
			/**/
			*pbAccent++ = BGetAccent(*pbText++) | bAccentTmp;
			bAccentTmp = 0;
			/*	reseting the accents
			/**/
			}
		}

	if ( pbNorm < pbBeyondKeyBufLeft )
		{
		/*	need to do accent
		/**/
		*pbNorm++ = 0;

		/*	key-accent separator
		/**/
		if ( bAccentTmp != 0 && bAccentTmp != 0x10 )
			{
			/*	an trailing accent which is not 0x10 should be kept
			/**/
			*pbAccent++ = bAccentTmp;
			}

		/*	at this point, pbAccent is pointing at one char
		/*	beyond the accent bytes.  clear up trailing 0x11's
		/**/
		while (--pbAccent >= rgbAccent && *pbAccent == 0x11)
			;
		*( pbAccent + 1 ) = 0;

		/*	append accent to text.
		/*	copy bytes up to and including '\0'.
		/*	case checked for rgbAccent being empty.
		/**/
		pbAccent = rgbAccent;
		Assert( pbNorm <= pbBeyondKeyBufLeft );
		while ( pbNorm < pbBeyondKeyBufLeft  &&  (*pbNorm++  =  *pbAccent++ ) )
			;
		}

	/*	compute the length of the normalized key and return
	/**/
	*pcbNorm = pbNorm - pbNormBegin;

	err = ( pbNorm < pbBeyondKeyBufLeft ? JET_errSuccess : ErrERRCheck( wrnFLDKeyTooBig ) );
	
#endif	// TO_UPPER_ONLY

	CallSx( err, wrnFLDKeyTooBig );
	return err;
	}


//  terminate norm subsystem

void OSUNormTerm()
	{
	//  nop
	}

//  init norm subsystem

ERR ErrOSUNormInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\dllentry.cxx ===
#include "osstd.hxx"


#define _DECL_DLLMAIN
#include <process.h>


//  OS Layer Init / Term functions

extern BOOL FOSPreinit();
extern void OSPostterm();


//  external parameters

extern volatile BOOL fProcessAbort;


//  DLL Entry Point

extern BOOL FINSTSomeInitialized();
extern BOOL FreeAllInitFaildInstances();

volatile DWORD tidDLLEntryPoint;

extern "C"
	{	
	BOOL WINAPI DLLEntryPoint( void* hinstDLL, DWORD fdwReason, LPVOID lpvReserved )
		{
		tidDLLEntryPoint = GetCurrentThreadId();
		
		BOOL fResult = fTrue;

		switch( fdwReason )
			{
			case DLL_THREAD_ATTACH:
				fResult = fResult && _CRT_INIT( hinstDLL, fdwReason, lpvReserved );
				break;

			case DLL_THREAD_DETACH:
				(void)_CRT_INIT( hinstDLL, fdwReason, lpvReserved );
				OSThreadDetach();
				OSSyncDetach();
				break;

			case DLL_PROCESS_ATTACH:

				//  init OS Layer

				fResult = fResult && FOSPreinit();

				//  init CRT

				fResult = fResult && _CRT_INIT( hinstDLL, fdwReason, lpvReserved );
				break;

			case DLL_PROCESS_DETACH:
				
				//  if JET is still initialized, we are experiencing an abnormal
				//  termination
				fProcessAbort = fProcessAbort || FINSTSomeInitialized();

				//  terminate CRT
				
				(void)_CRT_INIT( hinstDLL, fdwReason, lpvReserved );

				//  terminate OS Layer

				OSPostterm();
				break;
			}

		tidDLLEntryPoint = 0;
			
		return fResult;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\cprintf.cxx ===
#include "osstd.hxx"


CPRINTFNULL cprintfNull;

CPRINTFSTDOUT cprintfStdout;

#ifdef DEBUG

CPRINTFDEBUG cprintfDEBUG;

#endif  //  DEBUG


//  ================================================================
CPRINTF* CPRINTFDBGOUT::PcprintfInstance()
//  ================================================================
	{
	static CPRINTFDBGOUT cprintfDbgout;
	return &cprintfDbgout;
	}

//  ================================================================
void __cdecl CPRINTFDBGOUT::operator()( const _TCHAR* szFormat, ... ) const
//  ================================================================
	{
	CHAR szBuf[1024];
	va_list arg_ptr;
	va_start( arg_ptr, szFormat );
	_vstprintf( szBuf, szFormat, arg_ptr );
	va_end( arg_ptr );
	OutputDebugString( szBuf );
	}


CPRINTFFILE::CPRINTFFILE( const _TCHAR* szFile )
	{
	//  open the file for append

	if ( ( m_hFile = (void*)CreateFile( szFile, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ) ) == INVALID_HANDLE_VALUE )
		{
		return;
		}
	SetHandleInformation( HANDLE( m_hFile ), HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	if ( !( m_hMutex = (void*)CreateMutex( NULL, FALSE, NULL ) ) )
		{
		SetHandleInformation( HANDLE( m_hFile ), HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( HANDLE( m_hFile ) );
		m_hFile = INVALID_HANDLE_VALUE;
		return;
		}
	SetHandleInformation( HANDLE( m_hMutex ), HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	}

CPRINTFFILE::~CPRINTFFILE()
	{
	//  close the file

	if ( m_hMutex )
		{
		SetHandleInformation( HANDLE( m_hMutex ), HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( HANDLE( m_hMutex ) );
		m_hMutex = NULL;
		}

	if ( m_hFile != INVALID_HANDLE_VALUE )
		{
		SetHandleInformation( HANDLE( m_hFile ), HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( HANDLE( m_hFile ) );
		m_hFile = INVALID_HANDLE_VALUE;
		}
	}

//  ================================================================
void __cdecl CPRINTFFILE::operator()( const _TCHAR* szFormat, ... ) const
//  ================================================================
	{
	if ( HANDLE( m_hFile ) != INVALID_HANDLE_VALUE )
		{
		const SIZE_T cchBuf = 1024;
		_TCHAR szBuf[ cchBuf ];

		//  print into a temp buffer, truncating the string if too large
		
		va_list arg_ptr;
		va_start( arg_ptr, szFormat );
		_vsntprintf( szBuf, cchBuf - 1, szFormat, arg_ptr );
		szBuf[ cchBuf - 1 ] = 0;
		va_end( arg_ptr );
		
		//  append the string to the file

		WaitForSingleObject( HANDLE( m_hMutex ), INFINITE );

		SetFilePointer( HANDLE( m_hFile ), 0, NULL, FILE_END );

		DWORD cbWritten;
		WriteFile( HANDLE( m_hFile ), szBuf, (ULONG)(_tcslen( szBuf ) * sizeof( _TCHAR )), &cbWritten, NULL );

		ReleaseMutex( HANDLE( m_hMutex ) );
		}
	}
	

//  ================================================================
CPRINTFTLSPREFIX::CPRINTFTLSPREFIX( CPRINTF* pcprintf, const _TCHAR* const szPrefix ) :
//  ================================================================
	m_cindent( 0 ),
	m_pcprintf( pcprintf ),
	m_szPrefix( szPrefix )
	{
	}

	
//  ================================================================
void __cdecl CPRINTFTLSPREFIX::operator()( const _TCHAR* szFormat, ... ) const
//  ================================================================
	{		
	_TCHAR rgchBuf[1024];
	_TCHAR *pchBuf = rgchBuf;

	if( Ptls()->szCprintfPrefix )
		{
		pchBuf += _stprintf( pchBuf, "%s:\t%d:\t", Ptls()->szCprintfPrefix, DwUtilThreadId() );
		}
	if( m_szPrefix )
		{
		pchBuf += _stprintf( pchBuf, _T( "%s" ), m_szPrefix );
		}

	va_list arg_ptr;
	va_start( arg_ptr, szFormat );
	_vstprintf( pchBuf, szFormat, arg_ptr );
	va_end( arg_ptr );

	(*m_pcprintf)( _T( "%s" ), rgchBuf );
	}


//  ================================================================
INLINE void CPRINTFTLSPREFIX::Indent()
//  ================================================================
	{
	}


//  ================================================================
INLINE void CPRINTFTLSPREFIX::Unindent()
//  ================================================================
	{
	}



//  retrieves the current width of stdout

DWORD UtilCprintfStdoutWidth()
	{
	//  open stdout
	
	HANDLE hConsole = GetStdHandle( STD_OUTPUT_HANDLE );
	Assert( INVALID_HANDLE_VALUE != hConsole );

	//  get attributes of console receiving stdout

	CONSOLE_SCREEN_BUFFER_INFO csbi;
	const BOOL fSuccess = GetConsoleScreenBufferInfo( hConsole, &csbi );

	//  return width of console window or the standard 80 if unknown
	
	return fSuccess ? csbi.dwMaximumWindowSize.X : 80;
	}

	
//  post-terminate cprintf subsystem

void OSCprintfPostterm()
	{
	//  nop
	}

//  pre-init cprintf subsystem

BOOL FOSCprintfPreinit()
	{
	//  nop

	return fTrue;
	}


//  terminate cprintf subsystem

void OSCprintfTerm()
	{
	//  nop
	}

//  init cprintf subsystem

ERR ErrOSCprintfInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\config.cxx ===
#include "osstd.hxx"


//  Persistent Configuration Management
//
//  Configuration information is organized in a way very similar to a file
//  system.  Each configuration datum is a name and value pair stored in a
//  path.  All paths, names, ans values are text strings.
//
//  For Win32, we will store this information in the registry under the
//  following two paths:
//
//    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\<Image Name>\Global\
//    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\<Image Name>\Process\<Process Name>\
//
//  Global settings are overridden by Process settings.

LOCAL _TCHAR szConfigGlobal[_MAX_PATH];
LOCAL _TCHAR szConfigProcess[_MAX_PATH];

//  sets the specified name in the specified path to the given value, returning
//  fTrue on success.  any intermediate path that does not exist will be created
//
//  NOTE:  either '/' or '\\' is a valid path separator

const BOOL FOSConfigISet( _TCHAR* const szPath, const _TCHAR* const szName, const _TCHAR* const szValue )
	{
	//  create / open each path segment, returning fFalse on any failures

	const _TCHAR szDelim[] = _T( "/\\" );
	_TCHAR* szPathSeg = _tcstok( szPath, szDelim );
	HKEY hkeyPathSeg = HKEY_LOCAL_MACHINE;
	
	while ( szPathSeg != NULL )
		{
		HKEY hkeyPathSegOld = hkeyPathSeg;
		DWORD dwDisposition;
		DWORD dw = RegCreateKeyEx(	hkeyPathSegOld,
									szPathSeg,
									0,
									NULL,
									REG_OPTION_NON_VOLATILE,
									KEY_WRITE,
									NULL,
									&hkeyPathSeg,
									&dwDisposition );

		if ( hkeyPathSegOld != HKEY_LOCAL_MACHINE )
			{
			DWORD dwClosedKey = RegCloseKey( hkeyPathSegOld );
			Assert( dwClosedKey == ERROR_SUCCESS );
			}
		
		if ( dw != ERROR_SUCCESS )
			{
			return fFalse;
			}

		szPathSeg = _tcstok( NULL, szDelim );
		}

	//  delete existing name so that in case it has the wrong type, there will
	//  be no problems setting it

	(void)RegDeleteValue(	hkeyPathSeg,
							szName );

	//  set name to value

	DWORD dw = RegSetValueEx(	hkeyPathSeg,
								szName,
								0,
								REG_SZ,
								(LPBYTE)szValue,
								(ULONG)_tcslen( szValue ) + 1 );

	//  close path
	
	DWORD dwClosedKey = RegCloseKey( hkeyPathSeg );
	Assert( dwClosedKey == ERROR_SUCCESS );

	//  return result of setting the name to the value as our success

	return dw == ERROR_SUCCESS;
	}

const BOOL FOSConfigSet( const _TCHAR* const szPath, const _TCHAR* const szName, const _TCHAR* const szValue )
	{
	//  validate IN args

	Assert( szPath != NULL );
	Assert( _tcslen( szPath ) > 0 );
	Assert( _tcslen( szConfigProcess ) + _tcslen( szPath ) < _MAX_PATH );
	Assert( szPath[0] != _T( '/' ) );
	Assert( szPath[0] != _T( '\\' ) );
	Assert( szPath[_tcslen( szPath ) - 1] != _T( '/' ) );
	Assert( szPath[_tcslen( szPath ) - 1] != _T( '\\' ) );
	Assert( szName != NULL );
	Assert( _tcslen( szName ) > 0 );
	Assert( szValue != NULL );

	//  convert any '/' in the relative path into '\\'

	_TCHAR szRelPath[_MAX_PATH];
	for ( int itch = 0; szPath[itch]; itch++ )
		{
		if ( szPath[itch] == _T( '/' ) )
			{
			szRelPath[itch] = _T( '\\' );
			}
		else
			{
			szRelPath[itch] = szPath[itch];
			}
		}
	szRelPath[itch] = 0;

	//  build the absolute path to our process configuration

	_TCHAR szAbsPath[_MAX_PATH];
	_tcscpy( szAbsPath, szConfigProcess );
	_tcscat( szAbsPath, szRelPath );

	//  set our process configuration

	return FOSConfigISet( szAbsPath, szName, szValue );
	}

//  gets the value of the specified name in the specified path and places it in
//  the provided buffer, returning fFalse if the buffer is too small.  if the
//  value is not set, an empty string will be returned
//
//  NOTE:  either '/' or '\\' is a valid path separator

const BOOL FOSConfigIGet( _TCHAR* const szPath, const _TCHAR* const szName, _TCHAR* const szBuf, const long cbBuf )
	{
	//  open registry key with this path

	HKEY hkeyPath;
	DWORD dw = RegOpenKeyEx(	HKEY_LOCAL_MACHINE,
								szPath,
								0,
								KEY_READ,
								&hkeyPath );

	//  we failed to open the key
	
	if ( dw != ERROR_SUCCESS )
		{
		//  create the key / value with a NULL value, ignoring any errors

		(void)FOSConfigISet( szPath, szName, _T( "" ) );

		//  return an empty string if space permits

		if ( cbBuf >= sizeof( szBuf[0] ) )
			{
			szBuf[0] = 0;
			return fTrue;
			}
		else
			{
			return fFalse;
			}
		}

	//  retrieve the value into the user buffer

	DWORD dwType;
	DWORD cbValue = cbBuf;
	dw = RegQueryValueEx(	hkeyPath,
							szName,
							0,
							&dwType,
							(LPBYTE)szBuf,
							&cbValue );
							
	//  there was some error reading the value
	
	if ( dw != ERROR_SUCCESS || dwType != REG_SZ )
		{
		//  close the key
		
		DWORD dwClosedKey = RegCloseKey( hkeyPath );
		Assert( dwClosedKey == ERROR_SUCCESS );
		
		//  create the key / value with a NULL value, ignoring any errors

		(void)FOSConfigISet( szPath, szName, _T( "" ) );

		//  return an empty string if space permits

		if ( cbBuf >= sizeof( szBuf[0] ) )
			{
			szBuf[0] = 0;
			return fTrue;
			}
		else
			{
			return fFalse;
			}
		}

	//  if the value is bigger than the buffer, return fFalse

	if ( cbValue > cbBuf )
		{
		DWORD dwClosedKey = RegCloseKey( hkeyPath );
		Assert( dwClosedKey == ERROR_SUCCESS );
		return fFalse;
		}

	//  we succeeded in reading the value, so close the key and return

	DWORD dwClosedKey = RegCloseKey( hkeyPath );
	Assert( dwClosedKey == ERROR_SUCCESS );
	return fTrue;
	}

const BOOL FOSConfigGet( const _TCHAR* const szPath, const _TCHAR* const szName, _TCHAR* const szBuf, const long cbBuf )
	{
	//  validate IN args

	Assert( szPath != NULL );
	Assert( _tcslen( szPath ) > 0 );
	Assert( _tcslen( szConfigGlobal ) + _tcslen( szPath ) < _MAX_PATH );
	Assert( _tcslen( szConfigProcess ) + _tcslen( szPath ) < _MAX_PATH );
	Assert( szPath[0] != _T( '/' ) );
	Assert( szPath[0] != _T( '\\' ) );
	Assert( szPath[_tcslen( szPath ) - 1] != _T( '/' ) );
	Assert( szPath[_tcslen( szPath ) - 1] != _T( '\\' ) );
	Assert( szName != NULL );
	Assert( _tcslen( szName ) > 0 );
	Assert( szBuf != NULL );

	//  convert any '/' in the relative path into '\\'

	_TCHAR szRelPath[_MAX_PATH];
	for ( int itch = 0; szPath[itch]; itch++ )
		{
		if ( szPath[itch] == _T( '/' ) )
			{
			szRelPath[itch] = _T( '\\' );
			}
		else
			{
			szRelPath[itch] = szPath[itch];
			}
		}
	szRelPath[itch] = 0;

	//  build the absolute path to our process configuration

	_TCHAR szAbsPath[_MAX_PATH];
	_tcscpy( szAbsPath, szConfigProcess );
	_tcscat( szAbsPath, szRelPath );

	//  get our process configuration, failing on insufficient buffer

	if ( !FOSConfigIGet( szAbsPath, szName, szBuf, cbBuf ) )
		{
		return fFalse;
		}

	//  if we have process specific configuration, we're done

	if ( szBuf[0] )
		{
		return fTrue;
		}

	//  build the absolute path to our global configuration

	_tcscpy( szAbsPath, szConfigGlobal );
	_tcscat( szAbsPath, szRelPath );

	//  return our global configuration, whatever it is

	return FOSConfigIGet( szAbsPath, szName, szBuf, cbBuf );
	}


//  post-terminates the configuration subsystem

void OSConfigPostterm()
	{
	//  nop
	}

//  pre-initializes the configuration subsystem

BOOL FOSConfigPreinit()
	{
	//  build configuration paths

	szConfigGlobal[0] = 0;
	_tcscat( szConfigGlobal, _T( "SOFTWARE\\Microsoft\\" ) );
	_tcscat( szConfigGlobal, SzUtilImageVersionName() );
	_tcscat( szConfigGlobal, _T( "\\Global\\" ) );

	szConfigProcess[0] = 0;
	_tcscat( szConfigProcess, _T( "SOFTWARE\\Microsoft\\" ) );
	_tcscat( szConfigProcess, SzUtilImageVersionName() );
	_tcscat( szConfigProcess, _T( "\\Process\\" ) );
	_tcscat( szConfigProcess, SzUtilProcessName() );
	_tcscat( szConfigProcess, _T( "\\" ) );

	return fTrue;
	}


//  terminate config subsystem

void OSConfigTerm()
	{
	//  nop
	}

//  init config subsystem

ERR ErrOSConfigInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\memory.cxx ===
#include "osstd.hxx"

#include "mpheap.hxx"			//	MP Heap

#include <math.h>
#include <malloc.h>


#if !defined(_M_IA64) || defined(DEBUG)
#define ENABLE_VIRTUAL_QUERY
#endif // _M_IA64

#ifdef MEM_CHECK

void OSMemoryIDumpAlloc( const _TCHAR* szDumpFile, const BOOL memDump = fTrue );

int g_fMemCheck = 0;

#endif	//	MEM_CHECK


//  System Memory Attributes

//  returns the system page reserve granularity

LOCAL DWORD dwPageReserveGran;

DWORD OSMemoryPageReserveGranularity()
	{
	return dwPageReserveGran;
	}

//  returns the system page commit granularity

LOCAL DWORD dwPageCommitGran;

DWORD OSMemoryPageCommitGranularity()
	{
	return dwPageCommitGran;
	}

//  returns the current available physical memory in the system

HKEY hkeyWin9xStats;

DWORD_PTR OSMemoryAvailable()
	{
	//  we are running on NT
	
	if ( !hkeyWin9xStats )
		{
		//  return the amount of available physical memory as reported by NT
		
		MEMORYSTATUS ms = { sizeof( MEMORYSTATUS ) };
		GlobalMemoryStatus( &ms );
		return ms.dwAvailPhys;
		}

	//  we are running on Windows
	
	else
		{
		//  get the amount of available physical memory as reported by Windows.
		//  this amount does not include any RAM used by the disk cache
		
		MEMORYSTATUS ms = { sizeof( MEMORYSTATUS ) };
		GlobalMemoryStatus( &ms );

		//  get the current and minimum size of the disk cache.  the difference
		//  is the amount of memory that Windows could give up

		DWORD	cbData;
		DWORD	cbDiskcache;
		DWORD	cbDiskcacheMin;

		cbDiskcache		= 0;
		cbData			= sizeof( cbDiskcache );
		(void)RegQueryValueEx(	hkeyWin9xStats,
								"VMM\\cpgDiskcache",
								NULL,
								NULL,
								(BYTE*)&cbDiskcache,
								&cbData );

		cbDiskcacheMin	= 0;
		cbData			= sizeof( cbDiskcacheMin );
		(void)RegQueryValueEx(	hkeyWin9xStats,
								"VMM\\cpgDiskcacheMin",
								NULL,
								NULL,
								(BYTE*)&cbDiskcacheMin,
								&cbData );

		//  return the amount of available physical memory including what the
		//  Windows disk cache could release

		return ms.dwAvailPhys + cbDiskcache - cbDiskcacheMin;
		}
	}

//  returns the total physical memory in the system

LOCAL DWORD_PTR cbMemoryTotal;

DWORD_PTR OSMemoryTotal()
	{
	return cbMemoryTotal;
	}

//  returns the current available virtual address space in the process

DWORD_PTR OSMemoryPageReserveAvailable()
	{
	MEMORYSTATUS ms = { sizeof( MEMORYSTATUS ) };
	GlobalMemoryStatus( &ms );
	return ms.dwAvailVirtual;
	}

//  returns the total virtual address space in the process

LOCAL DWORD_PTR cbPageReserveTotal;

DWORD_PTR OSMemoryPageReserveTotal()
	{
	return cbPageReserveTotal;
	}

//  returns the total number of physical memory pages evicted from the system

typedef
NTSYSCALLAPI
NTSTATUS
NTAPI
PFNNtQuerySystemInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

BOOL							fEvictStatsInit;
PFNNtQuerySystemInformation*	pfnNtQuerySystemInformation;

enum	{ cRollingAvgDepth = 3 };
size_t	cAvailPage[ cRollingAvgDepth ];
int		icAvailPageOldest;
double	cAvailPageSum;
double	cAvailPageAvg;
long	cPageAllocLast;
DWORD	cPageEvict;

DWORD OSMemoryPageEvictionCount()
	{
	//  we are running on Windows

	if ( hkeyWin9xStats )
		{
		//  read the page eviction rate straight from Windows
		
		DWORD	cbData;
		DWORD	cDiscards;
		
		cDiscards		= 0;
		cbData			= sizeof( cDiscards );
		(void)RegQueryValueEx(	hkeyWin9xStats,
								"VMM\\cDiscards",
								NULL,
								NULL,
								(BYTE*)&cDiscards,
								&cbData );

		cPageEvict = cDiscards;
		}

	//  we are running on NT

	else
		{
		//  NT isn't courteous enough to expose its page eviction rate so we must
		//  go through a lot of machinations to estimate it.  we do this by
		//  ASSUMING that as memory gets short, all page faults indirectly cause
		//  a page eviction to satisfy them.  note that this number is less
		//  accurate when someone on the system is churning quickly through a
		//  small pool of memory but not actually applying memory pressure
		//
		//  NOTE:  this function must be called often to be accurate

		const size_t cAvailPageMin = 1024;  //  NT's page eviction threshold
			
		if ( !fEvictStatsInit )
			{
			size_t cAvailPageInit = OSMemoryAvailable() / OSMemoryPageCommitGranularity();
			for ( icAvailPageOldest = cRollingAvgDepth - 1; icAvailPageOldest >= 0; icAvailPageOldest-- )
				{
				cAvailPage[ icAvailPageOldest ] = cAvailPageInit;
				}
			icAvailPageOldest = 0;
			cAvailPageSum = cRollingAvgDepth * (double)cAvailPageInit;
			cAvailPageAvg = (double)cAvailPageInit;

	    	SYSTEM_PERFORMANCE_INFORMATION sysperfinfo;
			pfnNtQuerySystemInformation(	SystemPerformanceInformation,
											&sysperfinfo,
											sizeof( sysperfinfo ),
											NULL );
			cPageAllocLast	= sysperfinfo.PageFaultCount;
			
			cPageEvict		= 0;
			
			fEvictStatsInit	= fTrue;
			}
		else
			{
			cAvailPageSum -= cAvailPage[ icAvailPageOldest ];
			cAvailPage[ icAvailPageOldest ] = OSMemoryAvailable() / OSMemoryPageCommitGranularity();
			cAvailPageSum += cAvailPage[ icAvailPageOldest ];
			icAvailPageOldest = ( icAvailPageOldest + 1 ) % cRollingAvgDepth;
			cAvailPageAvg = (double)cAvailPageSum / (double)cRollingAvgDepth;

	    	SYSTEM_PERFORMANCE_INFORMATION sysperfinfo;
			pfnNtQuerySystemInformation(	SystemPerformanceInformation,
											&sysperfinfo,
											sizeof( sysperfinfo ),
											NULL );
			long	cPageAlloc		= sysperfinfo.PageFaultCount;
			long	dcPageAlloc		= cPageAlloc - cPageAllocLast;

			double	k;
			if ( cAvailPageAvg > 1.125 * cAvailPageMin )
				{
				k = 0;
				}
			else if ( cAvailPageAvg > 1.0 * cAvailPageMin )
				{
				k = 1 - ( cAvailPageAvg - 1.0 * cAvailPageMin ) / ( ( 1.125 - 1.0 ) * cAvailPageMin );
				}
			else
				{
				k = 1;
				}

			double	dcPageEvict;
			modf( k * dcPageAlloc + 0.5, &dcPageEvict );

			cPageAllocLast	= cPageAlloc;
			cPageEvict		= cPageEvict + long( dcPageEvict );
			}
		}

	//  return the current page eviction count

	return cPageEvict;
	}


//  Memory statistics

DWORD cAllocHeap;

long LOSHeapAllocPerSecCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = cAllocHeap;
		
	return 0;
	}

DWORD cFreeHeap;

long LOSHeapFreePerSecCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = cFreeHeap;
		
	return 0;
	}

long LOSHeapAllocCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = cAllocHeap - cFreeHeap;
		
	return 0;
	}

DWORD cbAllocHeap;

long LOSHeapBytesAllocCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = cbAllocHeap;
		
	return 0;
	}

DWORD_PTR cbReservePage;

long LOSPageBytesReservedCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = (unsigned long)cbReservePage;
		
	return 0;
	}

DWORD_PTR cbCommitPage;

long LOSPageBytesCommittedCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		*( (unsigned long*) pvBuf ) = (unsigned long)cbCommitPage;

	return 0;
	}


//  Memory Subsystem Init / Term

//    global MP heap

//NOTE:	Cannot initialise this variable because the code that allocates
//		TLS and uses this variable to store the index executes before
//		CRTInit, which would subsequently re-initialise the variable
//		with the value specified here
//DWORD tlsiHeapHint	= dwTlsInvalid;
DWORD	tlsiHeapHint;
BOOL	fTlsHeapHintAllocated;
HANDLE	hMPHeapGlobal;

#ifdef MEM_CHECK

//	MAI hash table

DWORD_PTR cmai;
struct MAI;
MAI** rgpmai;

DWORD ccsmai;
CRITICAL_SECTION* rgcsmai;

COSMemoryMap		*g_posmm;	//	list of COSMemoryMap objects
CRITICAL_SECTION	g_csosmm;	//	protection for COSMemoryMap list

#endif  //  MEM_CHECK

//  multi-map capability

BOOL fCanMultiMap;


//  post-terminates the memory subsystem

void OSMemoryPostterm()
	{
	//  terminate Win9x stats

	if ( hkeyWin9xStats )
		{
		HKEY hkeyWin9xStatsStop;
		if ( RegOpenKeyEx(	HKEY_DYN_DATA,
							"PerfStats\\StopStat",
							0,
							KEY_READ,
							&hkeyWin9xStatsStop ) == ERROR_SUCCESS )
			{
			DWORD	cbData;
			DWORD	cbDiskcache;
			DWORD	cbDiskcacheMin;
			DWORD	cDiscards;

			cbDiskcache		= 0;
			cbData			= sizeof( cbDiskcache );
			(void)RegQueryValueEx(	hkeyWin9xStatsStop,
									"VMM\\cpgDiskcache",
									NULL,
									NULL,
									(BYTE*)&cbDiskcache,
									&cbData );

			cbDiskcacheMin	= 0;
			cbData			= sizeof( cbDiskcacheMin );
			(void)RegQueryValueEx(	hkeyWin9xStatsStop,
									"VMM\\cpgDiskcacheMin",
									NULL,
									NULL,
									(BYTE*)&cbDiskcacheMin,
									&cbData );

			cDiscards		= 0;
			cbData			= sizeof( cDiscards );
			(void)RegQueryValueEx(	hkeyWin9xStatsStop,
									"VMM\\cDiscards",
									NULL,
									NULL,
									(BYTE*)&cDiscards,
									&cbData );

			RegCloseKey( hkeyWin9xStatsStop );
			hkeyWin9xStatsStop = NULL;
			}

		RegCloseKey( hkeyWin9xStats );
		hkeyWin9xStats = NULL;
		}
	
	//  verify that there are no memory leaks

#ifdef MEM_CHECK
	if ( !FUtilProcessAbort() && g_posmm )
		{
		if ( g_fMemCheck )
			{
			COSMemoryMap::OSMMDumpAlloc( _T( "Assert.TXT" ) );
			}

		AssertSzRTL( fFalse, "Memory-Map Leak Detected" );
		}
#endif	//	MEM_CHECK

	if ( !FUtilProcessAbort() && cbAllocHeap + cbReservePage > 0 )	//	+ cbCommitPage > 0 )
		{
#ifdef MEM_CHECK
		if ( g_fMemCheck )
			{
			OSMemoryIDumpAlloc( _T( "Assert.TXT" ) );
			}

#endif  //  MEM_CHECK

		AssertSzRTL( fFalse, "Memory Leak Detected" );
		}

#ifdef MEM_CHECK

	//	free COSMemoryMap critical section

	DeleteCriticalSection( &g_csosmm );

	//  free MAI hash table critical section pool

	if ( rgcsmai )
		{
		int icsmai;
		for ( icsmai = 0; icsmai < ccsmai; icsmai++ )
			{
			DeleteCriticalSection( rgcsmai + icsmai );
			}
		BOOL fFreedCSPool = !LocalFree( rgcsmai );
		Assert( fFreedCSPool );
		rgcsmai = NULL;
		}

	//  free MAI hash table

	if ( rgpmai )
		{
		BOOL fMAIHashFreed = VirtualFree( rgpmai, 0, MEM_RELEASE );
		Assert( fMAIHashFreed );
		rgpmai = NULL;
		}

#endif  //  MEM_CHECK
		
	//  terminate global MP heap

	if ( hMPHeapGlobal )
		{
		BOOL fHeapDestroyed = MpHeapDestroy( hMPHeapGlobal );
		Assert( fHeapDestroyed );
		hMPHeapGlobal = NULL;
		}

	if ( fTlsHeapHintAllocated )
		{
		Assert( dwTlsInvalid != tlsiHeapHint );
		
		const BOOL	fTLSFreed = TlsFree( tlsiHeapHint );
		Assert( fTLSFreed );		//	leak the TLS entry if we fail

		tlsiHeapHint = dwTlsInvalid;
		fTlsHeapHintAllocated = fFalse;
		}
	}


//  pre-initialize the memory subsystem

BOOL FOSMemoryPreinit()
	{
	//  initialize all pointers
	fTlsHeapHintAllocated = fFalse;
	tlsiHeapHint	= dwTlsInvalid;
	hMPHeapGlobal	= NULL;
	
#ifdef MEM_CHECK

	cmai			= 0;
	rgpmai			= NULL;
	ccsmai			= 0;
	rgcsmai			= NULL;

	g_posmm = NULL;
	InitializeCriticalSection( &g_csosmm );

#endif  //  MEM_CHECK

	hkeyWin9xStats	= NULL;

	//  initialize all counters
	
	fEvictStatsInit	= fFalse;
	cAllocHeap		= 0;
	cFreeHeap		= 0;
	cbAllocHeap		= 0;
	cbReservePage	= 0;
	cbCommitPage	= 0;

	//  initialize global MP heap

	tlsiHeapHint = TlsAlloc();
	if ( dwTlsInvalid == tlsiHeapHint )
		{
		goto HandleError;
		}
	fTlsHeapHintAllocated = fTrue;

	hMPHeapGlobal = MpHeapCreate( 0, 0, 4 * CUtilProcessProcessor() );
	if ( !hMPHeapGlobal )
		{
		goto HandleError;
		}

#ifdef MEM_CHECK

	char sz[10];
	
	if ( FOSConfigGet( "DEBUG", "Mem Check", sz, 9 ) )
		{
		g_fMemCheck = !!atoi( sz );
		}

	//  allocate MAI hash table

	MEMORYSTATUS ms;
	ms.dwLength = sizeof( MEMORYSTATUS );
	GlobalMemoryStatus( &ms );
	for ( cmai = 0; ms.dwTotalPhys; ms.dwTotalPhys /= 2, cmai++ );
	cmai = ( 1 << max( 10, cmai - 12 ) ) - 1;

	rgpmai = (MAI**) VirtualAlloc( NULL, cmai * sizeof( MAI* ), MEM_COMMIT, PAGE_READWRITE );
	if ( !rgpmai )
		{
		goto HandleError;
		}

	//  initialize MAI hash table critical section pool

	ccsmai = 8 * CUtilProcessProcessor();
	rgcsmai = (CRITICAL_SECTION*) LocalAlloc( 0, ccsmai * sizeof( CRITICAL_SECTION ) );
	if ( !rgcsmai )
		{
		goto HandleError;
		}
	int icsmai;
	for ( icsmai = 0; icsmai < ccsmai; icsmai++ )
		{
		InitializeCriticalSection( rgcsmai + icsmai );
		}

#endif  //  MEM_CHECK

	//  get page commit and reserve granularity

	SYSTEM_INFO sinf;
	GetSystemInfo( &sinf );
	dwPageReserveGran = sinf.dwAllocationGranularity;
	dwPageCommitGran = sinf.dwPageSize;

	//  get total physical memory

	MEMORYSTATUS ms2;
	ms2.dwLength = sizeof( MEMORYSTATUS );
	GlobalMemoryStatus( &ms2 );
	cbMemoryTotal		= ms2.dwTotalPhys;
	cbPageReserveTotal	= ms2.dwTotalVirtual;

	//  initialize Win9x / WinNT stats

	OSVERSIONINFO osvi;
	memset( &osvi, 0, sizeof( osvi ) );
	osvi.dwOSVersionInfoSize = sizeof( osvi );
	if ( !GetVersionEx( &osvi ) )
		{
		goto HandleError;
		}

	if (	osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS &&
			RegOpenKeyEx(	HKEY_DYN_DATA,
							"PerfStats\\StatData",
							0,
							KEY_READ,
							&hkeyWin9xStats ) == ERROR_SUCCESS )
		{
		HKEY hkeyWin9xStatsStart;
		if ( RegOpenKeyEx(	HKEY_DYN_DATA,
							"PerfStats\\StartStat",
							0,
							KEY_READ,
							&hkeyWin9xStatsStart ) == ERROR_SUCCESS )
			{
			DWORD	cbData;
			DWORD	cbDiskcache;
			DWORD	cbDiskcacheMin;
			DWORD	cDiscards;

			cbDiskcache		= 0;
			cbData			= sizeof( cbDiskcache );
			(void)RegQueryValueEx(	hkeyWin9xStatsStart,
									"VMM\\cpgDiskcache",
									NULL,
									NULL,
									(BYTE*)&cbDiskcache,
									&cbData );

			cbDiskcacheMin	= 0;
			cbData			= sizeof( cbDiskcacheMin );
			(void)RegQueryValueEx(	hkeyWin9xStatsStart,
									"VMM\\cpgDiskcacheMin",
									NULL,
									NULL,
									(BYTE*)&cbDiskcacheMin,
									&cbData );

			cDiscards		= 0;
			cbData			= sizeof( cDiscards );
			(void)RegQueryValueEx(	hkeyWin9xStatsStart,
									"VMM\\cDiscards",
									NULL,
									NULL,
									(BYTE*)&cDiscards,
									&cbData );

			RegCloseKey( hkeyWin9xStatsStart );
			hkeyWin9xStatsStart = NULL;
			}
		else
			{
			RegCloseKey( hkeyWin9xStats );
			hkeyWin9xStats = NULL;
			}
		}

	else
		{
		if ( !( pfnNtQuerySystemInformation = (PFNNtQuerySystemInformation*)GetProcAddress(	GetModuleHandle( _T( "ntdll.dll" ) ),
																							_T( "NtQuerySystemInformation" ) ) ) )
			{
			goto HandleError;
			}				
		}

	//  determine multi-map capability

	fCanMultiMap = osvi.dwPlatformId == VER_PLATFORM_WIN32_NT;
	
	return fTrue;

HandleError:
	OSMemoryPostterm();
	return fFalse;
	}


//  terminate memory subsystem

void OSMemoryTerm()
	{
	//  nop
	}


//  init memory subsystem

ERR ErrOSMemoryInit()
	{
	//  nop

	return JET_errSuccess;
	}


#ifdef MEM_CHECK

struct MAI
	{
	MAI*			pmaiNext;

	void*			pv;
	size_t			cb;
	DWORD			lLine;
	const _TCHAR*	szFile;
	};

INLINE int ImaiHashPv( void* const pv )
	{
	return (int)(( DWORD_PTR( pv ) / sizeof( int ) ) % cmai);
	}

void OSMemoryIInsertHeapAlloc( void* const pv, const size_t cb, const _TCHAR* szFile, long lLine )
	{
	//  we should not see any failed allocations

	Assert( pv );

	//  use the first chunk of the memory for the MAI

	MAI* pmai = (MAI*)pv;

	//  initialize the MAI

	pmai->pv = pv;
	pmai->cb = cb;
	pmai->szFile = szFile;
	pmai->lLine = lLine;

	//  insert the MAI into the hash table

	const int imai = ImaiHashPv( pv );
	CRITICAL_SECTION* pcsmai = rgcsmai + imai % ccsmai;

	EnterCriticalSection( pcsmai );

	pmai->pmaiNext = rgpmai[imai];
	rgpmai[imai] = pmai;

	LeaveCriticalSection( pcsmai );
	}

void OSMemoryIDeleteHeapAlloc( void* const pv, size_t cb )
	{
	//  we should not see any failed allocations

	Assert( pv );

	//  find the specified allocation in the hash table

	const int imai = ImaiHashPv( pv );
	CRITICAL_SECTION* pcsmai = rgcsmai + imai % ccsmai;

	EnterCriticalSection( pcsmai );

	MAI** ppmai = &rgpmai[imai];
	while ( *ppmai && (*ppmai)->pv != pv )
		{
		ppmai = &(*ppmai)->pmaiNext;
		}

	EnforceSz( *ppmai, "An attempt to free unallocated memory has been made" );

	//  remove the MAI from the hash table

	MAI* pmai = *ppmai;
	*ppmai = pmai->pmaiNext;

	AssertSz( pmai->cb == cb + sizeof( MAI ), "Difference between allocated and current size of heap chunk" );

	LeaveCriticalSection( pcsmai );
	}

void OSMemoryIInsertPageAlloc( void* const pv, const size_t cb, const _TCHAR* szFile, long lLine )
	{
	//  we should not see any failed allocations

	Assert( pv );

	//  allocate an MAI for this new allocation

	MAI* pmai = (MAI*)MpHeapAlloc( hMPHeapGlobal, 0, sizeof( MAI ) );
	EnforceSz( pmai, "MEM_CHECK only allocation failed!" );

	//  initialize the MAI

	pmai->pv = pv;
	pmai->cb = cb;
	pmai->szFile = szFile;
	pmai->lLine = lLine;

	//  insert the MAI into the hash table

	const int imai = ImaiHashPv( pv );
	CRITICAL_SECTION* pcsmai = rgcsmai + imai % ccsmai;

	EnterCriticalSection( pcsmai );

	pmai->pmaiNext = rgpmai[imai];
	rgpmai[imai] = pmai;

	LeaveCriticalSection( pcsmai );
	}

void OSMemoryIDeletePageAlloc( void* pv, const size_t cb )
	{
	//  we should not see any failed allocations

	Assert( pv );

	//  find the specified allocation in the hash table

	const int imai = ImaiHashPv( pv );
	CRITICAL_SECTION* pcsmai = rgcsmai + imai % ccsmai;

	EnterCriticalSection( pcsmai );

	MAI** ppmai = &rgpmai[imai];
	while ( *ppmai && (*ppmai)->pv != pv )
		{
		ppmai = &(*ppmai)->pmaiNext;
		}

	EnforceSz( *ppmai, "An attempt to free unallocated memory has been made" );

	//  remove the MAI from the hash table

	MAI* pmai = *ppmai;
	*ppmai = pmai->pmaiNext;

	AssertSz( pmai->cb == cb, "Difference between allocated 0x%016X and current size (pointer: 0x%p ) of page chunk" );

	LeaveCriticalSection( pcsmai );

	//  free allocation record

	MpHeapFree( hMPHeapGlobal, pmai );
	}
	
void OSMemoryIDumpAlloc( const _TCHAR* szDumpFile, const BOOL fMemDump )
	{
	HANDLE hFile = CreateFile(
		szDumpFile,
		GENERIC_WRITE,
		0,
		NULL,
		OPEN_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL
		);
		
	if ( INVALID_HANDLE_VALUE != hFile )
		{
		_TCHAR	szMessage[512];
		DWORD cchActual;

		(void)SetFilePointer( hFile, 0, NULL, FILE_END );

		_stprintf( szMessage, _T( "\r\nMemory Leak Statistics\r\n\r\n" ) );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

		_stprintf( szMessage, _T( "cAllocHeap - cFreeHeap = 0x%016I64x\r\n" ), (QWORD)cAllocHeap - cFreeHeap );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
		_stprintf( szMessage, _T( "cbAllocHeap            = 0x%016I64x bytes\r\n" ), (QWORD)cbAllocHeap );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
		_stprintf( szMessage, _T( "cbReservePage          = 0x%016I64x pages (0x%016I64x bytes)\r\n" ), (QWORD)cbReservePage / OSMemoryPageCommitGranularity(), (QWORD)cbReservePage );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
		_stprintf( szMessage, _T( "cbCommitPage           = 0x%016I64x pages (0x%016I64x bytes)\r\n\r\n" ), (QWORD)cbCommitPage / OSMemoryPageCommitGranularity(), (QWORD)cbCommitPage );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

		_stprintf( szMessage, _T( "Address             Size                Type  File(Line)\r\n" ) );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
		_stprintf( szMessage, _T( "==================  ==================  ====  ==========================================\r\n" ) );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

		DWORD imai;
		SIZE_T cbAlloc;
		DWORD_PTR cbReserve;
		DWORD cAlloc, cPages;
		cbAlloc = 0; 
		cbReserve = 0; 
		cAlloc = 0;
		cPages = 0;
		for ( imai = 0; imai < cmai; imai++ )
			{
			MAI* pmai = rgpmai[imai];
			while ( pmai )
				{
				size_t ib;
				size_t cb;
				BYTE *pb;

				cb = pmai->cb;
				pb = (BYTE*)pmai->pv;
				if ( pmai->pv == (void*)pmai )
					{
					pb += sizeof( MAI );	//	skip the MAI for heap allocations
					cb = ( cb > sizeof( MAI ) ? cb - sizeof( MAI ) : 0 );	//	should never be 0
					}

				_stprintf(	szMessage,
							_T( "0x%016I64X  0x%016I64X  %-4s  %s(%d)\r\n" ),
							QWORD( pb ),
							QWORD( cb ),
							pmai->pv == (void*)pmai ? _T( "Heap" ) : _T( "Page" ),
							pmai->szFile,
							pmai->lLine );
				(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
				if ( pmai->pv == pmai )
					{
					cAlloc++;
					cbAlloc += cb;
					}
				else
					{
					cPages++;
					cbReserve += cb;
					}

				if ( 512 < cb )
					{
					cb = 512;
					}
				if ( fMemDump )
					{
					//	dump up to 512 bytes

					if ( pmai->pv != (void*)pmai )
						{
						BOOL						fReadable	= fTrue;
						MEMORY_BASIC_INFORMATION	mbi;
						const size_t				iVQ			= VirtualQuery( pb, &mbi, cb );

						if ( iVQ >= sizeof( mbi ) )
							{
							if ( mbi.RegionSize < cb )
								{
								fReadable = fFalse;	//	should never happen -- we're too lazy to query again
								}
							if ( mbi.State != MEM_COMMIT )
								{
								fReadable = fFalse;
								}
							if ( !( mbi.AllocationProtect & 
									( PAGE_READONLY | 
									  PAGE_READWRITE | 
									  PAGE_EXECUTE_READ | 
									  PAGE_EXECUTE_READWRITE ) ) )
								{
								fReadable = fFalse;
								}
							}
						else
							{
							fReadable = fFalse;
							}
						if ( !fReadable )
							{
							_stprintf( szMessage, _T( "\t<< block is not dumpable (not committed) >>\r\n" ) );
							(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
							goto NextMAI;
							}
						}

					ib = 0;
					while ( ib < cb )
						{
						if ( cb - ib >= 16 )
							{
							_stprintf(	szMessage,
										_T( "\t%04X: %02X %02X %02X %02X %02X %02X %02X %02X-%02X %02X %02X %02X %02X %02X %02X %02X\r\n" ),
										ib,
										pb[ib+0], pb[ib+1], pb[ib+2], pb[ib+3],
										pb[ib+4], pb[ib+5], pb[ib+6], pb[ib+7],
										pb[ib+8], pb[ib+9], pb[ib+10], pb[ib+11],
										pb[ib+12], pb[ib+13], pb[ib+14], pb[ib+15] );
							ib += 16;
							}
						else 
							{
							_stprintf(	szMessage,
										_T( "\t%04X: %02X" ),
										ib,
										pb[ib] );
							ib++;
							while ( ib < cb )
								{
								_TCHAR szT[10];
								_stprintf(	szT,
											_T( " %02X" ),
											pb[ib] );
								ib++;
								_tcscat( szMessage, szT );
								}
							_tcscat( szMessage, "\r\n" );
							}
						(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
						}
					}

NextMAI:
				pmai = pmai->pmaiNext;
				}
			}
		_stprintf( szMessage, _T( "Calculated mem stats\r\n====================\r\n" ) );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
		_stprintf( szMessage, _T( "cAllocHeap - cFreeHeap = 0x%016I64x\r\n" ), (QWORD)cAlloc );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
		_stprintf( szMessage, _T( "cbAllocHeap            = 0x%016I64x bytes\r\n" ), (QWORD)cbAlloc );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
		_stprintf( szMessage, _T( "cbReservePage          = 0x%016I64x pages (0x%016I64x bytes)\r\n" ), (QWORD)cbReserve / OSMemoryPageCommitGranularity(), (QWORD)cbReserve );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

		(void)CloseHandle( hFile );
		}
	}

#endif  //  MEM_CHECK


//  Heap Memory Allocation

//	calculate the address of the aligned block and store its offset (for free)

INLINE void* PvOSMemoryHeapIAlign( void* const pv, const size_t cbAlign )
	{

	//	round up to the nearest cache line
	//	NOTE: this formula always forces an offset of atleast 1 byte

	const ULONG_PTR ulp			= ULONG_PTR( pv );
	const ULONG_PTR ulpAligned	= ( ( ulp + cbAlign ) / cbAlign ) * cbAlign;
	const ULONG_PTR ulpOffset	= ulpAligned - ulp;

	Assert( ulpOffset > 0 );
	Assert( ulpOffset <= cbAlign );
	Assert( ulpOffset == BYTE( ulpOffset ) );	//	must fit into a single BYTE

	//	store the offset

	BYTE *const pbAligned	= (BYTE*)ulpAligned;
	pbAligned[ -1 ]			= BYTE( ulpOffset );

	//	return the aligned block

	return (void*)pbAligned;
	}


//	retrieve the offset of the real block being freed

INLINE void* PvOSMemoryHeapIUnalign( void* const pv )
	{

	//	read the offset of the real block

	BYTE *const pbAligned	= (BYTE*)pv;
	const BYTE bOffset		= pbAligned[ -1 ];

	Assert( bOffset > 0 );

	//	return the real unaligned block

	return (void*)( pbAligned - bOffset );
	}


//  allocate a chunk of memory from the process heap of the specifed size,
//  returning NULL if there is insufficient heap memory available to satisfy
//  the request.  "aligned" memory will always start at the beginning of a
//	cache line.

#ifdef MEM_CHECK

void* PvOSMemoryHeapAlloc_( const size_t cbSize, const _TCHAR* szFile, long lLine )
	{
	if ( !g_fMemCheck )
		{
		return PvOSMemoryHeapAlloc__( cbSize );
		}

	//  check for RFS
	
	if ( !RFSAlloc( OSMemoryHeap ) )
		{
		return NULL;
		}

	//	calculate the size of the block

	const size_t cbSizeT = sizeof( MAI ) + cbSize;

	//  allocate memory from the process global heap

	void* const pv = MpHeapAlloc( hMPHeapGlobal, 0, cbSizeT );
	if ( !pv )
		{
		return pv;
		}

	//	get the true size of the block (heap may allocate a few extra bytes)

	size_t cbAllocSize = MpHeapSize( hMPHeapGlobal, 0, pv );
	
	AtomicIncrement( (long*)&cAllocHeap );
	AtomicExchangeAdd( (long*)&cbAllocHeap, DWORD( cbAllocSize - sizeof( MAI ) ) );

	//  insert allocation record for this memory

	OSMemoryIInsertHeapAlloc( pv, cbAllocSize, szFile, lLine );

	//  fill memory to detect illegal use of uninit data
	
	memset( (BYTE*)pv + sizeof( MAI ), chGlobalAllocFill, cbAllocSize - sizeof( MAI ) );

	//	return the block

	return (void*)( (BYTE*)pv + sizeof( MAI ) );
	}


void* PvOSMemoryHeapAllocAlign_( const size_t cbSize, const size_t cbAlign, const _TCHAR* szFile, long lLine )
	{
	if ( !g_fMemCheck )
		{
		return PvOSMemoryHeapAllocAlign__( cbSize, cbAlign );
		}
		
	void* const pv = PvOSMemoryHeapAlloc_( cbSize + cbAlign, szFile, lLine );
	if ( pv )
		{
		return PvOSMemoryHeapIAlign( pv, cbAlign );
		}
	return NULL;
	}


#endif  //  !MEM_CHECK


void* PvOSMemoryHeapAlloc__( const size_t cbSize )
	{
	//  check for RFS
	
	if ( !RFSAlloc( OSMemoryHeap ) )
		{
		return NULL;
		}

	//  allocate and return memory from the process global heap
	
	void* const pv = MpHeapAlloc( hMPHeapGlobal, 0, cbSize );
	if ( !pv )
		{
		return pv;
		}

	//	get the true size of the block (heap may allocate a few extra bytes)

	size_t cbAllocSize = MpHeapSize( hMPHeapGlobal, 0, pv );
	
	AtomicIncrement( (long*)&cAllocHeap );
	AtomicExchangeAdd( (long*)&cbAllocHeap, DWORD( cbAllocSize ) );

	//	return the block

	return pv;
	}

void* PvOSMemoryHeapAllocAlign__( const size_t cbSize, const size_t cbAlign )
	{
	void* const pv = PvOSMemoryHeapAlloc( cbSize + cbAlign );
	if ( pv )
		{
		return PvOSMemoryHeapIAlign( pv, cbAlign );
		}
	return NULL;
	}

//  free the specified chunk of memory back to the process heap

void OSMemoryHeapFree( void* const pv )
	{
	if ( pv )
		{
		//  recover true allocation pointer

#ifdef MEM_CHECK
		void* pvTrue = (BYTE*)pv - ( g_fMemCheck ? sizeof( MAI ) : 0 );
#else // MEM_CHECK
		void* pvTrue = pv;
#endif  //  MEM_CHECK

		//  recover the true allocation size

		size_t cbAllocSize = MpHeapSize( hMPHeapGlobal, 0, pvTrue );

#ifdef MEM_CHECK

		if ( g_fMemCheck )
			{

			//  fix true allocation size

			cbAllocSize -= sizeof( MAI );
			
			//  remove allocation record for this memory

			OSMemoryIDeleteHeapAlloc( pvTrue, cbAllocSize );

			//  fill memory to detect illegal use after free
		
			memset( pv, chGlobalFreeFill, cbAllocSize );
			}

#endif  //  MEM_CHECK

		//  free memory to the process global heap

		AtomicIncrement( (long*)&cFreeHeap );
		AtomicExchangeAdd( (long*)&cbAllocHeap, DWORD( -cbAllocSize ) );

		BOOL fMemFreed = MpHeapFree( hMPHeapGlobal, pvTrue );
		Assert( fMemFreed );
		}
	}


void OSMemoryHeapFreeAlign( void* const pv )
	{
	if ( pv )
		{
		OSMemoryHeapFree( PvOSMemoryHeapIUnalign( pv ) );
		}
	}



//  Page Memory Allocation Support

//  returns information about the page memory allocation unit containing the
//  specified pointer including the base address of the region, the size of the
//  region, and the amount of the region committed

#ifdef ENABLE_VIRTUAL_QUERY
void OSMemoryPageIGetAlloc( void* const pv, size_t* const pcbAllocReserve, size_t* const pcbAllocCommit )
	{
	//  get pointer to the base of the allocation region

	MEMORY_BASIC_INFORMATION	mbi;
	const size_t				cbRet			= VirtualQuery( pv, &mbi, sizeof( mbi ) );
	Assert( cbRet >= sizeof( mbi ) );

	void*						pvAllocBase		= mbi.AllocationBase;
	void*						pvScan			= pvAllocBase;

	//  scan the entire allocation region to determine its size and committed bytes

	*pcbAllocReserve = 0;
	*pcbAllocCommit = 0;
	for ( ; ; )
		{
		//  get this region's attributes
		
		const size_t	cbRet	= VirtualQuery( pvScan, &mbi, sizeof( mbi ) );
		Assert( cbRet >= sizeof( mbi ) );

		//  this region is part of the allocation

		if ( mbi.AllocationBase == pvAllocBase )
			{
			Assert( mbi.State == MEM_COMMIT || mbi.State == MEM_RESERVE );
			
			//  add this region's size to our reserve total

			*pcbAllocReserve += mbi.RegionSize;

			//  this region is committed

			if ( mbi.State == MEM_COMMIT )
				{
				//  add this region's size to our commit total

				*pcbAllocCommit += mbi.RegionSize;
				}
				
			//  advance to the next region

			pvScan = (void*)( (BYTE*)mbi.BaseAddress + mbi.RegionSize );
			}

		//  this region is not part of the allocation

		else
			{
			//  we're done

			break;
			}
		}
	}

//  returns the total size and committed bytes of the specified region, rounding
//  to the nearest page commit granularity on the high and low end of the region

void OSMemoryPageIGetCommit( void* const pv, const size_t cbSize, size_t* const pcbCommit, size_t* const pcbTotal )
	{
	//  compute region boundaries, accounting for page commit granularity
	
	void* pvStart = (BYTE*)pv - DWORD_PTR( pv ) % OSMemoryPageCommitGranularity();
	void* pvEnd = (BYTE*)pv + cbSize + OSMemoryPageCommitGranularity() - 1;
	pvEnd = (BYTE*)pvEnd - DWORD_PTR( pvEnd ) % OSMemoryPageCommitGranularity();

	//  compute total region size

	*pcbTotal = (BYTE*)pvEnd - (BYTE*)pvStart;

	//  scan region of memory looking for committed memory

	void* pvScan = pvStart;
	*pcbCommit = 0;
	do
		{
		//  get the attributes of the current region
		
		MEMORY_BASIC_INFORMATION	mbi;
		const size_t				cbRet	= VirtualQuery( pvScan, &mbi, sizeof( mbi ) );
		Assert( cbRet >= sizeof( mbi ) );
		Assert( mbi.State == MEM_COMMIT || mbi.State == MEM_RESERVE );

		//  this region is committed

		if ( mbi.State == MEM_COMMIT )
			{
			//  add its size to the total committed bytes count
			
			*pcbCommit += min( mbi.RegionSize, (BYTE*)pvEnd - (BYTE*)mbi.BaseAddress );
			}

		//  advance to the next region
			
		pvScan = (void*)( (BYTE*)mbi.BaseAddress + mbi.RegionSize );
		}
	while ( pvScan < pvEnd );
	}
#endif // ENABLE_VIRTUAL_QUERY



//  Page Memory Control

//  reserves and commits a range of virtual addresses of the specifed size,
//  returning NULL if there is insufficient address space or backing store to
//  satisfy the request.  Note that the page reserve granularity applies to
//  this range

#ifdef MEM_CHECK

void* PvOSMemoryPageAlloc_( const size_t cbSize, void* const pv, const _TCHAR* szFile, long lLine )
	{
	if ( !g_fMemCheck )
		{
		return PvOSMemoryPageAlloc__( cbSize, pv );
		}

	//  check for RFS
	
	if (	!RFSAlloc( OSMemoryPageAddressSpace ) ||
			!RFSAlloc( OSMemoryPageBackingStore ) )
		{
		return NULL;
		}

	//  allocate address space and backing store of the specified size

	void* const pvRet = VirtualAlloc( pv, cbSize, MEM_COMMIT, PAGE_READWRITE );
	if ( !pvRet )
		{
		return pvRet;
		}
	Assert( !pv || pvRet == pv );

#ifdef ENABLE_VIRTUAL_QUERY
	//	query the state of the address range

	size_t cbAllocReserve;
	size_t cbAllocCommit;
	OSMemoryPageIGetAlloc( pvRet, &cbAllocReserve, &cbAllocCommit );
	
	//	memory should be fully reserved and committed

	Enforce( cbAllocReserve >= cbSize );
	Enforce( cbAllocCommit >= cbSize );

	//	update the counters

	AtomicExchangeAddPointer( (void**)&cbReservePage, (void*)cbAllocReserve );
	AtomicExchangeAddPointer( (void**)&cbCommitPage, (void*)cbAllocCommit );

	//  insert allocation record for this memory
	
	OSMemoryIInsertPageAlloc( pvRet, cbAllocReserve, szFile, lLine );
#endif // ENABLE_VIRTUAL_QUERY

	return pvRet;
	}

#endif  //  !MEM_CHECK

void* PvOSMemoryPageAlloc__( const size_t cbSize, void* const pv )
	{
	//  check for RFS
	
	if (	!RFSAlloc( OSMemoryPageAddressSpace ) ||
			!RFSAlloc( OSMemoryPageBackingStore ) )
		{
		return NULL;
		}

	//  allocate address space and backing store of the specified size

	void* const pvRet = VirtualAlloc( pv, cbSize, MEM_COMMIT, PAGE_READWRITE );
	if ( !pvRet )
		{
		return pvRet;
		}
	Assert( !pv || pvRet == pv );

#ifdef ENABLE_VIRTUAL_QUERY
	//	query the state of the address range

	size_t cbAllocReserve;
	size_t cbAllocCommit;
	OSMemoryPageIGetAlloc( pvRet, &cbAllocReserve, &cbAllocCommit );
	
	//	memory should be fully reserved and committed

	Enforce( cbAllocReserve >= cbSize );
	Enforce( cbAllocCommit >= cbSize );

	//	update the counters

	AtomicExchangeAddPointer( (void**)&cbReservePage, (void*)cbAllocReserve );
	AtomicExchangeAddPointer( (void**)&cbCommitPage, (void*)cbAllocCommit );
#endif // ENABLE_VIRTUAL_QUERY

	return pvRet;
	}


//  free the reserved range of virtual addresses starting at the specified
//  address, freeing any backing store committed to this range

void OSMemoryPageFree( void* const pv )
	{
	if ( pv )
		{
#ifdef ENABLE_VIRTUAL_QUERY
		//	query the state of the address range

		size_t cbAllocReserve;
		size_t cbAllocCommit;
		OSMemoryPageIGetAlloc( pv, &cbAllocReserve, &cbAllocCommit );
	
		//	the state should be reflected in the counters

		Enforce( cbReservePage >= cbAllocReserve );
		Enforce( cbCommitPage >= cbAllocCommit );

		//	update the counters

		AtomicExchangeAddPointer( (void**)&cbReservePage, (void*)-cbAllocReserve );
		AtomicExchangeAddPointer( (void**)&cbCommitPage, (void*)-cbAllocCommit );

#ifdef MEM_CHECK

		if ( g_fMemCheck )
			{

			//  verify that the entire allocated range will be freed

			EnforceSz(	cbAllocCommit == 0 || cbAllocCommit == cbAllocReserve,
						"An attempt to free mixed-attribute page memory has been made" );

			//  remove allocation record for this memory

			OSMemoryIDeletePageAlloc( pv, cbAllocReserve );
			}

#endif  //  MEM_CHECK
#endif // ENABLE_VIRTUAL_QUERY

		BOOL fMemFreed = VirtualFree( pv, 0, MEM_RELEASE );
		Assert( fMemFreed );
		}
	}


//  reserve a range of virtual addresses of the specified size, returning NULL
//  if there is insufficient address space to satisfy the request.  Note that
//  the page reserve granularity applies to this range

#ifdef MEM_CHECK

void* PvOSMemoryPageReserve_( const size_t cbSize, void* const pv, const _TCHAR* szFile, long lLine )
	{
	if ( !g_fMemCheck )
		{
		return PvOSMemoryPageReserve__( cbSize, pv );
		}

	//  check for RFS
	
	if ( !RFSAlloc( OSMemoryPageAddressSpace ) )
		{
		return NULL;
		}

	//  allocate address space of the specified size

	void* const pvRet = VirtualAlloc( pv, cbSize, MEM_RESERVE, PAGE_READWRITE );
	if ( !pvRet )
		{
		return pvRet;
		}
	Assert( !pv || pvRet == pv );

#ifdef ENABLE_VIRTUAL_QUERY
	//	query the current state of the address range

	size_t cbAllocReserve;
	size_t cbAllocCommit;
	OSMemoryPageIGetAlloc( pvRet, &cbAllocReserve, &cbAllocCommit );

	//	memory should be reserved, not committed

	Enforce( cbAllocReserve >= cbSize );
	Enforce( 0 == cbAllocCommit );

	//	update the counters

	AtomicExchangeAddPointer( (void**)&cbReservePage, (void*)cbAllocReserve );

	//  insert allocation record for this memory
	
	OSMemoryIInsertPageAlloc( pvRet, cbAllocReserve, szFile, lLine );
#endif // ENABLE_VIRTUAL_QUERY

	return pvRet;
	}

#endif  //  !MEM_CHECK

void* PvOSMemoryPageReserve__( const size_t cbSize, void* const pv )
	{
	//  check for RFS
	
	if ( !RFSAlloc( OSMemoryPageAddressSpace ) )
		{
		return NULL;
		}

	//  allocate address space of the specified size

	void* const pvRet = VirtualAlloc( pv, cbSize, MEM_RESERVE, PAGE_READWRITE );
	if ( !pvRet )
		{
		return pvRet;
		}
	Assert( !pv || pvRet == pv );

#ifdef ENABLE_VIRTUAL_QUERY
	//	query the current state of the address range

	size_t cbAllocReserve;
	size_t cbAllocCommit;
	OSMemoryPageIGetAlloc( pvRet, &cbAllocReserve, &cbAllocCommit );

	//	memory should be reserved, not committed

	Enforce( cbAllocReserve >= cbSize );
	Enforce( 0 == cbAllocCommit );

	//	update the counters

	AtomicExchangeAddPointer( (void**)&cbReservePage, (void*)cbAllocReserve );
#endif // ENABLE_VIRTUAL_QUERY

	return pvRet;
	}


//  reset the dirty bit for the specified range of virtual addresses.  this
//  results in the contents of the memory being thrown away instead of paged
//  to disk if the OS needs its physical memory for another process.  a value
//  of fTrue for fToss results in a hint to the OS to throw the specified
//  memory out of our working set.  Note that the page commit granularity
//  applies to this range

void OSMemoryPageReset( void* const pv, const size_t cbSize, const BOOL fToss )
	{

	//  reset the dirty bit for these vmem pages if set
	
	(void)VirtualAlloc( pv, cbSize, MEM_RESET, PAGE_READWRITE );

	//  this memory has been selected to be thrown out of our working set
	
	if ( fToss )
		{
		//  VirtualUnlock() hints the OS to put this memory on the avail list
		
		(void)VirtualUnlock( pv, cbSize );
		}
	}


//  set the specified range of virtual addresses as read only.  Note that the
//  page commit granularity applies to this range

void OSMemoryPageProtect( void* const pv, const size_t cbSize )
	{
	DWORD flOldProtect;
	BOOL fSetRO = VirtualProtect( pv, cbSize, PAGE_READONLY, &flOldProtect );
	Assert( fSetRO );
	}


//  set the specified range of virtual addresses as read / write.  Note that
//  the page commit granularity applies to this range

void OSMemoryPageUnprotect( void* const pv, const size_t cbSize )
	{
	DWORD flOldProtect;
	BOOL fSetRW = VirtualProtect( pv, cbSize, PAGE_READWRITE, &flOldProtect );
	Assert( fSetRW );
	}


//  commit the specified range of virtual addresses, returning fFalse if there
//  is insufficient backing store to satisfy the request.  Note that the page
//  commit granularity applies to this range

BOOL FOSMemoryPageCommit( void* const pv, const size_t cb )
	{

	//  check for RFS
	
	if ( !RFSAlloc( OSMemoryPageBackingStore ) )
		{
		return fFalse;
		}

	//	verify input

	if ( !pv )
		{
		return fFalse;
		}

	//	query the state of the space we are committing

#ifdef ENABLE_VIRTUAL_QUERY
	size_t cbCommitT;
	size_t cbTotalT;
	OSMemoryPageIGetCommit( pv, cb, &cbCommitT, &cbTotalT );

	//	calculate the amount of memory we will be committing

	const size_t cbToCommitT = cbTotalT - cbCommitT;

	//	we cannot commit more than we have reserved

	Enforce( cbCommitPage + cbToCommitT <= cbReservePage );
#endif // ENABLE_VIRTUAL_QUERY

	//	commit the memory

	const BOOL fAllocOK = VirtualAlloc(	pv, cb, MEM_COMMIT, PAGE_READWRITE ) != NULL;

#ifdef ENABLE_VIRTUAL_QUERY
	if ( fAllocOK )
		{

		//	update the global counters

		AtomicExchangeAddPointer( (void**)&cbCommitPage, (void*)cbToCommitT );
		}
#endif // ENABLE_VIRTUAL_QUERY

	return fAllocOK;
	}


//  decommit the specified range of virtual addresses, freeing any backing
//  store committed to this range.  Note that the page commit granularity
//  applies to this range

void OSMemoryPageDecommit( void* const pv, const size_t cb )
	{

	//	verify input

	if ( !pv )
		{
		return;
		}

#ifdef ENABLE_VIRTUAL_QUERY
	//	query the state of the space we are decommitting

	size_t cbCommitT;
	size_t cbTotalT;
	OSMemoryPageIGetCommit( pv, cb, &cbCommitT, &cbTotalT );

	//	we cannot decommit more than we have reserved or committed

	Enforce( cbCommitT <= cbCommitPage );
	Enforce( cbCommitT <= cbReservePage );

	//	update the global counter

	AtomicExchangeAddPointer( (void**)&cbCommitPage, (void*)-cbCommitT );
#endif // ENABLE_VIRTUAL_QUERY

	//  free backing store for the specified range

	const BOOL fFreeOK = VirtualFree( pv, cb, MEM_DECOMMIT );
	Assert( fFreeOK );
	}




//	Memory Mapping


//	COSMemoryMap -- the basic object used in all memory mapping

//	ctor

COSMemoryMap::COSMemoryMap()
	{
	m_pvMap = NULL;
	m_cbMap = 0;
	m_cMap = 0;

	m_cbReserve = 0;
	m_cbCommit = 0;

#ifdef MEM_CHECK

	m_posmmNext = NULL;
	m_fInList = fFalse;
	m_szFile = NULL;
	m_lLine = 0;

#endif	//	MEM_CHECK
	}


//	dtor

COSMemoryMap::~COSMemoryMap()
	{
	}


//	init

COSMemoryMap::ERR
COSMemoryMap::ErrOSMMInit()
	{
	m_pvMap = NULL;
	m_cbMap = 0;
	m_cMap = 0;

	m_cbReserve = 0;
	m_cbCommit = 0;

#ifdef MEM_CHECK

	m_posmmNext = NULL;
	m_fInList = fFalse;
	m_szFile = NULL;
	m_lLine = 0;

	if ( g_fMemCheck )
		{

		//	insert this COSMemoryMap object into the global list

		EnterCriticalSection( &g_csosmm );
		m_posmmNext = g_posmm;
		g_posmm = this;
		m_fInList = fTrue;
		LeaveCriticalSection( &g_csosmm );
		}

#endif	//	MEM_CHECK

	return errSuccess;
	}


//	term

VOID COSMemoryMap::OSMMTerm()
	{
	//	make sure all resources have been released

	Enforce( 0 == m_cbReserve );
	Enforce( 0 == m_cbCommit );

#ifdef MEM_CHECK

	if ( g_fMemCheck && m_fInList )
		{

		//	remove this object from the list

		EnterCriticalSection( &g_csosmm );
		COSMemoryMap *posmmCur;
		COSMemoryMap *posmmPrev;

		posmmCur = g_posmm;
		posmmPrev = NULL;
		while ( posmmCur && posmmCur != this )
			{
			posmmPrev = posmmCur;
			posmmCur = posmmCur->m_posmmNext;
			}
		if ( posmmCur )
			{
			if ( posmmPrev )
				{
				posmmPrev->m_posmmNext = m_posmmNext;
				}
			else
				{
				g_posmm = m_posmmNext;
				}
			}
		else
			{
			EnforceSz( fFalse, "memory-map list corrupt" );
			}
		LeaveCriticalSection( &g_csosmm );

		m_fInList = fFalse;
		}

#endif	//	MEM_CHECK
	}

//  returns fTrue if we can map the same chunk of backing store into more than
//  one address range

BOOL COSMemoryMap::FCanMultiMap()
	{
	return fCanMultiMap;
	}

//	reserve a chunk of backing store and map it to the given address(es). 
//	if any of the given addresses in rgpvMap[] are NULL, a suitable address
//	will be chosen automatically.  on success, the location of each mapping 
//	will be returned in rgpvMap[].  on failure, the state of rgpvMap[] is
//	undefined.  
//
//	NOTE: backing store it not actually allocated until commit time
//	NOTE: page reserve granularity applies to this range


COSMemoryMap::ERR 
COSMemoryMap::ErrOSMMReserve__(	const size_t		cbMap, 
								const size_t		cMap, 
								void** const		rgpvMap, 
								const BOOL* const	rgfProtect )
	{
	ERR err;

	//  check for RFS

	if ( !RFSAlloc( OSMemoryPageBackingStore ) )
		{
		return errOutOfBackingStore;
		}
	if ( !RFSAlloc( OSMemoryPageAddressSpace ) )
		{
		return errMappingFailed;
		}

	size_t	cbMapT;
	HANDLE	hBackingStore	= NULL;
	size_t	iMap			= 0;

#ifdef ENABLE_VIRTUAL_QUERY
	//	verify our state (should not already have a mapping setup)

	Assert( !m_pvMap );
	Assert( 0 == m_cbMap );
	Assert( 0 == m_cMap );
#endif // ENABLE_VIRTUAL_QUERY

	//	verify input

	Assert( cbMap > 0 );
	Assert( cMap > 0 );
	Assert( rgpvMap );
	Assert( rgfProtect );

	//	round to the nearest reservation granularity

	cbMapT =	(	( cbMap + OSMemoryPageReserveGranularity() - 1 ) / 
					OSMemoryPageReserveGranularity() ) * 
				OSMemoryPageReserveGranularity();

	//	allocate the backing store

	hBackingStore = CreateFileMapping(	INVALID_HANDLE_VALUE,
										NULL,
										PAGE_READWRITE | SEC_RESERVE,
										sizeof( cbMapT ) > sizeof( DWORD ) ? cbMapT >> 32 : 0,
										DWORD( cbMapT ),
										NULL );
	if ( !hBackingStore )
		{
		return errOutOfBackingStore;
		}

	//	map the backing store to given location(s)

	while ( iMap < cMap )
		{
		void* const pvMap = MapViewOfFileEx(	hBackingStore,
												rgfProtect[iMap] ? FILE_MAP_READ : FILE_MAP_WRITE,
												0, 
												0, 
												0, 
												rgpvMap[iMap] );
		if ( !pvMap )
			{
			err = errMappingFailed;
			goto HandleError;
			}

		//	record the result of the mapping

		Assert( !rgpvMap[iMap] || pvMap == rgpvMap[iMap] );
		rgpvMap[iMap] = pvMap;

		//	move to the next mapping

		iMap++;
		}

	BOOL fCloseOK;
	fCloseOK = CloseHandle( hBackingStore );
	Assert( fCloseOK );

	//	record the state of the entire mapping

	m_pvMap = rgpvMap[0];
	m_cbMap = cbMapT;
	m_cMap = cMap;

#ifdef ENABLE_VIRTUAL_QUERY
	//	update our counters

	m_cbReserve = cMap * cbMapT;
	m_cbCommit = 0;

	//	update the global counters

	AtomicExchangeAddPointer( (void**)&cbReservePage, (void*)m_cbReserve );
#endif // ENABLE_VIRTUAL_QUERY

	return errSuccess;

HandleError:

	//	cleanup any leftover mappings

	while ( iMap-- > 0 )
		{
		const BOOL fUnmapOK = UnmapViewOfFile( rgpvMap[iMap] );
		Assert( fUnmapOK );
		}

	//	cleanup the backing store

	Assert( hBackingStore );
	fCloseOK = CloseHandle( hBackingStore );
	Assert( fCloseOK );

	return err;
	}

#ifdef MEM_CHECK

COSMemoryMap::ERR 
COSMemoryMap::ErrOSMMReserve_(	const size_t		cbMap, 
								const size_t		cMap, 
								void** const		rgpvMap, 
								const BOOL* const	rgfProtect,
								const _TCHAR* 		szFile, 
								long 				lLine )
	{

	//	do the reservation

	const ERR err = ErrOSMMReserve__( cbMap, cMap, rgpvMap, rgfProtect );

	if ( errSuccess == err && g_fMemCheck )
		{

		//  record the file/line responsible for this reservation

		Assert( !m_szFile );
		Assert( 0 == m_lLine );
		m_szFile = (_TCHAR*)szFile;
		m_lLine = lLine;
		}

	return err;
	}

#endif	//	MEM_CHECK


//	commit a chunk of the reservation.  this forces the backing store to be 
//	allocated and assigned to the appropriate address range.  on success,
//	the specified region within each mapping will be committed.
//
//	NOTE: page commit granularity applies to this range

BOOL COSMemoryMap::FOSMMCommit( const size_t ibOffset, const size_t cbCommit )
	{

	//  check for RFS
	
	if ( !RFSAlloc( OSMemoryPageBackingStore ) )
		{
		return fFalse;
		}

	//	verify our state (should have a mapping setup)

	Assert( m_pvMap );
	Assert( m_cbMap > 0 );
	Assert( m_cMap > 0 );

	//	verify input

	Assert( ibOffset + cbCommit <= m_cbMap );

	//	calculate the address we are committing

	void *const pvCommit = (BYTE*)m_pvMap + ibOffset;

	//	query the state of the space we are committing

#ifdef ENABLE_VIRTUAL_QUERY
	size_t cbCommitT;
	size_t cbTotalT;
	OSMemoryPageIGetCommit( pvCommit, cbCommit, &cbCommitT, &cbTotalT );

	//	calculate the amount of memory we will be committing

	const size_t cbToCommitT = ( cbTotalT - cbCommitT ) * m_cMap;

	//	we cannot commit more than we have reserved

	Enforce( m_cbCommit + cbToCommitT <= m_cbReserve );
#endif // ENABLE_VIRTUAL_QUERY

	//	commit the memory

	const BOOL fAllocOK = VirtualAlloc( pvCommit, cbCommit, MEM_COMMIT, PAGE_READWRITE ) != NULL;

#ifdef ENABLE_VIRTUAL_QUERY
	if ( fAllocOK )
		{

		//	update our counters

		AtomicExchangeAddPointer( (void**)&m_cbCommit, (void*)cbToCommitT );

		//	update the global counters

		AtomicExchangeAddPointer( (void**)&cbCommitPage, (void*)cbToCommitT );
		}
#endif // ENABLE_VIRTUAL_QUERY

	return fAllocOK;
	}


//  decommit and unreserve the address range

VOID COSMemoryMap::OSMMFree( void *const pv )
	{

	//	verify our state (should have a mapping setup)

	Assert( m_pvMap );
	Assert( m_cbMap > 0 );
	Assert( m_cMap > 0 );

	//	make sure we have a valid address

	if ( !pv )
		{
		return;
		}

#ifdef ENABLE_VIRTUAL_QUERY
	//	query the current state of the allocated block

	size_t cbAllocReserve;
	size_t cbAllocCommit;
	OSMemoryPageIGetAlloc( pv, &cbAllocReserve, &cbAllocCommit );

	//	verify the amount of reserved and committed memory

	Enforce( cbAllocReserve <= m_cbMap );
	Enforce( cbAllocCommit <= m_cbMap );

	//	verify that the counters reflect the reserved/committed sizes

	Enforce( cbReservePage >= cbAllocReserve );
	Enforce( cbCommitPage >= cbAllocCommit );
	Enforce( m_cbReserve >= cbAllocReserve );
	Enforce( m_cbCommit >= cbAllocCommit );

	//	update our counters

	AtomicExchangeAddPointer( (void**)&m_cbReserve, (void*)-cbAllocReserve );
	AtomicExchangeAddPointer( (void**)&m_cbCommit, (void*)-cbAllocCommit );

	//	update the global counters

	AtomicExchangeAddPointer( (void**)&cbReservePage, (void*)-cbAllocReserve );
	AtomicExchangeAddPointer( (void**)&cbCommitPage, (void*)-cbAllocCommit );

#ifdef DEBUG

	if ( 0 == m_cbReserve )
		{

		//	we are about to free that last portion of this mapping

		Assert( 0 == m_cbCommit );

		//	reset the rest of the object so it can be used again

		m_pvMap = NULL;
		m_cbMap = 0;
		m_cMap = 0;

#ifdef MEM_CHECK

		m_szFile = NULL;
		m_lLine = NULL;

#endif	//	MEM_CHECK
		}

#endif	//	DEBUG
#endif // ENABLE_VIRTUAL_QUERY

	//  free the specified range

	const BOOL fUnmapOK = UnmapViewOfFile( pv );
	Assert( fUnmapOK );
	}


//	reserve and commit a series of mappings to create a large contiguous 
//	pattern (e.g. zero-filled block)
//
//	NOTE: page reserve granularity applies here

#ifdef MEM_CHECK

COSMemoryMap::ERR 
COSMemoryMap::ErrOSMMPatternAlloc_(	const size_t	cbPattern, 
									const size_t	cbSize,
									void** const 	ppvPattern, 
									const _TCHAR*	szFile, 
									long 			lLine )
	{
	if ( !g_fMemCheck )
		{
		return ErrOSMMPatternAlloc__( cbPattern, cbSize, ppvPattern );
		}

	ERR err;

#ifdef ENABLE_VIRTUAL_QUERY
	//	verify our state (should not have a mapping setup)

	Assert( !m_pvMap );
	Assert( 0 == m_cbMap );
	Assert( 0 == m_cMap );
#endif // ENABLE_VIRTUAL_QUERY

	//	verify input

	Assert( cbPattern > 0 );
	Assert( cbSize >= cbPattern );
	Assert( ppvPattern );

	//	reset output

	*ppvPattern = NULL;

	//	round to the nearest reservation granularity

	size_t cbPatternT;
	cbPatternT =	(	( cbPattern + OSMemoryPageReserveGranularity() - 1 ) / 
						OSMemoryPageReserveGranularity() ) * 
					OSMemoryPageReserveGranularity();

	size_t cbSizeT;
	cbSizeT = 		(	( cbSize + OSMemoryPageReserveGranularity() - 1 ) /
						OSMemoryPageReserveGranularity() ) *
					OSMemoryPageReserveGranularity();

	Assert( cbSizeT >= cbPatternT );
	Assert( 0 == cbSizeT % cbPatternT );

	//	allocate space to describe the mappings (for addresses and protection)

	size_t	cMap		= cbSizeT / cbPatternT;
	void	**rgpvMap	= (void**)( _alloca( cMap * ( sizeof( void* ) + sizeof( BOOL ) ) ) );
	BOOL	*rgfProtect	= (BOOL*)( (BYTE*)rgpvMap + cMap * sizeof( void* ) );

	Assert( cMap > 0 );

	while ( fTrue )
		{

		//	find a suitable address range

		BYTE* rgb;
		if ( !( rgb = (BYTE*)PvOSMemoryPageReserve_( size_t( cbSizeT ), NULL, szFile, lLine ) ) )
			{
			return errOutOfAddressSpace;
			}
		OSMemoryPageFree( rgb );

		//	setup each mapping

		size_t iMap;
		for ( iMap = 0; iMap < cMap; iMap++ )
			{
			rgpvMap[iMap]		= rgb + ( iMap * cbPatternT );
			rgfProtect[iMap]	= fFalse;
			}

		//	make the mapping

		err = ErrOSMMReserve_( cbPatternT, cMap, rgpvMap, rgfProtect, szFile, lLine );
		if ( errSuccess == err )
			{
			break;
			}
		else if ( errOutOfBackingStore == err )
			{
			return err;
			}
		else
			{
			Assert( errMappingFailed == err );
			}
		}

	//	we should have a valid pattern

	Assert( rgpvMap[0] );
	Assert( m_pvMap == rgpvMap[0] );
	Assert( m_cbMap == cbPatternT );
	Assert( m_cMap == cMap );

#ifdef ENABLE_VIRTUAL_QUERY
	Assert( m_cbReserve == cbSizeT );
#endif // ENABLE_VIRTUAL_QUERY
	Assert( m_cbCommit == 0 );

	//  commit the mapping

	if ( !FOSMMCommit( 0, cbPatternT ) )
		{

		//	free each mapping

		size_t iMap;
		for ( iMap = 0; iMap < cMap; iMap++ )
			{
			Assert( (BYTE*)m_pvMap + ( iMap * cbPatternT ) == rgpvMap[iMap] );
			OSMMFree( rgpvMap[iMap] );
			}

		return errOutOfMemory;
		}

#ifdef ENABLE_VIRTUAL_QUERY
	Assert( m_cbCommit == cbSizeT );
#endif // ENABLE_VIRTUAL_QUERY

	//	return the result

	*ppvPattern = rgpvMap[0];

	return errSuccess;
	}

#endif	//	MEM_CHECK

COSMemoryMap::ERR 
COSMemoryMap::ErrOSMMPatternAlloc__(	const size_t	cbPattern, 
										const size_t	cbSize,
										void** const 	ppvPattern )
	{
	ERR err;

#ifdef ENABLE_VIRTUAL_QUERY
	//	verify our state (should not have a mapping setup)

	Assert( !m_pvMap );
	Assert( 0 == m_cbMap );
	Assert( 0 == m_cMap );
#endif // ENABLE_VIRTUAL_QUERY

	//	verify input

	Assert( cbPattern > 0 );
	Assert( cbSize >= cbPattern );
	Assert( ppvPattern );

	//	reset output

	*ppvPattern = NULL;

	//	round to the nearest reservation granularity

	size_t cbPatternT;
	cbPatternT =	(	( cbPattern + OSMemoryPageReserveGranularity() - 1 ) / 
						OSMemoryPageReserveGranularity() ) * 
					OSMemoryPageReserveGranularity();

	size_t cbSizeT;
	cbSizeT = 		(	( cbSize + OSMemoryPageReserveGranularity() - 1 ) /
						OSMemoryPageReserveGranularity() ) *
					OSMemoryPageReserveGranularity();

	Assert( cbSizeT >= cbPatternT );
	Assert( 0 == cbSizeT % cbPatternT );

	//	allocate space to describe the mappings (for addresses and protection)

	size_t	cMap		= cbSizeT / cbPatternT;
	void	**rgpvMap	= (void**)( _alloca( cMap * ( sizeof( void* ) + sizeof( BOOL ) ) ) );
	BOOL	*rgfProtect	= (BOOL*)( (BYTE*)rgpvMap + cMap * sizeof( void* ) );

	Assert( cMap > 0 );

	while ( fTrue )
		{

		//	find a suitable address range

		BYTE* rgb;
		if ( !( rgb = (BYTE*)PvOSMemoryPageReserve__( size_t( cbSizeT ), NULL ) ) )
			{
			return errOutOfAddressSpace;
			}
		OSMemoryPageFree( rgb );

		//	setup each mapping

		size_t iMap;
		for ( iMap = 0; iMap < cMap; iMap++ )
			{
			rgpvMap[iMap]		= rgb + ( iMap * cbPatternT );
			rgfProtect[iMap]	= fFalse;
			}

		//	make the mapping

		err = ErrOSMMReserve__( cbPatternT, cMap, rgpvMap, rgfProtect );
		if ( errSuccess == err )
			{
			break;
			}
		else if ( errOutOfBackingStore == err )
			{
			return err;
			}
		else
			{
			Assert( errMappingFailed == err );
			}
		}

	//	we should have a valid pattern

	Assert( rgpvMap[0] );
	Assert( m_pvMap == rgpvMap[0] );
	Assert( m_cbMap == cbPatternT );
	Assert( m_cMap == cMap );

#ifdef ENABLE_VIRTUAL_QUERY
	Assert( m_cbReserve == cbSizeT );
#endif // ENABLE_VIRTUAL_QUERY
	Assert( m_cbCommit == 0 );

	//  commit the mapping

	if ( !FOSMMCommit( 0, cbPatternT ) )
		{

		//	free each mapping

		size_t iMap;
		for ( iMap = 0; iMap < cMap; iMap++ )
			{
			Assert( (BYTE*)m_pvMap + ( iMap * cbPatternT ) == rgpvMap[iMap] );
			OSMMFree( rgpvMap[iMap] );
			}

		return errOutOfMemory;
		}

#ifdef ENABLE_VIRTUAL_QUERY
	Assert( m_cbCommit == cbSizeT );
#endif // ENABLE_VIRTUAL_QUERY

	//	return the result

	*ppvPattern = rgpvMap[0];

	return errSuccess;
	}


//	free the series of mappings used to make a pattern

VOID COSMemoryMap::OSMMPatternFree()
	{

	//	verify our state (should have a mapping setup)

	if ( m_pvMap )
		{
		Assert( m_cbMap > 0 );
		Assert( m_cMap > 0 );

		//	free each mapping

		size_t iMap;
		for ( iMap = 0; iMap < m_cMap; iMap++ )
			{
			OSMMFree( (BYTE*)m_pvMap + ( iMap * m_cbMap ) );
			}
		}

#ifdef ENABLE_VIRTUAL_QUERY
	//	we should no longer have any mapping info

	Assert( !m_pvMap );
	Assert( 0 == m_cbMap );
	Assert( 0 == m_cMap );
#endif // ENABLE_VIRTUAL_QUERY
	}



#ifdef MEM_CHECK

//	dump stray COSMemoryMap objects

VOID COSMemoryMap::OSMMDumpAlloc( const _TCHAR* szFile )
	{
	HANDLE hFile = CreateFile(	szFile,
								GENERIC_WRITE,
								0,
								NULL,
								OPEN_ALWAYS,
								FILE_ATTRIBUTE_NORMAL,
								NULL );
		
	if ( INVALID_HANDLE_VALUE == hFile )
		{
		return;
		}

	_TCHAR			szMessage[512];
	DWORD			cchActual;
	COSMemoryMap	*posmm;

	(void)SetFilePointer( hFile, 0, NULL, FILE_END );

	_stprintf( szMessage, _T( "\r\nCOSMemoryMap Leak Statistics\r\n\r\n" ) );
	(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

	_stprintf( szMessage, _T( "cbReservePage = %I64d pages (0x%016I64x bytes)\r\n" ), cbReservePage / OSMemoryPageCommitGranularity(), cbReservePage );
	(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
	_stprintf( szMessage, _T( "cbCommitPage  = %I64d pages (0x%016I64x bytes)\r\n\r\n" ), cbCommitPage / OSMemoryPageCommitGranularity(), cbCommitPage );
	(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

	_stprintf( szMessage, _T( "First Mapping       Size                Count  Reserved            Committed           File(Line)\r\n" ) );
	(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
	_stprintf( szMessage, _T( "==================  ==================  =====  ==================  ==================  ==========================================\r\n" ) );
	(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

	EnterCriticalSection( &g_csosmm );

	//	dump each COSMemoryMap object in the list

	posmm = g_posmm;
	while ( posmm )
		{
		_stprintf(	szMessage, 
					_T( "0x%016I64X  0x%016I64X  %-5d  0x%016I64X  0x%016I64X  %s(%d)\r\n" ),
					QWORD( posmm->m_pvMap ),
					QWORD( posmm->m_cbMap ),
					posmm->m_cMap,
					QWORD( posmm->m_cbReserve ),
					QWORD( posmm->m_cbCommit ),
					posmm->m_szFile,
					posmm->m_lLine );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );

		posmm = posmm->m_posmmNext;
		}
	if ( !g_posmm )
		{
		_stprintf( szMessage, _T( "<< no mappings >>\r\n" ) );
		(void)WriteFile( hFile, szMessage, lstrlen( szMessage ), &cchActual, NULL );
		}

	LeaveCriticalSection( &g_csosmm );

	CloseHandle( hFile );
	}

#endif	//	MEM_CHECK





//	checks whether pointer pv points to allocated memory ( not necessarly begin )
//	with at least cbSize bytes

#ifdef MEM_CHECK
void OSMemoryCheckPointer( void * const pv, const size_t cb )
	{
	if ( g_fMemCheck )
		{
		Assert( pv );
		Assert( (BYTE *)pv < (BYTE *)pv + cb );

		//  find the specified allocation in the hash table

		int imai;
		MAI *pmai;

		for ( imai = 0; imai < cmai; imai++ )
			{
			pmai = rgpmai[imai];
			while ( pmai && ( pmai->pv > pv || (BYTE *)pmai->pv + pmai->cb < (BYTE *)pv ) )
				{
				pmai = pmai->pmaiNext;
				}
			if ( pmai != NULL ) 
				{
				if ( (BYTE *)pmai->pv + pmai->cb < (BYTE *)pv + cb )
					{
					Assert( "Memory chunk is smaller than expected." );
					}
				break;
				}
			}
		
		if ( pmai == NULL )
			{
			Assert( "Pointer does not point to allocated memory or memory chunk is smaller than expected." );
			}
		
		}
	}
#endif // MEM_CHECK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\edbg.cxx ===
#include "osstd.hxx"


#include <imagehlp.h>
#include <wdbgexts.h>


#include "std.hxx"
#include "_bf.hxx"
#include "_osslv.hxx"
#include "_tls.hxx"


#ifdef DEBUGGER_EXTENSION

#define EDBGAddGlobal( x )		{ #x, (VOID *)&x }

//	forward references
extern SIZE_T		cEDBGGlobals;
extern DWORD		cAllocHeap;
extern DWORD		cFreeHeap;
extern DWORD		cbAllocHeap;
extern DWORD_PTR	cbReservePage;
extern DWORD_PTR	cbCommitPage;
extern CRES *		g_pcresVERPool;

EDBGGLOBALVAR		rgEDBGGlobals[]	=
						{
						EDBGAddGlobal( cEDBGGlobals ),		//	must be first entry
						EDBGAddGlobal( g_cbPage ),
						EDBGAddGlobal( rgfmp ),
						EDBGAddGlobal( ifmpMax ),
						EDBGAddGlobal( g_rgpinst ),
						EDBGAddGlobal( ipinstMax ),
						EDBGAddGlobal( cbfChunk ),
						EDBGAddGlobal( rgpbfChunk ),
						EDBGAddGlobal( cbfCache ),
						EDBGAddGlobal( cpgChunk ),
						EDBGAddGlobal( rgpvChunkRW ),
						EDBGAddGlobal( rgpvChunkRO ),
						EDBGAddGlobal( cAllocHeap ),
						EDBGAddGlobal( cFreeHeap ),
						EDBGAddGlobal( cbAllocHeap ),
						EDBGAddGlobal( cbReservePage ),
						EDBGAddGlobal( cbCommitPage ),
						EDBGAddGlobal( CPAGE::cbHintCache ),
						EDBGAddGlobal( CPAGE::maskHintCache ),
						EDBGAddGlobal( g_pcresVERPool )
						};

SIZE_T				cEDBGGlobals			= sizeof(rgEDBGGlobals) / sizeof(EDBGGLOBALVAR);

//	debugger's copy of the globals table
EDBGGLOBALVAR *		rgEDBGGlobalsDebugger	= NULL;


//  ****************************************************************
//  STRUCTURES AND CLASSES
//  ****************************************************************


//  ================================================================
typedef VOID (*EDBGFUNC)(
//  ================================================================
	const HANDLE hCurrentProcess,
	const HANDLE hCurrentThread,
	const DWORD dwCurrentPc,
    const PWINDBG_EXTENSION_APIS lpExtensionApis,
    const INT argc,
    const CHAR * const argv[] 
    );


//  ================================================================
class CPRINTFWDBG : public CPRINTF
//  ================================================================
	{
	public:
		VOID __cdecl operator()( const char * szFormat, ... ) const;
		static CPRINTF * PcprintfInstance();
		
		~CPRINTFWDBG() {}

	private:
		CPRINTFWDBG() {}
		static CHAR szBuf[1024];	//  WARNING: not multi-threaded safe!
	};


//  ================================================================
class CDUMP
//  ================================================================
	{
	public:
		CDUMP() {}
		virtual ~CDUMP() {}
		
		virtual VOID Dump( HANDLE, HANDLE, DWORD, PWINDBG_EXTENSION_APIS, INT, const CHAR * const [] ) = 0;
	};
	

//  ================================================================
template< class _STRUCT>
class CDUMPA : public CDUMP
//  ================================================================
	{
	public:		
		VOID Dump(
			    HANDLE hCurrentProcess,
			    HANDLE hCurrentThread,
			    DWORD dwCurrentPc,
			    PWINDBG_EXTENSION_APIS lpExtensionApis,
			    INT argc,
			    const CHAR * const argv[] );
		static CDUMPA	instance;
	};


//  ================================================================
struct EDBGFUNCMAP 
//  ================================================================
	{
	const char * 	szCommand;
	EDBGFUNC		function;
	const char * 	szHelp;
	};


//  ================================================================
struct CDUMPMAP 
//  ================================================================
	{
	const char * 	szCommand;
	CDUMP 	   *	pcdump;
	const char * 	szHelp;
	};



//  ****************************************************************
//  PROTOTYPES
//  ****************************************************************


#define VariableNameToString( var )	#var		

#define DUMPA(_struct)	{ #_struct, &(CDUMPA<_struct>::instance), #_struct " <address>" }

#define DEBUG_EXT( name )					\
	LOCAL VOID name(						\
		const HANDLE hCurrentProcess,		\
		const HANDLE hCurrentThread,		\
		const DWORD dwCurrentPc,			\
	    const PWINDBG_EXTENSION_APIS lpExtensionApis,	\
	    const INT argc,						\
	    const CHAR * const argv[]  )

DEBUG_EXT( EDBGCacheFind );
DEBUG_EXT( EDBGCacheMap );
DEBUG_EXT( EDBGChecksum );
DEBUG_EXT( EDBGDebug );
DEBUG_EXT( EDBGDump );
DEBUG_EXT( EDBGDumpCacheMap );
DEBUG_EXT( EDBGDumpLR );
DEBUG_EXT( EDBGVerStore );
DEBUG_EXT( EDBGMemory );
DEBUG_EXT( EDBGErr );
DEBUG_EXT( EDBGFindRes );
DEBUG_EXT( EDBGHash );
DEBUG_EXT( EDBGHelp );
DEBUG_EXT( EDBGHelpDump );
DEBUG_EXT( EDBGLoad );
DEBUG_EXT( EDBGSync );
DEBUG_EXT( EDBGTest );
DEBUG_EXT( EDBGGlobals );
DEBUG_EXT( EDBGTid2PIB );
DEBUG_EXT( EDBGUnload );
DEBUG_EXT( EDBGVersion );
DEBUG_EXT( EDBGDumpAllFMPs );
DEBUG_EXT( EDBGDumpAllINSTs );
DEBUG_EXT( EDBGSympath );



extern VOID DBUTLDumpRec( const VOID * const pv, const INT cb, CPRINTF * pcprintf, const INT cbWidth );
extern VOID JetErrorToString( JET_ERR err, const char **szError, const char **szErrorText );
extern UINT g_wAssertAction;



//  ****************************************************************
//  GLOBALS
//  ****************************************************************



LOCAL WINDBG_EXTENSION_APIS ExtensionApis;

LOCAL BOOL fDebugMode 	= fFalse;	//	enable exceptions and assert dialogs
LOCAL BOOL fInit 		= fFalse;	//	debugger extensions have geen initialized

LOCAL HINSTANCE hLibrary = NULL;	//	if we load outselves

CHAR CPRINTFWDBG::szBuf[1024];

template< class _STRUCT>
CDUMPA<_STRUCT> CDUMPA<_STRUCT>::instance;


//  ================================================================
LOCAL EDBGFUNCMAP rgfuncmap[] = {
//  ================================================================

	{
		"HELP",			EDBGHelp,
		"HELP                               - Print this help message"
	},
	{
		"CACHEFIND",	EDBGCacheFind,
		"CACHEFIND <ifmp> <pgno>            - Finds the BF containing the given ifmp:pgno"
	},
	{
		"CACHEMAP",		EDBGCacheMap,
		"CACHEMAP <address>                 - Performs pv => pbf or pbf => pv mapping"
	},
	{
		"CHECKSUM",		EDBGChecksum,
		"CHECKSUM <address> [<length>]      - Checksum a <g_cbPage> range of memory"
	},
	{ 
		"DEBUG",		EDBGDebug, 
		"DEBUG                              - Toggle debug mode"
	},
	{
		"DUMP",			EDBGDump,
		"DUMP <class> <address>             - Dump an ESE structure at the given address"
	},
	{
		"DUMPCACHEMAP",	EDBGDumpCacheMap,
		"DUMPCACHEMAP                       - Dump the database cache memory map"
	},
	{ 
		"DUMPFMPS",		EDBGDumpAllFMPs, 
		"DUMPFMPS [<rgfmp> <ifmpMax>] [*]   - Dump all used FMPs ([*] - also dump unused FMPs)"
	},
	{ 
		"DUMPINSTS",	EDBGDumpAllINSTs, 
		"DUMPINSTS [<g_rgpinst>]            - Dump all instances"
	},
	{
		"DUMPLR",		EDBGDumpLR,
		"DUMPLR                             - Dump a log record"
	},
	{
		"GLOBALS",		EDBGGlobals,
		"GLOBALS [<rgEDBGGlobals>]          - Load debuggee's table of globals (use when symbol mapping does not work)."
	},
	{
		"ERR",			EDBGErr,
		"ERR <error>                        - Turn an error number into a string"
	},
	{
		"FINDRES",		EDBGFindRes,
		"FINDRES <cres> <address> <length>  - Find pointers to memory in the CRES in the address range"
	},
	{
		"HASH",			EDBGHash,
		"HASH <ifmp> <pgnoFDP> <prefix-address> <prefix-length> <suffix-address> <suffix-length> <data> <data-length>\n\t"
		"                                   - Generate the version store hash for a given key"
	},
	{
		"LOAD",			EDBGLoad,
		"LOAD                               - Load the DLL"
	},
	{
		"MEMORY",		EDBGMemory,
		"MEMORY                             - Dump memory usage information"
	},
	{
		"SYNC",			EDBGSync,
		"SYNC ...                           - Synchronization Library Debugger Extensions"
	},
	{
		"SYMPATH", 		EDBGSympath,
		"SYMPATH [<pathname>]               - Set symbol path"						
	},
	{
		"TEST",			EDBGTest,
		"TEST                               - Test function"
	},
	{
		"TID2PIB",		EDBGTid2PIB,
		"TID2PIB <tid> [<g_rgpinst>]        - Find the PIB for a given TID"
	},
	{
		"UNLOAD",		EDBGUnload,
		"UNLOAD                             - Unload the DLL"
	},
	{ 
		"VERSION",		EDBGVersion, 
		"VERSION                            - Version info for ESE.DLL"
	},
	{
		"VERSTORE",		EDBGVerStore,
		"VERSTORE <instance id>             - Dump version store usage information for the specified instance"
	},
	};

const int cfuncmap = sizeof( rgfuncmap ) / sizeof( EDBGFUNCMAP );



//  ================================================================
LOCAL CDUMPMAP rgcdumpmap[] = {
//  ================================================================

	DUMPA( BF ),
	DUMPA( RCE ),
	DUMPA( PIB ),
	DUMPA( FUCB ),
	DUMPA( CSR ),
	DUMPA( REC ),
	DUMPA( FCB ),
	DUMPA( IDB ),
	DUMPA( TDB ),
	DUMPA( CRES ),
	DUMPA( INST ),
	DUMPA( FMP ),
	DUMPA( LOG ),
	DUMPA( VER ),
	{ 
		"MEMPOOL", 	&(CDUMPA<MEMPOOL>::instance), 
 		"MEMPOOL <address> [<itag>|*]       - <itag>=specified tag only, *=all tags"
	},
	DUMPA( SPLIT ),
	DUMPA( SPLITPATH ),
	DUMPA( MERGE ),
	DUMPA( MERGEPATH ),
	DUMPA( DBFILEHDR ),
	DUMPA( COSFile ),
	DUMPA( COSFileFind ),
	DUMPA( COSFileLayout ),
	DUMPA( COSFileSystem ),
	{ 
		"PAGE", 	&(CDUMPA<CPAGE>::instance), 
		"PAGE [a|h|t|*|2|4|8] <address>     - a=alloc map, h=header, t=tags, *=all, 2/4/8=pagesize"
	},
	DUMPA( CSLVBackingFile ),
	DUMPA( CSLVFileInfo ),
	DUMPA( CSLVFileTable ),
	DUMPA( CSLVInfo ),
	DUMPA( _SLVROOT ),
	};

const int ccdumpmap = sizeof( rgcdumpmap ) / sizeof( CDUMPMAP );



//  ****************************************************************
//  FUNCTIONS
//  ****************************************************************



//  ================================================================
inline VOID __cdecl CPRINTFWDBG::operator()( const char * szFormat, ... ) const
//  ================================================================
	{
	va_list arg_ptr;
	va_start( arg_ptr, szFormat );
	_vsnprintf( szBuf, sizeof( szBuf ), szFormat, arg_ptr );
	va_end( arg_ptr );
	szBuf[ sizeof( szBuf ) - 1 ] = 0;
	(ExtensionApis.lpOutputRoutine)( "%s", szBuf );
	}


//  ================================================================
CPRINTF * CPRINTFWDBG::PcprintfInstance()
//  ================================================================
	{
	static CPRINTFWDBG CPrintfWdbg;
	return &CPrintfWdbg;
	}


//  ================================================================
LOCAL INT SzToRgsz( CHAR * rgsz[], CHAR * const sz )
//  ================================================================
	{
	INT irgsz = 0;
	CHAR * szT = sz;
	while( NULL != ( rgsz[irgsz] = strtok( szT, " \t\n" ) ) )
		{
		++irgsz;
		szT = NULL;
		}
	return irgsz;
	}


//  ================================================================
LOCAL BOOL FArgumentMatch( const CHAR * const sz, const CHAR * const szCommand )
//  ================================================================
	{
	const BOOL fMatch = ( ( strlen( sz ) == strlen( szCommand ) )
			&& !( _strnicmp( sz, szCommand, strlen( szCommand ) ) ) );
	return fMatch;
	}


namespace OSSYM {

#include <imagehlp.h>
#include <psapi.h>


typedef DWORD IMAGEAPI WINAPI PFNUnDecorateSymbolName( PCSTR, PSTR, DWORD, DWORD );
typedef DWORD IMAGEAPI PFNSymSetOptions( DWORD );
typedef BOOL IMAGEAPI PFNSymCleanup( HANDLE );
typedef BOOL IMAGEAPI PFNSymInitialize( HANDLE, PSTR, BOOL );
typedef BOOL IMAGEAPI PFNSymGetSymFromAddr( HANDLE, DWORD_PTR, DWORD_PTR*, PIMAGEHLP_SYMBOL );
typedef BOOL IMAGEAPI PFNSymGetSymFromName( HANDLE, PSTR, PIMAGEHLP_SYMBOL );
typedef BOOL IMAGEAPI PFNSymGetSearchPath( HANDLE, PSTR, DWORD );
typedef BOOL IMAGEAPI PFNSymSetSearchPath( HANDLE, PSTR );
typedef BOOL IMAGEAPI PFNSymGetModuleInfo( HANDLE, DWORD_PTR, PIMAGEHLP_MODULE );
typedef DWORD IMAGEAPI PFNSymLoadModule( HANDLE, HANDLE, PSTR, PSTR, DWORD_PTR, DWORD );
typedef DWORD IMAGEAPI PFNSymUnloadModule( HANDLE, DWORD_PTR );
typedef PIMAGE_NT_HEADERS IMAGEAPI PFNImageNtHeader( PVOID );

PFNUnDecorateSymbolName*	pfnUnDecorateSymbolName;
PFNSymSetOptions*			pfnSymSetOptions;
PFNSymCleanup*				pfnSymCleanup;
PFNSymInitialize*			pfnSymInitialize;
PFNSymGetSymFromAddr*		pfnSymGetSymFromAddr;
PFNSymGetSymFromName*		pfnSymGetSymFromName;
PFNSymGetSearchPath*		pfnSymGetSearchPath;
PFNSymSetSearchPath*		pfnSymSetSearchPath;
PFNSymGetModuleInfo*		pfnSymGetModuleInfo;
PFNSymLoadModule*			pfnSymLoadModule;
PFNSymUnloadModule*			pfnSymUnloadModule;
PFNImageNtHeader*			pfnImageNtHeader;

HMODULE hmodImagehlp;

typedef BOOL WINAPI PFNEnumProcessModules( HANDLE, HMODULE*, DWORD, LPDWORD );
typedef DWORD WINAPI PFNGetModuleFileNameExA( HANDLE, HMODULE, LPSTR, DWORD );
typedef DWORD WINAPI PFNGetModuleBaseNameA( HANDLE, HMODULE, LPSTR, DWORD );
typedef BOOL WINAPI PFNGetModuleInformation( HANDLE, HMODULE, LPMODULEINFO, DWORD );

PFNEnumProcessModules*		pfnEnumProcessModules;
PFNGetModuleFileNameExA*	pfnGetModuleFileNameExA;
PFNGetModuleBaseNameA*		pfnGetModuleBaseNameA;
PFNGetModuleInformation*	pfnGetModuleInformation;

HMODULE hmodPsapi;

LOCAL const DWORD symopt =	SYMOPT_CASE_INSENSITIVE |
							SYMOPT_UNDNAME |
							SYMOPT_OMAP_FIND_NEAREST |
							SYMOPT_DEFERRED_LOADS;
LOCAL CHAR szParentImageName[_MAX_FNAME];
LOCAL HANDLE ghDbgProcess;


//  ================================================================
LOCAL BOOL SymLoadAllModules( HANDLE hProcess, BOOL fReload = fFalse )
//  ================================================================
	{
	HMODULE* rghmodDebuggee = NULL;

	//  fetch all modules in the debuggee process and manually load their symbols.
	//  we do this because telling imagehlp to invade the debuggee process doesn't
	//  work when we are already running in the context of a debugger

	DWORD cbNeeded;
	if ( !pfnEnumProcessModules( hProcess, NULL, 0, &cbNeeded ) )
		{
		goto HandleError;
		}

	DWORD cbActual;
	do	{
		cbActual = cbNeeded;
		rghmodDebuggee = (HMODULE*)LocalAlloc( 0, cbActual );

		if ( !pfnEnumProcessModules( hProcess, rghmodDebuggee, cbActual, &cbNeeded ) )
			{
			goto HandleError;
			}
		}
	while ( cbNeeded > cbActual );

	SIZE_T ihmod;
	SIZE_T ihmodLim;

	ihmodLim = cbNeeded / sizeof( HMODULE );
	for ( ihmod = 0; ihmod < ihmodLim; ihmod++ )
		{
		char szModuleImageName[ _MAX_PATH ];
		if ( !pfnGetModuleFileNameExA( hProcess, rghmodDebuggee[ ihmod ], szModuleImageName, _MAX_PATH ) )
			{
			goto HandleError;
			}

		char szModuleBaseName[ _MAX_FNAME ];
		if ( !pfnGetModuleBaseNameA( hProcess, rghmodDebuggee[ ihmod ], szModuleBaseName, _MAX_FNAME ) )
			{
			goto HandleError;
			}

		MODULEINFO mi;
		if ( !pfnGetModuleInformation( hProcess, rghmodDebuggee[ ihmod ], &mi, sizeof( mi ) ) )
			{
			goto HandleError;
			}

		if ( fReload )
			{
			pfnSymUnloadModule( hProcess, DWORD_PTR( mi.lpBaseOfDll ) );
			}
			
		if ( !pfnSymLoadModule(	hProcess,
								NULL,
								szModuleImageName,
								szModuleBaseName,
								DWORD_PTR( mi.lpBaseOfDll ),
								mi.SizeOfImage ) )
			{
			goto HandleError;
			}

		IMAGEHLP_MODULE im;
		im.SizeOfStruct = sizeof( IMAGEHLP_MODULE );

		if ( !pfnSymGetModuleInfo( hProcess, DWORD_PTR( mi.lpBaseOfDll ), &im ) )
			{
			goto HandleError;
			}
		}

	return fTrue;

HandleError:
	LocalFree( (void*)rghmodDebuggee );
	return fFalse;
	}

//  ================================================================
LOCAL BOOL SymInitializeEx(	HANDLE hProcess, HANDLE* phProcess )
//  ================================================================
	{
	//  init our out param

	*phProcess = NULL;

	//  duplicate the given debuggee process handle so that we have our own
	//  sandbox in imagehlp

	if ( !DuplicateHandle(	GetCurrentProcess(),
							hProcess,
							GetCurrentProcess(),
							phProcess,
							0,
							FALSE,
							DUPLICATE_SAME_ACCESS ) )
		{
		goto HandleError;
		}
	SetHandleInformation( *phProcess, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	//  init imagehlp for the debuggee process

	if ( !pfnSymInitialize( *phProcess, NULL, FALSE ) )
		{
		goto HandleError;
		}

	//  we're done

	return fTrue;

HandleError:
	if ( *phProcess )
		{
		SetHandleInformation( *phProcess, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( *phProcess );
		*phProcess = NULL;
		}
	return fFalse;
	}

//  ================================================================
LOCAL void SymTerm()
//  ================================================================
	{
	//  shut down imagehlp
	
	if ( pfnSymCleanup )
		{
		if ( ghDbgProcess )
			{
			pfnSymCleanup( ghDbgProcess );
			}
		pfnSymCleanup = NULL;
		}

	//  free psapi

	if ( hmodPsapi )
		{
		FreeLibrary( hmodPsapi );
		hmodPsapi = NULL;
		}

	//  free imagehlp

	if ( hmodImagehlp )
		{
		FreeLibrary( hmodImagehlp );
		hmodImagehlp = NULL;
		}

	//  close our process handle

	if ( ghDbgProcess )
		{
		SetHandleInformation( ghDbgProcess, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( ghDbgProcess );
		ghDbgProcess = NULL;
		}
	}

//  ================================================================
LOCAL BOOL FSymInit( HANDLE hProc )
//  ================================================================
	{
	HANDLE hThisProcess = NULL;
	
	//  reset all pointers
	
	ghDbgProcess	= NULL;
	hmodImagehlp	= NULL;
	pfnSymCleanup	= NULL;
	hmodPsapi		= NULL;

	//  load all calls in imagehlp
	
	if ( !( hmodImagehlp = LoadLibrary( "imagehlp.dll" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetSymFromAddr = (PFNSymGetSymFromAddr*)GetProcAddress( hmodImagehlp, "SymGetSymFromAddr" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetSymFromName = (PFNSymGetSymFromName*)GetProcAddress( hmodImagehlp, "SymGetSymFromName" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymInitialize = (PFNSymInitialize*)GetProcAddress( hmodImagehlp, "SymInitialize" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymCleanup = (PFNSymCleanup*)GetProcAddress( hmodImagehlp, "SymCleanup" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymSetOptions = (PFNSymSetOptions*)GetProcAddress( hmodImagehlp, "SymSetOptions" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnUnDecorateSymbolName = (PFNUnDecorateSymbolName*)GetProcAddress( hmodImagehlp, "UnDecorateSymbolName" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetSearchPath = (PFNSymGetSearchPath*)GetProcAddress( hmodImagehlp, "SymGetSearchPath" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymSetSearchPath = (PFNSymSetSearchPath*)GetProcAddress( hmodImagehlp, "SymSetSearchPath" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetModuleInfo = (PFNSymGetModuleInfo*)GetProcAddress( hmodImagehlp, "SymGetModuleInfo" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymLoadModule = (PFNSymLoadModule*)GetProcAddress( hmodImagehlp, "SymLoadModule" ) ) )
		{
		goto HandleError;
		}

	if ( !( pfnSymUnloadModule = (PFNSymUnloadModule*)GetProcAddress( hmodImagehlp, "SymUnloadModule" ) ) )
		{
		goto HandleError;
		}
	
	if ( !( pfnImageNtHeader = (PFNImageNtHeader*)GetProcAddress( hmodImagehlp, "ImageNtHeader" ) ) )
		{
		goto HandleError;
		}

	//  load all calls in psapi

	if ( !( hmodPsapi = LoadLibrary( "psapi.dll" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnEnumProcessModules = (PFNEnumProcessModules*)GetProcAddress( hmodPsapi, "EnumProcessModules" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnGetModuleFileNameExA = (PFNGetModuleFileNameExA*)GetProcAddress( hmodPsapi, "GetModuleFileNameExA" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnGetModuleBaseNameA = (PFNGetModuleBaseNameA*)GetProcAddress( hmodPsapi, "GetModuleBaseNameA" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnGetModuleInformation = (PFNGetModuleInformation*)GetProcAddress( hmodPsapi, "GetModuleInformation" ) ) )
		{
		goto HandleError;
		}

	//  get the name of our parent image in THIS process.  we need this name so
	//  that we can prefix symbols with the default module name and so that we
	//  can add the image path to the symbol path

	MEMORY_BASIC_INFORMATION mbi;
	if ( !VirtualQueryEx( GetCurrentProcess(), FSymInit, &mbi, sizeof( mbi ) ) )
		{
		goto HandleError;
		}
	char szImage[_MAX_PATH];
	if ( !GetModuleFileNameA( HINSTANCE( mbi.AllocationBase ), szImage, sizeof( szImage ) ) )
		{
		goto HandleError;
		}
	_splitpath( (const _TCHAR *)szImage, NULL, NULL, szParentImageName, NULL );

	//  init imagehlp for the debuggee process

	if ( !SymInitializeEx( hProc, &ghDbgProcess ) )
		{
		goto HandleError;
		}

	//  set our symbol path to include the path of this image and the process
	//  executable

	char szOldPath[ 4 * _MAX_PATH ];
	if ( pfnSymGetSearchPath( ghDbgProcess, szOldPath, sizeof( szOldPath ) ) )
		{
		char szNewPath[ 6 * _MAX_PATH ];
		char szDrive[ _MAX_DRIVE ];
		char szDir[ _MAX_DIR ];
		char szPath[ _MAX_PATH ];

		szNewPath[ 0 ] = 0;
		
		strcat( szNewPath, szOldPath );
		strcat( szNewPath, ";" );
		
		HMODULE hImage = GetModuleHandle( szParentImageName );
		GetModuleFileName( hImage, szPath, _MAX_PATH );
		_splitpath( szPath, szDrive, szDir, NULL, NULL );
		_makepath( szPath, szDrive, szDir, NULL, NULL );
		strcat( szNewPath, szPath );
		strcat( szNewPath, ";" );
		
		GetModuleFileName( NULL, szPath, _MAX_PATH );
		_splitpath( szPath, szDrive, szDir, NULL, NULL );
		_makepath( szPath, szDrive, szDir, NULL, NULL );
		strcat( szNewPath, szPath );
		
		pfnSymSetSearchPath( ghDbgProcess, szNewPath );
		}

	//  set our default symbol options
	
	pfnSymSetOptions( symopt );

	//  prepare symbols for the debuggee process

	if ( !SymLoadAllModules( ghDbgProcess ) )
		{
		goto HandleError;
		}

	return fTrue;

HandleError:
	if ( hThisProcess )
		{
		SetHandleInformation( hThisProcess, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hThisProcess );
		}
	SymTerm();
	return fFalse;
	}

//  ================================================================
LOCAL BOOL FUlFromSz( const char* const sz, ULONG* const pul, const int base = 16 )
//  ================================================================
	{
	if( sz && *sz )
		{
		char* pchEnd;
		*pul = strtoul( sz, &pchEnd, base );
		return !( *pchEnd );
		}
	return fFalse;
	}

//  ================================================================
template< class T >
LOCAL BOOL FAddressFromSz( const char* const sz, T** const ppt )
//  ================================================================
	{
	if ( sz && *sz )
		{
		int		n;
		QWORD	first;
		DWORD	second;
		int		cchRead;
		BOOL	f;

		n = sscanf( sz, "%I64x%n%*[` ]%8lx%n", &first, &cchRead, &second, &cchRead );

		switch ( n )
			{
			case 2:
				*ppt = (T*)( ( first << 32 ) | second );
				f = fTrue;
				break;

			case 1:
				*ppt = (T*)( first );
				f = fTrue;
				break;

			default:
				f = fFalse;
				break;
			};
		if ( cchRead != int( strlen( sz ) ) )
			{
			f = fFalse;
			}

		return f;
		}
	return fFalse;
	}

//  ================================================================
template< class T >
LOCAL BOOL FHintAddressFromGlobal( const char* const szGlobal, T** const ppt )
//  ================================================================
	{
	if ( NULL != rgEDBGGlobalsDebugger )
		{
		//	search in the table for the particular global name
		for ( SIZE_T i = 1; i < (SIZE_T)rgEDBGGlobalsDebugger[0].pvAddress; i++ )
			{
			if ( 0 == _stricmp( rgEDBGGlobalsDebugger[i].szName, szGlobal ) )
				{
				*ppt = (T*)rgEDBGGlobalsDebugger[i].pvAddress;
				return fTrue;
				}
			}
		}
	return fFalse;
	}

//  ================================================================
template< class T >
LOCAL BOOL FAddressFromGlobal( const char* const szGlobal, T** const ppt )
//  ================================================================
	{
	if ( FHintAddressFromGlobal( szGlobal, ppt ) )
		{
		return fTrue;
		}

	//  add the module prefix to the global name to form the symbol
	
	SIZE_T	cchSymbol	= strlen( szParentImageName ) + 1 + strlen( szGlobal );
	char*	szSymbol	= (char*)LocalAlloc( 0, ( cchSymbol + 1 ) * sizeof( char ) );
	if ( !szSymbol )
		{
		return fFalse;
		}
	szSymbol[ 0 ] = 0;
	if ( !strchr( szGlobal, '!' ) )
		{
		strcat( szSymbol, szParentImageName );
		strcat( szSymbol, "!" );
		}
	strcat( szSymbol, szGlobal );

	//  try forever until we manage to retrieve the entire undecorated symbol
	//  and address corresponding to this symbol

	SIZE_T cbBuf = 1024;
	BYTE* rgbBuf = (BYTE*)LocalAlloc( 0, cbBuf );
	if ( !rgbBuf )
		{
		LocalFree( (void*)szSymbol );
		return fFalse;
		}
		

	IMAGEHLP_SYMBOL* pis;
	do	{
		pis							= (IMAGEHLP_SYMBOL*)rgbBuf;
		pis->SizeOfStruct			= sizeof( IMAGEHLP_SYMBOL );
		pis->MaxNameLength			= DWORD( ( cbBuf - sizeof( IMAGEHLP_SYMBOL ) ) / sizeof( char ) );

		DWORD	symoptOld	= pfnSymSetOptions( symopt );
		BOOL	fSuccess	= pfnSymGetSymFromName( ghDbgProcess, PSTR( szSymbol ), pis );
		DWORD	symoptNew	= pfnSymSetOptions( symoptOld );
		
		if ( !fSuccess )
			{	
			LocalFree( (void*)szSymbol );
			LocalFree( (void*)rgbBuf );
			return fFalse;
			}

		if ( strlen( pis->Name ) == cbBuf - 1 )
			{
			LocalFree( (void*)rgbBuf );
			cbBuf *= 2;
			if ( !( rgbBuf = (BYTE*)LocalAlloc( 0, cbBuf ) ) )
				{
				LocalFree( (void*)szSymbol );
				return fFalse;
				}
			}
		}
	while ( strlen( pis->Name ) == cbBuf - 1 );

	//  validate the symbols for the image containing this address

	IMAGEHLP_MODULE		im	= { sizeof( IMAGEHLP_MODULE ) };
	IMAGE_NT_HEADERS*	pnh;
	
	if (	!pfnSymGetModuleInfo( ghDbgProcess, pis->Address, &im ) ||
			!( pnh = pfnImageNtHeader( (void*)im.BaseOfImage ) ) ||
			pnh->FileHeader.TimeDateStamp != im.TimeDateStamp ||
			pnh->FileHeader.SizeOfOptionalHeader >= IMAGE_SIZEOF_NT_OPTIONAL_HEADER &&
			pnh->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC &&
			pnh->OptionalHeader.CheckSum != im.CheckSum &&
			(	pnh->FileHeader.TimeDateStamp != im.TimeDateStamp ||
				_stricmp( im.ModuleName, "kernel32" ) &&
				_stricmp( im.ModuleName, "ntdll" ) ) )
		{		
		LocalFree( (void*)szSymbol );
		LocalFree( (void*)rgbBuf );
		return fFalse;
		}

	//  return the address of the symbol

	*ppt = (T*)pis->Address;

	LocalFree( (void*)szSymbol );
	LocalFree( (void*)rgbBuf );
	return fTrue;
	}

//  ================================================================
template< class T >
LOCAL BOOL FGlobalFromAddress( T* const pt, char* szGlobal, const SIZE_T cchMax, DWORD_PTR* const pdwOffset = NULL )
//  ================================================================
	{
	//  validate the symbols for the image containing this address

	IMAGEHLP_MODULE		im	= { sizeof( IMAGEHLP_MODULE ) };
	IMAGE_NT_HEADERS*	pnh;
	
	if (	!pfnSymGetModuleInfo( ghDbgProcess, DWORD_PTR( pt ), &im ) ||
			!( pnh = pfnImageNtHeader( (void*)im.BaseOfImage ) ) ||
			pnh->FileHeader.TimeDateStamp != im.TimeDateStamp ||
			pnh->FileHeader.SizeOfOptionalHeader >= IMAGE_SIZEOF_NT_OPTIONAL_HEADER &&
			pnh->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC &&
			pnh->OptionalHeader.CheckSum != im.CheckSum &&
			(	pnh->FileHeader.TimeDateStamp != im.TimeDateStamp ||
				_stricmp( im.ModuleName, "kernel32" ) &&
				_stricmp( im.ModuleName, "ntdll" ) ) )
		{
		return fFalse;
		}

	//  try forever until we manage to retrieve the entire undecorated symbol
	//  corresponding to this address

	SIZE_T cbBuf = 1024;
	BYTE* rgbBuf = (BYTE*)LocalAlloc( 0, cbBuf );
	if ( !rgbBuf )
		{
		return fFalse;
		}

	IMAGEHLP_SYMBOL* pis;
	do	{
		DWORD_PTR	dwT;
		DWORD_PTR*	pdwDisp	= pdwOffset ? pdwOffset : &dwT;

		pis							= (IMAGEHLP_SYMBOL*)rgbBuf;
		pis->SizeOfStruct			= sizeof( IMAGEHLP_SYMBOL );
		pis->MaxNameLength			= DWORD( cbBuf - sizeof( IMAGEHLP_SYMBOL ) );

		DWORD	symoptOld	= pfnSymSetOptions( symopt );
		BOOL	fSuccess	= pfnSymGetSymFromAddr( ghDbgProcess, DWORD_PTR( pt ), pdwDisp, pis );
		DWORD	symoptNew	= pfnSymSetOptions( symoptOld );
		
		if ( !fSuccess )
			{
			LocalFree( (void*)rgbBuf );
			return fFalse;
			}

		if ( strlen( pis->Name ) == cbBuf - 1 )
			{
			LocalFree( (void*)rgbBuf );
			cbBuf *= 2;
			if ( !( rgbBuf = (BYTE*)LocalAlloc( 0, cbBuf ) ) )
				{
				return fFalse;
				}
			}
		}
	while ( strlen( pis->Name ) == cbBuf - 1 );

	//  undecorate the symbol (if possible).  if not, use the decorated symbol

	char* szSymbol = (char*)LocalAlloc( 0, cchMax );
	if ( !szSymbol )
		{
		LocalFree( (void*)rgbBuf );
		return fFalse;
		}

	if ( !pfnUnDecorateSymbolName( pis->Name, szSymbol, DWORD( cchMax ), UNDNAME_COMPLETE ) )
		{
		strncpy( szSymbol, pis->Name, size_t( cchMax ) );
		szGlobal[ cchMax - 1 ] = 0;
		}

	//  write the module!symbol into the user's buffer

	_snprintf( szGlobal, size_t( cchMax ), "%s!%s", im.ModuleName, szSymbol );

	LocalFree( (void*)szSymbol );
	LocalFree( (void*)rgbBuf );
	return fTrue;
	}

//  ================================================================
template< class T >
INLINE BOOL FReadVariable( T* const rgtDebuggee, T* const rgt, const SIZE_T ct = 1 )
//  ================================================================
	{
	return ExtensionApis.lpReadProcessMemoryRoutine(
				(ULONG_PTR)rgtDebuggee,
				(VOID *)rgt,
				DWORD( sizeof( T ) * ct ),
				NULL );
	}

//  ================================================================
template< class T >
LOCAL BOOL FFetchVariable( T* const rgtDebuggee, T** const prgt, SIZE_T ct = 1 )
//  ================================================================
	{
	//  allocate enough storage to retrieve the requested type array

	if ( !( *prgt = (T*)LocalAlloc( 0, sizeof( T ) * ct ) ) )
		{
		return fFalse;
		}

	//  retrieve the requested type array

	if ( !FReadVariable( rgtDebuggee, *prgt, ct ) )
		{
		LocalFree( (VOID *)*prgt );
		return fFalse;
		}

	return fTrue;
	}

//  ================================================================
template< class T >
LOCAL BOOL FReadGlobal( const CHAR * const szGlobal, T* const rgt, const SIZE_T ct = 1 )
//  ================================================================
	{
	//  get the address of the global in the debuggee and fetch it

	T*	rgtDebuggee;

	if ( FAddressFromGlobal( szGlobal, &rgtDebuggee )
		&& FReadVariable( rgtDebuggee, rgt, ct ) )
		{
		return fTrue;
		}
	else
		{
		dprintf( "Error: Could not read global variable '%s'.\n", szGlobal );
		return fFalse;
		}
	}

//  ================================================================
template< class T >
LOCAL BOOL FReadGlobalAndFetchVariable( const CHAR * const szGlobal, T** const prgt, const SIZE_T ct = 1 )
//  ================================================================
	{
	//  get the address of the global in the debuggee and fetch its contents

	T*	rgtDebuggee;

	if ( FReadGlobal( szGlobal, &rgtDebuggee ) )
		{
		if ( FFetchVariable( rgtDebuggee, prgt, ct ) )
			return fTrue;
		else
			dprintf( "Error: Could not fetch global variable '%s'.\n", szGlobal );
		}

	return fFalse;
	}

//  ================================================================
template< class T >
LOCAL BOOL FFetchGlobal( const CHAR * const szGlobal, T** const prgt, SIZE_T ct = 1 )
//  ================================================================
	{
	//  get the address of the global in the debuggee and fetch it

	T*	rgtDebuggee;

	if ( FAddressFromGlobal( szGlobal, &rgtDebuggee )
		&& FFetchVariable( rgtDebuggee, prgt, ct ) )
		{
		return fTrue;
		}
	else
		{
		dprintf( "Error: Could not fetch global variable '%s'.\n", szGlobal );
		return fFalse;
		}
	}

//  ================================================================
template< class T >
LOCAL BOOL FFetchSz( T* const szDebuggee, T** const psz )
//  ================================================================
	{
	//  scan for the null terminator in the debuggee starting at the given
	//  address to get the size of the string

	const SIZE_T	ctScan				= 256;
	const SIZE_T	cbScan				= ctScan * sizeof( T );
	BYTE			rgbScan[ cbScan ];
	T*				rgtScan				= (T*)rgbScan;  //  because T can be const
	SIZE_T			itScan				= -1;
	SIZE_T			itScanLim			= 0;

	do	{
		if ( !( ++itScan % ctScan ) )
			{
			ULONG	cbRead;
			ExtensionApis.lpReadProcessMemoryRoutine(
								ULONG_PTR( szDebuggee + itScan ),
								(void*)rgbScan,
								cbScan,
								&cbRead );
				
			itScanLim = itScan + cbRead / sizeof( T );
			}
		}
	while ( itScan < itScanLim && rgtScan[ itScan % ctScan ] );

	//  we found a null terminator

	if ( itScan < itScanLim )
		{
		//  fetch the string using the determined string length

		return FFetchVariable( szDebuggee, psz, itScan + 1 );
		}

	//  we did not find a null terminator

	else
		{
		//  fail the operation

		return fFalse;
		}
	}

//  ================================================================
template< class T >
LOCAL void Unfetch( T* const rgt )
//  ================================================================
	{
	LocalFree( (void*)rgt );
	}

template <class T>
class FetchWrap
	{
	private:
		T m_t;
		FetchWrap &operator=( FetchWrap const & ); // forbidden

	public:
		FetchWrap() { m_t = NULL; }
		~FetchWrap() { Unfetch(); }
		BOOL FVariable( T const rgtDebuggee, SIZE_T ct = 1 ) { Unfetch(); return FFetchVariable( rgtDebuggee, &m_t, ct ); }
		BOOL FGlobal( const char * const szGlobal, SIZE_T ct = 1 ) { Unfetch(); return FFetchGlobal( szGlobal, &m_t, ct ); }
		BOOL FSz( T const szDebuggee ) { Unfetch(); return FFetchSz( szDebuggee, &m_t ); }
		VOID Unfetch() { OSSYM::Unfetch( m_t ); }
		T Release() { T t = m_t; m_t = NULL; return t; }	//		dereference the pointer, so the user will take care to Unfetch

		operator T() { return m_t; }
		T operator->() { return m_t; }
	};

}  //  namespace OSSYM


#define FCall( x, szError ) { if ( !x ) { dprintf szError; goto HandleError; } }
#define FCallR( x, szError ) { if ( !x ) { dprintf szError; return; } }

using namespace OSSYM;


//  ================================================================
BOOL FDuplicateHandle( const HANDLE hSourceProcess, const HANDLE hSource, HANDLE * const phDest )
//  ================================================================
	{
	const HANDLE hDestinationProcess	= GetCurrentProcess();
	const DWORD dwDesiredAccess			= GENERIC_READ;
	const BOOL bInheritHandle			= FALSE;
	const DWORD dwOptions				= 0;
	
	const BOOL fSuccess = DuplicateHandle(
			hSourceProcess,
			hSource,
			hDestinationProcess, 
			phDest,
			dwDesiredAccess,
			bInheritHandle,
			dwOptions );

	if( !fSuccess )
		{
		dprintf( "DuplicateHandle failed with error %d\n", GetLastError() );
		}
	return fSuccess;
	}


//  ================================================================
const CHAR * SzEDBGHexDump( const VOID * const pv, const INT cb )
//  ================================================================
//
//	WARNING: not multi-threaded safe
//
	{
	static CHAR rgchBuf[1024];
	rgchBuf[0] = '\n';
	rgchBuf[1] = '\0';
	
	if( NULL == pv )
		{
		return rgchBuf;
		}

	DBUTLSprintHex(
		rgchBuf,
		(BYTE *)pv,
		cb,
		cb + 1,
		4,
		0,
		0 );
		
	return rgchBuf;
	}


//  ================================================================
DEBUG_EXT( EDBGVersion )
//  ================================================================
	{
	dprintf(	"%s version %d.%02d.%04d.%04d (%s)\n",
				SzUtilImageVersionName(),
				DwUtilImageVersionMajor(),
				DwUtilImageVersionMinor(),
				DwUtilImageBuildNumberMajor(),
				DwUtilImageBuildNumberMinor(),
				SzUtilImageBuildClass() );
	dprintf(	"\tDAE version		= 0x%x.%x\n",
				ulDAEVersion,
				ulDAEUpdate );
	dprintf(	"\tLog version		= %d.%04d.%02d\n",
				ulLGVersionMajor,
				ulLGVersionMinor,
				ulLGVersionUpdate );
	dprintf(	"\t     cbPage		= 0x%x, %d\n",
				g_cbPage,
				g_cbPage );
		
#ifdef MEM_CHECK
	if ( g_fMemCheck )
		{
		dprintf(	"\tMemory allocation tracking is Enabled\n" );
		}
	else
		{
		dprintf(	"\tMemory allocation tracking is Disabled\n" );
		}
#endif	//	MEM_CHECK
	}


//  ================================================================
DEBUG_EXT( EDBGDebug )
//  ================================================================
	{
	if( fDebugMode )
		{
		dprintf( "changing to non-debug mode\n" );
		fDebugMode = fFalse;
		}
	else
		{
		dprintf( "changing to debug mode\n" );
		fDebugMode = fTrue;
		}
	}


//  ================================================================
DEBUG_EXT( EDBGTest )
//  ================================================================
	{
	dprintf( "================================================================\n" );
	dprintf( "fDebugMode = %d\n", fDebugMode );
	dprintf( "fInit = %d\n", fInit );
	dprintf( "ExtensionApis.nSize = %d\n", ExtensionApis.nSize );
	dprintf( "\n" );

	dprintf( "sizeof PIB = %d (0x%04x)\n", sizeof(PIB), sizeof(PIB) );
	dprintf( "sizeof FCB = %d (0x%04x)\n", sizeof(FCB), sizeof(FCB) );
	dprintf( "sizeof TDB = %d (0x%04x)\n", sizeof(TDB), sizeof(TDB) );
	dprintf( "sizeof IDB = %d (0x%04x)\n", sizeof(IDB), sizeof(IDB) );
	dprintf( "sizeof SCB = %d (0x%04x)\n", sizeof(SCB), sizeof(SCB) );
	dprintf( "sizeof RCE = %d (0x%04x)\n", sizeof(RCE), sizeof(RCE) );
	dprintf( "sizeof VER = %d (0x%04x)\n", sizeof(VER), sizeof(VER) );
	dprintf( "sizeof LOG = %d (0x%04x)\n", sizeof(LOG), sizeof(LOG) );
	dprintf( "sizeof FMP = %d (0x%04x)\n", sizeof(FMP), sizeof(FMP) );
	dprintf( "sizeof CSR = %d (0x%04x)\n", sizeof(CSR), sizeof(CSR) );
	dprintf( "sizeof FUCB = %d (0x%04x)\n", sizeof(FUCB), sizeof(FUCB) );
	dprintf( "sizeof INST = %d (0x%04x)\n", sizeof(INST), sizeof(INST) );
	dprintf( "\n" );

	LONG 	cbPage;
	if ( FReadGlobal( "g_cbPage", &cbPage ) )
		{
		dprintf( "g_cbPage = %d\n", cbPage );
		}
	else 
		{
		dprintf( "g_cbPage = [Error: cannot determine the page size of debuggee.]\n" );
		}
	dprintf( "\n" );

	if( NULL != rgEDBGGlobalsDebugger )
		{
		dprintf( "Globals table has been loaded internally.\n" );
		}
	else
		{
		dprintf( "Globals table has NOT been loaded internally.\n" );
		}
	dprintf( "\n" );

	if( NULL != hLibrary )
		{
		dprintf( "Library has been loaded internally.\n" );
		}
	else
		{
		dprintf( "Library has NOT been loaded internally.\n" );
		}
	dprintf( "\n" );

	if ( argc >= 1 )
		{
		void* pv;
		if ( FAddressFromGlobal( argv[ 0 ], &pv ) )
			{
			dprintf(	"The address of %s is 0x%0*I64X.\n",
						argv[ 0 ],
						sizeof( void* ) * 2,
						QWORD( pv ) );
			}
		else
			{
			dprintf( "Could not find the symbol.\n" );
			}
		}
	if ( argc >= 2 )
		{
		void* pv;
		if ( FAddressFromSz( argv[ 1 ], &pv ) )
			{
			char		szGlobal[ 1024 ];
			DWORD_PTR	dwOffset;
			if ( FGlobalFromAddress( pv, szGlobal, sizeof( szGlobal ), &dwOffset ) )
				{
				dprintf(	"The symbol closest to 0x%0*I64X is %s+0x%I64X.\n",
							sizeof( void* ) * 2,
							QWORD( pv ),
							szGlobal,
							QWORD( dwOffset ) );
				}
			else
				{
				dprintf( "Could not map this address to a symbol.\n" );
				}
			}
		else
			{
			dprintf( "That is not a valid address.\n" );
			}
		}

	dprintf( "================================================================\n" );
	dprintf( "\n" );
	}


LOCAL VOID EDBGUnloadGlobals()
	{
	if ( NULL != rgEDBGGlobalsDebugger )
		{
		for ( SIZE_T i = 0; i < (SIZE_T)rgEDBGGlobalsDebugger[0].pvAddress; i++ )
			{
			Unfetch( rgEDBGGlobalsDebugger[i].szName );
			}
		Unfetch( rgEDBGGlobalsDebugger );
		rgEDBGGlobalsDebugger = NULL;
		}
	}

//  ================================================================
DEBUG_EXT( EDBGGlobals )
//  ================================================================
	{
	EDBGGLOBALVAR *		rgEDBGGlobalsDebuggee	= NULL;

	dprintf( "\n" );

	if ( argc > 1
		|| ( 1 == argc && !FAddressFromSz( argv[0], &rgEDBGGlobalsDebuggee ) )
		|| ( 0 == argc && NULL == rgEDBGGlobalsDebugger ) )
		{
		if ( NULL == rgEDBGGlobalsDebugger )
			dprintf( "Globals table not currently loaded.\n\n" );

		dprintf( "Usage: GLOBALS [<rgEDBGGlobals>]\n" );
		dprintf( "\n" );
		dprintf( "       Loads the debuggee's table of globals (for use when symbols are not present or inaccurate).\n" );
		dprintf( "       If <rgEDBGGlobals> is inaccessible, it may also be found in each INST as m_rgEDBGGlobals.\n" );
		dprintf( "       If <rgEDBGGlobals> is not specified, the current globals table is dumped.\n" );
		return;
		}

	if ( 1 == argc )
		{
		EDBGGLOBALVAR		globalvar;
		SIZE_T				cGlobals;
		CHAR *				szName					= NULL;

		//	free any previous copy of the globals table
		EDBGUnloadGlobals();

		if ( FReadVariable( rgEDBGGlobalsDebuggee, &globalvar )
			&& FReadVariable( (SIZE_T *)globalvar.pvAddress, &cGlobals )
			&& FFetchSz( (CHAR *)globalvar.szName, &szName )
			&& 0 == _stricmp( szName, "cEDBGGlobals" )
			&& FFetchVariable( rgEDBGGlobalsDebuggee, &rgEDBGGlobalsDebugger, cGlobals ) )
			{
			//	SPECIAL-CASE: for first entry, store count of globals
			rgEDBGGlobalsDebugger[0].szName = szName;
			rgEDBGGlobalsDebugger[0].pvAddress = (VOID *)cGlobals;

			for ( SIZE_T i = 1; i < cGlobals; i++ )
				{
				if ( !FFetchSz( (CHAR *)rgEDBGGlobalsDebugger[i].szName, &szName ) )
					{
					dprintf( "Error: Failed loading globals table.\n" );

					//	free only the entries we've already updated
					rgEDBGGlobalsDebugger[0].pvAddress = (VOID *)i;
					EDBGUnloadGlobals();
					break;
					}

				//	update the debugger's copy of the globals table entry
				//	to store its own copy of the variable name
				rgEDBGGlobalsDebugger[i].szName = szName;
				}

			if ( NULL != rgEDBGGlobalsDebugger )
				dprintf( "Successfully loaded Globals table from 0x%p\n", rgEDBGGlobalsDebuggee );
			}
		else
			{
			dprintf( "Error: Failed loading globals table.\n" );
			Unfetch( szName );
			}
		}

	else
		{
		dprintf( "Globals table: 0x%p\n", rgEDBGGlobalsDebugger );
		for ( SIZE_T i = 0; i < (SIZE_T)rgEDBGGlobalsDebugger[0].pvAddress; i++ )
			{
			dprintf( "    %-24s: 0x%p\n", rgEDBGGlobalsDebugger[i].szName, rgEDBGGlobalsDebugger[i].pvAddress );
			}
		}

	dprintf( "\n--------------------\n\n" );

	}


//  ================================================================
DEBUG_EXT( EDBGLoad )
//  ================================================================
	{
	dprintf( "loading %s\n", SzUtilImagePath() );
	hLibrary = LoadLibrary( SzUtilImagePath() );
	if( NULL == hLibrary )
		{
		dprintf( "unable to load %s!\n", SzUtilImagePath() );
		}
	else
		{
		//	free any previous copy of the globals table
		EDBGUnloadGlobals();
		}
	}


//  ================================================================
DEBUG_EXT( EDBGUnload )
//  ================================================================
	{
	if( NULL != hLibrary )
		{
		EDBGUnloadGlobals();
		FreeLibrary( hLibrary );
		}
	else
		{
		dprintf( "%s not loaded!", SzUtilImagePath() );
		}
	}


//  ================================================================
DEBUG_EXT( EDBGErr )
//  ================================================================
	{
	LONG lErr;
	if( 1 == argc
		&& FUlFromSz( argv[0], (ULONG *)&lErr ) )
		{
		const CHAR * szError;
		const CHAR * szErrorText;
		JetErrorToString( lErr, &szError, &szErrorText );
		dprintf( "0x%x, %d: %s (%s)\n", lErr, lErr, szError, szErrorText );
		}
	else
		{
		dprintf( "Usage: ERR <error>\n" );
		}
	}


//  ================================================================
DEBUG_EXT( EDBGHelp )
//  ================================================================
	{
	INT ifuncmap;
	for( ifuncmap = 0; ifuncmap < cfuncmap; ifuncmap++ )
		{
		dprintf( "\t%s\n", rgfuncmap[ifuncmap].szHelp );
		}
	dprintf( "\n--------------------\n\n" );
	}


//  ================================================================
DEBUG_EXT( EDBGFindRes )
//  ================================================================
	{
	CRES*	pcresDebuggee	= NULL;
	CRES*	pcres			= NULL;
	VOID**	rgpvDebuggee	= NULL;
	VOID**	rgpv			= NULL;
	DWORD	cpv;

	if (	argc != 3 ||
			!FAddressFromSz( argv[0], &pcresDebuggee ) ||
			!FAddressFromSz( argv[1], &rgpvDebuggee ) ||
			!FUlFromSz( argv[2], &cpv ) )
		{
		dprintf( "Usage: DUMP <cres> <address> <length>\n" );
		return;
		}

	if ( FFetchVariable( pcresDebuggee, &pcres )
		&& FFetchVariable( rgpvDebuggee, &rgpv, cpv ) )
		{
		dprintf(	"pbMin = 0x%0*I64X, pbMax = 0x%0*I64X, cbBlock = 0x%x\n",
					sizeof( BYTE* ) * 2,
					QWORD( pcres->PbMin() ),
					sizeof( BYTE* ) * 2,
					QWORD( pcres->PbMax() ),
					pcres->CbBlock() );
					
		for ( SIZE_T ipv = 0; ipv < cpv; ipv++ )
			{
			if (	(BYTE*)rgpv[ ipv ] >= pcres->PbMin() &&
					(BYTE*)rgpv[ ipv ] < pcres->PbMax() )
				{
				//  this is possibly a pointer to something in the CRES
				
				dprintf(	"0x%0*I64X  0x%0*I64X ",
							sizeof( void* ) * 2,
							QWORD( rgpvDebuggee + ipv ),
							sizeof( void* ) * 2,
							QWORD( rgpv[ ipv ] ) );
				
				void* pvAligned = (void*)( pcres->PbMin() + ( ( (BYTE*)rgpv[ ipv ] - pcres->PbMin() ) / pcres->CbBlock() ) * pcres->CbBlock() );
				if ( pvAligned == rgpv[ ipv ] )
					{
					dprintf( "(aligned)\n" );
					}
				else
					{
					dprintf(	"(not-aligned, possibly 0x%0*I64X)\n",
								sizeof( void* ) * 2,
								QWORD( pvAligned ) );
					}
				}
			}
		}

	Unfetch( rgpv );
	Unfetch( pcres );
	}


namespace OSSYNC
	{
	VOID OSSYNCAPI OSSyncDebuggerExtension(
	    HANDLE hCurrentProcess,
	    HANDLE hCurrentThread,
	    DWORD dwCurrentPc,
	    PWINDBG_EXTENSION_APIS lpExtensionApis,
		const INT argc,
	    const CHAR * const argv[] );
	};
	
//  ================================================================
DEBUG_EXT( EDBGSync )
//  ================================================================
	{
	OSSyncDebuggerExtension(	hCurrentProcess,
								hCurrentThread,
								dwCurrentPc,
								lpExtensionApis,
								argc,
								argv );
	}

//  ================================================================
DEBUG_EXT( EDBGCacheFind )
//  ================================================================
	{
	ULONG		ifmp;
	ULONG		pgno;
	BF **		rgpbfChunkDebuggee	= NULL;
	BF **		rgpbfChunkT			= NULL;
	ULONG		cbfChunkDebuggee;
	LONG_PTR	cbfChunkT;
	ULONG		cbfCacheDebuggee;
	LONG_PTR	cbfCacheT;
	BOOL		fValidUsage;

	switch ( argc )
		{
		case 2:
			fValidUsage = ( FUlFromSz( argv[0], &ifmp )
							&& FUlFromSz( argv[1], &pgno )
							&& pgno > 0 );
			break;

		case 5:
			fValidUsage = ( FUlFromSz( argv[0], &ifmp )
							&& FUlFromSz( argv[1], &pgno )
							&& pgno > 0
							&& FAddressFromSz( argv[2], &rgpbfChunkDebuggee )
							&& FUlFromSz( argv[3], &cbfChunkDebuggee )
							&& FUlFromSz( argv[4], &cbfCacheDebuggee ) );
			break;

		default:
			fValidUsage = fFalse;
			break;
		}
			
	
	if ( !fValidUsage )
		{
		dprintf( "Usage: CACHEFIND <ifmp> <pgno> [<rgpbfChunk> <cbfChunk> <cbfCache>]\n" );
		dprintf( "\n" );
		dprintf( "    <ifmp> is the index to the FMP entry for the desired database file\n" );
		dprintf( "    <pgno> is the desired page number from this FMP\n" );
		return;
		}

	if ( NULL == rgpbfChunkDebuggee )
		{
		if ( !FReadGlobal( "cbfChunk", &cbfChunkT )
			|| !FReadGlobal( "cbfCache", &cbfCacheT )
			|| !FReadGlobal( "rgpbfChunk", &rgpbfChunkDebuggee ) )
			{
			dprintf( "Error: Could not load BF parameters.\n" );
			return;
			}
		}
	else
		{
		cbfChunkT = cbfChunkDebuggee;
		cbfCacheT = cbfCacheDebuggee;
		}

	if ( !FFetchVariable( rgpbfChunkDebuggee, &rgpbfChunkT, cCacheChunkMax ) )
		{
		dprintf( "Error: Could not load BF parameters.\n" );
		return;
		}

	//  scan all valid BFs looking for this IFMP / PGNO

	BOOL fFoundBF = fFalse;
	for ( LONG_PTR ibf = 0; ibf < cbfCacheT; ibf++ )
		{
		//  compute the address of the target BF

		PBF pbfDebuggee = rgpbfChunkT[ ibf / cbfChunkT ] + ibf % cbfChunkT;
		
		//  we failed to read this BF
		
		PBF pbf;
		if ( !FFetchVariable( pbfDebuggee, &pbf ) )
			{
			dprintf(	"Error: Could not fetch BF at 0x%0*I64X.\n",
						sizeof( PBF ) * 2,
						QWORD( pbfDebuggee ) );
			fFoundBF = fTrue;
			break;
			}

		//  this BF contains this IFMP / PGNO

		if (	pbf->ifmp == IFMP( ifmp ) &&
				pbf->pgno == PGNO( pgno ) &&
				( pbf->fCurrentVersion || pbf->fOlderVersion ) )
			{
			dprintf(	"%X:%08X is cached in BF 0x%0*I64X%s.\n",
						ifmp,
						pgno,
						sizeof( PBF ) * 2,
						QWORD( pbfDebuggee ),
						pbf->fCurrentVersion ? "" : " (v)" );
			fFoundBF = fTrue;
			}

		Unfetch( pbf );
		}

	//  we did not find the IFMP / PGNO

	if ( !fFoundBF )
		{
		dprintf( "%X:%08X is not cached.\n", ifmp, pgno );
		}

	//  unload BF parameters

	Unfetch( rgpbfChunkT );
	}

//  ================================================================
DEBUG_EXT( EDBGCacheMap )
//  ================================================================
	{
	void *pvOffset;
	if ( argc == 1 && FAddressFromSz( argv[ 0 ], &pvOffset ) )
		{
		//  load BF parameters

		LONG_PTR	cbfChunkT;
		BF **		rgpbfChunkT				= NULL;
		LONG_PTR	cpgChunkT;
		VOID **		rgpvChunkRWT			= NULL;
		VOID **		rgpvChunkROT			= NULL;
		LONG		cbPageT;

		if ( !FReadGlobal( "cbfChunk", &cbfChunkT )
			|| !FReadGlobalAndFetchVariable( "rgpbfChunk", &rgpbfChunkT, cCacheChunkMax )
			|| !FReadGlobal( "cpgChunk", &cpgChunkT )
			|| !FReadGlobalAndFetchVariable( "rgpvChunkRW", &rgpvChunkRWT, cCacheChunkMax )
			|| !FReadGlobalAndFetchVariable( "rgpvChunkRO", &rgpvChunkROT, cCacheChunkMax )
			|| !FReadGlobal( "g_cbPage", &cbPageT ) )
			{
			dprintf( "Error: Could not load BF parameters.\n" );
			}

		else
			{
			//  lookup this offset in all three tables

			IBF ibf = ibfNil;
			for ( LONG_PTR ibfChunk = 0; ibfChunk < cCacheChunkMax; ibfChunk++ )
				{
				if (	rgpbfChunkT[ ibfChunk ] &&
						rgpbfChunkT[ ibfChunk ] <= PBF( pvOffset ) &&
						PBF( pvOffset ) < rgpbfChunkT[ ibfChunk ] + cbfChunkT  )
					{
					ibf = ibfChunk * cbfChunkT + PBF( pvOffset ) - rgpbfChunkT[ ibfChunk ];
					}
				}

			IPG ipgRW = ipgNil;
			for ( LONG_PTR ipgChunk = 0; ipgChunk < cCacheChunkMax; ipgChunk++ )
				{
				if (	rgpvChunkRWT[ ipgChunk ] &&
						rgpvChunkRWT[ ipgChunk ] <= pvOffset &&
						pvOffset < (BYTE*)rgpvChunkRWT[ ipgChunk ] + cpgChunkT * cbPageT )
					{
					ipgRW = ipgChunk * cpgChunkT + ( (BYTE*)pvOffset - (BYTE*)rgpvChunkRWT[ ipgChunk ] ) / cbPageT;
					}
				}

			IPG ipgRO = ipgNil;
			for ( ipgChunk = 0; ipgChunk < cCacheChunkMax; ipgChunk++ )
				{
				if (	rgpvChunkROT[ ipgChunk ] &&
						rgpvChunkROT[ ipgChunk ] <= pvOffset &&
						pvOffset < (BYTE*)rgpvChunkROT[ ipgChunk ] + cpgChunkT * cbPageT )
					{
					ipgRO = ipgChunk * cpgChunkT + ( (BYTE*)pvOffset - (BYTE*)rgpvChunkROT[ ipgChunk ] ) / cbPageT;
					}
				}

			//  this is a BF

			if ( ibf != ibfNil )
				{
				PBF		pbfDebuggee			= rgpbfChunkT[ ibf / cbfChunkT ] + ibf % cbfChunkT;
				void*	pvRWImageDebuggee	= (BYTE*)rgpvChunkRWT[ ibf / cpgChunkT ] + ( ibf % cpgChunkT ) * cbPageT;
				void*	pvROImageDebuggee	= (BYTE*)rgpvChunkROT[ ibf / cpgChunkT ] + ( ibf % cpgChunkT ) * cbPageT;
				
				dprintf(	"0x%0*I64X detected as BF 0x%0*I64X\n",
							sizeof( void* ) * 2,
							QWORD( pvOffset ),
							sizeof( PBF ) * 2,
							QWORD( pbfDebuggee ) );
				dprintf(	"\tRW Image is at 0x%0*I64X\n",
							sizeof( void* ) * 2,
							QWORD( pvRWImageDebuggee ) );
				dprintf(	"\tRO Image is at 0x%0*I64X\n",
							sizeof( void* ) * 2,
							QWORD( pvROImageDebuggee ) );
				}

			//  this is a RW image pointer

			else if ( ipgRW != ipgNil )
				{
				PBF		pbfDebuggee			= rgpbfChunkT[ ipgRW / cbfChunkT ] + ipgRW % cbfChunkT;
				void*	pvRWImageDebuggee	= (BYTE*)rgpvChunkRWT[ ipgRW / cpgChunkT ] + ( ipgRW % cpgChunkT ) * cbPageT;
				
				dprintf(	"0x%0*I64X detected as RW Image 0x%0*I64X\n",
							sizeof( void* ) * 2,
							QWORD( pvOffset ),
							sizeof( void* ) * 2,
							QWORD( pvRWImageDebuggee ) );
				dprintf(	"\tBF is at 0x%0*I64X\n",
							sizeof( PBF ) * 2,
							QWORD( pbfDebuggee ) );
				}

			//  this is a RO image pointer

			else if ( ipgRO != ipgNil )
				{
				PBF		pbfDebuggee			= rgpbfChunkT[ ipgRO / cbfChunkT ] + ipgRO % cbfChunkT;
				void*	pvROImageDebuggee	= (BYTE*)rgpvChunkROT[ ipgRO / cpgChunkT ] + ( ipgRO % cpgChunkT ) * cbPageT;
				
				dprintf(	"0x%0*I64X detected as RO Image 0x%0*I64X\n",
							sizeof( void* ) * 2,
							QWORD( pvOffset ),
							sizeof( void* ) * 2,
							QWORD( pvROImageDebuggee ) );
				dprintf(	"\tBF is at 0x%0*I64X\n",
							sizeof( PBF ) * 2,
							QWORD( pbfDebuggee ) );
				}

			//  this is an unknown pointer

			else
				{
				dprintf(	"0x%0*I64X is not part of the cache.\n",
							sizeof( void* ) * 2,
							QWORD( pvOffset ) );
				}
			}

		//  unload BF parameters

		Unfetch( rgpbfChunkT );
		Unfetch( rgpvChunkRWT );
		Unfetch( rgpvChunkROT );
		}
	else
		{
		dprintf( "Usage: CACHEMAP <address>\n" );
		dprintf( "\n" );
		dprintf( "    <address> can be any address within a valid BF or page image\n" );
		}
	}


//  ================================================================
DEBUG_EXT( EDBGDumpCacheMap )
//  ================================================================
	{
	//  load BF parameters

	LONG_PTR	cbfChunkT;
	BF **		rgpbfChunkT				= NULL;
	LONG_PTR	cpgChunkT;
	VOID **		rgpvChunkRWT			= NULL;
	VOID **		rgpvChunkROT			= NULL;
	LONG		cbPageT;

	if ( !FReadGlobal( "cbfChunk", &cbfChunkT )
		|| !FReadGlobalAndFetchVariable( "rgpbfChunk", &rgpbfChunkT, cCacheChunkMax )
		|| !FReadGlobal( "cpgChunk", &cpgChunkT )
		|| !FReadGlobalAndFetchVariable( "rgpvChunkRW", &rgpvChunkRWT, cCacheChunkMax )
		|| !FReadGlobalAndFetchVariable( "rgpvChunkRO", &rgpvChunkROT, cCacheChunkMax )
		|| !FReadGlobal( "g_cbPage", &cbPageT ) )
		{
		dprintf( "Error: Could not load BF parameters.\n" );
		}

	else
		{
		dprintf( "BF:\n" );
		for ( LONG_PTR ibfChunk = 0; ibfChunk < cCacheChunkMax && rgpbfChunkT[ ibfChunk ]; ibfChunk++ )
			{
			dprintf(	"\t[0x%0*I64X, 0x%0*I64X)\n",
						sizeof( PBF ) * 2,
						QWORD( rgpbfChunkT[ ibfChunk ] ),
						sizeof( PBF ) * 2,
						QWORD( rgpbfChunkT[ ibfChunk ] + cbfChunkT ) );
			}
		dprintf( "\n" );

		dprintf( "RW Image:\n" );
		for ( LONG_PTR ipvChunk = 0; ipvChunk < cCacheChunkMax && rgpvChunkRWT[ ipvChunk ]; ipvChunk++ )
			{
			dprintf(	"\t[0x%0*I64X, 0x%0*I64X)\n",
						sizeof( void* ) * 2,
						QWORD( rgpvChunkRWT[ ipvChunk ] ),
						sizeof( void* ) * 2,
						QWORD( (BYTE*)rgpvChunkRWT[ ipvChunk ] + cpgChunkT * cbPageT ) );
			}
		dprintf( "\n" );

		dprintf( "RO Image:\n" );
		for ( ipvChunk = 0; ipvChunk < cCacheChunkMax && rgpvChunkROT[ ipvChunk ]; ipvChunk++ )
			{
			dprintf(	"\t[0x%0*I64X, 0x%0*I64X)\n",
						sizeof( void* ) * 2,
						QWORD( rgpvChunkROT[ ipvChunk ] ),
						sizeof( void* ) * 2,
						QWORD( (BYTE*)rgpvChunkROT[ ipvChunk ] + cpgChunkT * cbPageT ) );
			}
		dprintf( "\n" );
		}

	//  unload BF parameters

	Unfetch( rgpbfChunkT );
	Unfetch( rgpvChunkRWT );
	Unfetch( rgpvChunkROT );
	}


//  ================================================================
DEBUG_EXT( EDBGTid2PIB )
//  ================================================================
	{
	ULONG		ulTid				= 0;
	INST **		rgpinstDebuggee		= NULL;
	INST **		rgpinst				= NULL;
	BOOL		fFoundPIB			= fFalse;
	BOOL		fValidUsage;

	switch ( argc )
		{
		case 1:
			fValidUsage = FUlFromSz( argv[0], &ulTid );
			break;
		case 2:
			fValidUsage = ( FAddressFromSz( argv[1], &rgpinstDebuggee )
							&& FUlFromSz( argv[0], &ulTid ) );
			break;
		default:
			fValidUsage = fFalse;
			break;
		}

	if ( !fValidUsage )
		{
		dprintf( "Usage: TID2PIB <tid> [<g_rgpinst>]\n" );
		return;
		}

	if ( ( NULL == rgpinstDebuggee && !FAddressFromGlobal( "g_rgpinst", &rgpinstDebuggee ) )
		|| !FFetchVariable( rgpinstDebuggee, &rgpinst, cMaxInstances ) )
		{
		dprintf( "Error: Could not fetch instance table.\n" );
		return;
		}

	dprintf( "\nScanning 0x%X INST's starting at 0x%p...\n", cMaxInstances, rgpinstDebuggee );

	for ( SIZE_T ipinst = 0; ipinst < cMaxInstances; ipinst++ )
		{
		if ( rgpinst[ipinst] != pinstNil )
			{
			INST* pinst;
			if ( !FFetchVariable( rgpinst[ipinst], &pinst ) )
				{
				dprintf( "Error: Could not fetch instance definition at 0x%0*I64X.\n",
							sizeof(INST*) * 2,
							QWORD( rgpinst[ipinst] ) );
				Unfetch( rgpinst );
				return;
				}

			PIB* ppibDebuggee = pinst->m_ppibGlobal;
			
			while ( ppibDebuggee != ppibNil )
				{
				PIB* ppib;
				if ( !FFetchVariable( ppibDebuggee, &ppib ) )
					{
					dprintf( "Error: Could not fetch PIB at 0x%0*I64X.\n",
								sizeof(PIB*) * 2,
								QWORD( ppibDebuggee ) );
					Unfetch( pinst );
					Unfetch( rgpinst );
					return;
					}

				_TLS* ptlsDebuggee = (_TLS*)ppib->ptls;

				if ( ptlsDebuggee )
					{
					_TLS* ptls;
					if ( !FFetchVariable( ptlsDebuggee, &ptls ) )
						{
						dprintf( "Error: Could not fetch TLS at 0x%0*I64X.\n",
									sizeof(_TLS*) * 2,
									QWORD( ptlsDebuggee ) );
						Unfetch( ppib );
						Unfetch( pinst );
						Unfetch( rgpinst );
						return;
						}

					if ( ptls->dwThreadId == ulTid )
						{
						dprintf( "TID %d (0x%x) was the last user of PIB 0x%0*I64X.\n",
									ptls->dwThreadId,
									ptls->dwThreadId,
									sizeof(PIB*) * 2,
									QWORD( ppibDebuggee ) );

						fFoundPIB = fTrue;
						}

					Unfetch( ptls );
					}

				ppibDebuggee = ppib->ppibNext;

				Unfetch( ppib );
				}

			Unfetch( pinst );
			}
		}

	if ( !fFoundPIB )
		{
		dprintf( "This thread was not the last user of any PIBs.\n" );
		}

	Unfetch( rgpinst );
	}


//  ================================================================
DEBUG_EXT( EDBGChecksum )
//  ================================================================
	{
	BYTE*	rgbDebuggee;
	ULONG	cb;
	
	if (	argc < 1 ||
			argc > 2 ||
			!FAddressFromSz( argv[ 0 ], &rgbDebuggee ) ||
			argc == 2 && !FUlFromSz( argv[ 1 ], &cb ) )
		{
		dprintf( "Usage: CHECKSUM <address> [<length>]\n" );
		return;
		}

	LONG	cbPage;
	if ( argc == 1 && !FReadGlobal( "g_cbPage", &cbPage ) )
		{
		dprintf( "Error: cannot determine page size of debuggee.\n" );
		return;
		}

	cb = ( argc == 1 ? cbPage : cb );

	BYTE*	rgb;
	if ( !FFetchVariable( rgbDebuggee, &rgb, cb ) )
		{
		dprintf( "Error: Could not retrieve data to checksum.\n" );
		return;
		}

	const ULONG ulChecksum = UlUtilChecksum( rgb, cb );
	dprintf(	"Checksum of 0x%X bytes starting at 0x%0*I64X is:  %u (0x%08X).\n",
				cb,
				sizeof( BYTE* ) * 2,
				QWORD( rgbDebuggee ),
				ulChecksum,
				ulChecksum );

	Unfetch( rgb );
	}


//  ================================================================
DEBUG_EXT( EDBGDumpLR )
//  ================================================================
	{
	LR* plrDebuggee;
	if (	argc != 1 ||
			!FAddressFromSz( argv[ 0 ], &plrDebuggee ) )
		{
		dprintf( "Usage: DUMPLR <address>\n" );
		return;
		}

	//  get the fixed size of this log record

	LR	lr;
	if ( !FReadVariable( plrDebuggee, &lr ) )
		{
		dprintf( "Error: Could not fetch the log record type.\n" );
		return;
		}
	const SIZE_T	cbLRFixed	= CbLGFixedSizeOfRec( &lr );

	//  get the full size of this log record

	LR*	plrFixed;
	if ( !FFetchVariable( (BYTE*)plrDebuggee, (BYTE**)&plrFixed, cbLRFixed ) )
		{
		dprintf( "Error: Could not fetch the fixed-sized part of this log record.\n" );
		return;
		}
	const SIZE_T	cbLR		= CbLGSizeOfRec( plrFixed );

	Unfetch( (BYTE*)plrFixed );

	//  get the full log record

	LR*	plr;
	if ( !FFetchVariable( (BYTE*)plrDebuggee, (BYTE**)&plr, cbLR ) )
		{
		dprintf( "Error: Could not fetch the entire log record.\n" );
		return;
		}

	//  dump the log record

	dprintf(	"0x%0*I64X bytes @ 0x%0*I64X\n",
				sizeof( SIZE_T ) * 2,
				QWORD( cbLR ),
				sizeof( LR* ) * 2,
				QWORD( plr ) );

#ifdef DEBUG

	CHAR szBuf[ 2048 ];
	LrToSz( plr, szBuf, NULL );
	dprintf( "%s\n", szBuf );

#endif	//	DEBUG

	Unfetch( (BYTE*)plr );
	}


//  ================================================================
DEBUG_EXT( EDBGHash )
//  ================================================================
	{
	ULONG	ifmp;
	ULONG	pgnoFDP;
	BYTE*	rgbPrefixDebuggee;
	ULONG	cbPrefix;
	BYTE*	rgbSuffixDebuggee;
	ULONG	cbSuffix;
	BYTE*	rgbDataDebuggee;
	ULONG	cbData;
	
	if (	argc != 8 ||
			!FUlFromSz( argv[ 0 ], &ifmp ) ||
			!FUlFromSz( argv[ 1 ], &pgnoFDP ) ||
			!FAddressFromSz( argv[ 2 ], &rgbPrefixDebuggee ) ||
			!FUlFromSz( argv[ 3 ], &cbPrefix ) ||
			!FAddressFromSz( argv[ 4 ], &rgbSuffixDebuggee ) ||
			!FUlFromSz( argv[ 5 ], &cbSuffix ) ||
			!FAddressFromSz( argv[ 6 ], &rgbDataDebuggee ) ||
			!FUlFromSz( argv[ 7 ], &cbData ) )
		{
		dprintf( "Usage: HASH <ifmp> <pgnoFDP> <prefix> <prefix length> <suffix> <suffix length> <data> <data length>\n" );
		return;
		}

	BYTE*	rgbPrefix	= NULL;
	BYTE*	rgbSuffix	= NULL;
	BYTE*	rgbData		= NULL;
	if ( !FFetchVariable( rgbPrefixDebuggee, &rgbPrefix, cbPrefix )
		|| !FFetchVariable( rgbSuffixDebuggee, &rgbSuffix, cbSuffix )
		|| !FFetchVariable( rgbDataDebuggee, &rgbData, cbData ) )
		{
		dprintf( "Error: Couldn't fetch the prefix / suffix / data from the debuggee.\n" );
		}
	else
		{
		BOOKMARK bookmark;;
		bookmark.key.prefix.SetPv( rgbPrefix );
		bookmark.key.prefix.SetCb( cbPrefix );
		bookmark.key.suffix.SetPv( rgbSuffix );
		bookmark.key.suffix.SetCb( cbSuffix );
		bookmark.data.SetPv( rgbData );
		bookmark.data.SetCb( cbData );
		
		const ULONG ulVERChecksum = UiVERHash( IFMP( ifmp ), PGNO( pgnoFDP ), bookmark );
		
		dprintf(	"VER checksum is:  %u (0x%08X)\n",
					ulVERChecksum,
					ulVERChecksum );
		}

	Unfetch( rgbPrefix );
	Unfetch( rgbSuffix );
	Unfetch( rgbData );
	}


//  ================================================================
DEBUG_EXT( EDBGVerStore )
//  ================================================================
	{
	INST *		pinstDebuggee		= NULL;
	INST *		pinst				= NULL;
	PIB *		ppibTrxOldest		= NULL;
	VER	*		pver				= NULL;
	CRES *		pcresVER			= NULL;

	dprintf( "\n" );

	if ( argc != 1
		|| !FAddressFromSz( argv[0], &pinstDebuggee ) )
		{
		dprintf( "Usage: VERSTORE <instance id>\n" );
		dprintf( "\n" );
		dprintf( "       <instance id> is the JET_INSTANCEID of the instance\n" );
		dprintf( "       for which to dump version store information. If you\n" );
		dprintf( "       do not know the instance id, you may be able to find\n" );
		dprintf( "       it by manually scanning the instance id array, which\n" );
		dprintf( "       begins at '%s!%s' and contains '%s!%s'\n",
						SzUtilImageName(),
						VariableNameToString( g_rgpinst ),
						SzUtilImageName(),
						VariableNameToString( ipinstMac ) );
		dprintf( "       entries.\n" );						
		return;
		}

	if ( FFetchVariable( pinstDebuggee, &pinst )
		&& FFetchVariable( (PIB *)pinst->m_ppibTrxOldest, &ppibTrxOldest )
		&& FFetchVariable( pinst->m_pver, &pver )
		&& FFetchVariable( pver->m_pcresVERPool, &pcresVER ) )
		{
		SIZE_T		dwOffset;

		//	dump version store-related members of various structs

		dwOffset = (BYTE *)pinstDebuggee - (BYTE *)pinst;
		dprintf( "INSTANCE: 0x%0*I64x\n", sizeof(INST*) * 2, QWORD( pinstDebuggee ) );
		dprintf( FORMAT_POINTER( INST, pinst, m_pver, dwOffset ) );
		dprintf( FORMAT_INT( INST, pinst, m_lVerPagesMax, dwOffset ) );
		dprintf( FORMAT_INT( INST, pinst, m_lVerPagesPreferredMax, dwOffset ) );
		dprintf( FORMAT_BOOL( INST, pinst, m_fPreferredSetByUser, dwOffset ) );
		dprintf( FORMAT_INT( INST, pinst, m_trxNewest, dwOffset ) );
		dprintf( FORMAT_POINTER( INST, pinst, m_ppibTrxOldest, dwOffset ) );
		dprintf( "\n" );

		dwOffset = (BYTE *)pinst->m_ppibTrxOldest - (BYTE *)ppibTrxOldest;
		dprintf( "OLDEST TRANSACTION: 0x%0*I64x\n", sizeof(PIB*) * 2, QWORD( pinst->m_ppibTrxOldest ) );
		dprintf( FORMAT_UINT( PIB, ppibTrxOldest, dwTrxContext, dwOffset ) );	
		dprintf( FORMAT_UINT( PIB, ppibTrxOldest, trxBegin0, dwOffset ) );	
		dprintf( FORMAT_UINT( PIB, ppibTrxOldest, trxCommit0, dwOffset ) );	
		dprintf( FORMAT_INT( PIB, ppibTrxOldest, level, dwOffset ) );	
		dprintf( FORMAT_INT( PIB, ppibTrxOldest, levelRollback, dwOffset ) );	
		dprintf( FORMAT_INT( PIB, ppibTrxOldest, levelBegin, dwOffset ) );	
		dprintf( FORMAT_INT( PIB, ppibTrxOldest, clevelsDeferBegin, dwOffset ) );	
		dprintf( FORMAT_UINT( PIB, ppibTrxOldest, dwSessionContext, dwOffset ) );	
		dprintf( FORMAT_UINT( PIB, ppibTrxOldest, dwSessionContextThreadId, dwOffset ) );	
		dprintf( "\n" );
		
		dwOffset = (BYTE *)pinst->m_pver - (BYTE *)pver;
		dprintf( "VER: 0x%0*I64x\n", sizeof(VER*) * 2, QWORD( pinst->m_pver ) );
		dprintf( FORMAT_POINTER( VER, pver, m_pcresVERPool, dwOffset ) );
		dprintf( FORMAT_INT( VER, pver, m_cbucketGlobalAlloc, dwOffset ) );
		dprintf( FORMAT_INT( VER, pver, m_cbucketGlobalAllocDelete, dwOffset ) );
		dprintf( FORMAT_POINTER( VER, pver, m_pbucketGlobalHead, dwOffset ) );
		dprintf( FORMAT_POINTER( VER, pver, m_pbucketGlobalTail, dwOffset ) );
		dprintf( FORMAT_POINTER( VER, pver, m_pbucketGlobalLastDelete, dwOffset ) );
		dprintf( FORMAT_INT( VER, pver, m_cbucketGlobalAllocMost, dwOffset ) );
		dprintf( FORMAT_INT( VER, pver, m_cbucketGlobalAllocPreferred, dwOffset ) );
		dprintf( FORMAT_UINT( VER, pver, m_trxBegin0LastLongRunningTransaction, dwOffset ) );
		dprintf( FORMAT_POINTER( VER, pver, m_ppibTrxOldestLastLongRunningTransaction, dwOffset ) );
		dprintf( FORMAT_UINT( VER, pver, m_dwTrxContextLastLongRunningTransaction, dwOffset ) );
		dprintf( "\n" );

		dprintf( "STATISTICS:\n" );
		dprintf( "-----------\n" );
		dprintf( "Bucket size (in bytes): %d (0x%08x)\n", pcresVER->CbBlock(), pcresVER->CbBlock() );
		dprintf( "Global reserved buckets: %d (0x%08x)\n", pcresVER->CBlocksAllocated(), pcresVER->CBlocksAllocated() );
		dprintf( "Global reserved buckets start address: 0x%0*I64x\n", sizeof(BYTE*) * 2, QWORD( pcresVER->PbBlocksAllocated() ) );
		dprintf( "Global reserved buckets committed: %d (0x%08x)\n", pcresVER->CBlockCommit(), pcresVER->CBlockCommit() );
		dprintf( "\n" );

		dprintf( "Scanning buckets for this instance...\n" );
		ULONG_PTR	cBuckets					= 0;
		ULONG_PTR	cBucketsReserved			= 0;
		ULONG_PTR	cBucketsDynamic				= 0;
		ULONG_PTR	cRCETotal					= 0;
		ULONG_PTR	cbRCESizeTotal				= 0;
		ULONG_PTR	cbRCESizeMax				= 0;
		ULONG_PTR	cRCEMoved					= 0;
		ULONG_PTR	cbRCEMoved					= 0;
		ULONG_PTR	cRCEProxy					= 0;
		ULONG_PTR	cbRCEProxy					= 0;
		ULONG_PTR	cRCERolledBack				= 0;
		ULONG_PTR	cbRCERolledBack				= 0;
		ULONG_PTR	cRCENullified				= 0;
		ULONG_PTR	cbRCENullified				= 0;
		ULONG_PTR	cRCEUncommitted				= 0;
		ULONG_PTR	cbRCEUncommitted			= 0;
		ULONG_PTR	cRCECleanable				= 0;
		ULONG_PTR	cbRCECleanable				= 0;
		ULONG_PTR	cRCECleanableFlagDelete		= 0;
		ULONG_PTR	cRCECleanableDelta			= 0;
		ULONG_PTR	cRCECleanableSLVSpace		= 0;
		ULONG_PTR	cRCEUncleanable				= 0;
		ULONG_PTR	cbRCEUncleanable			= 0;
		ULONG_PTR	cRCEUncleanableFlagDelete	= 0;
		ULONG_PTR	cRCEUncleanableDelta		= 0;
		ULONG_PTR	cRCEUncleanableSLVSpace		= 0;

		BUCKET *	pbucket;
		BUCKET *	pbucketDebuggee;
		for ( pbucketDebuggee = pver->m_pbucketGlobalTail;
			NULL != pbucketDebuggee;
			pbucketDebuggee = pbucket->hdr.pbucketNext )
			{

			if ( !FFetchVariable( pbucketDebuggee, &pbucket ) )
				{
				dprintf( "Error: Could not read BUCKET memory. Aborting.\n\n" );
				break;
				}

			//	determine whether bucket was pre-reserved or
			//	dynamically allocated and increment appropriate
			//	counter
			cBuckets++;
			if ( pcresVER->FContains( (BYTE *)pbucketDebuggee ) )
				{
				cBucketsReserved++;
				}
			else
				{
				cBucketsDynamic++;
				}

			//	scan RCE's in this bucket
			const RCE *			prce			= (RCE *)pbucket->rgb;
			const RCE * const	prceNextNew		= (RCE *)( (BYTE *)pbucket->hdr.prceNextNew - (BYTE *)pbucketDebuggee + (BYTE *)pbucket );
			const BYTE * const	pbLastDelete	= pbucket->hdr.pbLastDelete - (BYTE *)pbucketDebuggee + (BYTE *)pbucket;

			while (	prceNextNew != prce )
				{
				const ULONG		cbRCE		= prce->CbRceEDBG();
				const BYTE *	pbNextRce	= reinterpret_cast<BYTE *>( PvAlignForAllPlatforms( (BYTE *)prce + cbRCE ) );

				//	increment total and size counters
				cRCETotal++;
				cbRCESizeTotal += cbRCE;
				cbRCESizeMax = max( cbRCESizeMax, cbRCE );

				//	was RCE moved?
				if ( prce->FMoved() )
					{
					cRCEMoved++;
					cbRCEMoved += cbRCE;
					}

				//	was RCE created by proxy?
				if ( prce->FProxy() )
					{
					cRCEProxy++;
					cbRCEProxy += cbRCE;
					}

				//	was RCE rolled back?
				if ( prce->FRolledBackEDBG() )
					{
					cRCERolledBack++;
					cbRCERolledBack += cbRCE;
					}

				//	determine the state of the RCE and increment
				//	appropriate counters
				if ( prce->FOperNull() )
					{
					cRCENullified++;
					cbRCENullified += cbRCE;
					}
				else if ( trxMax == prce->TrxCommittedEDBG() )
					{
					cRCEUncommitted++;
					cbRCEUncommitted += cbRCE;
					}
				else if ( TrxCmp( prce->TrxCommittedEDBG(), ppibTrxOldest->trxBegin0 ) < 0 )
					{
					cRCECleanable++;
					cbRCECleanable += cbRCE;

					switch ( prce->Oper() )
						{
						case operFlagDelete:
							cRCECleanableFlagDelete++;
							break;
						case operDelta:
							cRCECleanableDelta++;
							break;
						case operSLVSpace:
							cRCECleanableSLVSpace++;
							break;
						default:
							break;
						}
					}
				else
					{
					cRCEUncleanable++;
					cbRCEUncleanable += cbRCE;

					switch ( prce->Oper() )
						{
						case operFlagDelete:
							cRCEUncleanableFlagDelete++;
							break;
						case operDelta:
							cRCEUncleanableDelta++;
							break;
						case operSLVSpace:
							cRCEUncleanableSLVSpace++;
							break;
						default:
							break;
						}
					}

				//	move to next RCE, being careful to account
				//	for case where we are on the last moved RCE
				if ( pbNextRce != pbLastDelete )
					{
					prce = (RCE *)pbNextRce;
					}
				else
					{
					prce = (RCE *)( (BYTE *)pbucket->hdr.prceOldest - (BYTE *)pbucketDebuggee + (BYTE *)pbucket );
					}

				}
			}

		dprintf( "  Total buckets in use: %d (0x%0*I64x)\n", cBucketsReserved+cBucketsDynamic, sizeof(ULONG_PTR)*2, QWORD( cBucketsReserved+cBucketsDynamic ) );
		dprintf( "  Reserved buckets: %d (0x%0*I64x)\n", cBucketsReserved, sizeof(ULONG_PTR)*2, QWORD( cBucketsReserved ) );
		dprintf( "  Dynamic buckets: %d (0x%0*I64x)\n", cBucketsDynamic, sizeof(ULONG_PTR)*2, QWORD( cBucketsDynamic ) );
		dprintf( "\n" );

		dprintf( "  Total version store entries: %d (0x%0*I64x)\n", cRCETotal, sizeof(ULONG_PTR)*2, QWORD( cRCETotal ) );
		dprintf( "  Total size of all entries (in bytes): %d (0x%0*I64x)\n", cbRCESizeTotal, sizeof(ULONG_PTR)*2, QWORD( cbRCESizeTotal ) );
		dprintf( "  Max. entry size (in bytes): %d (0x%0*I64x)\n", cbRCESizeMax, sizeof(ULONG_PTR)*2, QWORD( cbRCESizeMax ) );
		dprintf( "  Average entry size (in bytes): %d (0x%0*I64x)\n", ( 0 != cRCETotal ? cbRCESizeTotal/cRCETotal : 0 ), sizeof(ULONG_PTR)*2, QWORD( 0 != cRCETotal ? cbRCESizeTotal/cRCETotal : 0 ) );
		dprintf( "\n" );

		dprintf( "  Entries moved: %d (0x%0*I64x)\n", cRCEMoved, sizeof(ULONG_PTR)*2, QWORD( cRCEMoved ) );
		dprintf( "  Total size of moved entries (in bytes): %d (0x%0*I64x)\n", cbRCEMoved, sizeof(ULONG_PTR)*2, QWORD( cbRCEMoved ) );
		dprintf( "\n" );

		dprintf( "  Entries created by proxy: %d (0x%0*I64x)\n", cRCEProxy, sizeof(ULONG_PTR)*2, QWORD( cRCEProxy ) );
		dprintf( "  Total size of entries created by proxy (in bytes): %d (0x%0*I64x)\n", cbRCEProxy, sizeof(ULONG_PTR)*2, QWORD( cbRCEProxy ) );
		dprintf( "\n" );

		dprintf( "  Entries rolled-back: %d (0x%0*I64x)\n", cRCERolledBack, sizeof(ULONG_PTR)*2, QWORD( cRCERolledBack ) );
		dprintf( "  Total size of rolled-back entries (in bytes): %d (0x%0*I64x)\n", cbRCERolledBack, sizeof(ULONG_PTR)*2, QWORD( cbRCERolledBack ) );
		dprintf( "\n" );

		dprintf( "  Entries nullified: %d (0x%0*I64x)\n", cRCENullified, sizeof(ULONG_PTR)*2, QWORD( cRCENullified ) );
		dprintf( "  Total size of nullified entries (in bytes): %d (0x%0*I64x)\n", cbRCENullified, sizeof(ULONG_PTR)*2, QWORD( cbRCENullified ) );
		dprintf( "\n" );

		dprintf( "  Entries uncommitted: %d (0x%0*I64x)\n", cRCEUncommitted, sizeof(ULONG_PTR)*2, QWORD( cRCEUncommitted ) );
		dprintf( "  Total size of uncommitted entries (in bytes): %d (0x%0*I64x)\n", cbRCEUncommitted, sizeof(ULONG_PTR)*2, QWORD( cbRCEUncommitted ) );
		dprintf( "\n" );

		dprintf( "  Entries committed: %d (0x%0*I64x)\n", cRCECleanable+cRCEUncleanable, sizeof(ULONG_PTR)*2, QWORD( cRCECleanable+cRCEUncleanable ) );
		dprintf( "  Total size of committed entries (in bytes): %d (0x%0*I64x)\n", cbRCECleanable+cbRCEUncleanable, sizeof(ULONG_PTR)*2, QWORD( cbRCECleanable+cbRCEUncleanable ) );
		dprintf( "    Cleanable Entries: %d (0x%0*I64x)\n", cRCECleanable, sizeof(ULONG_PTR)*2, QWORD( cRCECleanable ) );
		dprintf( "    Total size of cleanable entries (in bytes): %d (0x%0*I64x)\n", cbRCECleanable, sizeof(ULONG_PTR)*2, QWORD( cbRCECleanable ) );
		dprintf( "      Cleanable 'FlagDelete' entries:: %d (0x%0*I64x)\n", cRCECleanableFlagDelete, sizeof(ULONG_PTR)*2, QWORD( cRCECleanableFlagDelete ) );
		dprintf( "      Cleanable 'Delta' entries: %d (0x%0*I64x)\n", cRCECleanableDelta, sizeof(ULONG_PTR)*2, QWORD( cRCECleanableDelta ) );
		dprintf( "      Cleanable 'SLVSpace' entries:): %d (0x%0*I64x)\n", cRCECleanableSLVSpace, sizeof(ULONG_PTR)*2, QWORD( cRCECleanableSLVSpace ) );
		dprintf( "    Uncleanable Entries: %d (0x%0*I64x)\n", cRCEUncleanable, sizeof(ULONG_PTR)*2, QWORD( cRCEUncleanable ) );
		dprintf( "    Total size of Uncleanable entries (in bytes): %d (0x%0*I64x)\n", cbRCEUncleanable, sizeof(ULONG_PTR)*2, QWORD( cbRCEUncleanable ) );
		dprintf( "      Uncleanable 'FlagDelete' entries:: %d (0x%0*I64x)\n", cRCEUncleanableFlagDelete, sizeof(ULONG_PTR)*2, QWORD( cRCEUncleanableFlagDelete ) );
		dprintf( "      Uncleanable 'Delta' entries: %d (0x%0*I64x)\n", cRCEUncleanableDelta, sizeof(ULONG_PTR)*2, QWORD( cRCEUncleanableDelta ) );
		dprintf( "      Uncleanable 'SLVSpace' entries:): %d (0x%0*I64x)\n", cRCEUncleanableSLVSpace, sizeof(ULONG_PTR)*2, QWORD( cRCEUncleanableSLVSpace ) );
		}
	else
		{
		dprintf( "Error: Could not read some/all version store variables.\n" );
		}

	dprintf( "\n--------------------\n\n" );

	Unfetch( pcresVER );
	Unfetch( pver );
	Unfetch( ppibTrxOldest );
	Unfetch( pinst );
	}


//  ================================================================
DEBUG_EXT( EDBGMemory )
//  ================================================================
	{
	DWORD			cAllocHeapT;
	DWORD			cFreeHeapT;
	DWORD			cbAllocHeapT;
	DWORD_PTR		cbReservePageT;
	DWORD_PTR		cbCommitPageT;
	LONG			cbPageT;
	LONG_PTR		cbfCacheT;
	SIZE_T			cbHintCacheT;
	SIZE_T			maskHintCacheT;
	ULONG			ipinstMaxT;
	INST **			rgpinst				= NULL;
	CRES *			pcresVER			= NULL;

	dprintf( "\n" );

	if ( FReadGlobal( "cAllocHeap", &cAllocHeapT )
		&& FReadGlobal( "cFreeHeap", &cFreeHeapT )
		&& FReadGlobal( "cbAllocHeap", &cbAllocHeapT )
		&& FReadGlobal( "cbReservePage", &cbReservePageT )
		&& FReadGlobal( "cbCommitPage", &cbCommitPageT )
		&& FReadGlobal( "g_cbPage", &cbPageT )
		&& FReadGlobal( "cbfCache", &cbfCacheT )
		&& FReadGlobal( "CPAGE::cbHintCache", &cbHintCacheT )
		&& FReadGlobal( "CPAGE::maskHintCache", &maskHintCacheT )
		&& FReadGlobal( "ipinstMax", &ipinstMaxT )
		&& ipinstMaxT <= cMaxInstances
		&& FFetchGlobal( "g_rgpinst", &rgpinst, ipinstMaxT )
		&& FReadGlobalAndFetchVariable( "g_pcresVERPool", &pcresVER ) )
		{
		dprintf( "Heap Usage\n" );
		dprintf( "----------\n" );
		dprintf( "  Bytes currently allocated: %d (0x%0*I64x)\n", cbAllocHeapT, sizeof(DWORD_PTR)*2, QWORD( cbAllocHeapT ) );
		dprintf( "  Current allocations: %d (0x%0*I64x)\n", cAllocHeapT - cFreeHeapT, sizeof(DWORD_PTR)*2, QWORD( cAllocHeapT - cFreeHeapT ) );
		dprintf( "  Total allocations (life of instance): %d (0x%0*I64x)\n", cAllocHeapT, sizeof(DWORD_PTR)*2, QWORD( cAllocHeapT ) );
		dprintf( "  Total de-allocations (life of instance): %d (0x%0*I64x)\n", cFreeHeapT, sizeof(DWORD_PTR)*2, QWORD( cFreeHeapT ) );
		dprintf( "\n" );

		dprintf( "Virtual Address Space Usage\n" );
		dprintf( "---------------------------\n" );
		dprintf( "  Bytes reserved: %d (0x%0*I64x)\n", cbReservePageT, sizeof(DWORD_PTR)*2, QWORD( cbReservePageT ) );
		dprintf( "  Bytes committed: %d (0x%0*I64x)\n", cbCommitPageT, sizeof(DWORD_PTR)*2, QWORD( cbCommitPageT ) );
		dprintf( "\n" );


		//	break down virtual address space usage
		//	into its major consumers

		ULONG_PTR	cbucketDynamicAlloc		= 0;
		ULONG_PTR	cbTablesReserved		= 0;
		ULONG_PTR	cbTablesCommitted		= 0;
		ULONG_PTR	cbCursorsReserved		= 0;
		ULONG_PTR	cbCursorsCommitted		= 0;
		ULONG_PTR	cbSessionsReserved		= 0;
		ULONG_PTR	cbSessionsCommitted		= 0;
		ULONG_PTR	cbSortsReserved			= 0;
		ULONG_PTR	cbSortsCommitted		= 0;

		//	sum up individual instance totals to
		//	yield totals for the process

		for ( ULONG i = 0; i < ipinstMaxT; i++ )
			{
			if ( pinstNil == rgpinst[i] )
				continue;

			INST *	pinst		= NULL;
			VER *	pver		= NULL;
			CRES *	pcresFCB	= NULL;
			CRES *	pcresTDB	= NULL;
			CRES *	pcresIDB	= NULL;
			CRES *	pcresSCB	= NULL;
			CRES *	pcresFUCB	= NULL;
			CRES *	pcresPIB	= NULL;

			if ( FFetchVariable( rgpinst[i], &pinst )
				&& FFetchVariable( pinst->m_pver, &pver )
				&& FFetchVariable( pinst->m_pcresFCBPool, &pcresFCB )
				&& FFetchVariable( pinst->m_pcresTDBPool, &pcresTDB )
				&& FFetchVariable( pinst->m_pcresIDBPool, &pcresIDB )
				&& FFetchVariable( pinst->m_pcresSCBPool, &pcresSCB )
				&& FFetchVariable( pinst->m_pcresFUCBPool, &pcresFUCB )
				&& FFetchVariable( pinst->m_pcresPIBPool, &pcresPIB ) )
				{
				cbucketDynamicAlloc += pver->m_cbucketDynamicAlloc;

				cbTablesReserved += pcresFCB->CBlocksAllocated() * pcresFCB->CbBlock();
				cbTablesCommitted += pcresFCB->CBlockCommit() * pcresFCB->CbBlock();

				cbTablesReserved += pcresTDB->CBlocksAllocated() * pcresTDB->CbBlock();
				cbTablesCommitted += pcresTDB->CBlockCommit() * pcresTDB->CbBlock();

				cbTablesReserved += pcresIDB->CBlocksAllocated() * pcresIDB->CbBlock();
				cbTablesCommitted += pcresIDB->CBlockCommit() * pcresIDB->CbBlock();

				cbSortsReserved += pcresSCB->CBlocksAllocated() * pcresSCB->CbBlock();
				cbSortsCommitted += pcresSCB->CBlockCommit() * pcresSCB->CbBlock();

				cbCursorsReserved += pcresFUCB->CBlocksAllocated() * pcresFUCB->CbBlock();
				cbCursorsCommitted += pcresFUCB->CBlockCommit() * pcresFUCB->CbBlock();

				cbSessionsReserved += pcresPIB->CBlocksAllocated() * pcresPIB->CbBlock();
				cbSessionsCommitted += pcresPIB->CBlockCommit() * pcresPIB->CbBlock();
				}
			else
				{
				dprintf( "Error: Could not read INST information. Skipped an instance.\n" );
				}

			Unfetch( pcresPIB );
			Unfetch( pcresFUCB );
			Unfetch( pcresSCB );
			Unfetch( pcresIDB );
			Unfetch( pcresTDB );
			Unfetch( pcresFCB );
			Unfetch( pver );
			Unfetch( pinst );
			}

		dprintf( "  Buffer Manager:\n" );
		dprintf( "    Current buffers: %d (0x%0*I64x)\n", cbfCacheT, sizeof(LONG_PTR)*2, QWORD( cbfCacheT ) );
		dprintf( "    Current cache size (in bytes): %d (0x%0*I64x)\n", cbfCacheT * cbPageT, sizeof(LONG_PTR)*2, QWORD( cbfCacheT * cbPageT ) );
		dprintf( "    Current cache overhead (in bytes): %d (0x%0*I64x)\n", cbfCacheT * sizeof(BF), sizeof(LONG_PTR)*2, QWORD( cbfCacheT * sizeof(BF) ) );
		dprintf( "    Committed hint cache size (in bytes): %d (0x%0*I64x)\n", cbHintCacheT, sizeof(SIZE_T)*2, QWORD( cbHintCacheT ) );
		dprintf( "    Hint cache size in use (in bytes): %d (0x%0*I64x)\n", ( maskHintCacheT + 1 ) * sizeof(DWORD_PTR), sizeof(SIZE_T)*2, QWORD( ( maskHintCacheT + 1 ) * sizeof(DWORD_PTR) ) );
		dprintf( "  Version Store:\n" );
		dprintf( "    Pre-reserved bytes: %d (0x%0*I64x)\n", pcresVER->CBlocksAllocated() * pcresVER->CbBlock(), sizeof(ULONG_PTR)*2, QWORD( pcresVER->CBlocksAllocated() * pcresVER->CbBlock() ) );
		dprintf( "    Pre-reserved bytes committed: %d (0x%0*I64x)\n", pcresVER->CBlockCommit() * pcresVER->CbBlock(), sizeof(ULONG_PTR)*2, QWORD( pcresVER->CBlockCommit() * pcresVER->CbBlock() ) );
		dprintf( "    Dynamic bytes committed: %d (0x%0*I64x)\n", cbucketDynamicAlloc * pcresVER->CbBlock(), sizeof(ULONG_PTR)*2, QWORD( cbucketDynamicAlloc * pcresVER->CbBlock() ) );
		dprintf( "  Tables and Indexes (FCB,TDB,IDB):\n" );
		dprintf( "    Bytes reserved: %d (0x%0*I64x)\n", cbTablesReserved, sizeof(ULONG_PTR)*2, QWORD( cbTablesReserved ) );
		dprintf( "    Bytes committed: %d (0x%0*I64x)\n", cbTablesCommitted, sizeof(ULONG_PTR)*2, QWORD( cbTablesCommitted ) );
		dprintf( "  Sorts and Temporary Tables (SCB):\n" );
		dprintf( "    Bytes reserved: %d (0x%0*I64x)\n", cbSortsReserved, sizeof(ULONG_PTR)*2, QWORD( cbSortsReserved ) );
		dprintf( "    Bytes committed: %d (0x%0*I64x)\n", cbSortsCommitted, sizeof(ULONG_PTR)*2, QWORD( cbSortsCommitted ) );
		dprintf( "  Cursors (FUCB):\n" );
		dprintf( "    Bytes reserved: %d (0x%0*I64x)\n", cbCursorsReserved, sizeof(ULONG_PTR)*2, QWORD( cbCursorsReserved ) );
		dprintf( "    Bytes committed: %d (0x%0*I64x)\n", cbCursorsCommitted, sizeof(ULONG_PTR)*2, QWORD( cbCursorsCommitted ) );
		dprintf( "  Sessions (PIB):\n" );
		dprintf( "    Bytes reserved: %d (0x%0*I64x)\n", cbSessionsReserved, sizeof(ULONG_PTR)*2, QWORD( cbSessionsReserved ) );
		dprintf( "    Bytes committed: %d (0x%0*I64x)\n", cbSessionsCommitted, sizeof(ULONG_PTR)*2, QWORD( cbSessionsCommitted ) );
		}
	else
		{
		dprintf( "Error: Could not read some/all memory-related variables.\n" );
		}

	dprintf( "\n--------------------\n\n" );

	Unfetch( pcresVER );
	Unfetch( rgpinst );
	}


//  ================================================================
DEBUG_EXT( EDBGHelpDump )
//  ================================================================
	{
	INT icdumpmap;
	for( icdumpmap = 0; icdumpmap < ccdumpmap; icdumpmap++ )
		{
		dprintf( "\t%s\n", rgcdumpmap[icdumpmap].szHelp );
		}
	dprintf( "\n--------------------\n\n" );
	}


//  ================================================================
DEBUG_EXT( EDBGDump )
//  ================================================================
	{
	if( argc < 2 )
		{
		EDBGHelpDump( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, argv );
		return;
		}
		
	INT icdumpmap;
	for( icdumpmap = 0; icdumpmap < ccdumpmap; ++icdumpmap )
		{
		if( FArgumentMatch( argv[0], rgcdumpmap[icdumpmap].szCommand ) )
			{
			(rgcdumpmap[icdumpmap].pcdump)->Dump(
				hCurrentProcess,
				hCurrentThread,
				dwCurrentPc,
				lpExtensionApis,
				argc - 1, argv + 1 );
			return;
			}
		}
	EDBGHelpDump( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, argv );
	}


//  ================================================================
template< class _STRUCT>
VOID CDUMPA<_STRUCT>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[] 
    )
//  ================================================================
	{
	_STRUCT* ptDebuggee;
	if (	argc != 1 ||
			!FAddressFromSz( argv[ 0 ], &ptDebuggee ) )
		{
		dprintf( "Usage: DUMP <class> <address>\n" );
		return;
		}

	_STRUCT* pt;
	if ( FFetchVariable( ptDebuggee, &pt ) )
		{
		dprintf(	"0x%0*I64X bytes @ 0x%0*I64X\n",
					sizeof( size_t ) * 2,
					QWORD( sizeof( _STRUCT ) ),
					sizeof( _STRUCT* ) * 2,
					QWORD( ptDebuggee ) );
		pt->Dump( CPRINTFWDBG::PcprintfInstance(), (BYTE*)ptDebuggee - (BYTE*)pt );
		Unfetch( pt );
		}
	}


//  ================================================================
VOID CDUMPA<CPAGE>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[] 
    )
//  ================================================================
	{
	BOOL	fDumpAllocMap 	= fFalse;
	BOOL	fDumpBinary		= fFalse;
	BOOL	fDumpHeader 	= fFalse;
	BOOL	fDumpTags 		= fFalse;
	CHAR *	pchPageSize;

	switch ( argc )
		{
		case 1:
			fDumpHeader = fTrue;	//	no flags, so default is to dump header
			pchPageSize = NULL;
			break;
			
		case 2:
			fDumpAllocMap 	= ( strpbrk( argv[0], "aA*" ) != NULL );
			fDumpBinary 	= ( strpbrk( argv[0], "bB*" ) != NULL );
			fDumpHeader		= ( strpbrk( argv[0], "hH*" ) != NULL );
			fDumpTags		= ( strpbrk( argv[0], "tT*" ) != NULL );
			pchPageSize		= strpbrk( argv[0], "248" );
			break;

		default:
			dprintf( "Usage: DUMP PAGE [a|b|h|t|*|2|4|8] <address>\n" );
			return;
		}


	LONG	cbPage			= 0;
	BYTE *	rgbPageDebuggee	= NULL;
	BYTE *	rgbPage			= NULL;

	if ( NULL != pchPageSize )
		{
		Assert( '2' == *pchPageSize
			|| '4' == *pchPageSize
			|| '8' == *pchPageSize );
		cbPage = ( *pchPageSize - '0' ) * 1024;

		//	default to header dump if no other dumps specified
		if ( !fDumpAllocMap && !fDumpBinary && !fDumpTags )
			fDumpHeader = fTrue;
		}
	else if ( !FReadGlobal( "g_cbPage", &cbPage ) )
		{
		dprintf( "Error: Could not retrieve g_cbPage from the debuggee.\n" );
		return;
		}

	if ( !FAddressFromSz( argv[argc-1], &rgbPageDebuggee )
		|| !FFetchVariable( rgbPageDebuggee, &rgbPage, cbPage ) )
		{
		dprintf( "Error: Could not retrieve the required data from the debuggee.\n" );
		}
	else
		{
		g_cbPage = cbPage;
		SetCbPageRelated();

		CPAGE cpage;
		cpage.LoadPage( (void*)rgbPage );

		if ( fDumpHeader )
			{
			(VOID)cpage.DumpHeader( CPRINTFWDBG::PcprintfInstance(), rgbPageDebuggee - rgbPage );
			}
		if ( fDumpTags )
			{
			(VOID)cpage.DumpTags( CPRINTFWDBG::PcprintfInstance(), rgbPageDebuggee - rgbPage );
			}
		if ( fDumpAllocMap )
			{
			(VOID)cpage.DumpAllocMap( CPRINTFWDBG::PcprintfInstance() );
			}
		if ( fDumpBinary )
			{
			char* szBuf = (char*)LocalAlloc( 0, g_cbPageMax * 8 );
			if ( szBuf )
				{
				DBUTLSprintHex( (char* const)szBuf, rgbPage, g_cbPage, 16 );
				
				CHAR* szLine = strtok( (char* const)szBuf, "\n" );
				while ( szLine )
					{
					dprintf( "%s\n", szLine );
					szLine = strtok( NULL, "\n" );
					}
					
				LocalFree( (void*)szBuf );
				}
			}

		cpage.UnloadPage();
		}
	
	Unfetch( rgbPage );
	}


//  ================================================================
VOID CDUMPA<REC>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[] 
    )
//  ================================================================
	{
	BYTE*	rgbRecDebuggee;
	ULONG	cbRec;
	
	if (	argc != 2 ||
			!FAddressFromSz( argv[ 0 ], &rgbRecDebuggee ) ||
			!FUlFromSz( argv[ 1 ], &cbRec ) )
		{
		dprintf( "Usage: DUMP REC <address> <length>\n" );
		return;
		}

	BYTE* rgbRec;
	if ( !FFetchVariable( rgbRecDebuggee, &rgbRec, cbRec ) )
		{
		dprintf( "Error: Could not fetch record from debuggee.\n" );
		return;
		}

	DBUTLDumpRec( rgbRec, cbRec, CPRINTFWDBG::PcprintfInstance(), 16 );

	Unfetch( rgbRec );
	}


//  ================================================================
VOID CDUMPA<MEMPOOL>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[] 
    )
//  ================================================================
	{
	MEMPOOL *	pmempool;
	MEMPOOL *	pmempoolDebuggee;
	BOOL		fDumpTags		= fFalse;
	BOOL		fDumpAll		= fFalse;
	ULONG		itagDump		= 0;

	if ( argc < 1
		|| argc > 2
		|| !FAddressFromSz( argv[0], &pmempoolDebuggee )
		|| ( ( fDumpTags = ( argc == 2 ) )
			&& !( fDumpAll = ( strpbrk( argv[1], "*" ) != NULL ) )
			&& !FUlFromSz( argv[1], &itagDump ) ) )
		{
		dprintf( "Usage: DUMP MEMPOOL <address> [<itag>|*]\n" );
		return;
		}

	if ( !FFetchVariable( pmempoolDebuggee, &pmempool ) )
		{
		dprintf( "Error: Could not fetch MEMPOOL.\n" );
		return;
		}

	pmempool->Dump(
		CPRINTFWDBG::PcprintfInstance(),
		fDumpTags,
		fDumpAll,
		(MEMPOOL::ITAG)itagDump,
		(BYTE *)pmempoolDebuggee - (BYTE *)pmempool );
	
	Unfetch( pmempool );
	}


//  ================================================================
VOID CSR::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_INT( CSR, this, m_dbtimeSeen, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CSR, this, m_pgno, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CSR, this, m_iline, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CSR, this, m_latch, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CSR, this, m_cpage, dwOffset ) );

	dprintf( "\n\t [CPAGE] 0x%0*I64X bytes @ 0x%0*I64X\n",  
			sizeof( size_t ) * 2,
			QWORD( sizeof( CPAGE ) ),
			sizeof (CPAGE *) * 2,
			QWORD( (char *)this + dwOffset + OffsetOf( CSR, m_cpage ) )
			);
	
	(VOID)m_cpage.Dump( CPRINTFWDBG::PcprintfInstance(), dwOffset );
	}


//  ================================================================
VOID RCE::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_UINT( RCE, this, m_trxBegin0, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( RCE, this, m_trxCommitted, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( RCE, this, m_rceid, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( RCE, this, m_updateid, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( RCE, this, m_uiHash, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( RCE, this, m_ifmp, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( RCE, this, m_pgnoFDP, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( RCE, this, m_pgnoUndoInfo, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( RCE, this, m_pfcb, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_pfucb, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_prceUndoInfoNext, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_prceUndoInfoPrev, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_prceNextOfSession, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_prcePrevOfSession, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_prceNextOfFCB, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_prcePrevOfFCB, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_prceNextOfNode, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_prcePrevOfNode, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( RCE, this, m_prceHashOverflow, dwOffset ) );

	(*pcprintf)( FORMAT_INT( RCE, this, m_ulFlags, dwOffset ) );

	PRINT_METHOD_FLAG( pcprintf, FOperNull );
	PRINT_METHOD_FLAG( pcprintf, FOperDDL );
	PRINT_METHOD_FLAG( pcprintf, FUndoableLoggedOper );
	PRINT_METHOD_FLAG( pcprintf, FOperInHashTable );
	PRINT_METHOD_FLAG( pcprintf, FOperReplace );
	PRINT_METHOD_FLAG( pcprintf, FOperConcurrent );
	PRINT_METHOD_FLAG( pcprintf, FOperAffectsSecondaryIndex );
	PRINT_METHOD_FLAG( pcprintf, FMoved );
	PRINT_METHOD_FLAG( pcprintf, FProxy );

	(*pcprintf)( FORMAT_INT_BF( RCE, this, m_level, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( RCE, this, m_cbBookmarkKey, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( RCE, this, m_cbBookmarkData, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( RCE, this, m_cbData, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( RCE, this, m_oper, dwOffset ) );

	(*pcprintf)( FORMAT_0ARRAY( RCE, this, m_rgbData, dwOffset ) );
	}


//  ================================================================
VOID FCB::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_precdangling, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_ls, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( FCB, this, m_ptdb, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_pfcbNextIndex, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_pfcbLRU, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_pfcbMRU, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_pfcbNextList, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_pfcbPrevList, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_pfcbTable, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_pidb, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_pfucb, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FCB, this, m_wRefCount, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FCB, this, m_objidFDP, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FCB, this, m_pgnoFDP, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FCB, this, m_pgnoOE, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FCB, this, m_pgnoAE, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FCB, this, m_ifmp, dwOffset ) );
	
#ifdef TABLES_PERF
	(*pcprintf)( FORMAT_INT( FCB, this, m_tableclass, dwOffset ) );
#endif  //  TABLES_PERF

	(*pcprintf)( FORMAT_INT( FCB, this, m_cbDensityFree, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FCB, this, m_crefDomainDenyRead, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FCB, this, m_crefDomainDenyWrite, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_ppibDomainDenyRead, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FCB, this, m_errInit, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( FCB, this, m_prceNewest, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_prceOldest, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FCB, this, m_ulFCBListFlags, dwOffset ) );
	PRINT_METHOD_FLAG( pcprintf, FInList );
	PRINT_METHOD_FLAG( pcprintf, FInLRU );

	(*pcprintf)( FORMAT_INT( FCB, this, m_ulFCBFlags, dwOffset ) );
	PRINT_METHOD_FLAG( pcprintf, FTypeDatabase );
	PRINT_METHOD_FLAG( pcprintf, FTypeTable );
	PRINT_METHOD_FLAG( pcprintf, FTypeSecondaryIndex );
	PRINT_METHOD_FLAG( pcprintf, FTypeTemporaryTable );
	PRINT_METHOD_FLAG( pcprintf, FTypeSort );
	PRINT_METHOD_FLAG( pcprintf, FTypeSentinel );
	PRINT_METHOD_FLAG( pcprintf, FTypeLV );
	PRINT_METHOD_FLAG( pcprintf, FTypeSLVAvail );
	PRINT_METHOD_FLAG( pcprintf, FTypeSLVOwnerMap );
	PRINT_METHOD_FLAG( pcprintf, FPrimaryIndex );
	PRINT_METHOD_FLAG( pcprintf, FSequentialIndex );
	PRINT_METHOD_FLAG( pcprintf, FFixedDDL );
	PRINT_METHOD_FLAG( pcprintf, FTemplateTable );
	PRINT_METHOD_FLAG( pcprintf, FDerivedTable );
	PRINT_METHOD_FLAG( pcprintf, FTemplateIndex );
	PRINT_METHOD_FLAG( pcprintf, FDerivedIndex );
	PRINT_METHOD_FLAG( pcprintf, FInitialized );
	PRINT_METHOD_FLAG( pcprintf, FAboveThreshold );
	PRINT_METHOD_FLAG( pcprintf, FDeletePending );
	PRINT_METHOD_FLAG( pcprintf, FDeleteCommitted );
	PRINT_METHOD_FLAG( pcprintf, FUnique );
	PRINT_METHOD_FLAG( pcprintf, FNonUnique );
	PRINT_METHOD_FLAG( pcprintf, FNoCache );
	PRINT_METHOD_FLAG( pcprintf, FPreread );

	(*pcprintf)( FORMAT_INT( FCB, this, m_pgnoNextAvailSE, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FCB, this, m_psplitbufdangling, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FCB, this, m_bflPgnoFDP, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( FCB, this, m_bflPgnoOE, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( FCB, this, m_bflPgnoAE, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FCB, this, m_ctasksActive, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FCB, this, m_critRCEList, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FCB, this, m_sxwl, dwOffset ) );

	}


//  ================================================================
VOID IDB::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_INT( IDB, this, m_crefCurrentIndex, dwOffset ) );
	
	(*pcprintf)( FORMAT_INT( IDB, this, m_fidbPersisted, dwOffset ) );
	PRINT_METHOD_FLAG( pcprintf, FPrimary );
	PRINT_METHOD_FLAG( pcprintf, FUnique );
	PRINT_METHOD_FLAG( pcprintf, FAllowAllNulls );
	PRINT_METHOD_FLAG( pcprintf, FAllowFirstNull );
	PRINT_METHOD_FLAG( pcprintf, FAllowSomeNulls );
	PRINT_METHOD_FLAG( pcprintf, FNoNullSeg );
	PRINT_METHOD_FLAG( pcprintf, FSortNullsHigh );
	PRINT_METHOD_FLAG( pcprintf, FMultivalued );
	PRINT_METHOD_FLAG( pcprintf, FLocaleId );
	PRINT_METHOD_FLAG( pcprintf, FLocalizedText );
	PRINT_METHOD_FLAG( pcprintf, FTemplateIndex );
	PRINT_METHOD_FLAG( pcprintf, FDerivedIndex );

	(*pcprintf)( FORMAT_INT( IDB, this, m_fidbNonPersisted, dwOffset ) );
	PRINT_METHOD_FLAG( pcprintf, FVersioned );
	PRINT_METHOD_FLAG( pcprintf, FDeleted );
	PRINT_METHOD_FLAG( pcprintf, FVersionedCreate );
	PRINT_METHOD_FLAG( pcprintf, FHasPlaceholderColumn );
	PRINT_METHOD_FLAG( pcprintf, FSparseIndex );
	PRINT_METHOD_FLAG( pcprintf, FSparseConditionalIndex );
	PRINT_METHOD_FLAG( pcprintf, FTuples );

	(*pcprintf)( FORMAT_INT( IDB, this, m_idxunicode.lcid, dwOffset ) );
	(*pcprintf)( FORMAT_INT( IDB, this, m_idxunicode.dwMapFlags, dwOffset ) );
	(*pcprintf)( FORMAT_INT( IDB, this, m_crefVersionCheck, dwOffset ) );
	(*pcprintf)( FORMAT_INT( IDB, this, m_itagIndexName, dwOffset ) );
	(*pcprintf)( FORMAT_INT( IDB, this, m_cbVarSegMac, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( IDB, this, m_cidxseg, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( IDB, this, m_cidxsegConditional, dwOffset ) );
	if ( FIsRgidxsegInMempool() )
		{
		(*pcprintf)( "\tItagRgidxseg: %d\n", ItagRgidxseg() );
		}
	else
		{
		(*pcprintf)( FORMAT_VOID( IDB, this, rgidxseg, dwOffset ) );
		}
	if ( FIsRgidxsegConditionalInMempool() )
		{
		(*pcprintf)( "\tItagRgidxsegConditional: %d\n", ItagRgidxsegConditional() );
		}
	else
		{
		(*pcprintf)( FORMAT_VOID( IDB, this, rgidxsegConditional, dwOffset ) );
		}
	(*pcprintf)( FORMAT_VOID( IDB, this, m_rgbitIdx, dwOffset ) );
	}


//  ================================================================
VOID MEMPOOL::Dump(
	CPRINTF * 		pcprintf,
	const BOOL		fDumpTags,
	const BOOL		fDumpAll,
	const ITAG		itagDump,
	const DWORD_PTR	dwOffset )
//  ================================================================
	{
	(*pcprintf)( FORMAT_POINTER( MEMPOOL, this, m_pbuf, dwOffset ) );	
	(*pcprintf)( FORMAT_INT( MEMPOOL, this, m_cbBufSize, dwOffset ) );	
	(*pcprintf)( FORMAT_INT( MEMPOOL, this, m_ibBufFree, dwOffset ) );	
	(*pcprintf)( FORMAT_INT( MEMPOOL, this, m_itagUnused, dwOffset ) );	
	(*pcprintf)( FORMAT_INT( MEMPOOL, this, m_itagFreed, dwOffset ) );	

	if ( fDumpTags )
		{
		BYTE *	rgbBufDebuggee	= Pbuf();
		BYTE *	rgbBuf;

		if ( FFetchVariable( rgbBufDebuggee, &rgbBuf, CbBufSize() ) )
			{
			SetPbuf( rgbBuf );
		
			dprintf( "\n" );
			if ( fDumpAll )
				{
				//	dump the entire mempool
				for ( ITAG itag = 0; itag < ItagUnused(); itag++ )
					{
					DumpTag( pcprintf, itag, rgbBufDebuggee - rgbBuf );
					}
				}
			else 
				{
				//	dump just the specified tag
				DumpTag( pcprintf, itagDump, rgbBufDebuggee - rgbBuf );
				}
			dprintf( "\n--------------------\n\n" );
			Unfetch( rgbBuf );
			}
		else
			{
			dprintf( "Error: Could not fetch MEMPOOL buffer.\n" );
			}
		}
	}


//  ================================================================
VOID MEMPOOL::DumpTag( CPRINTF * pcprintf, const ITAG itag, const SIZE_T lOffset ) const
//  ================================================================
	{
	MEMPOOLTAG	* const rgbTags = (MEMPOOLTAG *)Pbuf();
	if( 0 != rgbTags[itag].cb )
		{
		//  this tag is used
		(*pcprintf)( "TAG %3d        address: 0x%x    cb: %4d    ib: %4d\n",
				 	itag, (BYTE *)(&(rgbTags[itag])) + lOffset, rgbTags[itag].cb, rgbTags[itag].ib );
		(*pcprintf)( "\t%s", SzEDBGHexDump( Pbuf() + rgbTags[itag].ib, min( 32, rgbTags[itag].cb ) ) );
		}
	else
		{
		//  this is a free tag
		(*pcprintf)( "TAG %3d (FREE) address: 0x%x    cb: %4d    ib: %4d\n",
				 	itag, (BYTE *)(&(rgbTags[itag])) + lOffset, rgbTags[itag].cb, rgbTags[itag].ib );		
		}	
	}


//  ================================================================
VOID PIB::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_UINT( PIB, this, trxBegin0, dwOffset ) );	
	(*pcprintf)( FORMAT_UINT( PIB, this, trxCommit0, dwOffset ) );	
	(*pcprintf)( FORMAT_POINTER( PIB, this, m_pinst, dwOffset ) );	
	(*pcprintf)( FORMAT_UINT( PIB, this, dwTrxContext, dwOffset ) );	

	(*pcprintf)( FORMAT_POINTER( PIB, this, ppibNext, dwOffset ) );	
	(*pcprintf)( FORMAT_INT( PIB, this, updateid, dwOffset ) );	

	(*pcprintf)( FORMAT_POINTER( PIB, this, pfucbOfSession, dwOffset ) );	
	(*pcprintf)( FORMAT_VOID( PIB, this, critCursors, dwOffset ) );	

	(*pcprintf)( FORMAT_UINT( PIB, this, procid, dwOffset ) );	
	(*pcprintf)( FORMAT_VOID( PIB, this, rgcdbOpen, dwOffset ) );	

	(*pcprintf)( FORMAT_POINTER( PIB, this, ptls, dwOffset ) );	
	(*pcprintf)( FORMAT_INT( PIB, this, level, dwOffset ) );	
	(*pcprintf)( FORMAT_INT( PIB, this, levelRollback, dwOffset ) );	
	(*pcprintf)( FORMAT_INT( PIB, this, levelBegin, dwOffset ) );	
	(*pcprintf)( FORMAT_INT( PIB, this, clevelsDeferBegin, dwOffset ) );	
	(*pcprintf)( FORMAT_UINT( PIB, this, grbitsCommitDefault, dwOffset ) );	

	(*pcprintf)( FORMAT_UINT( PIB, this, m_fFlags, dwOffset ) );	
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fUserSession, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fAfterFirstBT, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fRecoveringEndAllSessions, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fOLD, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fOLDSLV, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fSystemCallback, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fCIMCommitted, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fCIMDirty, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fSetAttachDB, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fUseSessionContextForTrxContext, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fReadOnlyTrx, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fDistributedTrx, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fPreparedToCommitTrx, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fBegin0Logged, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( PIB, this, m_fLGWaiting, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( PIB, this, pppibTrxPrevPpibNext, dwOffset ) );	
	(*pcprintf)( FORMAT_POINTER( PIB, this, ppibTrxNext, dwOffset ) );	
	(*pcprintf)( FORMAT_POINTER( PIB, this, prceNewest, dwOffset ) );	
	(*pcprintf)( FORMAT_VOID( PIB, this, critTrx, dwOffset ) );	

	(*pcprintf)( FORMAT_LGPOS( PIB, this, lgposStart, dwOffset ) );	
	(*pcprintf)( FORMAT_LGPOS( PIB, this, lgposCommit0, dwOffset ) );	

	(*pcprintf)( FORMAT_VOID( PIB, this, asigWaitLogFlush, dwOffset ) );	
	(*pcprintf)( FORMAT_POINTER( PIB, this, ppibNextWaitFlush, dwOffset ) );	
	(*pcprintf)( FORMAT_POINTER( PIB, this, ppibPrevWaitFlush, dwOffset ) );	
	(*pcprintf)( FORMAT_VOID( PIB, this, critLogDeferBeginTrx, dwOffset ) );	

	(*pcprintf)( FORMAT_UINT( PIB, this, dwSessionContext, dwOffset ) );	
	(*pcprintf)( FORMAT_UINT( PIB, this, dwSessionContextThreadId, dwOffset ) );	
	(*pcprintf)( FORMAT_INT( PIB, this, m_ifmpForceDetach, dwOffset ) );	
	(*pcprintf)( FORMAT_INT( PIB, this, m_errRollbackFailure, dwOffset ) );	

	(*pcprintf)( FORMAT_POINTER( PIB, this, m_pvRecordFormatConversionBuffer, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( PIB, this, m_pMacroNext, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( PIB, this, m_pvDistributedTrxData, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( PIB, this, m_cbDistributedTrxData, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( PIB, this, m_simplelistRceidDeferred, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( PIB, this, m_fInJetAPI, dwOffset ) );
	}


//  ================================================================
VOID FUCB::Dump( CPRINTF * pcprintf, DWORD_PTR ulBase ) const
//  ================================================================
	{
	if( 0 == ulBase )
		{
		ulBase = reinterpret_cast<DWORD_PTR>( this );
		}

	(*pcprintf)( FORMAT_POINTER( FUCB, this, pvtfndef, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, ppib, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, pfucbNextOfSession, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, u.pfcb, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, u.pscb, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, pfucbNextOfFile, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, ifmp, ulBase ) );

	(*pcprintf)( FORMAT_VOID( FUCB, this, csr, ulBase ) );

	(*pcprintf)( FORMAT_VOID( FUCB, this, kdfCurr, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, ispairCurr, ulBase ) );
	(*pcprintf)( FORMAT_VOID( FUCB, this, bmCurr, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, locLogical, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, pfucbCurIndex, ulBase ) );

	(*pcprintf)( FORMAT_VOID( FUCB, this, rgbBMCache, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, pvBMBuffer, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, cbBMBuffer, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, pvRCEBuffer, ulBase ) );
	(*pcprintf)( FORMAT_VOID( FUCB, this, ls, ulBase ) );

	(*pcprintf)( FORMAT_INT( FUCB, this, rceidBeginUpdate, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, updateid, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, levelOpen, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, levelNavigate, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, levelPrep, ulBase ) );

	(*pcprintf)( FORMAT_POINTER( FUCB, this, pcsrRoot, ulBase ) );

	(*pcprintf)( FORMAT_VOID( FUCB, this, dataSearchKey, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, cColumnsInSearchKey, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, keystat, ulBase ) );
	
	(*pcprintf)( FORMAT_INT( FUCB, this, cbstat, ulBase ) );
	(*pcprintf)( FORMAT_UINT( FUCB, this, ulChecksum, ulBase ) );
	(*pcprintf)( FORMAT_POINTER( FUCB, this, pvWorkBuf, ulBase ) );
	(*pcprintf)( FORMAT_VOID( FUCB, this, dataWorkBuf, ulBase ) );
	(*pcprintf)( FORMAT_VOID( FUCB, this, rgbitSet, ulBase ) );

	(*pcprintf)( FORMAT_INT( FUCB, this, cpgPreread, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, cpgPrereadNotConsumed, ulBase ) );
	(*pcprintf)( FORMAT_INT( FUCB, this, cbSequentialDataRead, ulBase ) );

	(*pcprintf)( FORMAT_UINT( FUCB, this, ulFlags, ulBase ) );

	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fIndex					, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fSecondary				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fCurrentSecondary		, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fSort					, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fSystemTable			, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fWrite					, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fDenyRead				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fDenyWrite				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fPermitDDL				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fDeferClose			, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fVersioned				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fLimstat				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fInclusive				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fUpper					, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fUpdateSeparateLV		, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fDeferredChecksum		, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fAvailExt				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fOwnExt				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fSequential			, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fPreread				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fPrereadForward		, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fPrereadBackward		, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fBookmarkPreviouslySaved, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fTouch					, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fRepair				, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fAlwaysRetrieveCopy	, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fNeverRetrieveCopy		, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fSLVOwnerMapNeedUpdate	, ulBase ) );
	(*pcprintf)( FORMAT_BOOL_BF( FUCB, this, fTagImplicitOp			, ulBase ) );
	}


//  ================================================================
VOID TDB::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidTaggedFirst, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidTaggedLastInitial, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidFixedFirst, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidFixedLastInitial, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidVarFirst, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidVarLastInitial, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidTaggedLast, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidFixedLast, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidVarLast, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_itagTableName, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_ibEndFixedColumns, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( TDB, this, m_pfieldsInitial, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( TDB, this, m_pdataDefaultRecord, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( TDB, this, m_pfcbTemplateTable, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( TDB, this, m_pfcbLV, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_ulLongIdLast, dwOffset ) );

	(*pcprintf)( FORMAT_INT( TDB, this, m_fidTaggedLastOfESE97Template, dwOffset ) );

	(*pcprintf)( FORMAT_INT( TDB, this, m_usFlags, dwOffset ) );
	PRINT_METHOD_FLAG( pcprintf, FTemplateTable );
	PRINT_METHOD_FLAG( pcprintf, FESE97TemplateTable );
	PRINT_METHOD_FLAG( pcprintf, FDerivedTable );
	PRINT_METHOD_FLAG( pcprintf, FESE97DerivedTable );
	PRINT_METHOD_FLAG( pcprintf, FTableHasSLVColumn );
	PRINT_METHOD_FLAG( pcprintf, F8BytesAutoInc );
	PRINT_METHOD_FLAG( pcprintf, FTableHasDefault );
	PRINT_METHOD_FLAG( pcprintf, FTableHasNonEscrowDefault );
	PRINT_METHOD_FLAG( pcprintf, FTableHasUserDefinedDefault );
	PRINT_METHOD_FLAG( pcprintf, FInitialisingDefaultRecord );

	(*pcprintf)( FORMAT_INT( TDB, this, m_qwAutoincrement, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidVersion, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_fidAutoincrement, dwOffset ) );
	(*pcprintf)( FORMAT_INT( TDB, this, m_dbkMost, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( TDB, this, m_mempool, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( TDB, this, m_blIndexes, dwOffset ) );
		
	(*pcprintf)( FORMAT_VOID( TDB, this, m_rgbitAllIndex, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( TDB, this, m_rwlDDL, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( TDB, this, m_pcbdesc, dwOffset ) );
	}


//	CRES dumping

CHAR mpresidsz[ residMax - residMin ][ 16 ] =
	{
	"residFCB",
	"residFUCB",
	"residTDB",
	"residIDB",
	"residPIB",
	"residSCB",
	"residVER",
	};

//  ================================================================
VOID CRES::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_INT( CRES, this, m_cbBlock, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CRES, this, m_cBlocksAllocated, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CRES, this, m_pbBlocksAllocated, dwOffset ) );

	(*pcprintf)( FORMAT_INT( CRES, this, m_cBlockAvail, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CRES, this, m_pbBlockAvail, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CRES, this, m_cBlockCommit, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( CRES, this, m_pinst, dwOffset ) );

	if ( residVER == m_resid )
		{
		(*pcprintf)( FORMAT_INT( CRES, this, m_cBlockCommitThreshold, dwOffset ) );
		(*pcprintf)( FORMAT_INT( CRES, this, m_iBlockToCommit, dwOffset ) );
		}
	else
		{
		(*pcprintf)( FORMAT_POINTER( CRES, this, m_pbPreferredThreshold, dwOffset ) );
		}
		
	(*pcprintf)( FORMAT_VOID( CRES, this, m_crit, dwOffset ) );
	(*pcprintf)( FORMAT_ENUM( CRES, this, m_resid, dwOffset, mpresidsz, residMin, residMax ) );
	}


//  ================================================================
VOID INST::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_POINTER( INST, this, m_rgEDBGGlobals, dwOffset ) );

	PRINT_SZ_ON_HEAP( pcprintf, INST, this, m_szInstanceName, dwOffset );
	PRINT_SZ_ON_HEAP( pcprintf, INST, this, m_szDisplayName, dwOffset );
	(*pcprintf)( FORMAT_INT( INST, this, m_iInstance, dwOffset ) );

	(*pcprintf)( FORMAT_INT( INST, this, m_cSessionInJetAPI, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fJetInitialized, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fTermInProgress, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fTermAbruptly, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fSTInit, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fBackupAllowed, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fStopJetService, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fInstanceUnavailable, dwOffset ) );
	
	(*pcprintf)( FORMAT_INT( INST, this, m_lSessionsMax, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lVerPagesMax, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lVerPagesPreferredMax, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fPreferredSetByUser, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lOpenTablesMax, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lOpenTablesPreferredMax, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lTemporaryTablesMax, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lCursorsMax, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lLogBuffers, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lLogFileSize, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fSetLogFileSize, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lLogFileSizeDuringRecovery, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( INST, this, m_fUseRecoveryLogFileSize, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_cpgSESysMin, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lPageFragment, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_cpageTempDBMin, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_grbitsCommitDefault, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pfnRuntimeCallback, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( INST, this, m_ulParams, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( INST, this, m_fTempTableVersioning, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( INST, this, m_fCreatePathIfNotExist, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( INST, this, m_fCleanupMismatchedLogFiles, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( INST, this, m_fNoInformationEvent, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( INST, this, m_fSLVProviderEnabled, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( INST, this, m_fGlobalOLDEnabled, dwOffset ) );

	(*pcprintf)( FORMAT_INT( INST, this, m_fOLDLevel, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lEventLoggingLevel, dwOffset ) );

	(*pcprintf)( FORMAT_SZ( INST, this, m_szSystemPath, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( INST, this, m_szTempDatabase, dwOffset ) );

	(*pcprintf)( FORMAT_SZ( INST, this, m_szEventSource, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( INST, this, m_szEventSourceKey, dwOffset ) );

	(*pcprintf)( FORMAT_SZ( INST, this, m_szUnicodeIndexLibrary, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( INST, this, m_critLV, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_ppibLV, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_plog, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pver, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( INST, this, m_mpdbidifmp, dwOffset ) );

	(*pcprintf)( FORMAT_INT( INST, this, m_updateid, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( INST, this, m_critPIB, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( INST, this, m_critPIBTrxOldest, dwOffset ) );
	
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pcresPIBPool, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_ppibGlobal, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_ppibGlobalMin, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_ppibGlobalMax, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( INST, this, m_blBegin0Commit0, dwOffset ) );

	(*pcprintf)( FORMAT_INT( INST, this, m_trxNewest, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_ppibTrxOldest, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_ppibSentinel, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_pcresFCBPool, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pcresTDBPool, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pcresIDBPool, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_cFCBPreferredThreshold, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_pfcbhash, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( INST, this, m_critFCBList, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pfcbList, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pfcbAvailBelowMRU, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pfcbAvailBelowLRU, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pfcbAvailAboveMRU, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pfcbAvailAboveLRU, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( INST, this, m_cFCBAvail, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( INST, this, m_cFCBAboveThresholdSinceLastPurge, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( INST, this, m_critFCBCreate, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_pcresFUCBPool, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_pcresSCBPool, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( INST, this, m_fFlushLogForCleanThread, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_pbAttach, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( INST, this, m_taskmgr, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_cOpenedSystemPibs, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_rgoldstatDB, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_rgoldstatSLV, dwOffset ) );

	(*pcprintf)( FORMAT_INT( INST, this, m_lSLVDefragFreeThreshold, dwOffset ) );
	(*pcprintf)( FORMAT_INT( INST, this, m_lSLVDefragMoveThreshold, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_pfsapi, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( INST, this, m_plnppibBegin, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( INST, this, m_plnppibEnd, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( INST, this, m_critLNPPIB, dwOffset ) );


	// m_mpdbidifmp

	FMP *		rgfmpDebuggee;
	IFMP		ifmpMaxDebuggee		= ifmpMax;
	const BOOL	fReadGlobals		= ( FReadGlobal( "rgfmp", &rgfmpDebuggee )
										&& FReadGlobal( "ifmpMax", &ifmpMaxDebuggee ));

	(*pcprintf)( "\t\tDatabases:\n" );
	
	for ( DBID dbid = 0; dbid < dbidMax; dbid++ )
		{
		//	UNDONE: what's the correct value to use
		//	if we can't read ifmpMax from the
		//	debuggee
		if ( m_mpdbidifmp[dbid] < ifmpMaxDebuggee )
			{
			(*pcprintf)( "\t\t\t [%d] = IFMP:0x%x (FMP:",
							dbid,
							m_mpdbidifmp[dbid] );
			if ( fReadGlobals )
				{
				(*pcprintf)( "0x%0*I64x)\n",
							sizeof(FMP*) * 2,
							QWORD( rgfmpDebuggee + m_mpdbidifmp[dbid] ) );
				}
			else
				{
				(*pcprintf)( "\?\?\?)\n" );
				}
			}
		}

	dprintf( "\n--------------------\n\n" );
	}
	

//  ================================================================
VOID FMP::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	PRINT_SZ_ON_HEAP( pcprintf, FMP, this, m_szDatabaseName, dwOffset );
	(*pcprintf)( FORMAT_POINTER( FMP, this, m_pinst, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_dbid, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( FMP, this, m_fFlags, dwOffset ) );	
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fCreatingDB, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fAttachingDB, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fDetachingDB, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fExclusiveOpen, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fReadOnlyAttach, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fLogOn, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fVersioningOff, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fSkippedAttach, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fAttached, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fDeferredAttach, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fRunningOLD, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fRunningOLDSLV, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fInBackupSession, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fAllowForceDetach, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fForceDetaching, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fRedoSLVProviderNotEnabled, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fDuringSnapshot, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fAllowHeaderUpdate, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fDefragSLVCopy, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( FMP, this, m_fCopiedPatchHeader, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FMP, this, m_dbtimeLast, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_dbtimeOldestGuaranteed, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_dbtimeOldestCandidate, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_dbtimeOldestTarget, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( FMP, this, m_trxOldestCandidate, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( FMP, this, m_trxOldestTarget, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FMP, this, m_objidLast, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FMP, this, m_ctasksActive, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( FMP, this, m_pfapi, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FMP, this, m_pdbfilehdr, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FMP, this, m_critLatch, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( FMP, this, m_gateWriteLatch, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( FMP, this, m_cbFileSize, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( FMP, this, m_semExtendingDB, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( FMP, this, m_semIOExtendDB, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FMP, this, m_cPin, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_crefWriteLatch, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FMP, this, m_ppibWriteLatch, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FMP, this, m_ppibExclusiveOpen, dwOffset ) );

	(*pcprintf)( FORMAT_LGPOS( FMP, this, m_lgposAttach, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( FMP, this, m_lgposDetach, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FMP, this, m_rwlDetaching, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( FMP, this, m_trxNewestWhenDiscardsLastReported, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_cpgDatabaseSizeMax, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_pgnoMost, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_pgnoCopyMost, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FMP, this, m_semRangeLock, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( FMP, this, m_msRangeLock, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FMP, this, m_rgprangelock, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FMP, this, m_rgdwBFContext, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FMP, this, m_rwlBFContext, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FMP, this, m_ileBFICleanList, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( FMP, this, m_fBFICleanFlags, dwOffset ) );
	PRINT_METHOD_FLAG( pcprintf, FBFICleanDb );
	PRINT_METHOD_FLAG( pcprintf, FBFICleanSLV );

	(*pcprintf)( FORMAT_INT( FMP, this, m_errPatch, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_cpagePatch, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_cPatchIO, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FMP, this, m_pfapiPatch, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( FMP, this, m_ppatchhdr, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FMP, this, m_dbtimeCurrentDuringRecovery, dwOffset ) );
	(*pcprintf)( FORMAT_INT( FMP, this, m_dbtimeUndoForceDetach, dwOffset ) );

	(*pcprintf)( FORMAT_INT( FMP, this, m_dbtimeLastScrub, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( FMP, this, m_logtimeScrub, dwOffset ) );

	PRINT_SZ_ON_HEAP( pcprintf, FMP, this, m_szPatchPath, dwOffset );

	(*pcprintf)( FORMAT_POINTER( FMP, this, m_patchchk, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FMP, this, m_patchchkRestored, dwOffset ) );

 	(*pcprintf)( FORMAT_POINTER( FMP, this, m_pslvspacenodecache, dwOffset ) );

	PRINT_SZ_ON_HEAP( pcprintf, FMP, this, m_szSLVName, dwOffset );
	PRINT_SZ_ON_HEAP( pcprintf, FMP, this, m_szSLVRoot, dwOffset );

	(*pcprintf)( FORMAT_POINTER( FMP, this, m_pfapiSLV, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FMP, this, m_slvrootSLV, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( FMP, this, m_pfcbSLVAvail, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( FMP, this, m_pfcbSLVOwnerMap, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FMP, this, m_cbSLVFileSize, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( FMP, this, m_rwlSLVSpace, dwOffset ) );

	(*pcprintf)(	"\t%*.*s <0x%0*I64x,%3i>:  \n",
					SYMBOL_LEN_MAX,
					SYMBOL_LEN_MAX,
					"m_rgcslvspaceoper",
					sizeof( char* ) * 2,
					QWORD( (char*)this + dwOffset + OffsetOf( FMP, m_rgcslvspaceoper ) ),
					sizeof( (this)->m_rgcslvspaceoper ) );
	(*pcprintf)(	"\t\t\t\tSLV Space Operation Summary:\n" );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"slvspaceoperFreeToReserved",
					m_rgcslvspaceoper[ slvspaceoperFreeToReserved ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"slvspaceoperReservedToCommitted",
					m_rgcslvspaceoper[ slvspaceoperReservedToCommitted ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"slvspaceoperFreeToCommitted",
					m_rgcslvspaceoper[ slvspaceoperFreeToCommitted ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"slvspaceoperCommittedToDeleted",
					m_rgcslvspaceoper[ slvspaceoperCommittedToDeleted ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"slvspaceoperDeletedToFree",
					m_rgcslvspaceoper[ slvspaceoperDeletedToFree ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"slvspaceoperFree",
					m_rgcslvspaceoper[ slvspaceoperFree ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"slvspaceoperFreeReserved",
					m_rgcslvspaceoper[ slvspaceoperFreeReserved ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"slvspaceoperDeletedToCommitted",
					m_rgcslvspaceoper[ slvspaceoperDeletedToCommitted ] );
	(*pcprintf)(	"\t%*.*s <0x%0*I64x,%3i>:  \n",
					SYMBOL_LEN_MAX,
					SYMBOL_LEN_MAX,
					"m_rgcslvspace",
					sizeof( char* ) * 2,
					QWORD( (char*)this + dwOffset + OffsetOf( FMP, m_rgcslvspace ) ),
					sizeof( (this)->m_rgcslvspace ) );
	(*pcprintf)(	"\t\t\t\tSLV Space Summary:\n" );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"sFree",
					m_rgcslvspace[ SLVSPACENODE::sFree ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"sReserved",
					m_rgcslvspace[ SLVSPACENODE::sReserved ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"sDeleted",
					m_rgcslvspace[ SLVSPACENODE::sDeleted ] );
	(*pcprintf)(	"\t\t\t\t\t%-*s:  %I64d\n",
					32,
					"sCommitted",
					m_rgcslvspace[ SLVSPACENODE::sCommitted ] );
	}

//  ================================================================
VOID LOG::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pinst, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fLogInitialized, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fLogDisabled, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fLogDisabledDueToRecoveryFailure, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fNewLogRecordAdded, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fLGNoMoreLogWrite, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_ls, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fRecovering, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_fRecoveringMode, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fHardRestore, dwOffset ) );
	(*pcprintf)( FORMAT_INT( LOG, this, m_fRestoreMode, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fLGCircularLogging, dwOffset ) );

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fLGFMPLoaded, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_signLog, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fSignLogSet, dwOffset ) );

	(*pcprintf)( FORMAT_SZ( LOG, this, m_szRecovery, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( LOG, this, m_csecLGFile, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_csecLGBuf, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fLGIgnoreVersion, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pfapiLog, dwOffset ) );

	(*pcprintf)( FORMAT_SZ( LOG, this, m_szBaseName, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( LOG, this, m_szJet, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( LOG, this, m_szJetLog, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( LOG, this, m_szJetLogNameTemplate, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( LOG, this, m_szJetTmp, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( LOG, this, m_szJetTmpLog, dwOffset ) );

	(*pcprintf)( FORMAT_SZ( LOG, this, m_szLogName, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( LOG, this, m_szLogFilePath, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( LOG, this, m_szLogFileFailoverPath, dwOffset ) );
	PRINT_SZ_ON_HEAP( pcprintf, LOG, this, m_szLogCurrent, dwOffset );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_plgfilehdr, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_plgfilehdrT, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pbLGBufMin, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pbLGBufMax, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_osmmLGBuf, dwOffset ) );

	(*pcprintf)( FORMAT_UINT( LOG, this, m_cbLGBuf, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pbEntry, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pbWrite, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_isecWrite, dwOffset ) );

	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposLogRec, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposToFlush, dwOffset ) );

	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposMaxFlushPoint, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pbLGFileEnd, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_isecLGFileEnd, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pbLastChecksum, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposLastChecksum, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fHaveShadow, dwOffset ) );

	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposStart, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposRecoveryUndo, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposFullBackup, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_logtimeFullBackup, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposIncBackup, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_logtimeIncBackup, dwOffset ) );


	(*pcprintf)( FORMAT_UINT( LOG, this, m_cbSec, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_cbSecVolume, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_csecHeader, dwOffset ) );

	(*pcprintf)( FORMAT_INT( LOG, this, m_fLGFlushWait, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_msLGTaskExec, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_asigLogFlushDone, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fLGFailedToPostFlushTask, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( LOG, this, m_critLGFlush, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_critLGBuf, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_critLGTrace, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_critLGWaitQ, dwOffset ) );

//	(*pcprintf)( FORMAT_INT( LOG, this, m_cLGWaitQ, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_ppibLGFlushQHead, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_ppibLGFlushQTail, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pcheckpoint, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( LOG, this, m_critCheckpoint, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fDisableCheckpoint, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pbNext, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( LOG, this, m_pbRead, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( LOG, this, m_isecRead, dwOffset ) );

	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposRedo, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposLastRec, dwOffset ) );
	
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fAbruptEnd, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( LOG, this, m_plread, dwOffset ) );
	
	(*pcprintf)( FORMAT_INT( LOG, this, m_errGlobalRedoError, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( LOG, this, m_fAfterEndAllSessions, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( LOG, this, m_fLastLRIsShutdown, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( LOG, this, m_fNeedInitialDbList, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( LOG, this, m_lgposRedoShutDownMarkGlobal, dwOffset ) );
	
//	CPPIB   		*m_rgcppib;
//	CPPIB   		*m_pcppibAvail;
//	INT				m_ccppib;
//	TABLEHFHASH 	*m_ptablehfhash;

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fBackupInProgress, dwOffset ) );

//	LGPOS			m_lgposFullBackupMark;
//	LOGTIME			m_logtimeFullBackupMark;
//	LONG			m_lgenCopyMic;
//	LONG			m_lgenCopyMac;
//	LONG			m_lgenDeleteMic;
//	LONG			m_lgenDeleteMac;
//	PIB				*m_ppibBackup;

	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fBackupFull, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( LOG, this, m_fBackupBeginNewLogFile, dwOffset ) );
	
//	PATCHLST 		**m_rgppatchlst;

	if (m_fRecovering)
		{
		(*pcprintf)( FORMAT_SZ( LOG, this, m_szRestorePath, dwOffset ) );
		(*pcprintf)( FORMAT_SZ( LOG, this, m_szNewDestination, dwOffset ) );
		}
	
//	RSTMAP			*m_rgrstmap;
//	INT				m_irstmapMac;
//	BOOL			m_fExternalRestore;
//	LONG			m_lGenLowRestore;
//	LONG			m_lGenHighRestore;
	}


//  ================================================================
VOID VER::Dump( CPRINTF * pcprintf, DWORD_PTR dwOffset ) const
//  ================================================================
	{
	(*pcprintf)( FORMAT_POINTER( VER, this, m_pinst, dwOffset ) );

	(*pcprintf)( FORMAT_INT( VER, this, m_fVERCleanUpWait, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( VER, this, m_ulVERTasksPostMax, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( VER, this, m_asigRCECleanDone, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( VER, this, m_critRCEClean, dwOffset ) );
	
	(*pcprintf)( FORMAT_VOID( VER, this, m_critBucketGlobal, dwOffset ) );
	(*pcprintf)( FORMAT_INT( VER, this, m_cbucketGlobalAlloc, dwOffset ) );
	(*pcprintf)( FORMAT_INT( VER, this, m_cbucketGlobalAllocDelete, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( VER, this, m_cbucketDynamicAlloc, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( VER, this, m_pbucketGlobalHead, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( VER, this, m_pbucketGlobalTail, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( VER, this, m_pbucketGlobalLastDelete, dwOffset ) );

	(*pcprintf)( FORMAT_INT( VER, this, m_cbucketGlobalAllocMost, dwOffset ) );
	(*pcprintf)( FORMAT_INT( VER, this, m_cbucketGlobalAllocPreferred, dwOffset ) );

	(*pcprintf)( FORMAT_POINTER( VER, this, m_ppibRCEClean, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( VER, this, m_ppibRCECleanCallback, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( VER, this, m_trxBegin0LastLongRunningTransaction, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( VER, this, m_ppibTrxOldestLastLongRunningTransaction, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( VER, this, m_dwTrxContextLastLongRunningTransaction, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( VER, this, m_fSyncronousTasks, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( VER, this, m_pcresVERPool, dwOffset ) );

	(*pcprintf)( FORMAT_VOID( VER, this, m_rgrceheadHashTable, dwOffset ) );
	}


//  ================================================================
DEBUG_EXT( EDBGDumpAllFMPs )
//  ================================================================
	{
	FMP *	rgfmpDebuggee		= NULL;
	ULONG 	ifmpMaxDebuggee;
	BOOL	fDumpAll			= fFalse;
	BOOL	fValidUsage;

	switch ( argc )
		{
		case 0:
			//	use defaults
			fValidUsage = fTrue;
			break;
		case 1:
			//	'*' only
			fValidUsage = ( '*' == argv[0][0] );
			break;
		case 2:
			//	<rgfmp> and <ifmpMax>
			fValidUsage = ( FAddressFromSz( argv[0], &rgfmpDebuggee )
							&& FUlFromSz( argv[1], &ifmpMaxDebuggee ) );
			break;
		case 3:
			if ( '*' == argv[0][0] )
				{
				//	'*' followed by <rgfmp> and <ifmpMax>
				fDumpAll = fTrue;
				fValidUsage = ( FAddressFromSz( argv[1], &rgfmpDebuggee )
								&& FUlFromSz( argv[2], &ifmpMaxDebuggee ) );
				}
			else if ( '*' == argv[2][0] )
				{
				//	<rgfmp> and <ifmpMax> followed by '*'
				fDumpAll = fTrue;
				fValidUsage = ( FAddressFromSz( argv[0], &rgfmpDebuggee )
								&& FUlFromSz( argv[1], &ifmpMaxDebuggee ) );
				}
			else
				{
				//	neither first nor third argument is a '*', so must be an error
				fValidUsage = fFalse;
				}
			break;
		default:
			fValidUsage = fFalse;
			break;
		}

	if ( !fValidUsage )
		{
		dprintf( "Usage: DUMPFMPS [<rgfmp> <ifmpMax>] [*]\n" );
		return;
		}

	if ( NULL == rgfmpDebuggee )
		{
		if ( !FReadGlobal( "rgfmp", &rgfmpDebuggee )
			|| !FReadGlobal( "ifmpMax", &ifmpMaxDebuggee ) )
			{
			dprintf( "Error: Could not fetch FMP variables.\n" );
			return;
			}
		}

	dprintf( "\nScanning 0x%X FMPs starting at 0x%p...\n", ifmpMaxDebuggee, rgfmpDebuggee );

	for ( IFMP ifmp = 0; ifmp < ifmpMaxDebuggee; ifmp++ )
		{
		FMP *	pfmp				= NULL;
		CHAR *	szDatabaseName		= NULL;
		
		if ( !FFetchVariable( rgfmpDebuggee + ifmp, &pfmp ) ||
			( pfmp->FInUse() && !FFetchSz( pfmp->SzDatabaseName(), &szDatabaseName ) ) )
			{
			dprintf(	"\n rgfmp[0x%x]  Error: Could not fetch FMP at 0x%0*I64X. Aborting.\n",
						ifmp,
						sizeof(FMP*) * 2,
						QWORD( rgfmpDebuggee + ifmp ) );

			//	force out of loop
			ifmp = ifmpMaxDebuggee;
			}
		else
			{
			if ( szDatabaseName || fDumpAll )
				{
				dprintf(	"\n rgfmp[0x%x]  (FMP 0x%0*I64x)\n",
							ifmp,
							sizeof( FMP* ) * 2,
							QWORD( rgfmpDebuggee + ifmp ) );
				dprintf(	"           \t %*.*s : %s\n",
							SYMBOL_LEN_MAX,
							SYMBOL_LEN_MAX,
							"m_szDatabaseName",
							szDatabaseName );
				dprintf(	"           \t %*.*s : 0x%0*I64x\n",
							SYMBOL_LEN_MAX,
							SYMBOL_LEN_MAX,
							"m_pinst",
							sizeof( INST* ) * 2,
							QWORD( pfmp->Pinst() ) );
				}
			}

		Unfetch( pfmp );
		Unfetch( szDatabaseName );
		}

	dprintf( "\n--------------------\n\n" );
	}

//  ================================================================
DEBUG_EXT( EDBGDumpAllINSTs )
//  ================================================================
	{
	INST **		rgpinstDebuggee		= NULL;
	INST **		rgpinst				= NULL;

	if ( 0 != argc
		&& ( 1 != argc || !FAddressFromSz( argv[0], &rgpinstDebuggee ) ) )
		{
		dprintf( "Usage: DUMPINSTS [<g_rgpinst>]\n" );
		return;
		}

	if ( ( NULL == rgpinstDebuggee && !FAddressFromGlobal( "g_rgpinst", &rgpinstDebuggee ) )
		|| !FFetchVariable( rgpinstDebuggee, &rgpinst, cMaxInstances ) )
		{
		dprintf( "Error: Could not fetch instance table.\n" );
		return;
		}

	dprintf( "\nScanning 0x%X INST's starting at 0x%p...\n", cMaxInstances, rgpinstDebuggee );

	for ( SIZE_T ipinst = 0; ipinst < cMaxInstances; ipinst++ )
		{
		if ( rgpinst[ipinst] != pinstNil )
			{
			INST *	pinst			= NULL;
			CHAR *	szInstanceName	= NULL;
			
			if ( !FFetchVariable( rgpinst[ ipinst ], &pinst )
				|| ( pinst->m_szInstanceName && !FFetchSz( pinst->m_szInstanceName, &szInstanceName ) ) )
				{
				dprintf(	"\n g_rgpinst[0x%x]  Error: Could not fetch INST at 0x%0*I64X. Aborting.\n",
							ipinst,
							sizeof(INST*) * 2,
							QWORD( rgpinst[ ipinst ] ) );

				//	force out of loop
				ipinst = ipinstMax;
				}
			else
				{
				dprintf(	"\n g_rgpinst[0x%x]  (INST 0x%0*I64X)\n",
							ipinst,
							sizeof( INST* ) * 2,
							QWORD( rgpinst[ ipinst ] ) );
				dprintf(	"              \t %*.*s : %s\n",
							SYMBOL_LEN_MAX,
							SYMBOL_LEN_MAX,
							"m_szInstanceName",
							szInstanceName );
				dprintf(	"              \t %*.*s : %s\n",
							SYMBOL_LEN_MAX,
							SYMBOL_LEN_MAX,
							"m_szSystemPath",
							pinst->m_szSystemPath );
				dprintf(	"              \t %*.*s : %s\n",
							SYMBOL_LEN_MAX,
							SYMBOL_LEN_MAX,
							"m_szTempDatabase",
							pinst->m_szTempDatabase );
				dprintf(	"              \t %*.*s : 0x%0*I64X\n",
							SYMBOL_LEN_MAX,
							SYMBOL_LEN_MAX,
							"m_pver",
							sizeof( VER* ) * 2,
							QWORD( pinst->m_pver ) );
				dprintf(	"              \t %*.*s : 0x%0*I64X\n",
							SYMBOL_LEN_MAX,
							SYMBOL_LEN_MAX,
							"m_plog",
							sizeof( LOG* ) * 2,
							QWORD( pinst->m_plog ) );
				dprintf(	"              \t %*.*s : 0x%0*I64X\n",
							SYMBOL_LEN_MAX,
							SYMBOL_LEN_MAX,
							"m_pfsapi",
							sizeof( IFileSystemAPI* ) * 2,
							QWORD( pinst->m_pfsapi ) );
				}

			Unfetch( pinst );
			Unfetch( szInstanceName );
			}
		}

	dprintf( "\n--------------------\n\n" );

	Unfetch( rgpinst );
	}


// =========================================================================
VOID UtilUpdateSymPath( 
	const HANDLE hCurrentProcess, 
	const char szSymPathIn[_MAX_PATH] 
	)
// =========================================================================
	{
	char szNewSymPath[_MAX_PATH];
	
	strcpy( szNewSymPath, szSymPathIn );


	if ( !pfnSymSetSearchPath( hCurrentProcess, szNewSymPath ) )
		{
		dprintf( "Updating sympath failed\n" );
		}
		
	if ( SymLoadAllModules( hCurrentProcess, fTrue ) )
		{
		pfnSymGetSearchPath(hCurrentProcess, szNewSymPath, sizeof( szNewSymPath ));
		dprintf( "SYMPATH: %s\n", szNewSymPath );
		}
	else
		{
		dprintf("Reload Modules Failed \n");
		}
	}



// =========================================================================
DEBUG_EXT( EDBGSympath )
// =========================================================================
	{
	if ( 0 == argc )  // dump current sympath
		{
		char szOldSympath[_MAX_PATH];
		
		if ( pfnSymGetSearchPath(hCurrentProcess, szOldSympath, sizeof( szOldSympath ) ) )
			{
			dprintf( "SYMPATH: %s\n", szOldSympath );
			}
		else
			{
			dprintf("Unable to dump the current sympath\n");
			}
		}
	else if ( 1 == argc )
		{
		UtilUpdateSymPath( hCurrentProcess, argv[0] ); 
		}
	else 	// print usage error
		{
		dprintf( "Usage: SYMPATH [<pathname>]\n" );
		}
	}


//	SPLIT dumping

CHAR mpsplittypesz[ splittypeMax - splittypeMin ][ 32 ] =
	{
	"splittypeVertical",
	"splittypeRight",
	"splittypeAppend",
	};

CHAR mpsplitopersz[ splitoperMax - splitoperMin ][ 64 ] =
	{
	"splitoperNone",
	"splitoperInsert",
	"splitoperReplace",
	"splitoperFlagInsertAndReplaceData",
	};

//  ================================================================
VOID CDUMPA<SPLIT>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[] 
    )
//  ================================================================
	{
	SPLIT *		psplitDebuggee		= NULL;
	SPLIT *		psplit				= NULL;

	if ( argc != 1 || !FAddressFromSz( argv[0], &psplitDebuggee ) )
		{
		dprintf( "Usage: DUMP SPLIT <address>\n" );
		return;
		}

	if ( FFetchVariable( psplitDebuggee, &psplit ) )
		{
		const SIZE_T	dwOffset	= (BYTE *)psplitDebuggee - (BYTE *)psplit;

		dprintf(	"[SPLIT] 0x%0*I64X bytes @ 0x%0*I64X\n",
					sizeof( size_t ) * 2,
					QWORD( sizeof( SPLIT ) ),
					sizeof( SPLIT* ) * 2,
					QWORD( psplitDebuggee ) );

		dprintf( FORMAT_VOID( SPLIT, psplit, csrNew, dwOffset ) );
		dprintf( FORMAT_VOID( SPLIT, psplit, csrRight, dwOffset ) );
		dprintf( FORMAT_UINT( SPLIT, psplit, pgnoSplit, dwOffset ) );
		dprintf( FORMAT_UINT( SPLIT, psplit, pgnoNew, dwOffset ) );
		dprintf( FORMAT_INT( SPLIT, psplit, dbtimeRightBefore, dwOffset ) );
		dprintf( FORMAT_ENUM( SPLIT, psplit, splittype, dwOffset, mpsplittypesz, splittypeMin, splittypeMax ) );	
		dprintf( FORMAT_POINTER( SPLIT, psplit, psplitPath, dwOffset ) );
		dprintf( FORMAT_ENUM( SPLIT, psplit, splitoper, dwOffset, mpsplitopersz, splitoperMin, splitoperMax ) );	
		dprintf( FORMAT_INT( SPLIT, psplit, ilineOper, dwOffset ) );
		dprintf( FORMAT_INT( SPLIT, psplit, clines, dwOffset ) );
		dprintf( FORMAT_UINT( SPLIT, psplit, fNewPageFlags, dwOffset ) );
		dprintf( FORMAT_UINT( SPLIT, psplit, fSplitPageFlags, dwOffset ) );
		dprintf( FORMAT_INT( SPLIT, psplit, cbUncFreeDest, dwOffset ) );
		dprintf( FORMAT_INT( SPLIT, psplit, cbUncFreeSrc, dwOffset ) );
		dprintf( FORMAT_INT( SPLIT, psplit, ilineSplit, dwOffset ) );
		dprintf( FORMAT_VOID( SPLIT, psplit, prefixinfoSplit, dwOffset ) );
		dprintf( FORMAT_VOID( SPLIT, psplit, prefixSplitOld, dwOffset ) );
		dprintf( FORMAT_VOID( SPLIT, psplit, prefixSplitNew, dwOffset ) );
		dprintf( FORMAT_VOID( SPLIT, psplit, prefixinfoNew, dwOffset ) );
		dprintf( FORMAT_VOID( SPLIT, psplit, kdfParent, dwOffset ) );
		dprintf( FORMAT_BOOL_BF( SPLIT, psplit, fAllocParent, dwOffset ) );
		dprintf( FORMAT_BOOL_BF( SPLIT, psplit, fHotpoint, dwOffset ) );
		dprintf( FORMAT_POINTER( SPLIT, psplit, rglineinfo, dwOffset ) );

		Unfetch( psplit );
		}
	}

// SPLITPATH dumping
//  ================================================================
VOID CDUMPA<SPLITPATH>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[] 
    )
//  ================================================================
	{
	SPLITPATH *		psplitpathDebuggee	= NULL;
	SPLITPATH *		psplitpath			= NULL;

	if ( argc != 1 || !FAddressFromSz( argv[0], &psplitpathDebuggee ) )
		{
		dprintf( "Usage: DUMP SPLITPATH <address>\n" );
		return;
		}

	if ( FFetchVariable( psplitpathDebuggee, &psplitpath ) )
		{
		const SIZE_T	dwOffset		= (BYTE *)psplitpathDebuggee - (BYTE *)psplitpath;

		dprintf(	"[SPLITPATH] 0x%0*I64X bytes @ 0x%0*I64X\n",
					sizeof( size_t ) * 2,
					QWORD( sizeof( SPLITPATH ) ),
					sizeof( SPLITPATH* ) * 2,
					QWORD( psplitpathDebuggee ) );

		dprintf( FORMAT_VOID( SPLITPATH, psplitpath, csr, dwOffset ) );
		dprintf( FORMAT_INT( SPLITPATH, psplitpath, dbtimeBefore, dwOffset ) );
		dprintf( FORMAT_POINTER( SPLITPATH, psplitpath, psplitPathParent, dwOffset ) );
		dprintf( FORMAT_POINTER( SPLITPATH, psplitpath, psplitPathChild, dwOffset ) );
		dprintf( FORMAT_POINTER( SPLITPATH, psplitpath, psplit, dwOffset ) );

		Unfetch( psplitpath );
		}
	}


//	MERGE dumping 

CHAR mpmergetypesz[ mergetypeMax - mergetypeMin ][ 32 ] = 
	{
	"mergetypeNone",
	"mergetypeEmptyPage",
	"mergetypeFullRight",
	"mergetypePartialRight",
	"mergetypeEmptyTree",
	};

//  ================================================================
VOID CDUMPA<MERGE>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[] 
    )
//  ================================================================
	{
	MERGE *		pmergeDebuggee		= NULL;
	MERGE *		pmerge				= NULL;

	if ( argc != 1 || !FAddressFromSz( argv[0], &pmergeDebuggee ) )
		{
		dprintf( "Usage: DUMP MERGE <address>\n" );
		return;
		}

	if ( FFetchVariable( pmergeDebuggee, &pmerge ) )
		{
		const SIZE_T	dwOffset	= (BYTE *)pmergeDebuggee - (BYTE *)pmerge;

		dprintf(	"[MERGE] 0x%0*I64X bytes @ 0x%0*I64X\n",
					sizeof( size_t ) * 2,
					QWORD( sizeof( MERGE ) ),
					sizeof( MERGE* ) * 2,
					QWORD( pmergeDebuggee ) );

		dprintf( FORMAT_VOID( MERGE, pmerge, csrLeft, dwOffset ) );
		dprintf( FORMAT_VOID( MERGE, pmerge, csrRight, dwOffset ) );
		dprintf( FORMAT_INT( MERGE, pmerge, dbtimeLeftBefore, dwOffset ) );
		dprintf( FORMAT_INT( MERGE, pmerge, dbtimeRightBefore, dwOffset ) );
		dprintf( FORMAT_ENUM( MERGE, pmerge, mergetype, dwOffset, mpmergetypesz, mergetypeMin, mergetypeMax ) );	
		dprintf( FORMAT_POINTER( MERGE, pmerge, pmergePath, dwOffset ) );
		dprintf( FORMAT_VOID( MERGE, pmerge, kdfParentSep, dwOffset ) );
		dprintf( FORMAT_BOOL_BF( MERGE, pmerge, fAllocParentSep, dwOffset ) );
		dprintf( FORMAT_INT( MERGE, pmerge, ilineMerge, dwOffset ) );
		dprintf( FORMAT_INT( MERGE, pmerge, cbSavings, dwOffset ) );
		dprintf( FORMAT_INT( MERGE, pmerge, cbSizeTotal, dwOffset ) );
		dprintf( FORMAT_INT( MERGE, pmerge, cbSizeMaxTotal, dwOffset ) );
		dprintf( FORMAT_INT( MERGE, pmerge, cbUncFreeDest, dwOffset ) );
		dprintf( FORMAT_INT( MERGE, pmerge, clines, dwOffset ) );
		dprintf( FORMAT_POINTER( MERGE, pmerge, rglineinfo, dwOffset ) );

		Unfetch( pmerge );
		}
	}

// MERGEPATH dumping
//  ================================================================
VOID CDUMPA<MERGEPATH>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[] 
    )
//  ================================================================
	{
	MERGEPATH *		pmergepathDebuggee	= NULL;
	MERGEPATH *		pmergepath			= NULL;

	if ( argc != 1 || !FAddressFromSz( argv[0], &pmergepathDebuggee ) )
		{
		dprintf( "Usage: DUMP MERGEPATH <address>\n" );
		return;
		}

	if ( FFetchVariable( pmergepathDebuggee, &pmergepath ) )
		{
		const SIZE_T	dwOffset		= (BYTE *)pmergepathDebuggee - (BYTE *)pmergepath;

		dprintf(	"[MERGEPATH] 0x%0*I64X bytes @ 0x%0*I64X\n",
					sizeof( size_t ) * 2,
					QWORD( sizeof( MERGEPATH ) ),
					sizeof( MERGEPATH* ) * 2,
					QWORD( pmergepathDebuggee ) );

		dprintf( FORMAT_VOID( MERGEPATH, pmergepath, csr, dwOffset ) );
		dprintf( FORMAT_INT( MERGEPATH, pmergepath, dbtimeBefore, dwOffset ) );
		dprintf( FORMAT_POINTER( MERGEPATH, pmergepath, pmergePathParent, dwOffset ) );
		dprintf( FORMAT_POINTER( MERGEPATH, pmergepath, pmergePathChild, dwOffset ) );
		dprintf( FORMAT_POINTER( MERGEPATH, pmergepath, pmerge, dwOffset ) );
		dprintf( FORMAT_INT( MERGEPATH, pmergepath, iLine, dwOffset ) );
		dprintf( FORMAT_BOOL_BF( MERGEPATH, pmergepath, fKeyChange, dwOffset ) );
		dprintf( FORMAT_BOOL_BF( MERGEPATH, pmergepath, fDeleteNode, dwOffset ) );
		dprintf( FORMAT_BOOL_BF( MERGEPATH, pmergepath, fEmptyPage, dwOffset ) );

		Unfetch( pmergepath );
		}
	}


// DBFILEHDR dumping
//  ================================================================
VOID CDUMPA<DBFILEHDR>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[] 
    )
//  ================================================================
	{
	DBFILEHDR *		pdbfilehdrDebuggee	= NULL;
	DBFILEHDR *		pdbfilehdr			= NULL;

	if ( argc != 1 || !FAddressFromSz( argv[0], &pdbfilehdrDebuggee ) )
		{
		dprintf( "Usage: DUMP DBFILEHDR <address>\n" );
		return;
		}

	if ( FFetchVariable( pdbfilehdrDebuggee, &pdbfilehdr ) )
		{
		const SIZE_T	dwOffset		= (BYTE *)pdbfilehdrDebuggee - (BYTE *)pdbfilehdr;

		dprintf(	"[DBFILEHDR] 0x%0*I64X bytes @ 0x%0*I64X\n",
					sizeof( size_t ) * 2,
					QWORD( sizeof( DBFILEHDR ) ),
					sizeof( DBFILEHDR* ) * 2,
					QWORD( pdbfilehdrDebuggee ) );

		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_ulChecksum, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_ulMagic, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_ulVersion, dwOffset ) );
		dprintf( FORMAT_INT( DBFILEHDR, pdbfilehdr, le_attrib, dwOffset ) );
		dprintf( FORMAT_INT( DBFILEHDR, pdbfilehdr, le_dbtimeDirtied, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, signDb, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_dbstate, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, le_lgposConsistent, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, logtimeConsistent, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, logtimeAttach, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, le_lgposAttach, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, logtimeDetach, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, le_lgposDetach, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_dbid, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, signLog, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, bkinfoFullPrev, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, bkinfoIncPrev, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, bkinfoFullCur, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, m_ulDbFlags, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_objidLast, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_dwMajorVersion, dwOffset ) );						
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_dwMinorVersion, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_dwBuildNumber, dwOffset ) );
		dprintf( FORMAT_INT( DBFILEHDR, pdbfilehdr, le_lSPNumber, dwOffset ) );	
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_ulUpdate, dwOffset ) );		
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_cbPageSize, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_ulRepairCount, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, logtimeRepair, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, signSLV, dwOffset ) );
		dprintf( FORMAT_INT( DBFILEHDR, pdbfilehdr, le_dbtimeLastScrub, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, logtimeScrub, dwOffset ) );
		dprintf( FORMAT_INT( DBFILEHDR, pdbfilehdr, le_lGenMinRequired, dwOffset ) );
		dprintf( FORMAT_INT( DBFILEHDR, pdbfilehdr, le_lGenMaxRequired, dwOffset ) );
		dprintf( FORMAT_INT( DBFILEHDR, pdbfilehdr, le_cpgUpgrade55Format, dwOffset ) );
		dprintf( FORMAT_INT( DBFILEHDR, pdbfilehdr, le_cpgUpgradeFreePages, dwOffset ) );
		dprintf( FORMAT_INT( DBFILEHDR, pdbfilehdr, le_cpgUpgradeSpaceMapPages, dwOffset ) );
		dprintf( FORMAT_VOID( DBFILEHDR, pdbfilehdr, bkinfoSnapshotCur, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_ulCreateVersion, dwOffset ) );
		dprintf( FORMAT_UINT( DBFILEHDR, pdbfilehdr, le_ulCreateUpdate, dwOffset ) );

		Unfetch( pdbfilehdr );
		}
	}


// Dump members of CPAGE class
VOID CPAGE::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
    {
	(*pcprintf)( FORMAT_POINTER( CPAGE, this, m_ppib, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE, this, m_ifmp, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CPAGE, this, m_pgno, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CPAGE, this, m_bfl, dwOffset ) );
	}

	
//  BF Dumping

CHAR mpbfdfsz[ bfdfMax - bfdfMin ][ 16 ] =
	{
	"bfdfClean",
	"bfdfUntidy",
	"bfdfDirty",
	"bfdfFilthy",
	};

void BF::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
#ifdef _WIN64

	(*pcprintf)( FORMAT_VOID( BF, this, ob0ic, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( BF, this, lgposOldestBegin0, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( BF, this, lgposModify, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( BF, this, sxwl, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, ifmp, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( BF, this, pgno, dwOffset ) );
	(*pcprintf)( FORMAT_INT( BF, this, err, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fNewlyCommitted, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fNewlyEvicted, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fQuiesced, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fAvailable, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fMemory, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fWARLatch, dwOffset ) );
	(*pcprintf)( FORMAT_ENUM_BF( BF, this, bfdf, dwOffset, mpbfdfsz, bfdfMin, bfdfMax ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fInOB0OL, dwOffset ) );
	(*pcprintf)( FORMAT_UINT_BF( BF, this, irangelock, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fCurrentVersion, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fOlderVersion, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fFlushed, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pvROImage, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pvRWImage, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( BF, this, lrukic, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, prceUndoInfoNext, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfDependent, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfDepChainHeadPrev, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfDepChainHeadNext, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfTimeDepChainPrev, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfTimeDepChainNext, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( BF, this, fDependentPurged, dwOffset ) );

#else  //  !_WIN64

	(*pcprintf)( FORMAT_VOID( BF, this, ob0ic, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( BF, this, lgposOldestBegin0, dwOffset ) );
	(*pcprintf)( FORMAT_LGPOS( BF, this, lgposModify, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfTimeDepChainPrev, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfTimeDepChainNext, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( BF, this, sxwl, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfDependent, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfDepChainHeadPrev, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pbfDepChainHeadNext, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, ifmp, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( BF, this, pgno, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pvROImage, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, pvRWImage, dwOffset ) );
	(*pcprintf)( FORMAT_INT( BF, this, err, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fNewlyCommitted, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fNewlyEvicted, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fQuiesced, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fAvailable, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fMemory, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fWARLatch, dwOffset ) );
	(*pcprintf)( FORMAT_ENUM_BF( BF, this, bfdf, dwOffset, mpbfdfsz, bfdfMin, bfdfMax ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fInOB0OL, dwOffset ) );
	(*pcprintf)( FORMAT_UINT_BF( BF, this, irangelock, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fCurrentVersion, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fOlderVersion, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL_BF( BF, this, fFlushed, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( BF, this, prceUndoInfoNext, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( BF, this, fDependentPurged, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( BF, this, lrukic, dwOffset ) );

#endif  //  _WIN64
	}
	
void CSLVFileInfo::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
	(*pcprintf)( FORMAT_BOOL( CSLVFileInfo, this, m_fFreeCache, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( CSLVFileInfo, this, m_fUpdateChecksum, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( CSLVFileInfo, this, m_fUpdateSlist, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( CSLVFileInfo, this, m_fCloseBuffer, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( CSLVFileInfo, this, m_fCloseCursor, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CSLVFileInfo, this, m_rgbLocalCache, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileInfo, this, m_rgbCache, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CSLVFileInfo, this, m_cbCache, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileInfo, this, m_pffeainf, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CSLVFileInfo, this, m_cbffeainf, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileInfo, this, m_wszFileName, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVFileInfo, this, m_cwchFileName, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileInfo, this, m_pstatusCommit, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileInfo, this, m_pdwInstanceID, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileInfo, this, m_pdwChecksum, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileInfo, this, m_ptickOpenDeadline, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileInfo, this, m_pslist, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CSLVFileInfo, this, m_cbslist, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CSLVFileInfo, this, m_irun, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileInfo, this, m_psle, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CSLVFileInfo, this, m_buffer, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CSLVFileInfo, this, m_cursor, dwOffset ) );
	}
	
void CSLVFileTable::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
	(*pcprintf)( FORMAT_BOOL( CSLVFileTable, this, m_fInit, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVFileTable, this, m_pslvroot, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CSLVFileTable, this, m_cDeferredCleanup, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CSLVFileTable, this, m_semCleanup, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVFileTable, this, m_fileidNextCleanup, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVFileTable, this, m_cbReserved, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVFileTable, this, m_cbDeleted, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVFileTable, this, m_centryInsert, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVFileTable, this, m_centryDelete, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVFileTable, this, m_centryClean, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CSLVFileTable, this, m_et, dwOffset ) );
	}
	
void CSLVInfo::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
	(*pcprintf)( FORMAT_POINTER( CSLVInfo, this, m_pfucb, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVInfo, this, m_columnid, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVInfo, this, m_itagSequence, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( CSLVInfo, this, m_fCopyBuffer, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVInfo, this, m_ibOffsetChunkMic, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVInfo, this, m_ibOffsetChunkMac, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVInfo, this, m_ibOffsetRunMic, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVInfo, this, m_ibOffsetRunMac, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVInfo, this, m_ibOffsetRun, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( CSLVInfo, this, m_fCacheDirty, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( CSLVInfo, this, m_pvCache, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVInfo, this, m_cbCache, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CSLVInfo, this, m_rgbSmallCache, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( CSLVInfo, this, m_fHeaderDirty, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CSLVInfo, this, m_header, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( CSLVInfo, this, m_fFileNameVolatile, dwOffset ) );
	(*pcprintf)( FORMAT_WSZ( CSLVInfo, this, m_wszFileName, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( CSLVInfo, this, m_fileid, dwOffset ) );
	}
	
void _SLVROOT::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
	(*pcprintf)( FORMAT_UINT( _SLVROOT, this, hFileRoot, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( _SLVROOT, this, dwInstanceID, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( _SLVROOT, this, pfapiBackingFile, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( _SLVROOT, this, pslvft, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( _SLVROOT, this, pfnSpaceReq, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( _SLVROOT, this, dwSpaceReqKey, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( _SLVROOT, this, semSpaceReq, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( _SLVROOT, this, semSpaceReqComp, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( _SLVROOT, this, msigTerm, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( _SLVROOT, this, msigTermAck, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( _SLVROOT, this, cbGrant, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( _SLVROOT, this, cbCommit, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( _SLVROOT, this, pfnSpaceFree, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( _SLVROOT, this, dwSpaceFreeKey, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( _SLVROOT, this, cbfgeainf, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( _SLVROOT, this, rgbEA, dwOffset ) );
	(*pcprintf)( FORMAT_WSZ( _SLVROOT, this, wszRootName, dwOffset ) );
	}
	
void CSLVBackingFile::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
	COSFile::Dump( pcprintf, dwOffset );
	(*pcprintf)( FORMAT_POINTER( CSLVBackingFile, this, m_slvroot, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( CSLVBackingFile, this, m_szAbsPathSLV, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( CSLVBackingFile, this, m_semSetSize, dwOffset ) );
	}
	
void COSFileSystem::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
	(*pcprintf)( FORMAT_BOOL( COSFileSystem, this, m_fWin9x, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFileSystem, this, m_hmodKernel32, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( COSFileSystem, this, m_pfnGetVolumePathName, dwOffset ) );
	}
	
void COSFileFind::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
	(*pcprintf)( FORMAT_POINTER( COSFileFind, this, m_posfs, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( COSFileFind, this, m_szFindPath, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( COSFileFind, this, m_szAbsFindPath, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( COSFileFind, this, m_fBeforeFirst, dwOffset ) );
	(*pcprintf)( FORMAT_INT( COSFileFind, this, m_errFirst, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFileFind, this, m_hFileFind, dwOffset ) );
	(*pcprintf)( FORMAT_INT( COSFileFind, this, m_errCurrent, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( COSFileFind, this, m_fFolder, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( COSFileFind, this, m_szAbsFoundPath, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFileFind, this, m_cbSize, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( COSFileFind, this, m_fReadOnly, dwOffset ) );
	}
	
void COSFile::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
	(*pcprintf)( FORMAT_SZ( COSFile, this, m_szAbsPath, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFile, this, m_hFile, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFile, this, m_cbFileSize, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( COSFile, this, m_fReadOnly, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFile, this, m_cbIOSize, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFile, this, m_cbMMSize, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( COSFile, this, m_pfnEndUpdate, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFile, this, m_keyEndUpdate, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( COSFile, this, m_pfnBeginUpdate, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFile, this, m_keyBeginUpdate, dwOffset ) );
	(*pcprintf)( FORMAT_POINTER( COSFile, this, m_p_osf, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( COSFile, this, m_msFileSize, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( COSFile, this, m_rgcbFileSize, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( COSFile, this, m_semChangeFileSize, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( COSFile, this, m_critDefer, dwOffset ) );
	(*pcprintf)( FORMAT_VOID( COSFile, this, m_ilDefer, dwOffset ) );
	}
	
void COSFileLayout::Dump( CPRINTF* pcprintf, DWORD_PTR dwOffset ) const
	{
	(*pcprintf)( FORMAT_POINTER( COSFileLayout, this, m_posf, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFileLayout, this, m_ibVirtualFind, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFileLayout, this, m_cbSizeFind, dwOffset ) );
	(*pcprintf)( FORMAT_BOOL( COSFileLayout, this, m_fBeforeFirst, dwOffset ) );
	(*pcprintf)( FORMAT_INT( COSFileLayout, this, m_errFirst, dwOffset ) );
	(*pcprintf)( FORMAT_INT( COSFileLayout, this, m_errCurrent, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( COSFileLayout, this, m_szAbsVirtualPath, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFileLayout, this, m_ibVirtual, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFileLayout, this, m_cbSize, dwOffset ) );
	(*pcprintf)( FORMAT_SZ( COSFileLayout, this, m_szAbsLogicalPath, dwOffset ) );
	(*pcprintf)( FORMAT_UINT( COSFileLayout, this, m_ibLogical, dwOffset ) );
	}

#endif	//	DEBUGGER_EXTENSION


extern "C" {

//  ================================================================
VOID __stdcall ese(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
//  ================================================================
    {
#ifdef DEBUGGER_EXTENSION

	TRY
		{
#ifdef DEBUG
		//  we don't want assertions appearing on the screen during debugging
		if( !fDebugMode )
			{
			g_wAssertAction = 3/* no action */;
			}
		else
			{
			g_wAssertAction = JET_AssertMsgBox;
			}
#endif

	    ExtensionApis 	= *lpExtensionApis;

		if ( sizeof( WINDBG_EXTENSION_APIS ) > lpExtensionApis->nSize )
			{
			dprintf( "WARNING: EXTENSION_APIS has unexpected size: 0x%x bytes\n", lpExtensionApis->nSize );
			}

		if( !fInit )
			{
			fInit = FSymInit( hCurrentProcess );
			}

		VOID * const pv = LocalAlloc( LMEM_ZEROINIT, strlen( lpArgumentString ) + 1 );
		memcpy( pv, lpArgumentString, strlen( lpArgumentString ) );
		CHAR * argv[256];
		INT argc = SzToRgsz( argv, reinterpret_cast<CHAR *>( pv ) );

		if( argc < 1 )
			{
			EDBGHelp( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, (const CHAR **)argv );
			goto Return;
			}
			
		INT ifuncmap;
		for( ifuncmap = 0; ifuncmap < cfuncmap; ifuncmap++ )
			{
			if( FArgumentMatch( argv[0], rgfuncmap[ifuncmap].szCommand ) )
				{
				(rgfuncmap[ifuncmap].function)(
					hCurrentProcess,
					hCurrentThread,
					dwCurrentPc,
					lpExtensionApis,
					argc - 1, (const CHAR **)( argv + 1 ) );
				goto Return;
				}
			}
		EDBGHelp( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, (const CHAR **)argv );
		goto Return;

	Return:
		LocalFree( pv );
		}
	EXCEPT( fDebugMode ? ExceptionFail( _T( "ESE Debugger Extension" ) ) : efaContinueSearch )
		{
		}
	ENDEXCEPT

#endif	//	DEBUGGER_EXTENSION	
    }

	
//  ================================================================
JET_ERR JET_API YouHaveBadSymbols(
	JET_SESID 		sesid,
	JET_DBID 		ifmp,
	JET_TABLEID 	tableid,
	JET_CBTYP 		cbtyp,
	void *			pvArg1,
	void *			pvArg2,
	void *			pvContext,
	ULONG_PTR		ulUnused )
//  ================================================================
	{
	//  this line should only compile if the signatures match
	JET_CALLBACK	callback = YouHaveBadSymbols;

	static BOOL fMessageBox = fTrue;
	
	const char * szCbtyp = "UNKNOWN";
	switch( cbtyp )
		{
		case JET_cbtypNull:
			szCbtyp = "NULL";
			break;
		case JET_cbtypBeforeInsert:
			szCbtyp = "BeforeInsert";
			break;
		case JET_cbtypAfterInsert:
			szCbtyp = "AfterInsert";
			break;
		case JET_cbtypBeforeReplace:
			szCbtyp = "BeforeReplace";
			break;
		case JET_cbtypAfterReplace:
			szCbtyp = "AfterReplace";
			break;
		case JET_cbtypBeforeDelete:
			szCbtyp = "BeforeDelete";
			break;
		case JET_cbtypAfterDelete:
			szCbtyp = "AfterDelete";
			break;
		}

	CHAR szMessage[256];
	sprintf( szMessage,
			"YouHaveBadSymbols:\n"
			"\tsesid   		= 0x%x\n"
			"\tifmp    		= 0x%x\n"
			"\ttableid 		= 0x%x\n"
			"\tcbtyp   		= 0x%x (%s)\n"
			"\tpvArg1  		= 0x%0*I64X\n"
			"\tpvArg2 		= 0x%0*I64X\n"
			"\tpvContext  	= 0x%0*I64X\n"
			"\tulUnused  	= 0x%x\n"			
			"\n",
			sesid, ifmp, tableid, cbtyp, szCbtyp,
				sizeof( LONG_PTR )*2, pvArg1,
				sizeof( LONG_PTR )*2, pvArg2,
				sizeof( LONG_PTR )*2, pvContext,
				ulUnused );
	printf( "%s", szMessage );

	JET_ERR err;
	char szName[JET_cbNameMost+1];
	
	err = JetGetTableInfo( sesid, tableid, szName, sizeof( szName ), JET_TblInfoName );
	if( JET_errSuccess != err )
		{
		printf( "JetGetTableInfo returns %d\n", err );
		}
	else
		{
		char szBuf[JET_cbColumnMost + 16];
		sprintf( szBuf, "Table \"%s\"\n", szName );
		strcat( szMessage, szBuf );
		printf( "%s", szBuf );
		}

	err = JetGetCurrentIndex( sesid, tableid, szName, sizeof( szName ) );
	if( JET_errSuccess != err )
		{
		printf( "JetGetCurrentIndex returns %d\n", err );
		}
	else
		{
		char szBuf[JET_cbColumnMost + 16];
		sprintf( szBuf, "Index \"%s\"\n", szName );
		strcat( szMessage, szBuf );
		printf( "%s", szBuf );
		}

#ifdef DEBUG
	err = JetMove( sesid, tableid, JET_MoveFirst, NO_GRBIT );
	Assert( JET_errSuccess != err );
	err = JetSetCurrentIndex( sesid, tableid, NULL );
	Assert( JET_errSuccess != err );
	JET_TABLEID tableid2;
	err = JetDupCursor( sesid, tableid, &tableid2, NO_GRBIT );
	Assert( JET_errSuccess == err );
	err = JetCloseTable( sesid, tableid );
	Assert( JET_errSuccess != err );
	err = JetCloseTable( sesid, tableid2 );
	Assert( JET_errSuccess == err );
#endif

	err = JET_errSuccess;

	switch( cbtyp )
		{
		case JET_cbtypBeforeInsert:
		case JET_cbtypBeforeReplace:
		case JET_cbtypBeforeDelete:
			if( fMessageBox )
				{
				strcat( szMessage,
						"\n"
						"Allow the callback to succeed?" );
				const int id = MessageBox(
					NULL,
					szMessage,
					"YouHaveBadSymbols",
					MB_SERVICE_NOTIFICATION | MB_SYSTEMMODAL | MB_ICONQUESTION | MB_YESNOCANCEL );
				if( IDNO == id )
					{
					err = JET_errCallbackFailed;
					}
				else if( IDCANCEL == id )
					{
					fMessageBox = fFalse;
					}
				}
			break;
		}

	printf( "YouHaveBadSymbols returns %d.\n\n", err );
	return err;
	}
    
}

	
//  post-terminate edbg subsystem

void OSEdbgPostterm()
	{
	//  nop
	}

//  pre-init edbg subsystem

BOOL FOSEdbgPreinit()
	{
	//  nop

	return fTrue;
	}

	
//  terminate edbg subsystem

void OSEdbgTerm()
	{
	//  term OSSYM

	SymTerm();
	}

//  init edbg subsystem

ERR ErrOSEdbgInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\error.cxx ===
#include "osstd.hxx"


const _TCHAR szNewLine[] 		= _T( "\r\n" );

enum {
	cchPtrHexWidth = sizeof( void* ) * 8 / 4
};
#ifdef _WIN64
#define SZPTRFORMATPREFIX _T( "I64" )
#define SZPTRFORMAT _T( "%016" ) SZPTRFORMATPREFIX _T( "x" )
#else
#define SZPTRFORMATPREFIX _T( "l" )
#define SZPTRFORMAT _T( "%08" ) SZPTRFORMATPREFIX _T( "x" )
#endif

#ifdef RTM
#else

#include <imagehlp.h>

typedef DWORD IMAGEAPI WINAPI PFNUnDecorateSymbolName( PCSTR, PSTR, DWORD, DWORD );
typedef DWORD IMAGEAPI PFNSymSetOptions( DWORD );
typedef BOOL IMAGEAPI PFNSymCleanup( HANDLE );
typedef DWORD IMAGEAPI PFNSymGetOptions( VOID );
typedef BOOL IMAGEAPI PFNSymInitialize( HANDLE, PSTR, BOOL );
typedef BOOL IMAGEAPI PFNSymGetSearchPath( HANDLE, PSTR, DWORD );
typedef BOOL IMAGEAPI PFNSymSetSearchPath( HANDLE, PSTR );
typedef BOOL IMAGEAPI PFNSymGetSymFromAddr( HANDLE, void *, PDWORD_PTR, PIMAGEHLP_SYMBOL );
typedef BOOL IMAGEAPI PFNSymGetModuleInfo( HANDLE, void *, PIMAGEHLP_MODULE );
typedef DWORD_PTR IMAGEAPI PFNSymGetModuleBase( HANDLE, IN  DWORD_PTR );
typedef PVOID IMAGEAPI PFNSymFunctionTableAccess( HANDLE, DWORD_PTR );
typedef BOOL IMAGEAPI PFNSymGetLineFromAddr( HANDLE, void *, PDWORD, PIMAGEHLP_LINE );
typedef BOOL IMAGEAPI PFNStackWalk(	DWORD,
									HANDLE,
									HANDLE,
									LPSTACKFRAME,
									PVOID,
									PREAD_PROCESS_MEMORY_ROUTINE,
									PFUNCTION_TABLE_ACCESS_ROUTINE,
									PGET_MODULE_BASE_ROUTINE,
									PTRANSLATE_ADDRESS_ROUTINE );
typedef PIMAGE_NT_HEADERS IMAGEAPI PFNImageNtHeader ( IN PVOID );

PFNUnDecorateSymbolName*	pfnUnDecorateSymbolName;
PFNSymSetOptions*			pfnSymSetOptions;
PFNSymCleanup*				pfnSymCleanup;
PFNSymGetOptions*			pfnSymGetOptions;
PFNSymInitialize*			pfnSymInitialize;
PFNSymGetSearchPath*		pfnSymGetSearchPath;
PFNSymSetSearchPath*		pfnSymSetSearchPath;
PFNSymGetSymFromAddr*		pfnSymGetSymFromAddr;
PFNSymGetModuleInfo*		pfnSymGetModuleInfo;
PFNSymGetModuleBase*		pfnSymGetModuleBase;
PFNSymFunctionTableAccess*	pfnSymFunctionTableAccess;
PFNSymGetLineFromAddr*		pfnSymGetLineFromAddr;
PFNStackWalk*				pfnStackWalk;
PFNImageNtHeader*			pfnImageNtHeader;

LIBRARY libraryImagehlp;

//  term stack walker

void OSErrorIStackwalkTerm()
	{
	if ( libraryImagehlp )
		{
		if ( pfnSymCleanup )
			pfnSymCleanup( GetCurrentProcess() );
		UtilFreeLibrary( libraryImagehlp );
		}
	}

//  init stack walker

const BOOL FOSErrorIStackwalkInit()
	{
	//  if we have already been initialized, return success

	if ( libraryImagehlp )
		{
		return fTrue;
		}
		
	//  load dbghelp.dll or imagehlp.dll and the functions we need for dumping the callstack

	if ( !FUtilLoadLibrary( _T( "dbghelp.dll" ), &libraryImagehlp, fFalse ) &&
		!FUtilLoadLibrary( _T( "imagehlp.dll" ), &libraryImagehlp, fFalse ) )
		{
		goto HandleError;
		}
	pfnSymGetLineFromAddr = (PFNSymGetLineFromAddr*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymGetLineFromAddr" ) );
	if ( !( pfnStackWalk = (PFNStackWalk*)PfnUtilGetProcAddress( libraryImagehlp, _T( "StackWalk" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymFunctionTableAccess = (PFNSymFunctionTableAccess*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymFunctionTableAccess" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetModuleBase = (PFNSymGetModuleBase*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymGetModuleBase" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetModuleInfo = (PFNSymGetModuleInfo*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymGetModuleInfo" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetSymFromAddr = (PFNSymGetSymFromAddr*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymGetSymFromAddr" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymSetSearchPath = (PFNSymSetSearchPath*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymSetSearchPath" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetSearchPath = (PFNSymGetSearchPath*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymGetSearchPath" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymInitialize = (PFNSymInitialize*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymInitialize" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetOptions = (PFNSymGetOptions*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymGetOptions" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymCleanup = (PFNSymCleanup*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymCleanup" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymSetOptions = (PFNSymSetOptions*)PfnUtilGetProcAddress( libraryImagehlp, _T( "SymSetOptions" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnUnDecorateSymbolName = (PFNUnDecorateSymbolName*)PfnUtilGetProcAddress( libraryImagehlp, _T( "UnDecorateSymbolName" ) ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnImageNtHeader = (PFNImageNtHeader*)PfnUtilGetProcAddress( libraryImagehlp, _T( "ImageNtHeader" ) ) ) )
		{
		goto HandleError;
		}

	//  initialize stack walker

	DWORD dwOptions;
	dwOptions = pfnSymGetOptions();
	pfnSymSetOptions( dwOptions | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES );
	if ( !pfnSymInitialize( GetCurrentProcess(), NULL, TRUE ) )
		{
		pfnSymInitialize = NULL;
		goto HandleError;
		}

	_TCHAR szOldPath[4 * _MAX_PATH];
	if ( pfnSymGetSearchPath( GetCurrentProcess(), szOldPath, sizeof( szOldPath ) ) )
		{
		_TCHAR szNewPath[6 * _MAX_PATH];
		_TCHAR szDrive[_MAX_DRIVE];
		_TCHAR szDir[_MAX_DIR];
		_TCHAR szPath[_MAX_PATH];

		szNewPath[ 0 ] = 0;
		
		_tcscat( szNewPath, szOldPath );
		_tcscat( szNewPath, ";" );
		
		_tsplitpath( SzUtilImagePath(), szDrive, szDir, NULL, NULL );
		_tmakepath( szPath, szDrive, szDir, NULL, NULL );
		_tcscat( szNewPath, szPath );
		_tcscat( szNewPath, ";" );
		
		_tsplitpath( SzUtilProcessPath(), szDrive, szDir, NULL, NULL );
		_tmakepath( szPath, szDrive, szDir, NULL, NULL );
		_tcscat( szNewPath, szPath );
		
		pfnSymSetSearchPath( GetCurrentProcess(), szNewPath );
		}

	return fTrue;

HandleError:
	OSErrorIStackwalkTerm();
	return fFalse;
	}


INLINE BOOL FUtilStackWalk( STACKFRAME* pstkfrm, CONTEXT* pctxt )
	{

	return	pfnStackWalk(	
#if defined( _M_IX86 )
						IMAGE_FILE_MACHINE_I386,
#elif defined( _M_ALPHA )
						IMAGE_FILE_MACHINE_ALPHA,
#elif defined( _M_IA64 )
						IMAGE_FILE_MACHINE_IA64,
#else
						IMAGE_FILE_MACHINE_UNKNOWN,
#endif
						GetCurrentProcess(),
						GetCurrentThread(),
						pstkfrm,
						pctxt,
						NULL,
						pfnSymFunctionTableAccess,
						pfnSymGetModuleBase,
						NULL );
	}

void UtilDumpFrame( CPRINTF* const pcprintf, const DWORD iFrame, const STACKFRAME* const pstkfrm )
	{
	//  do not dump this frame if the PC is NULL
	
	void *pvAddress = (void *)pstkfrm->AddrPC.Offset;
	if ( !pvAddress )
		{
		return;
		}
	
	//  dump the frame number, frame index, return address, and first four parameters
	
	(*pcprintf)(	_T( "%02x  " )
					SZPTRFORMAT _T( "  " )
					SZPTRFORMAT _T( "  " )
					SZPTRFORMAT _T( " " )
					SZPTRFORMAT _T( " " )
					SZPTRFORMAT _T( " " )
					SZPTRFORMAT _T( " " ),
					iFrame,
					pstkfrm->AddrFrame.Offset,
					pstkfrm->AddrReturn.Offset,
					pstkfrm->Params[0],
					pstkfrm->Params[1],
					pstkfrm->Params[2],
					pstkfrm->Params[3] );
	
	//  dump the name of the module that contains this address

	IMAGEHLP_MODULE		im			= { sizeof( IMAGEHLP_MODULE ) };
	
	if ( pfnSymGetModuleInfo( GetCurrentProcess(), pvAddress, &im ) )
		{
		(*pcprintf)( _T( "%s!" ), im.ModuleName );
		}

	//  dump the name of the symbol that contains this address
	
	BYTE				rgbData[ sizeof( IMAGEHLP_SYMBOL ) + IFileSystemAPI::cchPathMax ] = { 0 };
	IMAGEHLP_SYMBOL*	pis				= (IMAGEHLP_SYMBOL *)rgbData;
	DWORD_PTR			dwDisplacement	= 0;
	DWORD				dwDisplacementDword = 0;
	pis->SizeOfStruct	= sizeof( IMAGEHLP_SYMBOL );
	pis->MaxNameLength	= IFileSystemAPI::cchPathMax;

	if ( pfnSymGetSymFromAddr( GetCurrentProcess(), pvAddress, &dwDisplacement, pis ) )
		{
		_TCHAR szSymbol[256];
		if ( pfnUnDecorateSymbolName( pis->Name, szSymbol, sizeof( szSymbol ), UNDNAME_COMPLETE ) )
			{
			(*pcprintf)( _T( "%s+0x%" ) SZPTRFORMATPREFIX _T( "x" ), szSymbol, dwDisplacement );
			}
		else
			{
			(*pcprintf)( _T( "%s+0x%" ) SZPTRFORMATPREFIX _T( "x" ), pis->Name, dwDisplacement );
			}
		}
	else
		{
		(*pcprintf)( SZPTRFORMAT, pvAddress );
		}

	IMAGEHLP_LINE il = { sizeof( IMAGEHLP_LINE ) };
	if (	pfnSymGetLineFromAddr &&
			pfnSymGetLineFromAddr( GetCurrentProcess(), pvAddress, &dwDisplacementDword, &il ) )
		{
		CHAR szDrive[_MAX_DRIVE];
		CHAR szDir[_MAX_DIR];
		CHAR szFname[_MAX_FNAME];
		CHAR szExt[_MAX_EXT];
		_splitpath( il.FileName, szDrive, szDir, szFname, szExt );

		CHAR szFile[_MAX_PATH];
		_makepath( szFile, "", "", szFname, szExt );
		
		(*pcprintf)( _T( " [ %s @ %d ]" ), szFile, il.LineNumber );
		}

	BOOL fTimestampMismatch = fFalse;
	BOOL fChecksumMismatch = fFalse;
	IMAGE_NT_HEADERS* pnh = pfnImageNtHeader( (void*)im.BaseOfImage );
	if (	pnh &&
			pnh->FileHeader.TimeDateStamp != im.TimeDateStamp )
		{
		fTimestampMismatch = fTrue;
		}
	if (	pnh &&
			pnh->FileHeader.SizeOfOptionalHeader >= IMAGE_SIZEOF_NT_OPTIONAL_HEADER &&
			pnh->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC &&
			pnh->OptionalHeader.CheckSum != im.CheckSum &&
			(	pnh->FileHeader.TimeDateStamp != im.TimeDateStamp ||
				_stricmp( im.ModuleName, "kernel32" ) &&
				_stricmp( im.ModuleName, "ntdll" ) ) )
		{
		fChecksumMismatch = fTrue;
		}

	if ( fTimestampMismatch || fChecksumMismatch )
		{
		_TCHAR szImageFile[_MAX_PATH];
		_TCHAR szSymbolFile[_MAX_PATH];

		_tfullpath( szImageFile, im.ImageName, _MAX_PATH );
		_tfullpath( szSymbolFile, im.LoadedImageName, _MAX_PATH );
		
		(*pcprintf)(	_T( "    * %s%s%s mismatch between image file %s and symbol file %s" ),
						fTimestampMismatch ? _T( "timestamp" ) : _T( "" ),
						fTimestampMismatch && fChecksumMismatch ? _T( " and " ) : _T( "" ),
						fChecksumMismatch ? _T( "checksum" ) : _T( "" ),
						szImageFile,
						szSymbolFile );
		}

	if ( !pnh )
		{
		(*pcprintf)(	_T( "    * unknown image" ) );
		}
		
	(*pcprintf)( _T( "%s" ), szNewLine );
	}

void UtilDumpCallstack( CPRINTF* const pcprintf, const CONTEXT* const pctxt = NULL, DWORD cFrameSkip = 0 )
	{
	CONTEXT		ctxt	= { 0 };
	STACKFRAME	stkfrm	= { 0 };

	if ( !pctxt )
		{
		ctxt.ContextFlags = CONTEXT_FULL;
		if ( GetThreadContext( GetCurrentThread(), &ctxt ) )
			{
			cFrameSkip = 1;
			}
		}
	else
		{
		ctxt	= *pctxt;
		}

	//	Notice that we copy *pctxt. If we allow StackWalk() to write to
	//	*pctxt and pctxt points to the memory returned from
	//	GetExceptionInformation() (which callers are likely to pass us), the
	//	system will kill our process (seen on IA64).

	stkfrm.AddrPC.Mode = AddrModeFlat;
	stkfrm.AddrStack.Mode = AddrModeFlat;
	stkfrm.AddrFrame.Mode = AddrModeFlat;

#if defined( _M_IX86 )
	stkfrm.AddrPC.Offset	= ctxt.Eip;
	stkfrm.AddrStack.Offset	= ctxt.Esp;
	stkfrm.AddrFrame.Offset	= ctxt.Ebp;
#elif defined( _M_ALPHA )
	stkfrm.AddrPC.Offset	= ctxt.Fir;
	stkfrm.AddrStack.Offset	= ctxt.IntSp;
	stkfrm.AddrFrame.Offset	= ctxt.IntSp;
#elif defined( _M_IA64 )
	//	Leave zeroed values as per sample code
#else
#endif

    //  dump the call stack header

    (*pcprintf)( _T( "%s" ), szNewLine );
    (*pcprintf)( _T( "%s" ), szNewLine );
    (*pcprintf)( _T( "PID / TID:  %d / %d%s" ), DwUtilProcessId(), DwUtilThreadId(), szNewLine );
    (*pcprintf)( _T( "%s" ), szNewLine );
    (*pcprintf)( _T( "#   " )
    	_T( "%-*s  " )
    	_T( "%-*s  " )
    	_T( "%-*s " )
    	_T( "%-*s " )
    	_T( "%-*s " )
    	_T( "%-*s " )
    	_T( "Module!Function%s" ),
    	cchPtrHexWidth,
    	_T( "Frame" ),
    	cchPtrHexWidth,
    	_T( "Return" ),
    	cchPtrHexWidth,
    	_T( "Param1" ),
    	cchPtrHexWidth,
    	_T( "Param2" ),
    	cchPtrHexWidth,
    	_T( "Param3" ),
    	cchPtrHexWidth,
    	_T( "Param4" ),
    	szNewLine );
	for ( DWORD i = 0; i < cchPtrHexWidth * 6; ++i )
		{
		(*pcprintf)( _T( "-" ) );
		}
	(*pcprintf)( _T( "---------------------------%s" ), szNewLine );

	//  we successfully init the stack walker

	if ( FOSErrorIStackwalkInit() )
		{
		//  walk up the stack as far as possible dumping the symbol names

		DWORD iFrame = 0;
		while ( FUtilStackWalk( &stkfrm, &ctxt ) )
			{
			if ( cFrameSkip )
				{
				cFrameSkip--;
				}
			else
				{
				UtilDumpFrame( pcprintf, iFrame++, &stkfrm );
				}
			}
		}

	//  we did not successfully init the stack walker

	else
		{
		//  print error message

	    (*pcprintf)( _T( "The stack could not be dumped due to a run time error.%s" ), szNewLine );
		}

	//  dump the call stack footer

    (*pcprintf)( _T( "%s" ), szNewLine );
	}

#endif	//	RTM


//  returns fTrue if a debugger is attached to this process

BOOL IsDebuggerAttached()
	{
	typedef WINBASEAPI BOOL WINAPI PFNIsDebuggerPresent( VOID );

	HMODULE					hmodKernel32			= NULL;
	PFNIsDebuggerPresent*	pfnIsDebuggerPresent	= NULL;
	BOOL					fDebuggerPresent		= fFalse;

	if ( !( hmodKernel32 = LoadLibrary( _T( "kernel32.dll" ) ) ) )
		{
		goto NoIsDebuggerPresent;
		}
	if ( !( pfnIsDebuggerPresent = (PFNIsDebuggerPresent*)GetProcAddress( hmodKernel32, _T( "IsDebuggerPresent" ) ) ) )
		{
		goto NoIsDebuggerPresent;
		}

	fDebuggerPresent = pfnIsDebuggerPresent();

NoIsDebuggerPresent:
	if ( hmodKernel32 )
		{
		FreeLibrary( hmodKernel32 );
		}
	return fDebuggerPresent;
	}

//  returns fTrue if a debugger can be attached to this process

BOOL IsDebuggerAttachable()
	{
	extern volatile DWORD tidDLLEntryPoint;

	return tidDLLEntryPoint != GetCurrentThreadId();
	}


void KernelDebugBreakPoint()
	{
	DebugBreak();
	}

void UserDebugBreakPoint()
	{
	//  if this is an NT box then we must prevent ourselves from falling into
	//  the kernel debugger by issuing a debug break with no debugger attached

	OSVERSIONINFO osvi;
	memset( &osvi, 0, sizeof( osvi ) );
	osvi.dwOSVersionInfoSize = sizeof( osvi );

	if (	GetVersionEx( &osvi ) &&
			osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
			!IsDebuggerAttached() )
		{
		//  if it is possible to attach a debugger to the current process then
		//  we will do so
		
		if ( IsDebuggerAttachable() )
			{
			while ( !IsDebuggerAttached() )
				{
				//  get the AE Debug command line if present
				
				char szCmdFormat[ 256 ];
		
				if ( !GetProfileString(	"AeDebug",
										"Debugger",
										NULL,
										szCmdFormat,
										sizeof( szCmdFormat ) - 1 ) )
					{
					szCmdFormat[ 0 ] = 0;
					}

				//  ignore the AE Debug command line if it is pointing to Dr. Watson

				char szCmdFname[ 256 ];
				
				_splitpath( szCmdFormat, NULL, NULL, szCmdFname, NULL );
				if ( !_stricmp( szCmdFname, "drwtsn32" ) )
					{
					szCmdFormat[ 0 ] = 0;
					}

				//  try to use the AE Debug command line to start the debugger

	            SECURITY_ATTRIBUTES	sa;
	            HANDLE				hEvent;
	            STARTUPINFO			si;
	            PROCESS_INFORMATION	pi;
	            CHAR				szCmd[ 256 ];

	            sa.nLength				= sizeof( SECURITY_ATTRIBUTES );
	            sa.lpSecurityDescriptor	= NULL;
	            sa.bInheritHandle		= TRUE;

	            hEvent = CreateEvent( &sa, TRUE, FALSE, NULL );

	            memset( &si, 0, sizeof( STARTUPINFO ) );
	            
	            sprintf( szCmd, szCmdFormat, GetCurrentProcessId(), hEvent );
	            
	            si.cb			= sizeof( STARTUPINFO );
	            si.lpDesktop	= _T( "Winsta0\\Default" );
	            
	            if (	hEvent &&
	            		CreateProcess(	NULL,
										szCmd,
										NULL,
										NULL,
										TRUE,
										0,
										NULL,
										NULL,
										&si,
										&pi ) )
					{
					//	wait for debugger to load (force timeout to ensure we
					//	don't hang if "-e" was omitted from the command line)
					for ( DWORD dw = WaitForSingleObjectEx( hEvent, 3000, TRUE );
						( WAIT_IO_COMPLETION == dw || WAIT_TIMEOUT == dw ) && !IsDebuggerAttached();
						dw = WaitForSingleObjectEx( hEvent, 30000, TRUE ) )
						{
						NULL;
						}
					}

				//  if we couldn't start the debugger, prompt for one to be installed
				
				else
					{
					char szMessage[ 1024 ];

					if ( !szCmdFormat[ 0 ] )
						{
						sprintf( szMessage, "No debugger is installed on this machine.  Please install one now." );
						}
					else
						{
						DWORD	gle			= GetLastError();
						char*	szMsgBuf	= NULL;
						
						FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
											FORMAT_MESSAGE_FROM_SYSTEM |
											FORMAT_MESSAGE_MAX_WIDTH_MASK ),
									    NULL,
									    gle,
									    MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
									    (LPTSTR) &szMsgBuf,
									    0,
									    NULL );
						sprintf(	szMessage,
									"The debugger could not be attached to process %d!  Win32 error %d%s%s",
									GetCurrentProcessId(),
									gle,
									szMsgBuf ? ":  " : ".",
									szMsgBuf ? szMsgBuf : "" );
						LocalFree( (LPVOID)szMsgBuf );
						}
					
					if ( MessageBox(	NULL,
										szMessage,
										SzUtilImageVersionName(),
										MB_SERVICE_NOTIFICATION | MB_SYSTEMMODAL | MB_ICONSTOP | MB_RETRYCANCEL ) == IDCANCEL )
						{
						break;
						}
					}
				if ( hEvent )
					{
					CloseHandle( hEvent );
					}
				}
			}

		//  if we make it here and there is still no debugger attached, we will
		//  just kill the process

		if ( !IsDebuggerAttached() )
			{
			TerminateProcess( GetCurrentProcess(), -1 );
			}
		}

	//  stop in the debugger

	DebugBreak();
	}


#if defined( DEBUG ) || defined( MEM_CHECK ) || defined( ENABLE_EXCEPTIONS )

const _TCHAR szReleaseHdr[] 	= _T( "Rel. " );
const _TCHAR szFileHdr[] 		= _T( ", File " );
const _TCHAR szLineHdr[] 		= _T( ", Line " );
const _TCHAR szErrorHdr[] 		= _T( ", Err. " );
const _TCHAR szMsgHdr[] 		= _T( ": " );
const _TCHAR szPidHdr[] 		= _T( "PID: " );
const _TCHAR szTidHdr[] 		= _T( ", TID: " );

const _TCHAR szAssertFile[] 	= _T( "assert.txt" );
const _TCHAR szAssertHdr[] 		= _T( "Assertion Failure: " );

const _TCHAR szAssertInfo[]		= _T( "More complete information can be found in:  " );

const _TCHAR szAssertCaption[] 	= _T( "JET Assertion Failure" );
const _TCHAR szAssertPrompt[]	= _T( "Choose OK to continue execution or CANCEL to debug the process." );
const _TCHAR szAssertPrompt2[]	= _T( "Choose OK to continue execution or CANCEL to terminate the process (attaching the debugger is impossible during process initialization and termination)." );

#endif	//	DEBUG || MEM_CHECK || ENABLE_EXCEPTIONS

#ifdef DEBUG

int fNoWriteAssertEvent = 0;

/*      write assert to assert.txt
/*      may raise alert
/*      may log to event log
/*      may pop up
/*
/*      condition parameters
/*      assemble monolithic string for assert.txt,
/*              alert and event log
/*      assemble separated string for pop up
/*      
/**/

LOCAL HANDLE	hsemAssert;
LOCAL BOOL		fAssertFired	= fFalse;

LOCAL DWORD	pidAssert = GetCurrentProcessId();
LOCAL DWORD	tidAssert = GetCurrentThreadId();
LOCAL const _TCHAR * szFilenameAssert;
LOCAL long lLineAssert;

EExceptionFilterAction ExceptionFilterDumpCallstack( CPRINTF* const pcprintf, EXCEPTION_POINTERS* const pexp, const DWORD cFrameSkip )
{
	UtilDumpCallstack( pcprintf, pexp->ContextRecord, cFrameSkip );
	return efaExecuteHandler;
}

#pragma warning( disable : 4509 )
void __stdcall AssertFail( const _TCHAR* szMessage, const _TCHAR* szFilename, long lLine )
	{
	/*  acquire hsemAssert to prevent additional asserts from popping up
	/*  during debugger startup
	/**/
	WaitForSingleObjectEx( hsemAssert, INFINITE, FALSE );

	fAssertFired = fTrue;

	_TCHAR          szAssertText[1024];
	int             id;
	DWORD           dw;

	/*      get last error before another system call
	/**/
	dw = GetLastError();

	szFilenameAssert = szFilename;
	lLineAssert = lLine;

	/*      select file name from file path
	/**/
	szFilename = ( NULL == _tcsrchr( szFilename, _T( bPathDelimiter ) ) ) ? szFilename : _tcsrchr( szFilename, _T( bPathDelimiter ) ) + sizeof( TCHAR );

	/*      assemble monolithic assert string
	/**/
	_stprintf(
		szAssertText,
		_T( "%s%s%s%s%d.%d%s%s%s%d: %s%d%s%s%s" ),
		szNewLine,
		szNewLine,
		szAssertHdr,
		szReleaseHdr,
		DwUtilImageBuildNumberMajor(),
		DwUtilImageBuildNumberMinor(),
		szFileHdr,
		szFilename,
		szLineHdr,
		lLine,
		szTidHdr,
		DwUtilThreadId(),	
		szMsgHdr,
		szMessage,
		szNewLine
		);

	/******************************************************
	/**/

	/*      if event log environment variable set then write
	/*      assertion to event log.
	/**/
	if ( !fNoWriteAssertEvent )
		{
		const _TCHAR *	rgszT[4];
		_TCHAR			szPID[10];
		
		rgszT[0] = SzUtilProcessName();
	 
		_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
		rgszT[1] = szPID;

		rgszT[2] = "";		//	no instance name
		
		rgszT[3] = szAssertText;

		OSEventReportEvent( SzUtilImageVersionName(), eventError, GENERAL_CATEGORY, PLAIN_TEXT_ID, 4, rgszT );
		}

	/*  make sure that the log is flushed to facilitate debugging, ignoring any
	/*	errors that may be returned
	/**/
//	extern CAutoResetSignal m_asigLogFlush;
//	m_asigLogFlush.Set();
	
		{
		CPRINTFFILE cprintffileAssert( szAssertFile );
		cprintffileAssert( _T( "%s" ), szAssertText );

#if defined( _M_IX86 )
		OSVERSIONINFO osvi;
		memset( &osvi, 0, sizeof( osvi ) );
		osvi.dwOSVersionInfoSize = sizeof( osvi );

		if (	GetVersionEx( &osvi ) &&
			VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
			{
			//  We've been dumping callstacks in NT from this context for ages
			//  without any problems, so why mess with a good thing?

			UtilDumpCallstack( &cprintffileAssert );
			}
		else
#endif
			{
			enum {
				excCode = 0xC0DE0E5E
			};
			
			__try
				{
				RaiseException( excCode, 0, 0, NULL );
				}
			__except( excCode == GetExceptionCode() ?
				ExceptionFilterDumpCallstack(
					&cprintffileAssert,
					GetExceptionInformation(),
#if defined( _M_IX86 )
					0	// X86 platform has special hacks so RaiseException isn't on the callstack
#elif defined( _M_IA64 )
					2	// remove KERNEL32!RaiseException and NTDLL!RtlRaiseException from callstack
#else
					0
#endif
					) :
				efaContinueSearch )
				{
				}
			}
		}

	extern UINT g_wAssertAction;
	if ( g_wAssertAction == JET_AssertExit )
		{
		TerminateProcess( GetCurrentProcess(), -1 );
		}
	else if ( g_wAssertAction == JET_AssertBreak )
		{
		KernelDebugBreakPoint();
		}
	else if ( g_wAssertAction == JET_AssertStop )
		{
		for( ;; )
			{
			/*	wait for developer, or anyone else, to debug the failure
			/**/
			Sleep( 100 );
			}
		}
	else if ( g_wAssertAction == JET_AssertMsgBox )
		{
		_TCHAR	szT[10];
		
		/*	assemble monolithic assert string
		/**/
		szAssertText[0] = '\0';
		/*	copy version number to message
		/**/
		_tcscat( szAssertText, szReleaseHdr );
		_ltot( DwUtilImageBuildNumberMajor(), szT, 10 );
		_tcscat( szAssertText, szT );
		_tcscat( szAssertText, _T( "." ) );
		_ltot( DwUtilImageBuildNumberMinor(), szT, 10 );
		_tcscat( szAssertText, szT );
		/*      file name
		/**/
		_tcscat( szAssertText, szFileHdr );
		_tcscat( szAssertText, szFilename );
		/*      line number
		/**/
		_tcscat( szAssertText, szLineHdr );
		_ultot( lLine, szT, 10 );
		_tcscat( szAssertText, szT );
		/*      error
		/**/
		if ( dw && dw != ERROR_IO_PENDING )
			{
			_tcscat( szAssertText, szErrorHdr );
			_ltot( dw, szT, 10 );
			_tcscat( szAssertText, szT );
			}
		_tcscat( szAssertText, szNewLine );
		/*      assert txt
		/**/
		_tcscat( szAssertText, szMessage );
		_tcscat( szAssertText, szNewLine );

		/*	process and thread id
		/**/
		_tcscat( szAssertText, szPidHdr );
		_ultot( DwUtilProcessId(), szT, 10 );
		_tcscat( szAssertText, szT );
		_tcscat( szAssertText, szTidHdr );
		_ultot( DwUtilThreadId(), szT, 10 );
		_tcscat( szAssertText, szT );

		/*  assert file notification
		/**/
		_tcscat( szAssertText, szNewLine );
		_tcscat( szAssertText, szNewLine );
		_tcscat( szAssertText, szAssertInfo );
		_TCHAR szAssertFilePath[_MAX_PATH];		
		_tfullpath( szAssertFilePath, szAssertFile, _MAX_PATH );
		_tcscat( szAssertText, szAssertFilePath );

		/*  assert dialog action prompt
		/**/
		_tcscat( szAssertText, szNewLine );
		_tcscat( szAssertText, szNewLine );
		_tcscat( szAssertText, IsDebuggerAttachable() || IsDebuggerAttached() ? szAssertPrompt : szAssertPrompt2 );

		id = MessageBox(	NULL,
							szAssertText,
							szAssertCaption,
							MB_SERVICE_NOTIFICATION | MB_SYSTEMMODAL | MB_ICONSTOP |
							( IsDebuggerAttachable() || IsDebuggerAttached() ? MB_OKCANCEL : MB_OK ) );

		BOOL	fOKAllowed		= fFalse;
		_TCHAR	szComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
		DWORD	cbComputerName	= sizeof( szComputerName );
		fOKAllowed = fOKAllowed || !GetComputerName( szComputerName, &cbComputerName );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "ADAMFOXMAN" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "ADAMGR" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "ANDREIMA" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "ANDYGO" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "ESE" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "EXIFS" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "IVANTRIN" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "JLIEM" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "LAURIONB" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "PHILHU" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "SYJIANG" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "JEREMYK" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "MRORKE" ) );
		fOKAllowed = fOKAllowed || szComputerName == _tcsstr( szComputerName, _T( "SPENCERLOW" ) );
		
		if ( IDOK != id || !fOKAllowed )
			{
			UserDebugBreakPoint();
			}
		}

	fAssertFired = fFalse;
	ReleaseSemaphore( hsemAssert, 1, NULL );

	return;
	}
#pragma warning( default : 4509 )

	
void AssertErr( const ERR err, const _TCHAR* szFileName, const long lLine )
	{
	_TCHAR szMsg[32];

	if ( JET_errSuccess == err )
		_tcscpy( szMsg, _T( "Bogus Assert" ) );  // only call this routine if we know err != JET_errSuccess
	else
		_stprintf( szMsg, _T( "Unexpected error: %d" ), err );
		
	AssertFail( szMsg, szFileName, lLine );
	}

void AssertTrap( const ERR err, const _TCHAR* szFileName, const long lLine )
	{
	_TCHAR szMsg[32];

	if ( JET_errSuccess == err )
		_tcscpy( szMsg, _T( "Bogus Assert" ) );  // only call this routine if we know err != JET_errSuccess
	else
		_stprintf( szMsg, _T( "Error Trap: %d" ), err );
		
	AssertFail( szMsg, szFileName, lLine );
	}

#else  //  !DEBUG

void __stdcall AssertFail( const _TCHAR* szMessage, const _TCHAR* szFilename, long lLine )
	{
	const _TCHAR *	szFilenameNoPath;
	_TCHAR			szLine[8];
	const _TCHAR *	rgszT[5];
	_TCHAR			szPID[10];

	rgszT[0] = SzUtilProcessName();
 
	_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
	rgszT[1] = szPID;

	rgszT[2] = "";		//	no instance name
	
	szFilenameNoPath = ( NULL == _tcsrchr( szFilename, _T( bPathDelimiter ) ) ) ? szFilename : _tcsrchr( szFilename, _T( bPathDelimiter ) ) + sizeof( TCHAR );
	rgszT[3] = szFilenameNoPath;

	_itot( lLine, szLine, 10 );
	rgszT[4] = szLine;

	OSEventReportEvent(	SzUtilImageVersionName(),
						eventInformation,
						GENERAL_CATEGORY,
						INTERNAL_TRACE_ID,
						5,
						rgszT );

#ifdef RTM
#else  //  !RTM
	UserDebugBreakPoint();
#endif  //  RTM
	}

#endif  //  DEBUG


//  Enforces

//  Enforce Failure action
//
//  called when a strictly enforced condition has been violated

BOOL fOverrideEnforceFailure = fFalse;

void __stdcall EnforceFail( const _TCHAR* szMessage, const _TCHAR* szFilename, long lLine )
	{
	AssertFail( szMessage, szFilename, lLine );

	//  UNDONE:  log an event

	if ( !fOverrideEnforceFailure )
		{
		TerminateProcess( GetCurrentProcess(), -1 );
		}
	}


//  Exceptions

#ifdef ENABLE_EXCEPTIONS

//  Exception Information function for use by an exception filter
//
//  NOTE:  must be called in the scope of the exception filter expression

typedef DWORD_PTR EXCEPTION;

EXCEPTION (*pfnExceptionInfo)();

//  Exception Failure action
//
//  used as the filter whenever any exception that occurs is considered a failure

const _TCHAR szExceptionHdr[]		= _T( "Exception: " );
const _TCHAR szExceptionCaption[] 	= _T( "JET Exception" );
const _TCHAR szExceptionInfo[]		= _T( "More complete information can be found in:  " );
const _TCHAR szExceptionPrompt[]	= _T( "Choose OK to terminate the process or CANCEL to debug the process." );
const _TCHAR szExceptionPrompt2[]	= _T( "Choose OK to terminate the process (attaching the debugger is impossible during process initialization and termination)." );

//  ================================================================
LOCAL BOOL ExceptionDialog( const _TCHAR szException[] )
//  ================================================================
	{
	_TCHAR		szMessage[1024];
#ifdef RTM
	_TCHAR *	szFmt			= _T( "%s%d.%d%s%s%s%s%s%d%s%d%s%s%s" );
#else
	_TCHAR *	szFmt			= _T( "%s%d.%d%s%s%s%s%s%d%s%d%s%s%s%s%s%s%s" );
	_TCHAR		szExceptionFilePath[_MAX_PATH];		
	_tfullpath( szExceptionFilePath, szAssertFile, _MAX_PATH );
#endif	
	
	_stprintf( szMessage, szFmt,
		szReleaseHdr,
		DwUtilImageBuildNumberMajor(),
		DwUtilImageBuildNumberMinor(),
		szMsgHdr,
		szNewLine,
		szException,
		szNewLine,
		szPidHdr,
		DwUtilProcessId(),
		szTidHdr,
		DwUtilThreadId(),
		szNewLine,
		szNewLine,
#ifdef RTM
#else
		szExceptionInfo,
		szExceptionFilePath,
		szNewLine,
		szNewLine,
#endif		
		IsDebuggerAttachable() || IsDebuggerAttached() ? szExceptionPrompt : szExceptionPrompt2
		);

	const int id = MessageBox(
						NULL,
						szMessage,
						szExceptionCaption,
						MB_SERVICE_NOTIFICATION | MB_SYSTEMMODAL | MB_ICONSTOP |
						( IsDebuggerAttachable() || IsDebuggerAttached() ? MB_OKCANCEL : MB_OK ) );
	return ( IDOK != id );
	}


HANDLE	hsemExcept;
BOOL	fRetryCode = fFalse;

//  ================================================================
EExceptionFilterAction _ExceptionFail( const _TCHAR* szMessage, EXCEPTION exception )
//  ================================================================
	{
	PEXCEPTION_POINTERS pexp 			= PEXCEPTION_POINTERS( exception );
	PEXCEPTION_RECORD	pexr			= pexp->ExceptionRecord;
	PCONTEXT			pcxr			= pexp->ContextRecord;
	
	const DWORD			dwException		= pexr->ExceptionCode;
	const VOID * const	pvAddress		= pexr->ExceptionAddress;

	HANDLE				hFile			= NULL;
	DWORD				cchActual		= 0;

	const _TCHAR *		szException		= _T( "UNKNOWN" );

	//  this exception has already been trapped once, so the user must have
	//  allowed the exception to be passed on to the application by the
	//  debugger

	if ( fRetryCode )
		{
		//  let any other exception filters on the stack handle the error
		
		fRetryCode = fFalse;
		return efaContinueSearch;
		}
			
	//  prevent other exceptions from firing while we are handling this one

	WaitForSingleObjectEx( hsemExcept, INFINITE, FALSE );

#if defined(DEBUG)
	//  we are here as the result of an assertion failure
	extern BOOL fAssertFired;
	const BOOL	fUseSystemExceptionHandler		= fAssertFired;
#elif defined(RTM)
	//	this is shipping code, so don't pop up a dialog
	const BOOL	fUseSystemExceptionHandler		= fTrue;
#else
	//	pop up a dialog
	const BOOL	fUseSystemExceptionHandler		= fFalse;
#endif

	if ( fUseSystemExceptionHandler )
		{
		//  display the system unhandled exception dialog

		EExceptionFilterAction efa = EExceptionFilterAction( UnhandledExceptionFilter( pexp ) );

		//  the user chose to debug the application

		if ( efa == efaContinueSearch )
			{
			//  re-execute the debug break to halt the debugger in the assert code
			
			ReleaseSemaphore( hsemExcept, 1, NULL );
			return efaContinueExecution;
			}

		//  the user chose to terminate the application

		else
			{
			//  terminate the process

			TerminateProcess( GetCurrentProcess(), -1 );

			//  never reached

			return efaExecuteHandler;
			}
		}


#ifdef RTM
#else

	//  start our handler
	
	switch( dwException )
		{
#ifdef SZEXP
#error	SZEXP already defined
#endif	//	SZEXP

#define SZEXP( EXP )					\
		case EXP:						\
			szException = _T( #EXP );	\
			break;

		SZEXP( EXCEPTION_ACCESS_VIOLATION );
		SZEXP( EXCEPTION_ARRAY_BOUNDS_EXCEEDED );
		SZEXP( EXCEPTION_BREAKPOINT );
		SZEXP( EXCEPTION_DATATYPE_MISALIGNMENT );
		SZEXP( EXCEPTION_FLT_DENORMAL_OPERAND );
		SZEXP( EXCEPTION_FLT_DIVIDE_BY_ZERO );
		SZEXP( EXCEPTION_FLT_INEXACT_RESULT );
		SZEXP( EXCEPTION_FLT_INVALID_OPERATION );
		SZEXP( EXCEPTION_FLT_OVERFLOW );
		SZEXP( EXCEPTION_FLT_STACK_CHECK );
		SZEXP( EXCEPTION_FLT_UNDERFLOW );
		SZEXP( EXCEPTION_ILLEGAL_INSTRUCTION );
		SZEXP( EXCEPTION_IN_PAGE_ERROR );
		SZEXP( EXCEPTION_INT_DIVIDE_BY_ZERO );
		SZEXP( EXCEPTION_INT_OVERFLOW );
		SZEXP( EXCEPTION_INVALID_DISPOSITION );
		SZEXP( EXCEPTION_NONCONTINUABLE_EXCEPTION );
		SZEXP( EXCEPTION_PRIV_INSTRUCTION );
		SZEXP( EXCEPTION_SINGLE_STEP );
		SZEXP( EXCEPTION_STACK_OVERFLOW );

#undef SZEXP
		}


	//  print the exception information and callstack to our assert file

		{
		CPRINTFFILE cprintffileAssert( szAssertFile );

		cprintffileAssert(	_T( "JET Exception: Function \"%s\" raised exception 0x%08X (%s) at address 0x%0*I64X (base:0x%0*I64X, exr:0x%0*I64X, cxr:0x%0*I64X)." ),
							szMessage,
							dwException,
							szException,
							sizeof( LONG_PTR ) * 2,
							(QWORD)pvAddress,
							sizeof( LONG_PTR ) * 2,
							(QWORD)PvUtilImageBaseAddress(),
							sizeof( LONG_PTR ) * 2,
							(QWORD)pexr,
							sizeof( LONG_PTR ) * 2,
							(QWORD)pcxr );

		UtilDumpCallstack( &cprintffileAssert, pexp->ContextRecord );
		}


	//  ask user what they want to do with the exception

	_TCHAR szT[256];
	_stprintf( 	szT,
				_T( "JET Exception: Function \"%s\" raised exception 0x%08X (%s) at address 0x%0*I64X (base:0x%0*I64X, exr:0x%0*I64X, cxr:0x%0*I64X)." ),
				szMessage,
				dwException,
				szException,
				sizeof( LONG_PTR ) * 2,
				(QWORD)pvAddress,
				sizeof( LONG_PTR ) * 2,
				(QWORD)PvUtilImageBaseAddress(),
				sizeof( LONG_PTR ) * 2,
				(QWORD)pexr,
				sizeof( LONG_PTR ) * 2,
				(QWORD)pcxr );

	BOOL fDebug = ExceptionDialog( szT );

	//  the user chose to debug the process

	if ( fDebug )
		{
		//  Here is the exception that has caused the program failure:

		static DWORD dwExceptionCode = pexp->ExceptionRecord->ExceptionCode;

		//  halt the debugger
		
		UserDebugBreakPoint();

		//  To debug the exception, perform the following steps:
		//
		//  MS Developer Studio:
		//
		//    Go to the exception setup dialog and configure the debugger to
		//      Stop Always when exception <dwExceptionCode> occurs
		//    Continue program execution.  The debugger will stop on the
		//      offending code
		//
		//  Windbg:
		//
		//    Enter "SXE <dwExceptionCode> /C" to enable first chance handling
		//      of the exception
		//    Continue program execution.  The debugger will stop on the
		//      offending code
		//
		//  If you choose none of the above, the exception will simply be
		//  passed on to the next higher exception filter on the stack

		//  retry the instruction that caused the exception
		
		fRetryCode = fTrue;
		ReleaseSemaphore( hsemExcept, 1, NULL );
		return efaContinueExecution;
		}
		
	//  the user chose to terminate the process through either dialog

	TerminateProcess( GetCurrentProcess(), -1 );

#endif	//	!RTM

	//should never be reached
	return efaExecuteHandler;
	}

#endif	//	ENABLE_EXCEPTIONS

//  returns the exception id of an exception

const DWORD ExceptionId( EXCEPTION exception )
	{
	PEXCEPTION_POINTERS pexp = PEXCEPTION_POINTERS( exception );

	return pexp->ExceptionRecord->ExceptionCode;
	}


#ifdef DEBUG

/***********************************************************
/******************** error handling ***********************
/***********************************************************
/**/
ERR ErrERRCheck_( const ERR err, const _TCHAR* szFile, const long lLine )
	{

	//	if an assert is hit in one thread, dead-loop all other threads
	while ( fAssertFired )
		{
		UtilSleep( 1000 );
		}

	extern ERR g_errTrap;
	AssertSzRTL( err != g_errTrap, "Error Trap" );

	/*	to trap a specific error/warning, either set your breakpoint here 
	/*	or include a specific case below for the error/warning trapped
	/*	and set your breakpoint there.
	/**/
	switch( err )
		{
		case JET_errSuccess:
			Assert( fFalse );	// Shouldn't call ErrERRCheck() with JET_errSuccess.
			break;

		case JET_errInvalidTableId:
			QwUtilHRTCount();
			break;

		case JET_errKeyDuplicate:
			QwUtilHRTCount();
			break;

		case JET_errDiskIO:
			QwUtilHRTCount();
			break;
			
		case JET_errReadVerifyFailure:
			QwUtilHRTCount();
			break;

		case JET_errOutOfMemory:
			QwUtilHRTCount();
			break;

		case JET_errDerivedColumnCorruption:
			AssertSz( fFalse, "Corruption detected in column space of derived columns." );	//	allow debugging of corruption
			break;

		default:
			break;
		}

	Ptls()->szFileLastErr = szFile;
	Ptls()->ulLineLastErr = lLine;
	Ptls()->errLastErr	= err;
	
	return err;
	}

#endif  //  DEBUG


#ifdef RFS2

/*  RFS2 Options Text  */

LOCAL const CHAR szDisableRFS[]                = "Disable RFS";
LOCAL const CHAR szLogJETCall[]                = "Enable JET Call Logging";
LOCAL const CHAR szLogRFS[]                    = "Enable RFS Logging";
LOCAL const CHAR szRFSAlloc[]                  = "RFS Allocations (-1 to allow all)";
LOCAL const CHAR szRFSIO[]                     = "RFS IOs (-1 to allow all)";

/*  RFS2 Defaults  */

LOCAL const DWORD_PTR rgrgdwRFS2Defaults[][2] =
	{
	(DWORD_PTR)szDisableRFS,            0x00000001,             /*  Disable RFS  */
	(DWORD_PTR)szLogJETCall,            0x00000000,             /*  Disable JET call logging  */
	(DWORD_PTR)szLogRFS,                0x00000000,             /*  Disable RFS logging  */
	(DWORD_PTR)szRFSAlloc,              0xffffffff,             /*  Allow ALL RFS allocations  */
	(DWORD_PTR)szRFSIO,                 0xffffffff,             /*  Allow ALL RFS IOs  */
	(DWORD_PTR)NULL,                    0x00000000,             /*  <EOL>  */
	};

DWORD  g_fDisableRFS		= 0x00000001;
DWORD  g_fAuxDisableRFS	= 0x00000000;
DWORD  g_fLogJETCall		= 0x00000000;
DWORD  g_fLogRFS			= 0x00000000;
DWORD  g_cRFSAlloc		= 0xffffffff;
DWORD  g_cRFSIO			= 0xffffffff;

	/*
		RFS allocator:  returns 0 if allocation is disallowed.  Also handles RFS logging.
		g_cRFSAlloc is the global allocation counter.  A value of -1 disables RFS in debug mode.
	*/

DWORD  cRFSAllocBreak	= 0xfffffffe;
DWORD  cRFSIOBreak		= 0xfffffffe;

int UtilRFSAlloc( const _TCHAR* szType, int Type )
	{
	/*  leave ASAP if we are not enabled  */

	if ( g_fDisableRFS )
		return UtilRFSLog( szType, 1 );
		
	/*  Breaking here on RFS failure allows easy change to RFS success during debugging  */
	
	if (	(	( cRFSAllocBreak == g_cRFSAlloc && Type == 0 ) ||
				( cRFSIOBreak == g_cRFSIO && Type == 1 ) ) &&
			!( g_fDisableRFS || g_fAuxDisableRFS ) )
		UserDebugBreakPoint();

	switch ( Type )
		{
		case 0:  //  general allocation
			if ( g_cRFSAlloc == -1 || ( g_fDisableRFS || g_fAuxDisableRFS ) )
				return UtilRFSLog( szType, 1 );
			if ( !g_cRFSAlloc )
				return UtilRFSLog( szType, 0 );
			g_cRFSAlloc--;
			return UtilRFSLog( szType, 1 );
		case 1:  //  IO operation
			if ( g_cRFSIO == -1 || ( g_fDisableRFS || g_fAuxDisableRFS ) )
				return UtilRFSLog( szType, 1 );
			if ( !g_cRFSIO )
				return UtilRFSLog( szType, 0 );
			g_cRFSIO--;
			return UtilRFSLog( szType, 1 );
		default:
			Assert( 0 );
			break;
		}

	return 0;
	}

BOOL FRFSFailureDetected( UINT Type )
	{
	if ( g_fDisableRFS )
		return fFalse;

	if ( 0 == Type )		//	general allocations
		{
		return ( 0 == g_cRFSAlloc );
		}
	else if ( 1 == Type )	//	I/O
		{
		return ( 0 == g_cRFSIO );
		}

	Assert( fFalse );		//	unknown RFS type
	return fFalse;
	}

BOOL FRFSAnyFailureDetected()
	{
	return ( !g_fDisableRFS
			&& ( 0 == g_cRFSAlloc || 0 == g_cRFSIO ) );
	}
	/*
		RFS logging (log on success/failure).  If fPermitted == 0, access was denied .  Returns fPermitted.
		Turns on JET call logging if fPermitted == 0
	*/

int UtilRFSLog(const _TCHAR* szType,int fPermitted)
	{
	const _TCHAR *	rgszT[4];
	_TCHAR			szPID[10];
	if (!fPermitted)
		g_fLogJETCall = 1;
	
	if (!g_fLogRFS && fPermitted)
		return fPermitted;

	rgszT[0] = SzUtilProcessName();
 
	_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
	rgszT[1] = szPID;

	rgszT[2] = "";		//	no instance name
	
	rgszT[3] = (_TCHAR*) szType;
		
	if ( fPermitted )
		OSEventReportEvent( SzUtilImageVersionName(), eventInformation, RFS2_CATEGORY, RFS2_PERMITTED_ID , 4, rgszT );
	else
		OSEventReportEvent( SzUtilImageVersionName(), eventWarning, RFS2_CATEGORY, RFS2_DENIED_ID, 4, rgszT );
	
	return fPermitted;
	}

	/*  JET call logging (log on failure)
	/*  Logging will start even if disabled when RFS denies an allocation
	/**/

void UtilRFSLogJETCall(const _TCHAR* szFunc,ERR err,const _TCHAR* szFile, unsigned Line)
	{
	_TCHAR			szT[2][16];
	const _TCHAR *	rgszT[7];
	_TCHAR			szPID[10];
	
	if (err >= 0 || !g_fLogJETCall)
		return;

	rgszT[0] = SzUtilProcessName();

 	_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
	rgszT[1] = szPID;

	rgszT[2] = "";		//	no instance name

	rgszT[3] = (_TCHAR*) szFunc;

	_ltot( err, szT[0], 10 );
	rgszT[4] = szT[0];

	rgszT[5] = (_TCHAR*) szFile;

	_ltot( Line, szT[1], 10 );
	rgszT[6] = szT[1];
	
	OSEventReportEvent( SzUtilImageVersionName(), eventInformation, RFS2_CATEGORY, RFS2_JET_CALL_ID, 7, rgszT );
	}

	/*  JET INLINE error logging (logging controlled by JET call flags)  */

void UtilRFSLogJETErr(ERR err,const _TCHAR* szLabel,const _TCHAR* szFile, unsigned Line)
	{
	_TCHAR			szT[2][16];
	const _TCHAR *	rgszT[7];
	_TCHAR			szPID[10];

	if ( !g_fLogJETCall )
		return;
	
	rgszT[0] = SzUtilProcessName();
 
	_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
	rgszT[1] = szPID;

	rgszT[2] = "";		//	no instance name
	
	_ltot( err, szT[0], 10 );
	rgszT[3] = szT[0];

	rgszT[4] = (_TCHAR*) szLabel;

	rgszT[5] = (_TCHAR*) szFile;

	_ltot( Line, szT[1], 10 );
	rgszT[6] = szT[1];
	
	OSEventReportEvent( SzUtilImageVersionName(), eventInformation, PERFORMANCE_CATEGORY, RFS2_JET_ERROR_ID, 7, rgszT );
	}

BOOL RFSError::Check( ERR err, ... ) const
	{
	va_list arg_ptr;
	va_start( arg_ptr, err );
	
	for ( ; err != 0; err = va_arg( arg_ptr, ERR ) )
		{
		Assert( err > -9000 && err < 9000 );
		// acceptable RFS error
		if ( m_err == err )
			{
			break;
			}
		}
		
	va_end( arg_ptr );
	return (err != 0);
	}
#endif  /*  RFS2  */


//  post-terminate error subsystem

void OSErrorPostterm()
	{
	//  delete critical sections
	
#ifdef ENABLE_EXCEPTIONS
	if ( hsemExcept )
		{
		SetHandleInformation( hsemExcept, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hsemExcept );
		hsemExcept = NULL;
		}
#endif  //  ENABLE_EXCEPTIONS
#ifdef DEBUG
	if ( hsemAssert )
		{
		SetHandleInformation( hsemAssert, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hsemAssert );
		hsemAssert = NULL;
		}
#endif  //  DEBUG
	}

//  pre-init error subsystem

BOOL FOSErrorPreinit()
	{
	//  initialize critical sections

#ifdef ENABLE_EXCEPTIONS
	if ( !( hsemExcept = CreateSemaphore( NULL, 1, 1, NULL ) ) )
		{
		return fFalse;
		}
	SetHandleInformation( hsemExcept, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
#endif  //  ENABLE_EXCEPTIONS
#ifdef DEBUG
	if ( !( hsemAssert = CreateSemaphore( NULL, 1, 1, NULL ) ) )
		{
		SetHandleInformation( hsemExcept, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hsemExcept );
		hsemExcept = NULL;
		return fFalse;
		}
	SetHandleInformation( hsemAssert, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
#endif  //  DEBUG

	return fTrue;
	}


//  terminate error subsystem

void OSErrorTerm()
	{
	//  nop
	}

//  init error subsystem

ERR ErrOSErrorInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\os.cxx ===
#include "osstd.hxx"


//  post-terminate OS subsystem

extern void OSEdbgPostterm();
extern void OSPerfmonPostterm();
extern void OSNormPostterm();
extern void OSCprintfPostterm();
extern void OSSLVPostterm();
extern void OSFilePostterm();
extern void OSTaskPostterm();
extern void OSThreadPostterm();
extern void OSMemoryPostterm();
extern void OSErrorPostterm();
extern void OSEventPostterm();
extern void OSTracePostterm();
extern void OSConfigPostterm();
extern void OSTimePostterm();
extern void OSSysinfoPostterm();
extern void OSLibraryPostterm();

void OSPostterm()
	{
	//  terminate all OS subsystems in reverse dependency order

	OSEdbgPostterm();
	OSPerfmonPostterm();
	OSNormPostterm();
	OSCprintfPostterm();
	OSSLVPostterm();
	OSFilePostterm();
	OSTaskPostterm();
	OSThreadPostterm();
	OSMemoryPostterm();
	OSSyncPostterm();
	OSErrorPostterm();
	OSEventPostterm();
	OSTracePostterm();
	OSConfigPostterm();
	OSTimePostterm();
	OSSysinfoPostterm();
	OSLibraryPostterm();
	}

//  pre-init OS subsystem

extern BOOL FOSLibraryPreinit();
extern BOOL FOSSysinfoPreinit();
extern BOOL FOSTimePreinit();
extern BOOL FOSConfigPreinit();
extern BOOL FOSTracePreinit();
extern BOOL FOSEventPreinit();
extern BOOL FOSErrorPreinit();
extern BOOL FOSMemoryPreinit();
extern BOOL FOSThreadPreinit();
extern BOOL FOSTaskPreinit();
extern BOOL FOSFilePreinit();
extern BOOL FOSSLVPreinit();
extern BOOL FOSCprintfPreinit();
extern BOOL FOSNormPreinit();
extern BOOL FOSPerfmonPreinit();
extern BOOL FOSEdbgPreinit();

BOOL FOSPreinit()
	{
	//  initialize all OS subsystems in dependency order

	if (	!FOSLibraryPreinit() ||
			!FOSSysinfoPreinit() ||
			!FOSTimePreinit() ||
			!FOSConfigPreinit() ||
			!FOSTracePreinit() ||
			!FOSEventPreinit() ||
			!FOSErrorPreinit() ||
			!FOSSyncPreinit() ||
			!FOSMemoryPreinit() ||
			!FOSThreadPreinit() ||
			!FOSTaskPreinit() ||
			!FOSFilePreinit() ||
			!FOSSLVPreinit() ||
			!FOSCprintfPreinit() ||
			!FOSNormPreinit() ||
			!FOSPerfmonPreinit() ||
			!FOSEdbgPreinit() )
		{
		goto HandleError;
		}

	return fTrue;

HandleError:
	OSPostterm();
	return fFalse;
	}


//  init OS subsystem

extern ERR ErrOSLibraryInit();
extern ERR ErrOSSysinfoInit();
extern ERR ErrOSTimeInit();
extern ERR ErrOSConfigInit();
extern ERR ErrOSTraceInit();
extern ERR ErrOSEventInit();
extern ERR ErrOSErrorInit();
extern ERR ErrOSMemoryInit();
extern ERR ErrOSThreadInit();
extern ERR ErrOSTaskInit();
extern ERR ErrOSFileInit();
extern ERR ErrOSSLVInit();
extern ERR ErrOSCprintfInit();
extern ERR ErrOSNormInit();
extern ERR ErrOSPerfmonInit();
extern ERR ErrOSEdbgInit();

ERR ErrOSInit()
	{
	ERR err;
	
	//  initialize all OS subsystems in dependency order

	Call( ErrOSLibraryInit() );
	Call( ErrOSSysinfoInit() );
	Call( ErrOSTimeInit() );
	Call( ErrOSConfigInit() );
	Call( ErrOSTraceInit() );
	Call( ErrOSEventInit() );
	Call( ErrOSErrorInit() );
	Call( ErrOSMemoryInit() );
	Call( ErrOSThreadInit() );
	Call( ErrOSTaskInit() );
	Call( ErrOSFileInit() );
	Call( ErrOSSLVInit() );
	Call( ErrOSCprintfInit() );
	Call( ErrOSNormInit() );
	Call( ErrOSPerfmonInit() );
	Call( ErrOSEdbgInit() );

	return JET_errSuccess;

HandleError:
	OSTerm();
	return err;
	}

//  terminate OS subsystem

extern void OSEdbgTerm();
extern void OSPerfmonTerm();
extern void OSNormTerm();
extern void OSCprintfTerm();
extern void OSSLVTerm();
extern void OSFileTerm();
extern void OSTaskTerm();
extern void OSThreadTerm();
extern void OSMemoryTerm();
extern void OSErrorTerm();
extern void OSEventTerm();
extern void OSTraceTerm();
extern void OSConfigTerm();
extern void OSTimeTerm();
extern void OSSysinfoTerm();
extern void OSLibraryTerm();

void OSTerm()
	{
	//  terminate all OS subsystems in reverse dependency order

	OSEdbgTerm();
	OSPerfmonTerm();
	OSNormTerm();
	OSCprintfTerm();
	OSSLVTerm();
	OSFileTerm();
	OSTaskTerm();
	OSThreadTerm();
	OSMemoryTerm();
	OSErrorTerm();
	OSEventTerm();
	OSTraceTerm();
	OSConfigTerm();
	OSTimeTerm();
	OSSysinfoTerm();
	OSLibraryTerm();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\mpheap.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mpheap.c

Abstract:

    This DLL is a wrapper that sits on top of the Win32 Heap* api.  It
    provides multiple heaps and handles all the serialization itself.

    Many multithreaded applications that use the standard memory allocation
    routines (malloc/free, LocalAlloc/LocalFree, HeapAlloc/HeapFree) suffer
    a significant a significant performance penalty when running on a
    multi-processor machine.  This is due to the serialization used by the
    default heap package.  On a multiprocessor machine, more than one
    thread may simultaneously try to allocate memory.  One thread will
    block on the critical section guarding the heap.  The other thread must
    then signal the critical section when it is finished to unblock the
    waiting thread.  The additional codepath of blocking and signalling adds
    significant overhead to the frequent memory allocation path.

    By providing multiple heaps, this DLL allows simultaneous operations on
    each heap.  A thread on processor 0 can allocate memory from one heap
    at the same time that a thread on processor 1 is allocating from a
    different heap.  The additional overhead in this DLL is compensated by
    drastically reducing the number of times a thread must wait for heap
    access.

    The basic scheme is to attempt to lock each heap in turn with the new
    TryEnterCriticalSection API.  This will enter the critical section if
    it is unowned.  If the critical section is owned by a different thread,
    TryEnterCriticalSection returns failure instead of blocking until the
    other thread leaves the critical section.

    Another trick to increase performance is the use of a lookaside list to
    satisfy frequent allocations.  By using InterlockedExchange to remove
    lookaside list entries and InterlockedCompareExchange to add lookaside
    list entries, allocations and frees can be completed without needing a
    critical section lock.

    The final trick is the use of delayed frees.  If a chunk of memory is
    being freed, and the required lock is already held by a different
    thread, the free block is simply added to a delayed free list and the
    API completes immediately.  The next thread to acquire the heap lock
    will free everything on the list.

    Every application uses memory allocation routines in different ways.
    In order to allow better tuning of this package, MpHeapGetStatistics
    allows an application to monitor the amount of contention it is
    getting.  Increasing the number of heaps increases the potential
    concurrency, but also increases memory overhead.  Some experimentation
    is recommended to determine the optimal settings for a given number of
    processors.

    Some applications can benefit from additional techniques.  For example,
    per-thread lookaside lists for common allocation sizes can be very
    effective.  No locking is required for a per-thread structure, since no
    other thread will ever be accessing it.  Since each thread reuses the
    same memory, per-thread structures also improve locality of reference.

Revision History:

    [andygo] modified from the original version:  now uses sync.lib so that
    it will work as intended on Win9x.  Win9x does not provide support for
    InterlockedCompareExchange and TryEnterCriticalSection so all sync
    primitives used in mpheap are redirected into the sync library.

--*/
#include "osstd.hxx"
#include "mpheap.hxx"

#define MPHEAP_VALID_OPTIONS  (MPHEAP_GROWABLE                 | \
                               MPHEAP_REALLOC_IN_PLACE_ONLY    | \
                               MPHEAP_TAIL_CHECKING_ENABLED    | \
                               MPHEAP_FREE_CHECKING_ENABLED    | \
                               MPHEAP_DISABLE_COALESCE_ON_FREE | \
                               MPHEAP_ZERO_MEMORY              | \
                               MPHEAP_COLLECT_STATS)

//
// Flags that are not passed on to the Win32 heap package
//
#define MPHEAP_PRIVATE_FLAGS (MPHEAP_COLLECT_STATS | MPHEAP_ZERO_MEMORY);

//
// Define the heap header that gets tacked on the front of
// every allocation. Eight bytes is a lot, but we can't make
// it any smaller or else the allocation will not be properly
// aligned for 64-bit quantities.
//
typedef struct _MP_HEADER {
    union {
        struct _MP_HEAP_ENTRY *HeapEntry;
        PSINGLE_LIST_ENTRY Next;
    };
    SIZE_T MpSize;
} MP_HEADER, *PMP_HEADER;
//
// Definitions and structures for lookaside list
//
#define LIST_ENTRIES 128

typedef struct _MP_HEAP_LOOKASIDE {
    PMP_HEADER Entry;
} MP_HEAP_LOOKASIDE, *PMP_HEAP_LOOKASIDE;

#define NO_LOOKASIDE 0xffffffff
#define MaxLookasideSize (8*LIST_ENTRIES-7)
#define LookasideIndexFromSize(s) ((s < MaxLookasideSize) ? ((s) >> 3) : NO_LOOKASIDE)

//
// Define the structure that describes the entire MP heap.
//
// There is one MP_HEAP_ENTRY structure for each Win32 heap
// and a MP_HEAP structure that contains them all.
//
// Each MP_HEAP structure contains a lookaside list for quick
// lock-free alloc/free of various size blocks.
//

typedef struct _MP_HEAP_ENTRY {
	_MP_HEAP_ENTRY()
		:	Lock( CLockBasicInfo( CSyncBasicInfo( "_MP_HEAP_ENTRY::Lock" ), 0, 0 ) )
		{
		}
		
    HANDLE Heap;
    PSINGLE_LIST_ENTRY DelayedFreeList;
    CCriticalSection Lock;
    DWORD Allocations;
    DWORD Frees;
    DWORD LookasideAllocations;
    DWORD LookasideFrees;
    DWORD DelayedFrees;
    MP_HEAP_LOOKASIDE Lookaside[LIST_ENTRIES];
} MP_HEAP_ENTRY, *PMP_HEAP_ENTRY;


typedef struct _MP_HEAP {
    DWORD HeapCount;
    DWORD Flags;
    DWORD Hint;
    DWORD PadTo32Bytes;
    MP_HEAP_ENTRY Entry[1];     // variable size
} MP_HEAP, *PMP_HEAP;


VOID
ProcessDelayedFreeList(
    IN PMP_HEAP_ENTRY HeapEntry
    );

//
// HeapHint is a per-thread variable that offers a hint as to which heap to
// check first.  By giving each thread affinity towards a different heap,
// it is more likely that the first heap a thread picks for its allocation
// will be available.  It also improves a thread's locality of reference,
// which is very important for good MP performance
//
#define SetHeapHint(x)	TlsSetValue(tlsiHeapHint,(void*)(x))
#define GetHeapHint()	PtrToUlong(TlsGetValue(tlsiHeapHint))

HANDLE
WINAPI
MpHeapCreate(
    DWORD flOptions,
    SIZE_T dwInitialSize,
    DWORD dwParallelism
    )
/*++

Routine Description:

    This routine creates an MP-enhanced heap. An MP heap consists of a
    collection of standard Win32 heaps whose serialization is controlled
    by the routines in this module to allow multiple simultaneous allocations.

Arguments:

    flOptions - Supplies the options for this heap.

        Currently valid flags are:

            MPHEAP_GROWABLE
            MPHEAP_REALLOC_IN_PLACE_ONLY
            MPHEAP_TAIL_CHECKING_ENABLED
            MPHEAP_FREE_CHECKING_ENABLED
            MPHEAP_DISABLE_COALESCE_ON_FREE
            MPHEAP_ZERO_MEMORY
            MPHEAP_COLLECT_STATS

    dwInitialSize - Supplies the initial size of the combined heaps.

    dwParallelism - Supplies the number of Win32 heaps that will make up the
        MP heap. A value of zero defaults to three + # of processors.

Return Value:

    HANDLE - Returns a handle to the MP heap that can be passed to the
             other routines in this package.

    NULL - Failure, GetLastError() specifies the exact error code.

--*/
{
    DWORD Error;
    DWORD i;
    HANDLE Heap;
    PMP_HEAP MpHeap;
    SIZE_T HeapSize;
    DWORD PrivateFlags;

    if (flOptions & ~MPHEAP_VALID_OPTIONS) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    flOptions |= HEAP_NO_SERIALIZE;

    PrivateFlags = flOptions & MPHEAP_PRIVATE_FLAGS;

    flOptions &= ~MPHEAP_PRIVATE_FLAGS;

    if (dwParallelism == 0) {
        SYSTEM_INFO SystemInfo;

        GetSystemInfo(&SystemInfo);
        dwParallelism = 3 + SystemInfo.dwNumberOfProcessors;
    }

    HeapSize = dwInitialSize / dwParallelism;

    //
    // The first heap is special, since the MP_HEAP structure itself
    // is allocated from there.
    //
    Heap = HeapCreate(flOptions,HeapSize,0);
    if (Heap == NULL) {
        //
        // HeapCreate has already set last error appropriately.
        //
        return(NULL);
    }

    MpHeap = (PMP_HEAP)HeapAlloc(Heap,0,sizeof(MP_HEAP) +
                              (dwParallelism-1)*sizeof(MP_HEAP_ENTRY));
    if (MpHeap==NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        HeapDestroy(Heap);
        return(NULL);
    }

    //
    // Initialize the MP heap structure
    //
    MpHeap->HeapCount = 1;
    MpHeap->Flags = PrivateFlags;
    MpHeap->Hint = 0;

    //
    // Initialize the first heap
    //
    ZeroMemory(&MpHeap->Entry[0], sizeof(MpHeap->Entry[0]));
    new( &MpHeap->Entry[0] ) _MP_HEAP_ENTRY;
    MpHeap->Entry[0].Heap = Heap;
    MpHeap->Entry[0].DelayedFreeList = NULL;

    //
    // Initialize the remaining heaps. Note that the heap has been
    // sufficiently initialized to use MpHeapDestroy for cleanup
    // if something bad happens.
    //
    for (i=1; i<dwParallelism; i++) {
        ZeroMemory(&MpHeap->Entry[i], sizeof(MpHeap->Entry[i]));
	    new( &MpHeap->Entry[i] ) _MP_HEAP_ENTRY;
        MpHeap->Entry[i].Heap = HeapCreate(flOptions, HeapSize, 0);
        if (MpHeap->Entry[i].Heap == NULL) {
            Error = GetLastError();
            MpHeapDestroy((HANDLE)MpHeap);
            SetLastError(Error);
            return(NULL);
        }
        MpHeap->Entry[i].DelayedFreeList = NULL;
        ++MpHeap->HeapCount;
    }

    return((HANDLE)MpHeap);
}

BOOL
WINAPI
MpHeapDestroy(
    HANDLE hMpHeap
    )
{
    DWORD i;
    DWORD HeapCount;
    PMP_HEAP MpHeap;
    BOOL Success = TRUE;
    HANDLE Heap;

    MpHeap = (PMP_HEAP)hMpHeap;
    HeapCount = MpHeap->HeapCount;

	if (HeapCount)
	{

		//
		// Lock down all the heaps so we don't end up hosing people
		// who may be allocating things while we are deleting the heaps.
		// By setting MpHeap->HeapCount = 0 we also attempt to prevent
		// people from getting hosed as soon as we delete the critical
		// sections and heaps.
		// We will not try to enter critical sesction if the process is 
		// aborted because (1) we are the only thread running in the
		// process and (2) one of the killed threads might be the legal
		// owner of the crirical section and we will wait forever on
		// that critical section.
		//
		MpHeap->HeapCount = 0;
		if ( !FUtilProcessAbort() ) {
			for (i=0; i<HeapCount; i++) {
				CLockDeadlockDetectionInfo::DisableOwnershipTracking();
				MpHeap->Entry[i].Lock.Enter();
				CLockDeadlockDetectionInfo::EnableOwnershipTracking();
			}
		}

		//
		// Delete the heaps and their associated critical sections.
		// Note that the order is important here. Since the MpHeap
		// structure was allocated from MpHeap->Heap[0] we must
		// delete that last.
		//
		for (i=HeapCount-1; i>0; i--) {
			Heap = MpHeap->Entry[i].Heap;
			MpHeap->Entry[i].~_MP_HEAP_ENTRY();
			if (!HeapDestroy(Heap)) {
				Success = FALSE;
			}
		}

		Heap = MpHeap->Entry[0].Heap;
		MpHeap->Entry[0].~_MP_HEAP_ENTRY();
		Success = HeapDestroy(Heap);
	}
    return(Success);
}

BOOL
WINAPI
MpHeapValidate(
    HANDLE hMpHeap,
    LPVOID lpMem
    )
{
    PMP_HEAP MpHeap;
    DWORD i;
    BOOL Success;
    PMP_HEADER Header;
    PMP_HEAP_ENTRY Entry;

    MpHeap = (PMP_HEAP)hMpHeap;

    if (lpMem == NULL) {

        //
        // Lock and validate each heap in turn.
        //
        for (i=0; i < MpHeap->HeapCount; i++) {
            Entry = &MpHeap->Entry[i];
            __try {
                Entry->Lock.Enter();
                Success = HeapValidate(Entry->Heap, 0, NULL);
                Entry->Lock.Leave();
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                return(FALSE);
            }

            if (!Success) {
                return(FALSE);
            }
        }
        return(TRUE);
    } else {

        //
        // Lock and validate the given heap entry
        //
        Header = ((PMP_HEADER)lpMem) - 1;
        __try {
            Header->HeapEntry->Lock.Enter();
            Success = HeapValidate(Header->HeapEntry->Heap, 0, Header);
            Header->HeapEntry->Lock.Leave();
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            return(FALSE);
        }

        return(Success);
    }
}

SIZE_T
WINAPI
MpHeapCompact(
    HANDLE hMpHeap
    )
{
    PMP_HEAP MpHeap;
    DWORD i;
    SIZE_T LargestFreeSize=0;
    SIZE_T FreeSize;
    PMP_HEAP_ENTRY Entry;

    MpHeap = (PMP_HEAP)hMpHeap;

    //
    // Lock and compact each heap in turn.
    //
    for (i=0; i < MpHeap->HeapCount; i++) {
        Entry = &MpHeap->Entry[i];
        Entry->Lock.Enter();
        FreeSize = HeapCompact(Entry->Heap, 0);
        Entry->Lock.Leave();

        if (FreeSize > LargestFreeSize) {
            LargestFreeSize = FreeSize;
        }
    }

    return(LargestFreeSize);

}


LPVOID
WINAPI
MpHeapAlloc(
    HANDLE hMpHeap,
    DWORD flOptions,
    SIZE_T dwBytes
    )
{
    PMP_HEADER Header;
    PMP_HEAP MpHeap;
    DWORD_PTR i;
    PMP_HEAP_ENTRY Entry;
    SIZE_T Index;
    SIZE_T Size;

    MpHeap = (PMP_HEAP)hMpHeap;

    flOptions |= MpHeap->Flags;

    Size = ((dwBytes + 7) & (ULONG)~7) + sizeof(MP_HEADER);
    Index=LookasideIndexFromSize(Size);

    //
    // Iterate through the heap locks looking for one
    // that is not owned.
    //
    i=GetHeapHint();
    if (i>=MpHeap->HeapCount) {
        i=0;
        SetHeapHint(0);
    }
    Entry = &MpHeap->Entry[i];
    do {
        //
        // Check the lookaside list for a suitable allocation.
        //
        if ((Index != NO_LOOKASIDE) &&
            (Entry->Lookaside[Index].Entry != NULL)) {
            if ((Header = (PMP_HEADER)AtomicExchangePointer((void**)&Entry->Lookaside[Index].Entry,
                                                          NULL)) != NULL) {
                //
                // We have a lookaside hit, return it immediately.
                //
                ++Entry->LookasideAllocations;
                Header->HeapEntry = Entry;
                if (flOptions & MPHEAP_ZERO_MEMORY) {
                    ZeroMemory(Header + 1, dwBytes);
				}
                SetHeapHint(i);
                return(Header + 1);
            }
        }

        //
        // Attempt to lock this heap without blocking.
        //
        if (Entry->Lock.FTryEnter()) {
            //
            // success, go allocate immediately
            //
            goto LockAcquired;
        }

        //
        // This heap is owned by another thread, try
        // the next one.
        //
        i++;
        Entry++;
        if (i==MpHeap->HeapCount) {
            i=0;
            Entry=&MpHeap->Entry[0];
        }
    } while ( i != GetHeapHint());

    //
    // All of the critical sections were owned by someone else,
    // so we have no choice but to wait for a critical section.
    //
    Entry->Lock.Enter();

LockAcquired:
    ++Entry->Allocations;
    if (Entry->DelayedFreeList != NULL) {
        ProcessDelayedFreeList(Entry);
    }
    Header = (PMP_HEADER)HeapAlloc(Entry->Heap, 0, Size);
    Entry->Lock.Leave();
    if (Header != NULL) {
        Header->HeapEntry = Entry;
        Header->MpSize = Size;
        if (flOptions & MPHEAP_ZERO_MEMORY) {
            ZeroMemory(Header + 1, dwBytes);
        }
        SetHeapHint(i);
        return(Header + 1);
    } else {
        return(NULL);
    }
}

LPVOID
WINAPI
MpHeapReAlloc(
    HANDLE hMpHeap,
    LPVOID lpMem,
    SIZE_T dwBytes
    )
{
    PMP_HEADER Header;
    CCriticalSection* Lock;

	if (lpMem == NULL)
	{
		return MpHeapAlloc(hMpHeap, 0, dwBytes);
	}
	else
	{

		Header = ((PMP_HEADER)lpMem) - 1;
		Lock = &Header->HeapEntry->Lock;
		dwBytes = ((dwBytes + 7) & (ULONG)~7) + sizeof(MP_HEADER);

		Lock->Enter();
		if (Header->HeapEntry->DelayedFreeList != NULL) {
			ProcessDelayedFreeList(Header->HeapEntry);
		}
		Header = (PMP_HEADER)HeapReAlloc(Header->HeapEntry->Heap, 0, Header, dwBytes);
		Lock->Leave();

		if (Header != NULL) {
			Header->MpSize = dwBytes;
			return(Header + 1);
		} else {
			return(NULL);
		}
	}
}

BOOL
WINAPI
MpHeapFree(
    HANDLE hMpHeap,
    LPVOID lpMem
    )
{
    PMP_HEADER Header;
    CCriticalSection* Lock;
    BOOL Success;
    PMP_HEAP_ENTRY HeapEntry;
    PSINGLE_LIST_ENTRY Next;
    PMP_HEAP MpHeap;
    SIZE_T Index;

    Header = ((PMP_HEADER)lpMem) - 1;
    HeapEntry = Header->HeapEntry;
    MpHeap = (PMP_HEAP)hMpHeap;

    SetHeapHint(HeapEntry - &MpHeap->Entry[0]);

    Index = LookasideIndexFromSize(Header->MpSize);

    if (Index != NO_LOOKASIDE) {
        //
        // Try and put this back on the lookaside list
        //
        if (AtomicCompareExchangePointer((void**)&HeapEntry->Lookaside[Index],
                                       NULL,
                                       Header) == NULL) {
            //
            // Successfully freed to lookaside list.
            //
            ++HeapEntry->LookasideFrees;
            return(TRUE);
        }
    }
    Lock = &HeapEntry->Lock;

    if (Lock->FTryEnter()) {
        ++HeapEntry->Frees;
        if (HeapEntry->DelayedFreeList != NULL) {
        	ProcessDelayedFreeList(HeapEntry);
        }
        Success = HeapFree(HeapEntry->Heap, 0, Header);
        Lock->Leave();
        return(Success);
    }
    //
    // The necessary heap critical section could not be immediately
    // acquired. Post this free onto the Delayed free list and let
    // whoever has the lock process it.
    //
    do {
        Next = HeapEntry->DelayedFreeList;
        Header->Next = Next;
    } while ( AtomicCompareExchangePointer((void**)&HeapEntry->DelayedFreeList,
                                         Next,
                                         &Header->Next) != Next);
    return(TRUE);
}


SIZE_T
WINAPI
MpHeapSize(
		   HANDLE hMpHeap,
		   DWORD ulFlags,
		   LPVOID lpMem
		  )
{
	PMP_HEADER Header;

	Header = ((PMP_HEADER)lpMem) - 1;
	return Header->MpSize - sizeof(MP_HEADER);
}


VOID
ProcessDelayedFreeList(
    IN PMP_HEAP_ENTRY HeapEntry
    )
{
    PSINGLE_LIST_ENTRY FreeList;
    PSINGLE_LIST_ENTRY Next;
    PMP_HEADER Header;

    //
    // Capture the entire delayed free list with a single interlocked exchange.
    // Once we have removed the entire list, free each entry in turn.
    //
    FreeList = (PSINGLE_LIST_ENTRY)AtomicExchangePointer((void**)&HeapEntry->DelayedFreeList, NULL);
    while (FreeList != NULL) {
        Next = FreeList->Next;
        Header = CONTAINING_RECORD(FreeList, MP_HEADER, Next);
        ++HeapEntry->DelayedFrees;
        HeapFree(HeapEntry->Heap, 0, Header);
        FreeList = Next;
    }
}

DWORD
MpHeapGetStatistics(
    HANDLE hMpHeap,
    LPDWORD lpdwSize,
    MPHEAP_STATISTICS Stats[]
    )
{
    PMP_HEAP MpHeap;
    PMP_HEAP_ENTRY Entry;
    DWORD i;
    DWORD RequiredSize;

    MpHeap = (PMP_HEAP)hMpHeap;
    RequiredSize = MpHeap->HeapCount * sizeof(MPHEAP_STATISTICS);
    if (*lpdwSize < RequiredSize) {
        *lpdwSize = RequiredSize;
        return(ERROR_MORE_DATA);
    }
    ZeroMemory(Stats, MpHeap->HeapCount * sizeof(MPHEAP_STATISTICS));
    for (i=0; i < MpHeap->HeapCount; i++) {
        Entry = &MpHeap->Entry[i];

        Stats[i].Contention = -1;  //  sync.lib doesn't provide this statistic
        Stats[i].TotalAllocates = (Entry->Allocations + Entry->LookasideAllocations);
        Stats[i].TotalFrees = (Entry->Frees + Entry->LookasideFrees + Entry->DelayedFrees);
        Stats[i].LookasideAllocates = Entry->LookasideAllocations;
        Stats[i].LookasideFrees = Entry->LookasideFrees;
        Stats[i].DelayedFrees = Entry->DelayedFrees;
    }
    *lpdwSize = RequiredSize;
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\event.cxx ===
#include "osstd.hxx"

#include <malloc.h>


//  Event Logging

LOCAL volatile HANDLE hEventSource;

LOCAL CRITICAL_SECTION csEventCache;

#pragma warning ( disable : 4200 )	//  we allow zero sized arrays

struct EVENT
	{
	SIZE_T			cb;
	EVENT*			peventNext;
	const _TCHAR*	szSourceEventKey;
	EEventType		type;
	CategoryId		catid;
	MessageId		msgid;
	DWORD			cbRawData;
	void*			pvRawData;
	DWORD			cString;
	const _TCHAR*	rgpsz[0];
	};

LOCAL EVENT*		peventCacheHead;
LOCAL EVENT*		peventCacheTail;
LOCAL DWORD			ceventLost;
LOCAL SIZE_T		cbEventCache;


//  writes all cached events to the event log, ignoring any errors encountered

void OSEventIFlushEventCache()
	{
	EVENT*	peventPrev	= NULL;
	EVENT*	pevent;
	EVENT*	peventNext;

	//  report all cached events

	for ( pevent = peventCacheHead; NULL != pevent; pevent = peventNext )
		{
		//	save next event, because this one may go away
		peventNext = pevent->peventNext;
		
		hEventSource = RegisterEventSource( NULL, pevent->szSourceEventKey );
		if ( hEventSource )
			{
			SIZE_T	cbAlloc		= pevent->cb;

			//	remove this event from the list
			if ( NULL == peventPrev )
				{
				Assert( pevent == peventCacheHead );
				peventCacheHead = pevent->peventNext;
				}
			else
				{
				AssertTracking();		//	JLIEM: do we really have a case where only SOME events get removed from the list?
				peventPrev->peventNext = pevent->peventNext;
				}
			if ( pevent == peventCacheTail )
				peventCacheTail = peventPrev;
			
			(void)ReportEvent(	hEventSource,
								WORD( pevent->type ),
								WORD( pevent->catid ),
								pevent->msgid,
								0,
								WORD( pevent->cString ),
								WORD( pevent->cbRawData ),
								(const _TCHAR**)pevent->rgpsz,
								pevent->pvRawData );

			//	free the event
			const BOOL	fFreedEventMemory	= !LocalFree( pevent );
			Assert( fFreedEventMemory );

			DeregisterEventSource( hEventSource );
			hEventSource = NULL;

			Assert( cbEventCache >= cbAlloc );
			cbEventCache -= cbAlloc;
			}
		else
			{
			//	this event is going to remain in the list
			peventPrev = pevent;
			}
		}

	Assert( NULL == peventCacheHead ? NULL == peventCacheTail : NULL != peventCacheTail );

	//  we have lost some cached events

	if ( ceventLost )
		{
		//  UNDONE:  gripe about it in the event log
		ceventLost = 0;
		}
	}



#ifdef DEBUG
LOCAL BOOL	fOSSuppressEvents	= fFalse;
#endif
	

//  reports the specifed event using the given data to the system event log
	
#pragma optimize( "y", off )

void OSEventReportEvent( const _TCHAR* szSourceEventKey, 
						 const EEventType type, 
						 const CategoryId catid, 
						 const MessageId msgid, 
						 const DWORD cString, 
						 const _TCHAR* rgpszString[], 
						 const DWORD cbRawData, 
						 void *pvRawData, 
						 const LONG lEventLoggingLevel )
	{
	extern LONG	g_lEventLoggingLevel;
	
	if ( lEventLoggingLevel > g_lEventLoggingLevel )
		{
		return; /* Event Logging is disabled */
	 	}

#ifdef DEBUG
	//	ensure we don't get into a vicious cycle if we recursively enter this function
	//	because an assert fired within this function (and we go to report the assert in
	//	the event log)
	//	NOTE: this check doesn't need to be in the critical section because it's only
	//	designed to protect the current thread from recursively calling this function
	//	via an assert firing
	if ( fOSSuppressEvents )
		{
		return;
		}
#endif		

	//  the event log isn't open
	
	EnterCriticalSection( &csEventCache );

#ifdef DEBUG
	fOSSuppressEvents = fTrue;
#endif	

	Assert( !hEventSource );

	Assert( cbRawData == 0 || pvRawData != NULL );
	
	//  write all cached events to the event log
	if ( NULL != peventCacheHead )
		OSEventIFlushEventCache();

	//  try once again to open the event log
	
	hEventSource = RegisterEventSource( NULL, szSourceEventKey );

	//  we still failed to open the event log

	if ( !hEventSource )
		{
		//  allocate memory to cache this event

		extern LONG		g_cbEventHeapMax;
		EVENT*			pevent				= NULL;
		SIZE_T 			cbAlloc				= sizeof(EVENT);

		//	allocate room for eventsource, plus null terminator
		cbAlloc += _tcslen( szSourceEventKey ) + sizeof(_TCHAR );

		//	allocate room for string array
		cbAlloc += sizeof(const _TCHAR*) * cString;

		//	allocate room for individual strings, plus null terminator
		for ( DWORD ipsz = 0; ipsz < cString; ipsz++ )
			{
			cbAlloc += _tcslen( rgpszString[ipsz] ) + sizeof(_TCHAR);
			}

		//	allocate room for raw data
		cbAlloc += cbRawData;
		
		if ( cbEventCache + cbAlloc < g_cbEventHeapMax )
			{
			pevent = (EVENT*)LocalAlloc( 0, cbAlloc );
			if ( pevent )
				{
				cbEventCache += cbAlloc;
				}
			}

		//  we are out of memory
		
		if ( !pevent )
			{
			//  we lost this event

			ceventLost++;
			}

		//  we got the memory

		else
			{
			//  insert the event into the event cache
			_TCHAR*		psz;

			pevent->cb = cbAlloc;
			pevent->peventNext = NULL;
			pevent->type = type;
			pevent->catid = catid;
			pevent->msgid = msgid;
			pevent->cbRawData = cbRawData;
			pevent->cString = cString;

			//	start storing strings after the string array
			psz = (_TCHAR*)pevent->rgpsz + ( sizeof(const _TCHAR*) * cString );

			//	eventsource comes first
			pevent->szSourceEventKey = psz;
			_tcscpy( psz, szSourceEventKey );
			psz += _tcslen( szSourceEventKey ) + sizeof(_TCHAR);

			//	next store raw data
			if ( cbRawData > 0 )
				{
				pevent->pvRawData = (void*)psz;
				memcpy( psz, pvRawData, cbRawData );
				psz += cbRawData;
				}
			else
				{
				pevent->pvRawData = NULL;
				}

			//	finally store individual strings
			for ( DWORD ipsz = 0; ipsz < cString; ipsz++ )
				{
				pevent->rgpsz[ipsz] = psz;
				_tcscpy( psz, rgpszString[ipsz] );
				psz += _tcslen( rgpszString[ipsz] ) + sizeof(_TCHAR);
				}

			if ( psz - (_TCHAR*)pevent == cbAlloc )
				{
				if ( NULL != peventCacheTail )
					{
					Assert( NULL != peventCacheHead );
					peventCacheTail->peventNext = pevent;
					}
				else
					{
					Assert( NULL == peventCacheHead );
					peventCacheHead = pevent;
					}
				peventCacheTail = pevent;
				}
			else
				{
				Assert( fFalse );	//	should be impossible
				const BOOL	fFreedEventMemory = !LocalFree( pevent );
				Assert( fFreedEventMemory );
				}

			}
		}

	//  we opened the event log

	else
		{
		//  write event to the event log, ignoring any errors encountered
		
		(void)ReportEvent(	hEventSource,
							WORD( type ),
							WORD( catid ),
							msgid,
							0,
							WORD( cString ),
							WORD( cbRawData ),
							rgpszString,
							pvRawData );

		DeregisterEventSource( hEventSource );
		hEventSource = NULL;
		}

#ifdef DEBUG
	fOSSuppressEvents = fFalse;
#endif	

	LeaveCriticalSection( &csEventCache );
	}

#pragma optimize( "", on )


//  post-terminate event subsystem

void OSEventPostterm()
	{
	//	with our current eventlog scheme, it should be impossible to come here with an open event source
	Assert( !hEventSource || FUtilProcessAbort() );

	//  the event log is not open and we still have cached events

	if ( NULL != peventCacheHead )
		{
		Assert( NULL != peventCacheTail );

		//  try one last time to open the event log and write all cached events
		if ( hEventSource )
			{
			Assert( FUtilProcessAbort() );
			DeregisterEventSource( hEventSource );
			hEventSource = NULL;
			}
		OSEventIFlushEventCache();

		//  purge remaining cached events
		//  CONSIDER:  write remaining cached events to a file
		EVENT*	pevent;
		EVENT*	peventNext;			
		for ( pevent = peventCacheHead; pevent; pevent = pevent = peventNext )
			{
			peventNext = pevent->peventNext;
			const BOOL	fFreedEventMemory	= !LocalFree( pevent );
			Assert( fFreedEventMemory );
			}
		}
	else
		{
		Assert( NULL == peventCacheTail );
		}

	//  the event log is open

	if ( hEventSource )
		{
		//	UNDONE: this code path should be dead
		Assert( FUtilProcessAbort() );

		//  we should not have any cached events

		Assert( NULL == peventCacheHead );
		Assert( NULL == peventCacheTail );

		//  close the event log
		//
		//  NOTE:  ignore any error returned as the event log service may have
		//  already been shut down
		
		DeregisterEventSource( hEventSource );
		hEventSource = NULL;
		}

	//  reset the event cache
	
	peventCacheHead	= NULL;
	peventCacheTail	= NULL;
	ceventLost		= 0;
	cbEventCache	= 0;

	//  delete the event cache critical section

	DeleteCriticalSection( &csEventCache );
	}

//  pre-init event subsystem

BOOL FOSEventPreinit()
	{
	//  initialize the event cache critical section

	InitializeCriticalSection( &csEventCache );
	
	//  reset the event cache
	
	peventCacheHead	= NULL;
	peventCacheTail	= NULL;
	ceventLost		= 0;
	cbEventCache	= 0;
	
	//  add ourself as an event source in the registry

	static const _TCHAR szApplicationKeyPath[] = _T( "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\" );
	_TCHAR szImageKeyPath[ sizeof( szApplicationKeyPath ) + _MAX_FNAME ];
	_stprintf( szImageKeyPath, _T( "%s%.*s" ), szApplicationKeyPath, _MAX_FNAME, SzUtilImageVersionName() );

	DWORD error;
	HKEY hkeyImage;
	DWORD Disposition;
	error = RegCreateKeyEx(	HKEY_LOCAL_MACHINE,
							szImageKeyPath,
							0,
							NULL,
							REG_OPTION_NON_VOLATILE,
							KEY_WRITE,
							NULL,
							&hkeyImage,
							&Disposition );
	if ( error == ERROR_SUCCESS )
		{
		DWORD error = RegSetValueEx(	hkeyImage,
										_T( "EventMessageFile" ),
										0,
										REG_EXPAND_SZ,
										LPBYTE( SzUtilImagePath() ),
										(ULONG)_tcslen( SzUtilImagePath() ) + 1 );
		Assert( error == ERROR_SUCCESS );
		error = RegSetValueEx(	hkeyImage,
								_T( "CategoryMessageFile" ),
								0,
								REG_EXPAND_SZ,
								LPBYTE( SzUtilImagePath() ),
								(ULONG)_tcslen( SzUtilImagePath() ) + 1 );
		Assert( error == ERROR_SUCCESS );
		DWORD Data = MAC_CATEGORY - 1;
		error = RegSetValueEx(	hkeyImage,
								_T( "CategoryCount" ),
								0,
								REG_DWORD,
								LPBYTE( &Data ),
								sizeof( Data ) );
		Assert( error == ERROR_SUCCESS );
		Data = EVENTLOG_INFORMATION_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_ERROR_TYPE;
		error = RegSetValueEx(	hkeyImage,
								_T( "TypesSupported" ),
								0,
								REG_DWORD,
								LPBYTE( &Data ),
								sizeof( Data ) );
		Assert( error == ERROR_SUCCESS );
		error = RegCloseKey( hkeyImage );
		Assert( error == ERROR_SUCCESS );
		}
	else if ( error != ERROR_ACCESS_DENIED )
		{
		goto HandleError;
		}

	return fTrue;

HandleError:
	OSEventPostterm();
	return fFalse;
	}


//  terminate event subsystem

void OSEventTerm()
	{
	//  nop
	}

//  init event subsystem

ERR ErrOSEventInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\norm.cxx ===
#include "osstd.hxx"

#include < malloc.h >


LOCAL BOOL			fUnicodeSupport				= fFalse;

const SORTID		sortidDefault				= SORT_DEFAULT;
const SORTID		sortidNone					= SORT_DEFAULT;
const LANGID		langidDefault				= MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US );
const LANGID		langidNone					= MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL );

extern const LCID	lcidDefault					= MAKELCID( langidDefault, sortidDefault );
extern const LCID	lcidNone					= MAKELCID( langidNone, sortidNone );

extern const DWORD	dwLCMapFlagsDefaultOBSOLETE	= ( LCMAP_SORTKEY | NORM_IGNORECASE | NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH );
extern const DWORD	dwLCMapFlagsDefault			= ( LCMAP_SORTKEY | NORM_IGNORECASE | NORM_IGNOREKANATYPE | NORM_IGNOREWIDTH );


#ifdef DEBUG
VOID AssertNORMConstants()
	{
	//	since we now persist LCMapString() flags, we must verify
	//	that NT doesn't change them from underneath us
	Assert( LCMAP_SORTKEY == 0x00000400 );
	Assert( LCMAP_BYTEREV == 0x00000800 );
	Assert( NORM_IGNORECASE == 0x00000001 );
	Assert( NORM_IGNORENONSPACE == 0x00000002 );
	Assert( NORM_IGNORESYMBOLS == 0x00000004 );
	Assert( NORM_IGNOREKANATYPE == 0x00010000 );
	Assert( NORM_IGNOREWIDTH == 0x00020000 );
	Assert( SORT_STRINGSORT == 0x00001000 );

	Assert( sortidDefault == 0 );
	Assert( langidDefault == 0x0409 );
	Assert( lcidDefault == 0x00000409 );
	Assert( sortidNone == 0 );
	Assert( langidNone == 0 );
	Assert( lcidNone == 0 );

	CallS( ErrNORMCheckLcid( lcidDefault ) );
	CallS( ErrNORMCheckLCMapFlags( dwLCMapFlagsDefault ) );
	}
#endif	

const LCID LcidFromLangid( const LANGID langid )
	{
	return MAKELCID( langid, sortidDefault );
	}

const LANGID LangidFromLcid( const LCID lcid )
	{
	return LANGIDFROMLCID( lcid );
	}

ERR ErrNORMCheckLcid( const LCID lcid )
	{
	//	don't support LCID_SUPPORTED, must always have the lcid installed before using it
	const BOOL	fValidLocale	= ( lcidNone != lcid && IsValidLocale( lcid, LCID_INSTALLED ) );
	return ( fValidLocale ? JET_errSuccess : ErrNORMReportInvalidLcid( lcid ) );
	}
ERR ErrNORMCheckLcid( LCID * const plcid )
	{
	//	lcidNone filtered out before calling this function
	Assert( lcidNone != *plcid );

	//	if langid is system default, then coerce to system default
	if ( *plcid == LOCALE_SYSTEM_DEFAULT )
		{
		*plcid = GetSystemDefaultLCID();
		}
	else if ( *plcid == LOCALE_USER_DEFAULT )
		{
		*plcid = GetUserDefaultLCID();
		}

	return ErrNORMCheckLcid( *plcid );
	}


ERR ErrNORMCheckLCMapFlags( const DWORD dwLCMapFlags )
	{
	const DWORD		dwValidFlags	= ( LCMAP_BYTEREV
										| NORM_IGNORECASE
										| NORM_IGNORENONSPACE
										| NORM_IGNORESYMBOLS
										| NORM_IGNOREKANATYPE
										| NORM_IGNOREWIDTH
										| SORT_STRINGSORT );

	//	MUST have at least LCMAP_SORTKEY
	return ( LCMAP_SORTKEY == ( dwLCMapFlags & ~dwValidFlags ) ?
				JET_errSuccess :
				ErrNORMReportInvalidLCMapFlags( dwLCMapFlags ) );
	}
ERR ErrNORMCheckLCMapFlags( DWORD * const pdwLCMapFlags )
	{
	*pdwLCMapFlags |= LCMAP_SORTKEY;
	return ErrNORMCheckLCMapFlags( *pdwLCMapFlags );
	}


//	allocates memory for psz using new []
ERR ErrNORMGetLcidInfo( const LCID lcid, const LCTYPE lctype, _TCHAR ** psz )
	{
	ERR			err			= JET_errSuccess;
	const INT	cbNeeded	= GetLocaleInfo( lcid, lctype, NULL, 0 );

	if ( NULL == ( *psz = new _TCHAR[cbNeeded] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	else
		{
		const INT	cbT		= GetLocaleInfo( lcid, lctype, *psz, cbNeeded );

		Assert( cbT == cbNeeded );
		if ( 0 == cbT )
			{
			Call( ErrERRCheck( JET_errInternalError ) );
			}
		}

HandleError:
	return err;
	}


ERR ErrNORMReportInvalidLcid( const LCID lcid )
	{
	ERR 			err				= JET_errSuccess;
	_TCHAR			szT[16];
	_TCHAR			szPID[16];
	_TCHAR *		szLanguage		= NULL;
	_TCHAR *		szEngLanguage 	= NULL;
	
	const _TCHAR*	rgszT[6]	= { SzUtilProcessName(), szPID, "", szT, NULL, NULL };

	//	these routines allocate memory, remember to free it with delete[]
	
	Call( ErrNORMGetLcidInfo( lcid, LOCALE_SLANGUAGE, &szLanguage ) );	
	Call( ErrNORMGetLcidInfo( lcid, LOCALE_SENGLANGUAGE, &szEngLanguage ) );

	rgszT[4] = szLanguage;
	rgszT[5] = szEngLanguage;
	
	_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
	_stprintf( szT, _T( "0x%0*x" ), sizeof(LCID)*2, lcid );
	OSEventReportEvent(
			SzUtilImageVersionName(),
			eventError,
			GENERAL_CATEGORY,
			LANGUAGE_NOT_SUPPORTED_ID,
			6,
			rgszT );
	err = ErrERRCheck( JET_errInvalidLanguageId );

HandleError:
	delete [] szEngLanguage;
	delete [] szLanguage;
	
	return err;
	}

ERR ErrNORMReportInvalidLCMapFlags( const DWORD dwLCMapFlags )
	{
	_TCHAR			szT[16];
	_TCHAR			szPID[16];
	const _TCHAR*	rgszT[4]	= { SzUtilProcessName(), szPID, "", szT };

	_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
	_stprintf( szT, _T( "0x%0*x" ), sizeof(DWORD)*2, dwLCMapFlags );
	OSEventReportEvent(
			SzUtilImageVersionName(),
			eventError,
			GENERAL_CATEGORY,
			INVALID_LCMAPFLAGS_ID,
			4,
			rgszT );
	return ErrERRCheck( JET_errInvalidLCMapStringFlags );
	}



//	We are relying on the fact that the normalised key will never be
//	smaller than the original data, so we know that we can normalise
//	at most cbKeyMax characters.
const ULONG		cbColumnNormMost	= JET_cbKeyMost + 1;	//	ensure word-aligned

//	UNDONE: refine this constant based on unicode key format
//	Allocate enough for the common case - if more is required it will be
//	allocated dynamically
const ULONG		cbUnicodeKeyMost	= cbColumnNormMost * 3 + 32;

/*	From K.D. Chang, Lori Brownell, and Julie Bennett, here's the maximum
	sizes, in bytes, of a normalised string returned by LCMapString():

	If there are no Japanese Katakana or Hiragana characters:
	(number of input chars) * 4 + 5
	(number of input chars) * 3 + 5		// IgnoreCase

	If there are Japanese Katakana or Hiragana characters:
	(number of input chars) * 8 + 5
	(number of input chars) * 5 + 5		// IgnoreCase, IgnoreKanatype, IgnoreWidth

	So given that we ALWAYS specify IgnoreCase, IgnoreKanatype, and
	IgnoreWidth, that means our cbUnicodeKeyMost constant will almost
	always be enough to	satisfy any call to LCMapString(), except if
	Japanese Katakana or Hiragana characters are in a very long string
	(160 bytes or more), in which case we may need to make multiple calls
	to LCMapString() and dynamically allocate a big	enough buffer.
*/


#ifdef DEBUG_NORM
VOID NORMPrint( const BYTE * const pb, const INT cb )
	{
	INT		cbT		= 0;

	while ( cbT < cb )
		{
		INT	i;
		INT	cbTSav	= cbT;
		for ( i = 0; i < 16; i++ )
			{
			if ( cbT < cb )
				{
				printf( "%02x ", pb[cbT] );
				cbT++;
				}
			else
				{
				printf( "   " );
				}
			}

		cbT = cbTSav;
		for ( i = 0; i < 16; i++ )
			{
			if ( cbT < cb )
				{
				printf( "%c", ( isprint( pb[cbT] ) ? pb[cbT] : '.' ) );
				cbT++;
				}
			else
				{
				printf( " " );
				}
			}
		printf( "\n" );
		}
	}
#endif	//	DEBUG_NORM


INLINE CbNORMMapString_(
	const LCID			lcid,
	const DWORD			dwLCMapFlags,
	BYTE *				pbColumn,
	const INT			cbColumn,
	BYTE *				rgbKey,
	const INT			cbKeyMost )
	{
	Assert( fUnicodeSupport );

	return LCMapStringW(
					lcid,
					dwLCMapFlags,
					(LPCWSTR)pbColumn,
					cbColumn / sizeof(WCHAR),
					(LPWSTR)rgbKey,
					cbKeyMost );
	}

ERR ErrNORMMapString(
	const LCID		lcid,
	const DWORD		dwLCMapFlags,
	BYTE *			pbColumn,
	INT				cbColumn,
	BYTE * const	rgbSeg,
	const INT		cbMax,
	INT * const		pcbSeg )
	{
	ERR				err							= JET_errSuccess;
	BYTE    		rgbKey[cbUnicodeKeyMost];
	INT				cbKey;

	if ( !fUnicodeSupport )
		return ErrERRCheck( JET_errUnicodeNormalizationNotSupported );

	//	assert key buffer doesn't exceed maximum (minus header byte)
	Assert( cbMax < JET_cbKeyMost );

	//	assert non-zero length unicode string
	Assert( cbColumn > 0 );
	cbColumn = min( cbColumn, cbColumnNormMost );

	Assert( cbColumn > 0 );
	Assert( cbColumn % 2 == 0 );

#ifdef _X86_
#else
	//	convert pbColumn to aligned pointer for MIPS/Alpha builds
	BYTE    rgbColumn[cbColumnNormMost];
	UtilMemCpy( rgbColumn, pbColumn, cbColumn );
	pbColumn = rgbColumn;
#endif

	Assert( lcidNone != lcid );

	cbKey = CbNORMMapString_(
					lcid,
					dwLCMapFlags,
					pbColumn,
					cbColumn,
					rgbKey,
					cbUnicodeKeyMost );
		
	if ( 0 == cbKey )
		{
		const DWORD	dw		= GetLastError();

		if ( ERROR_INSUFFICIENT_BUFFER == dw )
			{
			//	ERROR_INSUFFICIENT_BUFFER means that our preallocated buffer was not big enough
			//	to hold the normalised string.  This should only happen in *extremely* rare
			//	circumstances (see comments just above this function).
			//	So what we have to do here is call LCMapString() again with a NULL buffer.
			//	This will return to us the size, in bytes, of the normalised string without
			//	actually returning the normalised string.  We then dynamically allocate
			//	a buffer of the specified size, then make the call to LCMapString() again
			//	using that buffer.
			//	UNDONE: We could avoid this whole path if LCMapString() normalised as much
			//	as possible even if the buffer is not large enough.  Unfortunately, it does
			//	not work that way.

			cbKey = CbNORMMapString_(
							lcid,
							dwLCMapFlags,
							pbColumn,
							cbColumn,
							NULL,
							0 );
			if ( 0 != cbKey )
				{
				BYTE		*pbNormBuf;
				const ULONG	cbNormBuf	= cbKey;

				Assert( IsValidLocale( lcid, LCID_INSTALLED ) );

				//	we should be guaranteed to overrun the default buffer
				//	and also the remaining key space
				Assert( cbKey > cbUnicodeKeyMost );
				Assert( cbKey > cbMax );

				pbNormBuf = (BYTE *)PvOSMemoryHeapAlloc( cbNormBuf );
				if ( NULL == pbNormBuf )
					{
					err = ErrERRCheck( JET_errOutOfMemory );
					}
				else
					{
					cbKey = CbNORMMapString_(
									lcid,
									dwLCMapFlags,
									pbColumn,
									cbColumn,
									pbNormBuf,
									cbNormBuf );

					//	this call shouldn't fail because we've
					//	already validated the lcid and
					//	allocated a sufficiently large buffer
					Assert( 0 != cbKey );

					if ( 0 != cbKey )
						{
						Assert( IsValidLocale( lcid, LCID_INSTALLED ) );
						Assert( cbKey > cbMax );
						Assert( cbNormBuf == cbKey );
						UtilMemCpy( rgbSeg, pbNormBuf, cbMax );
						*pcbSeg = cbMax;
						err = ErrERRCheck( wrnFLDKeyTooBig );
						}

					OSMemoryHeapFree( pbNormBuf );
					}
				}
			}

		if ( 0 == cbKey )
			{
			//	this code path should no longer be accessible,
			//	since we now pre-validate the lcid when
			//	we create the index or open the table
			Assert( fFalse );

			//	cbKey is 0 if WindowsNT installation does not
			//	support language id.  This can happen if a
			//	database is moved from one machine to another.

			const DWORD		dwT			= GetLastError();	
			Assert( ERROR_INSUFFICIENT_BUFFER != dwT );

			err = ErrNORMReportInvalidLcid( lcid );
			}
		}
	else
		{
		Assert( cbKey > 0 );
		Assert( IsValidLocale( lcid, LCID_INSTALLED ) );

		if ( cbKey > cbMax )
			{
			err = ErrERRCheck( wrnFLDKeyTooBig );
			*pcbSeg = cbMax;
			}
		else
			{
			CallS( err );
			*pcbSeg = cbKey;
			}
		UtilMemCpy( rgbSeg, rgbKey, *pcbSeg );
		}

#ifdef DEBUG_NORM
	printf( "\nOriginal Text (length %d):\n", cbColumn );
	NORMPrint( pbColumn, cbColumn );
	printf( "Normalized Text (length %d):\n", *pcbSeg );
	NORMPrint( rgbSeg, *pcbSeg );
	printf( "\n" );
#endif	

	return err;
	}



#ifdef DEAD_CODE

ERR ErrNORMWideCharToMultiByte(	unsigned int CodePage,
								DWORD dwFlags,
								const wchar_t* lpWideCharStr,
								int cwchWideChar,
								char* lpMultiByteStr,
								int cchMultiByte,
								const char* lpDefaultChar,
								BOOL* lpUsedDefaultChar,
								int* pcchMultiByteActual )
	{
	int cch = WideCharToMultiByte( CodePage, dwFlags, lpWideCharStr,
				cwchWideChar, lpMultiByteStr, cchMultiByte, lpDefaultChar, lpUsedDefaultChar );
	if (!cch )
		{
		DWORD dw = GetLastError();
		if ( dw == ERROR_INSUFFICIENT_BUFFER )
			return ErrERRCheck( JET_errUnicodeTranslationBufferTooSmall );
		else
			{
			Assert( dw == ERROR_INVALID_FLAGS ||
			    	dw == ERROR_INVALID_PARAMETER );
			return ErrERRCheck( JET_errUnicodeTranslationFail );
			}
		}
	*pcchMultiByteActual = cch;
	return JET_errSuccess;
	}

ERR ErrNORMMultiByteToWideChar(	unsigned int CodePage,			// code page
								DWORD dwFlags,					// character-type options
								const char* lpMultiByteStr,		// address of string to map
								int cchMultiByte,				// number of characters in string
								wchar_t* lpWideCharStr,			// address of wide-character buffer 
								int cwchWideChar,				// size of buffer
								int* pcwchActual )
	{
	int cwch = MultiByteToWideChar( CodePage, dwFlags, lpMultiByteStr,
			cchMultiByte, lpWideCharStr, cwchWideChar );
	if (!cwch )
		{
		DWORD dw = GetLastError();
		if ( dw == ERROR_INSUFFICIENT_BUFFER )
			return ErrERRCheck( JET_errUnicodeTranslationBufferTooSmall );
		else
			{
			Assert( dw == ERROR_INVALID_FLAGS ||
			 		dw == ERROR_INVALID_PARAMETER ||
			 		dw == ERROR_NO_UNICODE_TRANSLATION );
			return ErrERRCheck( JET_errUnicodeTranslationFail );
			}
		}

	*pcwchActual = cwch;
	return JET_errSuccess;
	}

#endif	//	DEAD_CODE


//  post-terminate norm subsystem

void OSNormPostterm()
	{
	//  nop
	}

//  pre-init norm subsystem

BOOL FOSNormPreinit()
	{
	//  nop

	return fTrue;
	}


//  terminate norm subsystem

void OSNormTerm()
	{
	fUnicodeSupport = fFalse;
	}

//  init norm subsystem

ERR ErrOSNormInit()
	{
	fUnicodeSupport = ( 0 != LCMapStringW( LOCALE_NEUTRAL, LCMAP_LOWERCASE, L"\0", 1, NULL, 0 ) );
	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\library.cxx ===
#include "osstd.hxx"


//  Dynamically Loaded Libraries

//  loads the library from the specified file, returning fTrue and the library
//  handle on success

BOOL FUtilLoadLibrary( const _TCHAR* szLibrary, LIBRARY* plibrary, const BOOL fPermitDialog )
	{
	while ( NULL == ( *plibrary = (LIBRARY)LoadLibrary( (LPTSTR)szLibrary ) )
		&& fPermitDialog )
		{		
		_TCHAR szMessage[256];
		(void)_stprintf(
			szMessage,
			_T( 	"Unable to find the callback library %s (or one of its dependencies).\r\n"
					"Copy in the file and hit OK to retry, or hit Cancel to abort.\r\n" ),
			szLibrary );

		const int id = MessageBox(
							NULL,
							szMessage,
							_T( "Callback DLL not found" ),
							MB_SERVICE_NOTIFICATION | MB_SYSTEMMODAL | MB_ICONSTOP |
							MB_OKCANCEL );

		if ( IDOK != id )
			{
			break;
			}
		}
		
	return ( NULL != *plibrary );
	}

//  retrieves the function pointer from the specified library or NULL if that
//  function is not found in the library

PFN PfnUtilGetProcAddress( LIBRARY library, const char* szFunction )
	{
	return (PFN) GetProcAddress( (HMODULE) library, szFunction );
	}

//  unloads the specified library

void UtilFreeLibrary( LIBRARY library )
	{
	FreeLibrary( (HMODULE) library );
	}

	
//  post-terminate library subsystem

void OSLibraryPostterm()
	{
	//  nop
	}

//  pre-init library subsystem

BOOL FOSLibraryPreinit()
	{
	//  nop

	return fTrue;
	}


//  terminate library subsystem

void OSLibraryTerm()
	{
	//  nop
	}

//  init library subsystem

ERR ErrOSLibraryInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\osstd.cxx ===
#include "osstd.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\sysinfo.cxx ===
#include "osstd.hxx"

#include "ntverp.h"

//  Process Attributes

//  returns the current process' name

LOCAL _TCHAR szProcessName[_MAX_FNAME];

const _TCHAR* SzUtilProcessName()
	{
	return szProcessName;
	}

//  returns the current process' path

LOCAL _TCHAR szProcessPath[_MAX_FNAME];

const _TCHAR* SzUtilProcessPath()
	{
	return szProcessPath;
	}

//  returns the current process ID

LOCAL DWORD dwProcessId;

const DWORD DwUtilProcessId()
	{
	return dwProcessId;
	}

//  returns the number of system processors on which the current process can execute

LOCAL DWORD cProcessProcessor;

const DWORD CUtilProcessProcessor()
	{
	return cProcessProcessor;
	}

//  returns fTrue if the current process is terminating abnormally

volatile BOOL fProcessAbort;

const BOOL FUtilProcessAbort()
	{
	return fProcessAbort;
	}


//  System Attributes

//  retrieves system major version

LOCAL DWORD dwSystemVersionMajor;

DWORD DwUtilSystemVersionMajor()
	{
	return dwSystemVersionMajor;
	}

//  retrieves system minor version

LOCAL DWORD dwSystemVersionMinor;

DWORD DwUtilSystemVersionMinor()
	{
	return dwSystemVersionMinor;
	}

//  retrieves system major build number

LOCAL DWORD dwSystemBuildNumber;

DWORD DwUtilSystemBuildNumber()
	{
	return dwSystemBuildNumber;
	}

//  retrieves system service pack number

LOCAL DWORD dwSystemServicePackNumber;

DWORD DwUtilSystemServicePackNumber()
	{
	return dwSystemServicePackNumber;
	}

//  returns fTrue if idle activity should be avoided

BOOL FUtilSystemRestrictIdleActivity()
	{
	const DWORD			dtickCheck		= 60 * 1000;
	static DWORD		tickLastCheck	= GetTickCount() - dtickCheck;
	static BOOL			fLastResult		= fTrue;

	if ( GetTickCount() - tickLastCheck >= dtickCheck )
		{
		SYSTEM_POWER_STATUS	sps;

		fLastResult		= !GetSystemPowerStatus( &sps ) || sps.ACLineStatus != 1;
		tickLastCheck	= GetTickCount();
		}

	return fLastResult;
	}


//  Image Attributes

//  retrieves image base address

VOID * pvImageBaseAddress;

const VOID * PvUtilImageBaseAddress()
	{
	return pvImageBaseAddress;
	}

//  retrieves image name

LOCAL _TCHAR szImageName[_MAX_FNAME];

const _TCHAR* SzUtilImageName()
	{
	return szImageName;
	}

//  retrieves image path

LOCAL _TCHAR szImagePath[_MAX_PATH];

const _TCHAR* SzUtilImagePath()
	{
	return szImagePath;
	}

//  retrieves image version name

LOCAL _TCHAR szImageVersionName[_MAX_FNAME];

const _TCHAR* SzUtilImageVersionName()
	{
	return szImageVersionName;
	}

//  retrieves image major version

LOCAL DWORD dwImageVersionMajor;

DWORD DwUtilImageVersionMajor()
	{
	return dwImageVersionMajor;
	}

//  retrieves image minor version

LOCAL DWORD dwImageVersionMinor;

DWORD DwUtilImageVersionMinor()
	{
	return dwImageVersionMinor;
	}

//  retrieves image major build number

LOCAL DWORD dwImageBuildNumberMajor;

DWORD DwUtilImageBuildNumberMajor()
	{
	return dwImageBuildNumberMajor;
	}

//  retrieves image minor build number

LOCAL DWORD dwImageBuildNumberMinor;

DWORD DwUtilImageBuildNumberMinor()
	{
	return dwImageBuildNumberMinor;
	}

//  retrieves image build class

LOCAL _TCHAR szImageBuildClass[_MAX_FNAME];

const _TCHAR* SzUtilImageBuildClass()
	{
	return szImageBuildClass;
	}


//  ^C and ^Break handler for process termination

BOOL WINAPI UtilSysinfoICtrlHandler( DWORD dwCtrlType )
	{
	//  set process to aborting status

	fProcessAbort = fTrue;
	return FALSE;
	}


//	do all processors in the system have the PrefetchNTA capability?

LOCAL BOOL fHardwareCanPrefetch;

BOOL FHardwareCanPrefetch()
	{
	return fHardwareCanPrefetch;
	}

LOCAL BOOL FDeterminePrefetchCapability()
	{
	BOOL fCanPrefetch = FALSE;
	
#ifdef _X86_
    ULONG    Features;
    ULONG    i;
    DWORD    OriginalAffinity;

 	SYSTEM_INFO system_inf;
 	GetSystemInfo( &system_inf );
 
    //
    // First check to see that I have at least Intel Pentium.  This simplifies
    // the cpuid
    //
    if (system_inf.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL ||
        system_inf.wProcessorLevel < 5)
	 	{
		return fCanPrefetch;
		}
	
	fCanPrefetch = TRUE;
 
    //
    // Affinity thread to boot processor
    //
 
	OriginalAffinity = SetThreadAffinityMask(GetCurrentThread(), 1);
 
	// Here we want to go through each CPU, so use the systeminfo # of
	// processors instead of gdwSchedulerCount
	//
	for ( i = 0; i < system_inf.dwNumberOfProcessors && fCanPrefetch; i++ )
		{
		if ( i != 0 )
			{
			SetThreadAffinityMask(GetCurrentThread(), 1 << i);
			}
 
		_asm
			{
			push   ebx
            mov    eax, 1	; cpuid
            _emit  0fh
            _emit  0a2h
 
            mov    Features, edx
            pop    ebx
			}
 
        //
        // Check for Prefetch Present
        //
        if (!(Features & 0x02000000))
			{
 
            //
            // All processors must have prefetch before we can use it.
            // We start with it enabled, if any processor does not have
            // it, we clear it and bail
 
            fCanPrefetch = FALSE;
			}
		}
		SetThreadAffinityMask(GetCurrentThread(), OriginalAffinity);		
#endif
	return fCanPrefetch;
	}


//  process module name to friendly name translation tables

LOCAL const _TCHAR* rglpszProcName[] =
	{
	_T( "dsamain" ),
	_T( "lsass" ),
	_T( "store" ),
	NULL
	};

//  UNDONE:  these should be localized

LOCAL const _TCHAR* rglpszFriendlyName[] =
	{
	_T( "Directory" ),
	_T( "NT Directory" ),
	_T( "Information Store" ),
	NULL
	};


//  post-terminate sysinfo subsystem

void OSSysinfoPostterm()
	{
	(void)SetConsoleCtrlHandler( UtilSysinfoICtrlHandler, FALSE );
	}

//  pre-init sysinfo subsystem

BOOL FOSSysinfoPreinit()
	{
	//  cache process name and path

	GetModuleFileName( NULL, szProcessPath, sizeof( szProcessPath ) );
	_tsplitpath( (const _TCHAR *)szProcessPath, NULL, NULL, szProcessName, NULL );

	long iprocname;
	for ( iprocname = 0; rglpszProcName[iprocname]; iprocname++ )
		{
		if ( !_tcsicmp( szProcessName, rglpszProcName[iprocname] ) )
			{
			_tcscpy( szProcessName, rglpszFriendlyName[iprocname] );
			}
		}

	//  cache process id

	dwProcessId = GetCurrentProcessId();

	//  cache process processor count

	DWORD_PTR maskProcess;
	DWORD_PTR maskSystem;
	BOOL fGotAffinityMask;
	fGotAffinityMask = GetProcessAffinityMask(	GetCurrentProcess(),
												&maskProcess,
												&maskSystem );
	Assert( fGotAffinityMask );

	for ( cProcessProcessor = 0; maskProcess != 0; maskProcess >>= 1 )
		{
		if ( maskProcess & 1 )
			{
			cProcessProcessor++;
			}
		}

	//  cache system attributes

	OSVERSIONINFO ovi;
	ovi.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
	if ( !GetVersionEx( &ovi ) )
		{
		goto HandleError;
        }

    dwSystemVersionMajor = ovi.dwMajorVersion;
    dwSystemVersionMinor = ovi.dwMinorVersion;
    dwSystemBuildNumber = ovi.dwBuildNumber;
    //  string of format "Service Pack %d"
    _TCHAR* szN;
    szN = _tcspbrk( ovi.szCSDVersion, _T( "0123456789" ) );
    dwSystemServicePackNumber = szN ? _ttol( szN ) : 0;

    //  cache image name and path

	MEMORY_BASIC_INFORMATION mbi;
	if ( !VirtualQueryEx( GetCurrentProcess(), FOSSysinfoPreinit, &mbi, sizeof( mbi ) ) )
		{
		goto HandleError;
		}
	if ( !GetModuleFileName( HINSTANCE( mbi.AllocationBase ), szImagePath, sizeof( szImagePath ) ) )
		{
		goto HandleError;
		}
	_tsplitpath( (const _TCHAR *)szImagePath, NULL, NULL, szImageName, NULL );
	pvImageBaseAddress = mbi.AllocationBase;

	//  cache image attributes

    _tcscpy( szImageVersionName, _T( SZVERSIONNAME ) );

	//	these constants come from ntverp.h
	dwImageVersionMajor = VER_PRODUCTMAJORVERSION;
	dwImageVersionMinor = VER_PRODUCTMINORVERSION;
	dwImageBuildNumberMajor = VER_PRODUCTBUILD;
	dwImageBuildNumberMinor = VER_PRODUCTBUILD_QFE;

	szImageBuildClass[0] = 0;
#ifdef DEBUG
	_tcscat( szImageBuildClass, _T( "DEBUG" ) );
#else  //  !DEBUG
	_tcscat( szImageBuildClass, _T( "RETAIL" ) );
#endif  //  DEBUG
#ifdef PROFILE
	_tcscat( szImageBuildClass, _T( " PROFILE" ) );
#endif  //  DEBUG
#ifdef RTM
	_tcscat( szImageBuildClass, _T( " RTM" ) );
#endif  //  RTM
#ifdef _UNICODE
	_tcscat( szImageBuildClass, _T( " UNICODE" ) );
#else  //  !_UNICODE
#ifdef _MBCS
	_tcscat( szImageBuildClass, _T( " MBCS" ) );
#else  //  !_MBCS
	_tcscat( szImageBuildClass, _T( " ASCII" ) );
#endif  //  _MBCS
#endif  //  _UNICODE

	//  setup ^C and ^Break handler for process termination if in console mode

	(void)SetConsoleCtrlHandler( UtilSysinfoICtrlHandler, TRUE );

	//	determine processor prefetch capability
	
	fHardwareCanPrefetch = FDeterminePrefetchCapability();
	
	return fTrue;

HandleError:
	OSSysinfoPostterm();
	return fFalse;
	}


//  terminate sysinfo subsystem

void OSSysinfoTerm()
	{
	//  nop
	}

//  init sysinfo subsystem

ERR ErrOSSysinfoInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\perfmon.cxx ===
#include "osstd.hxx"

#include <wchar.h>
#include <winperf.h>
#include <aclapi.h>


	/*  Init/Term routines for performance monitoring
	/**/

HANDLE	hPERFGDAMMF				= NULL;
PGDA	pgdaPERFGDA				= NULL;

HANDLE	hPERFInstanceMutex		= NULL;
HANDLE	hPERFIDAMMF				= NULL;
PIDA	pidaPERFIDA				= NULL;
HANDLE	hPERFGoEvent			= NULL;
HANDLE	hPERFReadyEvent			= NULL;
DWORD	cbMaxCounterBlockSize	= 0;
DWORD	cbInstanceSize			= 0;

HANDLE	hPERFEndDataThread		= NULL;
THREAD	threadPERFData			= NULL;

extern DWORD UtilPerfThread( DWORD_PTR dw );

void UtilPerfTerm(void)
	{
	DWORD	dwCurObj;
	DWORD	dwCurCtr;

	/*  end the performance data thread
	/**/
	if ( threadPERFData )
		{
		SetEvent( hPERFEndDataThread );
		UtilThreadEnd( threadPERFData );
		threadPERFData = NULL;
		}
	if ( hPERFEndDataThread )
		{
		CloseHandle( hPERFEndDataThread );
		hPERFEndDataThread = NULL;
		}

	/*  terminate all counters/objects
	/**/
	if ( cbInstanceSize )
		{
		for (dwCurObj = 0; dwCurObj < dwPERFNumObjects; dwCurObj++)
			(void)rgpicfPERFICF[dwCurObj](ICFTerm,NULL);
		for (dwCurCtr = 0; dwCurCtr < dwPERFNumCounters; dwCurCtr++)
			(void)rgpcefPERFCEF[dwCurCtr](CEFTerm,NULL);

		cbInstanceSize = 0;
		cbMaxCounterBlockSize = 0;
		}
	}

INLINE _TCHAR* SzPerfGlobal()
	{
	OSVERSIONINFO osverinfo;
	osverinfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
	if ( !GetVersionEx( &osverinfo ) ) 
		{
		return _T("");
		}
	//	Under Win2000 terminal server object names must be preceded by Global\
	//	to share the same name space
	return ( VER_PLATFORM_WIN32_NT == osverinfo.dwPlatformId && 5 <= osverinfo.dwMajorVersion )? _T("Global\\"): _T("");
	}

ERR ErrUtilPerfInit(void)
	{
	ERR							err;
	DWORD						dwCurObj;
	DWORD						dwCurCtr;
	DWORD						dwOffset;
	PPERF_OBJECT_TYPE			ppotObjectSrc;
	PPERF_INSTANCE_DEFINITION	ppidInstanceSrc;
	PPERF_COUNTER_DEFINITION	ppcdCounterSrc;
	
	/*  initialize all objects/counters
	/**/
	for (dwCurObj = 0; dwCurObj < dwPERFNumObjects; dwCurObj++)
		{
		if (rgpicfPERFICF[dwCurObj](ICFInit,NULL))
			{
			for (dwCurObj--; long( dwCurObj ) >= 0; dwCurObj--)
				rgpicfPERFICF[dwCurObj](ICFTerm,NULL);
				
			Call( ErrERRCheck( JET_errPermissionDenied ) );
			}
		}

	for (dwCurCtr = 0; dwCurCtr < dwPERFNumCounters; dwCurCtr++)
		{
		if (rgpcefPERFCEF[dwCurCtr](CEFInit,NULL))
			{
			for (dwCurCtr--; long( dwCurCtr ) >= 0; dwCurCtr--)
				rgpcefPERFCEF[dwCurCtr](CEFTerm,NULL);
			for (dwCurObj = dwPERFNumObjects-1; long( dwCurObj ) >= 0; dwCurObj--)
				rgpicfPERFICF[dwCurObj](ICFTerm,NULL);
				
			Call( ErrERRCheck( JET_errPermissionDenied ) );
			}
		}

	/*  initialize counter offsets and calculate instance size from template data
	/**/
	ppotObjectSrc = (PPERF_OBJECT_TYPE)pvPERFDataTemplate;
	ppidInstanceSrc = (PPERF_INSTANCE_DEFINITION)((char *)ppotObjectSrc + ppotObjectSrc->DefinitionLength);
	cbMaxCounterBlockSize = QWORD_MULTIPLE( sizeof(PERF_COUNTER_BLOCK) );
	for (dwCurObj = 0; dwCurObj < dwPERFNumObjects; dwCurObj++)
		{
		ppcdCounterSrc = (PPERF_COUNTER_DEFINITION)((char *)ppotObjectSrc + ppotObjectSrc->HeaderLength);
		dwOffset = QWORD_MULTIPLE( sizeof(PERF_COUNTER_BLOCK) );
		for (dwCurCtr = 0; dwCurCtr < ppotObjectSrc->NumCounters; dwCurCtr++)
			{
			ppcdCounterSrc->CounterOffset = dwOffset;
			dwOffset += QWORD_MULTIPLE( ppcdCounterSrc->CounterSize );
			
			ppcdCounterSrc = (PPERF_COUNTER_DEFINITION)((char *)ppcdCounterSrc + ppcdCounterSrc->ByteLength);
			}

		cbMaxCounterBlockSize = max(cbMaxCounterBlockSize,dwOffset);
		
		ppotObjectSrc = (PPERF_OBJECT_TYPE)((char *)ppotObjectSrc + ppotObjectSrc->TotalByteLength);
		}
	cbInstanceSize = ppidInstanceSrc->ByteLength + cbMaxCounterBlockSize;

	/*  create our performance data thread
	/**/
	if ( !( hPERFEndDataThread = CreateEvent( NULL, FALSE, FALSE, NULL ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	Call( ErrUtilThreadCreate(	UtilPerfThread,
								OSMemoryPageReserveGranularity(),
								priorityTimeCritical,
								&threadPERFData,
								NULL ) );

	return JET_errSuccess;

HandleError:
	UtilPerfTerm();
	return err;
	}

void UtilPerfThreadTerm(void)
	{
	/*  terminate all resources
	/**/
	if ( hPERFReadyEvent )
		{
		SetHandleInformation( hPERFReadyEvent, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hPERFReadyEvent );
		hPERFReadyEvent = NULL;
		}

	if ( hPERFGoEvent )
		{
		SetHandleInformation( hPERFGoEvent, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hPERFGoEvent );
		hPERFGoEvent = NULL;
		}

	if ( pidaPERFIDA )
		{
		UnmapViewOfFile( pidaPERFIDA );
		pidaPERFIDA = NULL;
		}

	if ( hPERFIDAMMF )
		{
		SetHandleInformation( hPERFIDAMMF, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hPERFIDAMMF );
		hPERFIDAMMF = NULL;
		}

	if ( hPERFInstanceMutex )
		{
		ReleaseMutex( hPERFInstanceMutex );
		SetHandleInformation( hPERFInstanceMutex, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hPERFInstanceMutex );
		hPERFInstanceMutex = NULL;
		}

	if ( pgdaPERFGDA )
		{
		UnmapViewOfFile( pgdaPERFGDA );
		pgdaPERFGDA = NULL;
		}

	if ( hPERFGDAMMF )
		{
		SetHandleInformation( hPERFGDAMMF, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hPERFGDAMMF );
		hPERFGDAMMF = NULL;
		}
	}


ERR ErrUtilPerfThreadInit(void)
	{
	ERR							err							= JET_errSuccess;
	SID_IDENTIFIER_AUTHORITY	siaWorldSidAuthority		= SECURITY_WORLD_SID_AUTHORITY;
	SID_IDENTIFIER_AUTHORITY	siaLocalSystemSidAuthority	= SECURITY_NT_AUTHORITY;
	PSID						psidWorldSid				= NULL;
	PSID						psidLocalSystemSid			= NULL;
	size_t						cbAcl						= 0;
	PACL						pacl						= NULL;
	PSECURITY_DESCRIPTOR		pSD							= NULL;
	SECURITY_ATTRIBUTES			sa							= { 0 };
	_TCHAR						szT[ 256 ];
	
	/*  create a SD that will be used to create our global objects
	/**/
	if ( !AllocateAndInitializeSid (	&siaWorldSidAuthority,
										1,
										SECURITY_WORLD_RID,
										0,
										0,
										0,
										0,
										0,
										0,
										0,
										&psidWorldSid ) )
		{
		Call( ErrERRCheck( JET_errPermissionDenied ) );
		}

	if ( !AllocateAndInitializeSid (	&siaLocalSystemSidAuthority,
										2,
										SECURITY_BUILTIN_DOMAIN_RID,
										DOMAIN_ALIAS_RID_ADMINS,
										0,
										0,
										0,
										0,
										0,
										0,
										&psidLocalSystemSid ) )
		{
		Call( ErrERRCheck( JET_errPermissionDenied ) );
		}

	cbAcl =	sizeof( ACL ) +
			2 * sizeof( ACCESS_ALLOWED_ACE ) +
			GetLengthSid( psidWorldSid ) +
			GetLengthSid( psidLocalSystemSid );

	Alloc( pacl = (PACL)LocalAlloc( 0, cbAcl ) );

	if ( !InitializeAcl(	pacl,
							cbAcl,
							ACL_REVISION2 ) )
		{
		Call( ErrERRCheck( JET_errPermissionDenied ) );
		}

	if ( !AddAccessAllowedAce (	pacl,
								ACL_REVISION2,
								GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
								psidWorldSid ) )
		{
		Call( ErrERRCheck( JET_errPermissionDenied ) );
		}

	if ( !AddAccessAllowedAce (	pacl,
								ACL_REVISION2,
								GENERIC_ALL,
								psidLocalSystemSid ) )
		{
		Call( ErrERRCheck( JET_errPermissionDenied ) );
		}

	Alloc( pSD = (PSECURITY_DESCRIPTOR)LocalAlloc( 0, SECURITY_DESCRIPTOR_MIN_LENGTH ) );

	if ( !InitializeSecurityDescriptor(	pSD,
										SECURITY_DESCRIPTOR_REVISION ) )
		{
		Call( ErrERRCheck( JET_errPermissionDenied ) );
		}

	if ( !SetSecurityDescriptorDacl(	pSD,
										TRUE,
										pacl,
										FALSE ) )
		{
		Call( ErrERRCheck( JET_errPermissionDenied ) );
		}

    sa.nLength = sizeof( SECURITY_DESCRIPTOR );
    sa.lpSecurityDescriptor = pSD;
    sa.bInheritHandle = FALSE;

	/*  open/create the shared global data area
	/**/
	_stprintf( szT, _T( "%sGDA:  %s" ), SzPerfGlobal(), szPERFVersion );
	if ( !( hPERFGDAMMF = CreateFileMapping(	INVALID_HANDLE_VALUE,
												&sa,
												PAGE_READWRITE | SEC_COMMIT,
												0,
												PERF_SIZEOF_GLOBAL_DATA,
												szT ) ) )
		{
		Call( ErrERRCheck( JET_errPermissionDenied ) );
		}
	SetHandleInformation( hPERFGDAMMF, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	if ( !( pgdaPERFGDA = PGDA( MapViewOfFile(	hPERFGDAMMF,
												FILE_MAP_WRITE,
												0,
												0,
												0 ) ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	/*  find an instance number for which we can successfully gain ownership of
	/*  the instance mutex
	/**/
	DWORD iInstance;
	for ( iInstance = 0; ; iInstance++ )
		{
		_stprintf( szT, _T( "%sInstance%d:  %s" ), SzPerfGlobal(), iInstance, szPERFVersion );
		if ( !( hPERFInstanceMutex = CreateMutex( &sa, FALSE, szT ) ) )
			{
			Call( ErrERRCheck( JET_errPermissionDenied ) );
			}

		DWORD errWin;
		errWin = WaitForSingleObject( hPERFInstanceMutex, 0 );

		if ( errWin == WAIT_OBJECT_0 || errWin == WAIT_ABANDONED )
			{
			break;
			}

		CloseHandle( hPERFInstanceMutex );
		hPERFInstanceMutex = NULL;
		}

	SetHandleInformation( hPERFInstanceMutex, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	/*  open/create the shared instance data area
	/**/
	_stprintf( szT, _T( "%sIDA%d:  %s" ), SzPerfGlobal(), iInstance, szPERFVersion );
	if ( !( hPERFIDAMMF = CreateFileMapping(	INVALID_HANDLE_VALUE,
												&sa,
												PAGE_READWRITE | SEC_COMMIT,
												0,
												PERF_SIZEOF_INSTANCE_DATA,
												szT ) ) )
		{
		Call( ErrERRCheck( JET_errPermissionDenied ) );
		}
	SetHandleInformation( hPERFIDAMMF, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	if ( !( pidaPERFIDA = PIDA( MapViewOfFile(	hPERFIDAMMF,
												FILE_MAP_ALL_ACCESS,
												0,
												0,
												0 ) ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	/*	open/create the go event
	/**/
	_stprintf( szT, _T( "%sGo%d:  %s" ), SzPerfGlobal(), iInstance, szPERFVersion );
	if ( !( hPERFGoEvent = CreateEvent( &sa, FALSE, FALSE, szT ) ) )
		{
		Call( ErrERRCheck( JET_errPermissionDenied ) );
		}
	SetHandleInformation( hPERFGoEvent, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	/*	open/create the ready event
	/**/
	_stprintf( szT, _T( "%sReady%d:  %s" ), SzPerfGlobal(), iInstance, szPERFVersion );
	if ( !( hPERFReadyEvent = CreateEvent( &sa, TRUE, FALSE, szT ) ) )
		{
		Call( ErrERRCheck( JET_errPermissionDenied ) );
		}
	SetHandleInformation( hPERFReadyEvent, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	/*  make sure that the performance DLL will check this instance index
	/**/

	while ( pgdaPERFGDA->iInstanceMax <= iInstance )
		{
		AtomicIncrement( (long*)&pgdaPERFGDA->iInstanceMax );
		}

	/*  set our connect time
	/**/
	pidaPERFIDA->tickConnect = GetTickCount();
	
HandleError:
	LocalFree( pacl );
	LocalFree( pSD );
	if ( psidWorldSid )
		{
		FreeSid( psidWorldSid );
		}
	if ( psidLocalSystemSid )
		{
		FreeSid( psidLocalSystemSid );
		}
	if ( err < JET_errSuccess )
		{
		UtilPerfThreadTerm();
		}
	return err;
	}


/*  Performance Data thread  */

DWORD UtilPerfThread( DWORD_PTR parm )
	{
	DWORD						dwCurObj;
	DWORD						dwCurInst;
	DWORD						dwCurCtr;
	DWORD						dwCollectCtr;
	PPERF_OBJECT_TYPE			ppotObjectSrc;
	PPERF_INSTANCE_DEFINITION	ppidInstanceSrc;
	PPERF_INSTANCE_DEFINITION	ppidInstanceDest;
	PPERF_COUNTER_DEFINITION	ppcdCounterSrc;
	PPERF_COUNTER_BLOCK			ppcbCounterBlockDest;
	DWORD						cInstances;
	DWORD						cbSpaceNeeded;
	LPVOID						pvBlock;
	LPWSTR						lpwszInstName;
	LPWSTR						wszName;
	DWORD						cwchName;
	DWORD						cwchNameMax;

	if ( ErrUtilPerfThreadInit() < JET_errSuccess )
		{
		return 0;
		}
	
	for ( ; ; )
		{
		/*  set our ready event to indicate we are done collecting data and / or
		/*  we are ready to collect more data
		/**/
		SetEvent( hPERFReadyEvent );

		/*  wait to either be killed or to be told to collect data
		/**/
		const size_t	chWait				= 2;
		HANDLE			rghWait[ chWait ]	= { hPERFEndDataThread, hPERFGoEvent };
		if ( WaitForMultipleObjectsEx( chWait, rghWait, FALSE, INFINITE, FALSE ) == WAIT_OBJECT_0 )
			{
			break;
			}

		/*  collect instances for all objects
		/**/
		for ( dwCurObj = 0, cInstances = 0; dwCurObj < dwPERFNumObjects; dwCurObj++ )
			{
			rglPERFNumInstances[dwCurObj] = rgpicfPERFICF[dwCurObj](ICFData,
												(const void **)( &rgwszPERFInstanceList[dwCurObj] ) );
			cInstances += rglPERFNumInstances[dwCurObj];
			}

		/*  calculate space needed to store instance data
		/*
		/*  Instance data for all objects is stored in our data block
		/*  in the following format:
		/*
		/*      //  Object 1
		/*      DWORD_PTR cInstances;
		/*      PERF_INSTANCE_DEFINITION rgpidInstances[cInstances];
		/*
		/*      . . . 
		/*
		/*      //  Object n
		/*      DWORD_PTR cInstances;
		/*      PERF_INSTANCE_DEFINITION rgpidInstances[cInstances];
		/*
		/*  The performance DLL can read this structure because it also
		/*  knows how many objects we have and it can also check for the
		/*  end of our data block.
		/*
		/*  NOTE:  If an object has 0 instances, it only has cInstances
		/*      for its data.  No PIDs are produced.
		/**/
		cbSpaceNeeded = cInstances * cbInstanceSize + sizeof( DWORD_PTR ) * dwPERFNumObjects;
		pidaPERFIDA->cbPerformanceData = cbSpaceNeeded;

		/*  verify that we have sufficient store to collect our data
		/**/
		Enforce( PERF_SIZEOF_INSTANCE_DATA - FIELD_OFFSET( IDA, rgbPerformanceData ) >= cbSpaceNeeded );

		/*	get a pointer to our data block
		/**/
		pvBlock = pidaPERFIDA->rgbPerformanceData;

		/*	loop through all objects, filling our block with instance data
		/**/
		dwCurCtr = 0;
		ppotObjectSrc = (PPERF_OBJECT_TYPE)pvPERFDataTemplate;
		ppidInstanceSrc = (PPERF_INSTANCE_DEFINITION)((char *)ppotObjectSrc + ppotObjectSrc->DefinitionLength);
		for (dwCurObj = 0; dwCurObj < dwPERFNumObjects; dwCurObj++)
			{
			/*	write the number of instances for this object to the block
			/**/
			*((DWORD_PTR *)pvBlock) = rglPERFNumInstances[dwCurObj];

			/*  get current instance name list
			/**/
			lpwszInstName = rgwszPERFInstanceList[dwCurObj];

			/*  loop through each instance
			/**/
			ppidInstanceDest = (PPERF_INSTANCE_DEFINITION)((char *)pvBlock + sizeof(DWORD_PTR));
			for ( dwCurInst = 0; dwCurInst < (DWORD)rglPERFNumInstances[dwCurObj]; dwCurInst++ )
				{
				/*	initialize instance/counter block from template data
				/**/
				UtilMemCpy((void *)ppidInstanceDest,(void *)ppidInstanceSrc,ppidInstanceSrc->ByteLength);
				ppcbCounterBlockDest = (PPERF_COUNTER_BLOCK)((char *)ppidInstanceDest + ppidInstanceDest->ByteLength);
				memset((void *)ppcbCounterBlockDest,0,cbMaxCounterBlockSize);
				ppcbCounterBlockDest->ByteLength = cbMaxCounterBlockSize;

				/*	no unique instance ID
				/**/
				ppidInstanceDest->UniqueID = PERF_NO_UNIQUE_ID;

				/*  NOTE:  performance DLL sets object hierarchy information  */

				/*	write instance name to buffer, avoiding overflow and illegal
				/*  characters ('#' and '/' in Win2k)
				/**/
				wszName = (wchar_t *)((char*)ppidInstanceDest + ppidInstanceDest->NameOffset);
				cwchNameMax = (ppidInstanceDest->ByteLength - ppidInstanceDest->NameOffset) / sizeof(wchar_t);
				for (cwchName = 0; cwchName < cwchNameMax && lpwszInstName[cwchName]; cwchName++)
					{
					switch ( lpwszInstName[cwchName] )
						{
						case L'#':
						case L'/':
							wszName[cwchName] = L'?';
							break;
							
						default:
							wszName[cwchName] = lpwszInstName[cwchName];
							break;
						}
					}
				wszName[cwchNameMax-1] = L'\0';
				ppidInstanceDest->NameLength = (ULONG)(wcslen(wszName)+1)*sizeof(wchar_t);
				lpwszInstName += wcslen(lpwszInstName)+1;

				/*  collect counter data for this instance
				/**/
				ppcdCounterSrc = (PPERF_COUNTER_DEFINITION)((char *)ppotObjectSrc + ppotObjectSrc->HeaderLength);
				for (dwCollectCtr = 0; dwCollectCtr < ppotObjectSrc->NumCounters; dwCollectCtr++)
					{
					rgpcefPERFCEF[dwCollectCtr + dwCurCtr](dwCurInst,(void *)((char *)ppcbCounterBlockDest + ppcdCounterSrc->CounterOffset));
					ppcdCounterSrc = (PPERF_COUNTER_DEFINITION)((char *)ppcdCounterSrc + ppcdCounterSrc->ByteLength);
					}
				ppidInstanceDest = (PPERF_INSTANCE_DEFINITION)((char *)ppidInstanceDest + cbInstanceSize);
				}
			dwCurCtr += ppotObjectSrc->NumCounters;
			ppotObjectSrc = (PPERF_OBJECT_TYPE)((char *)ppotObjectSrc + ppotObjectSrc->TotalByteLength);
			pvBlock = (void *)((char *)pvBlock + sizeof(DWORD_PTR) + cbInstanceSize * rglPERFNumInstances[dwCurObj]);
			}
		}

	UtilPerfThreadTerm();
	return 0;
	}

	
//  post-terminate perfmon subsystem

void OSPerfmonPostterm()
	{
	//  nop
	}

//  pre-init perfmon subsystem

BOOL FOSPerfmonPreinit()
	{
	//  nop

	return fTrue;
	}

	
//  terminate perfmon subsystem

void OSPerfmonTerm()
	{
	UtilPerfTerm();
	}

//  init perfmon subsystem

ERR ErrOSPerfmonInit()
	{
	ERR err = JET_errSuccess;
	
	//  start perfmon thread if we are on NT

	OSVERSIONINFO osvi;
	memset( &osvi, 0, sizeof( osvi ) );
	osvi.dwOSVersionInfoSize = sizeof( osvi );
	if ( GetVersionEx( &osvi ) && osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
		{
		Call( ErrUtilPerfInit() );
		}

HandleError:
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\osfile.cxx ===
#include "osstd.hxx"

#include "collection.hxx"

#include < malloc.h >


const TICK dtickOSFileDiskFullEvent = 60 * 1000;


////////////////////////////////////////
//  Support Functions

//  converts the last Win32 error code into an OSFile error code for return via
//  the OSFile API

ERR ErrOSFileIGetLastError( DWORD error = GetLastError() )
	{
	_TCHAR szT[64];
	_TCHAR szPID[10];
	const _TCHAR* rgszT[3] = { SzUtilProcessName(), szPID, szT };
	
	switch ( error )
		{
		case NO_ERROR:
		case ERROR_IO_PENDING:
			return JET_errSuccess;

		case ERROR_INVALID_PARAMETER:
		case ERROR_CALL_NOT_IMPLEMENTED:
			return ErrERRCheck( JET_errInvalidParameter );

		case ERROR_DISK_FULL:
			return ErrERRCheck( JET_errDiskFull );

		case ERROR_HANDLE_EOF:
			return ErrERRCheck( JET_errFileIOBeyondEOF );

		case ERROR_VC_DISCONNECTED:
		case ERROR_IO_DEVICE:
		case ERROR_DEVICE_NOT_CONNECTED:
		case ERROR_NOT_READY:
			return ErrERRCheck( JET_errDiskIO );

		case ERROR_NO_MORE_FILES:
		case ERROR_FILE_NOT_FOUND:
			return ErrERRCheck( JET_errFileNotFound );
		
		case ERROR_PATH_NOT_FOUND:
			return ErrERRCheck( JET_errInvalidPath );

		case ERROR_ACCESS_DENIED:
		case ERROR_SHARING_VIOLATION:
		case ERROR_LOCK_VIOLATION:
		case ERROR_WRITE_PROTECT:
			return ErrERRCheck( JET_errFileAccessDenied );

		case ERROR_TOO_MANY_OPEN_FILES:
			return ErrERRCheck( JET_errOutOfFileHandles );
			break;

		case ERROR_INVALID_USER_BUFFER:
		case ERROR_NOT_ENOUGH_MEMORY:
		case ERROR_WORKING_SET_QUOTA:
		case ERROR_NO_SYSTEM_RESOURCES:
			return ErrERRCheck( JET_errOutOfMemory );

		default:
			return ErrERRCheck( JET_errDiskIO );
		}
	}

//  returns the integer result of subtracting iFile1/ibOffset1 from iFile2/ibOffset2

INLINE __int64 IOSFileICmpIFileIbIFileIb( QWORD iFile1, QWORD ibOffset1, QWORD iFile2, QWORD ibOffset2 )
	{
	if ( iFile1 - iFile2 )
		{
		return iFile1 - iFile2;
		}
	else
		{
		return ibOffset1 - ibOffset2;
		}
	}


////////////////////////////////////////
//  Internal OSFile handle

class IOREQ;

class _OSFILE  //  _osf
	{
	public:

		enum IOMETHOD
			{
			iomethodSync,
			iomethodAsync,
			iomethodScatterGather
			};
	
		typedef void (*PfnFileIOComplete)(	const IOREQ* const		pioreq,
											const ERR				err,
											const DWORD_PTR			keyFileIOComplete );
	
	public:

		_OSFILE()
			:	semFilePointer( CSyncBasicInfo( _T( "_OSFILE::semFilePointer" ) ) )	
			{
			semFilePointer.Release();
			}

	public:
	
		HANDLE				hFile;				//  Win32 file handle
		PfnFileIOComplete	pfnFileIOComplete;	//  Per-file I/O completion function
		DWORD_PTR			keyFileIOComplete;	//  Per-file I/O completion key
		
		IOMETHOD			iomethodMost;		//  I/O capability
		QWORD				iFile;				//  File Index (for I/O Heap)
		CSemaphore			semFilePointer;		//  Semaphore Protecting the file pointer
		TICK				tickLastDiskFull;	//  last time we reported disk full
	};

typedef _OSFILE* P_OSFILE;


////////////////////////////////////////
//  I/O Request Pool

//  I/O request

class IOREQ
	{
	public:
		static SIZE_T OffsetOfAPIC()		{ return OffsetOf( IOREQ, apic ); }

		IOREQ& operator=( const IOREQ& ioreq )
			{
			memcpy( this, &ioreq, sizeof( IOREQ ) );

			return *this;
			}
	
	public:
		OVERLAPPED										ovlp;				//  must be first

	public:
		CPool< IOREQ, OffsetOfAPIC >::CInvasiveContext	apic;
		union
			{
			long											ipioreqHeap;
			IOREQ*											pioreqNext;
			};
		P_OSFILE										p_osf;
		BOOL											fWrite:1;
		int												group:2;
		QWORD											ibOffset;
		DWORD											cbData;
		const BYTE*										pbData;
		DWORD_PTR										dwCompletionKey;
		PFN												pfnCompletion;
	};


//  IOREQ pool

typedef CPool< IOREQ, IOREQ::OffsetOfAPIC > IOREQPool;

IOREQ*			rgioreq;
DWORD			cioreq;
volatile DWORD	cioreqInUse;
IOREQPool*		pioreqpool;

//  frees an IOREQ

INLINE void OSFileIIOREQFree( IOREQ* pioreq )
	{
	//  free the IOREQ to the pool

	pioreqpool->Insert( pioreq );
	}

//  attemps to create a new IOREQ and, if successful, frees it to the IOREQ
//  pool

INLINE ERR ErrOSFileIIOREQCreate()
	{
	ERR		err				= JET_errSuccess;
	HANDLE	hEvent			= NULL;
	DWORD	cioreqInUseBI	= 0;

	//  pre-allocate all resources we will need to grow the pool

	Alloc( hEvent = CreateEvent( NULL, FALSE, FALSE, NULL ) );

	//  try to allocate space in the pool for the new IOREQ.  if there is no
	//  more room then just return success

	if ( !FAtomicIncrementMax( &cioreqInUse, &cioreqInUseBI, cioreq ) )
		{
		CloseHandle( hEvent );
		return JET_errSuccess;
		}

	//  add the new IOREQ to the pool
	
	new( rgioreq + cioreqInUseBI ) IOREQ;
	rgioreq[ cioreqInUseBI ].ovlp.hEvent = hEvent;
	SetHandleInformation( rgioreq[ cioreqInUseBI ].ovlp.hEvent, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	OSFileIIOREQFree( rgioreq + cioreqInUseBI );

HandleError:
	return err;
	}

//  allocates an IOREQ, waiting for a free IOREQ if necessary

INLINE IOREQ* PioreqOSFileIIOREQAlloc()
	{
	//  we have a cached IOREQ available

	if ( Ptls()->pioreqCache )
		{
		//  return the cached IOREQ

		IOREQ* pioreq = Ptls()->pioreqCache;
		Ptls()->pioreqCache = NULL;
		
		return pioreq;
		}

	//  we don't have a cached IOREQ available

	else
		{
		//  allocate an IOREQ from the IOREQ pool, waiting forever if necessary

		IOREQ* pioreq;
		IOREQPool::ERR errIOREQ = pioreqpool->ErrRemove( &pioreq );
		Assert( errIOREQ == IOREQPool::errSuccess );

		//  there are no free IOREQs

		if ( !pioreqpool->Cobject() )
			{
			//  try to grow the IOREQ pool

			(void)ErrOSFileIIOREQCreate();
			
			//  start issuing I/O to produce more free IOREQs
			
			void OSFileIIOThreadStartIssue( const P_OSFILE p_osf );

			OSFileIIOThreadStartIssue( NULL );
			}

		//  return the allocated IOREQ

		return pioreq;
		}
	}

//  frees an IOREQ to the IOREQ cache

INLINE void OSFileIIOREQFreeToCache( IOREQ* pioreq )
	{
	//  purge any IOREQs currently in the TLS cache

	if ( Ptls()->pioreqCache )
		{
		OSFileIIOREQFree( Ptls()->pioreqCache );
		}

	//  put the IOREQ in the TLS cache

	Ptls()->pioreqCache = pioreq;
	}

//  allocates an IOREQ from the IOREQ cache, returning NULL if empty

INLINE IOREQ* PioreqOSFileIIOREQAllocFromCache()
	{
	//  get IOREQ from cache, if any
	
	IOREQ* pioreq = Ptls()->pioreqCache;

	//  clear cache

	Ptls()->pioreqCache = NULL;

	//  return cached IOREQ, if any

	return pioreq;
	}

//  terminates the IOREQ pool

void OSFileIIOREQTerm()
	{
	//  term IOREQ pool

	if ( pioreqpool )
		{
		pioreqpool->Term();
		pioreqpool->IOREQPool::~IOREQPool();
		OSMemoryHeapFreeAlign( pioreqpool );
		pioreqpool = NULL;
		}
	
	//  free IOREQ storage if allocated

	if ( rgioreq )
		{
		for ( DWORD iioreq = 0; iioreq < cioreqInUse; iioreq++ )
			{
			if ( rgioreq[iioreq].ovlp.hEvent )
				{
				SetHandleInformation( rgioreq[iioreq].ovlp.hEvent, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
				CloseHandle( rgioreq[iioreq].ovlp.hEvent );
				}
			rgioreq[iioreq].~IOREQ();
			}
		OSMemoryPageFree( rgioreq );
		rgioreq = NULL;
		}
	}

//  initializes the IOREQ pool, or returns JET_errOutOfMemory

ERR ErrOSFileIIOREQInit()
	{
	ERR		err;

	//  reset all pointers

	rgioreq		= NULL;
	cioreqInUse	= 0;
	pioreqpool	= NULL;
	
	//  select arbitrary and capricious constants for IOREQ Pool
	//  CONSIDER:  expose these settings

#ifdef DEBUG
	cioreq = 64;
#else  //  !DEBUG
	cioreq = OSMemoryPageReserveGranularity() / sizeof( IOREQ );
#endif  //  DEBUG

	//  allocate IOREQ storage

	if ( !( rgioreq = (IOREQ*)PvOSMemoryPageAlloc( cioreq * sizeof( IOREQ ), NULL ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  allocate IOREQ pool (we must do this as CRT is not yet init)

	BYTE *rgbIOREQPool;
	rgbIOREQPool = (BYTE*)PvOSMemoryHeapAllocAlign( sizeof( IOREQPool ), cbCacheLine );
	if ( !rgbIOREQPool )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	pioreqpool = new( rgbIOREQPool ) IOREQPool();

	//  init IOREQ pool

	switch ( pioreqpool->ErrInit( 0.0 ) )
		{
		default:
			AssertSz( fFalse, "Unexpected error initializing IOREQ Pool" );
		case IOREQPool::errOutOfMemory:
			Call( ErrERRCheck( JET_errOutOfMemory ) );
		case IOREQPool::errSuccess:
			break;
		}

	//  free an initial IOREQ to the pool

	Call( ErrOSFileIIOREQCreate() );

	return JET_errSuccess;

HandleError:
	OSFileIIOREQTerm();
	return err;
	}


////////////////////////
//  I/O Ascending Heap

//  critical section protecting the I/O Heap

extern CCriticalSection critIO;

//  I/O Ascending Heap

IOREQ* volatile *	rgpioreqIOAHeap;
long				ipioreqIOAHeapMax;
volatile long		ipioreqIOAHeapMac;

//  I/O Ascending Heap Functions

ERR ErrOSFileIIOAHeapInit();
void OSFileIIOAHeapTerm();
BOOL FOSFileIIOAHeapEmpty();
long CioreqOSFileIIOAHeap();
IOREQ* PioreqOSFileIIOAHeapTop();
void OSFileIIOAHeapAdd( IOREQ* pioreq );
void OSFileIIOAHeapRemove( IOREQ* pioreq );
BOOL FOSFileIIOAHeapIGreater( IOREQ* pioreq1, IOREQ* pioreq2 );
long IpioreqOSFileIIOAHeapIParent( long ipioreq );
long IpioreqOSFileIIOAHeapILeftChild( long ipioreq );
long IpioreqOSFileIIOAHeapIRightChild( long ipioreq );
void OSFileIIOAHeapIUpdate( IOREQ* pioreq );

//  initializes the I/O Ascending Heap, or returns JET_errOutOfMemory

ERR ErrOSFileIIOAHeapInit()
	{
	ERR err;
	
	//  reset all pointers

	rgpioreqIOAHeap = NULL;
	
	//  select arbitrary and capricious constants for I/O Ascending Heap
	//  CONSIDER:  expose these settings

	ipioreqIOAHeapMax = cioreq;
	
	//  allocate storage for the I/O Ascending Heap

	if ( !( rgpioreqIOAHeap = (IOREQ**) PvOSMemoryPageAlloc( ipioreqIOAHeapMax * sizeof( IOREQ* ), NULL ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  initialize the I/O Ascending Heap to be empty

	ipioreqIOAHeapMac = 0;

	return JET_errSuccess;

HandleError:
	OSFileIIOAHeapTerm();
	return err;
	}

//  terminates the I/O Ascending Heap

void OSFileIIOAHeapTerm()
	{
	//  free I/O Ascending Heap storage

	if ( rgpioreqIOAHeap != NULL )
		{
		OSMemoryPageFree( (void*)rgpioreqIOAHeap );
		rgpioreqIOAHeap = NULL;
		}
	}

//  returns fTrue if the I/O Ascending Heap is empty

INLINE BOOL FOSFileIIOAHeapEmpty()
	{
	Assert( critIO.FOwner() );
	return !ipioreqIOAHeapMac;
	}

//  returns the count of IOREQs in the I/O Ascending Heap

INLINE long CioreqOSFileIIOAHeap()
	{
	return ipioreqIOAHeapMac;
	}
	
//  returns IOREQ at the top of the I/O Ascending Heap, or NULL if empty

INLINE IOREQ* PioreqOSFileIIOAHeapTop()
	{
	Assert( critIO.FOwner() );
	Assert( !FOSFileIIOAHeapEmpty() );
	return rgpioreqIOAHeap[0];
	}

//  adds a IOREQ to the I/O Ascending Heap

INLINE void OSFileIIOAHeapAdd( IOREQ* pioreq )
	{
	//  critical section
	
	Assert( critIO.FOwner() );

	//  new value starts at bottom of heap

	long ipioreq = ipioreqIOAHeapMac++;

	//  percolate new value up the heap

	while (	ipioreq > 0 &&
			FOSFileIIOAHeapIGreater( pioreq, rgpioreqIOAHeap[IpioreqOSFileIIOAHeapIParent( ipioreq )] ) )
		{
		Assert(	rgpioreqIOAHeap[IpioreqOSFileIIOAHeapIParent( ipioreq )]->ipioreqHeap == IpioreqOSFileIIOAHeapIParent( ipioreq ) );
		rgpioreqIOAHeap[ipioreq] = rgpioreqIOAHeap[IpioreqOSFileIIOAHeapIParent( ipioreq )];
		rgpioreqIOAHeap[ipioreq]->ipioreqHeap = ipioreq;
		ipioreq = IpioreqOSFileIIOAHeapIParent( ipioreq );
		}

	//  put new value in its designated spot

	rgpioreqIOAHeap[ipioreq] = pioreq;
	pioreq->ipioreqHeap = ipioreq;
	}

//  removes a IOREQ from the I/O Ascending Heap

INLINE void OSFileIIOAHeapRemove( IOREQ* pioreq )
	{
	//  critical section
	
	Assert( critIO.FOwner() );

	//  remove the specified IOREQ from the heap

	long ipioreq = pioreq->ipioreqHeap;

	//  if this IOREQ was at the end of the heap, we're done

	if ( ipioreq == ipioreqIOAHeapMac - 1 )
		{
#ifdef DEBUG
		rgpioreqIOAHeap[ipioreqIOAHeapMac - 1] = (IOREQ*) 0xBAADF00DBAADF00D;
#endif  //  DEBUG
		ipioreqIOAHeapMac--;
		return;
		}

	//  copy IOREQ from tend of heap to fill removed IOREQ's vacancy

	rgpioreqIOAHeap[ipioreq] = rgpioreqIOAHeap[ipioreqIOAHeapMac - 1];
	rgpioreqIOAHeap[ipioreq]->ipioreqHeap = ipioreq;
#ifdef DEBUG
	rgpioreqIOAHeap[ipioreqIOAHeapMac - 1] = (IOREQ*) 0xBAADF00DBAADF00D;
#endif  //  DEBUG
	ipioreqIOAHeapMac--;

	//  update filler OSFiles position

	OSFileIIOAHeapIUpdate( rgpioreqIOAHeap[ipioreq] );
	}

//  updates a IOREQ's position in the I/O Ascending Heap if its weight has changed

void OSFileIIOAHeapIUpdate( IOREQ* pioreq )
	{
	//  critical section
	
	Assert( critIO.FOwner() );

	//  get the specified IOREQ's position

	long ipioreq = pioreq->ipioreqHeap;
	Assert( rgpioreqIOAHeap[ipioreq] == pioreq );
	
	//  percolate IOREQ up the heap

	while (	ipioreq > 0 &&
			FOSFileIIOAHeapIGreater( pioreq, rgpioreqIOAHeap[IpioreqOSFileIIOAHeapIParent( ipioreq )] ) )
		{
		Assert( rgpioreqIOAHeap[IpioreqOSFileIIOAHeapIParent( ipioreq )]->ipioreqHeap == IpioreqOSFileIIOAHeapIParent( ipioreq ) );
		rgpioreqIOAHeap[ipioreq] = rgpioreqIOAHeap[IpioreqOSFileIIOAHeapIParent( ipioreq )];
		rgpioreqIOAHeap[ipioreq]->ipioreqHeap = ipioreq;
		ipioreq = IpioreqOSFileIIOAHeapIParent( ipioreq );
		}

	//  percolate IOREQ down the heap

	while ( ipioreq < ipioreqIOAHeapMac )
		{
		//  if we have no children, stop here

		if ( IpioreqOSFileIIOAHeapILeftChild( ipioreq ) >= ipioreqIOAHeapMac )
			break;

		//  set child to greater child

		long ipioreqChild;
		if (	IpioreqOSFileIIOAHeapIRightChild( ipioreq ) < ipioreqIOAHeapMac && 
				FOSFileIIOAHeapIGreater(	rgpioreqIOAHeap[IpioreqOSFileIIOAHeapIRightChild( ipioreq )],
										rgpioreqIOAHeap[IpioreqOSFileIIOAHeapILeftChild( ipioreq )] ) )
			{
			ipioreqChild = IpioreqOSFileIIOAHeapIRightChild( ipioreq );
			}
		else
			{
			ipioreqChild = IpioreqOSFileIIOAHeapILeftChild( ipioreq );
			}

		//  if we are greater than the greatest child, stop here

		if ( FOSFileIIOAHeapIGreater( pioreq, rgpioreqIOAHeap[ipioreqChild] ) )
			break;

		//  trade places with greatest child and continue down

		Assert( rgpioreqIOAHeap[ipioreqChild]->ipioreqHeap == ipioreqChild );
		rgpioreqIOAHeap[ipioreq] = rgpioreqIOAHeap[ipioreqChild];
		rgpioreqIOAHeap[ipioreq]->ipioreqHeap = ipioreq;
		ipioreq = ipioreqChild;
		}
	Assert( ipioreq < ipioreqIOAHeapMac );

	//  put IOREQ in its designated spot

	rgpioreqIOAHeap[ipioreq] = pioreq;
	pioreq->ipioreqHeap = ipioreq;
	}

//  returns fTrue if the first IOREQ is greater than the second IOREQ

INLINE BOOL FOSFileIIOAHeapIGreater( IOREQ* pioreq1, IOREQ* pioreq2 )
	{
	return IOSFileICmpIFileIbIFileIb(	pioreq1->p_osf->iFile,
										pioreq1->ibOffset,
										pioreq2->p_osf->iFile,
										pioreq2->ibOffset ) < 0;
	}

//  returns the index to the parent of the given child

INLINE long IpioreqOSFileIIOAHeapIParent( long ipioreq )
	{
	return ( ipioreq - 1 ) / 2;
	}

//  returns the index to the left child of the given parent

INLINE long IpioreqOSFileIIOAHeapILeftChild( long ipioreq )
	{
	return 2 * ipioreq + 1;
	}

//  returns the index to the right child of the given parent

INLINE long IpioreqOSFileIIOAHeapIRightChild( long ipioreq )
	{
	return 2 * ipioreq + 2;
	}


/////////////////////////
//  I/O Descending Heap

//  critical section protecting the I/O Heap

extern CCriticalSection critIO;

//  I/O Descending Heap

IOREQ* volatile *	rgpioreqIODHeap;
long				ipioreqIODHeapMax;
volatile long		ipioreqIODHeapMic;

//  I/O Descending Heap Functions

ERR ErrOSFileIIODHeapInit();
void OSFileIIODHeapTerm();
BOOL FOSFileIIODHeapEmpty();
long CioreqOSFileIIODHeap();
IOREQ* PioreqOSFileIIODHeapTop();
void OSFileIIODHeapAdd( IOREQ* pioreq );
void OSFileIIODHeapRemove( IOREQ* pioreq );
BOOL FOSFileIIODHeapIGreater( IOREQ* pioreq1, IOREQ* pioreq2 );
long IpioreqOSFileIIODHeapIParent( long ipioreq );
long IpioreqOSFileIIODHeapILeftChild( long ipioreq );
long IpioreqOSFileIIODHeapIRightChild( long ipioreq );
void OSFileIIODHeapIUpdate( IOREQ* pioreq );


//  initializes the I/O Descending Heap, or returns JET_errOutOfMemory

ERR ErrOSFileIIODHeapInit()
	{
	//  I/O Descending Heap uses the heap memory that is not used by the
	//  I/O Ascending Heap, and therefore must be initialized second

	Assert( rgpioreqIOAHeap );

	rgpioreqIODHeap = rgpioreqIOAHeap;
	ipioreqIODHeapMax = ipioreqIOAHeapMax;
	
	//  initialize the I/O Descending Heap to be empty

	ipioreqIODHeapMic = ipioreqIODHeapMax;

	return JET_errSuccess;
	}

//  terminates the I/O Descending Heap

void OSFileIIODHeapTerm()
	{
	//  nop
	}

//  returns fTrue if the I/O Descending Heap is empty

INLINE BOOL FOSFileIIODHeapEmpty()
	{
	Assert( critIO.FOwner() );
	return ipioreqIODHeapMic == ipioreqIODHeapMax;
	}

//  returns the count of IOREQs in the I/O Descending Heap

INLINE long CioreqOSFileIIODHeap()
	{
	return long( ipioreqIODHeapMax - ipioreqIODHeapMic );
	}
	
//  returns IOREQ at the top of the I/O Descending Heap, or NULL if empty

INLINE IOREQ* PioreqOSFileIIODHeapTop()
	{
	Assert( critIO.FOwner() );
	Assert( !FOSFileIIODHeapEmpty() );
	return rgpioreqIODHeap[ipioreqIODHeapMax - 1];
	}

//  adds a IOREQ to the I/O Descending Heap

INLINE void OSFileIIODHeapAdd( IOREQ* pioreq )
	{
	//  critical section
	
	Assert( critIO.FOwner() );

	//  new value starts at bottom of heap

	long ipioreq = --ipioreqIODHeapMic;

	//  percolate new value up the heap

	while (	ipioreq < ipioreqIODHeapMax - 1 &&
			FOSFileIIODHeapIGreater( pioreq, rgpioreqIODHeap[IpioreqOSFileIIODHeapIParent( ipioreq )] ) )
		{
		Assert(	rgpioreqIODHeap[IpioreqOSFileIIODHeapIParent( ipioreq )]->ipioreqHeap == IpioreqOSFileIIODHeapIParent( ipioreq ) );
		rgpioreqIODHeap[ipioreq] = rgpioreqIODHeap[IpioreqOSFileIIODHeapIParent( ipioreq )];
		rgpioreqIODHeap[ipioreq]->ipioreqHeap = ipioreq;
		ipioreq = IpioreqOSFileIIODHeapIParent( ipioreq );
		}

	//  put new value in its designated spot

	rgpioreqIODHeap[ipioreq] = pioreq;
	pioreq->ipioreqHeap = ipioreq;
	}

//  removes a IOREQ from the I/O Descending Heap

INLINE void OSFileIIODHeapRemove( IOREQ* pioreq )
	{
	//  critical section
	
	Assert( critIO.FOwner() );

	//  remove the specified IOREQ from the heap

	long ipioreq = pioreq->ipioreqHeap;

	//  if this IOREQ was at the end of the heap, we're done

	if ( ipioreq == ipioreqIODHeapMic )
		{
#ifdef DEBUG
		rgpioreqIODHeap[ipioreqIODHeapMic] = (IOREQ*)0xBAADF00DBAADF00D;
#endif  //  DEBUG
		ipioreqIODHeapMic++;
		return;
		}

	//  copy IOREQ from end of heap to fill removed IOREQ's vacancy

	rgpioreqIODHeap[ipioreq] = rgpioreqIODHeap[ipioreqIODHeapMic];
	rgpioreqIODHeap[ipioreq]->ipioreqHeap = ipioreq;
#ifdef DEBUG
	rgpioreqIODHeap[ipioreqIODHeapMic] = (IOREQ*)0xBAADF00DBAADF00D;
#endif  //  DEBUG
	ipioreqIODHeapMic++;

	//  update filler IOREQs position

	OSFileIIODHeapIUpdate( rgpioreqIODHeap[ipioreq] );
	}

//  returns fTrue if the first IOREQ is greater than the second IOREQ

INLINE BOOL FOSFileIIODHeapIGreater( IOREQ* pioreq1, IOREQ* pioreq2 )
	{
	return IOSFileICmpIFileIbIFileIb(	pioreq1->p_osf->iFile,
										pioreq1->ibOffset,
										pioreq2->p_osf->iFile,
										pioreq2->ibOffset ) >= 0;
	}

//  returns the index to the parent of the given child

INLINE long IpioreqOSFileIIODHeapIParent( long ipioreq )
	{
	return ipioreqIODHeapMax - 1 - ( ipioreqIODHeapMax - 1 - ipioreq - 1 ) / 2;
	}

//  returns the index to the left child of the given parent

INLINE long IpioreqOSFileIIODHeapILeftChild( long ipioreq )
	{
	return ipioreqIODHeapMax - 1 - ( 2 * ( ipioreqIODHeapMax - 1 - ipioreq ) + 1 );
	}

//  returns the index to the right child of the given parent

INLINE long IpioreqOSFileIIODHeapIRightChild( long ipioreq )
	{
	return ipioreqIODHeapMax - 1 - ( 2 * ( ipioreqIODHeapMax - 1 - ipioreq ) + 2 );
	}

//  updates a IOREQ's position in the I/O Descending Heap if its weight has changed

void OSFileIIODHeapIUpdate( IOREQ* pioreq )
	{
	//  get the specified IOREQ's position

	long ipioreq = pioreq->ipioreqHeap;
	Assert( rgpioreqIODHeap[ipioreq] == pioreq );
	
	//  percolate IOREQ up the heap

	while (	ipioreq < ipioreqIODHeapMax - 1 &&
			FOSFileIIODHeapIGreater( pioreq, rgpioreqIODHeap[IpioreqOSFileIIODHeapIParent( ipioreq )] ) )
		{
		Assert( rgpioreqIODHeap[IpioreqOSFileIIODHeapIParent( ipioreq )]->ipioreqHeap == IpioreqOSFileIIODHeapIParent( ipioreq ) );
		rgpioreqIODHeap[ipioreq] = rgpioreqIODHeap[IpioreqOSFileIIODHeapIParent( ipioreq )];
		rgpioreqIODHeap[ipioreq]->ipioreqHeap = ipioreq;
		ipioreq = IpioreqOSFileIIODHeapIParent( ipioreq );
		}

	//  percolate IOREQ down the heap

	while ( ipioreq >= ipioreqIODHeapMic )
		{
		//  if we have no children, stop here

		if ( IpioreqOSFileIIODHeapILeftChild( ipioreq ) < ipioreqIODHeapMic )
			break;

		//  set child to greater child

		long ipioreqChild;
		if (	IpioreqOSFileIIODHeapIRightChild( ipioreq ) >= ipioreqIODHeapMic && 
				FOSFileIIODHeapIGreater(	rgpioreqIODHeap[IpioreqOSFileIIODHeapIRightChild( ipioreq )],
									rgpioreqIODHeap[IpioreqOSFileIIODHeapILeftChild( ipioreq )] ) )
			{
			ipioreqChild = IpioreqOSFileIIODHeapIRightChild( ipioreq );
			}
		else
			{
			ipioreqChild = IpioreqOSFileIIODHeapILeftChild( ipioreq );
			}

		//  if we are greater than the greatest child, stop here

		if ( FOSFileIIODHeapIGreater( pioreq, rgpioreqIODHeap[ipioreqChild] ) )
			break;

		//  trade places with greatest child and continue down

		Assert( rgpioreqIODHeap[ipioreqChild]->ipioreqHeap == ipioreqChild );
		rgpioreqIODHeap[ipioreq] = rgpioreqIODHeap[ipioreqChild];
		rgpioreqIODHeap[ipioreq]->ipioreqHeap = ipioreq;
		ipioreq = ipioreqChild;
		}
	Assert( ipioreq >= ipioreqIODHeapMic );

	//  put IOREQ in its designated spot

	rgpioreqIODHeap[ipioreq] = pioreq;
	pioreq->ipioreqHeap = ipioreq;
	}


//////////////
//  I/O Heap

//  critical section protecting the I/O Heap

CCriticalSection critIO( CLockBasicInfo( CSyncBasicInfo( "critIO" ), 0, 0 ) );

//  I/O Heap stats

BOOL	fAscending;

QWORD	iFileCurrent;
QWORD	ibOffsetCurrent;

//  terminates the I/O Heap

void OSFileIIOHeapTerm()
	{
	//  terminate sub-heaps

	OSFileIIODHeapTerm();
	OSFileIIOAHeapTerm();
	}

//  initializes the I/O Heap, or returns JET_errOutOfMemory

ERR ErrOSFileIIOHeapInit()
	{
	ERR err;

	//  init sub-heaps

	Call( ErrOSFileIIOAHeapInit() );
	Call( ErrOSFileIIODHeapInit() );

	//  reset current I/O stats

	fAscending		= fTrue;

	iFileCurrent	= 0;
	ibOffsetCurrent	= 0;

	return JET_errSuccess;

HandleError:
	OSFileIIOHeapTerm();
	return err;
	}

//  returns fTrue if the I/O Heap is empty

INLINE BOOL FOSFileIIOHeapEmpty()
	{
	Assert( critIO.FOwner() );
	return FOSFileIIOAHeapEmpty() && FOSFileIIODHeapEmpty();
	}

//  returns the count of IOREQs in the I/O Heap

INLINE long CioreqOSFileIIOHeap()
	{
	return CioreqOSFileIIOAHeap() + CioreqOSFileIIODHeap();
	}
	
//  returns IOREQ at the top of the I/O Heap, or NULL if empty

INLINE IOREQ* PioreqOSFileIIOHeapTop()
	{
	//  critical section
	
	Assert( critIO.FOwner() );

	//  the I/O Ascending Heap is empty

	if ( FOSFileIIOAHeapEmpty() )
		{
		//  the I/O Descending Heap is empty

		if ( FOSFileIIODHeapEmpty() )
			{
			//  the I/O Heap is empty

			return NULL;
			}

		//  the I/O Descending Heap is not empty

		else
			{
			//  return the top of the I/O Descending Heap

			return PioreqOSFileIIODHeapTop();
			}
		}

	//  the I/O Ascending Heap is not empty

	else
		{
		//  the I/O Descending Heap is empty

		if ( FOSFileIIODHeapEmpty() )
			{
			//  return the top of the I/O Ascending Heap

			return PioreqOSFileIIOAHeapTop();
			}

		//  the I/O Descending Heap is not empty

		else
			{
			//  select the IOREQ on top of the I/O Heap in our issue direction

			if ( fAscending )
				{
				return PioreqOSFileIIOAHeapTop();
				}
			else
				{
				return PioreqOSFileIIODHeapTop();
				}
			}
		}
	}

//  adds a IOREQ to the I/O Heap

INLINE void OSFileIIOHeapAdd( IOREQ* pioreq )
	{
	//  critical section
	
	Assert( critIO.FOwner() );

	//  this IOREQ should go in the I/O Ascending Heap

	if ( IOSFileICmpIFileIbIFileIb(	pioreq->p_osf->iFile,
									pioreq->ibOffset,
									iFileCurrent,
									ibOffsetCurrent ) >= 0 )
		{
		OSFileIIOAHeapAdd( pioreq );
		}

	//  this IOREQ should go in the I/O Descending Heap

	else
		{
		OSFileIIODHeapAdd( pioreq );
		}
	}

//  removes a IOREQ from the I/O Heap

INLINE void OSFileIIOHeapRemove( IOREQ* pioreq )
	{
	//  critical section
	
	Assert( critIO.FOwner() );

	//  this IOREQ is in the I/O Ascending Heap

	if ( pioreq->ipioreqHeap < ipioreqIOAHeapMac )
		{
		OSFileIIOAHeapRemove( pioreq );
		fAscending = fTrue;
		}

	//  this IOREQ is in the I/O Descending Heap

	else
		{
		OSFileIIODHeapRemove( pioreq );
		fAscending = fFalse;
		}

	//  remember the iFile/ibOffset of the last IOREQ removed from the I/O Heap

	iFileCurrent	= pioreq->p_osf->iFile;
	ibOffsetCurrent	= pioreq->ibOffset;
	}


////////////////
//  I/O Thread

DWORD  				cbIOMax;
BOOL				fTooManyIOs;
CTaskManager*		postaskmgrFile;
long				cIOPending;
HMODULE				hmodKernel32;

typedef
WINBASEAPI
BOOL
WINAPI
PFNReadFileScatter(
    IN HANDLE hFile,
    IN FILE_SEGMENT_ELEMENT aSegmentArray[],
    IN DWORD nNumberOfBytesToRead,
    IN LPDWORD lpReserved,
    IN LPOVERLAPPED lpOverlapped
    );

typedef
WINBASEAPI
BOOL
WINAPI
PFNWriteFileGather(
    IN HANDLE hFile,
    OUT FILE_SEGMENT_ELEMENT aSegmentArray[],
    IN DWORD nNumberOfBytesToWrite,
    IN LPDWORD lpReserved,
    IN LPOVERLAPPED lpOverlapped
    );

PFNReadFileScatter*	pfnReadFileScatter;
PFNWriteFileGather*	pfnWriteFileGather;

//  dummy stubs for ReadFileScatter / WriteFileGather

BOOL
WINAPI
ReadFileScatterNotSupported(
    IN HANDLE hFile,
    IN FILE_SEGMENT_ELEMENT aSegmentArray[],
    IN DWORD nNumberOfBytesToRead,
    IN LPDWORD lpReserved,
    IN LPOVERLAPPED lpOverlapped
    )
   {
   SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
   return FALSE;
   }

BOOL
WINAPI
WriteFileGatherNotSupported(
    IN HANDLE hFile,
    OUT FILE_SEGMENT_ELEMENT aSegmentArray[],
    IN DWORD nNumberOfBytesToWrite,
    IN LPDWORD lpReserved,
    IN LPOVERLAPPED lpOverlapped
    )
   {
   SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
   return FALSE;
   }

//  returns fTrue if the specified IOREQ can be processed using SGIO

INLINE BOOL FOSFileICanUseSGIO( IOREQ* pioreq )
	{
	return	pioreq->p_osf->iomethodMost >= _OSFILE::iomethodScatterGather &&		//  SGIO enabled for this file
			pioreq->cbData % OSMemoryPageCommitGranularity() == 0 &&				//  data is vmem page sized
			DWORD_PTR( pioreq->pbData ) % OSMemoryPageCommitGranularity() == 0;		//  data is vmem page aligned
	}

//  process I/O Thread Issue command

void OSFileIIOThreadCompleteWithErr( DWORD error, DWORD cbTransfer, IOREQ* pioreqHead );
				
#pragma optimize( "y", off )

void OSFileIIOThreadIIssue( const DWORD_PTR dwReserved1,
							const DWORD		dwReserved2,
							const DWORD_PTR	dwReserved3 )
	{
	//  allocate worst case storage for Scatter/Gather I/O list from the stack,
	//  allocating one extra for NULL terminating the list and another extra for
	//  aligning the list properly

	const DWORD cfse = cbIOMax / OSMemoryPageCommitGranularity() + 2;
	BYTE* rgbFSE = (BYTE*)_alloca( cfse * sizeof( FILE_SEGMENT_ELEMENT ) );
	rgbFSE = rgbFSE + sizeof( FILE_SEGMENT_ELEMENT ) - 1;
	rgbFSE = rgbFSE - DWORD_PTR( rgbFSE ) % sizeof( FILE_SEGMENT_ELEMENT );
	PFILE_SEGMENT_ELEMENT rgfse = PFILE_SEGMENT_ELEMENT( rgbFSE );
	
	//  issue as many I/Os as possible

	fTooManyIOs = fFalse;
	while ( !fTooManyIOs && CioreqOSFileIIOHeap() )
		{
		//  collect a run of IOREQs with continuous p_osf/ibs that are the same
		//  I/O type (read vs write)

		DWORD cbRun = 0;
		IOREQ* pioreqHead = NULL;
		IOREQ* pioreqTail = NULL;
		
		critIO.Enter();
	
		BOOL fMember = fTrue;
		while ( fMember && CioreqOSFileIIOHeap() )
			{
			//  get top of I/O heap

			IOREQ* pioreq = PioreqOSFileIIOHeapTop();

			//  determine if this IOREQ is a member of the current run

			fMember =	!pioreqTail ||																//  start of run (single IOREQs always OK)
						(	pioreq->fWrite == pioreqTail->fWrite &&									//  run for same I/O type (Read vs Write)
						 	(	pioreqTail->ibOffset + pioreqTail->cbData == pioreq->ibOffset ||	//  run is contiguous
								pioreq->ibOffset + pioreq->cbData == pioreqTail->ibOffset ) &&
							pioreq->p_osf == pioreqTail->p_osf &&									//  run in same file
							cbRun + pioreq->cbData <= cbIOMax &&									//  run no larger than max run size
							pioreq->ibOffset % cbIOMax &&											//  run aligned to max run size
							FOSFileICanUseSGIO( pioreqHead ) && FOSFileICanUseSGIO( pioreq ) );		//  run can use SGIO

			//  this IOREQ is a member of the current run

			if ( fMember )
				{
				//  take IOREQ out of I/O Heap

				OSFileIIOHeapRemove( pioreq );

				//  add IOREQ to run

				if ( !pioreqTail )
					{
					pioreqHead = pioreq;
					}
				else
					{
					pioreqTail->pioreqNext = pioreq;
					}
				pioreqTail = pioreq;
				pioreqTail->pioreqNext = NULL;
				cbRun += pioreq->cbData;
				}
			}

		critIO.Leave();

		//  determine I/O method for this run

		_OSFILE::IOMETHOD iomethod;

		iomethod	= (	pioreqHead == pioreqTail ?
							_OSFILE::iomethodAsync :
							_OSFILE::iomethodScatterGather );
		iomethod	= _OSFILE::IOMETHOD( min( pioreqHead->p_osf->iomethodMost, iomethod ) );
			
		//  prepare all IOREQs for I/O

		IOREQ* pioreq = pioreqHead;
		DWORD cbLast;
		for ( DWORD cb = 0; cb < cbRun; cb += cbLast )
			{
			//  setup for each I/O method

			switch ( iomethod )
				{
				case _OSFILE::iomethodSync:
				case _OSFILE::iomethodAsync:
					break;

				case _OSFILE::iomethodScatterGather:
				
					//  setup Scatter/Gather I/O source array for this buffer

					DWORD ipageRun = cb / OSMemoryPageCommitGranularity();
					DWORD cpageIOREQ = pioreq->cbData / OSMemoryPageCommitGranularity();
					DWORD cpageRun = cbRun / OSMemoryPageCommitGranularity();
					DWORD ipageStart;

					if ( pioreqHead->ibOffset < pioreqTail->ibOffset )
						{
						ipageStart = ipageRun;
						}
					else
						{
						ipageStart = cpageRun - ipageRun - cpageIOREQ;
						}

					//  copy data pointers into Scatter/Gather I/O list

					DWORD ipage;
					DWORD cbIOREQ;
					for (	ipage = ipageStart, cbIOREQ = 0;
							ipage < ipageStart + cpageIOREQ;
							ipage++, cbIOREQ += OSMemoryPageCommitGranularity() )
						{
						rgfse[ipage].Alignment	= 0;
						rgfse[ipage].Buffer		= (BYTE*)pioreq->pbData + cbIOREQ;
						}
					break;
				}
				
			cbLast = pioreq->cbData;
			pioreq = pioreq->pioreqNext;
			}

		//  setup embedded OVERLAPPED structure in the head IOREQ for the I/O

		QWORD ibOffset = min( pioreqHead->ibOffset, pioreqTail->ibOffset );
		pioreqHead->ovlp.Offset		= ULONG( ibOffset );
		pioreqHead->ovlp.OffsetHigh = ULONG( ibOffset >> 32 );

		//  null terminate the scatter list

		if ( iomethod == _OSFILE::iomethodScatterGather )
			{
			DWORD cpageRun = cbRun / OSMemoryPageCommitGranularity();
			
			rgfse[cpageRun].Alignment	= 0;
			rgfse[cpageRun].Buffer		= NULL;
			}

		//  RFS:  pre-completion error

		DWORD	cbTransfer		= 0;
		BOOL	fIOSucceeded	= RFSAlloc( pioreqHead->fWrite ? OSFileWrite : OSFileRead );
		DWORD	error			= fIOSucceeded ? ERROR_SUCCESS : ERROR_IO_DEVICE;

		//  issue the I/O

		switch ( iomethod )
			{
			case _OSFILE::iomethodSync:
				pioreqHead->p_osf->semFilePointer.Acquire();
				fIOSucceeded = (	fIOSucceeded &&
									(	SetFilePointer(	pioreqHead->p_osf->hFile,
														pioreqHead->ovlp.Offset,
														(long*)&pioreqHead->ovlp.OffsetHigh,
														FILE_BEGIN ) != INVALID_SET_FILE_POINTER ||
										GetLastError() == NO_ERROR ) );
				fIOSucceeded = (	fIOSucceeded &&
									(	pioreqHead->fWrite ?
											WriteFile(	pioreqHead->p_osf->hFile,
														pioreqHead->pbData,
														cbRun,
														&cbTransfer,
														NULL ) :
											ReadFile(	pioreqHead->p_osf->hFile,
														(BYTE*)pioreqHead->pbData,
														cbRun,
														&cbTransfer,
														NULL ) ) );
				pioreqHead->p_osf->semFilePointer.Release();
				break;

			case _OSFILE::iomethodAsync:
				fIOSucceeded = (	fIOSucceeded &&
									(	pioreqHead->fWrite ?
											WriteFile(	pioreqHead->p_osf->hFile,
														pioreqHead->pbData,
														cbRun,
														NULL,
														LPOVERLAPPED( pioreqHead ) ) :
											ReadFile(	pioreqHead->p_osf->hFile,
														(BYTE*)pioreqHead->pbData,
														cbRun,
														NULL,
														LPOVERLAPPED( pioreqHead ) ) ) );
				break;

			case _OSFILE::iomethodScatterGather:
				fIOSucceeded = (	fIOSucceeded &&
									(	pioreqHead->fWrite ?
											pfnWriteFileGather(	pioreqHead->p_osf->hFile,
																rgfse,
																cbRun,
																NULL,
																LPOVERLAPPED( pioreqHead ) ) :
											pfnReadFileScatter(	pioreqHead->p_osf->hFile,
																rgfse,
																cbRun,
																NULL,
																LPOVERLAPPED( pioreqHead ) ) ) );
				break;
			}
		error = error != ERROR_SUCCESS ? error : GetLastError();

		//  the issue succeeded and completed immediately

		if ( fIOSucceeded )
			{
			//  this was a sync I/O

			if ( iomethod == _OSFILE::iomethodSync )
				{
				//  complete the I/O
				
				OSFileIIOThreadCompleteWithErr( ERROR_SUCCESS, cbTransfer, pioreqHead );
				}

			//  this was not a sync I/O

			else
				{
				//  increment our pending I/O count

				AtomicIncrement( &cIOPending );
				
				//  the I/O completion has been posted to this thread so we
				//  will use it to complete the I/O
				}
			}

		//  the issue failed or did not complete immediately
		
		else
			{
			//  the I/O is pending

			const ERR errIO = ErrOSFileIGetLastError( error );
			
			if ( errIO >= 0 )
				{
				//  increment our pending I/O count

				AtomicIncrement( &cIOPending );
				
				//  the I/O completion will be posted to this thread later
				}
				
			//  we either issued too many I/Os or this I/O method does not work
			//  on this file

			else if (	errIO == JET_errOutOfMemory ||
					(	errIO == JET_errInvalidParameter &&
						iomethod > _OSFILE::iomethodSync ) )
				{
				//  we issued too many I/Os

				if ( errIO == JET_errOutOfMemory )
					{
					//  stop issuing I/O

					fTooManyIOs = fTrue;
					}

				//  this I/O method does not work on this file

				else
					{
					//  reduce I/O capability for this file

					pioreqHead->p_osf->iomethodMost = _OSFILE::IOMETHOD( pioreqHead->p_osf->iomethodMost - 1 );
					}
					
				//  return run to the I/O Heap so that we can try issuing it
				//  again later

				critIO.Enter();

				while ( pioreqHead )
					{
					IOREQ* const pioreqNext = pioreqHead->pioreqNext;
					OSFileIIOHeapAdd( pioreqHead );
					pioreqHead = pioreqNext;
					}

				critIO.Leave();
				}

			//  some other fatal error occurred

			else
				{
				//  complete the I/O with the error

				OSFileIIOThreadCompleteWithErr( error, 0, pioreqHead );
				}
			}
		}
	}

#pragma optimize( "", on )

//  process I/O completions

void OSFileIIOThreadCompleteWithErr( DWORD error, DWORD cbTransfer, IOREQ* pioreqHead )
	{
	//  RFS:  post-completion error

	if ( !RFSAlloc( pioreqHead->fWrite ? OSFileWrite : OSFileRead ) )
		{
		error = error != ERROR_SUCCESS ? error : ERROR_IO_DEVICE;
		}

	//  if this I/O failed then report it to the event log
	//
	//  exceptions:
	//
	//  -  we do not report ERROR_HANDLE_EOF
	//  -  we limit the frequency of ERROR_DISK_FULL reports

	if (	error != ERROR_HANDLE_EOF &&
			(	error != ERROR_DISK_FULL ||
				TickOSTimeCurrent() - pioreqHead->p_osf->tickLastDiskFull >= dtickOSFileDiskFullEvent ) &&
			ErrOSFileIGetLastError( error ) < JET_errSuccess )
		{
		if ( error == ERROR_DISK_FULL )
			{
			pioreqHead->p_osf->tickLastDiskFull = TickOSTimeCurrent();
			}

		IFileAPI*	pfapi		= (IFileAPI*)pioreqHead->p_osf->keyFileIOComplete;  //  HACK!
		QWORD		ibOffset	= (	QWORD( pioreqHead->ovlp.Offset ) +
									( QWORD( pioreqHead->ovlp.OffsetHigh ) << 32 ) );
		DWORD		cbLength	= 0;
		ERR			err			= ErrOSFileIGetLastError( error );

		for ( IOREQ* pioreqT = pioreqHead; pioreqT; pioreqT = pioreqT->pioreqNext )
			{
			cbLength += pioreqT->cbData;
			}
		
		const _TCHAR*	rgpsz[ 9 ];
		DWORD			irgpsz						= 0;
		_TCHAR			szPID[ 64 ];
		_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szOffset[ 64 ];
		_TCHAR			szLength[ 64 ];
		_TCHAR			szError[ 64 ];
		_TCHAR			szSystemError[ 64 ];
		_TCHAR*			szSystemErrorDescription	= NULL;

		_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
		CallS( pfapi->ErrPath( szAbsPath ) );
		_stprintf( szOffset, _T( "%I64i (0x%016I64x)" ), ibOffset, ibOffset );
		_stprintf( szLength, _T( "%u (0x%08x)" ), cbLength, cbLength );
		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );
		_stprintf( szSystemError, _T( "%u (0x%08x)" ), error, error );
		FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_MAX_WIDTH_MASK ),
						NULL,
						error,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
						LPTSTR( &szSystemErrorDescription ),
						0,
						NULL );

		rgpsz[ irgpsz++ ]	= SzUtilProcessName();
		rgpsz[ irgpsz++ ]	= szPID;
		rgpsz[ irgpsz++ ]	= "";		//	no instance name
		rgpsz[ irgpsz++ ]	= szAbsPath;
		rgpsz[ irgpsz++ ]	= szOffset;
		rgpsz[ irgpsz++ ]	= szLength;
		rgpsz[ irgpsz++ ]	= szError;
		rgpsz[ irgpsz++ ]	= szSystemError;
		rgpsz[ irgpsz++ ]	= szSystemErrorDescription ? szSystemErrorDescription : _T( "" );

		OSEventReportEvent(	SzUtilImageVersionName(),
							eventError,
							GENERAL_CATEGORY,
							pioreqHead->fWrite ? OSFILE_WRITE_ERROR_ID : OSFILE_READ_ERROR_ID,
							irgpsz,
							rgpsz );

		LocalFree( szSystemErrorDescription );
		}
	
	//  process callback for each IOREQ

	const QWORD ibOffsetHead =	QWORD( pioreqHead->ovlp.Offset ) +
								( QWORD( pioreqHead->ovlp.OffsetHigh ) << 32 );

	IOREQ* pioreqUnused = NULL;
	IOREQ* pioreqNext;
	for ( IOREQ* pioreq = pioreqHead; pioreq; pioreq = pioreqNext )
		{
		//  fetch next IOREQ

		pioreqNext = pioreq->pioreqNext;

		//  get the error for this IOREQ, specifically with respect to reading
		//  past the end of file.  it is possible to get a run of IOREQs where
		//  some are before the EOF and some are after the EOF.  each must be
		//  passed or failed accordingly

		const DWORD	errorIOREQ	= (	error != ERROR_SUCCESS ?
										error :
										(	pioreq->ibOffset + pioreq->cbData <= ibOffsetHead + cbTransfer ?
												ERROR_SUCCESS :
												ERROR_HANDLE_EOF ) );

		//  backup the status of this IOREQ before we free it

		IOREQ const ioreq = *pioreq;

		//  free IOREQ for possible reuse by an I/O issued by this callback

		OSFileIIOREQFreeToCache( pioreq );

		//  perform per-file I/O completion callback

		ioreq.p_osf->pfnFileIOComplete(	&ioreq,
										ErrOSFileIGetLastError( errorIOREQ ),
										ioreq.p_osf->keyFileIOComplete );

		//  get IOREQ back from cache (if unused) and add to used IOREQ list

		pioreq = PioreqOSFileIIOREQAllocFromCache();
		if ( pioreq )
			{
			pioreq->pioreqNext = pioreqUnused;
			pioreqUnused = pioreq;
			}
		}

	//  free any unused IOREQs

	if ( pioreqUnused )
		{
		while ( pioreqUnused )
			{
			pioreqNext = pioreqUnused->pioreqNext;
			OSFileIIOREQFree( pioreqUnused );
			pioreqUnused = pioreqNext;
			}
		}

	//  there are still I/Os that need to be issued

	if ( fTooManyIOs )
		{
		//  try to issue some more

		void OSFileIIOThreadStartIssue( const P_OSFILE p_osf );

		OSFileIIOThreadStartIssue( NULL );
		}
	}

void OSFileIIOThreadIComplete(	const DWORD_PTR	dwThreadContext,
								DWORD			cbTransfer,
								IOREQ			*pioreqHead )
	{
	//  this is a completion packet caused by our I/O functions

	if ( pioreqHead >= rgioreq && pioreqHead < rgioreq + cioreq )
		{
		//  decrement our pending I/O count

		AtomicDecrement( &cIOPending );
		
		//  call completion function with error

		OSFileIIOThreadCompleteWithErr( GetLastError(), cbTransfer, pioreqHead );
		}

	//  this is a completion packet caused by some other I/O

	else
		{
		//  ignore this I/O packet
		}
	}

void OSFileIIOThreadIIdle(	const DWORD_PTR dwReserved1,
							const DWORD		dwReserved2,
							const DWORD_PTR	dwReserved3 )
	{
	//  our init packet has completed

	if ( Ptls()->fIOThread )
		{
		//  there are queued I/Os and there are no pending I/Os

		if ( CioreqOSFileIIOHeap() && !cIOPending )
			{
			//  start issuing I/Os

			OSFileIIOThreadIIssue( 0, 0, 0 );
			}
		}
	}

void OSFileIIOThreadIInit(	const DWORD_PTR dwReserved1,
							const DWORD		dwReserved2,
							const DWORD_PTR	dwReserved3 )
	{
	//  mark this thread as part of the I/O pool

	Ptls()->fIOThread = fTrue;
	}
	
//  terminates the I/O Thread

void OSFileIIOThreadTerm( void )
	{
	//	term the task manager

	if ( postaskmgrFile )
		{
		postaskmgrFile->TMTerm();
		delete postaskmgrFile;
		postaskmgrFile = NULL;
		}

	//  unload SGIO

	if ( hmodKernel32 )
		{
		FreeLibrary( hmodKernel32 );
		hmodKernel32 = NULL;
		}
	}

//  initializes the I/O Thread, or returns either JET_errOutOfMemory or
//  JET_errOutOfThreads

ERR ErrOSFileIIOThreadInit( void )
	{
	ERR err;
	
	//  reset all pointers

	fTooManyIOs		= fFalse;
	postaskmgrFile	= NULL;
	cIOPending		= 0;
	hmodKernel32	= NULL;

	//  select arbitrary and capricious constants for I/O
	//  CONSIDER:  expose these settings

	cbIOMax = 1024 * 1024;

	//	initialize our task manager (1 thread, no local contexts)
	//  NOTE:  1 thread required to serialize I/O on Win9x

	postaskmgrFile = new CTaskManager;
	if ( !postaskmgrFile )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	Call( postaskmgrFile->ErrTMInit(	1,
										NULL,
										30000,
										OSFileIIOThreadIIdle ) );

	//  load SGIO

	if (	!( hmodKernel32 = LoadLibrary( _T( "kernel32.dll" ) ) ) ||
			!( pfnReadFileScatter = (PFNReadFileScatter*)GetProcAddress( hmodKernel32, _T( "ReadFileScatter" ) ) ) ||
			!( pfnWriteFileGather = (PFNWriteFileGather*)GetProcAddress( hmodKernel32, _T( "WriteFileGather" ) ) ) )
		{
		pfnReadFileScatter	= ReadFileScatterNotSupported;
		pfnWriteFileGather	= WriteFileGatherNotSupported;
		}

	//  post an init task

	Call( postaskmgrFile->ErrTMPost( OSFileIIOThreadIInit, 0, 0 ) );
	
	return JET_errSuccess;

HandleError:
	OSFileIIOThreadTerm();
	return err;
	}

//  tells I/O Thread to start issuing scheduled I/O

void OSFileIIOThreadStartIssue( const P_OSFILE p_osf )
	{
		const ERR err =	postaskmgrFile->ErrTMPost( OSFileIIOThreadIIssue, 0, 0 );
		Assert( JET_errSuccess == err );
	}

//  registers the given file for use with the I/O thread

INLINE ERR ErrOSFileIIOThreadRegisterFile( const P_OSFILE p_osf )
	{
	ERR err;
	
	//  attach the thread to the completion port

	if ( !postaskmgrFile->FTMRegisterFile(	p_osf->hFile, 
											CTaskManager::PfnCompletion( OSFileIIOThreadIComplete ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  initially enable Scatter/Gather I/O.  we will disable it later if it
	//  is not permitted on this file

	p_osf->iomethodMost = _OSFILE::iomethodScatterGather;

	//  get File Index for I/O Heap

	p_osf->iFile = QWORD( DWORD_PTR( p_osf->hFile ) );

	//  init stats

	p_osf->tickLastDiskFull = TickOSTimeCurrent() - dtickOSFileDiskFullEvent;

	return JET_errSuccess;

HandleError:
	return err;
	}

	
//  post-terminate file subsystem

void OSFilePostterm()
	{
	//  nop
	}

//  pre-init file subsystem

BOOL FOSFilePreinit()
	{
	//  nop

	return fTrue;
	}


//  pre-zeroed buffer used to extend files

QWORD			cbZero;
BYTE*			rgbZero;
COSMemoryMap*	posmmZero;


//  parameters

BOOL			fUseDirectIO;
QWORD			cbMMSize;


//  terminate file subsystem

void OSFileTerm()
	{
	//  terminate all service threads

	OSFileIIOThreadTerm();

	//  terminate all components

	OSFileIIOHeapTerm();
	OSFileIIOREQTerm();

	if ( posmmZero )
		{
		//  free file extension buffer

		if ( rgbZero )
			{
			posmmZero->OSMMPatternFree();
			rgbZero = NULL;
			}

		//	term the memory map

		posmmZero->OSMMTerm();
		delete posmmZero;
		posmmZero = NULL;
		}
	else
		{
		//  free file extension buffer

		if ( rgbZero )
			{
			OSMemoryPageFree( rgbZero );
			rgbZero = NULL;
			}
		}
	}


//  init file subsystem

ERR ErrOSFileInit()
	{
	ERR err = JET_errSuccess;

	//  reset all pointers

	rgbZero				= NULL;
	posmmZero			= NULL;
	
	//  load OS version

	OSVERSIONINFO osvi;
	memset( &osvi, 0, sizeof( osvi ) );
	osvi.dwOSVersionInfoSize = sizeof( osvi );
	if ( !GetVersionEx( &osvi ) )
		{
		Call( ErrOSFileIGetLastError() );
		}

	//  use direct I/O if we are not on Win9x
	
	fUseDirectIO = osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS;

	//  fetch our MM block size

	SYSTEM_INFO sinf;
	GetSystemInfo( &sinf );
	cbMMSize = sinf.dwAllocationGranularity;

	//  perform Win9x / non-Win9x init

	if ( osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS )
		{
		//  set all configuration defaults

		cbZero = 1 * 1024 * 1024;

		Assert( cbZero == size_t( cbZero ) );

		//  allocate file extension buffer by allocating the smallest chunk of page
		//  store possible and remapping it consecutively in memory until we hit the
		//  desired chunk size

		//	allocate the memory map object

		posmmZero = new COSMemoryMap();
		if ( !posmmZero )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		//	init the memory map

		COSMemoryMap::ERR errOSMM;
		errOSMM = posmmZero->ErrOSMMInit();
		if ( COSMemoryMap::errSuccess != errOSMM )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		//	allocate the pattern

		errOSMM = posmmZero->ErrOSMMPatternAlloc(	size_t( OSMemoryPageReserveGranularity() ), 
													size_t( cbZero ), 
													(void**)&rgbZero );
		if ( COSMemoryMap::errSuccess != errOSMM )
			{
			AssertSz(	COSMemoryMap::errOutOfBackingStore == errOSMM ||
						COSMemoryMap::errOutOfAddressSpace == errOSMM ||
						COSMemoryMap::errOutOfMemory == errOSMM, 
						"unexpected error while allocating memory pattern" );
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		}
	else
		{
		//  set all configuration defaults

		cbZero = 64 * 1024;

		//  allocate the file extension buffer

		if ( !( rgbZero = (BYTE*)PvOSMemoryPageAlloc( size_t( cbZero ), NULL ) ) )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		}

	//  init all components

	Call( ErrOSFileIIOREQInit() );
	Call( ErrOSFileIIOHeapInit() );

	//  start all service threads

	Call( ErrOSFileIIOThreadInit() );

	return JET_errSuccess;

HandleError:
	OSFileTerm();
	return err;
	}


////////////////////////////////////////
//  API Implementation

COSFile::COSFile()
	:	m_hFile( INVALID_HANDLE_VALUE ),
		m_p_osf( NULL ),
		m_semChangeFileSize( CSyncBasicInfo( _T( "COSFile::m_semChangeFileSize" ) ) ),
		m_critDefer( CLockBasicInfo( CSyncBasicInfo( _T( "COSFile::m_critDefer" ) ), 0, 0 ) )
	{
#ifdef LOGPATCH_UNIT_TEST

	m_cbData	= 0;
	m_rgbData	= NULL;

#endif	//	LOGPATCH_UNIT_TEST
	}

ERR COSFile::ErrInit(	_TCHAR* const	szAbsPath,
						const HANDLE	hFile,
						const QWORD		cbFileSize,
						const BOOL		fReadOnly,
						const DWORD		cbIOSize )
	{
	ERR err = JET_errSuccess;

	//  copy our arguments

	_tcscpy( m_szAbsPath, szAbsPath );
	m_hFile			= hFile;
	m_cbFileSize	= cbFileSize;
	m_fReadOnly		= fReadOnly;
	m_cbIOSize		= cbIOSize;
	m_cbMMSize		= cbMMSize;

	//  set our initial file size

	m_rgcbFileSize[ 0 ] = m_cbFileSize;
	m_semChangeFileSize.Release();

	//  set our initial layout update callbacks

	m_pfnEndUpdate		= PfnEndUpdate( EndUpdateSink_ );
	m_keyEndUpdate		= DWORD_PTR( NULL );

	m_pfnBeginUpdate	= PfnBeginUpdate( BeginUpdateSink_ );
	m_keyBeginUpdate	= DWORD_PTR( NULL );

	//  init our I/O context

	if ( !( m_p_osf = new _OSFILE ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	m_p_osf->hFile				= m_hFile;
	m_p_osf->pfnFileIOComplete	= _OSFILE::PfnFileIOComplete( IOComplete_ );
	m_p_osf->keyFileIOComplete	= DWORD_PTR( this );

#ifndef LOGPATCH_UNIT_TEST

	Call( ErrOSFileIIOThreadRegisterFile( m_p_osf ) );

#else	//	LOGPATCH_UNIT_TEST

	m_cbData = DWORD( cbFileSize );
	m_rgbData = (BYTE*)PvOSMemoryPageAlloc( size_t( m_cbData ), NULL );
	if ( !m_rgbData )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

#endif	//	!LOGPATCH_UNIT_TEST

	return JET_errSuccess;

HandleError:
	m_hFile = INVALID_HANDLE_VALUE;
	return err;
	}

HANDLE COSFile::Handle()
	{
	return m_hFile;
	}

void COSFile::ForbidLayoutChanges()
	{
	}
	
void COSFile::PermitLayoutChanges()
	{
	}

COSFile::~COSFile()
	{
	//  we should stop layout updates before we start destruction

	if ( m_hFile != INVALID_HANDLE_VALUE )
		{
		SetHandleInformation( m_hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( m_hFile );
		m_hFile = INVALID_HANDLE_VALUE;
		}

	delete m_p_osf;
	m_p_osf = NULL;

#ifdef LOGPATCH_UNIT_TEST

	if ( m_rgbData )
		{
		OSMemoryPageFree( m_rgbData );
		}
	m_rgbData	= NULL;
	m_cbData	= 0;

#endif	//	LOGPATCH_UNIT_TEST
	}

ERR COSFile::ErrPath( _TCHAR* const szAbsPath )
	{
	_tcscpy( szAbsPath, m_szAbsPath );
	return JET_errSuccess;
	}

ERR COSFile::ErrSize( QWORD* const pcbSize )
	{
	const int group = m_msFileSize.Enter();
	*pcbSize = m_rgcbFileSize[ group ];
	m_msFileSize.Leave( group );
	return JET_errSuccess;
	}

ERR COSFile::ErrIsReadOnly( BOOL* const pfReadOnly )
	{
	*pfReadOnly = m_fReadOnly;
	return JET_errSuccess;
	}

ERR COSFile::ErrSetSize( const QWORD cbSize )
	{
	CIOComplete iocomplete;

	//  allocate an extending write request

	CExtendingWriteRequest* const pewreq = new CExtendingWriteRequest;
	if ( !pewreq )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	
	//  allocate an I/O request structure

	IOREQ* const pioreq = PioreqOSFileIIOREQAlloc();

	//  wait until we can change the file size

	m_semChangeFileSize.Acquire();
	const int group = m_msFileSize.ActiveGroup();

	//  we are extending the file

	if ( m_rgcbFileSize[ group ] < cbSize )
		{
		//  setup an extending write request to grow the file from the current
		//  size to the desired size
		
		pioreq->p_osf			= m_p_osf;
		pioreq->fWrite			= fTrue;
		pioreq->group			= group;
		pioreq->ibOffset		= m_rgcbFileSize[ group ];
		pioreq->cbData			= 0;
		pioreq->pbData			= NULL;
		pioreq->dwCompletionKey	= DWORD_PTR( pewreq );
		pioreq->pfnCompletion	= PFN( IOZeroingWriteComplete_ );

		pioreq->ovlp.Offset		= (ULONG) ( pioreq->ibOffset );
		pioreq->ovlp.OffsetHigh	= (ULONG) ( pioreq->ibOffset >> 32 );
		pioreq->pioreqNext		= NULL;

		pewreq->m_posf			= this;
		pewreq->m_pioreq		= pioreq;
		pewreq->m_group			= group;
		pewreq->m_ibOffset		= cbSize;
		pewreq->m_cbData		= 0;
		pewreq->m_pbData		= NULL;
		pewreq->m_pfnIOComplete	= PfnIOComplete( IOSyncComplete_ );
		pewreq->m_keyIOComplete	= DWORD_PTR( &iocomplete );

		OSFileIIOThreadCompleteWithErr(	ERROR_SUCCESS,
										pioreq->cbData,
										pioreq );
		}

	//  we are shrinking the file (or it is staying at the same size)

	else
		{
		//  setup a null extending write request at the desired file size
		
		pioreq->p_osf			= m_p_osf;
		pioreq->fWrite			= fTrue;
		pioreq->group			= group;
		pioreq->ibOffset		= cbSize;
		pioreq->cbData			= 0;
		pioreq->pbData			= NULL;
		pioreq->dwCompletionKey	= DWORD_PTR( pewreq );
		pioreq->pfnCompletion	= PFN( IOZeroingWriteComplete_ );

		pioreq->ovlp.Offset		= (ULONG) ( pioreq->ibOffset );
		pioreq->ovlp.OffsetHigh	= (ULONG) ( pioreq->ibOffset >> 32 );
		pioreq->pioreqNext		= NULL;

		pewreq->m_posf			= this;
		pewreq->m_pioreq		= pioreq;
		pewreq->m_group			= group;
		pewreq->m_ibOffset		= cbSize;
		pewreq->m_cbData		= 0;
		pewreq->m_pbData		= NULL;
		pewreq->m_pfnIOComplete	= PfnIOComplete( IOSyncComplete_ );
		pewreq->m_keyIOComplete	= DWORD_PTR( &iocomplete );

		OSFileIIOThreadCompleteWithErr(	ERROR_SUCCESS,
										pioreq->cbData,
										pioreq );
		}

	//  wait for the I/O completion and return its result

	if ( !iocomplete.m_msig.FTryWait() )
		{
		CallS( ErrIOIssue() );
		iocomplete.m_msig.Wait();
		}
	return iocomplete.m_err;
	}

ERR COSFile::ErrIOSize( DWORD* const pcbSize )
	{
	*pcbSize = m_cbIOSize;
	return JET_errSuccess;
	}

ERR COSFile::ErrIORead(	const QWORD			ibOffset,
						const DWORD			cbData,
						BYTE* const			pbData,
						const PfnIOComplete	pfnIOComplete,
						const DWORD_PTR		keyIOComplete )
	{
	ERR err = JET_errSuccess;

	//  a completion routine was specified

	if ( pfnIOComplete )
		{
#ifdef LOGPATCH_UNIT_TEST

		Enforce( ibOffset + cbData <= m_cbData );
		memcpy( pbData, m_rgbData + ibOffset, cbData );
		pfnIOComplete( JET_errSuccess, this, ibOffset, cbData, pbData, keyIOComplete );

#else	//	!LOGPATCH_UNIT_TEST

		//  allocate an I/O request structure

		IOREQ* const pioreq = PioreqOSFileIIOREQAlloc();

		//  use it to perform the I/O asynchronously
		
		IOAsync(	pioreq,
					fFalse,
					0,
					ibOffset,
					cbData,
					pbData,
					pfnIOComplete,
					keyIOComplete );

#endif	//	LOGPATCH_UNIT_TEST
		}

	//  a completion routine was not specified

	else
		{
		CIOComplete iocomplete;
		
		//  perform the I/O asynchronously
	
		CallS( ErrIORead(	ibOffset,
							cbData,
							pbData,
							PfnIOComplete( IOSyncComplete_ ),
							DWORD_PTR( &iocomplete ) ) );

		//  wait for the I/O completion and return its result

		if ( !iocomplete.m_msig.FTryWait() )
			{
			CallS( ErrIOIssue() );
			iocomplete.m_msig.Wait();
			}
		Call( iocomplete.m_err );
		}

	return JET_errSuccess;

HandleError:
	return err;
	}

ERR COSFile::ErrIOWrite(	const QWORD			ibOffset,
							const DWORD			cbData,
							const BYTE* const	pbData,
							const PfnIOComplete	pfnIOComplete,
							const DWORD_PTR		keyIOComplete )
	{
	ERR err = JET_errSuccess;

	//  a completion routine was specified

	if ( pfnIOComplete )
		{
#ifdef LOGPATCH_UNIT_TEST

		Enforce( ibOffset + cbData <= m_cbData );
		memcpy( m_rgbData + ibOffset, pbData, cbData );
		pfnIOComplete( JET_errSuccess, this, ibOffset, cbData, pbData, keyIOComplete );

#else	//	!LOGPATCH_UNIT_TEST

		//  allocate an I/O request structure

		IOREQ* const pioreq = PioreqOSFileIIOREQAlloc();

		//  use it to perform the I/O asynchronously
		
		IOAsync(	pioreq,
					fTrue,
					m_msFileSize.Enter(),
					ibOffset,
					cbData,
					(BYTE* const)pbData,
					pfnIOComplete,
					keyIOComplete );

#endif	//	LOGPATCH_UNIT_TEST
		}

	//  a completion routine was not specified

	else
		{
		CIOComplete iocomplete;
		
		//  perform the I/O asynchronously
	
		CallS( ErrIOWrite(	ibOffset,
							cbData,
							pbData,
							PfnIOComplete( IOSyncComplete_ ),
							DWORD_PTR( &iocomplete ) ) );

		//  wait for the I/O completion and return its result

		if ( !iocomplete.m_msig.FTryWait() )
			{
			CallS( ErrIOIssue() );
			iocomplete.m_msig.Wait();
			}
		Call( iocomplete.m_err );
		}

	return JET_errSuccess;

HandleError:
	return err;
	}

ERR COSFile::ErrIOIssue()
	{
	OSFileIIOThreadStartIssue( m_p_osf );
	return JET_errSuccess;
	}

ERR COSFile::ErrMMSize( QWORD* const pcbSize )
	{
	*pcbSize = m_cbMMSize;
	return JET_errSuccess;
	}

ERR COSFile::ErrMMRead(	const QWORD		ibOffset,
						const QWORD		cbSize,
						void** const	ppvMap,
						void* const		pvMapRequested )
	{
	ERR		err			= JET_errSuccess;
	HANDLE	hFileMap	= NULL;

	if ( size_t( cbSize ) != cbSize )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	//  RFS:  out of address space

	if ( !RFSAlloc( OSMemoryPageAddressSpace ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	if ( !( hFileMap = CreateFileMapping(	m_hFile,
											NULL,
											PAGE_READONLY | SEC_COMMIT,
											0,
											0,
											NULL ) ) )
		{
		Call( ErrOSFileIGetLastError() );
		}
	
	if ( !( *ppvMap = MapViewOfFileEx(	hFileMap,
										FILE_MAP_READ,
										DWORD( ibOffset >> 32 ),
										DWORD( ibOffset ),
										size_t( cbSize ),
										pvMapRequested ) ) )
		{
		Call( ErrOSFileIGetLastError() );
		}

	CloseHandle( hFileMap );
	hFileMap = NULL;

	//  RFS:  in-page error

	if ( !RFSAlloc( OSFileRead ) )
		{
		DWORD flOldProtect;
		(void)VirtualProtect( *ppvMap, DWORD( cbSize ), PAGE_NOACCESS, &flOldProtect );
		}
	
	return JET_errSuccess;

HandleError:
	if ( hFileMap )
		{
		CloseHandle( hFileMap );
		}
	*ppvMap = NULL;
	return err;
	}

ERR COSFile::ErrMMWrite(	const QWORD		ibOffset,
							const QWORD		cbSize,
							void** const	ppvMap,
							void* const		pvMapRequested )
	{
	ERR		err			= JET_errSuccess;
	HANDLE	hFileMap	= NULL;

	if ( size_t( cbSize ) != cbSize )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	//  RFS:  out of address space

	if ( !RFSAlloc( OSMemoryPageAddressSpace ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	if ( !( hFileMap = CreateFileMapping(	m_hFile,
											NULL,
											PAGE_READWRITE | SEC_COMMIT,
											0,
											0,
											NULL ) ) )
		{
		Call( ErrOSFileIGetLastError() );
		}
	
	if ( !( *ppvMap = MapViewOfFileEx(	hFileMap,
										FILE_MAP_WRITE,
										DWORD( ibOffset >> 32 ),
										DWORD( ibOffset ),
										size_t( cbSize ),
										pvMapRequested ) ) )
		{
		Call( ErrOSFileIGetLastError() );
		}

	CloseHandle( hFileMap );
	hFileMap = NULL;

	//  RFS:  in-page error

	if ( !RFSAlloc( OSFileRead ) )
		{
		DWORD flOldProtect;
		(void)VirtualProtect( *ppvMap, DWORD( cbSize ), PAGE_NOACCESS, &flOldProtect );
		}
	
	return JET_errSuccess;

HandleError:
	if ( hFileMap )
		{
		CloseHandle( hFileMap );
		}
	*ppvMap = NULL;
	return err;
	}

ERR COSFile::ErrMMFlush( void* const pvMap, const QWORD cbSize )
	{
	ERR err = JET_errSuccess;

	if ( size_t( cbSize ) != cbSize )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	//  RFS:  cannot flush view

	if ( !RFSAlloc( OSFileWrite ) )
		{
		Call( ErrERRCheck( JET_errDiskIO ) );
		}
	
	if ( !FlushViewOfFile( pvMap, size_t( cbSize ) ) )
		{
		Call( ErrOSFileIGetLastError() );
		}

	return JET_errSuccess;

HandleError:
	return err;
	}

ERR COSFile::ErrMMFree( void* const pvMap )
	{
	ERR err = JET_errSuccess;
	
	if ( pvMap && !UnmapViewOfFile( pvMap ) )
		{
		Call( ErrOSFileIGetLastError() );
		}

	return JET_errSuccess;

HandleError:
	return err;
	}

ERR COSFile::ErrRequestLayoutUpdates(	const PfnEndUpdate		pfnEndUpdate,
										const DWORD_PTR			keyEndUpdate,
										const PfnBeginUpdate	pfnBeginUpdate,
										const DWORD_PTR			keyBeginUpdate )
	{
	//  freeze our layout while updating our callbacks to avoid confusing the
	//  client

	ForbidLayoutChanges();

	//  update the callbacks

	m_pfnEndUpdate		= pfnEndUpdate ? pfnEndUpdate : PfnEndUpdate( EndUpdateSink_ );
	m_keyEndUpdate		= pfnEndUpdate ? keyEndUpdate : DWORD_PTR( NULL );

	m_pfnBeginUpdate	= pfnBeginUpdate ? pfnBeginUpdate : PfnBeginUpdate( BeginUpdateSink_ );
	m_keyBeginUpdate	= pfnBeginUpdate ? keyBeginUpdate : DWORD_PTR( NULL );

	//  unfreeze our layout

	PermitLayoutChanges();
	return JET_errSuccess;
	}

ERR COSFile::ErrQueryLayout(	const QWORD				ibVirtual,
								const QWORD				cbSize,
 								IFileLayoutAPI** const	ppflapi )
	{
	ERR				err		= JET_errSuccess;
	COSFileLayout*	posfl	= NULL;

	//  allocate the file layout iterator
	
	if ( !( posfl = new COSFileLayout ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  initialize the file layout iterator

	Call( posfl->ErrInit( this, ibVirtual, cbSize ) );

	//  return the interface to our file layout iterator

	*ppflapi = posfl;
	return JET_errSuccess;

HandleError:
	delete posfl;
	*ppflapi = NULL;
	return err;
	}

void COSFile::EndUpdateSink_(	COSFile* const	posf,
								const DWORD_PTR	keyEndUpdate )
	{
	posf->EndUpdateSink( keyEndUpdate );
	}

void COSFile::EndUpdateSink( const DWORD_PTR keyEndUpdate )
	{
	//  nop
	}
	
void COSFile::BeginUpdateSink_(	COSFile* const	posf,
								const DWORD_PTR	keyBeginUpdate )
	{
	posf->BeginUpdateSink( keyBeginUpdate );
	}

void COSFile::BeginUpdateSink( const DWORD_PTR keyBeginUpdate )
	{
	//  nop
	}

void COSFile::IOComplete_(	IOREQ* const	pioreq,
							const ERR		err,
							COSFile* const	posf )
	{
	posf->IOComplete( pioreq, err );
	}

void COSFile::IOComplete( IOREQ* const pioreq, const ERR err )
	{
	//  if this is a normal write then release our lock on the file size

	if (	pioreq->fWrite &&
			pioreq->pfnCompletion != PFN( IOZeroingWriteComplete_ ) &&
			pioreq->pfnCompletion != PFN( IOExtendingWriteComplete_ ) )
		{
		m_msFileSize.Leave( pioreq->group );
		}
	
	//  perform I/O completion callback
	
	const PfnIOComplete	pfnIOComplete	= PfnIOComplete( pioreq->pfnCompletion );

	pfnIOComplete(	err,
					this,
					pioreq->ibOffset,
					pioreq->cbData,
					pioreq->pbData,
					pioreq->dwCompletionKey );
	}

void COSFile::IOSyncComplete_(	const ERR			err,
								COSFile* const		posf,
								const QWORD			ibOffset,
								const DWORD			cbData,
								BYTE* const			pbData,
								CIOComplete* const	piocomplete )
	{
	posf->IOSyncComplete(	err,
							ibOffset,
							cbData,
							pbData,
							piocomplete );
	}

void COSFile::IOSyncComplete(	const ERR			err,
								const QWORD			ibOffset,
								const DWORD			cbData,
								BYTE* const			pbData,
								CIOComplete* const	piocomplete )
	{
	//  save the error code
	
	piocomplete->m_err = err;

	//  signal completion of the I/O

	piocomplete->m_msig.Set();
	}

void COSFile::IOAsync(	IOREQ* const		pioreq,
						const BOOL			fWrite,
						const int			group,
						const QWORD			ibOffset,
						const DWORD			cbData,
						BYTE* const			pbData,
						const PfnIOComplete	pfnIOComplete,
						const DWORD_PTR		keyIOComplete )
	{
	//  setup the I/O request

	pioreq->p_osf			= m_p_osf;
	pioreq->fWrite			= fWrite;
	pioreq->group			= group;
	pioreq->ibOffset		= ibOffset;
	pioreq->cbData			= cbData;
	pioreq->pbData			= pbData;
	pioreq->dwCompletionKey	= keyIOComplete;
	pioreq->pfnCompletion	= PFN( pfnIOComplete );

	pioreq->ovlp.Offset		= (ULONG) ( pioreq->ibOffset );
	pioreq->ovlp.OffsetHigh	= (ULONG) ( pioreq->ibOffset >> 32 );
	pioreq->pioreqNext		= NULL;

	//  this is an extending write

	if (	pioreq->fWrite &&
			pioreq->ibOffset + pioreq->cbData > m_rgcbFileSize[ pioreq->group ] )
		{
		//  try to allocate an extending write request

		CExtendingWriteRequest* const pewreq = new CExtendingWriteRequest;

		//  we failed to allocate an extending write request
		
		if ( !pewreq )
			{
			//  fail the I/O with out of memory
			
			OSFileIIOThreadCompleteWithErr(	ERROR_NOT_ENOUGH_MEMORY,
											pioreq->cbData,
											pioreq );
			}

		//  we got an extending write request

		else
			{
			//  save the parameters for this write

			pewreq->m_posf			= this;
			pewreq->m_pioreq		= pioreq;
			pewreq->m_group			= group;
			pewreq->m_ibOffset		= ibOffset;
			pewreq->m_cbData		= cbData;
			pewreq->m_pbData		= pbData;
			pewreq->m_pfnIOComplete	= pfnIOComplete;
			pewreq->m_keyIOComplete	= keyIOComplete;

			//  we can initiate a change in the file size

			if ( m_semChangeFileSize.FTryAcquire() )
				{
				//  start file extension by completing a fake extension I/O up to
				//  the current file size
				
				pioreq->ibOffset		= m_rgcbFileSize[ pioreq->group ];
				pioreq->cbData			= 0;
				pioreq->pbData			= NULL;
				pioreq->dwCompletionKey	= DWORD_PTR( pewreq );
				pioreq->pfnCompletion	= PFN( IOZeroingWriteComplete_ );

				pioreq->ovlp.Offset		= (ULONG) ( pioreq->ibOffset );
				pioreq->ovlp.OffsetHigh	= (ULONG) ( pioreq->ibOffset >> 32 );

				m_msFileSize.Leave( pioreq->group );

				OSFileIIOThreadCompleteWithErr(	ERROR_SUCCESS,
												pioreq->cbData,
												pioreq );
				}

			//  we cannot initiate a change in the file size

			else
				{
				//  defer this extending write

				m_critDefer.Enter();
				m_ilDefer.InsertAsNextMost( pewreq );
				m_critDefer.Leave();

				//	leave metered section after appending to list to ensure
				//	that IOChangeFileSizeComplete() will see the deferral.

				m_msFileSize.Leave( pioreq->group );
				}
			}
		}

	//  SPECIAL CASE:  this is a sync I/O and we can directly issue it on this
	//  thread

	else if (	pioreq->pfnCompletion == PFN( IOSyncComplete_ ) &&
				fUseDirectIO &&
				!Ptls()->fIOThread )
		{
		//  directly issue the I/O

		pioreq->ovlp.hEvent = HANDLE( DWORD_PTR( pioreq->ovlp.hEvent ) | DWORD_PTR( 1 ) );

		DWORD		cbTransfer;
		const BOOL	fIOSucceeded	= (	pioreq->fWrite ?
											WriteFile(	pioreq->p_osf->hFile,
														(BYTE*)pioreq->pbData,
														pioreq->cbData,
														&cbTransfer,
														LPOVERLAPPED( pioreq ) ) :
											ReadFile(	pioreq->p_osf->hFile,
														(BYTE*)pioreq->pbData,
														pioreq->cbData,
														&cbTransfer,
														LPOVERLAPPED( pioreq ) ) );
		const DWORD	error			= GetLastError();

		//  the issue succeeded and completed immediately

		if ( fIOSucceeded )
			{
			//  complete the I/O
			
			pioreq->ovlp.hEvent = HANDLE( DWORD_PTR( pioreq->ovlp.hEvent ) & ( ~DWORD_PTR( 1 ) ) );
			OSFileIIOThreadCompleteWithErr( ERROR_SUCCESS, cbTransfer, pioreq );
			}

		//  the issue failed or did not complete immediately
		
		else
			{
			//  the I/O is pending

			const ERR errIO = ErrOSFileIGetLastError( error );
			
			if ( errIO >= 0 )
				{
				//  wait for the I/O to complete and complete the I/O with the
				//  appropriate error code
				
				if ( GetOverlappedResult(	pioreq->p_osf->hFile,
											LPOVERLAPPED( pioreq ),
											&cbTransfer,
											TRUE ) )
					{
					pioreq->ovlp.hEvent = HANDLE( DWORD_PTR( pioreq->ovlp.hEvent ) & ( ~DWORD_PTR( 1 ) ) );
					OSFileIIOThreadCompleteWithErr( ERROR_SUCCESS, cbTransfer, pioreq );
					}
				else
					{
					pioreq->ovlp.hEvent = HANDLE( DWORD_PTR( pioreq->ovlp.hEvent ) & ( ~DWORD_PTR( 1 ) ) );
					OSFileIIOThreadCompleteWithErr( GetLastError(), 0, pioreq );
					}
				}

			//  we issued too many I/Os
	
			else if ( JET_errOutOfMemory == errIO )
				{
				//  queue the I/O for async completion

				pioreq->ovlp.hEvent = HANDLE( DWORD_PTR( pioreq->ovlp.hEvent ) & ( ~DWORD_PTR( 1 ) ) );
				critIO.Enter();
				OSFileIIOHeapAdd( pioreq );
				critIO.Leave();
				}

			//  some other fatal error occurred

			else
				{
				//  complete the I/O with the error

				pioreq->ovlp.hEvent = HANDLE( DWORD_PTR( pioreq->ovlp.hEvent ) & ( ~DWORD_PTR( 1 ) ) );
				OSFileIIOThreadCompleteWithErr( error, 0, pioreq );
				}
			}
		}

	//  this is not an extending write and is not a special case I/O

	else
		{
		//  queue the I/O for async completion

		critIO.Enter();
		OSFileIIOHeapAdd( pioreq );
		critIO.Leave();
		}
	}

void COSFile::IOZeroingWriteComplete_(	const ERR						err,
										COSFile* const					posf,
										const QWORD						ibOffset,
										const DWORD						cbData,
										BYTE* const						pbData,
										CExtendingWriteRequest* const	pewreq )
	{
	posf->IOZeroingWriteComplete(	err,
									ibOffset,
									cbData,
									pbData,
									pewreq );
	}

void COSFile::IOZeroingWriteComplete(	const ERR						err,
										const QWORD						ibOffset,
										const DWORD						cbData,
										BYTE* const						pbData,
										CExtendingWriteRequest* const	pewreq )
	{
	//  save the current error

	pewreq->m_err = err;

	//	start file extension process of zeroing from current filesystem EOF
	//	(using as many zeroing I/Os as we need) up to any extending write
	//	that we need to complete. if we're going to be using more than 1 I/O
	//	to extend the file to its new size, we should call SetEndOfFile() ahead
	//	of time to give the filesystem more information up front. (and we
	//	don't want to always call SetEndOfFile() [even though it would be
	//	"correct"] because NTFS counterintuitively behaves worse then.)

	if ( pewreq->m_err >= JET_errSuccess &&
		//	start of extension process (also case of file size staying the same)
		ibOffset + cbData == m_rgcbFileSize[ pewreq->m_group ] &&
		//	if extending write is past EOF, this means that at least 1
		//	zeroing I/O will need to be done
		pewreq->m_ibOffset > m_rgcbFileSize[ pewreq->m_group ] &&
		//	if extending write has actual data to be written, that is an additional I/O,
		//	or if there will need to be more than 1 zeroing I/O.
		( pewreq->m_cbData > 0 || pewreq->m_ibOffset - m_rgcbFileSize[ pewreq->m_group ] > cbZero ) )
		{
		//	give the filesystem early notification of how much storage we require
		//	for this entire multi-I/O extension process
		
		const QWORD	cbSize		= pewreq->m_ibOffset + pewreq->m_cbData;
		const DWORD	cbSizeLow	= DWORD( cbSize );
		DWORD	cbSizeHigh		= DWORD( cbSize >> 32 );

		m_p_osf->semFilePointer.Acquire();

		if ( (	SetFilePointer(	m_hFile,
								cbSizeLow,
								(long*)&cbSizeHigh,
								FILE_BEGIN ) == INVALID_SET_FILE_POINTER &&
				GetLastError() != NO_ERROR ) ||
			!SetEndOfFile( m_hFile ) )
			{
			pewreq->m_err = (	pewreq->m_err < JET_errSuccess ?
								pewreq->m_err :
								ErrOSFileIGetLastError() );		
			}
	
		m_p_osf->semFilePointer.Release();
		}
	
	//  this zeroing write succeeded

	if ( pewreq->m_err >= JET_errSuccess )
		{		
		//  there is still more file to be zeroed between the original file size
		//  and the extending write

		if ( ibOffset + cbData < pewreq->m_ibOffset )
			{
			//  compute the offset of the current chunk to be zeroed

			const QWORD ibWrite = ibOffset + cbData;
			
			//	We used to chunk align our zeroing writes (for unknown
			//	reasons) by using "cbZero - ibWrite % cbZero" instead of
			//	"cbZero" in the min() below. Chunk aligning broke NTFS's
			//	secret automagic pre-allocation algorithms which increased
			//	file fragmentation.
			
			const QWORD cbWrite = min(	cbZero,
										pewreq->m_ibOffset - ibWrite );
			Assert( DWORD( cbWrite ) == cbWrite );

			//  set the new file size to the file size after extension

			m_rgcbFileSize[ 1 - pewreq->m_group ] = ibWrite + cbWrite;

			//  zero the next aligned chunk of the file

			const P_OSFILE p_osf = pewreq->m_posf->m_p_osf;

			IOREQ* const pioreq = PioreqOSFileIIOREQAlloc();
			
			IOAsync(	pioreq,
						fTrue,
						1 - pewreq->m_group,
						ibWrite,
						DWORD( cbWrite ),
						rgbZero,
						PfnIOComplete( IOZeroingWriteComplete_ ),
						DWORD_PTR( pewreq ) );

			OSFileIIOThreadStartIssue( p_osf );
			}

		//  there is no more file to be zeroed

		else
			{
			//  set the new file size to the file size after extension

			m_rgcbFileSize[ 1 - pewreq->m_group ] = pewreq->m_ibOffset + pewreq->m_cbData;

			//  perform the original extending write

			const P_OSFILE p_osf = pewreq->m_posf->m_p_osf;

			IOREQ* const pioreq = PioreqOSFileIIOREQAlloc();
			
			IOAsync(	pioreq,
						fTrue,
						1 - pewreq->m_group,
						pewreq->m_ibOffset,
						pewreq->m_cbData,
						pewreq->m_pbData,
						PfnIOComplete( IOExtendingWriteComplete_ ),
						DWORD_PTR( pewreq ) );

			OSFileIIOThreadStartIssue( p_osf );
			}
		}

	//  this zeroing write failed

	else
		{
		//  set the file size back to the original file size

		m_rgcbFileSize[ 1 - pewreq->m_group ] = m_rgcbFileSize[ pewreq->m_group ];
		
		//  change over to the new file size

		m_msFileSize.Partition( CMeteredSection::PFNPARTITIONCOMPLETE( IOChangeFileSizeComplete_ ),
								DWORD_PTR( pewreq ) );
		}
	}

void COSFile::IOExtendingWriteComplete_(	const ERR						err,
											COSFile* const					posf,
											const QWORD						ibOffset,
											const DWORD						cbData,
											BYTE* const						pbData,
											CExtendingWriteRequest* const	pewreq )
	{
	posf->IOExtendingWriteComplete(	err,
									ibOffset,
									cbData,
									pbData,
									pewreq );
	}

void COSFile::IOExtendingWriteComplete(	const ERR						err,
										const QWORD						ibOffset,
										const DWORD						cbData,
										BYTE* const						pbData,
										CExtendingWriteRequest* const	pewreq )
	{
	//  save the current error

	pewreq->m_err = err;
	
	//  this extending write succeeded

	if ( err >= JET_errSuccess )
		{
		//  change over to the new file size

		m_msFileSize.Partition( CMeteredSection::PFNPARTITIONCOMPLETE( IOChangeFileSizeComplete_ ),
								DWORD_PTR( pewreq ) );
		}
	
	//  this extending write failed

	else
		{
		//  set the file size back to the original file size

		m_rgcbFileSize[ 1 - pewreq->m_group ] = m_rgcbFileSize[ pewreq->m_group ];
		
		//  change over to the new file size

		m_msFileSize.Partition( CMeteredSection::PFNPARTITIONCOMPLETE( IOChangeFileSizeComplete_ ),
								DWORD_PTR( pewreq ) );
		}
	}

void COSFile::IOChangeFileSizeComplete_( CExtendingWriteRequest* const pewreq )
	{
	pewreq->m_posf->IOChangeFileSizeComplete( pewreq );
	}

void COSFile::IOChangeFileSizeComplete( CExtendingWriteRequest* const pewreq )
	{
	const QWORD	cbSize		= m_rgcbFileSize[ 1 - pewreq->m_group ];
	const DWORD	cbSizeLow	= DWORD( cbSize );
	DWORD	cbSizeHigh		= DWORD( cbSize >> 32 );

	//	Shrinking file (user requested, or because we enlarged it, but
	//	subsequently encountered an I/O error and now want to shrink
	//	it back), so we need to explicitly set the file size.
	
	if ( cbSize < m_rgcbFileSize[ pewreq->m_group ] ||
		pewreq->m_err < JET_errSuccess )
		{
		//  set the end of file pointer to the new file size

		m_p_osf->semFilePointer.Acquire();

		if ( (	SetFilePointer(	m_hFile,
								cbSizeLow,
								(long*)&cbSizeHigh,
								FILE_BEGIN ) == INVALID_SET_FILE_POINTER &&
				GetLastError() != NO_ERROR ) ||
			!SetEndOfFile( m_hFile ) )
			{
			pewreq->m_err = (	pewreq->m_err < JET_errSuccess ?
								pewreq->m_err :
								ErrOSFileIGetLastError() );
			}
	
		m_p_osf->semFilePointer.Release();
		}

	//	When enlarging the file, we wrote into the newly allocated portion
	//	of the file so we should already be set
	
	else
		{
#ifdef DEBUG
		BY_HANDLE_FILE_INFORMATION	bhfi;

		if ( GetFileInformationByHandle( m_hFile, &bhfi ) )
			{
			Assert( cbSizeLow == bhfi.nFileSizeLow );
			Assert( cbSizeHigh == bhfi.nFileSizeHigh );
			}
#endif
		}

	//	Note that we could implement this by always calling SetEndOfFile(),
	//	but that causes NTFS to give up pre-allocated space it has reserved
	//	for us -- thus creating highly fragmented files.
	
	//	NT bug requires SetEndOfFile() or FlushFileBuffers() for other apps to
	//	see our updated file size.
	
	if ( !FlushFileBuffers( m_hFile ) )
		{
		pewreq->m_err = (	pewreq->m_err < JET_errSuccess ?
							pewreq->m_err :
							ErrOSFileIGetLastError() );
		}

	//  we have completed changing the file size so allow others to change it

	m_semChangeFileSize.Release();

	//  grab the list of deferred extending writes.  we must do this before we
	//  complete this extending write because the completion of the write might
	//  delete this file object if the list is empty!

	m_critDefer.Enter();
	CDeferList ilDefer = m_ilDefer;
	m_ilDefer.Empty();
	m_critDefer.Leave();

	//  fire the completion for the extending write

	pewreq->m_pfnIOComplete(	pewreq->m_err,
								this,
								pewreq->m_ibOffset,
								pewreq->m_cbData,
								pewreq->m_pbData,
								pewreq->m_keyIOComplete );

	delete pewreq;

	//  reissue all deferred extending writes
	//
	//  NOTE:  we start with the deferred extending write with the highest
	//  offset to minimize the number of times we extend the file.  this little
	//  trick makes a HUGE difference when appending to the file

	P_OSFILE p_osf = NULL;

	CExtendingWriteRequest* pewreqT;
	CExtendingWriteRequest* pewreqEOF;
	for ( pewreqT = pewreqEOF = ilDefer.PrevMost(); pewreqT; pewreqT = ilDefer.Next( pewreqT ) )
		{
		if ( pewreqT->m_ibOffset > pewreqEOF->m_ibOffset )
			{
			pewreqEOF = pewreqT;
			}
		}

	if ( pewreqEOF )
		{
		ilDefer.Remove( pewreqEOF );
		
		p_osf = pewreqEOF->m_posf->m_p_osf;
		
		IOAsync(	pewreqEOF->m_pioreq,
					fTrue,
					m_msFileSize.Enter(),
					pewreqEOF->m_ibOffset,
					pewreqEOF->m_cbData,
					pewreqEOF->m_pbData,
					pewreqEOF->m_pfnIOComplete,
					pewreqEOF->m_keyIOComplete );

		delete pewreqEOF;
		}

	while ( ilDefer.PrevMost() )
		{
		CExtendingWriteRequest* const pewreqDefer = ilDefer.PrevMost();
		ilDefer.Remove( pewreqDefer );

		p_osf = pewreqDefer->m_posf->m_p_osf;
		
		IOAsync(	pewreqDefer->m_pioreq,
					fTrue,
					m_msFileSize.Enter(),
					pewreqDefer->m_ibOffset,
					pewreqDefer->m_cbData,
					pewreqDefer->m_pbData,
					pewreqDefer->m_pfnIOComplete,
					pewreqDefer->m_keyIOComplete );

		delete pewreqDefer;
		}

	if ( p_osf )
		{
		OSFileIIOThreadStartIssue( p_osf );
		}
	}


COSFileLayout::COSFileLayout()
	:	m_posf( NULL ),
		m_fBeforeFirst( fTrue ),
		m_errFirst( JET_errNoCurrentRecord ),
		m_errCurrent( JET_errNoCurrentRecord )
	{
	}

ERR COSFileLayout::ErrInit(	COSFile* const	posf,
							QWORD const		ibVirtual,
							QWORD const		cbSize )
	{
	ERR err = JET_errSuccess;
	
	//  reference the file object that created this File Layout iterator and
	//  freeze its layout for the lifetime of this iterator

	m_posf = posf;
	m_posf->ForbidLayoutChanges();

	//  copy our original search criteria

	m_ibVirtualFind	= ibVirtual;
	m_cbSizeFind	= cbSize;

	//  get the size of the referenced file.  remember that this cannot change
	//  while this iterator exists

	QWORD cbFileSize;
	Call( m_posf->ErrSize( &cbFileSize ) );

	//  the queried offset range begins before the end of our file

	if ( m_ibVirtualFind < cbFileSize )
		{
		//  setup the iterator to move first to a single dummy run that
		//  represents the range of the file in the queried offset range

		Call( m_posf->ErrPath( m_szAbsVirtualPath ) );
		m_ibVirtual	= m_ibVirtualFind;
		m_cbSize	= min( cbFileSize - m_ibVirtualFind, m_cbSizeFind );
		Call( m_posf->ErrPath( m_szAbsLogicalPath ) );
		m_ibLogical	= m_ibVirtualFind;

		m_errFirst = JET_errSuccess;
		}

	return JET_errSuccess;

HandleError:
	return err;
	}

COSFileLayout::~COSFileLayout()
	{
	if ( m_posf )
		{
		//  unreference our file object

		m_posf->PermitLayoutChanges();
		m_posf = NULL;
		}
	m_fBeforeFirst	= fTrue;
	m_errFirst		= JET_errNoCurrentRecord;
	m_errCurrent	= JET_errNoCurrentRecord;
	}

ERR COSFileLayout::ErrNext()
	{
	ERR err = JET_errSuccess;

	//  we have yet to move first

	if ( m_fBeforeFirst )
		{
		m_fBeforeFirst = fFalse;

		//  setup the iterator to be on the results of the move first that we
		//  did in ErrInit()
		
		m_errCurrent = m_errFirst;
		}

	//  we cannot potentially see any more runs

	else
		{
		//  setup the iterator to be after last

		m_errCurrent = JET_errNoCurrentRecord;
		}

	//  check the error state of the iterator's current entry

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}
	
	return JET_errSuccess;

HandleError:
	m_errCurrent = err;
	return err;
	}

ERR COSFileLayout::ErrVirtualPath( _TCHAR* const szAbsVirtualPath )
	{
	ERR err = JET_errSuccess;

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}

	_tcscpy( szAbsVirtualPath, m_szAbsVirtualPath );
	return JET_errSuccess;

HandleError:
	_tcscpy( szAbsVirtualPath, _T( "" ) );
	return err;
	}

ERR COSFileLayout::ErrVirtualOffsetRange(	QWORD* const	pibVirtual,
											QWORD* const	pcbSize )
	{
	ERR err = JET_errSuccess;

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}

	*pibVirtual	= m_ibVirtual;
	*pcbSize	= m_cbSize;
	return JET_errSuccess;

HandleError:
	*pibVirtual	= 0;
	*pcbSize	= 0;
	return err;
	}

ERR COSFileLayout::ErrLogicalPath( _TCHAR* const szAbsLogicalPath )
	{
	ERR err = JET_errSuccess;

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}

	_tcscpy( szAbsLogicalPath, m_szAbsLogicalPath );
	return JET_errSuccess;

HandleError:
	_tcscpy( szAbsLogicalPath, _T( "" ) );
	return err;
	}

ERR COSFileLayout::ErrLogicalOffsetRange(	QWORD* const	pibLogical,
											QWORD* const	pcbSize )
	{
	ERR err = JET_errSuccess;

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}

	*pibLogical	= m_ibLogical;
	*pcbSize	= m_cbSize;
	return JET_errSuccess;

HandleError:
	*pibLogical	= 0;
	*pcbSize	= 0;
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\task.cxx ===
#include "osstd.hxx"


LOCAL BOOL fCanUseIOCP;

LOCAL const char *szCritTaskList	= "CTaskManager::m_critTask";
LOCAL const char *szCritActiveThread	= "CTaskManager::m_critActiveThread";
LOCAL const int rankCritTaskList	= 0;

LOCAL const char *szSemTaskDispatch	= "CTaskManager::m_semTaskDispatch";


////////////////////////////////////////////////
//
//	Generic Task Manager
//

//	ctor

CTaskManager::CTaskManager()
	:	m_critTask( CLockBasicInfo( CSyncBasicInfo( szCritTaskList ), rankCritTaskList, 0 ) ),
		m_critActivateThread( CLockBasicInfo( CSyncBasicInfo( szCritTaskList ), rankCritTaskList, 0 ) ),
		m_semTaskDispatch( CSyncBasicInfo( szSemTaskDispatch ) )
	{
	m_cThread			= 0;
	m_cThreadMax		= 0;
	m_cPostedTasks		= 0;
	m_cmsLastActivateThreadTime	= 0;
	m_cTasksThreshold	= 0;

#ifdef DEBUG
	m_fIgnoreTasksAmountAsserts	= fFalse;
#endif // DEBUG
	m_rgThreadContext	= NULL;

	m_rgpTaskNode		= NULL;

	m_hIOCPTaskDispatch	= NULL;

	m_dtickTimeout		= 0;
	m_pfnTimeout		= NULL;
	}


//	dtor

CTaskManager::~CTaskManager()
	{
	}


//	initialize the task manager
//	NOTE: this is not thread-safe with respect to TMTerm or itself

ERR CTaskManager::ErrTMInit(	const ULONG						cThread,
								const DWORD_PTR *const			rgThreadContext,
								const TICK						dtickTimeout,
								CTaskManager::PfnCompletion		pfnTimeout )
	{
	ERR err;

	Assert( 0 == m_cThread );
	Assert( !m_rgThreadContext );
	Assert( m_ilTask.FEmpty() );
	Assert( 0 == m_semTaskDispatch.CAvail() );
	Assert( !m_rgpTaskNode );
	Assert( !m_hIOCPTaskDispatch );

	m_dtickTimeout	= dtickTimeout;
	m_pfnTimeout	= pfnTimeout;

	if ( !fCanUseIOCP )
		{
		ULONG iThread;

		//	allocate extra task-nodes for TMTerm (prevents out-of-memory)
		//	NOTE: they must be allocated separately so they can be freed separately

		m_rgpTaskNode = new CTaskNode*[cThread];
		if ( !m_rgpTaskNode )
			{
			Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
			}
		memset( m_rgpTaskNode, 0, cThread * sizeof( CTaskNode * ) );
		for ( iThread = 0; iThread < cThread; iThread++ )
			{
			m_rgpTaskNode[iThread] = new CTaskNode();
			if ( !m_rgpTaskNode[iThread] )
				{
				Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
				}
			}
		}

	//	allocate THREAD handles

	m_cThread = 0;
	m_rgThreadContext = new THREADCONTEXT[cThread];
	if ( !m_rgThreadContext )
		{
		Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
		}
	memset( m_rgThreadContext, 0, sizeof( THREADCONTEXT ) * cThread );

	//	initialize dispatcher

	if ( fCanUseIOCP )
		{

		//	create an I/O completion port for posting tasks

		m_hIOCPTaskDispatch = CreateIoCompletionPort( INVALID_HANDLE_VALUE, NULL, 0, 0 );
		if ( !m_hIOCPTaskDispatch )
			{
			Error( ErrERRCheck( JET_errOutOfMemory ), HandleError );
			}
		}
	else
		{

		//	setup the task-node list

		//	nop (done by ctor)
		}

	Assert( cThread < 1000 );
	m_cThreadMax = cThread;

	//	prepare the thread context

	if ( rgThreadContext )
		{
		
		for ( m_cThread = 0; m_cThread < cThread; m_cThread++ )
			{
			m_rgThreadContext[m_cThread].dwThreadContext = rgThreadContext[m_cThread];
			}
		}
	for ( m_cThread = 0; m_cThread < cThread; m_cThread++ )
		{
		m_rgThreadContext[m_cThread].ptm = this;
		}
	m_cThread = 0;

	//  one fake posted task to initialize thread checker

	m_cPostedTasks = 1;
	Call( ErrAddThreadCheck() );
	m_cPostedTasks = 0;

	Assert( 1 == m_cThread );

	return JET_errSuccess;

HandleError:

	//	cleanup

	TMTerm();

	return err;
	}


//	cleanup the task manager
//	NOTE: this is not thread-safe with respect to ErrTMInit or itself

VOID CTaskManager::TMTerm()
	{
	ULONG iThread;
	ULONG cThread;

	// stop eventual growing of the threads' number in the thread pool

	m_critActivateThread.Enter();
	m_cTasksThreshold = -1;
	m_cThreadMax = 0;
	m_critActivateThread.Leave();

	//	capture the number of active threads

	cThread = m_cThread;

	if ( NULL != m_rgThreadContext )
		{
		//	post a set of fake tasks that will cause the worker threads to exit gracefully

		for ( iThread = 0; iThread < cThread; iThread++ )
			{
			if ( fCanUseIOCP )
				{

				//	try to post a task to the I/O completion port
				//	NOTE: if the task-post fails, the thread will linger and be cleaned up by the OS

				Assert( m_hIOCPTaskDispatch );
				CallS( ErrTMPost( TMITermTask, 0, 0 ) );
				}
			else
				{
				//	verify the extra task-node

				Assert( m_rgpTaskNode );
				Assert( m_rgpTaskNode[iThread] );

				//	initialize the extra task-node

				m_rgpTaskNode[iThread]->m_pfnCompletion = TMITermTask;

				//	post the task

				m_critTask.Enter();
				m_ilTask.InsertAsNextMost( m_rgpTaskNode[iThread] );
				m_critTask.Leave();
				m_semTaskDispatch.Release();

				//	prevent cleanup from freeing the extra task-node

				m_rgpTaskNode[iThread] = NULL;
				}
			}

		//	wait for each thread to exit

		for ( iThread = 0; iThread < cThread; iThread++ )
			{
			if ( m_rgThreadContext[iThread].thread )
				{
				UtilThreadEnd( m_rgThreadContext[iThread].thread );
				}
			}

		//	cleanup the thread array

		delete m_rgThreadContext;
		}
	m_rgThreadContext = NULL;
	m_cThread = 0;
	m_cTasksThreshold = 0;
	m_cmsLastActivateThreadTime = 0;

	//	term the task-list (it should be empty at this point)

	Assert( m_ilTask.FEmpty() );
	if ( !m_ilTask.FEmpty() )
		{
		//	lock the task list

		m_critTask.Enter();
		
		while ( !m_ilTask.FEmpty() )
			{
			CTaskNode *ptn = m_ilTask.PrevMost();
			m_ilTask.Remove( ptn );
			delete ptn;
			}

		m_critTask.Leave();
		}

	Assert( 0 == m_semTaskDispatch.CAvail() );
	while ( m_semTaskDispatch.FTryAcquire() )
		{
		}

	//	cleanup the extra task-nodes

	if ( m_rgpTaskNode )
		{
		for ( iThread = 0; iThread < m_cThread; iThread++ )
			{
			delete m_rgpTaskNode[iThread];
			}
		delete [] m_rgpTaskNode;
		}
	m_rgpTaskNode = NULL;

	//	cleanup the I/O completion port

	if ( m_hIOCPTaskDispatch )
		{
		const BOOL fCloseOk = CloseHandle( m_hIOCPTaskDispatch );
		Assert( fCloseOk );
		}
	m_hIOCPTaskDispatch = NULL;
	}


//	post a task

ERR CTaskManager::ErrTMPost(	CTaskManager::PfnCompletion	pfnCompletion,
								const DWORD					dwCompletionKey1,
								const DWORD_PTR				dwCompletionKey2 )
	{

	//	verify input

	Assert( pfnCompletion );

	Assert( 0 < m_cThread );

	//	Increment the number of eventually posted tasks

	AtomicIncrement( (LONG *)&m_cPostedTasks );
	(VOID)ErrAddThreadCheck();

	if ( fCanUseIOCP )
		{

		//	we will be posting a task to the I/O completion port

		Assert( m_hIOCPTaskDispatch );

		//	post the task to the I/O completion port

		BOOL fPostedOk = PostQueuedCompletionStatus(	m_hIOCPTaskDispatch,
														dwCompletionKey1,
														DWORD_PTR( pfnCompletion ),
														(OVERLAPPED*)dwCompletionKey2 );
		if ( !fPostedOk )
			{

			//	correct the number of posted tasks
			
			AtomicDecrement( (LONG *)&m_cPostedTasks );
			return ErrERRCheck( JET_errOutOfMemory );
			}
		}
	else
		{

		//	allocate a task-list node using the given context

		CTaskNode *ptn = new CTaskNode();
		if ( !ptn )
			{

			//	correct the number of posted tasks
			
			AtomicDecrement( (LONG *)&m_cPostedTasks );
			return ErrERRCheck( JET_errOutOfMemory );
			}
		ptn->m_pfnCompletion = pfnCompletion;
		ptn->m_dwCompletionKey1 = dwCompletionKey1;
		ptn->m_dwCompletionKey2 = dwCompletionKey2;

		//	post the task

		m_critTask.Enter();
		m_ilTask.InsertAsNextMost( ptn );
		m_critTask.Leave();
		m_semTaskDispatch.Release();
		}

	return JET_errSuccess;
	}


//	special API to allow files to register with the task manager's I/O completion port

BOOL CTaskManager::FTMRegisterFile( VOID *hFile, CTaskManager::PfnCompletion pfnCompletion )
	{
	HANDLE hIOCP;

	//	verify input

	Assert( hFile );
	Assert( pfnCompletion );

	//  if we can't use I/O completion ports then we don't need to do anything

	if ( !fCanUseIOCP )
		{
		return fTrue;
		}

	//	we should have an I/O completion port allocated

	Assert( m_hIOCPTaskDispatch );

	//	register the file handle with the I/O completion port
	//
	//	notes on how this works:
	//
	//		When async-file-I/O completes, it will post a completion packet which will wake up a 
	//		CTaskManager thread.  The thread will interpret the parameters of the completion
	//		as if they came from ErrTMPost via PostQueuedCompletionStatus.  Therefore, we must
	//		make sure that the I/O completion looks and acts like one from ErrTMPost.
	//
	//		ErrTMPost interprets the completion packet like this:
	//
	//			number of bytes transferred ==> dwCompletionKey1 (DWORD)
	//			completion key              ==> pfnCompletion    (DWORD_PTR)
	//			ptr to overlapped structure ==> dwCompletionKey2 (DWORD_PTR)
	//
	//		We make the "completion key" a function pointer by passing in the address of the
	//		specified I/O handler (pfnCompletion).  The number of bytes transferred and the
	//		overlapped ptr are specified at I/O-issue time.

	hIOCP = CreateIoCompletionPort( hFile, m_hIOCPTaskDispatch, DWORD_PTR( pfnCompletion ), 0 );
	Assert( NULL == hIOCP || hIOCP == m_hIOCPTaskDispatch );
	if ( NULL != hIOCP && m_cThread < m_cThreadMax )
		{
		//	We are not able to perform gracefully growing of the threads number
		//	because the task can be issued without using ErrTMPost
		//	and we have no control over real number of posted tasks
		//	Thus we will try to create Max number of threads
		ERR err = JET_errSuccess;
		m_critActivateThread.Enter();
		for ( ; m_cThread < m_cThreadMax && JET_errSuccess <= err; m_cThread ++ )
			{
			//	create the thread
			
			err = ErrUtilThreadCreate(	PUTIL_THREAD_PROC( TMDispatch ),
										OSMemoryPageReserveGranularity(),
										priorityNormal,
										&m_rgThreadContext[m_cThread].thread,
										DWORD_PTR( m_rgThreadContext + m_cThread ) );
			}
		AtomicExchange( (LONG *)&m_cTasksThreshold, -1 );
#ifdef DEBUG
		m_fIgnoreTasksAmountAsserts = fTrue;
#endif // DEBUG
		m_critActivateThread.Leave();
		}

	return BOOL( NULL != hIOCP );
	}


//	dispatch a task (wrapper for TMIDispatch)

DWORD CTaskManager::TMDispatch( DWORD_PTR dwContext )
	{
	THREADCONTEXT *ptc;
	
	//	extract the context

	Assert( 0 != dwContext );
	ptc = (THREADCONTEXT *)dwContext;

	//	run the internal dispatcher

	ptc->ptm->TMIDispatch( ptc->dwThreadContext );

	return 0;
	}


//	main task dispatcher (thread-body for workers)

VOID CTaskManager::TMIDispatch( const DWORD_PTR dwThreadContext )
	{
	PfnCompletion	pfnCompletion;
	DWORD			dwCompletionKey1;
	DWORD_PTR		dwCompletionKey2;

	//	we should be a task thread

	Assert( !Ptls()->fIsTaskThread );
	Ptls()->fIsTaskThread = fTrue;

	//	task loop

	while ( Ptls()->fIsTaskThread )
		{
		if ( fCanUseIOCP )
			{

			//	wait for a task to appear on the I/O completion port

			BOOL fSuccess = GetQueuedCompletionStatus(	m_hIOCPTaskDispatch,
														&dwCompletionKey1,
														(DWORD_PTR*)&pfnCompletion,
														(OVERLAPPED**)&dwCompletionKey2,
														m_dtickTimeout ? m_dtickTimeout : INFINITE );
			if ( fSuccess )
				{
				SetLastError( ERROR_SUCCESS );
				}
			if ( GetLastError() == WAIT_TIMEOUT )
				{
				//  fire a timeout event

				pfnCompletion		= m_pfnTimeout;
				dwCompletionKey1	= 0;
				dwCompletionKey2	= 0;

				//	correct the number of posted tasks
				
				AtomicIncrement( (LONG *)&m_cPostedTasks );
				}
			}
		else
			{
			CTaskNode *ptn;

			//	wait for a task to be posted (disable deadlock timeout)

			if ( m_semTaskDispatch.FAcquire( m_dtickTimeout ? m_dtickTimeout : cmsecInfiniteNoDeadlock ) )
				{
				//	get the next task-node

				m_critTask.Enter();
				ptn = m_ilTask.PrevMost();
				Assert( ptn );
				m_ilTask.Remove( ptn );
				m_critTask.Leave();

				//	extract the task node's parameters

				pfnCompletion		= ptn->m_pfnCompletion;
				dwCompletionKey1	= ptn->m_dwCompletionKey1;
				dwCompletionKey2	= ptn->m_dwCompletionKey2;

				//	cleanup up the task node

				delete ptn;
				}
			else
				{
				//  fire a timeout event

				pfnCompletion		= m_pfnTimeout;
				dwCompletionKey1	= 0;
				dwCompletionKey2	= 0;

				//	correct the number of posted tasks
				
				AtomicIncrement( (LONG *)&m_cPostedTasks );
				}
			}

		//	run the task

		Assert( pfnCompletion );
		pfnCompletion( dwThreadContext, dwCompletionKey1, dwCompletionKey2 );

			//	correct the number of posted tasks
			
		LONG count = AtomicDecrement( (LONG *)&m_cPostedTasks );
		Assert( !m_fIgnoreTasksAmountAsserts || 0 <= count );
		}
	}


//	used a bogus completion to pop threads off of the I/O completion port

VOID CTaskManager::TMITermTask(	const DWORD_PTR	dwThreadContext,
								const DWORD		dwCompletionKey1,
								const DWORD_PTR	dwCompletionKey2 )
	{

	//	this thread is no longer processing tasks

	Assert( Ptls()->fIsTaskThread );
	Ptls()->fIsTaskThread = fFalse;
	}


//	Check if need to activate one more thread in the thread pool

ERR CTaskManager::ErrAddThreadCheck()
	{
	ERR err = JET_errSuccess;

	//	should we ignore the check?
	if ( m_cPostedTasks <= m_cTasksThreshold )
		{
		//	do nothing
		}
		
	else if ( m_cmsLastActivateThreadTime + m_cThread * 500 / CUtilProcessProcessor() > TickOSTimeCurrent() )
		{
		//	do nothing except check if the Win timer is overflowed
		if ( m_cmsLastActivateThreadTime > TickOSTimeCurrent() )
			{
			ULONG cmsLastActivateThreadTime = m_cmsLastActivateThreadTime;
			if ( m_critActivateThread.FTryEnter() )
				{
				//	correct last activate time
				AtomicCompareExchange( (LONG *)&m_cmsLastActivateThreadTime, cmsLastActivateThreadTime, TickOSTimeCurrent() );
				m_critActivateThread.Leave();
				}
			}
		}
	
	//	Try to enter the critical section to update the thread information
	else if ( m_critActivateThread.FTryEnter() )
		{
		//	verify the time again. Just in case if somebody is updated the information meanwhile
		if ( m_cmsLastActivateThreadTime + m_cThread * 500 / CUtilProcessProcessor() <= TickOSTimeCurrent() 
			&& m_cThread < m_cThreadMax 
			&& m_cPostedTasks > m_cTasksThreshold )
			{
			//	create the thread
			err = ErrUtilThreadCreate(	PUTIL_THREAD_PROC( TMDispatch ),
										OSMemoryPageReserveGranularity(),
										priorityNormal,
										&m_rgThreadContext[m_cThread].thread,
										DWORD_PTR( m_rgThreadContext + m_cThread ) );
			if ( JET_errSuccess <= err )
				{
				//	increase the thread count AFTER we have successfully created the thread
				AtomicIncrement( (LONG *)&m_cThread );
				//	if we have reached the max number of threads 
				if ( m_cThread == m_cThreadMax )
					{
					//	disable further attempts to activate threads
					m_cTasksThreshold = -1;
					}
				else
					{
					//	set new activate, time & threshold
					Assert( m_cThread < m_cThreadMax );
					m_cmsLastActivateThreadTime = TickOSTimeCurrent();
					m_cTasksThreshold = m_cThread * 8;
					}
				}
			}

		//	Leave the critical section
		m_critActivateThread.Leave();
		}
	return err;
	}


////////////////////////////////////////////////
//
//	Task Manager for Win2000
//

LONG volatile CGPTaskManager::m_cRef = 0;
CTaskManager CGPTaskManager::m_taskmanager;
CGPTaskManager *g_pGPTaskMgr = NULL;

typedef BOOL (__stdcall *PfnQueueUserWorkItem)(
  LPTHREAD_START_ROUTINE Function,  // starting address
  VOID *Context,                    // function data
  ULONG Flags                       // worker options
);

LOCAL PfnQueueUserWorkItem pfnQueueUserWorkItem = NULL;

//	ctor

CGPTaskManager::CGPTaskManager() :
	m_fInit( fFalse ),
	m_cPostedTasks( 0 ),
	m_asigAllDone( CSyncBasicInfo( _T( "CGPTaskManager::m_asigAllDone" ) ) )
	{
	}

CGPTaskManager::~CGPTaskManager()
	{
	Assert( 0 == m_cPostedTasks );
	}

ERR CGPTaskManager::ErrTMInit( const ULONG cThread )
	{
	ERR err = JET_errSuccess;
	//	Init for the first time
	if ( 1 == AtomicIncrement( (LONG *)&m_cRef ) )
		{
		Assert( 0 < cThread );
		//	If QueueUserWorkItem is not supported use CTaskManager with 
		//	adviced cThread number of threads.
		if ( NULL == pfnQueueUserWorkItem )
			{
			err = m_taskmanager.ErrTMInit( cThread );
			if ( JET_errSuccess > err )
				{
				m_cRef = 0;
				}
			}
		}
		
	if ( JET_errSuccess <= err )
		{
		AtomicExchange( (LONG *)&m_fInit, fTrue );
		}
		
	return err;
	}

VOID CGPTaskManager::TMTerm()
	{
	LONG cRef;
	LONG fInit = AtomicExchange( (LONG *)&m_fInit, fFalse );
	Assert( fInit );
	m_cmsPostTasks.Partition();

	//	Wait until all tasks complete
	if ( 0 != m_cPostedTasks )
		{
		m_asigAllDone.Wait();
		}
	m_asigAllDone.Reset();
	Assert( 0 == m_cPostedTasks );

	// decrement the reference counter
	cRef = AtomicDecrement( (LONG *)&m_cRef );
	Assert( 0 <= cRef );

	//	If it is the last instance free the resources
	if ( 0 == cRef )
		{
		//	If we use CTaskManager terminate it.
		if ( NULL == pfnQueueUserWorkItem )
			{
			m_taskmanager.TMTerm();
			}
		}
	}

ERR CGPTaskManager::ErrTMPost( PfnCompletion	 pfnCompletion, VOID *pvParam, DWORD dwFlags )
	{
	ERR err = JET_errSuccess;
	PTMCallWrap ptmCallWrap = NULL;
	int iGroup;

	//	Enter post task metered section
	iGroup = m_cmsPostTasks.Enter();

	//	Increment the number of eventually posted tasks
	AtomicIncrement( (LONG *)&m_cPostedTasks );

	if ( m_fInit )
		{
		//  wrap the Call
		ptmCallWrap = new TMCallWrap;
		if ( NULL != ptmCallWrap )
			{
			ptmCallWrap->pfnCompletion	= pfnCompletion;
			ptmCallWrap->pvParam		= pvParam;
			ptmCallWrap->pThis			= this;

			//	choose the proper dispatch function based on used thread pool manager
			if ( NULL == pfnQueueUserWorkItem )
				{
				err = m_taskmanager.ErrTMPost( TMIDispatch, 0, DWORD_PTR( ptmCallWrap ) );
				}
			else if ( !pfnQueueUserWorkItem( CGPTaskManager::TMIDispatchGP, ptmCallWrap, dwFlags ) )
				{
				err = ErrERRCheck( JET_errOutOfMemory );
				}
			}
		else
			{
			err = ErrERRCheck( JET_errOutOfMemory );
			}
		}
	else
		{

		//	the task manager is not initialized so the task must be dropped

		err = ErrERRCheck( JET_errTaskDropped );
		AssertTracking();	//	this shouldn't happen; trap it because caller may not handle this case well
		}

	//	if we failed to post the task decrement the number of posted tasks
	if ( JET_errSuccess > err )
		{
		ULONG cPostedTasks = AtomicDecrement( (LONG *)&m_cPostedTasks );
		//	Set the AllDone signal if there is no other posted tasks
		if ( 0 == cPostedTasks && !m_fInit )
			{
			m_asigAllDone.Set();
			}
		}

	// leave post task metered section
	m_cmsPostTasks.Leave( iGroup );

	return err;
	}

DWORD __stdcall CGPTaskManager::TMIDispatchGP( VOID *pvParam )
	{
	PTMCallWrap		ptmCallWrap		= PTMCallWrap( pvParam );	
	int fIsTaskThread = Ptls()->fIsTaskThread;

	//	All tasks must be executed in TaskThread environment
	if ( !fIsTaskThread )
		{
		Ptls()->fIsTaskThread = fTrue;
		}

	// check input parameters
	Assert( NULL != ptmCallWrap );

	extern BOOL g_fCatchExceptions;
	if ( g_fCatchExceptions && NULL != pfnQueueUserWorkItem )
		{
		TRY 
			{
			ptmCallWrap->pfnCompletion( ptmCallWrap->pvParam );
			} 
		EXCEPT( ExceptionFail( "In worker thread." ) ) 
			{ 
			}
		ENDEXCEPT
		}
	else
		{
		ptmCallWrap->pfnCompletion( ptmCallWrap->pvParam );
		}

	LONG cRunningTasks = AtomicDecrement( ( LONG * )&(ptmCallWrap->pThis->m_cPostedTasks) );
	Assert( 0 <= cRunningTasks );
	if ( 0 == cRunningTasks && !ptmCallWrap->pThis->m_fInit )
		{
		ptmCallWrap->pThis->m_asigAllDone.Set();
		}
	delete ptmCallWrap;
	if ( !fIsTaskThread )
		{
		Ptls()->fIsTaskThread = fFalse;
		}
	return 0;
	}

VOID CGPTaskManager::TMIDispatch( const DWORD_PTR	dwThreadContext,
										const DWORD		dwCompletionKey1,
										const DWORD_PTR	dwCompletionKey2 )
	{
	// check input parameters
	Assert( NULL == dwThreadContext );
	Assert( 0 == dwCompletionKey1 );
	TMIDispatchGP( (VOID *)dwCompletionKey2 );
	}

//  post-terminate task subsystem

void OSTaskPostterm()
	{
	//  nop
	}

//  pre-init task subsystem

BOOL FOSTaskPreinit()
	{
	//  determine IOCP availability

	OSVERSIONINFO osvi;
	memset( &osvi, 0, sizeof( osvi ) );
	osvi.dwOSVersionInfoSize = sizeof( osvi );
	if ( !GetVersionEx( &osvi ) )
		{
		goto HandleError;
		}

	fCanUseIOCP = osvi.dwPlatformId == VER_PLATFORM_WIN32_NT;

	return fTrue;

HandleError:
	OSTaskPostterm();
	return fFalse;
	}


//  terminates the task subsystem

void OSTaskTerm()
	{
	if ( NULL != g_pGPTaskMgr )
		{
		g_pGPTaskMgr->TMTerm();
		delete g_pGPTaskMgr;
		g_pGPTaskMgr = NULL;
		}
	}

//  init task subsystem

ERR ErrOSTaskInit()
	{
	ERR err = JET_errSuccess;
	Assert( NULL == g_pGPTaskMgr );
	HMODULE hmodKernel32 = NULL;
	hmodKernel32 = LoadLibrary( _T("Kernel32.dll") );
	if ( NULL != hmodKernel32 )
		{
		pfnQueueUserWorkItem = (PfnQueueUserWorkItem)GetProcAddress( hmodKernel32, "QueueUserWorkItem" );
		FreeLibrary( hmodKernel32 );
		}
	g_pGPTaskMgr = new CGPTaskManager;
	if ( NULL == g_pGPTaskMgr )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		}
	else
		{
		err = g_pGPTaskMgr->ErrTMInit( min( 8 * CUtilProcessProcessor(), 100 ) );
		if ( JET_errSuccess > err )
			{
			delete g_pGPTaskMgr;
			g_pGPTaskMgr = NULL;
			}
		}
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\osslv.cxx ===
#include "osstd.hxx"
#include "std.hxx"
#include "_osslv.hxx"


TICK tickOSSLVInstanceID;


long 	cbOSSLVReserve;

TICK 	cmsecOSSLVSpaceFreeDelay;
TICK 	cmsecOSSLVFileOpenDelay;
TICK 	cmsecOSSLVTTL;
TICK 	cmsecOSSLVTTLSafety;
TICK 	cmsecOSSLVTTLInfinite;

QWORD	cbBackingFileSizeMax;


PFNRtlInitUnicodeString*		pfnRtlInitUnicodeString;
PFNNtCreateFile*				pfnNtCreateFile;

BOOL	fUseRelativeOpen;
HMODULE	hmodNtdll;


PFNIfsGetFirstCursor*			pfnIfsGetFirstCursor;
PFNIfsConsumeCursor*			pfnIfsConsumeCursor;
PFNIfsGetNextCursor*			pfnIfsGetNextCursor;
PFNIfsFinishCursor*				pfnIfsFinishCursor;
PFNIfsCreateNewBuffer*			pfnIfsCreateNewBuffer;
PFNIfsCopyBufferToReference*	pfnIfsCopyBufferToReference;
PFNIfsCopyReferenceToBuffer*	pfnIfsCopyReferenceToBuffer;
PFNIfsCloseBuffer*				pfnIfsCloseBuffer;
PFNIfsInitializeProvider*		pfnIfsInitializeProvider;
PFNIfsCloseProvider*			pfnIfsCloseProvider;
PFNIfsCreateFileProv*			pfnIfsCreateFile;
PFNIfsInitializeRoot*			pfnIfsInitializeRoot;
PFNIfsSpaceGrantRoot*			pfnIfsSpaceGrantRoot;
PFNIfsSetEndOfFileRoot*			pfnIfsSetEndOfFileRoot;
PFNIfsSpaceRequestRoot*			pfnIfsSpaceRequestRoot;
PFNIfsQueryEaFile*				pfnIfsQueryEaFile;
PFNIfsTerminateRoot*			pfnIfsTerminateRoot;
PFNIfsSetRootMap*				pfnIfsSetRootMap;
PFNIfsResetRootMap*				pfnIfsResetRootMap;
PFNIfsFlushHandle*				pfnIfsFlushHandle;

HMODULE	hmodIfsProxy;
ERR		errSLVProvider;


#pragma warning( disable: 4307 )

INLINE ULONG_PTR IbOSSLVQwordAlign( const ULONG_PTR ib )
	{
	return (ULONG_PTR)( ( ib + sizeof( QWORD ) - 1 ) & ( ULONG_PTR( ~( LONG_PTR( 0 ) ) ) * sizeof( QWORD ) ) );
	}

#pragma warning( default : 4307 )

INLINE void* PvOSSLVQwordAlign( const void* const pv )
	{
	return (void*) IbOSSLVQwordAlign( ULONG_PTR( pv ) );
	}

#pragma warning( disable: 4307 )

INLINE ULONG_PTR IbOSSLVLongAlign( const ULONG_PTR ib )
	{
	return (ULONG_PTR)( ( ib + sizeof( DWORD ) - 1 ) & ( ULONG_PTR( ~( LONG_PTR( 0 ) ) ) * sizeof( DWORD ) ) );
	}

#pragma warning( default : 4307 )

INLINE void* PvOSSLVLongAlign( const void* const pv )
	{
	return (void*) IbOSSLVLongAlign( ULONG_PTR( pv ) );
	}


//  converts the last Win32 error code into an OSSLVRoot error code for return
//  via the OSSLVRoot API

ERR ErrOSSLVRootIGetLastError( const DWORD error = GetLastError() )
	{
	_TCHAR			szT[64];
	const _TCHAR*	rgszT[1]	= { szT };
	
	switch ( error )
		{
		case NO_ERROR:
		case ERROR_IO_PENDING:
		case EXSTATUS_ROOT_NEEDS_SPACE:
			return JET_errSuccess;

		case ERROR_INVALID_USER_BUFFER:
		case ERROR_NOT_ENOUGH_MEMORY:
		case ERROR_WORKING_SET_QUOTA:
			return ErrERRCheck( JET_errTooManyIO );

		case ERROR_DISK_FULL:
			return ErrERRCheck( JET_errDiskFull );

		case ERROR_HANDLE_EOF:
		case ERROR_VC_DISCONNECTED:
		case ERROR_IO_DEVICE:
			return ErrERRCheck( JET_errDiskIO );

		case ERROR_NO_MORE_FILES:
		case ERROR_FILE_NOT_FOUND:
			return ErrERRCheck( JET_errFileNotFound );
		
		case ERROR_PATH_NOT_FOUND:
			return ErrERRCheck( JET_errInvalidPath );

		case ERROR_ACCESS_DENIED:
		case ERROR_SHARING_VIOLATION:
		case ERROR_LOCK_VIOLATION:
		case ERROR_WRITE_PROTECT:
			return ErrERRCheck( JET_errFileAccessDenied );

		case ERROR_TOO_MANY_OPEN_FILES:
			return ErrERRCheck( JET_errOutOfFileHandles );
			break;

		case ERROR_NO_SYSTEM_RESOURCES:
			return ErrERRCheck( JET_errOutOfMemory );

		//  unexpected error code
		
		default:
			_stprintf( szT, _T( "Unexpected Win32 error:  %dL" ), error );
			AssertSz( fFalse, szT );
			UtilReportEvent( eventError, PERFORMANCE_CATEGORY, PLAIN_TEXT_ID, 1, rgszT );
			return ErrERRCheck( JET_errDiskIO );
		}
	}


//  converts the last Win32 error code into an OSSLVFile error code for return
//  via the OSSLVFile API

ERR ErrOSSLVFileIGetLastError( const DWORD error = GetLastError() )
	{
	_TCHAR			szT[64];
	const _TCHAR*	rgszT[1]	= { szT };
	
	switch ( error )
		{
		case NO_ERROR:
		case ERROR_IO_PENDING:
		case EXSTATUS_ROOT_NEEDS_SPACE:
			return JET_errSuccess;

		case ERROR_INVALID_USER_BUFFER:
		case ERROR_NOT_ENOUGH_MEMORY:
		case ERROR_WORKING_SET_QUOTA:
			return ErrERRCheck( JET_errTooManyIO );

		case ERROR_DISK_FULL:
			return ErrERRCheck( JET_errSLVStreamingFileFull );

		case ERROR_HANDLE_EOF:
		case ERROR_VC_DISCONNECTED:
		case ERROR_IO_DEVICE:
			return ErrERRCheck( JET_errSLVFileIO );

		case ERROR_NO_MORE_FILES:
		case ERROR_FILE_NOT_FOUND:
			return ErrERRCheck( JET_errSLVFileNotFound );
		
		case ERROR_PATH_NOT_FOUND:
			return ErrERRCheck( JET_errSLVFileInvalidPath );

		case ERROR_ACCESS_DENIED:
		case ERROR_SHARING_VIOLATION:
		case ERROR_LOCK_VIOLATION:
		case ERROR_WRITE_PROTECT:
			return ErrERRCheck( JET_errSLVFileAccessDenied );

		case ERROR_TOO_MANY_OPEN_FILES:
			return ErrERRCheck( JET_errOutOfFileHandles );
			break;

		case ERROR_NO_SYSTEM_RESOURCES:
			return ErrERRCheck( JET_errOutOfMemory );

		case ERROR_INVALID_EA_NAME:
		case ERROR_EA_LIST_INCONSISTENT:
		case ERROR_EAS_DIDNT_FIT:
		case ERROR_EA_FILE_CORRUPT:
		case ERROR_EA_TABLE_FULL:
		case ERROR_INVALID_EA_HANDLE:
		case ERROR_EAS_NOT_SUPPORTED:
		case ERROR_EA_ACCESS_DENIED:
			return ErrERRCheck( JET_errSLVEAListCorrupt );

		case ERROR_MORE_DATA:
			return ErrERRCheck( JET_errSLVBufferTooSmall );

		//  unexpected error code
		
		default:
			_stprintf( szT, _T( "Unexpected Win32 error:  %dL" ), error );
			AssertSz( fFalse, szT );
			UtilReportEvent( eventError, PERFORMANCE_CATEGORY, PLAIN_TEXT_ID, 1, rgszT );
			return ErrERRCheck( JET_errSLVFileUnknown );
		}
	}


//  converts the last NT API status code into an OSSLVRoot error code for return
//  via the OSSLVRoot API

ERR ErrOSSLVRootINTStatus( NTSTATUS ntstatus )
	{
	_TCHAR			szT[64];
	const _TCHAR*	rgszT[1]	= { szT };
		
	switch ( ntstatus )
		{
		case STATUS_SUCCESS:
		case STATUS_PENDING:
		case EXSTATUS_ROOT_NEEDS_SPACE:
			return JET_errSuccess;

		case STATUS_INVALID_USER_BUFFER:
		case STATUS_NO_MEMORY:
		case STATUS_WORKING_SET_QUOTA:
			return ErrERRCheck( JET_errTooManyIO );

		case STATUS_DISK_FULL:
			return ErrERRCheck( JET_errDiskFull );

		case STATUS_END_OF_FILE:
		case STATUS_VIRTUAL_CIRCUIT_CLOSED:
		case STATUS_IO_DEVICE_ERROR:
			return ErrERRCheck( JET_errDiskIO );

		case STATUS_NO_MORE_FILES:
		case STATUS_NO_SUCH_FILE:
		case EXSTATUS_NO_SUCH_FILE:
			return ErrERRCheck( JET_errFileNotFound );
		
		case STATUS_ACCESS_DENIED:
		case STATUS_SHARING_VIOLATION:
		case STATUS_MEDIA_WRITE_PROTECTED:
			return ErrERRCheck( JET_errFileAccessDenied );

		case STATUS_TOO_MANY_OPENED_FILES:
			return ErrERRCheck( JET_errOutOfFileHandles );
			break;

		case STATUS_INSUFFICIENT_RESOURCES:
			return ErrERRCheck( JET_errOutOfMemory );

		case EXSTATUS_ROOT_ABANDONED:
			return ErrERRCheck( JET_errSLVRootStillOpen );

		case STATUS_OBJECT_PATH_NOT_FOUND:
			return ErrERRCheck( JET_errSLVProviderNotLoaded );

		case STATUS_OBJECT_NAME_INVALID:
		case STATUS_OBJECT_PATH_INVALID:
		case STATUS_OBJECT_PATH_SYNTAX_BAD:
			return ErrERRCheck( JET_errSLVRootPathInvalid );

		//  unexpected error code
		
		default:
			_stprintf( szT, _T( "Unexpected NT API error:  0x%08X" ), ntstatus );
			AssertSz( fFalse, szT );
			UtilReportEvent( eventError, PERFORMANCE_CATEGORY, PLAIN_TEXT_ID, 1, rgszT );
			return ErrERRCheck( JET_errDiskIO );
		}
	}

//  converts the last NT API status code into an OSSLVFile error code for return
//  via the OSSLVFile API

ERR ErrOSSLVFileINTStatus( NTSTATUS ntstatus )
	{
	_TCHAR			szT[64];
	const _TCHAR*	rgszT[1]	= { szT };
		
	switch ( ntstatus )
		{
		case STATUS_SUCCESS:
		case STATUS_PENDING:
		case EXSTATUS_ROOT_NEEDS_SPACE:
			return JET_errSuccess;

		case STATUS_INVALID_USER_BUFFER:
		case STATUS_NO_MEMORY:
		case STATUS_WORKING_SET_QUOTA:
			return ErrERRCheck( JET_errTooManyIO );

		case STATUS_DISK_FULL:
			return ErrERRCheck( JET_errSLVStreamingFileFull );

		case STATUS_END_OF_FILE:
		case STATUS_VIRTUAL_CIRCUIT_CLOSED:
		case STATUS_IO_DEVICE_ERROR:
			return ErrERRCheck( JET_errSLVFileIO );

		case STATUS_NO_MORE_FILES:
		case STATUS_NO_SUCH_FILE:
		case EXSTATUS_NO_SUCH_FILE:
		case STATUS_OBJECT_NAME_NOT_FOUND:
			return ErrERRCheck( JET_errSLVFileNotFound );
		
		case STATUS_ACCESS_DENIED:
		case STATUS_SHARING_VIOLATION:
		case STATUS_MEDIA_WRITE_PROTECTED:
			return ErrERRCheck( JET_errSLVFileAccessDenied );

		case STATUS_TOO_MANY_OPENED_FILES:
			return ErrERRCheck( JET_errOutOfFileHandles );
			break;

		case STATUS_INSUFFICIENT_RESOURCES:
			return ErrERRCheck( JET_errOutOfMemory );

		case STATUS_OBJECT_PATH_NOT_FOUND:
			return ErrERRCheck( JET_errSLVProviderNotLoaded );

		case STATUS_OBJECT_NAME_INVALID:
		case STATUS_OBJECT_PATH_INVALID:
		case STATUS_OBJECT_PATH_SYNTAX_BAD:
			return ErrERRCheck( JET_errSLVRootPathInvalid );

		case STATUS_INVALID_EA_NAME:
		case STATUS_EA_LIST_INCONSISTENT:
		case STATUS_INVALID_EA_FLAG:
		case STATUS_EAS_NOT_SUPPORTED:
		case STATUS_EA_TOO_LARGE:
		case STATUS_NONEXISTENT_EA_ENTRY:
		case STATUS_NO_EAS_ON_FILE:
		case STATUS_EA_CORRUPT_ERROR:
		case EXSTATUS_SPACE_UNCOMMITTED:
		case EXSTATUS_INVALID_CHECKSUM:
		case EXSTATUS_OPEN_DEADLINE_EXPIRED:
			return ErrERRCheck( JET_errSLVEAListCorrupt );

		case EXSTATUS_FILE_DOUBLE_COMMIT:
			return ErrERRCheck( JET_errSLVEAListCorrupt );
			
		case EXSTATUS_INSTANCE_ID_MISMATCH:
			return ErrERRCheck( JET_errSLVEAListCorrupt );

		case EXSTATUS_STALE_HANDLE:
			return ErrERRCheck( JET_errSLVFileStale );
		
		//  unexpected error code
		
		default:
			_stprintf( szT, _T( "Unexpected NT API error:  0x%08X" ), ntstatus );
			AssertSz( fFalse, szT );
			UtilReportEvent( eventError, PERFORMANCE_CATEGORY, PLAIN_TEXT_ID, 1, rgszT );
			return ErrERRCheck( JET_errSLVFileUnknown );
		}
	}


//  SLV File Table

long cOSSLVFileTableInsert;
PM_CEF_PROC LOSSLVFileTableInsertsCEFLPv;
long LOSSLVFileTableInsertsCEFLPv( long iInstance, void* pvBuf )
	{	
	if ( pvBuf )
		{		
		*( (unsigned long*) pvBuf ) = cOSSLVFileTableInsert;
		}
	return 0;
	}

long cOSSLVFileTableDelete;
PM_CEF_PROC LOSSLVFileTableDeletesCEFLPv;
long LOSSLVFileTableDeletesCEFLPv( long iInstance, void* pvBuf )
	{	
	if ( pvBuf )
		{		
		*( (unsigned long*) pvBuf ) = cOSSLVFileTableDelete;
		}
	return 0;
	}

long cOSSLVFileTableClean;
PM_CEF_PROC LOSSLVFileTableCleansCEFLPv;
long LOSSLVFileTableCleansCEFLPv( long iInstance, void* pvBuf )
	{	
	if ( pvBuf )
		{		
		*( (unsigned long*) pvBuf ) = cOSSLVFileTableClean;
		}
	return 0;
	}

PM_CEF_PROC LOSSLVFileTableEntriesCEFLPv;
long LOSSLVFileTableEntriesCEFLPv( long iInstance, void* pvBuf )
	{	
	if ( pvBuf )
		{		
		*( (unsigned long*) pvBuf ) = cOSSLVFileTableInsert - cOSSLVFileTableDelete;
		}
	return 0;
	}

inline CSLVFileTable::CEntryTable::NativeCounter HashFileid( const CSLVInfo::FILEID& fileid ) 
	{
	return CSLVFileTable::CEntryTable::NativeCounter( fileid / SLVPAGE_SIZE );
	}

inline CSLVFileTable::CEntryTable::NativeCounter CSLVFileTable::CEntryTable::CKeyEntry::Hash( const CSLVInfo::FILEID& fileid )
	{
	return HashFileid( fileid );
	}

inline CSLVFileTable::CEntryTable::NativeCounter CSLVFileTable::CEntryTable::CKeyEntry::Hash() const
	{
	return HashFileid( m_entry.m_fileid );
	}

inline BOOL CSLVFileTable::CEntryTable::CKeyEntry::FEntryMatchesKey( const CSLVInfo::FILEID& fileid ) const
	{
	return fileid == m_entry.m_fileid;
	}

inline void CSLVFileTable::CEntryTable::CKeyEntry::SetEntry( const CSLVFileTable::CEntry& entry )
	{
	m_entry = entry;
	}

inline void CSLVFileTable::CEntryTable::CKeyEntry::GetEntry( CSLVFileTable::CEntry* const pentry ) const
	{
	*pentry = m_entry;
	}

ERR CSLVFileTable::ErrInit( P_SLVROOT pslvroot )
	{
	ERR err = JET_errSuccess;

	//  save the _SLVROOT for use by cleanup

	m_pslvroot = pslvroot;

	//  initialize cleanup variables

	m_cDeferredCleanup	= 0;
	m_semCleanup.Release();
	m_fileidNextCleanup	= 0;

	//  reset our stats

	m_cbReserved	= 0;
	m_cbDeleted		= 0;
	m_centryInsert	= 0;
	m_centryDelete	= 0;
	m_centryClean	= 0;

	//  initialize the entry table

	if ( m_et.ErrInit( 2.0, 1.0 ) != CEntryTable::errSuccess )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  init successful

	m_fInit = fTrue;

	return JET_errSuccess;

HandleError:
	Term();
	return err;
	}
	
void CSLVFileTable::Term()
	{
	//  free all memory pointed to by entries in the entry table
	
	if ( m_fInit )
		{
		CEntryTable::CLock	lockET;
		CEntryTable::ERR	errET;

		m_et.BeginHashScan( &lockET );

		while ( ( errET = m_et.ErrMoveNext( &lockET ) ) == CEntryTable::errSuccess )
			{
			CEntry entry;
			errET = m_et.ErrRetrieveEntry( &lockET, &entry );

			if ( entry.m_pextentry )
				{
				while ( !entry.m_pextentry->m_ilRunReserved.FEmpty() )
					{
					CExtendedEntry::CRun* prun = entry.m_pextentry->m_ilRunReserved.PrevMost();
					entry.m_pextentry->m_ilRunReserved.Remove( prun );
					delete prun;
					}
				while ( !entry.m_pextentry->m_ilRunDeleted.FEmpty() )
					{
					CExtendedEntry::CRun* prun = entry.m_pextentry->m_ilRunDeleted.PrevMost();
					entry.m_pextentry->m_ilRunDeleted.Remove( prun );
					delete prun;
					}
				delete entry.m_pextentry->m_wszFileName;
				delete entry.m_pextentry;
				}
				
			AtomicIncrement( (long*)&cOSSLVFileTableDelete );
			AtomicIncrement( (long*)&m_centryDelete );
			}
		Assert( errET == CEntryTable::errNoCurrentEntry );

		m_et.EndHashScan( &lockET );
		}
	
	//  terminate the entry table

	m_et.Term();

	//  term successful

	m_fInit = fFalse;
	}
	
ERR CSLVFileTable::ErrCreate( CSLVInfo* const pslvinfo )
	{
	ERR					err			= JET_errSuccess;
	CEntry				entry;
	CExtendedEntry*		pextentry	= NULL;
	CEntryTable::CLock	lockET;
	CEntryTable::ERR	errET;
	BOOL				fLocked		= fFalse;
	BOOL				fInserted	= fFalse;
	
	//  create a new entry and extended entry for this SLV File

	if ( !( pextentry = new CExtendedEntry ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  initialize the entry with the SLV File's FILEID and an extended entry
	
	Call( pslvinfo->ErrGetFileID( &entry.m_fileid ) );
	entry.m_pextentry = pextentry;

	//  store the SLV File's current file name in the extended entry

	Call( pslvinfo->ErrGetFileNameLength( &pextentry->m_cwchFileName ) );
	if ( !( pextentry->m_wszFileName = new wchar_t[ pextentry->m_cwchFileName + 1 ] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	Call( pslvinfo->ErrGetFileName( pextentry->m_wszFileName ) );

	//  store all the reserved space owned by this SLV File in the extended entry

	CallS( pslvinfo->ErrMoveBeforeFirst() );
	while ( ( err = pslvinfo->ErrMoveNext() ) >= JET_errSuccess )
		{
		CSLVInfo::RUN run;
		Call( pslvinfo->ErrGetCurrentRun( &run ) );

		CExtendedEntry::CRun* prun;
		if ( !( prun = new CExtendedEntry::CRun ) )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
			
		prun->m_ibLogical	= run.ibLogical;
		prun->m_cbSize		= run.cbSize;
		
		pextentry->m_ilRunReserved.InsertAsNextMost( prun );
		AtomicAdd( &m_cbReserved, prun->m_cbSize );
		}
	if ( err == JET_errNoCurrentRecord )
		{
		err = JET_errSuccess;
		}
	Call( err );

	//  store the allocation size for this SLV File in the extended entry

	Call( pslvinfo->ErrGetFileAlloc( &pextentry->m_cbAlloc ) );
	Call( pslvinfo->ErrGetFileAlloc( &pextentry->m_cbSpace ) );

	//  insert the new entry in the table
	
	m_et.WriteLockKey( entry.m_fileid, &lockET );
	fLocked = fTrue;
	if ( ( errET = m_et.ErrInsertEntry( &lockET, entry ) ) != CEntryTable::errSuccess )
		{
		Assert(	errET == CEntryTable::errOutOfMemory ||
				errET == CEntryTable::errKeyDuplicate );

		if ( errET == CEntryTable::errOutOfMemory )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		else
			{
			Call( ErrERRCheck( JET_errSLVSpaceCorrupted ) );
			}
		}
	fInserted = fTrue;
	AtomicIncrement( (long*)&cOSSLVFileTableInsert );
	AtomicIncrement( (long*)&m_centryInsert );
	m_et.WriteUnlockKey( &lockET );
	fLocked = fFalse;

	//  if we inserted an entry into the table then perform some cleanup

	if ( fInserted )
		{
		_PerformAmortizedCleanup();
		fInserted = fFalse;
		}

	return JET_errSuccess;

HandleError:
	if ( fLocked )
		{
		m_et.WriteUnlockKey( &lockET );
		}
	if ( pextentry )
		{
		while ( !pextentry->m_ilRunReserved.FEmpty() )
			{
			CExtendedEntry::CRun* prun = pextentry->m_ilRunReserved.PrevMost();
			pextentry->m_ilRunReserved.Remove( prun );
			AtomicAdd( &m_cbReserved, -prun->m_cbSize );
			delete prun;
			}
		delete pextentry->m_wszFileName;
		delete pextentry;
		}
	if ( fInserted )
		{
		_PerformAmortizedCleanup();
		}
	return err;
	}

ERR CSLVFileTable::ErrOpen(	CSLVInfo* const	pslvinfo,
							const BOOL		fSetExpiration,
							size_t* const	pcwchFileName,
							wchar_t* const	wszFileName,
							TICK* const		ptickExpiration )
	{
	ERR		err			= JET_errSuccess;
	TICK	cmsecTTL	= cmsecOSSLVTTL;

	//  retry the open with ever increasing open deadlines until we succeed in
	//  opening the file with enough time to spare.  this is to allow the
	//  common case to be fast while handling the pathological case where the
	//  server load is so high that we occasionally get huge delays when
	//  performing amortized cleanup of the table
	
	do
		{
		Call( _ErrOpen(	pslvinfo,
						fSetExpiration,
						cmsecTTL,
						pcwchFileName,
						wszFileName,
						ptickExpiration ) );

		cmsecTTL = min( cmsecTTL * 2, cmsecOSSLVTTLInfinite );
		}
	while ( TickCmp( TickOSTimeCurrent() + cmsecOSSLVTTL / 2, *ptickExpiration ) > 0 );

HandleError:
	return err;
	}
	
ERR CSLVFileTable::_ErrOpen(	CSLVInfo* const	pslvinfo,
								const BOOL		fSetExpiration,
								const TICK		cmsecTTL,
								size_t* const	pcwchFileName,
								wchar_t* const	wszFileName,
								TICK* const		ptickExpiration )
	{
	ERR					err			= JET_errSuccess;
	CEntry				entry;
	CEntryTable::CLock	lockET;
	CEntryTable::ERR	errET;
	BOOL				fLocked		= fFalse;
	BOOL				fInserted	= fFalse;
	
	//  fetch the entry for this SLV File from the table if it exists.  if
	//  it doesn't exist, the entry will start out initialized to have the
	//  correct FILEID and no other attributes

	Call( pslvinfo->ErrGetFileID( &entry.m_fileid ) );
	entry.m_tickExpiration	= TickOSTimeCurrent() + cmsecOSSLVTTLInfinite;  //  expires far in the future
	entry.m_pextentry		= NULL;

	m_et.WriteLockKey( entry.m_fileid, &lockET );
	fLocked = fTrue;
	(void)m_et.ErrRetrieveEntry( &lockET, &entry );

	//  this SLV File's contents was moved

	if ( entry.m_pextentry && entry.m_pextentry->m_fDependent )
		{
		//  remember the source contents pointer from this entry

		const CSLVInfo::FILEID	fileidSource		= entry.m_pextentry->m_fileidSource;
		const QWORD				idContentsSource	= entry.m_pextentry->m_idContentsSource;

		//  fetch the source's entry

		m_et.WriteUnlockKey( &lockET );
		fLocked = fFalse;

		m_et.WriteLockKey( fileidSource, &lockET );
		fLocked = fTrue;
		errET = m_et.ErrRetrieveEntry( &lockET, &entry );
		Assert(	errET == CEntryTable::errSuccess ||
				errET == CEntryTable::errEntryNotFound );

		//  the source's entry doesn't exist or doesn't have a matching idContents

		if (	errET != CEntryTable::errSuccess ||
				!entry.m_pextentry ||
				entry.m_pextentry->m_idContents != idContentsSource )
			{
			//  the source has been closed so we can safely use the entry for
			//  this SLV File.  re-fetch the entry for this SLV File as before
			
			m_et.WriteUnlockKey( &lockET );
			fLocked = fFalse;

			Call( pslvinfo->ErrGetFileID( &entry.m_fileid ) );
			entry.m_tickExpiration	= TickOSTimeCurrent() + cmsecOSSLVTTLInfinite;  //  expires far in the future
			entry.m_pextentry		= NULL;

			m_et.WriteLockKey( entry.m_fileid, &lockET );
			fLocked = fTrue;
			(void)m_et.ErrRetrieveEntry( &lockET, &entry );
			}
		}

	//  we were asked to set a new expiration time

	if ( fSetExpiration )
		{
		//  set the new expiration time for the entry if requested

		entry.m_tickExpiration	= TickOSTimeCurrent() + cmsecTTL;

		//  try to update the entry in the entry table

		if ( ( errET = m_et.ErrReplaceEntry( &lockET, entry ) ) != CEntryTable::errSuccess )
			{
			Assert( errET == CEntryTable::errNoCurrentEntry );

			//  the entry does not yet exist, so try to insert it in the entry table

			if ( ( errET = m_et.ErrInsertEntry( &lockET, entry ) ) != CEntryTable::errSuccess )
				{
				Assert( errET == CEntryTable::errOutOfMemory );
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			fInserted = fTrue;
			AtomicIncrement( (long*)&cOSSLVFileTableInsert );
			AtomicIncrement( (long*)&m_centryInsert );
			}
		}

	//  we were asked to not set a new expiration time

	else
		{
		//  set a time far in the future

		entry.m_tickExpiration	= TickOSTimeCurrent() + cmsecOSSLVTTLInfinite;
		}

	//  copy the requested information into the user's buffers

	if ( entry.m_pextentry )
		{
		if ( *pcwchFileName < entry.m_pextentry->m_cwchFileName + 1 )
			{
			Call( ErrERRCheck( JET_errSLVBufferTooSmall ) );
			}
		*pcwchFileName		= entry.m_pextentry->m_cwchFileName;
		wcscpy( wszFileName, entry.m_pextentry->m_wszFileName );
		*ptickExpiration	= entry.m_tickExpiration;
		}
	else
		{
		size_t cwchFileName = *pcwchFileName;
		Call( pslvinfo->ErrGetFileNameLength( pcwchFileName ) );
		if ( cwchFileName < *pcwchFileName )
			{
			Call( ErrERRCheck( JET_errSLVBufferTooSmall ) );
			}
		Call( pslvinfo->ErrGetFileName( wszFileName ) );
		*ptickExpiration = entry.m_tickExpiration;
		}

	m_et.WriteUnlockKey( &lockET );
	fLocked = fFalse;

	//  if we inserted an entry in the table then perform some cleanup

	if ( fInserted )
		{
		_PerformAmortizedCleanup();
		fInserted = fFalse;
		}

	return JET_errSuccess;

HandleError:
	if ( fLocked )
		{
		m_et.WriteUnlockKey( &lockET );
		}
	if ( fInserted )
		{
		_PerformAmortizedCleanup();
		}
	return err;
	}
	
ERR CSLVFileTable::ErrCopy(	CSLVInfo* const	pslvinfoSrc,
							CSLVInfo* const	pslvinfoDest,
							const QWORD		idContents )
	{
	//  we don't need to do anything here right now
	
	return JET_errSuccess;
	}
	
ERR CSLVFileTable::ErrMove(	CSLVInfo* const	pslvinfoSrc,
							CSLVInfo* const	pslvinfoDest,
							const QWORD		idContents )
	{
	ERR					err					= JET_errSuccess;
	CEntry				entry;
	CExtendedEntry*		pextentrySrc		= NULL;
	CExtendedEntry*		pextentryDest		= NULL;
	CEntryTable::CLock	lockET;
	CEntryTable::ERR	errET;
	BOOL				fLocked				= fFalse;
	BOOL				fInserted			= fFalse;
	BOOL				fSyncFree			= fFalse;
	
	//  fetch the entry for the source SLV File from the table if it exists.
	//  if it doesn't exist, the entry will start out initialized to have the
	//  correct FILEID, file name, and no other attributes

	if ( !( pextentrySrc = new CExtendedEntry ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	Call( pslvinfoSrc->ErrGetFileID( &entry.m_fileid ) );
	entry.m_pextentry = pextentrySrc;

	Call( pslvinfoSrc->ErrGetFileNameLength( &pextentrySrc->m_cwchFileName ) );
	if ( !( pextentrySrc->m_wszFileName = new wchar_t[ pextentrySrc->m_cwchFileName + 1 ] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	Call( pslvinfoSrc->ErrGetFileName( pextentrySrc->m_wszFileName ) );

	m_et.WriteLockKey( entry.m_fileid, &lockET );
	fLocked = fTrue;
	(void)m_et.ErrRetrieveEntry( &lockET, &entry );

	if ( !entry.m_pextentry )
		{
		entry.m_pextentry = pextentrySrc;
		}

	//  this SLV File's contents was moved

	if ( entry.m_pextentry && entry.m_pextentry->m_fDependent )
		{
		//  remember the source contents pointer from this entry

		const CSLVInfo::FILEID	fileidSource		= entry.m_pextentry->m_fileidSource;
		const QWORD				idContentsSource	= entry.m_pextentry->m_idContentsSource;

		//  fetch the source's entry

		m_et.WriteUnlockKey( &lockET );
		fLocked = fFalse;

		m_et.WriteLockKey( fileidSource, &lockET );
		fLocked = fTrue;
		errET = m_et.ErrRetrieveEntry( &lockET, &entry );
		Assert(	errET == CEntryTable::errSuccess ||
				errET == CEntryTable::errEntryNotFound );

		//  the source's entry doesn't exist or doesn't have a matching idContents

		if (	errET != CEntryTable::errSuccess ||
				!entry.m_pextentry ||
				entry.m_pextentry->m_idContents != idContentsSource )
			{
			//  the source has been closed so we can safely use the entry for
			//  this SLV File.  re-fetch the entry for this SLV File as before
			
			m_et.WriteUnlockKey( &lockET );
			fLocked = fFalse;

			Call( pslvinfoSrc->ErrGetFileID( &entry.m_fileid ) );
			entry.m_pextentry = pextentrySrc;

			Call( pslvinfoSrc->ErrGetFileNameLength( &pextentrySrc->m_cwchFileName ) );
			if ( !( pextentrySrc->m_wszFileName = new wchar_t[ pextentrySrc->m_cwchFileName + 1 ] ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			Call( pslvinfoSrc->ErrGetFileName( pextentrySrc->m_wszFileName ) );

			m_et.WriteLockKey( entry.m_fileid, &lockET );
			fLocked = fTrue;
			(void)m_et.ErrRetrieveEntry( &lockET, &entry );

			if ( !entry.m_pextentry )
				{
				entry.m_pextentry = pextentrySrc;
				}
			}
		}
		
	//  flag the source SLV File with the specified contents ID so that the
	//  contents of this file can be looked up in the SLV File Table.  only flag
	//  an SLV File that doesn't already have a contents ID so that if the same
	//  contents are moved more than once, we don't break any entry's contents
	//  source pointer
	//
	//  NOTE:  we will use the extended entry pointer in the entry which is not
	//  necessarily the extended entry we allocated

	if ( entry.m_pextentry->m_idContents == CSLVInfo::fileidNil )
		{
		entry.m_pextentry->m_idContents = idContents;
		}

	//  build an extended entry for the destination SLV File and link it into
	//  the source SLV File as a dependent.  this will enable the source SLV
	//  File to notify the destination SLV File when it has been removed
	//
	//  NOTE:  we will use the contents ID in the extended entry which is not
	//  necessarily the contents ID specified for this move (see above)

	if ( !( pextentryDest = new CExtendedEntry ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	Call( pslvinfoDest->ErrGetFileNameLength( &pextentryDest->m_cwchFileName ) );
	if ( !( pextentryDest->m_wszFileName = new wchar_t[ pextentryDest->m_cwchFileName + 1 ] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	Call( pslvinfoDest->ErrGetFileName( pextentryDest->m_wszFileName ) );

	AtomicExchange( (long*)&pextentryDest->m_fDependent, long( fTrue ) );
	entry.m_pextentry->m_ilDependents.InsertAsNextMost( pextentryDest );

	pextentryDest->m_fileidSource		= entry.m_fileid;
	pextentryDest->m_idContentsSource	= entry.m_pextentry->m_idContents;

	//  try to update the entry in the entry table

	if ( ( errET = m_et.ErrReplaceEntry( &lockET, entry ) ) != CEntryTable::errSuccess )
		{
		Assert( errET == CEntryTable::errNoCurrentEntry );

		//  the entry does not yet exist, so try to insert it in the entry table

		if ( ( errET = m_et.ErrInsertEntry( &lockET, entry ) ) != CEntryTable::errSuccess )
			{
			Assert( errET == CEntryTable::errOutOfMemory );
			entry.m_pextentry->m_ilDependents.Remove( pextentryDest );
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		fInserted = fTrue;
		AtomicIncrement( (long*)&cOSSLVFileTableInsert );
		AtomicIncrement( (long*)&m_centryInsert );
		}

	m_et.WriteUnlockKey( &lockET );
	fLocked = fFalse;
	fSyncFree = fTrue;

	//  if we didn't use the allocated extended entry then free it

	if ( pextentrySrc != entry.m_pextentry )
		{
		Assert( pextentrySrc->m_ilDependents.FEmpty() );
		delete pextentrySrc->m_wszFileName;
		delete pextentrySrc;
		}
	pextentrySrc = NULL;

	//  if we inserted an entry in the table then perform some cleanup

	if ( fInserted )
		{
		_PerformAmortizedCleanup();
		fInserted = fFalse;
		}

	//  create a new entry and extended entry for the dest SLV File.  we should
	//  never see an existing entry because the space would have to be deleted
	//  and cleaned up before an attempt can be made to move a file here.  this
	//  will happen even if the same move is reattempted after a failure.
	//  initialize the entry with the extended entry we created above
	
	Call( pslvinfoDest->ErrGetFileID( &entry.m_fileid ) );
	entry.m_pextentry = pextentryDest;

	//  insert the new entry in the table
	
	m_et.WriteLockKey( entry.m_fileid, &lockET );
	fLocked = fTrue;
	if ( ( errET = m_et.ErrInsertEntry( &lockET, entry ) ) != CEntryTable::errSuccess )
		{
		Assert(	errET == CEntryTable::errOutOfMemory ||
				errET == CEntryTable::errKeyDuplicate );

		if ( errET == CEntryTable::errOutOfMemory )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		else
			{
			Call( ErrERRCheck( JET_errSLVSpaceCorrupted ) );
			}
		}
	fInserted = fTrue;
	AtomicIncrement( (long*)&cOSSLVFileTableInsert );
	AtomicIncrement( (long*)&m_centryInsert );
	m_et.WriteUnlockKey( &lockET );
	fLocked = fFalse;
	pextentryDest = NULL;

	//  if we inserted an entry into the table then perform some cleanup

	if ( fInserted )
		{
		_PerformAmortizedCleanup();
		fInserted = fFalse;
		}

	return JET_errSuccess;

HandleError:
	if ( fLocked )
		{
		m_et.WriteUnlockKey( &lockET );
		}
	if ( pextentrySrc )
		{
		delete pextentrySrc->m_wszFileName;
		delete pextentrySrc;
		}
	if (	pextentryDest &&
			(	!fSyncFree ||
				!BOOL( AtomicExchange( (long*)&pextentryDest->m_fDependent, long( fFalse ) ) ) ) )
		{
		delete pextentryDest->m_wszFileName;
		delete pextentryDest;
		}
	if ( fInserted )
		{
		_PerformAmortizedCleanup();
		}
	return err;
	}

ERR CSLVFileTable::ErrCommitSpace( CSLVInfo* const pslvinfo )
	{
	ERR					err			= JET_errSuccess;
	CEntry				entry;
	CEntryTable::CLock	lockET;
	CEntryTable::ERR	errET;
	BOOL				fLocked		= fFalse;
	BOOL				fUpdate		= fFalse;
	QWORD				cbCommit	= 0;
	
	//  fetch the entry for this SLV File from the table

	Call( pslvinfo->ErrGetFileID( &entry.m_fileid ) );

	m_et.WriteLockKey( entry.m_fileid, &lockET );
	fLocked = fTrue;
	if ( ( errET = m_et.ErrRetrieveEntry( &lockET, &entry ) ) != CEntryTable::errSuccess )
		{
		Assert( errET == CEntryTable::errEntryNotFound );
		Call( ErrERRCheck( JET_errSLVSpaceCorrupted ) );
		}

	//  remove all the (partial) space owned by this SLV File from the reserved
	//  space in the extended entry

	CallS( pslvinfo->ErrMoveBeforeFirst() );
	while ( ( err = pslvinfo->ErrMoveNext() ) >= JET_errSuccess )
		{
		CSLVInfo::RUN run;
		Call( pslvinfo->ErrGetCurrentRun( &run ) );

		CExtendedEntry::CRun* prun = entry.m_pextentry->m_ilRunReserved.PrevMost();
		while ( prun )
			{
			CExtendedEntry::CRun* prunNext = entry.m_pextentry->m_ilRunReserved.Next( prun );
			
			if ( prun->m_ibLogical == run.ibLogical )
				{
				prun->m_ibLogical	+= run.cbSize;
				prun->m_cbSize		-= run.cbSize;

				cbCommit += run.cbSize;
				run.cbSize = 0;
				fUpdate = fTrue;
				}
			else if ( prun->m_ibLogical + prun->m_cbSize == run.ibLogical + run.cbSize )
				{
				prun->m_cbSize		-= run.cbSize;

				cbCommit += run.cbSize;
				run.cbSize = 0;
				fUpdate = fTrue;
				}

			if ( !prun->m_cbSize )
				{
				entry.m_pextentry->m_ilRunReserved.Remove( prun );
				delete prun;
				fUpdate = fTrue;
				}

			prun = prunNext;
			}

		if ( run.cbSize )
			{
			Call( ErrERRCheck( JET_errSLVSpaceCorrupted ) );
			}
		}
	if ( err == JET_errNoCurrentRecord )
		{
		err = JET_errSuccess;
		}
	Call( err );

	if ( fUpdate )
		{
		entry.m_pextentry->m_cbSpace -= cbCommit;
		errET = m_et.ErrReplaceEntry( &lockET, entry );
		Assert( errET == CEntryTable::errSuccess );
		if ( errET == CEntryTable::errSuccess )
			{
			AtomicAdd( &m_cbReserved, -cbCommit );
			}
		fUpdate = fFalse;
		}

	m_et.WriteUnlockKey( &lockET );
	fLocked = fFalse;

	return JET_errSuccess;

HandleError:
	if ( fUpdate )
		{
		entry.m_pextentry->m_cbSpace -= cbCommit;
		errET = m_et.ErrReplaceEntry( &lockET, entry );
		Assert( errET == CEntryTable::errSuccess );
		if ( errET == CEntryTable::errSuccess )
			{
			AtomicAdd( &m_cbReserved, -cbCommit );
			}
		}
	if ( fLocked )
		{
		m_et.WriteUnlockKey( &lockET );
		}
	return err;
	}
	
ERR CSLVFileTable::ErrDeleteSpace( CSLVInfo* const pslvinfo )
	{
	ERR						err			= JET_errSuccess;
	CEntry					entry;
	CExtendedEntry*			pextentry	= NULL;
	CEntryTable::CLock		lockET;
	CEntryTable::ERR		errET;
	BOOL					fLocked		= fFalse;
	BOOL					fInserted	= fFalse;
	CExtendedEntry::CRun*	prunPrev	= NULL;
	
	//  fetch the entry for this SLV File from the table if it exists.  if
	//  it doesn't exist, the entry will start out initialized to have the
	//  correct FILEID, allocation size, file name, and no other attributes

	if ( !( pextentry = new CExtendedEntry ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	Call( pslvinfo->ErrGetFileID( &entry.m_fileid ) );
	entry.m_pextentry = pextentry;

	Call( pslvinfo->ErrGetFileAlloc( &pextentry->m_cbAlloc ) );

	Call( pslvinfo->ErrGetFileNameLength( &pextentry->m_cwchFileName ) );
	if ( !( pextentry->m_wszFileName = new wchar_t[ pextentry->m_cwchFileName + 1 ] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	Call( pslvinfo->ErrGetFileName( pextentry->m_wszFileName ) );

	m_et.WriteLockKey( entry.m_fileid, &lockET );
	fLocked = fTrue;
	(void)m_et.ErrRetrieveEntry( &lockET, &entry );

	if ( !entry.m_pextentry )
		{
		entry.m_pextentry = pextentry;
		}

	//  add the (partial) space owned by this SLV File to the deleted space in
	//  the extended entry
	//
	//  NOTE:  we will use the extended entry pointer in the entry which is not
	//  necessarily the extended entry we allocated

	prunPrev = entry.m_pextentry->m_ilRunDeleted.NextMost();

	CallS( pslvinfo->ErrMoveBeforeFirst() );
	while ( ( err = pslvinfo->ErrMoveNext() ) >= JET_errSuccess )
		{
		CSLVInfo::RUN run;
		Call( pslvinfo->ErrGetCurrentRun( &run ) );

		CExtendedEntry::CRun* prun;
		if ( !( prun = new CExtendedEntry::CRun ) )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
			
		prun->m_ibLogical	= run.ibLogical;
		prun->m_cbSize		= run.cbSize;
		
		entry.m_pextentry->m_ilRunDeleted.InsertAsNextMost( prun );
		AtomicAdd( &m_cbDeleted, prun->m_cbSize );
		entry.m_pextentry->m_cbSpace += prun->m_cbSize;
		}
	if ( err == JET_errNoCurrentRecord )
		{
		err = JET_errSuccess;
		}
	Call( err );

	//  try to update the entry in the entry table

	if ( ( errET = m_et.ErrReplaceEntry( &lockET, entry ) ) != CEntryTable::errSuccess )
		{
		Assert( errET == CEntryTable::errNoCurrentEntry );

		//  the entry does not yet exist, so try to insert it in the entry table

		if ( ( errET = m_et.ErrInsertEntry( &lockET, entry ) ) != CEntryTable::errSuccess )
			{
			Assert( errET == CEntryTable::errOutOfMemory );
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		fInserted = fTrue;
		AtomicIncrement( (long*)&cOSSLVFileTableInsert );
		AtomicIncrement( (long*)&m_centryInsert );
		}

	m_et.WriteUnlockKey( &lockET );
	fLocked = fFalse;

	//  if we didn't use the allocated extended entry then free it

	if ( pextentry != entry.m_pextentry )
		{
		Assert( pextentry->m_ilRunDeleted.FEmpty() );
		delete pextentry->m_wszFileName;
		delete pextentry;
		}
	pextentry = NULL;

	//  if we inserted an entry in the table then perform some cleanup

	if ( fInserted )
		{
		_PerformAmortizedCleanup();
		fInserted = fFalse;
		}

	return JET_errSuccess;

HandleError:
	if ( prunPrev )
		{
		while ( entry.m_pextentry->m_ilRunDeleted.Next( prunPrev ) )
			{
			CExtendedEntry::CRun* prun = entry.m_pextentry->m_ilRunDeleted.Next( prunPrev );
			entry.m_pextentry->m_ilRunDeleted.Remove( prun );
			AtomicAdd( &m_cbDeleted, -prun->m_cbSize );
			entry.m_pextentry->m_cbSpace -= prun->m_cbSize;
			delete prun;
			}
		}
	if ( fLocked )
		{
		m_et.WriteUnlockKey( &lockET );
		}
	if ( pextentry )
		{
		while ( !pextentry->m_ilRunDeleted.FEmpty() )
			{
			CExtendedEntry::CRun* prun = pextentry->m_ilRunDeleted.PrevMost();
			pextentry->m_ilRunDeleted.Remove( prun );
			AtomicAdd( &m_cbDeleted, -prun->m_cbSize );
			entry.m_pextentry->m_cbSpace -= prun->m_cbSize;
			delete prun;
			}
		delete pextentry->m_wszFileName;
		delete pextentry;
		}
	if ( fInserted )
		{
		_PerformAmortizedCleanup();
		}
	return err;
	}

ERR CSLVFileTable::ErrRename(	CSLVInfo* const	pslvinfo,
								wchar_t* const	wszFileNameDest )
	{
	ERR					err				= JET_errSuccess;
	CEntry				entry;
	CEntryTable::CLock	lockET;
	CEntryTable::ERR	errET;
	BOOL				fLocked			= fFalse;
	size_t				cwchFileName;
	wchar_t*			wszFileName		= NULL;
	
	//  fetch the entry for this SLV File from the table

	Call( pslvinfo->ErrGetFileID( &entry.m_fileid ) );

	m_et.WriteLockKey( entry.m_fileid, &lockET );
	fLocked = fTrue;
	if ( ( errET = m_et.ErrRetrieveEntry( &lockET, &entry ) ) != CEntryTable::errSuccess )
		{
		Assert( errET == CEntryTable::errEntryNotFound );
		Call( ErrERRCheck( JET_errSLVSpaceCorrupted ) );
		}

	//  this SLV File's contents was moved

	if ( entry.m_pextentry && entry.m_pextentry->m_fDependent )
		{
		//  remember the source contents pointer from this entry

		const CSLVInfo::FILEID	fileidSource		= entry.m_pextentry->m_fileidSource;
		const QWORD				idContentsSource	= entry.m_pextentry->m_idContentsSource;

		//  fetch the source's entry

		m_et.WriteUnlockKey( &lockET );
		fLocked = fFalse;

		m_et.WriteLockKey( fileidSource, &lockET );
		fLocked = fTrue;
		errET = m_et.ErrRetrieveEntry( &lockET, &entry );
		Assert(	errET == CEntryTable::errSuccess ||
				errET == CEntryTable::errEntryNotFound );

		//  the source's entry doesn't exist or doesn't have a matching idContents

		if (	errET != CEntryTable::errSuccess ||
				!entry.m_pextentry ||
				entry.m_pextentry->m_idContents != idContentsSource )
			{
			//  the source has been closed so we can safely use the entry for
			//  this SLV File.  re-fetch the entry for this SLV File as before
			
			m_et.WriteUnlockKey( &lockET );
			fLocked = fFalse;

			Call( pslvinfo->ErrGetFileID( &entry.m_fileid ) );

			m_et.WriteLockKey( entry.m_fileid, &lockET );
			fLocked = fTrue;
			if ( ( errET = m_et.ErrRetrieveEntry( &lockET, &entry ) ) != CEntryTable::errSuccess )
				{
				Assert( errET == CEntryTable::errEntryNotFound );
				Call( ErrERRCheck( JET_errSLVSpaceCorrupted ) );
				}
			}
		}

	//  store the SLV File's new file name in the extended entry

	cwchFileName = wcslen( wszFileNameDest );
	if ( !( wszFileName = new wchar_t[ cwchFileName + 1 ] ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	wcscpy( wszFileName, wszFileNameDest );

	delete entry.m_pextentry->m_wszFileName;
	entry.m_pextentry->m_cwchFileName	= cwchFileName;
	entry.m_pextentry->m_wszFileName	= wszFileName;
	wszFileName = NULL;

	m_et.WriteUnlockKey( &lockET );
	fLocked = fFalse;

	return JET_errSuccess;

HandleError:
	if ( fLocked )
		{
		m_et.WriteUnlockKey( &lockET );
		}
	delete[] wszFileName;
	return err;
	}

void CSLVFileTable::_PerformAmortizedCleanup()
	{
	//  increment the deferred cleanup count.  if we are not elected to perform
	//  cleanup, this will cause someone who is to cleanup the table on behalf
	//  of our table insertion

	AtomicExchangeAdd( (long*)&m_cDeferredCleanup, 2 );

	//  we are elected to perform the amortized cleanup

	if ( m_semCleanup.FTryAcquire() )
		{
		//  get the current cleanup count.  this number can be zero or negative
		//  if someone else has already done our cleanup or did more cleanup
		//  than necessary due to the entry distribution in the hash table

		const long cCleanup = m_cDeferredCleanup;

		//  we have some cleanup work to do

		if ( cCleanup > 0 )
			{
			//  perform our share of the amortized table cleanup rounded up to the
			//  next bucket plus one more.  we use this additional entry to set the
			//  starting fileid for our next pass

			CEntryTable::CLock	lockET;
			CEntryTable::ERR	errET;
			
			m_et.BeginHashScanFromKey( m_fileidNextCleanup, &lockET );

			BOOL fFinishedBucket = fFalse;
			for ( DWORD iCleanup = 0; iCleanup <= cCleanup || !fFinishedBucket; iCleanup++ )
				{
				//  get the next entry in the entry table

				BOOL fLeftBucket;
				if ( ( errET = m_et.ErrMoveNext( &lockET, &fLeftBucket ) ) != CEntryTable::errSuccess )
					{
					//  we have hit the end of the entry table
					
					Assert( errET == CEntryTable::errNoCurrentEntry );

					//  restart our scan at the beginning of the entry table
					
					m_et.EndHashScan( &lockET );
					m_et.BeginHashScan( &lockET );

					//  get the first entry in the entry table

					if ( ( errET = m_et.ErrMoveNext( &lockET ) ) != CEntryTable::errSuccess )
						{
						//  the table is empty so we are done

						Assert( errET == CEntryTable::errNoCurrentEntry );

						m_fileidNextCleanup	= 0;
						AtomicExchangeAdd( (long*)&m_cDeferredCleanup, long( cCleanup - iCleanup ) );
						break;
						}

					fLeftBucket = fTrue;
					}
				fFinishedBucket = fFinishedBucket || fLeftBucket && iCleanup > 0;

				//  get the current entry

				CEntry entry;
				errET = m_et.ErrRetrieveEntry( &lockET, &entry );
				Assert( errET == CEntryTable::errSuccess );

				//  we are done cleaning

				if ( iCleanup >= cCleanup && fFinishedBucket )
					{
					//  save this entry's fileid as the starting point for the next
					//  cleanup

					m_fileidNextCleanup = entry.m_fileid;
					}

				//  we are not done cleaning

				else
					{
					//  this entry's expiration has passed (including a safety margin
					//  to avoid race conditions) and we are not dependent on another
					//  entry

					AtomicDecrement( (long*)&m_cDeferredCleanup );
					AtomicIncrement( (long*)&cOSSLVFileTableClean );
					AtomicIncrement( (long*)&m_centryClean );

					if (	TickCmp( entry.m_tickExpiration + cmsecOSSLVTTLSafety, TickOSTimeCurrent() ) < 0 &&
							( !entry.m_pextentry || !entry.m_pextentry->m_fDependent ) )
						{
						//  there is space or a file name stored in this entry

						if (	entry.m_pextentry &&
								(	entry.m_pextentry->m_wszFileName ||
									!entry.m_pextentry->m_ilRunReserved.FEmpty() ||
									!entry.m_pextentry->m_ilRunDeleted.FEmpty() ) )
							{
							//  attempt to open the SLV File if and only if it exists

							WCHAR	Buffer[ IFileSystemAPI::cchPathMax ];
							HANDLE	hFile				= NULL;
							ERR		errOpen				= JET_errSuccess;

							wcscpy( Buffer, m_pslvroot->wszRootName );
							wcscat( Buffer, L"\\" );
							wcscat( Buffer, entry.m_pextentry->m_wszFileName );

							hFile = pfnIfsCreateFile(	Buffer,
														0, 
														0,
														NULL,
														OPEN_EXISTING,
														FILE_ATTRIBUTE_NORMAL,
														NULL,
														0 );
							if ( hFile == INVALID_HANDLE_VALUE )
								{
								errOpen = ErrOSSLVFileIGetLastError();
								}

							//  if we can't find the file and either all or none
							//  of the file's space is present then that means
							//  that no one is using the file and all space in
							//  the file is in a consistent state so we can
							//  therefore cleanup this table entry

							if (	errOpen == JET_errSLVFileNotFound &&
									(	!entry.m_pextentry->m_cbSpace ||
										entry.m_pextentry->m_cbSpace == entry.m_pextentry->m_cbAlloc ) )
								{
								//  free any space owned by this entry

								while (	!entry.m_pextentry->m_ilRunReserved.FEmpty() ||
										!entry.m_pextentry->m_ilRunDeleted.FEmpty() )
									{
									//  get the current space entry.  if the current space
									//  entry contains the first run (which determines the
									//  File ID) and there are other entries, save this
									//  entry until last.  we must do this so that we can
									//  maintain ownership of this File ID until the file
									//  is entirely cleaned up.  if we free this run too
									//  soon, it can be reallocated and used as the File ID
									//  for another file.  this, of course, would be bad

									CInvasiveList< CExtendedEntry::CRun, CExtendedEntry::CRun::OffsetOfILE >*	pilRun	= NULL;
									CExtendedEntry::CRun*														prun	= NULL;

									if ( !prun )
										{
										pilRun = &entry.m_pextentry->m_ilRunReserved;
										prun = pilRun->PrevMost();
										}

									if ( prun && CSLVInfo::FILEID( prun->m_ibLogical ) == entry.m_fileid )
										{
										prun = pilRun->Next( prun );
										}

									if ( !prun )
										{
										pilRun = &entry.m_pextentry->m_ilRunDeleted;
										prun = pilRun->PrevMost();
										}

									if ( prun && CSLVInfo::FILEID( prun->m_ibLogical ) == entry.m_fileid )
										{
										prun = pilRun->Next( prun );
										}

									if ( !prun )
										{
										pilRun = &entry.m_pextentry->m_ilRunReserved;
										prun = pilRun->PrevMost();
										}

									if ( !prun )
										{
										pilRun = &entry.m_pextentry->m_ilRunDeleted;
										prun = pilRun->PrevMost();
										}

									Assert( pilRun );
									Assert( prun );
									Assert(	CSLVInfo::FILEID( prun->m_ibLogical ) != entry.m_fileid ||
											!pilRun->Prev( prun ) &&
											!pilRun->Next( prun ) &&
											(	entry.m_pextentry->m_ilRunReserved.FEmpty() ^
												entry.m_pextentry->m_ilRunDeleted.FEmpty() ) );

									//  we successfully cleaned up the space

									if (	m_pslvroot->pfnSpaceFree(	m_pslvroot->dwSpaceFreeKey,
																		prun->m_ibLogical,
																		prun->m_cbSize,
																		pilRun == &entry.m_pextentry->m_ilRunDeleted ) >= JET_errSuccess )
										{
										//  remove this space from the entry

										pilRun->Remove( prun );
										if ( pilRun == &entry.m_pextentry->m_ilRunDeleted )
											{
											AtomicAdd( &m_cbDeleted, -prun->m_cbSize );
											}
										else
											{
											AtomicAdd( &m_cbReserved, -prun->m_cbSize );
											}
										delete prun;
										}

									//  we failed to clean up the space

									else
										{
										//  reset the expiration on this file to sometime
										//  in the future to optimize cleanup of the table

										entry.m_tickExpiration = TickOSTimeCurrent() + cmsecOSSLVSpaceFreeDelay;

										//  stop cleaning this entry

										break;
										}
									}
									
								//  there is no space left in this entry

								if (	entry.m_pextentry->m_ilRunReserved.FEmpty() &&
										entry.m_pextentry->m_ilRunDeleted.FEmpty() )
									{
									//  remove any dependents we may have
									//
									//  NOTE:  if we see a dependent with its dependent
									//  flag reset then that means that the dependency
									//  was never setup and the extended entry has been
									//  orphaned so we must free this extended entry

									while ( entry.m_pextentry->m_ilDependents.PrevMost() )
										{
										CSLVFileTable::CExtendedEntry* pextentry;
										pextentry = entry.m_pextentry->m_ilDependents.PrevMost();

										entry.m_pextentry->m_ilDependents.Remove( pextentry );

										if ( !BOOL( AtomicExchange( (long*)&pextentry->m_fDependent, long( fFalse ) ) ) )
											{
											delete pextentry->m_wszFileName;
											delete pextentry;
											}
										}
									
									//  delete this entry in the table

									delete entry.m_pextentry->m_wszFileName;
									delete entry.m_pextentry;
									
									errET = m_et.ErrDeleteEntry( &lockET );
									Assert( errET == CEntryTable::errSuccess );
									AtomicIncrement( (long*)&cOSSLVFileTableDelete );
									AtomicIncrement( (long*)&m_centryDelete );
									}

								//  there is space left in this entry

								else
									{
									//  update this entry in the table
									
									errET = m_et.ErrReplaceEntry( &lockET, entry );
									Assert( errET == CEntryTable::errSuccess );
									}
								}

							//  the SLV File is still in use

							else
								{
								//  close the file if opened

								if ( hFile )
									{
									CloseHandle( hFile );
									}
								
								//  reset the expiration on this file to sometime in the
								//  future to optimize cleanup of the table

								entry.m_tickExpiration = TickOSTimeCurrent() + cmsecOSSLVFileOpenDelay;
								
								errET = m_et.ErrReplaceEntry( &lockET, entry );
								Assert( errET == CEntryTable::errSuccess );
								}
							}

						//  there is neither space nor a file name stored in this entry

						else
							{
							//  remove any dependents we may have
							//
							//  NOTE:  if we see a dependent with its dependent
							//  flag reset then that means that the dependency
							//  was never setup and the extended entry has been
							//  orphaned so we must free this extended entry

							while ( entry.m_pextentry && entry.m_pextentry->m_ilDependents.PrevMost() )
								{
								CSLVFileTable::CExtendedEntry* pextentry;
								pextentry = entry.m_pextentry->m_ilDependents.PrevMost();

								entry.m_pextentry->m_ilDependents.Remove( pextentry );

								if ( !BOOL( AtomicExchange( (long*)&pextentry->m_fDependent, long( fFalse ) ) ) )
									{
									delete pextentry->m_wszFileName;
									delete pextentry;
									}
								}
							
							//  delete this entry in the table

							if ( entry.m_pextentry )
								{
								delete entry.m_pextentry->m_wszFileName;
								delete entry.m_pextentry;
								}
									
							errET = m_et.ErrDeleteEntry( &lockET );
							Assert( errET == CEntryTable::errSuccess );
							AtomicIncrement( (long*)&cOSSLVFileTableDelete );
							AtomicIncrement( (long*)&m_centryDelete );
							}
						}
					}
				}

			m_et.EndHashScan( &lockET );
			}

		//  we're done with our share of the amortized cleanup so let someone
		//  else take a crack at it

		m_semCleanup.Release();
		}
	}

CSLVFileInfo::CSLVFileInfo()
	{
	m_fFreeCache	= fFalse;
	m_fCloseBuffer	= fFalse;
	m_fCloseCursor	= fFalse;
	}
	
CSLVFileInfo::~CSLVFileInfo()
	{
	Assert( !m_fFreeCache );
	Assert( !m_fCloseBuffer );
	Assert( !m_fCloseCursor );
	}
	
ERR CSLVFileInfo::ErrCreate()
	{
	PFILE_FULL_EA_INFORMATION	pffeainfCur;
	BYTE*						pbNameStart;
	BYTE*						pbNameEnd;
	BYTE*						pbValueStart;
	BYTE*						pbValueEnd;
	PFILE_FULL_EA_INFORMATION	pffeainfNext;

	//  init the cache
	
	m_fFreeCache		= fFalse;
	m_fUpdateChecksum	= fFalse;
	m_fUpdateSlist		= fFalse;
	m_rgbCache			= (BYTE*) _PvAlign( m_rgbLocalCache );
	m_cbCache			= cbLocalCache;

#ifdef DEBUG
	memset( m_rgbCache, 0xEA, m_cbCache );
#endif  //  DEBUG

	//  build an empty EA List in the buffer and initialize all property
	//  pointers to point to the correct places in that EA List
	
	m_pffeainf	= PFILE_FULL_EA_INFORMATION( m_rgbCache );
	m_cbffeainf	=	EXIFS_EA_LEN_FILENAME( sizeof( L"" ) ) +
					EXIFS_EA_LEN_COMMIT +
					EXIFS_EA_LEN_INSTANCE_ID +
					EXIFS_EA_LEN_CHECKSUM +
					EXIFS_EA_LEN_OPEN_DEADLINE +
					EXIFS_EA_LEN_SCATTER_LIST( m_fUpdateSlist );  //  don't ask

	Assert( m_cbffeainf <= m_cbCache );
	
	pffeainfNext = m_pffeainf;
	
	//  add an empty file name to the EA List

	pffeainfCur		= pffeainfNext;
	pbNameStart		= (BYTE*)pffeainfCur->EaName;
	pbNameEnd		= pbNameStart + sizeof( EXIFS_EA_NAME_FILENAME );
	pbValueStart	= (BYTE*)_PvAlign( pbNameEnd );
	pbValueEnd		= pbValueStart + sizeof( L"" );
	pffeainfNext	= (FILE_FULL_EA_INFORMATION*)_PvAlign( pbValueEnd );

	pffeainfCur->NextEntryOffset	= (ULONG)((BYTE*)pffeainfNext - (BYTE*)pffeainfCur);
	pffeainfCur->Flags				= 0;
	pffeainfCur->EaNameLength		= BYTE( pbNameEnd - pbNameStart - 1 );
	pffeainfCur->EaValueLength		= WORD( (BYTE*)pffeainfNext - pbNameEnd );
	
	strcpy( (char*)pbNameStart, EXIFS_EA_NAME_FILENAME );
	
	m_wszFileName		= (wchar_t*)pbValueStart;

	wcscpy( m_wszFileName, L"" );
	m_cwchFileName = wcslen( L"" );
	
	//  add the commit status to the EA List, indicating that this space is either
	//  committed or reserved

	pffeainfCur		= pffeainfNext;
	pbNameStart		= (BYTE*)pffeainfCur->EaName;
	pbNameEnd		= pbNameStart + sizeof( EXIFS_EA_NAME_COMMIT );
	pbValueStart	= (BYTE*)_PvAlign( pbNameEnd );
	pbValueEnd		= pbValueStart + sizeof( NTSTATUS );
	pffeainfNext	= (FILE_FULL_EA_INFORMATION*)_PvAlign( pbValueEnd );

	pffeainfCur->NextEntryOffset	= (ULONG)((BYTE*)pffeainfNext - (BYTE*)pffeainfCur);
	pffeainfCur->Flags				= 0;
	pffeainfCur->EaNameLength		= BYTE( pbNameEnd - pbNameStart - 1 );
	pffeainfCur->EaValueLength		= WORD( (BYTE*)pffeainfNext - pbNameEnd );
	
	strcpy( (char*)pbNameStart, EXIFS_EA_NAME_COMMIT );
	
	m_pstatusCommit		= (NTSTATUS*) pbValueStart;

	*m_pstatusCommit	= STATUS_EA_CORRUPT_ERROR;

	//  add the instance ID to the EA List

	pffeainfCur		= pffeainfNext;
	pbNameStart		= (BYTE*)pffeainfCur->EaName;
	pbNameEnd		= pbNameStart + sizeof( EXIFS_EA_NAME_INSTANCE_ID );
	pbValueStart	= (BYTE*)_PvAlign( pbNameEnd );
	pbValueEnd		= pbValueStart + sizeof( DWORD );
	pffeainfNext	= (FILE_FULL_EA_INFORMATION*)_PvAlign( pbValueEnd );

	pffeainfCur->NextEntryOffset	= (ULONG)((BYTE*)pffeainfNext - (BYTE*)pffeainfCur);
	pffeainfCur->Flags				= 0;
	pffeainfCur->EaNameLength		= BYTE( pbNameEnd - pbNameStart - 1 );
	pffeainfCur->EaValueLength		= WORD( (BYTE*)pffeainfNext - pbNameEnd );
	
	strcpy( (char*)pbNameStart, EXIFS_EA_NAME_INSTANCE_ID );

	m_pdwInstanceID		= (DWORD*) pbValueStart;
	
	*m_pdwInstanceID	= EXIFS_INVALID_INSTANCE_ID;

	//  add the EA List checksum to the EA List and set it to 0 initially.  we
	//  will come back and set it to the correct value once the entire EA List
	//  is constructed

	pffeainfCur		= pffeainfNext;
	pbNameStart		= (BYTE*)pffeainfCur->EaName;
	pbNameEnd		= pbNameStart + sizeof( EXIFS_EA_NAME_CHECKSUM );
	pbValueStart	= (BYTE*)_PvAlign( pbNameEnd );
	pbValueEnd		= pbValueStart + sizeof( DWORD );
	pffeainfNext	= (FILE_FULL_EA_INFORMATION*)_PvAlign( pbValueEnd );

	pffeainfCur->NextEntryOffset	= (ULONG)((BYTE*)pffeainfNext - (BYTE*)pffeainfCur);
	pffeainfCur->Flags				= 0;
	pffeainfCur->EaNameLength		= BYTE( pbNameEnd - pbNameStart - 1 );
	pffeainfCur->EaValueLength		= WORD( (BYTE*)pffeainfNext - pbNameEnd );
	
	strcpy( (char*)pbNameStart, EXIFS_EA_NAME_CHECKSUM );
	
	m_pdwChecksum	= (DWORD*) pbValueStart;

	*m_pdwChecksum	= EXIFS_CHECKSUM_SEED;

	//  add the open deadline to the EA List

	pffeainfCur		= pffeainfNext;
	pbNameStart		= (BYTE*)pffeainfCur->EaName;
	pbNameEnd		= pbNameStart + sizeof( EXIFS_EA_NAME_OPEN_DEADLINE );
	pbValueStart	= (BYTE*)_PvAlign( pbNameEnd );
	pbValueEnd		= pbValueStart + sizeof( TICK );
	pffeainfNext	= (FILE_FULL_EA_INFORMATION*)_PvAlign( pbValueEnd );

	pffeainfCur->NextEntryOffset	= (ULONG)((BYTE*)pffeainfNext - (BYTE*)pffeainfCur);
	pffeainfCur->Flags				= 0;
	pffeainfCur->EaNameLength		= BYTE( pbNameEnd - pbNameStart - 1 );
	pffeainfCur->EaValueLength		= WORD( (BYTE*)pffeainfNext - pbNameEnd );
	
	strcpy( (char*)pbNameStart, EXIFS_EA_NAME_OPEN_DEADLINE );

	m_ptickOpenDeadline		= (TICK*) pbValueStart;
	
	*m_ptickOpenDeadline	= TickOSTimeCurrent() - cmsecOSSLVTTLSafety;

	//  add an empty scatter list as the last entry in the EA List

	pffeainfCur		= pffeainfNext;
	pbNameStart		= (BYTE*)pffeainfCur->EaName;
	pbNameEnd		= pbNameStart + sizeof( EXIFS_EA_NAME_SCATTER_LIST );
	pbValueStart	= (BYTE*)_PvAlign( pbNameEnd );
	pbValueEnd		= pbValueStart + _SizeofScatterList( 0 );
	pffeainfNext	= (FILE_FULL_EA_INFORMATION*)_PvAlign( pbValueEnd );

	pffeainfCur->NextEntryOffset	= 0;
	pffeainfCur->Flags				= 0;
	pffeainfCur->EaNameLength		= BYTE( pbNameEnd - pbNameStart - 1 );
	pffeainfCur->EaValueLength		= WORD( (BYTE*)pffeainfNext - pbNameEnd );
	
	strcpy( (char*)pbNameStart, EXIFS_EA_NAME_SCATTER_LIST );

	m_pslist	= PSCATTER_LIST( pbValueStart );
	m_cbslist	= _SizeofScatterList( 0 );

	m_pslist->Signature				= SCATTER_LIST_SIGNATURE;
	m_pslist->NumFragments			= 0;
	m_pslist->TotalBytes.QuadPart	= 0;
	m_pslist->OverflowOffset		= (ULONG)m_cbslist;
	m_pslist->OverflowLen			= 0;
	m_pslist->Flags					= 0;

	//  verify that the generated EA List is of the expected size

	Assert( m_cbffeainf == (BYTE*)pffeainfNext - (BYTE*)m_pffeainf );

	//  set our currency to before the first run

	MoveBeforeFirstRun();

	//  init the large scatter list buffer

	m_fCloseBuffer	= fFalse;
	m_fCloseCursor	= fFalse;

	return JET_errSuccess;
	}
	
ERR CSLVFileInfo::ErrLoad( const void* const pv, const size_t cb, const BOOL fCommit )
	{
	ERR							err			= JET_errSuccess;
	PFILE_FULL_EA_INFORMATION	pffeainfCur;
	
	//  init the cache
	
	m_fFreeCache		= fFalse;
	m_fUpdateChecksum	= fFalse;
	m_fUpdateSlist		= fFalse;
	m_rgbCache			= (BYTE*) pv;
	m_cbCache			= cb;

	//  load the EA List from the provided buffer

	m_pffeainf	= PFILE_FULL_EA_INFORMATION( m_rgbCache );
	m_cbffeainf	= cb;

	//  verify the checksum of the EA list

	if ( LOG::UlChecksumBytes(	(BYTE*)m_pffeainf,
								(BYTE*)m_pffeainf + m_cbffeainf,
								EXIFS_CHECKSUM_SEED ) )
		{
		Call( ErrERRCheck( JET_errSLVEAListCorrupt ) );
		}

	//  TODO:  validate EA list structure

	//  extract each EA from the EA list

	pffeainfCur			= m_pffeainf;
	m_wszFileName		= (wchar_t*)_PvAlign( pffeainfCur->EaName + pffeainfCur->EaNameLength + 1 );
	m_cwchFileName		= wcslen( m_wszFileName );

	pffeainfCur			= PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainfCur + pffeainfCur->NextEntryOffset );
	m_pstatusCommit		= (NTSTATUS*)_PvAlign( pffeainfCur->EaName + pffeainfCur->EaNameLength + 1 );

	pffeainfCur			= PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainfCur + pffeainfCur->NextEntryOffset );
	m_pdwInstanceID		= (DWORD*)_PvAlign( pffeainfCur->EaName + pffeainfCur->EaNameLength + 1 );

	pffeainfCur			= PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainfCur + pffeainfCur->NextEntryOffset );
	m_pdwChecksum		= (DWORD*)_PvAlign( pffeainfCur->EaName + pffeainfCur->EaNameLength + 1 );

	pffeainfCur			= PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainfCur + pffeainfCur->NextEntryOffset );
	m_ptickOpenDeadline	= (TICK*)_PvAlign( pffeainfCur->EaName + pffeainfCur->EaNameLength + 1 );

	pffeainfCur			= PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainfCur + pffeainfCur->NextEntryOffset );
	m_pslist			= PSCATTER_LIST( _PvAlign( pffeainfCur->EaName + pffeainfCur->EaNameLength + 1 ) );
	m_cbslist			= _SizeofScatterList( m_pslist->NumFragments, ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) );

	//  validate EAs
	//
	//  TODO:  validate ALL EAs

	if ( fCommit )
		{
		Call( ErrOSSLVFileINTStatus( *m_pstatusCommit ) );
		}

	if ( m_pslist->OverflowOffset != sizeof( SCATTER_LIST ) )
		{
		Call( ErrERRCheck( JET_errSLVProviderVersionMismatch ) );
		}

	//  init the large scatter list buffer

	if ( ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) )
		{
		Call( ErrOSSLVFileIGetLastError( pfnIfsCopyReferenceToBuffer(	PIFS_LARGE_BUFFER( (BYTE*)m_pslist + m_pslist->OverflowOffset ),
																		NULL,
																		&m_buffer ) ) );
		m_fCloseBuffer	= fTrue;
		
		m_fCloseCursor	= fFalse;
		}
	else
		{
		m_fCloseBuffer	= fFalse;
		m_fCloseCursor	= fFalse;
		}

	//  set our currency to before the first run

	MoveBeforeFirstRun();

	return JET_errSuccess;

HandleError:
	Unload();
	return err;
	}
	
INLINE void CSLVFileInfo::Unload()
	{
	if ( m_fCloseCursor )
		{
		pfnIfsFinishCursor( &m_cursor );
		m_fCloseCursor = fFalse;
		}
	if ( m_fCloseBuffer )
		{
		pfnIfsCloseBuffer( &m_buffer );
		m_fCloseBuffer = fFalse;
		}
	if ( m_fFreeCache )
		{
		OSMemoryHeapFree( m_rgbCache );
		m_fFreeCache = fFalse;
		}
	}
	
INLINE ERR CSLVFileInfo::ErrGetFileName( wchar_t** const pwszFileName, size_t* const pcwchFileName )
	{
	*pwszFileName	= m_wszFileName;
	*pcwchFileName	= m_cwchFileName;

	return JET_errSuccess;
	}
	
ERR CSLVFileInfo::ErrSetFileName( const wchar_t* const wszFileName )
	{
	ERR err = JET_errSuccess;
	
	//  get the change in size of the EA List

	size_t	cwchFileNameNew	= wcslen( wszFileName );
	size_t	cbFileNameNew	= _IbAlign( ( cwchFileNameNew + 1 ) * sizeof( wchar_t ) );
	size_t	cbFileName		= _IbAlign( ( m_cwchFileName + 1 ) * sizeof( wchar_t ) );

	size_t	dcbffeainf		= cbFileNameNew - cbFileName;

	//  make the cache large enough to hold the new EA List

	CallR( _ErrCheckCacheSize( m_cbffeainf + dcbffeainf ) );

	//  move the EA List data after the new file name

	memmove(	(BYTE*)m_pffeainf + m_pffeainf->NextEntryOffset + dcbffeainf,
				(BYTE*)m_pffeainf + m_pffeainf->NextEntryOffset,
				m_cbffeainf - m_pffeainf->NextEntryOffset );

	//  fix up the EA List pointers for the new file name

	m_pffeainf->NextEntryOffset	= (ULONG)(m_pffeainf->NextEntryOffset + dcbffeainf);
	m_pffeainf->EaValueLength	= WORD( m_pffeainf->EaValueLength + dcbffeainf );
	m_cbffeainf					= m_cbffeainf + dcbffeainf;

	//  move all property pointers after the new file name

	m_pstatusCommit		= (NTSTATUS*)( DWORD_PTR( m_pstatusCommit ) + dcbffeainf );
	m_pdwInstanceID		= (DWORD*)( DWORD_PTR( m_pdwInstanceID ) + dcbffeainf );
	m_pdwChecksum		= (DWORD*)( DWORD_PTR( m_pdwChecksum ) + dcbffeainf );
	m_ptickOpenDeadline	= (TICK*)( DWORD_PTR( m_ptickOpenDeadline ) + dcbffeainf );
	m_pslist			= PSCATTER_LIST( DWORD_PTR( m_pslist ) + dcbffeainf );

	//  copy in the new file name

	wcscpy( m_wszFileName, wszFileName );
	m_cwchFileName = cwchFileNameNew;

	m_fUpdateChecksum = fTrue;
	
	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrGetCommitStatus( NTSTATUS* const pstatusCommit )
	{
	*pstatusCommit = *m_pstatusCommit;

	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrSetCommitStatus( const NTSTATUS statusCommit )
	{
	*m_pstatusCommit = statusCommit;
	
	m_fUpdateChecksum = fTrue;
	
	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrGetInstanceID( DWORD* const pdwInstanceID )
	{
	*pdwInstanceID = *m_pdwInstanceID;

	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrSetInstanceID( const DWORD dwInstanceID )
	{
	*m_pdwInstanceID = dwInstanceID;
	
	m_fUpdateChecksum = fTrue;
	
	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrGetOpenDeadline( TICK* const ptickOpenDeadline )
	{
	*ptickOpenDeadline = *m_ptickOpenDeadline;

	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrSetOpenDeadline( const TICK tickOpenDeadline )
	{
	*m_ptickOpenDeadline = tickOpenDeadline;
	
	m_fUpdateChecksum = fTrue;
	
	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrGetRunCount( DWORD* const pcrun )
	{
	*pcrun = m_pslist->NumFragments;

	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrGetFileSize( QWORD* const pcbSize )
	{
	*pcbSize = m_pslist->TotalBytes.QuadPart;

	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrSetFileSize( const QWORD cbSize )
	{
	m_pslist->TotalBytes.QuadPart = cbSize;
	
	m_fUpdateChecksum = fTrue;
	
	return JET_errSuccess;
	}
	
INLINE void CSLVFileInfo::MoveBeforeFirstRun()
	{
	m_irun	= -1;
	m_psle	= NULL;
	
	if ( m_fCloseCursor )
		{
		pfnIfsFinishCursor( &m_cursor );
		m_fCloseCursor = fFalse;
		}

	if ( ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) )
		{
		m_psle = PSCATTER_LIST_ENTRY( pfnIfsGetFirstCursor(	&m_buffer,
															&m_cursor,
															0,
															0,
															OSMemoryPageReserveGranularity(),
															fTrue ) );
		m_fCloseCursor = !!m_psle;
		}
	}
	
INLINE ERR CSLVFileInfo::ErrMoveNextRun()
	{
	m_irun++;
	
	if ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER )
		{
		if ( !m_fCloseCursor )
			{
			return ErrERRCheck( JET_errOutOfMemory );
			}

		if (	m_irun >= MAX_FRAGMENTS + 1 && m_irun <= m_pslist->NumFragments &&
				!( m_psle = PSCATTER_LIST_ENTRY( pfnIfsConsumeCursor( &m_cursor, sizeof( SCATTER_LIST_ENTRY ) ) ) ) &&
				!( m_psle = PSCATTER_LIST_ENTRY( pfnIfsGetNextCursor( &m_cursor, OSMemoryPageReserveGranularity() ) ) ) &&
				m_irun < m_pslist->NumFragments )
			{
			return ErrERRCheck( JET_errSLVEAListCorrupt );
			}
		}
		
	if ( m_irun >= m_pslist->NumFragments )
		{
		m_irun = m_pslist->NumFragments;
		return ErrERRCheck( JET_errNoCurrentRecord );
		}

	return JET_errSuccess;
	}
	
INLINE ERR CSLVFileInfo::ErrGetCurrentRun( CRun* const prun )
	{
	ERR					err		= JET_errSuccess;
	PSCATTER_LIST_ENTRY	psle	= NULL;
		
	if ( m_irun < 0 )
		{
		Assert( m_irun == -1 );
		}
	else if ( m_irun < MAX_FRAGMENTS )
		{
		psle = m_pslist->sle + m_irun;
		}
	else if ( m_irun < m_pslist->NumFragments )
		{
		if ( ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) )
			{
			psle = m_psle;
			}
		else
			{
			psle = PSCATTER_LIST_ENTRY( (BYTE*)m_pslist + m_pslist->OverflowOffset ) + m_irun - MAX_FRAGMENTS;
			}
		}
	else
		{
		Assert( m_irun == m_pslist->NumFragments );
		}

	if ( psle )
		{
		TRY
			{
			prun->m_ibLogical	= psle->Offset.QuadPart;
			prun->m_cbSize		= psle->Length;
			}
		EXCEPT( efaExecuteHandler )
			{
			err = ErrERRCheck( JET_errOutOfMemory );
			}
		ENDEXCEPT
		}
	else
		{
		err = ErrERRCheck( JET_errNoCurrentRecord );
		}

	return err;
	}
	
ERR CSLVFileInfo::ErrSetCurrentRun( const CRun& run )
	{
	ERR					err		= JET_errSuccess;
	PSCATTER_LIST_ENTRY	psle	= NULL;
	
	if ( m_irun == m_pslist->NumFragments )
		{
		//  get the change in size of the EA List

		size_t	cbslistNew	= _IbAlign( _SizeofScatterList( m_pslist->NumFragments + 1, ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) ) );
		size_t	cbslist		= _IbAlign( _SizeofScatterList( m_pslist->NumFragments, ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) ) );

		size_t	dcbffeainf	= cbslistNew - cbslist;

		//  make the cache large enough to hold the new EA List

		CallR( _ErrCheckCacheSize( m_cbffeainf + dcbffeainf ) );

		//  recompute the change in size of the EA List in case the scatter list
		//  was pushed into the large buffer format

		cbslistNew	= _IbAlign( _SizeofScatterList( m_pslist->NumFragments + 1, ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) ) );
		cbslist		= _IbAlign( _SizeofScatterList( m_pslist->NumFragments, ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) ) );

		dcbffeainf	= cbslistNew - cbslist;

		//  fix up the EA List pointers for the new scatter list

		PFILE_FULL_EA_INFORMATION pffeainf;
		pffeainf = m_pffeainf;
		pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );
		pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );
		pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );
		pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );
		pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );

		pffeainf->EaValueLength		= WORD( pffeainf->EaValueLength + dcbffeainf );
		m_cbffeainf					= m_cbffeainf + dcbffeainf;

		//  fix up the Scatter List to contain the new run

		m_pslist->NumFragments	= m_pslist->NumFragments + 1;
		m_cbslist				= _SizeofScatterList( m_pslist->NumFragments, ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) );

		//  fall through to the below cases to set the current run now that our
		//  currency is on an actual run
		}
	else if ( m_irun < 0 )
		{
		Assert( m_irun == -1 );
		}
	if ( m_irun < MAX_FRAGMENTS )
		{
		psle = m_pslist->sle + m_irun;
		}
	else
		{
		Assert( m_irun < m_pslist->NumFragments );
		
		if ( ( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER ) )
			{
			psle = m_psle;
			}
		else
			{
			psle = PSCATTER_LIST_ENTRY( (BYTE*)m_pslist + m_pslist->OverflowOffset ) + m_irun - MAX_FRAGMENTS;
			}
		}

	if ( psle )
		{
		Assert( DWORD( run.m_cbSize ) == run.m_cbSize );
		
		TRY
			{
			psle->Offset.QuadPart	= run.m_ibLogical;
			psle->Length			= DWORD(run.m_cbSize );
			psle->ulReserved		= 0;
			}
		EXCEPT( efaExecuteHandler )
			{
			err = ErrERRCheck( JET_errOutOfMemory );
			}
		ENDEXCEPT

		m_fUpdateChecksum	= fTrue;
		m_fUpdateSlist		= m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER;
		}
	else
		{
		err = ErrERRCheck( JET_errNoCurrentRecord );
		}

	return err;
	}

INLINE BOOL CSLVFileInfo::FEAListIsSelfDescribing()
	{
	return FScatterListIsSelfDescribing();
	}

INLINE ERR CSLVFileInfo::ErrGetEAList( void** const ppv, size_t* const pcb )
	{
	if ( m_fUpdateSlist )
		{
		Assert(	m_irun == m_pslist->NumFragments - 1 ||
				m_irun == m_pslist->NumFragments );

		ERR err = ErrMoveNextRun();
		Assert( err == JET_errNoCurrentRecord );
				
		pfnIfsCopyBufferToReference(	&m_buffer,
										PIFS_LARGE_BUFFER( (BYTE*)m_pslist + m_pslist->OverflowOffset ) );

		m_fUpdateChecksum	= fTrue;
		m_fUpdateSlist		= fFalse;
		}
	
	if ( m_fUpdateChecksum )
		{
		*m_pdwChecksum = 0;
		*m_pdwChecksum = LOG::UlChecksumBytes(	(BYTE*)m_pffeainf,
												(BYTE*)m_pffeainf + m_cbffeainf,
												EXIFS_CHECKSUM_SEED );

		m_fUpdateChecksum = fFalse;
		}

	Assert( !LOG::UlChecksumBytes(	(BYTE*)m_pffeainf,
									(BYTE*)m_pffeainf + m_cbffeainf,
									EXIFS_CHECKSUM_SEED ) );
	
	*ppv = m_pffeainf;
	*pcb = m_cbffeainf;

	return JET_errSuccess;
	}

INLINE BOOL CSLVFileInfo::FScatterListIsSelfDescribing()
	{
	return !( m_pslist->Flags & IFS_SLIST_FLAGS_LARGE_BUFFER );
	}

INLINE ERR CSLVFileInfo::ErrGetScatterList( void** const ppv, size_t* const pcb )
	{
	if ( m_fUpdateSlist )
		{
		Assert(	m_irun == m_pslist->NumFragments - 1 ||
				m_irun == m_pslist->NumFragments );

		ERR err = ErrMoveNextRun();
		Assert( err == JET_errNoCurrentRecord );
				
		pfnIfsCopyBufferToReference(	&m_buffer,
										PIFS_LARGE_BUFFER( (BYTE*)m_pslist + m_pslist->OverflowOffset ) );

		m_fUpdateChecksum	= fTrue;
		m_fUpdateSlist		= fFalse;
		}
	
	*ppv = m_pslist;
	*pcb = m_cbslist;

	return JET_errSuccess;
	}

INLINE DWORD_PTR CSLVFileInfo::_IbAlign( const DWORD_PTR ib )
	{
	return (ULONG_PTR)( ( ib + cbEAAlign - 1 ) & ( ( ~( (LONG_PTR)0 ) ) * cbEAAlign ) );
	}

INLINE void* CSLVFileInfo::_PvAlign( const void* const pv )
	{
	return (void*)_IbAlign( DWORD_PTR( pv ) );
	}

INLINE size_t CSLVFileInfo::_SizeofScatterList( const size_t crun, const BOOL fLarge )
	{
	return	sizeof( SCATTER_LIST ) +
			(	fLarge ?
				sizeof( IFS_LARGE_BUFFER ) :
				(	crun < MAX_FRAGMENTS ?
						0 :
						( crun - MAX_FRAGMENTS ) * sizeof( SCATTER_LIST_ENTRY ) ) );
	}

ERR CSLVFileInfo::_ErrCheckCacheSize( const size_t cbCacheNew )
	{
	ERR err = JET_errSuccess;
	
	//  the new EA List will overflow the buffer

	if ( cbCacheNew > m_cbCache )
		{
		//  we are already using an allocated cache
		
		if ( m_fFreeCache )
			{
			//  we are already using the large scatter list buffer

			if ( m_fCloseBuffer )
				{
				//  fail the change with OOM

				return ErrERRCheck( JET_errOutOfMemory );
				}

			//  we are not already using the large scatter list buffer

			else
				{
				//  create a new large buffer

				CallR( ErrOSSLVFileIGetLastError( pfnIfsCreateNewBuffer( &m_buffer, 0, 0, NULL ) ) );

				//  move all our extended runs into the large buffer

				if ( !( m_psle = PSCATTER_LIST_ENTRY( pfnIfsGetFirstCursor(	&m_buffer,
																			&m_cursor,
																			0,
																			0,
																			OSMemoryPageReserveGranularity(),
																			fTrue ) ) ) )
					{
					pfnIfsCloseBuffer( &m_buffer );
					return ErrERRCheck( JET_errOutOfMemory );
					}

				PSCATTER_LIST_ENTRY	psleSrc;
				LONG				irun;

				err		= JET_errSuccess;
				psleSrc	= PSCATTER_LIST_ENTRY( (BYTE*)m_pslist + m_pslist->OverflowOffset );
				
				for ( irun = MAX_FRAGMENTS; irun < m_pslist->NumFragments; irun++ )
					{
					Assert( !psleSrc->ulReserved );
					
					TRY
						{
						m_psle->Offset.QuadPart	= psleSrc->Offset.QuadPart;
						m_psle->Length			= psleSrc->Length;
						m_psle->ulReserved		= 0;
						}
					EXCEPT( efaExecuteHandler )
						{
						err = ErrERRCheck( JET_errOutOfMemory );
						}
					ENDEXCEPT

					psleSrc++;
					if (	!( m_psle = PSCATTER_LIST_ENTRY( pfnIfsConsumeCursor( &m_cursor, sizeof( SCATTER_LIST_ENTRY ) ) ) ) &&
							!( m_psle = PSCATTER_LIST_ENTRY( pfnIfsGetNextCursor( &m_cursor, OSMemoryPageReserveGranularity() ) ) ) )
						{
						err = ErrERRCheck( JET_errOutOfMemory );
						break;
						}
					}

				if ( err < JET_errSuccess )
					{
					m_psle = NULL;
					pfnIfsFinishCursor( &m_cursor );
					pfnIfsCloseBuffer( &m_buffer );
					return err;
					}

				//  fixup the EA List to account for the new large buffer format

				size_t dcbffeainf =	_SizeofScatterList( m_pslist->NumFragments, fTrue ) -
									_SizeofScatterList( m_pslist->NumFragments, fFalse );

				PFILE_FULL_EA_INFORMATION pffeainf;
				pffeainf = m_pffeainf;
				pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );
				pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );
				pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );
				pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );
				pffeainf = PFILE_FULL_EA_INFORMATION( (BYTE*)pffeainf + pffeainf->NextEntryOffset );

				pffeainf->EaValueLength		= WORD( pffeainf->EaValueLength + dcbffeainf );
				m_cbffeainf					= m_cbffeainf + dcbffeainf;
				
				//  fixup the Scatter List to use the new large buffer

				m_fCloseBuffer		= fTrue;
				m_fCloseCursor		= fTrue;
				m_pslist->Flags		= IFS_SLIST_FLAGS_LARGE_BUFFER;
				m_cbslist			= _SizeofScatterList( m_pslist->NumFragments, fTrue );

				m_fUpdateChecksum	= fTrue;
				m_fUpdateSlist		= fTrue;

				//  NOCODE:  move our cursor back to the current record
				//
				//  NOTE:  this will magically work for appending runs

				Assert( m_irun == m_pslist->NumFragments );
				}
			}

		//  we are not already using an allocated cache

		else
			{
			//  allocate a new cache

			BYTE* rgbCacheNew;
			if ( !( rgbCacheNew = (BYTE*)PvOSMemoryHeapAlloc( cbEAListMax ) ) )
				{
				return ErrERRCheck( JET_errOutOfMemory );
				}

			//  move our data to the new cache

			m_fFreeCache	= fTrue;
			m_rgbCache		= rgbCacheNew;
			m_cbCache		= cbEAListMax;

#ifdef DEBUG
			memset( m_rgbCache, 0xEA, m_cbCache );
#endif  //  DEBUG

			memcpy( m_rgbCache, m_pffeainf, m_cbffeainf );

			//  update all property pointers to point to the new cache

			DWORD_PTR dwOffset;
			dwOffset = DWORD_PTR( m_rgbCache ) - DWORD_PTR( m_pffeainf );

			m_pffeainf			= PFILE_FULL_EA_INFORMATION( DWORD_PTR( m_pffeainf ) + dwOffset );
			m_wszFileName		= (wchar_t*)( DWORD_PTR( m_wszFileName ) + dwOffset );
			m_pstatusCommit		= (NTSTATUS*)( DWORD_PTR( m_pstatusCommit ) + dwOffset );
			m_pdwInstanceID		= (DWORD*)( DWORD_PTR( m_pdwInstanceID ) + dwOffset );
			m_pdwChecksum		= (DWORD*)( DWORD_PTR( m_pdwChecksum ) + dwOffset );
			m_ptickOpenDeadline	= (TICK*)( DWORD_PTR( m_ptickOpenDeadline ) + dwOffset );
			m_pslist			= PSCATTER_LIST( DWORD_PTR( m_pslist ) + dwOffset );

			m_fUpdateChecksum	= fTrue;
			}
		}

	return JET_errSuccess;
	}


//  validates and converts the given SLV File Info into SLV Info

void OSSLVRootSpaceIConsume( SLVROOT slvroot, QWORD cbSize );

ERR ErrOSSLVFileIConvertSLVFileInfoToSLVInfo(	const SLVROOT		slvroot,
												CSLVFileInfo&		slvfileinfo,
												CSLVInfo* const		pslvinfo )
	{
	ERR					err				= JET_errSuccess;
	DWORD				crun;
	CSLVFileInfo::CRun	runSrc;
	size_t				cwchFileName;
	wchar_t*			wszFileName;
	QWORD				cbSize			= 0;
	CSLVInfo::HEADER	header;
	CSLVInfo::RUN		runDest;

	//  this SLV File has no runs

	Call( slvfileinfo.ErrGetRunCount( &crun ) );

	if ( !crun )
		{
		//  fail the conversion because we need at least one run per SLV File
		//  to provide us with its File ID

		Call( ErrERRCheck( JET_errSLVEAListZeroAllocation ) );
		}

	//  note the amount of reserved space we have successfully committed to the
	//  SLV Provider

	slvfileinfo.MoveBeforeFirstRun();
	while ( ( err = slvfileinfo.ErrMoveNextRun() ) >= JET_errSuccess )
		{
		Call( slvfileinfo.ErrGetCurrentRun( &runSrc ) );
		cbSize += runSrc.m_cbSize;
		}
	Call( err == JET_errNoCurrentRecord ? JET_errSuccess : err );
		
	OSSLVRootSpaceIConsume( slvroot, cbSize );

	//  set the file name for this SLV relative to the SLV Root

	Call( slvfileinfo.ErrGetFileName( &wszFileName, &cwchFileName ) );

#ifdef OSSLV_VOLATILE_FILENAMES
	Call( pslvinfo->ErrSetFileNameVolatile() );
#endif  //  OSSLV_VOLATILE_FILENAMES
	Call( pslvinfo->ErrSetFileName( wszFileName ) );

	//  copy over all the runs, concatenating any contiguous runs

	CallS( pslvinfo->ErrGetHeader( &header ) );
	Assert( !header.cbSize );
	Assert( !header.cRun );
	Call( slvfileinfo.ErrGetFileSize( &cbSize ) );
	header.cbSize = cbSize;

	memset( &runDest, 0, sizeof( runDest ) );

	slvfileinfo.MoveBeforeFirstRun();
	while ( ( err = slvfileinfo.ErrMoveNextRun() ) >= JET_errSuccess )
		{
		//  fetch the current source run
		
		Call( slvfileinfo.ErrGetCurrentRun( &runSrc ) );

		//  this run can be appended to the current destination run

		if ( runSrc.m_ibLogical == runDest.ibLogicalNext )
			{
			//  append the source run to the destination run
			
			runDest.ibVirtualNext	+= runSrc.m_cbSize;
			runDest.cbSize			+= runSrc.m_cbSize;
			runDest.ibLogicalNext	+= runSrc.m_cbSize;
			}

		//  this run cannot be appended to the current destination run

		else
			{
			//  save the current ending virtual offset in the SLV
			
			const QWORD ibVirtual = runDest.ibVirtualNext;

			//  save our changes to the current destination run

			if ( runDest.ibVirtualNext )
				{
				CallS( pslvinfo->ErrMoveAfterLast() );
				Call( pslvinfo->ErrSetCurrentRun( runDest ) );
				}

			//  add a run to the header

			header.cRun++;
			
			//  set the destination run to include the source run

			runDest.ibVirtualNext	= ibVirtual + runSrc.m_cbSize;
			runDest.ibLogical		= runSrc.m_ibLogical;
			runDest.qwReserved		= 0;
			runDest.ibVirtual		= ibVirtual;
			runDest.cbSize			= runSrc.m_cbSize;
			runDest.ibLogicalNext	= runSrc.m_ibLogical + runSrc.m_cbSize;
			}
		}
	Call( err == JET_errNoCurrentRecord ? JET_errSuccess : err );

	//  save our changes to the current destination run

	if ( runDest.ibVirtualNext )
		{
		CallS( pslvinfo->ErrMoveAfterLast() );
		Call( pslvinfo->ErrSetCurrentRun( runDest ) );
		}
	
	//  save our changes to the header

	CallS( pslvinfo->ErrSetHeader( header ) );

	//  there should be enough space to back this file

	if ( header.cbSize > cbSize )
		{
		AssertSzRTL( fFalse, "139131:  Entire SLV File is not backed by pages from the streaming file!" );
		Call( ErrERRCheck( JET_errSLVEAListCorrupt ) );
		}

	//  register this new SLV File with the SLV File Table

	Call( P_SLVROOT( slvroot )->pslvft->ErrCreate( pslvinfo ) );

	//  return the generated SLV Info

	return JET_errSuccess;

HandleError:
	return err;
	}

//  converts the given SLV Info into SLV File Info

ERR ErrOSSLVFileIConvertSLVInfoToSLVFileInfo(	const SLVROOT		slvroot,
												CSLVInfo&			slvinfo,
												CSLVFileInfo* const	pslvfileinfo,
												const BOOL			fSetOpenDeadline	= fFalse,
												const NTSTATUS		statusCommit		= STATUS_SUCCESS )
	{
	ERR					err							= JET_errSuccess;
	QWORD				cbSize						= 0;
	CSLVInfo::HEADER	header;
	CSLVInfo::RUN		runSrc;
	CSLVFileInfo::CRun	runDest;
	size_t				cwchFileName				= IFileSystemAPI::cchPathMax;
	wchar_t				wszFileName[ IFileSystemAPI::cchPathMax ];
	TICK				tickOpenDeadline;
	
	//  copy all runs
	//
	//  NOTE:  we do this before getting the open deadline as this can be costly!

	CallS( slvinfo.ErrMoveBeforeFirst() );
	while ( ( err = slvinfo.ErrMoveNext() ) >= JET_errSuccess )
		{
		Call( slvinfo.ErrGetCurrentRun( &runSrc ) );

		cbSize += runSrc.cbSize;

		const QWORD LengthMax = 0x80000000;
		QWORD ibRun;
		for ( ibRun = 0; ibRun < runSrc.cbSize; ibRun += LengthMax )
			{
			runDest.m_ibLogical	= runSrc.ibLogical + ibRun;
			runDest.m_cbSize	= min( LengthMax, runSrc.cbSize - ibRun );

			err = pslvfileinfo->ErrMoveNextRun();
			Assert( err == JET_errNoCurrentRecord );
			Call( pslvfileinfo->ErrSetCurrentRun( runDest ) );
			}
		}
	Call( err == JET_errNoCurrentRecord ? JET_errSuccess : err );
	
	//  get the current file name and the open deadline for this SLV File from
	//  the SLV File Table
	//
	//  NOTE:  only use the SLV File Table for normal SLV Files, i.e. ones that
	//  are opened for external use

	if ( statusCommit == STATUS_SUCCESS )
		{
		Call( P_SLVROOT( slvroot )->pslvft->ErrOpen(	&slvinfo,
														fSetOpenDeadline,
														&cwchFileName,
														wszFileName,
														&tickOpenDeadline ) );
		}
	else if ( statusCommit == EXSTATUS_SPACE_UNCOMMITTED )
		{
		cwchFileName		= 0;
		wszFileName[ 0 ]	= 0;
		tickOpenDeadline	= 0;
		}
	else
		{
		Call( slvinfo.ErrGetFileNameLength( &cwchFileName ) );
		if ( IFileSystemAPI::cchPathMax < cwchFileName )
			{
			Call( ErrERRCheck( JET_errSLVBufferTooSmall ) );
			}
		Call( slvinfo.ErrGetFileName( wszFileName ) );
		if ( fSetOpenDeadline )
			{
			tickOpenDeadline = TickOSTimeCurrent() + cmsecOSSLVTTL;
			}
		else
			{
			tickOpenDeadline = TickOSTimeCurrent() + cmsecOSSLVTTLInfinite;
			}
		}

	//  set all SLV File Info properties

	Call( pslvfileinfo->ErrSetFileName( wszFileName ) );
	
	Call( pslvfileinfo->ErrSetCommitStatus( statusCommit ) );
	
	Call( pslvfileinfo->ErrSetInstanceID( P_SLVROOT( slvroot )->dwInstanceID ) );
	
	Call( pslvfileinfo->ErrSetOpenDeadline( tickOpenDeadline ) );
	
	CallS( slvinfo.ErrGetHeader( &header ) );
	Call( pslvfileinfo->ErrSetFileSize( header.cbSize ) );

	//  there should be enough space to back this file

	if ( header.cbSize > cbSize )
		{
		AssertSzRTL( fFalse, "139131:  Entire SLV File is not backed by pages from the streaming file!" );
		Call( ErrERRCheck( JET_errSLVCorrupted ) );
		}

	//  return the generated SLV File Info

	err = JET_errSuccess;

HandleError:
	return err;
	}

//  validates and converts the given EA list into SLV Info

ERR ErrOSSLVFileConvertEAToSLVInfo(	const SLVROOT		slvroot,
									const void* const	pffeainf,
									const DWORD			cbffeainf,
									CSLVInfo* const		pslvinfo )
	{
	ERR				err			= JET_errSuccess;
	CSLVFileInfo	slvfileinfo;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  validate IN args

	Assert( slvroot != slvrootNil );
	Assert( pffeainf );
	Assert( cbffeainf );
	Assert( pslvinfo );

	//  load the given EA List into an SLV File Info iterator.  the iterator
	//  will validate the EA List on load

	Call( slvfileinfo.ErrLoad( pffeainf, cbffeainf ) );

	//  convert the SLV File Info into SLV Info

	Call( ErrOSSLVFileIConvertSLVFileInfoToSLVInfo( slvroot, slvfileinfo, pslvinfo ) );

	//  return the generated SLV Info

	slvfileinfo.Unload();
	return JET_errSuccess;

HandleError:
	slvfileinfo.Unload();
	return err;
	}

//  converts the given SLV Info into an EA list

ERR ErrOSSLVFileConvertSLVInfoToEA(	const SLVROOT	slvroot,
									CSLVInfo&		slvinfo,
									const DWORD		ibOffset,
									void* const		pffeainf,
									const DWORD		cbffeainfMax,
									DWORD* const	pcbffeainfActual )
	{
	ERR				err			= JET_errSuccess;
	CSLVFileInfo	slvfileinfo;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  create an empty SLV File Info to receive the converted data

	Call( slvfileinfo.ErrCreate() );

	//  convert the given SLV Info into SLV File Info, give the SLV File Info
	//  an expiration time, and enable copy-on-write

	Call( ErrOSSLVFileIConvertSLVInfoToSLVFileInfo(	slvroot,
													slvinfo,
													&slvfileinfo,
													fTrue ) );

	//  if we can't perform a simple copy of the EA List data into the user's
	//  buffer then fail the transfer with EA List too big.  this will force
	//  them to refetch the SLV File as a handle.  in that case, we will be
	//  able to handle the retrieval because we will still have the SLV File
	//  Info when the handle is created

	if ( !slvfileinfo.FEAListIsSelfDescribing() )
		{
		Call( ErrERRCheck( JET_errSLVEAListTooBig ) );
		}

	//  copy the requested chunk of the EA List into the user's buffer according
	//  to JetRetrieveColumn() rules for LVs

	size_t	cbffeainfBuf;
	void*	pffeainfBuf;
	Call( slvfileinfo.ErrGetEAList( &pffeainfBuf, &cbffeainfBuf ) );

	if ( ibOffset > cbffeainfBuf )
		{
		if ( pcbffeainfActual )
			{
			*pcbffeainfActual = 0;
			}
		}
	else
		{
		if ( pcbffeainfActual )
			{
			*pcbffeainfActual = DWORD( cbffeainfBuf - ibOffset );
			}
		if ( cbffeainfBuf - ibOffset > cbffeainfMax )
			{
			err = ErrERRCheck( JET_wrnBufferTruncated );
			}

		if ( pffeainfBuf != pffeainf )
			{
			UtilMemCpy(	pffeainf,
						(BYTE*)pffeainfBuf + ibOffset,
						min( cbffeainfMax, cbffeainfBuf - ibOffset ) );
			}
		else
			{
			Assert( !ibOffset );
			}
		}

HandleError:
	slvfileinfo.Unload();
	return err;
	}

//  converts the given SLV Info into an SLV File

ERR ErrOSSLVFileConvertSLVInfoToFile(	const SLVROOT	slvroot,
										CSLVInfo&		slvinfo,
										const DWORD		ibOffset,
										void* const		pfile,
										const DWORD		cbfileMax,
										DWORD* const	pcbfileActual )
	{
	ERR				err			= JET_errSuccess;
	CSLVFileInfo	slvfileinfo;
	size_t			cwchRelPath;
	wchar_t*		wszRelPath;
	size_t			cbffeainf;
	void*			pffeainf;
	WCHAR			wszAbsPath[ IFileSystemAPI::cchPathMax ];
	HANDLE			hFile		= INVALID_HANDLE_VALUE;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  validate the input buffer

	if ( ibOffset || !pfile || cbfileMax < sizeof( HANDLE ) )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	//  create an empty SLV File Info to receive the converted data

	Call( slvfileinfo.ErrCreate() );

	//  convert the given SLV Info into SLV File Info, give the SLV File Info
	//  no expiration time, and enable copy-on-write

	Call( ErrOSSLVFileIConvertSLVInfoToSLVFileInfo(	slvroot,
													slvinfo,
													&slvfileinfo ) );

	//  get the file name and EA List for this SLV File

	Call( slvfileinfo.ErrGetFileName( &wszRelPath, &cwchRelPath ) );
	Call( slvfileinfo.ErrGetEAList( &pffeainf, &cbffeainf ) );

	//  get the absolute path for the file to create

	wcscpy( wszAbsPath, P_SLVROOT( slvroot )->wszRootName );
	wcscat( wszAbsPath, L"\\" );
	wcscat( wszAbsPath, wszRelPath );

	//  create the file handle from the EA List
	
	hFile = pfnIfsCreateFile(	wszAbsPath,
								GENERIC_READ,
								FILE_SHARE_READ | FILE_SHARE_WRITE,
								NULL,
								OPEN_ALWAYS,
								(	FILE_ATTRIBUTE_NORMAL |
									FILE_FLAG_WRITE_THROUGH |
									FILE_FLAG_OVERLAPPED ), 
								(PVOID) pffeainf,
								cbffeainf );
	if ( hFile == INVALID_HANDLE_VALUE )
		{
		Call( ErrOSSLVFileIGetLastError() );
		}

	//  return the file handle

	memcpy( (BYTE*)pfile, (BYTE*)&hFile, sizeof( HANDLE ) );
	if ( pcbfileActual )
		{
		*pcbfileActual = sizeof( HANDLE );
		}
	hFile = INVALID_HANDLE_VALUE;

HandleError:
	if ( hFile != INVALID_HANDLE_VALUE )
		{
		CloseHandle( hFile );
		}
	slvfileinfo.Unload();
	return err;
	}


//	WARNING!!	This function may allocate a new buffer if the one passed in
//				is not large enough.
INLINE ERR ErrOSSLVFileIQueryEaFile(
	const SLVROOT	slvroot,
	IFileAPI* const pfapi,
	BYTE**			pEaOutBuffer,
	DWORD			EaOutLength,
	DWORD*			pActualLength,
	const BOOL		fCommit )
	{
	ERR				err;
	COSFile* const	posf				= (COSFile*)pfapi;
	BYTE*			EaOutBuffer			= *pEaOutBuffer;
	DWORD			RequiredLength		= 0;
	UINT			cAttempts			= 0;

	forever
		{
		err = JET_errSuccess;

		//	this loop should converge pretty quickly
		AssertRTL( ++cAttempts < 10 );

#ifdef DEBUG
		memset( EaOutBuffer, 0xEA, EaOutLength );
#endif

		if ( !pfnIfsQueryEaFile(
					posf->Handle(),
					NULL,
					P_SLVROOT( slvroot )->wszRootName,
					( fCommit ? &P_SLVROOT( slvroot )->fgeainf : NULL ),
					( fCommit ? P_SLVROOT( slvroot )->cbfgeainf : 0 ),
					EaOutBuffer,
					EaOutLength,
					&RequiredLength ) )
			{
			err = ErrOSSLVFileIGetLastError();
			}

		if ( err >= JET_errSuccess )	//	not expecting any warnings, but better to be safe than sorry
			{
			CallS( err );
			break;
			}

		//	free current buffer (after which we will either retry or err out)
		if ( EaOutBuffer != *pEaOutBuffer )
			{
			OSMemoryHeapFree( EaOutBuffer );
			}

		if ( JET_errSLVBufferTooSmall == err )
			{
			//  Allocate a larger buffer and try again.
			//	We add a fudge factor to the new buffer size for two reasons:
			//		1) In case the EA list changes between the previous call to
			//		   QueryEAFile() and the next one
			//		2) BUGFIX #151178: size returned by previous call to QueryEAFile
			//		   may not be accurate
			EaOutLength = RequiredLength * 3 / 2 ;
			if ( !( EaOutBuffer = (BYTE*)PvOSMemoryHeapAlloc( EaOutLength ) ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
			}
		else
			{
			//	on any other error (warnings not expected), bail out
			Assert( err < 0 );
			goto HandleError;
			}
		}

	CallS( err );
	*pEaOutBuffer = EaOutBuffer;
	*pActualLength = RequiredLength;

HandleError:
	return err;
	}

ERR ErrOSSLVFileIGetSLVInfo(	const SLVROOT		slvroot,
								IFileAPI* const		pfapi,
								CSLVInfo* const		pslvinfo )
	{
	ERR				err					= JET_errSuccess;
	COSFile* const	posf				= (COSFile*)pfapi;
	const DWORD		_EaOutLength		= 1024;
	QWORD			_AlignedEaOutBuffer[ _EaOutLength / sizeof( QWORD ) + 1 ];
	BYTE*			_EaOutBuffer		= (BYTE*)PvOSSLVQwordAlign( _AlignedEaOutBuffer );
	BYTE*			EaOutBuffer			= _EaOutBuffer;
	DWORD			ActualLength		= 0;
	CSLVFileInfo	slvfileinfo;

	//  try to fetch EA list with a buffer large enough to catch most cases

	Call( ErrOSSLVFileIQueryEaFile(
					slvroot,
					pfapi,
					&EaOutBuffer,
					_EaOutLength,
					&ActualLength,
					fTrue ) );

	//  load the given EA List into an SLV File Info iterator.  the iterator
	//  will validate the EA List on load

	Call( slvfileinfo.ErrLoad( EaOutBuffer, ActualLength ) );

	//  convert the SLV File Info into SLV Info

	Call( ErrOSSLVFileIConvertSLVFileInfoToSLVInfo( slvroot, slvfileinfo, pslvinfo ) );

HandleError:
	if ( EaOutBuffer != _EaOutBuffer )	
		{
		OSMemoryHeapFree( EaOutBuffer );
		}
	slvfileinfo.Unload();
	return err;
	}

ERR ErrOSSLVFileIGetEAFileName(	const SLVROOT		slvroot,
								IFileAPI* const		pfapi,
								wchar_t* const		wszFileName )
	{
	ERR				err					= JET_errSuccess;
	COSFile* const	posf				= (COSFile*)pfapi;
	const DWORD		_EaOutLength		= 1024;
	QWORD			_AlignedEaOutBuffer[ _EaOutLength / sizeof( QWORD ) + 1 ];
	BYTE*			_EaOutBuffer		= (BYTE*)PvOSSLVQwordAlign( _AlignedEaOutBuffer );
	BYTE*			EaOutBuffer			= _EaOutBuffer;
	DWORD			ActualLength		= 0;
	CSLVFileInfo	slvfileinfo;
	wchar_t*		wszEAFileName		= NULL;
	size_t			cwchEAFileName		= 0;

	//  try to fetch EA list with a buffer large enough to catch most cases

	Call( ErrOSSLVFileIQueryEaFile(
					slvroot,
					pfapi,
					&EaOutBuffer,
					_EaOutLength,
					&ActualLength,
					fFalse ) );

	//  load the given EA List into an SLV File Info iterator.  the iterator
	//  will validate the EA List on load

	Call( slvfileinfo.ErrLoad( EaOutBuffer, ActualLength, fFalse ) );

	//  retrieve the EA filename

	Call( slvfileinfo.ErrGetFileName( &wszEAFileName, &cwchEAFileName ) );
	wcscpy( wszFileName, wszEAFileName );

HandleError:
	if ( EaOutBuffer != _EaOutBuffer )	
		{
		OSMemoryHeapFree( EaOutBuffer );
		}
	slvfileinfo.Unload();
	return err;
	}

//  retrieves the SLV Info of the specified SLV file into the given buffer.
//  any space returned will be considered reserved by the SLV Provider.  this
//  space must be committed via ErrOSSLVRootSpaceCommit() or it will eventually
//  be freed when it is safe via the PSLVROOT_SPACEFREE callback

ERR ErrOSSLVFileGetSLVInfo(	const SLVROOT		slvroot,
							IFileAPI* const		pfapi,
							CSLVInfo* const		pslvinfo )
	{
	ERR					err			= JET_errSuccess;
	static long			cSpace		= 0;
	wchar_t				wszSpace[ IFileSystemAPI::cchPathMax ];
	IFileAPI*			pfapiSpace	= NULL;
	CSLVInfo::HEADER	header;
	wchar_t				wszFileName[ IFileSystemAPI::cchPathMax ];

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  try to get the SLV Info for the specified SLV File

	err = ErrOSSLVFileIGetSLVInfo( slvroot, pfapi, pslvinfo );

	//  we couldn't get the SLV Info because this file has no allocated space

	if ( err == JET_errSLVEAListZeroAllocation )
		{
		//  get the EA filename for this SLV File

		Call( ErrOSSLVFileIGetEAFileName( slvroot, pfapi, wszFileName ) );
		
		//  create a SLV File with the minimum amount of space

		swprintf( wszSpace, L"$Space%08X$", AtomicIncrement( &cSpace ) );
		Call( ErrOSSLVFileCreate( slvroot, wszSpace, SLVPAGE_SIZE, &pfapiSpace ) );

		//  get the SLV Info for the temporary SLV File
		
		Call( ErrOSSLVFileIGetSLVInfo( slvroot, pfapiSpace, pslvinfo ) );

		//  change the temporary SLV File to be a zero-length SLV File to
		//  match the original SLV File
		
		CallS( pslvinfo->ErrGetHeader( &header ) );
		header.cbSize = 0;
		CallS( pslvinfo->ErrSetHeader( header ) );

		//  rename the zero-length SLV File to the EA filename of the original
		//  SLV File in the SLV File Table to associate its space with the
		//  original SLV File

		Call( P_SLVROOT( slvroot )->pslvft->ErrRename( pslvinfo, wszFileName ) );

		//  set the filename in the SLV Info for the zero-length SLV File to
		//  the EA filename of the original SLV File and return that as the
		//  SLV Info for the original SLV File
		
		Call( pslvinfo->ErrSetFileName( wszFileName ) );
		}

	//  if we failed to retrieve the SLV Info, fail the operation

	Call( err );

HandleError:
	delete pfapiSpace;
	return err;
	}

//  creates a new SLV file with the specified path relative to the specified
//  SLV root and returns its handle.  if the file cannot be created,
//  JET_errSLVFileAccessDenied will be returned

ERR ErrOSSLVFileCreate(	const SLVROOT			slvroot,
						const wchar_t* const	wszRelPath,
						const QWORD				cbFileSize,
						IFileAPI** const		ppfapi,
						const BOOL				fCache )
	{
	ERR			err			= JET_errSuccess;
	COSFile*	posf		= NULL;
	WCHAR		wszAbsPath[ IFileSystemAPI::cchPathMax ];
	_TCHAR		szAbsPath[ IFileSystemAPI::cchPathMax ];
	HANDLE		hFile		= INVALID_HANDLE_VALUE;
	DWORD		cbIOSize;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  allocate the file object
	
	if ( !( posf = new COSFile ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  get the absolute path for the file to create

	wcscpy( wszAbsPath, P_SLVROOT( slvroot )->wszRootName );
	wcscat( wszAbsPath, L"\\" );
	wcscat( wszAbsPath, wszRelPath );

	Call( ErrOSSTRUnicodeToTchar( wszAbsPath, szAbsPath, IFileSystemAPI::cchPathMax ) );

	//  create the file, passing an empty EA List to the SLV Provider to indicate
	//  that this is a new SLV file
	
	hFile = pfnIfsCreateFile(	wszAbsPath,
								GENERIC_READ | GENERIC_WRITE, 
								FILE_SHARE_READ | FILE_SHARE_WRITE,
								NULL,
								CREATE_NEW,
								(	FILE_ATTRIBUTE_NORMAL |
									FILE_FLAG_WRITE_THROUGH |
									( fCache ? FILE_FLAG_SEQUENTIAL_SCAN : FILE_FLAG_NO_BUFFERING ) |
									FILE_FLAG_OVERLAPPED ), 
								NULL,
								0 );
	if ( hFile == INVALID_HANDLE_VALUE )
		{
		Call( ErrOSSLVFileIGetLastError() );
		}

	SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	//  set the initial file size.  this will force the SLV Provider to allocate
	//  enough space to back the file.  it is optimal to do it this way because
	//  we do not want to set the file size via the file object because the file
	//  object will zero the new offset range in the file

	if ( cbFileSize > 0 )
		{
		DWORD	cbSizeLow	= DWORD( cbFileSize );
		DWORD	cbSizeHigh	= DWORD( cbFileSize >> 32 );
		
		if (	(	SetFilePointer(	hFile,
									cbSizeLow,
									(long*)&cbSizeHigh,
									FILE_BEGIN ) == INVALID_SET_FILE_POINTER &&
					GetLastError() != NO_ERROR ) ||
				!SetEndOfFile( hFile ) )
			{
			Call( ErrOSSLVFileIGetLastError() );
			}
		}

	//  get the file I/O size

	if ( fCache )
		{
		cbIOSize = 1;
		}
	else
		{
		Call( P_SLVROOT( slvroot )->pfapiBackingFile->ErrIOSize( &cbIOSize ) );
		}

	//  initialize the file object

	Call( posf->ErrInit( szAbsPath, hFile, cbFileSize, fFalse, cbIOSize ) );
	hFile = INVALID_HANDLE_VALUE;

	//  return the interface to our file object

	*ppfapi = posf;
	return JET_errSuccess;

HandleError:
	if ( hFile != INVALID_HANDLE_VALUE )
		{
		SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hFile );
		}
	delete posf;
	*ppfapi = NULL;
	return err;
	}

//  opens the SLV file corresponding to the given SLV Info with the specified
//  access privileges and returns its handle.  if the file cannot be opened,
//  JET_errSLVFileAccessDenied is returned

ERR ErrOSSLVFileOpen(	const SLVROOT		slvroot,
						CSLVInfo&			slvinfo,
						IFileAPI** const	ppfapi,
						const BOOL			fCache,
						const BOOL			fReadOnly )
	{
	ERR				err			= JET_errSuccess;
	CSLVFileInfo	slvfileinfo;
	size_t			cwchRelPath;
	wchar_t*		wszRelPath;
	size_t			cbffeainf;
	void*			pffeainf;
	COSFile*		posf		= NULL;
	WCHAR			wszAbsPath[ IFileSystemAPI::cchPathMax ];
	_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
	HANDLE			hFile		= INVALID_HANDLE_VALUE;
	QWORD			cbFileSize;
	DWORD			cbIOSize;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  allocate the file object
	
	if ( !( posf = new COSFile ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  create an empty SLV File Info to receive the converted data

	Call( slvfileinfo.ErrCreate() );

	//  convert the given SLV Info into SLV File Info, give the SLV File Info
	//  no expiration time, and disable copy-on-write

	Call( ErrOSSLVFileIConvertSLVInfoToSLVFileInfo(	slvroot,
													slvinfo,
													&slvfileinfo,
													fFalse,
													EXSTATUS_PRIVILEGED_HANDLE ) );

	//  get the file name and EA List for this SLV File

	Call( slvfileinfo.ErrGetFileName( &wszRelPath, &cwchRelPath ) );
	Call( slvfileinfo.ErrGetEAList( &pffeainf, &cbffeainf ) );

	//  get the absolute path for the file to create

	wcscpy( wszAbsPath, P_SLVROOT( slvroot )->wszRootName );
	wcscat( wszAbsPath, L"\\" );
	wcscat( wszAbsPath, wszRelPath );

	Call( ErrOSSTRUnicodeToTchar( wszAbsPath, szAbsPath, IFileSystemAPI::cchPathMax ) );

	//  create the file, passing the generated EA List to the SLV Provider
	
	hFile = pfnIfsCreateFile(	wszAbsPath,
								GENERIC_READ | ( fReadOnly ? 0 : GENERIC_WRITE ),
								FILE_SHARE_READ | FILE_SHARE_WRITE,
								NULL,
								OPEN_ALWAYS,
								(	FILE_ATTRIBUTE_NORMAL |
									FILE_FLAG_WRITE_THROUGH |
									( fCache ? FILE_FLAG_SEQUENTIAL_SCAN : FILE_FLAG_NO_BUFFERING ) |
									FILE_FLAG_OVERLAPPED ), 
								(PVOID) pffeainf,
								cbffeainf );
	if ( hFile == INVALID_HANDLE_VALUE )
		{
		Call( ErrOSSLVFileIGetLastError() );
		}

	SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	//  get the file size

	Call( slvfileinfo.ErrGetFileSize( &cbFileSize ) );

	//  get the file I/O size

	if ( fCache )
		{
		cbIOSize = 1;
		}
	else
		{
		Call( P_SLVROOT( slvroot )->pfapiBackingFile->ErrIOSize( &cbIOSize ) );
		}

	//  initialize the file object

	Call( posf->ErrInit( szAbsPath, hFile, cbFileSize, fFalse, cbIOSize ) );
	hFile = INVALID_HANDLE_VALUE;

	//  return the interface to our file object

	*ppfapi = posf;
	slvfileinfo.Unload();
	return JET_errSuccess;

HandleError:
	if ( hFile != INVALID_HANDLE_VALUE )
		{
		SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hFile );
		}
	delete posf;
	*ppfapi = NULL;
	slvfileinfo.Unload();
	return err;
	}

ERR ErrOSSLVFileOpen(	const SLVROOT		slvroot,
						const void* const	pfile,
						const size_t		cbfile,
						IFileAPI** const	ppfapi,
						const BOOL			fReadOnly )
	{
	ERR			err					= JET_errSuccess;
	COSFile*	posf				= NULL;
	WCHAR		wszAbsPath[ IFileSystemAPI::cchPathMax ];
	_TCHAR		szAbsPath[ IFileSystemAPI::cchPathMax ];
	HANDLE		hFileSrc			= INVALID_HANDLE_VALUE;
	HANDLE		hFile				= INVALID_HANDLE_VALUE;
	DWORD		cbFileSizeLow;
	DWORD		cbFileSizeHigh;
	QWORD		cbFileSize;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  get the source file handle from the input buffer

	if ( !pfile || cbfile != sizeof( HANDLE ) )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	memcpy( (BYTE*)&hFileSrc, pfile, sizeof( HANDLE ) );

	//  allocate the file object
	
	if ( !( posf = new COSFile ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  get the absolute path for the file to create
	//
	//  NOTE:  we actually don't know this so make one up

	wcscpy( wszAbsPath, P_SLVROOT( slvroot )->wszRootName );
	wcscat( wszAbsPath, L"\\" );
	wcscat( wszAbsPath, L"$Unknown$" );

	Call( ErrOSSTRUnicodeToTchar( wszAbsPath, szAbsPath, IFileSystemAPI::cchPathMax ) );

	//  duplicate the file handle to preserve open / close semantics

	if ( !DuplicateHandle(	GetCurrentProcess(),
							hFileSrc,
							GetCurrentProcess(),
							&hFile,
							GENERIC_READ | ( fReadOnly ? 0 : GENERIC_WRITE ),
							FALSE,
							0 ) )
		{
		hFile = INVALID_HANDLE_VALUE;
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	//  get the file size and attributes

	if (	( cbFileSizeLow = GetFileSize(	hFile,
											&cbFileSizeHigh ) ) == -1 &&
			GetLastError() != NO_ERROR )
		{
		Call( ErrERRCheck( ErrOSSLVFileIGetLastError() ) );
		}
	cbFileSize	= ( QWORD( cbFileSizeHigh ) << 32 ) + cbFileSizeLow;

	//  initialize the file object

	err = posf->ErrInit( szAbsPath, hFile, cbFileSize, fReadOnly );

	//  we successfully inited the file object

	if ( err >= JET_errSuccess )
		{
		//  the file object owns the handle now
		
		hFile = INVALID_HANDLE_VALUE;
		}

	//  we failed to init the file object

	else
		{
		//  we will guess that the init failed because the file was already
		//  associated with a completion port.  we will try again with a new
		//  file handle that we get by doing a relative open on the existing
		//  file handle (required as we don't know its file name)

		if ( fUseRelativeOpen )
			{
			SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
			CloseHandle( hFile );
			hFile = INVALID_HANDLE_VALUE;
			
			delete posf;  //  remember, we cannot reuse the file object!!!
			posf = NULL;

			if ( !( posf = new COSFile ) )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}

			UNICODE_STRING FileName;
		    pfnRtlInitUnicodeString( &FileName, L"" );
		    
			OBJECT_ATTRIBUTES ObjectAttributes;
		    InitializeObjectAttributes(	&ObjectAttributes,
									    &FileName,
									    OBJ_CASE_INSENSITIVE,
									    hFileSrc,
									    NULL );

			IO_STATUS_BLOCK IoStatusBlock;
			NTSTATUS Status;
		    Status = pfnNtCreateFile(	&hFile,
										GENERIC_READ | ( fReadOnly ? 0 : GENERIC_WRITE ),
										&ObjectAttributes,
										&IoStatusBlock,
										NULL,
										FILE_ATTRIBUTE_NORMAL,
										FILE_SHARE_READ | FILE_SHARE_WRITE,
										FILE_OPEN,
										FILE_WRITE_THROUGH | FILE_SEQUENTIAL_ONLY,
										NULL,
										0 );

			if ( !NT_SUCCESS( Status ) )
				{
				Call( ErrOSSLVFileINTStatus( Status ) );
				}

			SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

			if (	( cbFileSizeLow = GetFileSize(	hFile,
													&cbFileSizeHigh ) ) == -1 &&
					GetLastError() != NO_ERROR )
				{
				Call( ErrERRCheck( ErrOSSLVFileIGetLastError() ) );
				}
			cbFileSize	= ( QWORD( cbFileSizeHigh ) << 32 ) + cbFileSizeLow;

			Call( posf->ErrInit( szAbsPath, hFile, cbFileSize, fReadOnly ) );
			hFile = INVALID_HANDLE_VALUE;
			}

		//  we cannot use relative open to resolve this error so fail

		else
			{
			Call( err );
			}
		}

	//  return the interface to our file object

	*ppfapi = posf;
	return JET_errSuccess;

HandleError:
	if ( hFile != INVALID_HANDLE_VALUE )
		{
		SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hFile );
		}
	delete posf;
	*ppfapi = NULL;
	return err;
	}

//  logically copies the contents of one SLV File to another SLV File.  the
//  contents are tracked using the specified unique identifier

ERR ErrOSSLVRootCopyFile(	const SLVROOT	slvroot,
							IFileAPI* const	pfapiSrc,
							CSLVInfo&		slvinfoSrc,
							IFileAPI* const	pfapiDest,
							CSLVInfo&		slvinfoDest,
							const QWORD		idContents )
	{
	ERR				err			= JET_errSuccess;
	CSLVFileInfo	slvfileinfo;
	size_t			cwchRelPath;
	wchar_t*		wszRelPath;
	size_t			cbffeainf;
	void*			pffeainf;
	WCHAR			wszAbsPath[ IFileSystemAPI::cchPathMax ];
	COSFile* const	posfDest	= (COSFile*)pfapiDest;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  perform the logical copy via the SLV File Table

	Call( P_SLVROOT( slvroot )->pslvft->ErrCopy( &slvinfoSrc, &slvinfoDest, idContents ) );

	//  create an empty SLV File Info to receive the converted data

	Call( slvfileinfo.ErrCreate() );

	//  convert the given SLV Info into SLV File Info, give the SLV File Info
	//  no expiration time, and enable copy-on-write

	Call( ErrOSSLVFileIConvertSLVInfoToSLVFileInfo(	slvroot,
													slvinfoDest,
													&slvfileinfo ) );

	//  get the file name and EA List for this SLV File

	Call( slvfileinfo.ErrGetFileName( &wszRelPath, &cwchRelPath ) );
	Call( slvfileinfo.ErrGetEAList( &pffeainf, &cbffeainf ) );

	//  get the absolute path for the file

	wcscpy( wszAbsPath, P_SLVROOT( slvroot )->wszRootName );
	wcscat( wszAbsPath, L"\\" );
	wcscat( wszAbsPath, wszRelPath );

	//  notify the SLV Provider of the copy

	if ( !pfnIfsFlushHandle(	posfDest->Handle(),
								wszAbsPath,
								P_SLVROOT( slvroot )->wszRootName,
								pffeainf,
								DWORD( cbffeainf ) ) )
		{
		Call( ErrOSSLVFileIGetLastError() );
		}

HandleError:
	slvfileinfo.Unload();
	return err;
	}

//  logically moves the contents of one SLV File to another SLV File.  the
//  contents are tracked using the specified unique identifier

ERR ErrOSSLVRootMoveFile(	const SLVROOT	slvroot,
							IFileAPI* const	pfapiSrc,
							CSLVInfo&		slvinfoSrc,
							IFileAPI* const	pfapiDest,
							CSLVInfo&		slvinfoDest,
							const QWORD		idContents )
	{
	ERR				err			= JET_errSuccess;
	CSLVFileInfo	slvfileinfo;
	size_t			cwchRelPath;
	wchar_t*		wszRelPath;
	size_t			cbffeainf;
	void*			pffeainf;
	WCHAR			wszAbsPath[ IFileSystemAPI::cchPathMax ];
	COSFile* const	posfDest	= (COSFile*)pfapiDest;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  perform the logical move via the SLV File Table

	Call( P_SLVROOT( slvroot )->pslvft->ErrMove( &slvinfoSrc, &slvinfoDest, idContents ) );

	//  create an empty SLV File Info to receive the converted data

	Call( slvfileinfo.ErrCreate() );

	//  convert the given SLV Info into SLV File Info, give the SLV File Info
	//  no expiration time, and enable copy-on-write

	Call( ErrOSSLVFileIConvertSLVInfoToSLVFileInfo(	slvroot,
													slvinfoDest,
													&slvfileinfo ) );

	//  get the file name and EA List for this SLV File

	Call( slvfileinfo.ErrGetFileName( &wszRelPath, &cwchRelPath ) );
	Call( slvfileinfo.ErrGetEAList( &pffeainf, &cbffeainf ) );

	//  get the absolute path for the file

	wcscpy( wszAbsPath, P_SLVROOT( slvroot )->wszRootName );
	wcscat( wszAbsPath, L"\\" );
	wcscat( wszAbsPath, wszRelPath );

	//  notify the SLV Provider of the move

	if ( !pfnIfsFlushHandle(	posfDest->Handle(),
								wszAbsPath,
								P_SLVROOT( slvroot )->wszRootName,
								pffeainf,
								DWORD( cbffeainf ) ) )
		{
		Call( ErrOSSLVFileIGetLastError() );
		}

HandleError:
	slvfileinfo.Unload();
	return err;
	}

//  callback indicating that the current layout changes to the backing file
//  have ended and that the root map needs to be updated

void OSSLVRootSpaceIEndRemap( IFileAPI* const pfapi, const SLVROOT slvroot )
	{
	ERR					err			= JET_errSuccess;
	CSLVFileInfo		slvfileinfo;
	IFileLayoutAPI*		pflapi		= NULL;
	size_t				cbslist;
	SCATTER_LIST*		pslist;

	//  create an empty SLV File Info to receive the converted data

	Call( slvfileinfo.ErrCreate() );

	//  fill the SLV File Info with the layout of the backing file

	Call( pfapi->ErrQueryLayout( 0, -1, &pflapi ) );
	while ( ( err = pflapi->ErrNext() ) >= JET_errSuccess )
		{
		QWORD				ibVirtual;
		QWORD				cbVirtualSize;
		QWORD				ibLogical;
		QWORD				cbLogicalSize;
		QWORD				ibRun;
		const QWORD			LengthMax	= 0x80000000;
		CSLVFileInfo::CRun	runDest;
		
		Call( pflapi->ErrVirtualOffsetRange( &ibVirtual, &cbVirtualSize ) );
		Call( pflapi->ErrLogicalOffsetRange( &ibLogical, &cbLogicalSize ) );

		if ( cbVirtualSize != cbLogicalSize && cbLogicalSize != 0 )
			{
			Call( ErrERRCheck( JET_errSLVCorrupted ) );
			}

		for ( ibRun = 0; ibRun < cbVirtualSize; ibRun += LengthMax )
			{
			runDest.m_ibLogical	= (	cbLogicalSize ?
										ibLogical + ibRun :
										0xABAD1DEA00000000 );
			runDest.m_cbSize	= min( LengthMax, cbVirtualSize - ibRun );

			err = slvfileinfo.ErrMoveNextRun();
			Assert( err == JET_errNoCurrentRecord );
			Call( slvfileinfo.ErrSetCurrentRun( runDest ) );
			}
		}
	Call( err == JET_errNoCurrentRecord ? JET_errSuccess : err );

	delete pflapi;
	pflapi = NULL;

	//  get the Scatter List for the backing file for this root
	
	Call( slvfileinfo.ErrGetScatterList( (void**)&pslist, &cbslist ) );

	//  send the backing file layout to the SLV Provider and unfreeze I/O to
	//  the backing file

	if ( !pfnIfsSetRootMap(	P_SLVROOT( slvroot )->hFileRoot,
							P_SLVROOT( slvroot )->wszRootName,
							pslist,
							cbslist ) )
		{
		Call( ErrOSSLVRootIGetLastError() );
		}

HandleError:
	//  UNDONE:  what do we do on an error?
	slvfileinfo.Unload();
	delete pflapi;
	}

//  callback indicating that the current layout of the backing file is about
//  to change

void OSSLVRootSpaceIBeginRemap( IFileAPI* const pfapi, const SLVROOT slvroot )
	{
	ERR err = JET_errSuccess;
	
	//  freeze I/O to the backing file and invalidate its layout

	if ( !pfnIfsResetRootMap(	P_SLVROOT( slvroot )->hFileRoot,
								P_SLVROOT( slvroot )->wszRootName ) )
		{
		Call( ErrOSSLVRootIGetLastError() );
		}

HandleError:
	//  UNDONE:  what do we do on an error?
	;
	}

//  issues a space request from the SLV Provider

void WINAPI OSSLVRootSpaceIRequest( SLVROOT slvroot )
	{
	//  BUGBUG:  the SLV Provider should specify the amount of space requested

	const QWORD cbReserve = cbOSSLVReserve;
	
	//  we are not terminating the space request loop

	if ( !P_SLVROOT( slvroot )->msigTerm.FTryWait() )
		{
		//  we do not already have a space request pending

		if ( P_SLVROOT( slvroot )->semSpaceReq.FTryAcquire() )
			{
			//  allow one space request completion to match this space request

			P_SLVROOT( slvroot )->semSpaceReqComp.Release();
			
			//  fire the space request callback

			P_SLVROOT( slvroot )->pfnSpaceReq(	P_SLVROOT( slvroot )->dwSpaceReqKey,
												cbReserve );
			}
		}

	//  we are terminating the space request loop

	else
		{
		//  signal that the space request loop has stopped

		P_SLVROOT( slvroot )->msigTermAck.Set();
		}
	}

//  completes a space request from the SLV Provider

void OSSLVRootSpaceIRequestComplete( SLVROOT slvroot )
	{
	//  we are not terming the SLV Root

	if ( !P_SLVROOT( slvroot )->msigTerm.FTryWait() )
		{
		//  we do not already have a space request completion pending

		if ( P_SLVROOT( slvroot )->semSpaceReqComp.FTryAcquire() )
			{
			//  allow one space request to match this space request completion

			P_SLVROOT( slvroot )->semSpaceReq.Release();
			
			//  pend another space request
			
			pfnIfsSpaceRequestRoot(	P_SLVROOT( slvroot )->hFileRoot,
									P_SLVROOT( slvroot )->wszRootName, 
									PFN_IFSCALLBACK( OSSLVRootSpaceIRequest ),
									PVOID( slvroot ), 
									NULL );
			}
		}
	}

//  notes the amount of reserved space granted to the SLV Provider

void OSSLVRootSpaceIProduce( SLVROOT slvroot, QWORD cbSize )
	{
	AtomicAdd( (QWORD*)&P_SLVROOT( slvroot )->cbGrant, cbSize );
	}

//  notes the amount of reserved space committed to the SLV Provider

void OSSLVRootSpaceIConsume( SLVROOT slvroot, QWORD cbSize )
	{
	AtomicAdd( (QWORD*)&P_SLVROOT( slvroot )->cbCommit, cbSize );
	}

//  reserves the space in the given SLV Info for an SLV Root

ERR ErrOSSLVRootSpaceReserve( const SLVROOT slvroot, CSLVInfo& slvinfo )
	{
	ERR					err			= JET_errSuccess;
	CSLVFileInfo		slvfileinfo;
	CSLVFileInfo::CRun	runSrc;
	size_t				cbslist;
	SCATTER_LIST*		pslist;
	QWORD				cbSize		= 0;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  create an empty SLV File Info to receive the converted data

	Call( slvfileinfo.ErrCreate() );

	//  convert the SLV Info into SLV File Info, giving it no open deadline and
	//  flagging all the space as reserved

	Call( ErrOSSLVFileIConvertSLVInfoToSLVFileInfo(	slvroot,
													slvinfo,
													&slvfileinfo,
													fFalse,
													EXSTATUS_SPACE_UNCOMMITTED ) );

	//  get the Scatter List for this SLV File
	
	Call( slvfileinfo.ErrGetScatterList( (void**)&pslist, &cbslist ) );

	//  send the reserved space to the SLV Provider

	if ( !pfnIfsSpaceGrantRoot(	P_SLVROOT( slvroot )->hFileRoot,
								P_SLVROOT( slvroot )->wszRootName,
								pslist,
								cbslist ) )
		{
		Call( ErrOSSLVRootIGetLastError() );
		}

	//  note the amount of reserved space we have successfully granted to the
	//  SLV Provider

	slvfileinfo.MoveBeforeFirstRun();
	while ( ( err = slvfileinfo.ErrMoveNextRun() ) >= JET_errSuccess )
		{
		Call( slvfileinfo.ErrGetCurrentRun( &runSrc ) );
		cbSize += runSrc.m_cbSize;
		}
	Call( err == JET_errNoCurrentRecord ? JET_errSuccess : err );
		
HandleError:
	OSSLVRootSpaceIProduce( slvroot, cbSize );
	OSSLVRootSpaceIRequestComplete( slvroot );
	slvfileinfo.Unload();
	return err;
	}
	
//  commits the space in the given SLV Info for an SLV Root.  only space that
//  is reserved for a particular SLV File may be committed in this way.  SLV File
//  space MUST be committed in this way or it will later be freed when it is safe
//  via the PSLVROOT_SPACEFREE callback

ERR ErrOSSLVRootSpaceCommit( const SLVROOT slvroot, CSLVInfo& slvinfo )
	{
	ERR err = JET_errSuccess;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  commit the space in this SLV Info for the associated SLV File

	Call( P_SLVROOT( slvroot )->pslvft->ErrCommitSpace( &slvinfo ) );

	return JET_errSuccess;

HandleError:
	return err;
	}

//  deletes the space in the given SLV Info from an SLV Root.  this space will
//  later be freed when it is safe via the PSLVROOT_SPACEFREE callback

ERR ErrOSSLVRootSpaceDelete( const SLVROOT slvroot, CSLVInfo& slvinfo )
	{
	ERR err = JET_errSuccess;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  delete the space in this SLV Info for the associated SLV File

	Call( P_SLVROOT( slvroot )->pslvft->ErrDeleteSpace( &slvinfo ) );

	return JET_errSuccess;

HandleError:
	return err;
	}


CSLVBackingFile::CSLVBackingFile()
	:	m_semSetSize( CSyncBasicInfo( "CSLVBackingFile::m_semSetSize" ) )
	{
	//  nop
	}

ERR CSLVBackingFile::ErrInit(	_TCHAR* const	szAbsPath,
								const HANDLE	hFile,
								const QWORD		cbFileSize,
								const BOOL		fReadOnly,
								const DWORD		cbIOSize,
								const SLVROOT	slvroot,
								_TCHAR* const	szAbsPathSLV )
	{
	ERR err = JET_errSuccess;

	//  init underlying OS File object
	
	Call( COSFile::ErrInit(	szAbsPath,
							hFile,
							cbFileSize,
							fReadOnly,
							cbIOSize ) );

	//  remember our associated SLV Root

	m_slvroot = slvroot;

	//  remember the true OS path for the streaming file
	
	_tcscpy( m_szAbsPathSLV, szAbsPathSLV );

	//  allow updates to the backing file size

	m_semSetSize.Release();

	return JET_errSuccess;

HandleError:
	return err;
	}

CSLVBackingFile::~CSLVBackingFile()
	{
	//  nop
	}

ERR CSLVBackingFile::ErrPath( _TCHAR* const szAbsPath )
	{
	//  return the true path of the backing file
	
	_tcscpy( szAbsPath, m_szAbsPathSLV );
	return JET_errSuccess;
	}

ERR CSLVBackingFile::ErrSetSize( const QWORD cbSize )
	{
	ERR err = JET_errSuccess;

	//  set the file size for the underlying OS File object
	
	m_semSetSize.Acquire();
	Call( COSFile::ErrSetSize( cbSize ) );

	//  update the backing file size on the SLV Root

	if ( !pfnIfsSetEndOfFileRoot(	P_SLVROOT( m_slvroot )->hFileRoot,
									P_SLVROOT( m_slvroot )->wszRootName,
									cbSize ) )
		{
		Call( ErrOSSLVRootIGetLastError() );
		}
	m_semSetSize.Release();

	return JET_errSuccess;

HandleError:
	m_semSetSize.Release();
	return err;
	}


ERR ErrOSSLVRootIOpenRaw(	const SLVROOT			slvroot,
							IFileSystemAPI* const	pfsapi,
							const wchar_t* const	wszBackingFile,
							IFileAPI** const		ppfapiBackingFile )
	{
	ERR					err						= JET_errSuccess;
	_TCHAR				szBackingFile[ IFileSystemAPI::cchPathMax ];
	_TCHAR				szAbsPathBackingFile[ IFileSystemAPI::cchPathMax ];
	IFileFindAPI*		pffapi					= NULL;
	QWORD				cbBackingFileSize;
	DWORD				cbBackingFileIOSize;
	CSLVInfo			slvinfo;
	CSLVInfo::HEADER	header;
	CSLVInfo::RUN		run;
	CSLVFileInfo		slvfileinfo;
	size_t				cwchRelPath;
	wchar_t*			wszRelPath;
	size_t				cbffeainf;
	void*				pffeainf;
	CSLVBackingFile*	pslvbf					= NULL;
	WCHAR				wszAbsPath[ IFileSystemAPI::cchPathMax ];
	_TCHAR				szAbsPath[ IFileSystemAPI::cchPathMax ];
	HANDLE				hFile					= INVALID_HANDLE_VALUE;

	//  get the current properties of the backing file

	Call( ErrOSSTRUnicodeToTchar(	wszBackingFile,
									szBackingFile,
									IFileSystemAPI::cchPathMax ) );

	Call( pfsapi->ErrFileFind( szBackingFile, &pffapi ) );
	Call( pffapi->ErrNext() );
	Call( pffapi->ErrPath( szAbsPathBackingFile ) );
	Call( pffapi->ErrSize( &cbBackingFileSize ) );
	delete pffapi;
	pffapi = NULL;

	Call( pfsapi->ErrFileAtomicWriteSize(	szBackingFile,
											&cbBackingFileIOSize ) );

	//  describe a HUGE SLV File that covers all possible offsets of the
	//  backing file.  this SLV File will be used for raw access to the
	//  backing file via the SLV Provider and is called $Raw$
	
	Call( slvinfo.ErrCreateVolatile() );

	header.cbSize			= cbBackingFileSizeMax;
	header.cRun				= 1;
	header.fDataRecoverable	= fFalse;
	header.rgbitReserved_31	= 0;
	header.rgbitReserved_32	= 0;
	Call( slvinfo.ErrSetHeader( header ) );

	Call( slvinfo.ErrSetFileName( L"$Raw$" ) );

	run.ibVirtualNext	= cbBackingFileSizeMax;
	run.ibLogical		= 0;
	run.qwReserved		= 0;
	run.ibVirtual		= 0;
	run.cbSize			= cbBackingFileSizeMax;
	run.ibLogicalNext	= cbBackingFileSizeMax;
	Call( slvinfo.ErrMoveAfterLast() );
	Call( slvinfo.ErrSetCurrentRun( run ) );

	//  allocate the file object
	
	if ( !( pslvbf = new CSLVBackingFile ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  create an empty SLV File Info to receive the converted data

	Call( slvfileinfo.ErrCreate() );

	//  convert the given SLV Info into SLV File Info, give the SLV File Info
	//  no expiration time, and disable copy-on-write

	Call( ErrOSSLVFileIConvertSLVInfoToSLVFileInfo(	slvroot,
													slvinfo,
													&slvfileinfo,
													fFalse,
													EXSTATUS_PRIVILEGED_HANDLE ) );

	//  get the file name and EA List for this SLV File

	Call( slvfileinfo.ErrGetFileName( &wszRelPath, &cwchRelPath ) );
	Call( slvfileinfo.ErrGetEAList( &pffeainf, &cbffeainf ) );

	//  get the absolute path for the file to create

	wcscpy( wszAbsPath, P_SLVROOT( slvroot )->wszRootName );
	wcscat( wszAbsPath, L"\\" );
	wcscat( wszAbsPath, wszRelPath );

	Call( ErrOSSTRUnicodeToTchar( wszAbsPath, szAbsPath, IFileSystemAPI::cchPathMax ) );

	//  create the file, passing the generated EA List to the SLV Provider
	
	hFile = pfnIfsCreateFile(	wszAbsPath,
								GENERIC_READ | GENERIC_WRITE,
								FILE_SHARE_READ | FILE_SHARE_WRITE,
								NULL,
								OPEN_ALWAYS,
								(	FILE_ATTRIBUTE_NORMAL |
									FILE_FLAG_WRITE_THROUGH |
									FILE_FLAG_NO_BUFFERING |
									FILE_FLAG_OVERLAPPED ), 
								(PVOID) pffeainf,
								cbffeainf );
	if ( hFile == INVALID_HANDLE_VALUE )
		{
		Call( ErrOSSLVFileIGetLastError() );
		}

	SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	//  reduce the file size to match the size of the backing file.  this will
	//  not change our scatter list but it will allow the file object to extend
	//  and shrink the file normally

	DWORD	cbSizeLow;
	DWORD	cbSizeHigh;
	
	cbSizeLow	= DWORD( cbBackingFileSize );
	cbSizeHigh	= DWORD( cbBackingFileSize >> 32 );
	if (	(	SetFilePointer(	hFile,
								cbSizeLow,
								(long*)&cbSizeHigh,
								FILE_BEGIN ) == INVALID_SET_FILE_POINTER &&
				GetLastError() != NO_ERROR ) ||
			!SetEndOfFile( hFile ) )
		{
		Call( ErrOSSLVFileIGetLastError() );
		}

	//  initialize the file object

	Call( pslvbf->ErrInit(	szAbsPath,
							hFile,
							cbBackingFileSize,
							fFalse,
							cbBackingFileIOSize,
							slvroot,
							szAbsPathBackingFile ) );
	hFile = INVALID_HANDLE_VALUE;

	//  return the interface to our file object

	*ppfapiBackingFile = pslvbf;
	slvfileinfo.Unload();
	slvinfo.Unload();
	return JET_errSuccess;

HandleError:
	delete pffapi;
	if ( hFile != INVALID_HANDLE_VALUE )
		{
		SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hFile );
		}
	delete pslvbf;
	*ppfapiBackingFile = NULL;
	slvfileinfo.Unload();
	slvinfo.Unload();
	return err;
	}

//  creates an SLV Root with the specified relative root path in the SLV name
//  space backed by the specified file.  the provided completions will be
//  notified when more space is needed for the SLV Root for creating SLV
//  files or when space used by the SLV Root can safely be freed.  if the root
//  cannot be created, JET_errFileAccessDenied will be returned.  if the
//  backing file does not exist, JET_errFileNotFound will be returned

ERR ErrOSSLVRootCreate(	const wchar_t* const		wszRootPath,
						IFileSystemAPI* const		pfsapi,
						const wchar_t* const		wszBackingFile,
						const PSLVROOT_SPACEREQ		pfnSpaceReq,
						const DWORD_PTR				dwSpaceReqKey,
						const PSLVROOT_SPACEFREE	pfnSpaceFree,
						const DWORD_PTR				dwSpaceFreeKey,
						const BOOL					fUseRootMap,
						SLVROOT* const				pslvroot,
						IFileAPI** const			ppfapiBackingFile )
	{
	ERR					err					= JET_errSuccess;
	_TCHAR				szBackingFile[ IFileSystemAPI::cchPathMax ];
	IFileAPI*			pfapiBackingFile	= NULL;
	IFileLayoutAPI*		pflapi				= NULL;
	_TCHAR				szBackingFilePhys[ IFileSystemAPI::cchPathMax ];
	wchar_t				wszBackingFilePhys[ IFileSystemAPI::cchPathMax ];
	DWORD				Error				= 0;

	//  check for SLV Provider

	if ( errSLVProvider < JET_errSuccess )
		{
		Call( ErrERRCheck( errSLVProvider ) );
		}

	//  setup the SLV Root for open

	if ( !( *PP_SLVROOT( pslvroot ) = new _SLVROOT ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	P_SLVROOT( *pslvroot )->hFileRoot			= NULL;
	P_SLVROOT( *pslvroot )->dwInstanceID		= AtomicExchangeAdd( (long*)&tickOSSLVInstanceID, 2 );

	P_SLVROOT( *pslvroot )->pfapiBackingFile	= NULL;

	P_SLVROOT( *pslvroot )->pslvft				= NULL;

	P_SLVROOT( *pslvroot )->pfnSpaceReq			= pfnSpaceReq;
	P_SLVROOT( *pslvroot )->dwSpaceReqKey		= dwSpaceReqKey;

	P_SLVROOT( *pslvroot )->msigTerm.Reset();
	P_SLVROOT( *pslvroot )->msigTermAck.Set();

	P_SLVROOT( *pslvroot )->cbGrant				= 0;
	P_SLVROOT( *pslvroot )->cbCommit			= 0;

	P_SLVROOT( *pslvroot )->pfnSpaceFree		= pfnSpaceFree;
	P_SLVROOT( *pslvroot )->dwSpaceFreeKey		= dwSpaceFreeKey;

	wcscpy( P_SLVROOT( *pslvroot )->wszRootName, wszRootPath );

	PFILE_GET_EA_INFORMATION	pfgeainfCur;
	BYTE*						pbNameStart;
	BYTE*						pbNameEnd;
	PFILE_GET_EA_INFORMATION	pfgeainfNext;

	pfgeainfNext = &P_SLVROOT( *pslvroot )->fgeainf;
	
	pfgeainfCur		= pfgeainfNext;
	pbNameStart		= (BYTE*)pfgeainfCur->EaName;
	pbNameEnd		= pbNameStart + sizeof( EXIFS_EA_NAME_COMMIT );
	pfgeainfNext	= (FILE_GET_EA_INFORMATION*)PvOSSLVLongAlign( pbNameEnd );

	pfgeainfCur->NextEntryOffset	= (ULONG)((BYTE*)pfgeainfNext - (BYTE*)pfgeainfCur);
	pfgeainfCur->EaNameLength		= BYTE( pbNameEnd - pbNameStart - 1 );
	
	strcpy( (char*)pbNameStart, EXIFS_EA_NAME_COMMIT );
	
	pfgeainfCur		= pfgeainfNext;
	pbNameStart		= (BYTE*)pfgeainfCur->EaName;
	pbNameEnd		= pbNameStart + sizeof( "0000000000" );
	pfgeainfNext	= (FILE_GET_EA_INFORMATION*)PvOSSLVLongAlign( pbNameEnd );

	pfgeainfCur->NextEntryOffset	= 0;
	pfgeainfCur->EaNameLength		= BYTE( pbNameEnd - pbNameStart - 1 );
	
	sprintf( (char*)pbNameStart, "%010u", P_SLVROOT( *pslvroot )->dwInstanceID );

	P_SLVROOT( *pslvroot )->cbfgeainf = (DWORD)((BYTE*)pfgeainfNext - (BYTE*)( &P_SLVROOT( *pslvroot )->fgeainf ));
	Assert( P_SLVROOT( *pslvroot )->cbfgeainf <= sizeof( P_SLVROOT( *pslvroot )->rgbEA ) );
	Assert( P_SLVROOT( *pslvroot )->cbfgeainf == EXIFS_GET_EA_LEN_COMMIT + EXIFS_GET_EA_LEN_INSTANCE_ID );

	//  initialize the SLV File Table

	BYTE* rgbSLVFileTable;
	rgbSLVFileTable = (BYTE*)PvOSMemoryHeapAllocAlign( sizeof( CSLVFileTable ), cbCacheLine );
	if ( !rgbSLVFileTable )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	P_SLVROOT( *pslvroot )->pslvft = new( rgbSLVFileTable ) CSLVFileTable();
	Call( P_SLVROOT( *pslvroot )->pslvft->ErrInit( P_SLVROOT( *pslvroot ) ) );

	//  we will be using a root mapping  [SFS case]
	
	if ( fUseRootMap )
		{
		//  query the layout of the backing file and get the physical backing
		//  file path so that we can give that to the SLV Provider
		//
		//  NOTE:  we assume that the backing file is not zero-length (it should
		//  have a header by now) and that it is backed by only one logical path
		//  (the .SFS file path)

		Call( ErrOSSTRUnicodeToTchar(	wszBackingFile,
										szBackingFile,
										IFileSystemAPI::cchPathMax ) );
		Call( pfsapi->ErrFileOpen( szBackingFile, &pfapiBackingFile ) );

		Call( pfapiBackingFile->ErrQueryLayout( 0, -1, &pflapi ) );
		Call( pflapi->ErrNext() );
		Call( pflapi->ErrLogicalPath( szBackingFilePhys ) );
		delete pflapi;
		pflapi = NULL;

		delete pfapiBackingFile;
		pfapiBackingFile = NULL;

		Call( ErrOSSTRTcharToUnicode(	szBackingFilePhys,
										wszBackingFilePhys,
										IFileSystemAPI::cchPathMax ) );
		}

	//  we will not be using a root mapping  [non-SFS case]
	
	else
		{
		//  the specified backing file path is the physical backing file path

		wcscpy( wszBackingFilePhys, wszBackingFile );
		}

	//  save the backing file handle in the SLV Root
	
	P_SLVROOT( *pslvroot )->pfapiBackingFile = pfapiBackingFile;
	pfapiBackingFile = NULL;

	//  open the SLV Root path exclusively to ensure that no one else is currently
	//  attached to this SLV Root

	do
		{
		P_SLVROOT( *pslvroot )->hFileRoot = pfnIfsCreateFile(	(WCHAR*)wszRootPath,
																GENERIC_READ | GENERIC_WRITE,
																0,
																NULL,
																CREATE_NEW,
																(	FILE_ATTRIBUTE_NORMAL |
																	FILE_FLAG_WRITE_THROUGH |
																	FILE_FLAG_OVERLAPPED ), 
																NULL,
																0 );
		if ( P_SLVROOT( *pslvroot )->hFileRoot == INVALID_HANDLE_VALUE )
			{
			Error = GetLastError();
			if ( Error == ERROR_DEVICE_IN_USE )
				{
				Sleep( 100 );
				}
			}
		}
	while ( Error == ERROR_DEVICE_IN_USE );

	if ( Error != NO_ERROR )
        {
		P_SLVROOT( *pslvroot )->hFileRoot = NULL;
		err = ErrOSSLVRootIGetLastError( Error );
		if ( err == JET_errInvalidPath )
			{
			err = ErrERRCheck( JET_errSLVProviderNotLoaded );
			}
		Call( err );
        }

	SetHandleInformation( P_SLVROOT( *pslvroot )->hFileRoot, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	
	if ( !pfnIfsInitializeRoot(	P_SLVROOT( *pslvroot )->hFileRoot,
								(WCHAR*)wszRootPath,
								(WCHAR*)wszBackingFilePhys,
								P_SLVROOT( *pslvroot )->dwInstanceID, 
								SLVPAGE_SIZE,
								(	FILE_WRITE_THROUGH |
									FILE_RANDOM_ACCESS |
									( fUseRootMap ? FILE_OPEN_FOR_BACKUP_INTENT : 0 ) ) ) )
		{
		Call( ErrOSSLVRootIGetLastError() );
		}

	//  we will be using a root mapping  [SFS case]
	
	if ( fUseRootMap )
		{
		//  open the backing file with full sharing (HACK HACK HACK)

		Call( ErrOSSTRUnicodeToTchar(	wszBackingFile,
										szBackingFile,
										IFileSystemAPI::cchPathMax ) );
		Call( pfsapi->ErrFileOpen(	szBackingFile,
									&pfapiBackingFile,
									fFalse,
									fFalse ) );

		//  request layout updates for this file.  we will use these callbacks
		//  to update the root mapping

		Call( pfapiBackingFile->ErrRequestLayoutUpdates(	IFileAPI::PfnEndUpdate( OSSLVRootSpaceIEndRemap ),
															DWORD_PTR( *pslvroot ),
															IFileAPI::PfnBeginUpdate( OSSLVRootSpaceIBeginRemap ),
															DWORD_PTR( *pslvroot ) ) );

		//  fire the end remap callback to setup the initial root map

		OSSLVRootSpaceIEndRemap( pfapiBackingFile, *pslvroot );
		}

	//  we will not be using a root mapping  [non-SFS case]
	
	else
		{
		//  create the special $Raw$ SLV File and use that as the backing file

		Call( ErrOSSLVRootIOpenRaw(	*pslvroot,
									pfsapi,
									wszBackingFile,
									&pfapiBackingFile ) );
		}

	//  save the backing file handle in the SLV Root
	
	P_SLVROOT( *pslvroot )->pfapiBackingFile = pfapiBackingFile;
	pfapiBackingFile = NULL;

	//  start the space request loop to allow the SLV Provider to tell us
	//  when it needs space

	P_SLVROOT( *pslvroot )->msigTermAck.Reset();
	P_SLVROOT( *pslvroot )->semSpaceReqComp.Release();
	OSSLVRootSpaceIRequestComplete( *pslvroot );

	//  return the SLV Root and its backing file handle

	*ppfapiBackingFile = P_SLVROOT( *pslvroot )->pfapiBackingFile;
	return JET_errSuccess;

HandleError:
	OSSLVRootClose( *pslvroot );
	delete pfapiBackingFile;
	delete pflapi;
	*pslvroot			= slvrootNil;
	*ppfapiBackingFile	= NULL;
	return err;
	}

//  closes an SLV Root

void OSSLVRootClose( const SLVROOT slvroot )
	{
	//  we have an SLV Root pointer

	if ( slvroot && slvroot != slvrootNil )
		{
		//  close the backing file

		delete P_SLVROOT( slvroot )->pfapiBackingFile;

		//  we opened the SLV Root handle

		if ( P_SLVROOT( slvroot )->hFileRoot )
			{
			//  shut down the SLV Root and the space request loop

			P_SLVROOT( slvroot )->msigTerm.Set();
			pfnIfsTerminateRoot( P_SLVROOT( slvroot )->hFileRoot, P_SLVROOT( slvroot )->wszRootName, 0 );
			P_SLVROOT( slvroot )->msigTermAck.Wait();

			//  close the SLV Root

			SetHandleInformation( P_SLVROOT( slvroot )->hFileRoot, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
			BOOL fCloseOK = CloseHandle( P_SLVROOT( slvroot )->hFileRoot );
			Assert( fCloseOK );
			}

		//  terminate the SLV File Table

		if ( P_SLVROOT( slvroot )->pslvft )
			{
			P_SLVROOT( slvroot )->pslvft->Term();
			P_SLVROOT( slvroot )->pslvft->CSLVFileTable::~CSLVFileTable();
			OSMemoryHeapFreeAlign( P_SLVROOT( slvroot )->pslvft );
			}

		//  delete the SLV Root info

		OSMemoryHeapFree( P_SLVROOT( slvroot ) );
		}
	}

	
//  post-terminate SLV subsystem

void OSSLVPostterm()
	{
	//  nop
	}

//  pre-init SLV subsystem

BOOL FOSSLVPreinit()
	{
	//  get our init time which we will use later to generate Instance IDs

	tickOSSLVInstanceID = GetTickCount() & 0xFFFFFFFE;
	return fTrue;
	}


//  term SLV subsystem

void OSSLVTerm()
	{
	//  free ifsproxy.dll

	if ( hmodIfsProxy )
		{
		if ( pfnIfsCloseProvider )
			{
			pfnIfsCloseProvider();
			}

		FreeLibrary( hmodIfsProxy );
		hmodIfsProxy = NULL;
		}

	//  free ntdll

	if ( hmodNtdll )
		{
		FreeLibrary( hmodNtdll );
		hmodNtdll = NULL;
		}
	}

//  init SLV subsystem

ERR ErrOSSLVInit()
	{
	ERR			err				= JET_errSuccess;
	const int	cbBuf			= 256;
	_TCHAR		szBuf[ cbBuf ];
	
	//  reset all pointers

	hmodNtdll			= NULL;
	fUseRelativeOpen	= fFalse;
	hmodIfsProxy		= NULL;
	errSLVProvider		= JET_errSuccess;

	//  load OS version

	OSVERSIONINFO osvi;
	memset( &osvi, 0, sizeof( osvi ) );
	osvi.dwOSVersionInfoSize = sizeof( osvi );
	if ( !GetVersionEx( &osvi ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  set all configuration defaults

	cbOSSLVReserve				= 2 * 1024 * 1024;

	cmsecOSSLVSpaceFreeDelay	= 60 * 1000;
	cmsecOSSLVFileOpenDelay		= 60 * 1000;
	cmsecOSSLVTTL				= 5 * 1000;
	cmsecOSSLVTTLSafety			= 100;
	cmsecOSSLVTTLInfinite		= 1 << 30;

	cbBackingFileSizeMax		= (	osvi.dwPlatformId == VER_PLATFORM_WIN32_NT ?
										SLVSIZE_MAX :
										0x100000000 - SLVPAGE_SIZE );

	//  load configuration from the registry
	
	if (	FOSConfigGet( _T( "OS/SLV" ), _T( "Space Grant Size (B)" ), szBuf, cbBuf ) &&
			szBuf[ 0 ] )
		{
		cbOSSLVReserve = _ttol( szBuf );
		}
	
	if (	FOSConfigGet( _T( "OS/SLV" ), _T( "EA List Time-To-Live (ms)" ), szBuf, cbBuf ) &&
			szBuf[ 0 ] )
		{
		cmsecOSSLVTTL = _ttol( szBuf );
		}

	//  init performance counters

	cOSSLVFileTableInsert	= 0;
	cOSSLVFileTableClean	= 0;
	cOSSLVFileTableDelete	= 0;

	//  load ntdll.dll

	fUseRelativeOpen = (	( hmodNtdll = LoadLibrary( _T( "ntdll.dll" ) ) ) &&
							( pfnRtlInitUnicodeString = (PFNRtlInitUnicodeString*)GetProcAddress( hmodNtdll, _T( "RtlInitUnicodeString" ) ) ) &&
							( pfnNtCreateFile = (PFNNtCreateFile*)GetProcAddress( hmodNtdll, _T( "NtCreateFile" ) ) ) );
		
	//  load ifsproxy.dll

	if ( !( hmodIfsProxy = LoadLibrary( _T( "ifsproxy.dll" ) ) ) )
		{
		goto NoIfsProxy;
		}
	if ( !( pfnIfsGetFirstCursor = (PFNIfsGetFirstCursor*)GetProcAddress( hmodIfsProxy, _T( "IfsGetFirstCursor" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsConsumeCursor = (PFNIfsConsumeCursor*)GetProcAddress( hmodIfsProxy, _T( "IfsConsumeCursor" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsGetNextCursor = (PFNIfsGetNextCursor*)GetProcAddress( hmodIfsProxy, _T( "IfsGetNextCursor" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsFinishCursor = (PFNIfsFinishCursor*)GetProcAddress( hmodIfsProxy, _T( "IfsFinishCursor" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsCreateNewBuffer = (PFNIfsCreateNewBuffer*)GetProcAddress( hmodIfsProxy, _T( "IfsCreateNewBuffer" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsCopyBufferToReference = (PFNIfsCopyBufferToReference*)GetProcAddress( hmodIfsProxy, _T( "IfsCopyBufferToReference" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsCopyReferenceToBuffer = (PFNIfsCopyReferenceToBuffer*)GetProcAddress( hmodIfsProxy, _T( "IfsCopyReferenceToBuffer" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsCloseBuffer = (PFNIfsCloseBuffer*)GetProcAddress( hmodIfsProxy, _T( "IfsCloseBuffer" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsInitializeProvider = (PFNIfsInitializeProvider*)GetProcAddress( hmodIfsProxy, _T( "IfsInitializeProvider" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsCloseProvider = (PFNIfsCloseProvider*)GetProcAddress( hmodIfsProxy, _T( "IfsCloseProvider" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsCreateFile = (PFNIfsCreateFileProv*)GetProcAddress( hmodIfsProxy, _T( "IfsCreateFileProv" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsInitializeRoot = (PFNIfsInitializeRoot*)GetProcAddress( hmodIfsProxy, _T( "IfsInitializeRoot" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsSpaceGrantRoot = (PFNIfsSpaceGrantRoot*)GetProcAddress( hmodIfsProxy, _T( "IfsSpaceGrantRoot" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsSetEndOfFileRoot = (PFNIfsSetEndOfFileRoot*)GetProcAddress( hmodIfsProxy, _T( "IfsSetEndOfFileRoot" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsSpaceRequestRoot = (PFNIfsSpaceRequestRoot*)GetProcAddress( hmodIfsProxy, _T( "IfsSpaceRequestRoot" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsQueryEaFile = (PFNIfsQueryEaFile*)GetProcAddress( hmodIfsProxy, _T( "IfsQueryEaFile" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsTerminateRoot = (PFNIfsTerminateRoot*)GetProcAddress( hmodIfsProxy, _T( "IfsTerminateRoot" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsSetRootMap = (PFNIfsSetRootMap*)GetProcAddress( hmodIfsProxy, _T( "IfsSetRootMap" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsResetRootMap = (PFNIfsResetRootMap*)GetProcAddress( hmodIfsProxy, _T( "IfsResetRootMap" ) ) ) )
		{
		goto WrongIfsProxy;
		}
	if ( !( pfnIfsFlushHandle = (PFNIfsFlushHandle*)GetProcAddress( hmodIfsProxy, "IfsFlushHandle" ) ) )
		{
		goto WrongIfsProxy;
		}

	if ( !pfnIfsInitializeProvider( 0 ) )
		{
		errSLVProvider = ErrOSSLVRootIGetLastError();
		goto HandleError;
		}

	return JET_errSuccess;

WrongIfsProxy:
	errSLVProvider = ErrERRCheck( JET_errSLVProviderVersionMismatch );
	goto HandleError;
	
NoIfsProxy:
	errSLVProvider = ErrERRCheck( JET_errSLVProviderNotLoaded );
	goto HandleError;

HandleError:
	OSSLVTerm();
	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\string.cxx ===
#include "osstd.hxx"


//	get the length of the string

LONG LOSSTRLengthA( const char *const psz )
	{
	return lstrlenA( psz );
	}
LONG LOSSTRLengthW( const wchar_t *const pwsz )
	{
	return lstrlenW( pwsz );
	}


//	copy a string

VOID OSSTRCopyA( char *const pszDst, const char *const pszSrc )
	{
	(VOID)lstrcpyA( pszDst, pszSrc );
	}
VOID OSSTRCopyW( wchar_t *const pwszDst, const wchar_t *const pwszSrc )
	{
	(VOID)lstrcpyW( pwszDst, pwszSrc );
	}


//	append a string

VOID OSSTRAppendA( char *const pszDst, const char* const pszSrc )
	{
	const ULONG cch = LOSSTRLengthA( pszDst );
	OSSTRCopyA( pszDst + cch, pszSrc );
	}
VOID OSSTRAppendW( wchar_t *const pwszDst, const wchar_t *const pwszSrc )
	{
	const ULONG cch = LOSSTRLengthW( pwszDst );
	OSSTRCopyW( pwszDst + cch, pwszSrc );
	}



//	compare the strings (up to the given maximum length).  if the first string 
//	is "less than" the second string, -1 is returned.  if the strings are "equal", 
//	0 is returned.  if the first string is "greater than" the second string, +1 is returned.

LONG LOSSTRCompareA( const char *const pszStr1, const char *const pszStr2, const ULONG cchMax )
	{
	ULONG cch1 = lstrlenA( pszStr1 );
	ULONG cch2 = lstrlenA( pszStr2 );
	ULONG ich;

	//	limit the lengths

	if ( cch1 > cchMax )
		{
		cch1 = cchMax;
		}
	if ( cch2 > cchMax )
		{
		cch2 = cchMax;
		}

	//	compare the lengths

	if ( cch1 < cch2 )
		{
		return -1;
		}
	else if ( cch1 > cch2 )
		{
		return +1;
		}

	//	compare the strings

	ich = 0;
	while ( ich < cch1 )
		{
		if ( pszStr1[ich] == pszStr2[ich] )
			{
			ich++;
			}
		else if ( pszStr1[ich] < pszStr2[ich] )
			{
			return -1;
			}
		else
			{
			return +1;
			}
		}

	return 0;
	}


LONG LOSSTRCompareW( const wchar_t *const pwszStr1, const wchar_t *const pwszStr2, const ULONG cchMax )
	{
	ULONG cch1 = lstrlenW( pwszStr1 );
	ULONG cch2 = lstrlenW( pwszStr2 );
	ULONG ich;

	//	limit the lengths

	if ( cch1 > cchMax )
		{
		cch1 = cchMax;
		}
	if ( cch2 > cchMax )
		{
		cch2 = cchMax;
		}

	//	compare the lengths

	if ( cch1 < cch2 )
		{
		return -1;
		}
	else if ( cch1 > cch2 )
		{
		return +1;
		}

	//	compare the strings

	ich = 0;
	while ( ich < cch1 )
		{
		if ( pwszStr1[ich] == pwszStr2[ich] )
			{
			ich++;
			}
		else if ( pwszStr1[ich] < pwszStr2[ich] )
			{
			return -1;
			}
		else
			{
			return +1;
			}
		}

	return 0;
	}



//	create a formatted string in a given buffer

LONG __cdecl LOSSTRFormatA( char *const pszBuffer, const char *const pszFormat, ... )
	{
	va_list alist;
	va_start( alist, pszFormat );
	const int i = vsprintf( pszBuffer, pszFormat, alist );
	va_end( alist );
	return LONG( i );
	}
LONG __cdecl LOSSTRFormatW( wchar_t *const pwszBuffer, const wchar_t *const pwszFormat, ... )
	{
	va_list alist;
	va_start( alist, pwszFormat );
	const int i = vswprintf( pwszBuffer, pwszFormat, alist );
	va_end( alist );
	return LONG( i );
	}


//	returns a pointer to the next character in the string.  when no more
//	characters are left, the given ptr is returned.

VOID OSSTRCharNextA( const char *const psz, char **const ppszNext )
	{
	*ppszNext = const_cast< char *const >( '\0' != *psz ? psz + 1 : psz );
	}
VOID OSSTRCharNextW( const wchar_t *const pwsz, wchar_t **const ppwszNext )
	{
	*ppwszNext = const_cast< wchar_t *const >( L'\0' != *pwsz ? pwsz + 1 : pwsz );
	}


//	returns a pointer to the previous character in the string.  when the first
//	character is reached, the given ptr is returned.

VOID OSSTRCharPrevA( const char *const pszBase, const char *const psz, char **const ppszPrev )
	{
	*ppszPrev = const_cast< char *const >( psz > pszBase ? psz - 1 : psz );
	}
VOID OSSTRCharPrevW( const wchar_t *const pwszBase, const wchar_t *const pwsz, wchar_t **const ppwszPrev )
	{
	*ppwszPrev = const_cast< wchar_t *const >( pwsz > pwszBase ? pwsz - 1 : pwsz );
	}


//	find the first occurrence of the given character in the given string and
//	return a pointer to that character.  NULL is returned when the character 
//	is not found.

VOID OSSTRCharFindA( const char *const pszStr, const char ch, char **const ppszFound )
	{
	*ppszFound = strchr( pszStr, ch );
	}
VOID OSSTRCharFindW( const wchar_t *const pwszStr, const wchar_t wch, wchar_t **const ppwszFound )
	{
	const wchar_t *pwszFound = pwszStr;
	while ( L'\0' != *pwszFound && wch != *pwszFound )
		{
		pwszFound++;
		}
	*ppwszFound = const_cast< wchar_t *const >( wch == *pwszFound ? pwszFound : NULL );
	}


//	find the last occurrence of the given character in the given string and
//	return a pointer to that character.  NULL is returned when the character
//	is not found.

VOID OSSTRCharFindReverseA( const char *const pszStr, const char ch, char **const ppszFound )
	{
	Assert( '\0' != ch );
	*ppszFound = strrchr( pszStr, ch );
	}
VOID OSSTRCharFindReverseW( const wchar_t *const pwszStr, const wchar_t wch, wchar_t **const ppwszFound )
	{
	ULONG	ich;
	ULONG	cch;

	Assert( L'\0' != wch );

	*ppwszFound = NULL;

	cch = LOSSTRLengthW( pwszStr );
	ich = cch;

	while ( ich-- > 0 )
		{
		if ( wch == pwszStr[ich] )
			{
			*ppwszFound = const_cast< wchar_t* const >( pwszStr + ich );
			return;
			}
		}
	}


//	check for a trailing path-delimeter

BOOL FOSSTRTrailingPathDelimiterA( const char *const pszPath )
	{
	const DWORD cchPath = lstrlenA( pszPath );

	if ( cchPath > 0 )
		{
		return BOOL( '\\' == pszPath[cchPath - 1] || '/' == pszPath[cchPath - 1] );
		}
	return fFalse;
	}
BOOL FOSSTRTrailingPathDelimiterW( const wchar_t *const pwszPath )
	{
	const DWORD cchPath = lstrlenW( pwszPath );

	if ( cchPath > 0 )
		{
		return BOOL( L'\\' == pwszPath[cchPath - 1] || L'/' == pwszPath[cchPath - 1] );
		}
	return fFalse;
	}


//	conditionally append a path delimiter to a path.  if fCheckExist is true,
//	the path delimiter will only be appended if one is not already present.

VOID OSSTRAppendPathDelimiterA( char *const pszPath, const BOOL fCheckExist )
	{
	if ( !fCheckExist || !FOSSTRTrailingPathDelimiterA( pszPath ) )
		{
		const UINT cch = lstrlenA( pszPath );
		pszPath[ cch ] = bPathDelimiter;
		pszPath[ cch + 1 ] = '\0';
		}
	}
VOID OSSTRAppendPathDelimiterW( wchar_t *const pwszPath, const BOOL fCheckExist )
	{
	if ( !fCheckExist || !FOSSTRTrailingPathDelimiterW( pwszPath ) )
		{
		const UINT cch = lstrlenW( pwszPath );
		pwszPath[ cch ] = wchPathDelimiter;
		pwszPath[ cch + 1 ] = L'\0';
		}
	}


//	convert a byte string to a wide-char string

ERR ErrOSSTRAsciiToUnicode(	const char *const	pszIn,
							wchar_t *const		pwszOut,
							const int			cwchOut,	//	pass in 0 to only return output buffer size in pcwchActual
							int* const			pcwchActual )
	{
	//	check the input buffer against the output buffer

	const int cchIn = lstrlenA( pszIn ) + 1;
	if ( cwchOut < cchIn
		&& ( 0 != cwchOut || NULL == pcwchActual ) )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}


	//	do the conversion

	const int cwchActual = MultiByteToWideChar(	CP_ACP,
												MB_ERR_INVALID_CHARS,
												pszIn,
												cchIn,
												pwszOut,
												cwchOut );
	if ( NULL != pcwchActual )
		*pcwchActual = cwchActual;

	if ( 0 != cwchActual )
		{
		if ( 0 != cwchOut )
			{
			Assert( cwchActual <= cwchOut );
			Assert( L'\0' == pwszOut[cwchActual - 1] );
			}
		return JET_errSuccess;
		}

	//	handle the error

	const DWORD dwError = GetLastError();

	if ( ERROR_INSUFFICIENT_BUFFER == dwError )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}
	else if ( ERROR_INVALID_PARAMETER == dwError )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}
	else if ( ERROR_NO_UNICODE_TRANSLATION == dwError )
		{
		return ErrERRCheck( JET_errUnicodeTranslationFail );
		}
	else
		{
		//	unexpected error

		_TCHAR			szT[150];
		_TCHAR			szPID[10];
		const _TCHAR *	rgszT[4]	= { SzUtilProcessName(), szPID, "", szT };

		_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
		_stprintf(	szT, 
					_T( "Unexpected Win32 error in ErrOSSTRAsciiToUnicode: %dL (0x%08X)" ), 
					dwError, 
					dwError );
		AssertSz( fFalse, szT );
		OSEventReportEvent( SzUtilImageVersionName(), eventError, PERFORMANCE_CATEGORY, PLAIN_TEXT_ID, 4, rgszT );

		return ErrERRCheck( JET_errUnicodeTranslationFail );
		}
	}

//	convert a wide-char string to a byte string

ERR ErrOSSTRUnicodeToAscii(	const wchar_t *const	pwszIn,
							char *const				pszOut,
							const int				cchOut,		//	pass in 0 to only return output buffer size in pcchActual
							int* const				pcchActual )
	{
	//	check the input buffer against the output buffer

	const int cwchIn = lstrlenW( pwszIn ) + 1;
	if ( cchOut < cwchIn
		&& ( 0 != cchOut || NULL == pcchActual ) )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}


	//	do the conversion

	const int cchActual = WideCharToMultiByte(	CP_ACP,
												0,
												pwszIn,
												cwchIn,
												pszOut,
												cchOut,
												NULL,
												NULL );
	if ( NULL != pcchActual )
		*pcchActual = cchActual;

	if ( 0 != cchActual )
		{
		if ( 0 != cchOut )
			{
			Assert( cchActual <= cchOut );
			Assert( '\0' == pszOut[cchActual - 1] );
			}
		return JET_errSuccess;
		}

	//	handle the error

	const DWORD dwError = GetLastError();

	if ( ERROR_INSUFFICIENT_BUFFER == dwError )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}
	else if ( ERROR_INVALID_PARAMETER == dwError )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}
	else
		{
		//	unexpected error

		_TCHAR			szT[150];
		_TCHAR			szPID[10];
		const _TCHAR *	rgszT[4]	= { SzUtilProcessName(), szPID, "", szT };

		_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
		_stprintf(	szT, 
					_T( "Unexpected Win32 error in ErrOSSTRUnicodeToAscii: %dL (0x%08X)" ), 
					dwError, 
					dwError );
		AssertSz( fFalse, szT );
		OSEventReportEvent( SzUtilImageVersionName(), eventError, PERFORMANCE_CATEGORY, PLAIN_TEXT_ID, 4, rgszT );

		return ErrERRCheck( JET_errUnicodeTranslationFail );
		}
	}


//  convert a _TCHAR string to a WCHAR string

ERR ErrOSSTRTcharToUnicode(	const _TCHAR *const	ptszIn, 
							wchar_t *const		pwszOut, 
							const int			cwchOut )
	{
#ifdef UNICODE

	//	check the input buffer against the output buffer

	const size_t ctchIn = wcslen( ptszIn ) + 1;
	if ( cwchOut < ctchIn )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}
	Assert( cwchOut > 0 );

	//  copy the string

	wcsncpy( pwszOut, ptszIn, cwchOut );
	return JET_errSuccess;
	
#else  //  !UNICODE

	return ErrOSSTRAsciiToUnicode( ptszIn, pwszOut, cwchOut );

#endif  //  UNICODE
	}

//  convert a WCHAR string to a _TCHAR string

ERR ErrOSSTRUnicodeToTchar(	const wchar_t *const	pwszIn, 
							_TCHAR *const			ptszOut, 
							const int				ctchOut )
	{
#ifdef UNICODE

	//	check the input buffer against the output buffer

	const wchar_t cwchIn = wcslen( pwszIn ) + 1;
	if ( ctchOut < cwchIn )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}
	Assert( ctchOut > 0 );

	//  copy the string

	wcsncpy( ptszOut, pwszIn, ctchOut );
	return JET_errSuccess;
	
#else  //  !UNICODE

	return ErrOSSTRUnicodeToAscii( pwszIn, ptszOut, ctchOut );

#endif  //  UNICODE
	}


//  convert a byte string to a _TCHAR string

ERR ErrOSSTRAsciiToTchar(	const char *const	pszIn, 
							_TCHAR *const		ptszOut, 
							const int			ctchOut )
	{
#ifdef UNICODE

	return ErrOSSTRAsciiToUnicode( pszIn, ptszOut, ctchOut );
	
#else  //  !UNICODE

	//	check the input buffer against the output buffer

	const int cchIn = (INT)strlen( pszIn ) + 1;
	if ( ctchOut < cchIn )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}
	Assert( ctchOut > 0 );

	//  copy the string

	strncpy( ptszOut, pszIn, ctchOut );
	return JET_errSuccess;

#endif  //  UNICODE
	}

//  convert a _TCHAR string to a byte string

ERR ErrOSSTRTcharToAscii(	const _TCHAR *const	ptszIn, 
							char *const			pszOut, 
							const int			cchOut )
	{
#ifdef UNICODE

	return ErrOSSTRUnicodeToAscii( ptszIn, pszOut, cchOut );
	
#else  //  !UNICODE

	//	check the input buffer against the output buffer

	const size_t ctchIn = strlen( ptszIn ) + 1;
	if ( cchOut < ctchIn )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}
	Assert( cchOut > 0 );

	//  copy the string

	strncpy( pszOut, ptszIn, cchOut );
	return JET_errSuccess;

#endif  //  UNICODE
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\osfs.cxx ===
#include "osstd.hxx"


COSFileSystem::COSFileSystem()
	:	m_hmodKernel32( NULL )
	{
	}

ERR COSFileSystem::ErrInit()
	{
	const _TCHAR	szKernel32[] 			= _T( "kernel32.dll" );
#ifdef UNICODE
	const _TCHAR	szGetVolumePathName[]	= _T( "GetVolumePathNameW" );
#else  //  !UNICODE
	const _TCHAR	szGetVolumePathName[]	= _T( "GetVolumePathNameA" );
#endif  //  UNICODE

	ERR				err						= JET_errSuccess;

	//  load OS version

	OSVERSIONINFO osvi;
	memset( &osvi, 0, sizeof( osvi ) );
	osvi.dwOSVersionInfoSize = sizeof( osvi );
	if ( !GetVersionEx( &osvi ) )
		{
		Call( ErrGetLastError() );
		}

	//  remember if we are running on Win9x
	
	m_fWin9x = osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS;
	
	//  load GetVolumePathName if on NT 5+

	m_pfnGetVolumePathName = NULL;
	if ( m_hmodKernel32 = LoadLibrary( szKernel32 ) )
		{
		m_pfnGetVolumePathName = (PfnGetVolumePathName*)GetProcAddress( m_hmodKernel32, szGetVolumePathName );
		}
	if (	!m_pfnGetVolumePathName &&
			osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
			osvi.dwMajorVersion >= 5 )
		{
		Call( ErrERRCheck( JET_errFileAccessDenied ) );
		}

	return JET_errSuccess;

HandleError:
	return err;
	}

ERR COSFileSystem::ErrGetLastError( const DWORD error )
	{
	_TCHAR szT[64];
	_TCHAR szPID[10];
	const _TCHAR* rgszT[3] = { SzUtilProcessName(), szPID, szT };

	//  map Win32 errors to JET API errors
	
	switch ( error )
		{
		case NO_ERROR:
			return JET_errSuccess;

		case ERROR_DISK_FULL:
			return ErrERRCheck( JET_errDiskFull );

		case ERROR_HANDLE_EOF:
		case ERROR_VC_DISCONNECTED:
		case ERROR_IO_DEVICE:
		case ERROR_DEVICE_NOT_CONNECTED:
		case ERROR_NOT_READY:
			return ErrERRCheck( JET_errDiskIO );

		case ERROR_NO_MORE_FILES:
		case ERROR_FILE_NOT_FOUND:
			return ErrERRCheck( JET_errFileNotFound );
		
		case ERROR_PATH_NOT_FOUND:
			return ErrERRCheck( JET_errInvalidPath );

		case ERROR_ACCESS_DENIED:
		case ERROR_SHARING_VIOLATION:
		case ERROR_LOCK_VIOLATION:
		case ERROR_WRITE_PROTECT:
			return ErrERRCheck( JET_errFileAccessDenied );

		case ERROR_TOO_MANY_OPEN_FILES:
			return ErrERRCheck( JET_errOutOfFileHandles );
			break;

		case ERROR_NO_SYSTEM_RESOURCES:
		case ERROR_NOT_ENOUGH_MEMORY:
		case ERROR_WORKING_SET_QUOTA:
			return ErrERRCheck( JET_errOutOfMemory );

		default:
			return ErrERRCheck( JET_errDiskIO );
		}
	}

ERR COSFileSystem::ErrPathRoot(	const _TCHAR* const	szPath,	
								_TCHAR* const		szAbsRootPath )
	{
	ERR		err			= JET_errSuccess;
	_TCHAR	szAbsPath[ IFileSystemAPI::cchPathMax ];
	_TCHAR	szRootPath[ IFileSystemAPI::cchPathMax ];

	//  get the absolute path for the given path

	Call( ErrPathComplete( szPath, szAbsPath ) );

	//  the GetVolumePathName Win32 API is available

	if ( m_pfnGetVolumePathName )
		{
		//  compute the root path in this absolute path
		
		if ( !m_pfnGetVolumePathName( szAbsPath, szRootPath, IFileSystemAPI::cchPathMax ) )
			{
			Call( ErrGetLastError() );
			}
		}

	//  the GetVolumePathName Win32 API is available

	else
		{
		//  setup the root path to be the simple DOS device root from this path
		
		_tsplitpath( szAbsPath, szRootPath, NULL, NULL, NULL );
		_tcscat( szRootPath, _T( "/" ) );
		}

	//  compute the absolute path for the root path

	Call( ErrPathComplete( szRootPath, szAbsRootPath ) );
	return JET_errSuccess;

HandleError:
	_tcscpy( szAbsRootPath, _T( "" ) );
	return err;
	}

COSFileSystem::~COSFileSystem()
	{
	if ( m_hmodKernel32 )
		{
		FreeLibrary( m_hmodKernel32 );
		m_hmodKernel32 = NULL;
		}
	}

ERR COSFileSystem::ErrFileAtomicWriteSize(	const _TCHAR* const	szPath,
											DWORD* const		pcbSize )
	{
	ERR		err		= JET_errSuccess;
	DWORD	error	= ERROR_SUCCESS;
	_TCHAR	szAbsRootPath[ IFileSystemAPI::cchPathMax ];
	DWORD	dwT;

	//  get the root path for the specified path

	Call( ErrPathRoot( szPath, szAbsRootPath ) );

	//  RFS:  bad path

	if ( !RFSAlloc( OSFileISectorSize ) )
		{
		error = ERROR_PATH_NOT_FOUND;
		CallJ( ErrGetLastError( error ), HandleWin32Error );
		}

	//  get the sector size for the root path

	if ( !GetDiskFreeSpace( szAbsRootPath, &dwT, pcbSize, &dwT, &dwT ) )
		{
		error = GetLastError();
		CallJ( ErrGetLastError( error ), HandleWin32Error );
		}

HandleWin32Error:
	if ( err < JET_errSuccess )
		{
		const _TCHAR*	rgpsz[ 8 ];
		DWORD			irgpsz						= 0;
		_TCHAR			szPID[ 64 ];
		_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szError[ 64 ];
		_TCHAR			szSystemError[ 64 ];
		_TCHAR*			szSystemErrorDescription	= NULL;

		_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
		if ( ErrPathComplete( szPath, szAbsPath ) < JET_errSuccess )
			{
			_tcscpy( szAbsPath, szPath );
			}
		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );
		_stprintf( szSystemError, _T( "%u (0x%08x)" ), error, error );
		FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_MAX_WIDTH_MASK ),
						NULL,
						error,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
						LPTSTR( &szSystemErrorDescription ),
						0,
						NULL );

		rgpsz[ irgpsz++ ]	= SzUtilProcessName();
		rgpsz[ irgpsz++ ]	= szPID;
		rgpsz[ irgpsz++ ]	= "";		//	no instance name
		rgpsz[ irgpsz++ ]	= szAbsRootPath;
		rgpsz[ irgpsz++ ]	= szAbsPath;
		rgpsz[ irgpsz++ ]	= szError;
		rgpsz[ irgpsz++ ]	= szSystemError;
		rgpsz[ irgpsz++ ]	= szSystemErrorDescription ? szSystemErrorDescription : _T( "" );

		OSEventReportEvent(	SzUtilImageVersionName(),
							eventError,
							GENERAL_CATEGORY,
							OSFS_SECTOR_SIZE_ERROR_ID,
							irgpsz,
							rgpsz );

		LocalFree( szSystemErrorDescription );
		}
HandleError:
	if ( err < JET_errSuccess )
		{
		*pcbSize = 0;
		}
	return err;
	}

ERR COSFileSystem::ErrPathComplete(	const _TCHAR* const	szPath,	
									_TCHAR* const		szAbsPath )
	{
	ERR err = JET_errSuccess;

	//  RFS:  bad path

	if ( !RFSAlloc( OSFilePathComplete ) )
		{
		Call( ErrERRCheck( JET_errInvalidPath ) );
		}
	
	if ( !_tfullpath( szAbsPath, szPath, IFileSystemAPI::cchPathMax ) )
		{
		Call( ErrERRCheck( JET_errInvalidPath ) );
		}

	return JET_errSuccess;

HandleError:
	return err;
	}

ERR COSFileSystem::ErrPathParse(	const _TCHAR* const	szPath,
									_TCHAR* const		szFolder,
									_TCHAR* const		szFileBase,
									_TCHAR* const		szFileExt )
	{
	_TCHAR szFolderT[ IFileSystemAPI::cchPathMax ];

	*szFolder	= _T( '\0' );
	*szFileBase	= _T( '\0' );
	*szFileExt	= _T( '\0' );
	
	_tsplitpath( szPath, szFolder, szFolderT, szFileBase, szFileExt );

	//	szFolder already contains the drive, so just append
	//	the directory to form the complete folder location
	_tcscat( szFolder, szFolderT );

	return JET_errSuccess;
	}

ERR COSFileSystem::ErrPathBuild(	const _TCHAR* const	szFolder,
									const _TCHAR* const	szFileBase,
									const _TCHAR* const	szFileExt,
									_TCHAR* const		szPath )
	{
	*szPath = _T( '\0' );

	_tmakepath( szPath, NULL, szFolder, szFileBase, szFileExt );

	return JET_errSuccess;
	}

ERR COSFileSystem::ErrFolderCreate( const _TCHAR* const szPath )
	{
	ERR		err		= JET_errSuccess;
	DWORD	error	= ERROR_SUCCESS;

	//  RFS:  access denied

	if ( !RFSAlloc( OSFileCreateDirectory ) )
		{
		error = ERROR_ACCESS_DENIED;
		Call( ErrGetLastError( error ) );
		}
	
	if ( !CreateDirectory( szPath, NULL ) )
		{
		error = GetLastError();
		Call( ErrGetLastError( error ) );
		}

HandleError:
	if ( err < JET_errSuccess )
		{
		const _TCHAR*	rgpsz[ 7 ];
		DWORD			irgpsz						= 0;
		_TCHAR			szPID[ 64 ];
		_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szError[ 64 ];
		_TCHAR			szSystemError[ 64 ];
		_TCHAR*			szSystemErrorDescription	= NULL;

		_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
		if ( ErrPathComplete( szPath, szAbsPath ) < JET_errSuccess )
			{
			_tcscpy( szAbsPath, szPath );
			}
		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );
		_stprintf( szSystemError, _T( "%u (0x%08x)" ), error, error );
		FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_MAX_WIDTH_MASK ),
						NULL,
						error,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
						LPTSTR( &szSystemErrorDescription ),
						0,
						NULL );

		rgpsz[ irgpsz++ ]	= SzUtilProcessName();
		rgpsz[ irgpsz++ ]	= szPID;
		rgpsz[ irgpsz++ ]	= "";		//	no instance name
		rgpsz[ irgpsz++ ]	= szAbsPath;
		rgpsz[ irgpsz++ ]	= szError;
		rgpsz[ irgpsz++ ]	= szSystemError;
		rgpsz[ irgpsz++ ]	= szSystemErrorDescription ? szSystemErrorDescription : _T( "" );

		OSEventReportEvent(	SzUtilImageVersionName(),
							eventError,
							GENERAL_CATEGORY,
							OSFS_CREATE_FOLDER_ERROR_ID,
							irgpsz,
							rgpsz );

		LocalFree( szSystemErrorDescription );
		}
	return err;
	}

ERR COSFileSystem::ErrFolderRemove( const _TCHAR* const szPath )
	{
	ERR		err		= JET_errSuccess;
	DWORD	error	= ERROR_SUCCESS;

	//  RFS:  access denied

	if ( !RFSAlloc( OSFileRemoveDirectory ) )
		{
		error = ERROR_ACCESS_DENIED;
		Call( ErrGetLastError( error ) );
		}
	
	if ( !RemoveDirectory( szPath ) )
		{
		error = GetLastError();
		Call( ErrGetLastError( error ) );
		}

HandleError:
	if ( err == JET_errFileNotFound )
		{
		err = JET_errInvalidPath;
		}
	if (	err < JET_errSuccess &&
			error != ERROR_FILE_NOT_FOUND )
		{
		const _TCHAR*	rgpsz[ 7 ];
		DWORD			irgpsz						= 0;
		_TCHAR			szPID[ 64 ];
		_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szError[ 64 ];
		_TCHAR			szSystemError[ 64 ];
		_TCHAR*			szSystemErrorDescription	= NULL;

		_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
		if ( ErrPathComplete( szPath, szAbsPath ) < JET_errSuccess )
			{
			_tcscpy( szAbsPath, szPath );
			}
		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );
		_stprintf( szSystemError, _T( "%u (0x%08x)" ), error, error );
		FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_MAX_WIDTH_MASK ),
						NULL,
						error,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
						LPTSTR( &szSystemErrorDescription ),
						0,
						NULL );

		rgpsz[ irgpsz++ ]	= SzUtilProcessName();
		rgpsz[ irgpsz++ ]	= szPID;
		rgpsz[ irgpsz++ ]	= "";		//	no instance name
		rgpsz[ irgpsz++ ]	= szAbsPath;
		rgpsz[ irgpsz++ ]	= szError;
		rgpsz[ irgpsz++ ]	= szSystemError;
		rgpsz[ irgpsz++ ]	= szSystemErrorDescription ? szSystemErrorDescription : _T( "" );

		OSEventReportEvent(	SzUtilImageVersionName(),
							eventError,
							GENERAL_CATEGORY,
							OSFS_REMOVE_FOLDER_ERROR_ID,
							irgpsz,
							rgpsz );

		LocalFree( szSystemErrorDescription );
		}
	return err;
	}

ERR COSFileSystem::ErrFileFind(	const _TCHAR* const		szFind,
								IFileFindAPI** const	ppffapi )
	{
	ERR				err		= JET_errSuccess;
	COSFileFind*	posff	= NULL;

	//  allocate the file find iterator
	
	if ( !( posff = new COSFileFind ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  initialize the file find iterator

	Call( posff->ErrInit( this, szFind ) );

	//  return the interface to our file find iterator

	*ppffapi = posff;
	return JET_errSuccess;

HandleError:
	delete posff;
	*ppffapi = NULL;
	return err;
	}

ERR COSFileSystem::ErrFileDelete( const _TCHAR* const szPath )
	{
	ERR		err		= JET_errSuccess;
	DWORD	error	= ERROR_SUCCESS;
	
	//  RFS:  access denied
	
	if ( !RFSAlloc( OSFileDelete ) )
		{
		error = ERROR_ACCESS_DENIED;
		Call( ErrGetLastError( error ) );
		}
	
	if ( !DeleteFile( szPath ) )
		{
		error = GetLastError();
		Call( ErrGetLastError( error ) );
		}

HandleError:
	if (	err < JET_errSuccess &&
			error != ERROR_FILE_NOT_FOUND )
		{
		const _TCHAR*	rgpsz[ 7 ];
		DWORD			irgpsz						= 0;
		_TCHAR			szPID[ 64 ];
		_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szError[ 64 ];
		_TCHAR			szSystemError[ 64 ];
		_TCHAR*			szSystemErrorDescription	= NULL;

		_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
		if ( ErrPathComplete( szPath, szAbsPath ) < JET_errSuccess )
			{
			_tcscpy( szAbsPath, szPath );
			}
		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );
		_stprintf( szSystemError, _T( "%u (0x%08x)" ), error, error );
		FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_MAX_WIDTH_MASK ),
						NULL,
						error,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
						LPTSTR( &szSystemErrorDescription ),
						0,
						NULL );

		rgpsz[ irgpsz++ ]	= SzUtilProcessName();
		rgpsz[ irgpsz++ ]	= szPID;
		rgpsz[ irgpsz++ ]	= "";		//	no instance name
		rgpsz[ irgpsz++ ]	= szAbsPath;
		rgpsz[ irgpsz++ ]	= szError;
		rgpsz[ irgpsz++ ]	= szSystemError;
		rgpsz[ irgpsz++ ]	= szSystemErrorDescription ? szSystemErrorDescription : _T( "" );

		OSEventReportEvent(	SzUtilImageVersionName(),
							eventError,
							GENERAL_CATEGORY,
							OSFS_DELETE_FILE_ERROR_ID,
							irgpsz,
							rgpsz );

		LocalFree( szSystemErrorDescription );
		}
	return err;
	}

ERR COSFileSystem::ErrFileMove(	const _TCHAR* const	szPathSource,
								const _TCHAR* const	szPathDest,
								const BOOL			fOverwriteExisting )
	{
	ERR			err				= JET_errSuccess;
	DWORD		error			= ERROR_SUCCESS;
	const DWORD	dtickTimeout	= cmsecAccessDeniedRetryPeriod;
	DWORD		tickStart		= GetTickCount();	
	
	//  RFS:  pre-move error
	
	if ( !RFSAlloc( OSFileMove ) )
		{
		error = ERROR_ACCESS_DENIED;
		Call( ErrGetLastError( error ) );
		}

	if ( m_fWin9x )
		{
		if ( fOverwriteExisting )
			{
			do
				{
				err		= JET_errSuccess;
				error	= ERROR_SUCCESS;
				
				if ( !DeleteFile( szPathDest ) )
					{
					error	= GetLastError();
					if ( error == ERROR_FILE_NOT_FOUND )
						{
						error = ERROR_SUCCESS;
						}
					err		= ErrGetLastError( error );

					if ( err == JET_errFileAccessDenied )
						{
						Sleep( 1 );
						}
					}
				}
			while ( err == JET_errFileAccessDenied && GetTickCount() - tickStart < dtickTimeout );
			Call( err );
			}

		do
			{
			err		= JET_errSuccess;
			error	= ERROR_SUCCESS;
			
			if ( !MoveFile(	szPathSource, szPathDest ) )
				{
				error	= GetLastError();
				err		= ErrGetLastError();

				if ( err == JET_errFileAccessDenied )
					{
					Sleep( 1 );
					}
				}
			}
		while ( err == JET_errFileAccessDenied && GetTickCount() - tickStart < dtickTimeout );
		Call( err );

		HANDLE	hFileDest = INVALID_HANDLE_VALUE;

		do
			{
			err		= JET_errSuccess;
			error	= ERROR_SUCCESS;
			
			hFileDest = CreateFile(	szPathDest,
									GENERIC_READ | GENERIC_WRITE,
									0,
									NULL,
									OPEN_EXISTING,
									(	FILE_ATTRIBUTE_NORMAL |
										FILE_FLAG_WRITE_THROUGH |
										FILE_FLAG_NO_BUFFERING ),
									NULL );
			if ( hFileDest == INVALID_HANDLE_VALUE )
				{
				error	= GetLastError();
				err		= ErrGetLastError();

				if ( err == JET_errFileAccessDenied )
					{
					Sleep( 1 );
					}
				}
			}
		while ( err == JET_errFileAccessDenied && GetTickCount() - tickStart < dtickTimeout );
		Call( err );
		
		if ( !FlushFileBuffers( hFileDest ) )
			{
			CloseHandle( hFileDest );
			Call( ErrGetLastError() );
			}
		CloseHandle( hFileDest );
		}
	else
		{
		do
			{
			err		= JET_errSuccess;
			error	= ERROR_SUCCESS;
			
			if ( !MoveFileEx(	szPathSource,
								szPathDest,
								(	MOVEFILE_COPY_ALLOWED |
									MOVEFILE_WRITE_THROUGH |
									( fOverwriteExisting ? MOVEFILE_REPLACE_EXISTING : 0 ) ) ) )
				{
				error	= GetLastError();
				err		= ErrGetLastError( error );

				if ( err == JET_errFileAccessDenied )
					{
					Sleep( 1 );
					}
				}
			}
		while ( err == JET_errFileAccessDenied && GetTickCount() - tickStart < dtickTimeout );
		Call( err );
		}
	
	//  RFS:  post-move error
	
	if ( !RFSAlloc( OSFileMove ) )
		{
		error = ERROR_IO_DEVICE;
		Call( ErrGetLastError( error ) );
		}

HandleError:
	if ( err < JET_errSuccess )
		{
		const _TCHAR*	rgpsz[ 8 ];
		DWORD			irgpsz						= 0;
		_TCHAR			szPID[ 64 ];
		_TCHAR			szAbsPathSrc[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szAbsPathDest[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szError[ 64 ];
		_TCHAR			szSystemError[ 64 ];
		_TCHAR*			szSystemErrorDescription	= NULL;

		_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
		if ( ErrPathComplete( szPathSource, szAbsPathSrc ) < JET_errSuccess )
			{
			_tcscpy( szAbsPathSrc, szPathSource );
			}
		if ( ErrPathComplete( szPathDest, szAbsPathDest ) < JET_errSuccess )
			{
			_tcscpy( szAbsPathDest, szPathDest );
			}
		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );
		_stprintf( szSystemError, _T( "%u (0x%08x)" ), error, error );
		FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_MAX_WIDTH_MASK ),
						NULL,
						error,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
						LPTSTR( &szSystemErrorDescription ),
						0,
						NULL );

		rgpsz[ irgpsz++ ]	= SzUtilProcessName();
		rgpsz[ irgpsz++ ]	= szPID;
		rgpsz[ irgpsz++ ]	= "";		//	no instance name
		rgpsz[ irgpsz++ ]	= szAbsPathSrc;
		rgpsz[ irgpsz++ ]	= szAbsPathDest;
		rgpsz[ irgpsz++ ]	= szError;
		rgpsz[ irgpsz++ ]	= szSystemError;
		rgpsz[ irgpsz++ ]	= szSystemErrorDescription ? szSystemErrorDescription : _T( "" );

		OSEventReportEvent(	SzUtilImageVersionName(),
							eventError,
							GENERAL_CATEGORY,
							OSFS_MOVE_FILE_ERROR_ID,
							irgpsz,
							rgpsz );

		LocalFree( szSystemErrorDescription );
		}
	return err;
	}

ERR COSFileSystem::ErrFileCopy(	const _TCHAR* const	szPathSource,
								const _TCHAR* const	szPathDest,
								const BOOL			fOverwriteExisting )
	{
	ERR		err		= JET_errSuccess;
	DWORD	error	= ERROR_SUCCESS;
	
	//  RFS:  pre-copy error
	
	if ( !RFSAlloc( OSFileCopy ) )
		{
		error = ERROR_ACCESS_DENIED;
		Call( ErrGetLastError( error ) );
		}
	
	if ( !CopyFile( szPathSource, szPathDest, !fOverwriteExisting ) )
		{
		error = GetLastError();
		Call( ErrGetLastError( error ) );
		}

	if ( m_fWin9x )
		{
		HANDLE hFileDest = CreateFile(	szPathDest,
										GENERIC_READ | GENERIC_WRITE,
										0,
										NULL,
										OPEN_EXISTING,
										(	FILE_ATTRIBUTE_NORMAL |
											FILE_FLAG_WRITE_THROUGH |
											FILE_FLAG_NO_BUFFERING ),
										NULL );
		if ( hFileDest == INVALID_HANDLE_VALUE )
			{
			error = GetLastError();
			Call( ErrGetLastError( error ) );
			}
		if ( !FlushFileBuffers( hFileDest ) )
			{
			CloseHandle( hFileDest );
			Call( ErrGetLastError() );
			}
		CloseHandle( hFileDest );
		}
	
	//  RFS:  post-copy error
	
	if ( !RFSAlloc( OSFileCopy ) )
		{
		error = ERROR_IO_DEVICE;
		Call( ErrGetLastError( error ) );
		}

HandleError:
	if ( err < JET_errSuccess )
		{
		const _TCHAR*	rgpsz[ 8 ];
		DWORD			irgpsz						= 0;
		_TCHAR			szPID[ 64 ];
		_TCHAR			szAbsPathSrc[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szAbsPathDest[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szError[ 64 ];
		_TCHAR			szSystemError[ 64 ];
		_TCHAR*			szSystemErrorDescription	= NULL;

		_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
		if ( ErrPathComplete( szPathSource, szAbsPathSrc ) < JET_errSuccess )
			{
			_tcscpy( szAbsPathSrc, szPathSource );
			}
		if ( ErrPathComplete( szPathDest, szAbsPathDest ) < JET_errSuccess )
			{
			_tcscpy( szAbsPathDest, szPathDest );
			}
		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );
		_stprintf( szSystemError, _T( "%u (0x%08x)" ), error, error );
		FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_MAX_WIDTH_MASK ),
						NULL,
						error,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
						LPTSTR( &szSystemErrorDescription ),
						0,
						NULL );

		rgpsz[ irgpsz++ ]	= SzUtilProcessName();
		rgpsz[ irgpsz++ ]	= szPID;
		rgpsz[ irgpsz++ ]	= "";		//	no instance name
		rgpsz[ irgpsz++ ]	= szAbsPathSrc;
		rgpsz[ irgpsz++ ]	= szAbsPathDest;
		rgpsz[ irgpsz++ ]	= szError;
		rgpsz[ irgpsz++ ]	= szSystemError;
		rgpsz[ irgpsz++ ]	= szSystemErrorDescription ? szSystemErrorDescription : _T( "" );

		OSEventReportEvent(	SzUtilImageVersionName(),
							eventError,
							GENERAL_CATEGORY,
							OSFS_COPY_FILE_ERROR_ID,
							irgpsz,
							rgpsz );

		LocalFree( szSystemErrorDescription );
		}
	return err;
	}

ERR COSFileSystem::ErrFileCreate(	const _TCHAR* const	szPath,
									IFileAPI** const	ppfapi,
									const BOOL			fAtomic,
									const BOOL			fTemporary,
									const BOOL			fOverwriteExisting,
									const BOOL			fLockFile )
	{
	ERR							err				= JET_errSuccess;
	DWORD						error			= ERROR_SUCCESS;
	COSFile*					posf			= NULL;
	_TCHAR						szAbsPath[ IFileSystemAPI::cchPathMax ];
	DWORD						dtickTimeout	= cmsecAccessDeniedRetryPeriod;
	DWORD						tickStart		= GetTickCount();	
	HANDLE						hFile			= INVALID_HANDLE_VALUE;
	DWORD						cbIOSize;
	BY_HANDLE_FILE_INFORMATION	bhfi;
	QWORD						cbFileSize;
	BOOL						fIsReadOnly;

	//  allocate the file object
	
	if ( !( posf = new COSFile ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

#ifdef LOGPATCH_UNIT_TEST

	hFile			= NULL;
	cbFileSize		= 5 * 1024 * 1024;
	fIsReadOnly		= fFalse;
	cbIOSize		= 512;

#else	//	!LOGPATCH_UNIT_TEST

	//  RFS:  pre-creation error
	
	if ( !RFSAlloc( OSFileCreate ) )
		{
		error = ERROR_ACCESS_DENIED;
		CallJ( ErrGetLastError( error ), HandleWin32Error );
		}

	//  create the file, retrying for a limited time on access denied

	do
		{
		err		= JET_errSuccess;
		error	= ERROR_SUCCESS;
		
		hFile = CreateFile(	szPath,
							GENERIC_READ | GENERIC_WRITE,
							fLockFile ? 0 : FILE_SHARE_READ | FILE_SHARE_WRITE,
							NULL,
							fOverwriteExisting ? CREATE_ALWAYS : CREATE_NEW,
							(	FILE_ATTRIBUTE_NORMAL |
								( m_fWin9x ? 0 : FILE_FLAG_OVERLAPPED ) |
								( fTemporary ? FILE_FLAG_DELETE_ON_CLOSE : 0 ) |
								FILE_FLAG_WRITE_THROUGH |
								FILE_FLAG_NO_BUFFERING ),
							NULL );

		if ( hFile == INVALID_HANDLE_VALUE )
			{
			error	= GetLastError();
			err		= ErrGetLastError( error );

			if ( err == JET_errFileAccessDenied )
				{
				Sleep( 1 );
				}
			}
		}
	while ( err == JET_errFileAccessDenied && GetTickCount() - tickStart < dtickTimeout );
	CallJ( err, HandleWin32Error );

	SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	
	//  RFS:  post-creation error
	
	if ( !RFSAlloc( OSFileCreate ) )
		{
		error = ERROR_IO_DEVICE;
		CallJ( ErrGetLastError( error ), HandleWin32Error );
		}

	//  get the file's properties

	Call( ErrPathComplete( szPath, szAbsPath ) );

	if ( !GetFileInformationByHandle( hFile, &bhfi ) )
		{
		Call( ErrGetLastError() );
		}
	cbFileSize	= ( QWORD( bhfi.nFileSizeHigh ) << 32 ) + bhfi.nFileSizeLow;
	fIsReadOnly	= !!( bhfi.dwFileAttributes & FILE_ATTRIBUTE_READONLY );

	Call( ErrFileAtomicWriteSize( szAbsPath, &cbIOSize ) );

#endif	//	LOGPATCH_UNIT_TEST

	//  initialize the file object

	Call( posf->ErrInit( szAbsPath, hFile, cbFileSize, fIsReadOnly, cbIOSize ) );
	hFile = INVALID_HANDLE_VALUE;

	//  return the interface to our file object

	*ppfapi = posf;

#ifndef LOGPATCH_UNIT_TEST

HandleWin32Error:
	if ( err < JET_errSuccess )
		{
		const _TCHAR*	rgpsz[ 7 ];
		DWORD			irgpsz						= 0;
		_TCHAR			szPID[ 64 ];
		_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szError[ 64 ];
		_TCHAR			szSystemError[ 64 ];
		_TCHAR*			szSystemErrorDescription	= NULL;

		_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
		if ( ErrPathComplete( szPath, szAbsPath ) < JET_errSuccess )
			{
			_tcscpy( szAbsPath, szPath );
			}
		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );
		_stprintf( szSystemError, _T( "%u (0x%08x)" ), error, error );
		FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_MAX_WIDTH_MASK ),
						NULL,
						error,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
						LPTSTR( &szSystemErrorDescription ),
						0,
						NULL );

		rgpsz[ irgpsz++ ]	= SzUtilProcessName();
		rgpsz[ irgpsz++ ]	= szPID;
		rgpsz[ irgpsz++ ]	= "";		//	no instance name
		rgpsz[ irgpsz++ ]	= szAbsPath;
		rgpsz[ irgpsz++ ]	= szError;
		rgpsz[ irgpsz++ ]	= szSystemError;
		rgpsz[ irgpsz++ ]	= szSystemErrorDescription ? szSystemErrorDescription : _T( "" );

		OSEventReportEvent(	SzUtilImageVersionName(),
							eventError,
							GENERAL_CATEGORY,
							OSFS_CREATE_FILE_ERROR_ID,
							irgpsz,
							rgpsz );

		LocalFree( szSystemErrorDescription );
		}

#endif	//	!LOGPATCH_UNIT_TEST

HandleError:
	if ( err < JET_errSuccess )
		{

#ifndef LOGPATCH_UNIT_TEST

		if ( hFile != INVALID_HANDLE_VALUE )
			{
			SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
			CloseHandle( hFile );
			DeleteFile( szPath );
			}

#endif	//	!LOGPATCH_UNIT_TEST

		delete posf;
		*ppfapi = NULL;
		}
	return err;
	}

ERR COSFileSystem::ErrFileOpen(	const _TCHAR* const	szPath,
								IFileAPI** const	ppfapi,
								const BOOL			fReadOnly,
								const BOOL			fLockFile )
	{
	ERR							err				= JET_errSuccess;
	DWORD						error			= ERROR_SUCCESS;
	COSFile*					posf			= NULL;
	_TCHAR						szAbsPath[ IFileSystemAPI::cchPathMax ];
	DWORD						dtickTimeout	= cmsecAccessDeniedRetryPeriod;
	DWORD						tickStart		= GetTickCount();	
	HANDLE						hFile			= INVALID_HANDLE_VALUE;
	DWORD						cbIOSize;
	BY_HANDLE_FILE_INFORMATION	bhfi;
	QWORD						cbFileSize;
	BOOL						fIsReadOnly;

	//  allocate the file object
	
	if ( !( posf = new COSFile ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

#ifdef LOGPATCH_UNIT_TEST

	hFile			= NULL;
	cbFileSize		= 5 * 1024 * 1024;
	fIsReadOnly		= fFalse;
	cbIOSize		= 512;

#else	//	!LOGPATCH_UNIT_TEST

	//  RFS:  access denied
	
	if ( !RFSAlloc( OSFileOpen ) )
		{
		error = ERROR_ACCESS_DENIED;
		CallJ( ErrGetLastError( error ), HandleWin32Error );
		}

	//  create the file, retrying for a limited time on access denied

	do
		{
		err		= JET_errSuccess;
		error	= ERROR_SUCCESS;
		
		hFile = CreateFile(	szPath,
							GENERIC_READ | ( fReadOnly ? 0 : GENERIC_WRITE ),
							(	fLockFile ?
								( fReadOnly ? FILE_SHARE_READ : 0 ) :
								FILE_SHARE_READ | FILE_SHARE_WRITE ),
							NULL,
							OPEN_EXISTING,
							(	FILE_ATTRIBUTE_NORMAL |
								( m_fWin9x ? 0 : FILE_FLAG_OVERLAPPED ) |
								FILE_FLAG_WRITE_THROUGH |
								FILE_FLAG_NO_BUFFERING ),
							NULL );

		if ( hFile == INVALID_HANDLE_VALUE )
			{
			error	= GetLastError();
			err		= ErrGetLastError( error );

			if ( err == JET_errFileAccessDenied )
				{
				Sleep( 1 );
				}
			}
		}
	while ( err == JET_errFileAccessDenied && GetTickCount() - tickStart < dtickTimeout );
	CallJ( err, HandleWin32Error );

	SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	//  get the file's properties

	Call( ErrPathComplete( szPath, szAbsPath ) );

	if ( !GetFileInformationByHandle( hFile, &bhfi ) )
		{
		Call( ErrGetLastError() );
		}
	cbFileSize	= ( QWORD( bhfi.nFileSizeHigh ) << 32 ) + bhfi.nFileSizeLow;
	fIsReadOnly	= !!( bhfi.dwFileAttributes & FILE_ATTRIBUTE_READONLY );

	Call( ErrFileAtomicWriteSize( szAbsPath, &cbIOSize ) );

#endif	//	LOGPATCH_UNIT_TEST

	//  initialize the file object

	Call( posf->ErrInit( szAbsPath, hFile, cbFileSize, fIsReadOnly, cbIOSize ) );
	hFile = INVALID_HANDLE_VALUE;

	//  return the interface to our file object

	*ppfapi = posf;

#ifndef LOGPATCH_UNIT_TEST

HandleWin32Error:
	if (	err < JET_errSuccess &&
			error != ERROR_FILE_NOT_FOUND )
		{
		const _TCHAR*	rgpsz[ 7 ];
		DWORD			irgpsz						= 0;
		_TCHAR			szPID[ 64 ];
		_TCHAR			szAbsPath[ IFileSystemAPI::cchPathMax ];
		_TCHAR			szError[ 64 ];
		_TCHAR			szSystemError[ 64 ];
		_TCHAR*			szSystemErrorDescription	= NULL;

		_stprintf( szPID, _T( "%d" ), DwUtilProcessId() );
		if ( ErrPathComplete( szPath, szAbsPath ) < JET_errSuccess )
			{
			_tcscpy( szAbsPath, szPath );
			}
		_stprintf( szError, _T( "%i (0x%08x)" ), err, err );
		_stprintf( szSystemError, _T( "%u (0x%08x)" ), error, error );
		FormatMessage(	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_FROM_SYSTEM |
							FORMAT_MESSAGE_MAX_WIDTH_MASK ),
						NULL,
						error,
						MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ),
						LPTSTR( &szSystemErrorDescription ),
						0,
						NULL );

		rgpsz[ irgpsz++ ]	= SzUtilProcessName();
		rgpsz[ irgpsz++ ]	= szPID;
		rgpsz[ irgpsz++ ]	= "";		//	no instance name
		rgpsz[ irgpsz++ ]	= szAbsPath;
		rgpsz[ irgpsz++ ]	= szError;
		rgpsz[ irgpsz++ ]	= szSystemError;
		rgpsz[ irgpsz++ ]	= szSystemErrorDescription ? szSystemErrorDescription : _T( "" );

		OSEventReportEvent(	SzUtilImageVersionName(),
							eventError,
							GENERAL_CATEGORY,
							(	fReadOnly ?
									OSFS_OPEN_FILE_RO_ERROR_ID :
									OSFS_OPEN_FILE_RW_ERROR_ID ),
							irgpsz,
							rgpsz );

		LocalFree( szSystemErrorDescription );
		}

#endif	//	!LOGPATCH_UNIT_TEST

HandleError:
	if ( err < JET_errSuccess )
		{

#ifndef LOGPATCH_UNIT_TEST

		if ( hFile != INVALID_HANDLE_VALUE )
			{
			SetHandleInformation( hFile, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
			CloseHandle( hFile );
			}

#endif	//	!LOGPATCH_UNIT_TEST

		delete posf;
		*ppfapi = NULL;
		}
	return err;
	}


COSFileFind::COSFileFind()
	:	m_posfs( NULL ),
		m_hFileFind( INVALID_HANDLE_VALUE ),
		m_fBeforeFirst( fTrue ),
		m_errFirst( JET_errFileNotFound ),
		m_errCurrent( JET_errFileNotFound )
	{
	}

ERR COSFileFind::ErrInit(	COSFileSystem* const	posfs,
							const _TCHAR* const		szFindPath )
	{
	ERR		err				= JET_errSuccess;
	_TCHAR	szAbsFindPath[ IFileSystemAPI::cchPathMax ];
	_TCHAR	szAbsRootPath[ IFileSystemAPI::cchPathMax ];
	_TCHAR	szT[ IFileSystemAPI::cchPathMax ];
	_TCHAR*	pchEnd;
	BOOL	fExpectFolder	= fFalse;

	//  reference the file system object that created this File Find iterator
	
	m_posfs = posfs;

	//  copy our original search criteria
	
	_tcscpy( m_szFindPath, szFindPath );

	//  compute the full path of our search criteria

	CallJ( m_posfs->ErrPathComplete( szFindPath, szAbsFindPath ), DeferredInvalidPath )

	//  we are searching for a specific folder

	pchEnd = szAbsFindPath + _tcslen( szAbsFindPath ) - 1;
	if (	pchEnd > szAbsFindPath &&
			( *pchEnd == _T( '\\' ) || *pchEnd == _T( '/' ) ) )
		{
		//  strip the trailing delimiter from the path

		*pchEnd = _T( '\0' );

		//  remember that we expect to see a folder

		fExpectFolder = fTrue;
		}

	//  compute the absolute path of the folder we are searching

	CallJ( m_posfs->ErrPathParse( szAbsFindPath, m_szAbsFindPath, szT, szT ), DeferredInvalidPath );

	//  look for the first file or folder that matches our search criteria

	WIN32_FIND_DATA wfd;
	m_hFileFind = FindFirstFile( szAbsFindPath, &wfd );

	//  we found something
	
	if ( m_hFileFind != INVALID_HANDLE_VALUE )
		{

		//  setup the iterator to move first on the file or folder that
		//  we found

		_TCHAR	szFile[ IFileSystemAPI::cchPathMax ];
		_TCHAR	szExt[ IFileSystemAPI::cchPathMax ];

		m_fFolder	= !!( wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY );
		CallJ( m_posfs->ErrPathParse( wfd.cFileName, szT, szFile, szExt ), DeferredInvalidPath );
		CallJ( m_posfs->ErrPathBuild( m_szAbsFindPath, szFile, szExt, m_szAbsFoundPath ), DeferredInvalidPath );
		m_cbSize	= ( QWORD( wfd.nFileSizeHigh ) << 32 ) + wfd.nFileSizeLow;
		m_fReadOnly	= !!( wfd.dwFileAttributes & FILE_ATTRIBUTE_READONLY );
		
		m_errFirst = JET_errSuccess;

		//  if we should have found a folder but did not then setup the
		//  iterator to find nothing and return invalid path

		if ( fExpectFolder && !m_fFolder )
			{
			m_errFirst = JET_errInvalidPath;
			}
		}

	//  we didn't find something
	
	else
		{
		//  setup the iterator to move first onto the resulting error
		
		m_errFirst = m_posfs->ErrGetLastError();

		//  if the path was invalid then we did not find any files

		if ( m_errFirst == JET_errInvalidPath )
			{
			m_errFirst = JET_errFileNotFound;
			}

		//  if we failed for some reason other than not finding a file or
		//  folder that match our search criteria then fail the creation
		//  of the File Find iterator with that error
		
		if ( m_errFirst != JET_errFileNotFound )
			{
			Call( ErrERRCheck( m_errFirst ) );
			}

		//  the search criteria exactly matches the root of a volume

		if (	m_posfs->ErrPathRoot( szAbsFindPath, szAbsRootPath ) == JET_errSuccess &&
				!_tcsnicmp(	szAbsFindPath,
							szAbsRootPath,
							max( _tcslen( szAbsFindPath ), _tcslen( szAbsRootPath ) - 1 ) ) )
			{
			//  get the attributes of the root

			const DWORD dwFileAttributes = GetFileAttributes( szAbsFindPath );

			//  we got the attributes of the root
			
			if ( dwFileAttributes != -1 )
				{
				//  setup the iterator to move first onto this root
				
				m_fFolder	= !!( dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY );
				_tcscpy( m_szAbsFoundPath, szAbsFindPath );
				m_cbSize	= 0;
				m_fReadOnly	= !!( dwFileAttributes & FILE_ATTRIBUTE_READONLY );
				
				m_errFirst	= JET_errSuccess;
				}

			//  we failed to get the attributes of the root
			
			else
				{
				//  setup the iterator to move first onto the resulting error
				
				m_errFirst = m_posfs->ErrGetLastError();
				}
			}
		}

	return JET_errSuccess;

HandleError:
	return err;

DeferredInvalidPath:
	//  if the path was invalid then we did not find any files
	m_errFirst = err == JET_errInvalidPath ? JET_errFileNotFound : err;
	return JET_errSuccess;
	}

COSFileFind::~COSFileFind()
	{
	if ( m_posfs )
		{
		//  unreference our file system object

		m_posfs = NULL;
		}
	if ( m_hFileFind != INVALID_HANDLE_VALUE )
		{
		FindClose( m_hFileFind );
		m_hFileFind = INVALID_HANDLE_VALUE;
		}
	m_fBeforeFirst	= fTrue;
	m_errFirst		= JET_errFileNotFound;
	m_errCurrent	= JET_errFileNotFound;
	}

ERR COSFileFind::ErrNext()
	{
	ERR err = JET_errSuccess;

	//  we have yet to move first

	if ( m_fBeforeFirst )
		{
		m_fBeforeFirst = fFalse;

		//  setup the iterator to be on the results of the move first that we
		//  did in ErrInit()
		
		m_errCurrent = m_errFirst;
		}

	//  we can potentially see more files or folders
	
	else if ( m_hFileFind != INVALID_HANDLE_VALUE )
		{
		WIN32_FIND_DATA wfd;

		//  we found another file or folder
		
		if ( FindNextFile( m_hFileFind, &wfd ) )
			{
			//  setup the iterator to be on the file or folder that we found
			
			_TCHAR	szT[ IFileSystemAPI::cchPathMax ];
			_TCHAR	szFile[ IFileSystemAPI::cchPathMax ];
			_TCHAR	szExt[ IFileSystemAPI::cchPathMax ];
			
			m_fFolder	= !!( wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY );
			Call( m_posfs->ErrPathParse( wfd.cFileName, szT, szFile, szExt ) );
			Call( m_posfs->ErrPathBuild( m_szAbsFindPath, szFile, szExt, m_szAbsFoundPath ) );
			m_cbSize	= ( QWORD( wfd.nFileSizeHigh ) << 32 ) + wfd.nFileSizeLow;
			m_fReadOnly	= !!( wfd.dwFileAttributes & FILE_ATTRIBUTE_READONLY );
			
			m_errCurrent = JET_errSuccess;
			}

		//  we didn't find another file or folder
		
		else
			{
			//  setup the iterator to be on the resulting error
			
			m_errCurrent = m_posfs->ErrGetLastError();
			}
		}

	//  we cannot potentially see any more files or folders

	else
		{
		//  setup the iterator to be after last

		m_errCurrent = JET_errFileNotFound;
		}

	//  RFS:  file not found

	if ( !RFSAlloc( OSFileFindNext ) )
		{
		m_errCurrent = JET_errFileNotFound;
		}

	//  check the error state of the iterator's current entry

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}
	
	return JET_errSuccess;

HandleError:
	m_errCurrent = err;
	return err;
	}

ERR COSFileFind::ErrIsFolder( BOOL* const pfFolder )
	{
	ERR err = JET_errSuccess;

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}

	*pfFolder = m_fFolder;
	return JET_errSuccess;

HandleError:
	*pfFolder = fFalse;
	return err;
	}
	
ERR COSFileFind::ErrPath( _TCHAR* const szAbsFoundPath )
	{
	ERR err = JET_errSuccess;

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}

	_tcscpy( szAbsFoundPath, m_szAbsFoundPath );
	return JET_errSuccess;

HandleError:
	_tcscpy( szAbsFoundPath, _T( "" ) );
	return err;
	}
	
ERR COSFileFind::ErrSize( QWORD* const pcbSize )
	{
	ERR err = JET_errSuccess;

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}

	*pcbSize = m_cbSize;
	return JET_errSuccess;

HandleError:
	*pcbSize = 0;
	return err;
	}
	
ERR COSFileFind::ErrIsReadOnly( BOOL* const pfReadOnly )
	{
	ERR err = JET_errSuccess;

	if ( m_errCurrent < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurrent ) );
		}

	*pfReadOnly = m_fReadOnly;
	return JET_errSuccess;

HandleError:
	*pfReadOnly = fFalse;
	return err;
	}


//  initializes an interface to the default OS File System

ERR ErrOSFSCreate( IFileSystemAPI** const ppfsapi )
	{
	ERR				err		= JET_errSuccess;
	COSFileSystem*	posfs	= NULL;

	//  allocate the file system object
	
	if ( !( posfs = new COSFileSystem ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  initialize the file system object

	Call( posfs->ErrInit() );

	//  return the interface to our file system object

	*ppfsapi = posfs;
	return JET_errSuccess;

HandleError:
	delete posfs;
	*ppfsapi = NULL;
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\thread.cxx ===
#include "osstd.hxx"

#include <process.h>


//  Thread Local Storage

//  Internal TLS structure

#include "_tls.hxx"


//  Global TLS List

CRITICAL_SECTION csTlsGlobal;
_TLS* ptlsGlobal;

//  Allocated TLS Entry

//NOTE:	Cannot initialise this variable because the code that allocates
//		TLS and uses this variable to store the index executes before
//		CRTInit, which would subsequently re-initialise the variable
//		with the value specified here
//DWORD dwTlsIndex	= dwTlsInvalid;
DWORD dwTlsIndex;

//  registers the given Internal TLS structure as the TLS for this context

static BOOL FOSThreadITlsRegister( _TLS* ptls )
	{
	BOOL	fAllocatedTls	= fFalse;

	//  we are the first to register TLS

	EnterCriticalSection( &csTlsGlobal );

	if ( NULL == ptlsGlobal )
		{
		//  allocate a new TLS entry

		dwTlsIndex = TlsAlloc();
		if ( dwTlsInvalid == dwTlsIndex )
			{
			LeaveCriticalSection( &csTlsGlobal );
			return fFalse;
			}

		fAllocatedTls = fTrue;
		}

	Assert( dwTlsInvalid != dwTlsIndex );

	//  save the pointer to the given TLS
	const BOOL	fTLSPointerSet	= TlsSetValue( dwTlsIndex, ptls );
	if ( !fTLSPointerSet )
		{
		//	free TLS entry if we allocated one
		if ( fAllocatedTls )
			{
			Assert( NULL == ptlsGlobal );

			const BOOL	fTLSFreed	= TlsFree( dwTlsIndex );
			Assert( fTLSFreed );		//	leak the TLS entry if we fail

			dwTlsIndex = dwTlsInvalid;
			}

		LeaveCriticalSection( &csTlsGlobal );
		return fFalse;
		}

	//  add this TLS into the global list

	ptls->ptlsNext = ptlsGlobal;
	if ( ptls->ptlsNext )
		{
		ptls->ptlsNext->pptlsNext = &ptls->ptlsNext;
		}
	ptls->pptlsNext = &ptlsGlobal;
	ptlsGlobal = ptls;
	LeaveCriticalSection( &csTlsGlobal );

	return fTrue;
	}

//  unregisters the given Internal TLS structure as the TLS for this context

static void OSThreadITlsUnregister( _TLS* ptls )
	{
	//  there should be TLSs registered

	EnterCriticalSection( &csTlsGlobal );
	Assert( ptlsGlobal != NULL );
	
	//  remove our TLS from the global TLS list
	
	if( ptls->ptlsNext )
		{
		ptls->ptlsNext->pptlsNext = ptls->pptlsNext;
		}
	*( ptls->pptlsNext ) = ptls->ptlsNext;

	//  we are the last to unregister our TLS

	if ( ptlsGlobal == NULL )
		{
		//  deallocate TLS entry

		Assert( dwTlsInvalid != dwTlsIndex );

		const BOOL	fTLSFreed = TlsFree( dwTlsIndex );
		Assert( fTLSFreed );	//	leak the TLS entry if we fail

		dwTlsIndex = dwTlsInvalid;
		}

	LeaveCriticalSection( &csTlsGlobal );
	}


//  returns the pointer to the current context's local storage.  if the thread
//  does not yet have TLS, allocate it.

TLS* const Ptls()
	{
	_TLS* ptls	= ( NULL != ptlsGlobal ?
						reinterpret_cast<_TLS *>( TlsGetValue( dwTlsIndex ) ) :
						NULL );

	if ( NULL == ptls )
		{
		while ( !FOSThreadAttach() )
			{
			Sleep( 1000 );
			}

		Assert( dwTlsInvalid != dwTlsIndex );
		ptls = reinterpret_cast<_TLS *>( TlsGetValue( dwTlsIndex ) );
		}

	AssertPREFIX( NULL != ptls );
	return &( ptls->tls );
	}


//  Thread Management

//  suspends execution of the current context for the specified interval

void UtilSleep( const DWORD cmsec )
	{
	//  we should never sleep more than this arbitrary interval

	const DWORD cmsecWait = min( cmsec, 60 * 1000 );

	//  sleep

	SleepEx( cmsecWait, FALSE );
	}

//  thread base function (used by ErrUtilThreadCreate)

struct _THREAD
	{
	PUTIL_THREAD_PROC	pfnStart;
	DWORD_PTR			dwParam;
	const _TCHAR*		szStart;
	HANDLE				hThread;
	DWORD				idThread;
	BOOL				fFinish;
	BOOL				fEndSelf;
	};

DWORD WINAPI UtilThreadIThreadBase( _THREAD* const p_thread )
	{
	DWORD	dwExitCode;
	//  call thread function, catching any exceptions that might happen
	//  if requested

	extern BOOL g_fCatchExceptions;
	if ( g_fCatchExceptions )
		{
		TRY
			{
			dwExitCode = ( p_thread->pfnStart )( p_thread->dwParam );
			}
		EXCEPT( ExceptionFail( p_thread->szStart ) )
			{
			}
		ENDEXCEPT
		}
	else
		{
		dwExitCode = ( p_thread->pfnStart )( p_thread->dwParam );
		}

	//  declare this thread as done

	p_thread->fFinish = fTrue;

	//  cleanup our context if we are ending ourself

	if ( p_thread->fEndSelf )
		{
		UtilThreadEnd( THREAD( p_thread ) );
		}

	//  exit with code from thread function

	return dwExitCode;
	}

//  thread priority table

const DWORD rgthreadpriority[] =
	{
	THREAD_PRIORITY_IDLE,
	THREAD_PRIORITY_LOWEST,
	THREAD_PRIORITY_BELOW_NORMAL,
	THREAD_PRIORITY_NORMAL,
	THREAD_PRIORITY_ABOVE_NORMAL,
	THREAD_PRIORITY_HIGHEST,
	THREAD_PRIORITY_TIME_CRITICAL
	};

//  creates a thread with the specified attributes

const ERR ErrUtilThreadICreate(
	const PUTIL_THREAD_PROC		pfnStart,
	const DWORD					cbStack,
	const EThreadPriority		priority,
	THREAD* const				pThread,
	const DWORD_PTR				dwParam,
	const _TCHAR* const			szStart )
	{
	ERR err;
	
	//  allocate memory to pass thread args

	_THREAD* const p_thread = (_THREAD*)LocalAlloc( 0, sizeof( _THREAD ) );
	if ( p_thread == NULL )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//  setup thread args

	p_thread->pfnStart		= pfnStart;
	p_thread->dwParam		= dwParam;
	p_thread->szStart		= szStart;
	p_thread->hThread		= NULL;
	p_thread->idThread		= 0;
	p_thread->fFinish		= fFalse;
	p_thread->fEndSelf		= fFalse;

	//  create the thread in suspended animation

	p_thread->hThread = HANDLE( CreateThread(	NULL,
												cbStack,
												LPTHREAD_START_ROUTINE( UtilThreadIThreadBase ),
												(void*) p_thread,
												CREATE_SUSPENDED,
												&p_thread->idThread ) );

	if ( !p_thread->hThread )
		{
		Call( ErrERRCheck( JET_errOutOfThreads ) );
		}
	SetHandleInformation( p_thread->hThread, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	
	//  set the thread priority, ignoring any errors encountered because we may
	//  not be allowed to set the priority for a legitimate reason (e.g. quotas)

	SetThreadPriority( p_thread->hThread, rgthreadpriority[ priority ] );

	//  activate the thread

	ResumeThread( p_thread->hThread );

	//  return the handle to the thread

	*pThread = THREAD( p_thread );
	return JET_errSuccess;

HandleError:
	UtilThreadEnd( THREAD( p_thread ) );
	*pThread = THREAD( NULL );
	return err;
	}

//  waits for the specified thread to exit and returns its return value

const DWORD UtilThreadEnd( const THREAD Thread )
	{
	DWORD dwExitCode = 0;
	
	//  we have a thread object
	
	_THREAD* const p_thread = (_THREAD*)Thread;

	if ( p_thread )
		{
		//  the thread was created successfully

		if ( p_thread->hThread )
			{
			//  we are trying to end ourself

			if ( p_thread->idThread == GetCurrentThreadId() )
				{
				//  indicate that we are ending ourself

				p_thread->fEndSelf = fTrue;

				//  do not actually end the thread until it has finished

				if ( !p_thread->fFinish )
					{
					return 0;
					}
				}

			//  we are trying to end another thread

			else
				{
				//  wait for the specified thread to either finish or terminate

				WaitForSingleObjectEx( p_thread->hThread, INFINITE, FALSE );

				//  fetch the thread's exit code

				GetExitCodeThread( p_thread->hThread, &dwExitCode );
				}

			//  cleanup the thread's context

			SetHandleInformation( p_thread->hThread, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
			CloseHandle( p_thread->hThread );
			}
		LocalFree( p_thread );
		}

	//  return the thread's exit code

	return dwExitCode;
	}

//  attaches to the current thread, returning fFalse on failure

const BOOL FOSThreadAttach()
	{
	//  allocate memory for this thread's TLS

	_TLS* const ptls = (_TLS*) LocalAlloc( LMEM_ZEROINIT, sizeof( _TLS ) );
	if ( !ptls )
		{
		return fFalse;
		}

	//  initialize internal TLS fields

	ptls->dwThreadId = GetCurrentThreadId();

	//  register our TLS

	if ( !FOSThreadITlsRegister( ptls ) )
		{
		//	free the entry and fail

		LocalFree( ptls );
		return fFalse;
		}

	return fTrue;
	}

//  detaches from the current thread

static void OSThreadIDetach( _TLS * const ptls )
	{
	//  unregister our TLS

	OSThreadITlsUnregister( ptls );

	//  free our TLS storage

	BOOL fFreedTLSOK = !LocalFree( ptls );
	Assert( fFreedTLSOK );	//	leak the TLS block if we fail
	}

void OSThreadDetach()
	{
	//  retrieve our TLS

	_TLS * const ptls	= ( NULL != ptlsGlobal ?
								reinterpret_cast<_TLS *>( TlsGetValue( dwTlsIndex ) ) :
								NULL );

	if ( NULL != ptls )
		{
		//  clear our TLS pointer from our TLS entry

		const BOOL	fTLSPointerSet	= TlsSetValue( dwTlsIndex, NULL );
		OSSYNCAssert( fTLSPointerSet );

		//	detach using this TLS pointer

		OSThreadIDetach( ptls );
		}
	}


//  returns the current thread's ID
//
//  CONSIDER:  remove our use Ptls()

const DWORD DwUtilThreadId()
	{
	return GetCurrentThreadId();
	}


//  post-terminate thread subsystem

void OSThreadPostterm()
	{
	//	remove any remaining TLS allocated by NT thread pool threads,
	//	which don't seem to perform a DLL_THREAD_DETACH when the
	//	process dies (this will also free any other TLS that got
	//	orphaned for whatever unknown reason)

	while ( ptlsGlobal )
		{
		OSThreadIDetach( ptlsGlobal );
		}

	DeleteCriticalSection( &csTlsGlobal );
	}

//  pre-init thread subsystem

BOOL FOSThreadPreinit()
	{
	//  reset global TLS list

	InitializeCriticalSection( &csTlsGlobal );
	ptlsGlobal = NULL;
	dwTlsIndex = dwTlsInvalid;

	return fTrue;
	}


//  terminate thread subsystem

void OSThreadTerm()
	{
	//  nop
	}

//  init thread subsystem

ERR ErrOSThreadInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\time.cxx ===
#include "osstd.hxx"


//  Low Resolution Timer

//  returns the current timer count (1 Hz)

ULONG_PTR UlUtilGetSeconds()
	{
	return time( NULL );
	}


//  Medium Resolution Timer

//  returns the current timer count (1000 Hz)

TICK TickOSTimeCurrent()
	{
	return TICK( GetTickCount() );
	}


//  High Resolution Timer

//    High Resolution Timer Type

enum HRTType
	{
	hrttNone,
	hrttWin32,
#ifdef TIME_USE_X86_ASM
	hrttPentium,
#endif  //  TIME_USE_X86_ASM
	} hrtt;

//    HRT Frequency

QWORD qwHRTFreq;

#ifdef TIME_USE_X86_ASM

//    Pentium Time Stamp Counter Fetch

#define rdtsc __asm _emit 0x0f __asm _emit 0x31

#endif  //  TIME_USE_X86_ASM

//  returns fTrue if we are allowed to use RDTSC

BOOL IsRDTSCAvailable()
	{
	typedef WINBASEAPI BOOL WINAPI PFNIsProcessorFeaturePresent( IN DWORD ProcessorFeature );

	HMODULE							hmodKernel32					= NULL;
	PFNIsProcessorFeaturePresent*	pfnIsProcessorFeaturePresent	= NULL;
	BOOL							fRDTSCAvailable					= fFalse;

	if ( !( hmodKernel32 = GetModuleHandle( _T( "kernel32.dll" ) ) ) )
		{
		goto NoIsProcessorFeaturePresent;
		}
	if ( !( pfnIsProcessorFeaturePresent = (PFNIsProcessorFeaturePresent*)GetProcAddress( hmodKernel32, _T( "IsProcessorFeaturePresent" ) ) ) )
		{
		goto NoIsProcessorFeaturePresent;
		}

	fRDTSCAvailable = pfnIsProcessorFeaturePresent( PF_RDTSC_INSTRUCTION_AVAILABLE );

NoIsProcessorFeaturePresent:
	return fRDTSCAvailable;
	}

//  initializes the HRT subsystem

void UtilHRTInit()
	{
	//  if we have already been initialized, we're done

	if ( qwHRTFreq )
		{
		return;
		}

#ifdef _M_ALPHA
#else  //  !_M_ALPHA

	//  Win32 high resolution counter is available

	if ( QueryPerformanceFrequency( (LARGE_INTEGER *) &qwHRTFreq ) )
		{
		hrtt = hrttWin32;
		}

	//  Win32 high resolution counter is not available
	
	else
	
#endif  //  _M_ALPHA

		{
		//  fall back on GetTickCount() (ms since Windows has started)
		
		QWORDX qwx;
		qwx.SetDwLow( 1000 );
		qwx.SetDwHigh( 0 );
		qwHRTFreq = qwx.Qw();

		hrtt = hrttNone;
		}

#ifdef TIME_USE_X86_ASM

	//  can we use the TSC?
	
	if ( IsRDTSCAvailable() )
		{
		//  use pentium TSC register, but first find clock frequency experimentally
		
		QWORDX qwxTime1a;
		QWORDX qwxTime1b;
		QWORDX qwxTime2a;
		QWORDX qwxTime2b;
		if ( hrtt == hrttWin32 )
			{
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime1a.m_l,eax	//lint !e530
			__asm mov		qwxTime1a.m_h,edx	//lint !e530
			QueryPerformanceCounter( (LARGE_INTEGER*) qwxTime1b.Pqw() );
			Sleep( 50 );
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime2a.m_l,eax	//lint !e530
			__asm mov		qwxTime2a.m_h,edx	//lint !e530
			QueryPerformanceCounter( (LARGE_INTEGER*) qwxTime2b.Pqw() );
			qwHRTFreq =	( qwHRTFreq * ( qwxTime2a.Qw() - qwxTime1a.Qw() ) ) /
						( qwxTime2b.Qw() - qwxTime1b.Qw() );
			qwHRTFreq = ( ( qwHRTFreq + 50000 ) / 100000 ) * 100000;
			}
		else
			{
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime1a.m_l,eax
			__asm mov		qwxTime1a.m_h,edx
			qwxTime1b.SetDwLow( GetTickCount() );
			qwxTime1b.SetDwHigh( 0 );
			Sleep( 2000 );
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime2a.m_l,eax
			__asm mov		qwxTime2a.m_h,edx
			qwxTime2b.SetDwLow( GetTickCount() );
			qwxTime2b.SetDwHigh( 0 );
			qwHRTFreq =	( qwHRTFreq * ( qwxTime2a.Qw() - qwxTime1a.Qw() ) ) /
						( qwxTime2b.Qw() - qwxTime1b.Qw() );
			qwHRTFreq = ( ( qwHRTFreq + 500000 ) / 1000000 ) * 1000000;
			}

		hrtt = hrttPentium;
		}
		
#endif  //  TIME_USE_X86_ASM

	}

//  returns the current HRT frequency

QWORD QwUtilHRTFreq()
	{
	return qwHRTFreq;
	}

//  returns the current HRT count

QWORD QwUtilHRTCount()
	{
	QWORDX qwx;

	switch ( hrtt )
		{
		case hrttNone:
			qwx.SetDwLow( GetTickCount() );
			qwx.SetDwHigh( 0 );
			break;

		case hrttWin32:
			QueryPerformanceCounter( (LARGE_INTEGER*) qwx.Pqw() );
			break;

#ifdef TIME_USE_X86_ASM

		case hrttPentium:
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwx.m_l,eax
			__asm mov		qwx.m_h,edx
			break;
			
#endif  //  TIME_USE_X86_ASM

		}

	return qwx.Qw();
	}


//  returns the current system date and time

void UtilGetCurrentDateTime( DATETIME *pdate )
	{
	SYSTEMTIME              systemtime;
	
	GetLocalTime( &systemtime );

	pdate->month	= systemtime.wMonth;
	pdate->day		= systemtime.wDay;
	pdate->year		= systemtime.wYear;
	pdate->hour		= systemtime.wHour;
	pdate->minute	= systemtime.wMinute;
	pdate->second	= systemtime.wSecond;
	}
	

// post- terminate time subsystem

void OSTimePostterm()
	{
	//  nop
	}

//  pre-init time subsystem

BOOL FOSTimePreinit()
	{
	//  iniitalize the HRT

	UtilHRTInit();

	return fTrue;
	}


//  terminate time subsystem

void OSTimeTerm()
	{
	//  nop
	}

//  init time subsystem

ERR ErrOSTimeInit()
	{
	//  nop

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\uuid.cxx ===
#include "osstd.hxx"


//	create a new UUID

void OSUUIDCreate( OSUUID* const posuuid )
	{

	//	call the RPC library

	UuidCreate( (UUID*)posuuid );
	}


//	compare two UUIDs for equality

BOOL FOSUUIDEqual( const OSUUID* const posuuid1, const OSUUID* const posuuid2 )
	{

	//	compare the bytes directly

	return BOOL( 0 == memcmp( (void*)posuuid1, (void*)posuuid2, sizeof( OSUUID ) ) );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\eseperf\eseperf.cxx ===
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <tchar.h>
#include <aclapi.h>

	/*  Performance Monitoring support
	/*
	/*  Status information is reported to the Event Log in the PERFORMANCE_CATEGORY
	/**/

#include "perfutil.hxx"
#include "perfmon.hxx"

typedef unsigned long MessageId;
#include "jetusa.h"

#define fTrue	1
#define fFalse	0


///#define DEBUG_PERFMON
#define PERF_TIMEOUT 100
#define PERF_PERFINST_MAX 256


#pragma const_seg( ".text" )
const char szDisplayDevOnly[] = "Squeaky Lobster";
#pragma const_seg()


struct PERFINST
	{
	BOOL	fInitialized;
	HANDLE	hInstanceMutex;
	HANDLE	hReadyEvent;
	HANDLE	hGoEvent;
	HANDLE	hIDAMMF;
	IDA*	pida;
	IDA*	pidaBackup;
	BYTE	rgbReserved[8];
	};

PERFINST rgperfinst[PERF_PERFINST_MAX] = { 0 };

inline _TCHAR* SzPerfGlobal()
	{
	OSVERSIONINFO osverinfo;
	osverinfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
	if ( !GetVersionEx( &osverinfo ) ) 
		{
		return _T("");
		}
	//	Under Win2000 terminal server object names must be preceded by Global\
	//	to share the same name space
	return ( VER_PLATFORM_WIN32_NT == osverinfo.dwPlatformId && 5 <= osverinfo.dwMajorVersion )? _T("Global\\"): _T("");
	}

BOOL AccessInstance( DWORD iInstance, PERFINST** ppperfinst )
	{
	PERFINST*					pperfinst					= rgperfinst + iInstance;
	SID_IDENTIFIER_AUTHORITY	siaWorldSidAuthority		= SECURITY_WORLD_SID_AUTHORITY;
	SID_IDENTIFIER_AUTHORITY	siaLocalSystemSidAuthority	= SECURITY_NT_AUTHORITY;
	PSID						psidWorldSid				= NULL;
	PSID						psidLocalSystemSid			= NULL;
	size_t						cbAcl						= 0;
	PACL						pacl						= NULL;
	PSECURITY_DESCRIPTOR		pSD							= NULL;
	SECURITY_ATTRIBUTES			sa							= { 0 };
	_TCHAR						szT[ 256 ];

	*ppperfinst = NULL;

	if ( !pperfinst->fInitialized )
		{
		/*  create a SD that will be used to create our global objects
		/**/
		if ( !AllocateAndInitializeSid (	&siaWorldSidAuthority,
											1,
											SECURITY_WORLD_RID,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											&psidWorldSid ) )
			{
			goto fail;
			}

		if ( !AllocateAndInitializeSid (	&siaLocalSystemSidAuthority,
											2,
											SECURITY_BUILTIN_DOMAIN_RID,
											DOMAIN_ALIAS_RID_ADMINS,
											0,
											0,
											0,
											0,
											0,
											0,
											&psidLocalSystemSid ) )
			{
			goto fail;
			}

		cbAcl =	sizeof( ACL ) +
				2 * sizeof( ACCESS_ALLOWED_ACE ) +
				GetLengthSid( psidWorldSid ) +
				GetLengthSid( psidLocalSystemSid );

		if ( !( pacl = (PACL)LocalAlloc( 0, cbAcl ) ) )
			{
			goto fail;
			}

		if ( !InitializeAcl(	pacl,
								cbAcl,
								ACL_REVISION2 ) )
			{
			goto fail;
			}

		if ( !AddAccessAllowedAce (	pacl,
									ACL_REVISION2,
									GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
									psidWorldSid ) )
			{
			goto fail;
			}

		if ( !AddAccessAllowedAce (	pacl,
									ACL_REVISION2,
									GENERIC_ALL,
									psidLocalSystemSid ) )
			{
			goto fail;
			}

		if ( !( pSD = (PSECURITY_DESCRIPTOR)LocalAlloc( 0, SECURITY_DESCRIPTOR_MIN_LENGTH ) ) )
			{
			goto fail;
			}

		if ( !InitializeSecurityDescriptor(	pSD,
											SECURITY_DESCRIPTOR_REVISION ) )
			{
			goto fail;
			}

		if ( !SetSecurityDescriptorDacl(	pSD,
											TRUE,
											pacl,
											FALSE ) )
			{
			goto fail;
			}

	    sa.nLength = sizeof( SECURITY_DESCRIPTOR );
	    sa.lpSecurityDescriptor = pSD;
	    sa.bInheritHandle = FALSE;

		/*  open/create the instance mutex
		/**/
		_stprintf( szT, _T( "%sInstance%d:  %s" ), SzPerfGlobal(), iInstance, szPERFVersion );
		if ( !( pperfinst->hInstanceMutex = CreateMutex( &sa, FALSE, szT ) ) )
			{
			goto fail;
			}

		/*	open/create the ready event
		/**/
		_stprintf( szT, _T( "%sReady%d:  %s" ), SzPerfGlobal(), iInstance, szPERFVersion );
		if ( !( pperfinst->hReadyEvent = CreateEvent( &sa, TRUE, FALSE, szT ) ) )
			{
			goto fail;
			}

		/*	open/create the go event
		/**/
		_stprintf( szT, _T( "%sGo%d:  %s" ), SzPerfGlobal(), iInstance, szPERFVersion );
		if ( !( pperfinst->hGoEvent = CreateEvent( &sa, FALSE, FALSE, szT ) ) )
			{
			goto fail;
			}

		/*  open/create the shared instance data area
		/**/
		_stprintf( szT, _T( "%sIDA%d:  %s" ), SzPerfGlobal(), iInstance, szPERFVersion );
		if ( !( pperfinst->hIDAMMF = CreateFileMapping(	INVALID_HANDLE_VALUE,
														&sa,
														PAGE_READWRITE | SEC_COMMIT,
														0,
														PERF_SIZEOF_INSTANCE_DATA,
														szT ) ) )
			{
			goto fail;
			}
		if ( !( pperfinst->pida = PIDA( MapViewOfFile(	pperfinst->hIDAMMF,
														FILE_MAP_WRITE,
														0,
														0,
														0 ) ) ) )
			{
			goto fail;
			}

		if ( !( pperfinst->pidaBackup = PIDA( VirtualAlloc( NULL, PERF_SIZEOF_INSTANCE_DATA, MEM_COMMIT, PAGE_READWRITE ) ) ) )
			{
			goto fail;
			}

		/*  we are now initialized
		/**/
		pperfinst->fInitialized = fTrue;
		}

	*ppperfinst = pperfinst;

fail:
	LocalFree( pacl );
	LocalFree( pSD );
	if ( psidWorldSid )
		{
		FreeSid( psidWorldSid );
		}
	if ( psidLocalSystemSid )
		{
		FreeSid( psidLocalSystemSid );
		}
	if ( !( *ppperfinst ) )
		{
		pperfinst->fInitialized = fFalse;
		if ( pperfinst->pidaBackup )
			{
			VirtualFree( pperfinst->pidaBackup, 0, MEM_RELEASE );
			pperfinst->pidaBackup = NULL;
			}
		if ( pperfinst->pida )
			{
			UnmapViewOfFile( pperfinst->pida );
			pperfinst->pida = NULL;
			}
		if ( pperfinst->hIDAMMF )
			{
			CloseHandle( pperfinst->hIDAMMF );
			pperfinst->hIDAMMF = NULL;
			}
		if ( pperfinst->hGoEvent )
			{
			CloseHandle( pperfinst->hGoEvent );
			pperfinst->hGoEvent = NULL;
			}
		if ( pperfinst->hReadyEvent )
			{
			CloseHandle( pperfinst->hReadyEvent );
			pperfinst->hReadyEvent = NULL;
			}
		if ( pperfinst->hInstanceMutex )
			{
			CloseHandle( pperfinst->hInstanceMutex );
			pperfinst->hInstanceMutex = NULL;
			}
		return FALSE;
		}
	return TRUE;
	}


struct ODA
	{
	DWORD	iNextBlock;		//  Index of next free block
	DWORD	cbAvail;		//  Available bytes
	BYTE*	pbTop;			//  Top of the allocation stack
	BYTE*	pbBlock[];		//  Pointer to each block
	};


extern "C" {

	/*  function prototypes (to keep __stdcall happy)  */
	
DWORD APIENTRY OpenPerformanceData(LPWSTR);
DWORD APIENTRY CollectPerformanceData(LPWSTR, LPVOID *, LPDWORD, LPDWORD);
DWORD APIENTRY ClosePerformanceData(void);

	/*  OpenPerformanceData() is an export that is called when another application
	/*  wishes to start fetching performance data from this DLL.  Any initializations
	/*  that need to be done on the first or subsequent opens are done here.
	/*
	/**/

DWORD dwOpenCount = 0;
DWORD dwFirstCounter;
DWORD dwFirstHelp;
BOOL fTemplateDataInitialized = fFalse;
DWORD cbMaxCounterBlockSize;
DWORD cbInstanceSize;

DWORD APIENTRY OpenPerformanceData(LPWSTR lpwszDeviceNames)
{
	HKEY hkeyPerf = (HKEY)(-1);
	DWORD err = ERROR_SUCCESS;
	DWORD Type;
	LPBYTE lpbData;
	PPERF_OBJECT_TYPE ppotObjectSrc;
	PPERF_INSTANCE_DEFINITION ppidInstanceSrc;
	PPERF_COUNTER_DEFINITION ppcdCounterSrc;
	DWORD dwCurObj;
	DWORD dwCurCtr;
#ifdef DEBUG_PERFMON
	CHAR szDescr[256];
#endif  //  DEBUG_PERFMON
	BOOL fDisplayDevOnly;
	DWORD dwMinDetailLevel;
	DWORD dwOffset;

	if (!dwOpenCount)
	{
			/*  perform first open initializations  */

			/*  initialize system layer  */

		if ((err = DwPerfUtilInit()) != ERROR_SUCCESS)
			goto HandleFirstOpenError;

			/*  initialize template data if not initialized  */

		if (!fTemplateDataInitialized)
		{
				/*  retrieve counter/help ordinals from the registry  */

			if ((err = DwPerfUtilRegOpenKeyEx(
					HKEY_LOCAL_MACHINE,
					"SYSTEM\\CurrentControlSet\\Services\\" SZVERSIONNAME "\\Performance",
					&hkeyPerf)) != ERROR_SUCCESS)
			{
#ifdef DEBUG_PERFMON
				PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE,"Not installed.");
#endif
				goto HandleFirstOpenError;
			}

			err = DwPerfUtilRegQueryValueEx(hkeyPerf,"First Counter",&Type,&lpbData);
			if (err != ERROR_SUCCESS || Type != REG_DWORD) 
			{
#ifdef DEBUG_PERFMON
				PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE,"Installation corrupt.");
#endif
				goto HandleFirstOpenError;

			}
			else
			{
				dwFirstCounter = *((DWORD *)lpbData);
				free(lpbData);
			}

			err = DwPerfUtilRegQueryValueEx(hkeyPerf,"First Help",&Type,&lpbData);
			if (err != ERROR_SUCCESS || Type != REG_DWORD) 
			{
#ifdef DEBUG_PERFMON
				PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE,"Installation corrupt.");
#endif
				goto HandleFirstOpenError;
			}
			else
			{
				dwFirstHelp = *((DWORD *)lpbData);
				free(lpbData);
			}

#ifdef RTM
			err = DwPerfUtilRegQueryValueEx(hkeyPerf,(char*)szDisplayDevOnly,&Type,&lpbData);
			if (err != ERROR_SUCCESS || Type != REG_DWORD) 
			{
				fDisplayDevOnly = fFalse;
			}
			else
			{
				fDisplayDevOnly = *((DWORD *)lpbData) ? fTrue : fFalse;
				free(lpbData);
			}
#else  //  !RTM
			fDisplayDevOnly = fTrue;
#endif  //  RTM

			(VOID)DwPerfUtilRegCloseKeyEx(hkeyPerf);
			hkeyPerf = (HKEY)(-1);

				/*  initialize template data  */
				
			ppotObjectSrc = (PPERF_OBJECT_TYPE)pvPERFDataTemplate;
			ppidInstanceSrc = (PPERF_INSTANCE_DEFINITION)((char *)ppotObjectSrc + ppotObjectSrc->DefinitionLength);
			cbMaxCounterBlockSize = QWORD_MULTIPLE( sizeof(PERF_COUNTER_BLOCK) );
			for (dwCurObj = 0; dwCurObj < dwPERFNumObjects; dwCurObj++)
			{
					/*  update name/help ordinals for object  */
					
				ppotObjectSrc->ObjectNameTitleIndex += dwFirstCounter;
				ppotObjectSrc->ObjectHelpTitleIndex += dwFirstHelp;

				ppcdCounterSrc = (PPERF_COUNTER_DEFINITION)((char *)ppotObjectSrc + ppotObjectSrc->HeaderLength);
				dwMinDetailLevel = PERF_DETAIL_WIZARD;
				dwOffset = QWORD_MULTIPLE( sizeof(PERF_COUNTER_BLOCK) );
				for (dwCurCtr = 0; dwCurCtr < ppotObjectSrc->NumCounters; dwCurCtr++)
				{
						/*  update name/help ordinals for counter  */
						
					ppcdCounterSrc->CounterNameTitleIndex += dwFirstCounter;
					ppcdCounterSrc->CounterHelpTitleIndex += dwFirstHelp;

						/*  this counter is marked as PERF_DETAIL_DEVONLY  */

					if ( ppcdCounterSrc->DetailLevel & PERF_DETAIL_DEVONLY )
					{
							/*  restore true display detail  */
							
						ppcdCounterSrc->DetailLevel &= ~PERF_DETAIL_DEVONLY;

							/*  the counter has not been selected for display  */

						if ( !fDisplayDevOnly )
						{
								/*  conceal the counter  */
								
							ppcdCounterSrc->CounterType = PERF_COUNTER_NODATA;
						}
					}

						/*  get minimum detail level of counters  */

					dwMinDetailLevel = min(dwMinDetailLevel,ppcdCounterSrc->DetailLevel);

						/*  update counter's data offset value  */

					ppcdCounterSrc->CounterOffset = dwOffset;
					dwOffset += QWORD_MULTIPLE( ppcdCounterSrc->CounterSize );
					
					ppcdCounterSrc = (PPERF_COUNTER_DEFINITION)((char *)ppcdCounterSrc + ppcdCounterSrc->ByteLength);
				}

					/*  set object's detail level as the minimum of all its counter's detail levels  */

				ppotObjectSrc->DetailLevel = dwMinDetailLevel;

					/*  keep track of the max counter block size  */

				cbMaxCounterBlockSize = max(cbMaxCounterBlockSize,dwOffset);
				
				ppotObjectSrc = (PPERF_OBJECT_TYPE)((char *)ppotObjectSrc + ppotObjectSrc->TotalByteLength);
			}
			cbInstanceSize = ppidInstanceSrc->ByteLength + cbMaxCounterBlockSize;

			fTemplateDataInitialized = fTrue;
		}
	}

		/*  perform per open initializations  */

	;

		/*  all initialization succeeded  */

	dwOpenCount++;
	
#ifdef DEBUG_PERFMON
	sprintf(szDescr,"Opened successfully.  Open Count = %ld.",dwOpenCount);
	PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_INFORMATION_TYPE,szDescr);
#endif
	
	return ERROR_SUCCESS;

		/*  Error Handlers  */

/*HandlePerOpenError:*/

HandleFirstOpenError:

	if (hkeyPerf != (HKEY)(-1))
		(VOID)DwPerfUtilRegCloseKeyEx(hkeyPerf);

#ifdef DEBUG_PERFMON
	sprintf(szDescr,"Open attempt failed!  Open Count = %ld.",dwOpenCount);
	PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_ERROR_TYPE,szDescr);
#endif
	
	PerfUtilTerm();

	return err;
}


	/*  CollectPerformanceData() is an export that is called by another application to
	/*  collect performance data from this DLL.  A list of the desired data is passed in
	/*  and the requested data is returned ASAP in the caller's buffer.
	/*
	/*  NOTE:  because we are multithreaded, locks must be used in order to update or
	/*  read any performance information in order to avoid reporting bad results.
	/*
	/**/

WCHAR wszDelim[] = L"\n\r\t\v ";
WCHAR wszForeign[] = L"Foreign";
WCHAR wszGlobal[] = L"Global";
WCHAR wszCostly[] = L"Costly";

DWORD APIENTRY CollectPerformanceData(
	LPWSTR  lpwszValueName,
	LPVOID  *lppData,
	LPDWORD lpcbTotalBytes,
	LPDWORD lpNumObjectTypes)
{
	LPWSTR lpwszValue = NULL;
	LPWSTR lpwszTok;
	BOOL fNoObjFound;
	DWORD dwIndex;
	DWORD cbBufferSize;
	PPERF_OBJECT_TYPE ppotObjectSrc;
	PPERF_OBJECT_TYPE ppotObjectDest;
	PPERF_INSTANCE_DEFINITION ppidInstanceSrc;
	PPERF_INSTANCE_DEFINITION ppidInstanceDest;
	PPERF_COUNTER_BLOCK ppcbCounterBlockDest;
	DWORD dwCurObj;
	DWORD dwCurInst;
	DWORD cInstances;
	ODA* poda = NULL;
	long iBlock;

#ifdef DEBUG_PERFMON
	char *rgsz[3];
	char szT[256];
#endif  //  DEBUG_PERFMON

	memset( *lppData, 0xFF, *lpcbTotalBytes );

	/*  grab instance mutex to lock out other instances of this dll
	/**/
	WaitForSingleObject( hPERFInstanceMutex, INFINITE );

		/*  no data if OpenPerformanceData() was never called  */

	if ( !lpwszValueName || !dwOpenCount)
		{
		goto ReturnNoData;
		}
		
		/*  make our own copy of the value string for tokenization and
		/*  get the first token
		/**/

	if (!(lpwszValue = static_cast<WCHAR *>( malloc((wcslen(lpwszValueName)+1)*sizeof(WCHAR)))) )
		goto ReturnNoData;
	lpwszTok = wcstok(wcscpy(lpwszValue,lpwszValueName),wszDelim);
	if ( !lpwszTok )
		{
		goto ReturnNoData;
		}

		/*  we don't support foreign computer data requests  */

	if (!wcscmp(lpwszTok,wszForeign))  /*  lpwszTok == wszForeign  */
		goto ReturnNoData;

		/*  if none of our objects are in the value list, return no data  */

	if (wcscmp(lpwszTok,wszGlobal) && wcscmp(lpwszTok,wszCostly))  /*  lpwszTok != wszGlobal || lpwszTok != wszCostly  */
	{
		fNoObjFound = fTrue;
		do
		{
			dwIndex = (DWORD)wcstoul(lpwszTok,NULL,10)-dwFirstCounter;
			if (dwIndex <= dwPERFMaxIndex)
			{
				fNoObjFound = fFalse;
				break;
			}
		}
		while (lpwszTok = wcstok(NULL,wszDelim));

		if (fNoObjFound)
			goto ReturnNoData;
	}

	/*  initialize output data area
	/**/
	if ( !( poda = (ODA*)VirtualAlloc( NULL, *lpcbTotalBytes, MEM_COMMIT, PAGE_READWRITE ) ) )
		{
		goto ReturnNoData;
		}
	poda->iNextBlock	= 0;
	poda->cbAvail		= *lpcbTotalBytes - sizeof( ODA );
	poda->pbTop			= (BYTE*)poda + *lpcbTotalBytes;

	/*  collect performance data from any instances we can find
	/**/
	DWORD iInstance;
	for (	iInstance = 0;
			iInstance < PERF_PERFINST_MAX && iInstance < pgdaPERFGDA->iInstanceMax;
			iInstance++ )
		{
		/*  access the current instance
		/**/
		PERFINST* pperfinst;
		if ( !AccessInstance( iInstance, &pperfinst ) )
			{
			continue;
			}

		/*  this instance is alive (NOTE:  can detect instance crashes via WAIT_ABANDONED)
		/**/
		if ( WaitForSingleObject( pperfinst->hInstanceMutex, 0 ) == WAIT_TIMEOUT )
			{
			/*  this instance is ready to collect data
			/**/
			if ( WaitForSingleObject( pperfinst->hReadyEvent, 0 ) == WAIT_OBJECT_0 )
				{
				/*  reset the ready event for this instance
				/**/
				ResetEvent( pperfinst->hReadyEvent );

				/*  set the go event for this instance to start data collection
				/**/
				SetEvent( pperfinst->hGoEvent );

				/*  we did not time out waiting for the ready event to be set
				/*  for this instance indicating data collection is complete
				/**/
				if ( WaitForSingleObject( pperfinst->hReadyEvent, PERF_TIMEOUT ) == WAIT_OBJECT_0 )
					{
					/*  copy the new data to the backup data for this instance
					/**/
					memcpy(	pperfinst->pidaBackup,
							pperfinst->pida,
							sizeof( IDA ) + pperfinst->pida->cbPerformanceData );
					}
				}

			/*  the backup data for this instance is valid
			/**/
			if ( pperfinst->pidaBackup->tickConnect == pperfinst->pida->tickConnect )
				{
				/*  add the backup data for this instance to the output data area
				/**/
				if ( poda->cbAvail >= sizeof( DWORD_PTR ) + pperfinst->pidaBackup->cbPerformanceData )
					{
					poda->cbAvail	-= sizeof( DWORD_PTR ) + pperfinst->pidaBackup->cbPerformanceData;
					poda->pbTop		-= pperfinst->pidaBackup->cbPerformanceData;
					poda->pbBlock[ poda->iNextBlock++ ] = poda->pbTop;

					memcpy(	poda->pbTop,
							pperfinst->pidaBackup->rgbPerformanceData,
							pperfinst->pidaBackup->cbPerformanceData );
					}
				else
					{
					goto NeedMoreData;
					}
				}
			}

		/*  this instance is not alive
		/**/
		else
			{
			/*  invalidate any backup data for this instance
			/**/
			pperfinst->pidaBackup->tickConnect = 0;
			
			/*  release the mutex to permit connection to this instance number
			/**/
			ReleaseMutex( pperfinst->hInstanceMutex );
			}
		}

	/*****************************************************************************************
	/*
	/*  NOTE!  This has been designed so that if NO instances of the main DLL are found, the
	/*  buffer filling routines will fill the buffer correctly as if each object has ZERO
	/*  instances (which is permitted).  This is mainly done by having each of the instance
	/*  loops fail on entry because poda->iNextBlock will be ZERO.
	/*
	/****************************************************************************************/
	
    	/*  all data has been collected, so fill the buffer with it and return it.
    	/*  if we happen to run out of space along the way, we will stop building
    	/*  and request more buffer space for next time.
    	/**/

	ppotObjectSrc = (PPERF_OBJECT_TYPE)pvPERFDataTemplate;
	ppotObjectDest = (PPERF_OBJECT_TYPE)*lppData;
	for (dwCurObj = 0; dwCurObj < dwPERFNumObjects; dwCurObj++)
	{
			/*  if the end of this object goes past the buffer, we're out of space  */

		if (((char *)ppotObjectDest - (char *)*lppData) + ppotObjectSrc->DefinitionLength > *lpcbTotalBytes)
			goto NeedMoreData;

			/*  copy current object's template data to buffer  */

		memcpy((void *)ppotObjectDest,(void *)ppotObjectSrc,ppotObjectSrc->DefinitionLength);
	
			/*  update the object's TotalByteLength and NumInstances to include instances  */

		for (iBlock = (long)poda->iNextBlock-1; iBlock >= 0; iBlock--)
			ppotObjectDest->NumInstances += DWORD( *((DWORD_PTR *)poda->pbBlock[iBlock]) );
		ppotObjectDest->TotalByteLength += cbMaxCounterBlockSize + (ppotObjectDest->NumInstances-1)*cbInstanceSize;

			/*  if there are no instances, append a counter block to the object definition  */
		
		if (!ppotObjectDest->NumInstances)
			ppotObjectDest->TotalByteLength += cbMaxCounterBlockSize;

			/*  if the end of this object goes past the buffer, we're out of space  */

		if (((char *)ppotObjectDest - (char *)*lppData) + ppotObjectDest->TotalByteLength > *lpcbTotalBytes)
			goto NeedMoreData;
	
			/*  collect all instances for all processes  */

		ppidInstanceDest = (PPERF_INSTANCE_DEFINITION)((char *)ppotObjectDest + ppotObjectDest->DefinitionLength);
		for (iBlock = (long)poda->iNextBlock-1; iBlock >= 0; iBlock--)
		{
				/*  copy all instance data for the current object for this process  */

			cInstances = DWORD( *((DWORD_PTR *)poda->pbBlock[iBlock]) );
			ppidInstanceSrc = (PPERF_INSTANCE_DEFINITION)(poda->pbBlock[iBlock] + sizeof(DWORD_PTR));
			memcpy((void *)ppidInstanceDest,(void *)ppidInstanceSrc,cbInstanceSize * cInstances);

				/*  update the instance's data fields  */

			for (dwCurInst = 0; dwCurInst < cInstances; dwCurInst++)
			{
					/*  if this is not the root object, setup instance hierarchy information  */
					
				if (dwCurObj)
				{
					ppidInstanceDest->ParentObjectTitleIndex = ((PPERF_OBJECT_TYPE)pvPERFDataTemplate)->ObjectNameTitleIndex;
					ppidInstanceDest->ParentObjectInstance = (long)poda->iNextBlock-1-iBlock;
				}
					
				ppidInstanceDest = (PPERF_INSTANCE_DEFINITION)((char *)ppidInstanceDest+cbInstanceSize);
			}

				/*  increment block offset past used instances  */

			poda->pbBlock[iBlock] += sizeof(DWORD_PTR) + cbInstanceSize * cInstances;
		}

			/*  if there are no instances, zero the counter block  */

		if (!ppotObjectDest->NumInstances)
		{
			ppcbCounterBlockDest = (PPERF_COUNTER_BLOCK)((char *)ppotObjectDest + ppotObjectDest->DefinitionLength);
			memset((void *)ppcbCounterBlockDest,0,cbMaxCounterBlockSize);
			ppcbCounterBlockDest->ByteLength = cbMaxCounterBlockSize;
		}
		
		ppotObjectDest = (PPERF_OBJECT_TYPE)((char *)ppotObjectDest+ppotObjectDest->TotalByteLength);
		ppotObjectSrc = (PPERF_OBJECT_TYPE)((char *)ppotObjectSrc+ppotObjectSrc->TotalByteLength);
	}

	cbBufferSize = DWORD( (char *)ppotObjectDest - (char *)*lppData );
//	Assert( cbBufferSize <= *lpcbTotalBytes );

#ifdef DEBUG_PERFMON
	sprintf(	szT,
				"Data collected starting at 0x%lX with length 0x%lX (0x100 bytes after our data are displayed).  "
				"We were given 0x%lX bytes of buffer.",
				*lppData,
				cbBufferSize,
				*lpcbTotalBytes );
	
	rgsz[0]	= "";
	rgsz[1] = "";
	rgsz[2]	= szT;
	
	ReportEvent(
		hOurEventSource,
		EVENTLOG_ERROR_TYPE,
		(WORD)PERFORMANCE_CATEGORY,
		PLAIN_TEXT_ID,
		0,
		3,
		cbBufferSize + 256,
		(const char **)rgsz,
		*lppData );
#endif  //  DEBUG_PERFMON
			
	free( lpwszValue );
	VirtualFree( poda, 0, MEM_RELEASE );
	*lppData = (void *)ppotObjectDest;
	*lpcbTotalBytes = cbBufferSize;
	*lpNumObjectTypes = dwPERFNumObjects;
	
	ReleaseMutex( hPERFInstanceMutex );
	return ERROR_SUCCESS;

NeedMoreData:
	free( lpwszValue );
	VirtualFree( poda, 0, MEM_RELEASE );
    *lpcbTotalBytes = 0;
    *lpNumObjectTypes = 0;
    
	ReleaseMutex( hPERFInstanceMutex );
	return ERROR_MORE_DATA;

ReturnNoData:
	free( lpwszValue );
	VirtualFree( poda, 0, MEM_RELEASE );
	*lpcbTotalBytes = 0;
	*lpNumObjectTypes = 0;

	ReleaseMutex( hPERFInstanceMutex );
	return ERROR_SUCCESS;
}


	/*  ClosePerformanceData() is an export that is called by another application when
	/*  it no longer desires performance data.  Per application or final termination
	/*  code for the performance routines can be performed here.
	/*
	/**/

DWORD APIENTRY ClosePerformanceData(void)
{
#ifdef DEBUG_PERFMON
	CHAR szDescr[256];
#endif  //  DEBUG_PERFMON

	if (!dwOpenCount)
		return ERROR_SUCCESS;

	dwOpenCount--;
	
		/*  perform per close termination  */

	;

		/*  log closing  */
	
#ifdef DEBUG_PERFMON
	sprintf(szDescr,"Closed successfully.  Open Count = %ld.",dwOpenCount);
	PerfUtilLogEvent(PERFORMANCE_CATEGORY,EVENTLOG_INFORMATION_TYPE,szDescr);
#endif

		/*  perform final close termination  */

	if (!dwOpenCount)
	{
			/*  shut down system layer  */

		PerfUtilTerm();
	}

	return ERROR_SUCCESS;
}


}  //  extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_sfs\sfsfilename.cxx ===
#include "sfsstd.hxx"


//
//	this library has been ported to work with ESE
//


/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Name.c

Abstract:

    The unicode name support package is for manipulating unicode strings
    The routines allow the caller to dissect and compare strings.

    This package uses the same FSRTL_COMPARISON_RESULT typedef used by name.c

    The following routines are provided by this package:

      o  FsRtlDissectName - This routine takes a path name string and breaks
         into two parts.  The first name in the string and the remainder.
         It also checks that the first name is valid for an NT file.

      o  FsRtlColateNames - This routine is used to colate directories
         according to lexical ordering.  Lexical ordering is strict unicode
         numerical oerdering.

      o  FsRtlDoesNameContainWildCards - This routine tells the caller if
         a string contains any wildcard characters.

      o  FsRtlIsNameInExpression - This routine is used to compare a string
         against a template (possibly containing wildcards) to sees if the
         string is in the language denoted by the template.

Author:

    Gary Kimura     [GaryKi]    5-Feb-1990

Revision History:

--*/



//
//	the following UNICODE_STRING definition was ripped from ntdef.h
//
#ifndef _NTDEF_

// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    wchar_t *Buffer;
//#ifdef MIDL_PASS
//    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
//#else // MIDL_PASS
//    PWSTR  Buffer;
//#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;
#define UNICODE_NULL ((wchar_t)0) // winnt

#endif // _NTDEF_

#ifndef IN
#define IN
#endif	//	IN

#ifndef OUT
#define OUT
#endif	//	OUT


//
//  Local support routine prototypes
//

BOOL
FsRtlIsNameInExpressionPrivate(
    IN PUNICODE_STRING Expression,
    IN PUNICODE_STRING Name,
    OUT BOOL *const pfMatch
    );


BOOL
FsRtlIsPathDelimiter( IN wchar_t wch )
	{
	return L'\\' == wch || L'/' == wch;
	}



VOID
FsRtlDissectName (
    IN UNICODE_STRING Path,
    OUT PUNICODE_STRING FirstName,
    OUT PUNICODE_STRING RemainingName
    )

/*++

Routine Description:

    This routine cracks a path.  It picks off the first element in the
    given path name and provides both it and the remaining part.  A path
    is a set of file names separated by backslashes.  If a name begins
    with a backslash, the FirstName is the string immediately following
    the backslash.  Here are some examples:

        Path           FirstName    RemainingName
        ----           ---------    -------------
        empty          empty        empty

        \              empty        empty

        A              A            empty

        \A             A            empty

        A\B\C\D\E      A            B\C\D\E

        *A?            *A?          empty


    Note that both output strings use the same string buffer memory of the
    input string, and are not necessarily null terminated.

    Also, this routine makes no judgement as to the legality of each
    file name componant.  This must be done separatly when each file name
    is extracted.

Arguments:

    Path - The full path name to crack.

    FirstName - The first name in the path.  Don't allocate a buffer for
        this string.

    RemainingName - The rest of the path.  Don't allocate a buffer for this
        string.

Return Value:

    None.

--*/

{
    ULONG i = 0;
    ULONG PathLength;
    ULONG FirstNameStart;

    //
    //  Make both output strings empty for now
    //

    FirstName->Length = 0;
    FirstName->MaximumLength = 0;
    FirstName->Buffer = NULL;

    RemainingName->Length = 0;
    RemainingName->MaximumLength = 0;
    RemainingName->Buffer = NULL;

    PathLength = Path.Length / sizeof(wchar_t);

    //
    //  Check for an empty input string
    //

    if (PathLength == 0) {

        return;
    }

    //
    //  Skip over a starting backslash, and make sure there is more.
    //

    if ( FsRtlIsPathDelimiter( Path.Buffer[0] ) ) {

        i = 1;
    }

    //
    //  Now run down the input string until we hit a backslash or the end
    //  of the string, remembering where we started;
    //

    for ( FirstNameStart = i;
          (i < PathLength) && !FsRtlIsPathDelimiter( Path.Buffer[i] );
          i += 1 ) {

        //	nop
    }

    //
    //  At this point all characters up to (but not including) i are
    //  in the first part.   So setup the first name
    //

    FirstName->Length = (USHORT)((i - FirstNameStart) * sizeof(wchar_t));
    FirstName->MaximumLength = FirstName->Length;
    FirstName->Buffer = &Path.Buffer[FirstNameStart];

    //
    //  Now the remaining part needs a string only if the first part didn't
    //  exhaust the entire input string.  We know that if anything is left
    //  that is must start with a backslash.  Note that if there is only
    //  a trailing backslash, the length will get correctly set to zero.
    //

    if (i < PathLength) {

        RemainingName->Length = (USHORT)((PathLength - (i + 1)) * sizeof(wchar_t));
        RemainingName->MaximumLength = RemainingName->Length;
        RemainingName->Buffer = &Path.Buffer[i + 1];
    }

    //
    //  And return to our caller
    //

    return;
}


BOOL
FsRtlDoesNameContainWildCards (
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine simply scans the input Name string looking for any Nt
    wild card characters.

Arguments:

    Name - The string to check.

Return Value:

    BOOL - fTrue if one or more wild card characters was found.

--*/
{
    USHORT *p;

    //
    //  Check each character in the name to see if it's a wildcard
    //  character.
    //

    if( Name->Length ) {
        for( p = Name->Buffer + (Name->Length / sizeof(wchar_t)) - 1;
             p >= Name->Buffer && !FsRtlIsPathDelimiter( *p );
             p-- ) {

            //
            //  check for a wild card character
            //

//            if (FsRtlIsUnicodeCharacterWild( *p )) {
			if ( L'*' == *p || L'?' == *p ) {

                //
                //  Tell caller that this name contains wild cards
                //

                return fTrue;
            }
        }
    }

    //
    //  No wildcard characters were found, so return to our caller
    //

    return fFalse;
}



//
//  The following routine is just a wrapper around
//  FsRtlIsNameInExpressionPrivate to make a last minute fix a bit safer.
//

BOOL
FsRtlIsNameInExpression (
    IN PUNICODE_STRING Expression,
    IN PUNICODE_STRING Name,
    OUT BOOL *const pfMatch
    )

{

	//	verify input

	Assert( pfMatch );

    return FsRtlIsNameInExpressionPrivate( Expression,
                                           Name,
                                           pfMatch );

}


#define MATCHES_ARRAY_SIZE 16

//
//  Local support routine prototypes
//

ERR
FsRtlIsNameInExpressionPrivate (
    IN PUNICODE_STRING Expression,
    IN PUNICODE_STRING Name,
    OUT BOOL *const pfMatch
    )

/*++

Routine Description:

    This routine compares a Dbcs name and an expression and tells the caller
    if the name is in the language defined by the expression.  The input name
    cannot contain wildcards, while the expression may contain wildcards.

    Expression wild cards are evaluated as shown in the nondeterministic
    finite automatons below.  Note that ~* and ~? are DOS_STAR and DOS_QM.


             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT


                                       S
                                    <-----<
                                 X  |     |  e       Y
             X * Y ==       (0)----->-(1)->-----(2)-----(3)


                                      S-.
                                    <-----<
                                 X  |     |  e       Y
             X ~* Y ==      (0)----->-(1)->-----(2)-----(3)



                                X     S     S     Y
             X ?? Y ==      (0)---(1)---(2)---(3)---(4)



                                X     .        .      Y
             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^


                                X     S-.     S-.     Y
             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^



         where S is any single character

               S-. is any single character except the final .

               e is a null character transition

               EOF is the end of the name string

    In words:

        * matches 0 or more characters.

        ? matches exactly 1 character.

        DOS_STAR matches 0 or more characters until encountering and matching
            the final . in the name.

        DOS_QM matches any single character, or upon encountering a period or
            end of name string, advances the expression to the end of the
            set of contiguous DOS_QMs.

        DOS_DOT matches either a . or zero characters beyond name string.

Arguments:

    Expression - Supplies the input expression to check against
        (Caller must already upcase if passing CaseInsensitive fTrue.)

    Name - Supplies the input name to check for.

    CaseInsensitive - fTrue if Name should be Upcased before comparing.

Return Value:

    BOOL - fTrue if Name is an element in the set of strings denoted
        by the input Expression and fFalse otherwise.

--*/

{
    USHORT NameOffset;
    USHORT ExprOffset;

    ULONG SrcCount;
    ULONG DestCount;
    ULONG PreviousDestCount;
    ULONG MatchesCount;

    wchar_t NameChar, ExprChar;

    USHORT LocalBuffer[MATCHES_ARRAY_SIZE * 2];

    USHORT *AuxBuffer = NULL;
    USHORT *PreviousMatches;
    USHORT *CurrentMatches;

    USHORT MaxState;
    USHORT CurrentState;

    BOOL NameFinished = fFalse;

	Assert( pfMatch );

	*pfMatch = fFalse;

    //
    //  The idea behind the algorithm is pretty simple.  We keep track of
    //  all possible locations in the regular expression that are matching
    //  the name.  If when the name has been exhausted one of the locations
    //  in the expression is also just exhausted, the name is in the language
    //  defined by the regular expression.
    //

    Assert( Name->Length != 0 );
    Assert( Expression->Length != 0 );

    //
    //  If one string is empty return fFalse.  If both are empty return fTrue.
    //

    if ( (Name->Length == 0) || (Expression->Length == 0) ) {

        *pfMatch = (BOOL)(!(Name->Length + Expression->Length));
        return JET_errSuccess;
    }

    //
    //  Special case by far the most common wild card search of *
    //

    if ((Expression->Length == 2) && (Expression->Buffer[0] == L'*')) {

        *pfMatch = fTrue;
        return JET_errSuccess;
    }

    //
    //  Also special case expressions of the form *X.  With this and the prior
    //  case we have covered virtually all normal queries.
    //

    if (Expression->Buffer[0] == L'*') {

        UNICODE_STRING LocalExpression;

        LocalExpression = *Expression;

        LocalExpression.Buffer += 1;
        LocalExpression.Length -= 2;

        //
        //  Only special case an expression with a single *
        //

        if ( !FsRtlDoesNameContainWildCards( &LocalExpression ) ) {

            ULONG StartingNameOffset;

            if (Name->Length < (USHORT)(Expression->Length - sizeof(wchar_t))) {

                *pfMatch = fFalse;
                return JET_errSuccess;
            }

            StartingNameOffset = ( Name->Length -
                                   LocalExpression.Length ) / sizeof(wchar_t);

            //
            //  Do a simple memory compare if case sensitive, otherwise
            //  we have got to check this one character at a time.
            //

            // *pfMatch = (BOOL)( 0 == memcmp( LocalExpression.Buffer,
            //                            Name->Buffer + StartingNameOffset,
            //                            LocalExpression.Length ) );

			*pfMatch = BOOL( 0 == LSFSNAMECompare( LocalExpression.Buffer, Name->Buffer + StartingNameOffset ) );
                							
            return JET_errSuccess;
        }
    }

    //
    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the expression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the expression can represent one or two
    //  states.  * and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expreesion characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //  NameOffset  - The offset of the current name char being processed.
    //
    //  ExprOffset  - The offset of the current expression char being processed.
    //
    //  SrcCount    - Prior match being investigated with current name char
    //
    //  DestCount   - Next location to put a matching assuming current name char
    //
    //  NameFinished - Allows one more itteration through the Matches array
    //                 after the name is exhusted (to come *s for example)
    //
    //  PreviousDestCount - This is used to prevent entry duplication, see coment
    //
    //  PreviousMatches   - Holds the previous set of matches (the Src array)
    //
    //  CurrentMatches    - Holds the current set of matches (the Dest array)
    //
    //  AuxBuffer, LocalBuffer - the storage for the Matches arrays
    //

    //
    //  Set up the initial variables
    //

    PreviousMatches = &LocalBuffer[0];
    CurrentMatches = &LocalBuffer[MATCHES_ARRAY_SIZE];

    PreviousMatches[0] = 0;
    MatchesCount = 1;

    NameOffset = 0;

    MaxState = (USHORT)(Expression->Length * 2);

    while ( !NameFinished ) {

        if ( NameOffset < Name->Length ) {

            NameChar = Name->Buffer[NameOffset / sizeof(wchar_t)];

            NameOffset += sizeof(wchar_t);;

        } else {

            NameFinished = fTrue;

            //
            //  if we have already exhasted the expression, cool.  Don't
            //  continue.
            //

            if ( PreviousMatches[MatchesCount-1] == MaxState ) {

                break;
            }
        }


        //
        //  Now, for each of the previous stored expression matches, see what
        //  we can do with this name character.
        //

        SrcCount = 0;
        DestCount = 0;
        PreviousDestCount = 0;

        while ( SrcCount < MatchesCount ) {

            USHORT Length;

            //
            //  We have to carry on our expression analysis as far as possible
            //  for each character of name, so we loop here until the
            //  expression stops matching.  A clue here is that expression
            //  cases that can match zero or more characters end with a
            //  continue, while those that can accept only a single character
            //  end with a break.
            //

            ExprOffset = (USHORT)((PreviousMatches[SrcCount++] + 1) / 2);


            Length = 0;

            while ( fTrue ) {

                if ( ExprOffset == Expression->Length ) {

                    break;
                }

                //
                //  The first time through the loop we don't want
                //  to increment ExprOffset.
                //

                ExprOffset = USHORT( ExprOffset + Length );
                Length = sizeof(wchar_t);

                CurrentState = (USHORT)(ExprOffset * 2);

                if ( ExprOffset == Expression->Length ) {

                    CurrentMatches[DestCount++] = MaxState;
                    break;
                }

                ExprChar = Expression->Buffer[ExprOffset / sizeof(wchar_t)];

                //
                //  Before we get started, we have to check for something
                //  really gross.  We may be about to exhaust the local
                //  space for ExpressionMatches[][], so we have to allocate
                //  some pool if this is the case.  Yuk!
                //

                if ( (DestCount >= MATCHES_ARRAY_SIZE - 2) &&
                     (AuxBuffer == NULL) ) {

                    ULONG ExpressionChars;

                    ExpressionChars = Expression->Length / sizeof(wchar_t);

					AuxBuffer = new USHORT[(ExpressionChars+1)*2*2];
					if ( !AuxBuffer )
						{
						return ErrERRCheck( JET_errOutOfMemory );
						}

					memcpy( AuxBuffer, CurrentMatches, MATCHES_ARRAY_SIZE * sizeof( USHORT ) );
					CurrentMatches = AuxBuffer;

					memcpy( AuxBuffer + (ExpressionChars+1)*2, PreviousMatches, MATCHES_ARRAY_SIZE * sizeof( USHORT ) );
					PreviousMatches = AuxBuffer + (ExpressionChars+1)*2;

/**********************************************************************

                    AuxBuffer = FsRtlpAllocatePool( PagedPool,
                                                    (ExpressionChars+1) *
                                                    sizeof(USHORT)*2*2 );

                    RtlCopyMemory( AuxBuffer,
                                   CurrentMatches,
                                   MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    CurrentMatches = AuxBuffer;

                    RtlCopyMemory( AuxBuffer + (ExpressionChars+1)*2,
                                   PreviousMatches,
                                   MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    PreviousMatches = AuxBuffer + (ExpressionChars+1)*2;

**********************************************************************/
                }

                //
                //  * matches any character zero or more times.
                //

                if (ExprChar == L'*') {

                    CurrentMatches[DestCount++] = CurrentState;
                    CurrentMatches[DestCount++] = USHORT( CurrentState + 3 );
                    continue;
                }


/**************************************************************************************
                //
                //  DOS_STAR matches any character except . zero or more times.
                //

                if (ExprChar == DOS_STAR) {

                    BOOL ICanEatADot = fFalse;

                    //
                    //  If we are at a period, determine if we are allowed to
                    //  consume it, ie. make sure it is not the last one.
                    //

                    if ( !NameFinished && (NameChar == '.') ) {

                        USHORT Offset;

                        for ( Offset = NameOffset;
                              Offset < Name->Length;
                              Offset += Length ) {

                            if (Name->Buffer[Offset / sizeof(wchar_t)] == L'.') {

                                ICanEatADot = fTrue;
                                break;
                            }
                        }
                    }

                    if (NameFinished || (NameChar != L'.') || ICanEatADot) {

                        CurrentMatches[DestCount++] = CurrentState;
                        CurrentMatches[DestCount++] = CurrentState + 3;
                        continue;

                    } else {

                        //
                        //  We are at a period.  We can only match zero
                        //  characters (ie. the epsilon transition).
                        //

                        CurrentMatches[DestCount++] = CurrentState + 3;
                        continue;
                    }
                }
**************************************************************************************/

                //
                //  The following expreesion characters all match by consuming
                //  a character, thus force the expression, and thus state
                //  forward.
                //

                CurrentState += (USHORT)(sizeof(wchar_t) * 2);

/**************************************************************************************
                //
                //  DOS_QM is the most complicated.  If the name is finished,
                //  we can match zero characters.  If this name is a '.', we
                //  don't match, but look at the next expression.  Otherwise
                //  we match a single character.
                //

                if ( ExprChar == DOS_QM ) {

                    if ( NameFinished || (NameChar == L'.') ) {

                        continue;
                    }

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }
**************************************************************************************/

/**************************************************************************************
                //
                //  A DOS_DOT can match either a period, or zero characters
                //  beyond the end of name.
                //

                if (ExprChar == DOS_DOT) {

                    if ( NameFinished ) {

                        continue;
                    }

                    if (NameChar == L'.') {

                        CurrentMatches[DestCount++] = CurrentState;
                        break;
                    }
                }
**************************************************************************************/

                //
                //  From this point on a name character is required to even
                //  continue, let alone make a match.
                //

                if ( NameFinished ) {

                    break;
                }

                //
                //  If this expression was a '?' we can match it once.
                //

                if (ExprChar == L'?') {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  Finally, check if the expression char matches the name char
                //

                if (ExprChar == (wchar_t)NameChar) {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  The expression didn't match so go look at the next
                //  previous match.
                //

                break;
            }


            //
            //  Prevent duplication in the destination array.
            //
            //  Each of the arrays is montonically increasing and non-
            //  duplicating, thus we skip over any source element in the src
            //  array if we just added the same element to the destination
            //  array.  This guarentees non-duplication in the dest. array.
            //

            if ((SrcCount < MatchesCount) &&
                (PreviousDestCount < DestCount) ) {

                while (PreviousDestCount < DestCount) {

                    while ( PreviousMatches[SrcCount] <
                         CurrentMatches[PreviousDestCount] ) {

                        SrcCount += 1;
                    }

                    PreviousDestCount += 1;
                }
            }
        }

        //
        //  If we found no matches in the just finished itteration, it's time
        //  to bail.
        //

        if ( DestCount == 0 ) {

            if (AuxBuffer != NULL) { delete [] AuxBuffer; }

            *pfMatch = fFalse;
            return JET_errSuccess;
        }

        //
        //  Swap the meaning the two arrays
        //

        {
            USHORT *Tmp;

            Tmp = PreviousMatches;

            PreviousMatches = CurrentMatches;

            CurrentMatches = Tmp;
        }

        MatchesCount = DestCount;
    }


    CurrentState = PreviousMatches[MatchesCount-1];

    if (AuxBuffer != NULL) { delete [] AuxBuffer; }

    *pfMatch = (BOOL)(CurrentState == MaxState);
    return JET_errSuccess;
}


//	compare two file names (will not fail with mixed '\\' and '/' path delimiters)

LONG LSFSNAMECompare(	const wchar_t* const	pwszPath1,
						const wchar_t* const	pwszPath2,
						const ULONG				cchMax )
	{
	LONG	cch1;
	LONG	cch2;

	//	verify input

	Assert( pwszPath1 );
	Assert( pwszPath2 );

#ifdef DEBUG

	//	verify that the paths are normalized

	wchar_t	wszPath1Normal[IFileSystemAPI::cchPathMax];
	wchar_t	wszPath2Normal[IFileSystemAPI::cchPathMax];

	OSSTRCopyW( wszPath1Normal, pwszPath1 );
	OSSTRCopyW( wszPath2Normal, pwszPath2 );

	SFSNAMENormalize( wszPath1Normal );
	SFSNAMENormalize( wszPath2Normal );

	Assert( 0 == LOSSTRCompareW( wszPath1Normal, pwszPath1 ) );
	Assert( 0 == LOSSTRCompareW( wszPath2Normal, pwszPath2 ) );

	Assert( 0 == memcmp( wszPath1Normal, pwszPath1, LOSSTRLengthW( pwszPath1 ) ) );
	Assert( 0 == memcmp( wszPath2Normal, pwszPath2, LOSSTRLengthW( pwszPath2 ) ) );

#endif	//	DEBUG

	//	calculate the string lengths

	cch1 = LOSSTRLengthW( pwszPath1 );
	cch2 = LOSSTRLengthW( pwszPath2 );

	//	limit the lengths

	if ( cch1 > cchMax )
		{
		cch1 = cchMax;
		}
	if ( cch2 > cchMax )
		{
		cch2 = cchMax;
		}

	//	compare the lengths first

	if ( cch1 < cch2 )
		{
		return -1;
		}
	else if ( cch1 > cch2 )
		{
		return +1;
		}

	return memcmp( pwszPath1, pwszPath2, cch1 * sizeof( wchar_t ) );
	}


//	normalize a file name

VOID SFSNAMENormalize( wchar_t* const pwszPath )
	{
	wchar_t	*pwsz;

	//	verify input

	Assert( pwszPath );

	//	find the last '/' or '\\'

	for ( pwsz = pwszPath + LOSSTRLengthW( pwszPath ) - 1; pwsz >= pwszPath; pwsz-- )
		{
		if ( L'/' == *pwsz || L'\\' == *pwsz )
			{
			pwsz++;
			break;
			}
		}
	Assert( pwsz != pwszPath );

	if ( pwsz > pwszPath )
		{

		//	we found a '\\'

		Assert( L'\\' == pwsz[-1] || L'/' == pwsz[-1] );

		//	get the length of the filename

		const ULONG	cchFilename = LOSSTRLengthW( pwsz );

		//	copy only the filename

		memmove( pwszPath, pwsz, ( cchFilename + 1 ) * sizeof( wchar_t ) );
		Assert( L'\0' == pwszPath[cchFilename] );
		}

	//	convert it to upper-case

	_wcsupr( pwszPath );
	}


//	check for wildcards in the given file name

BOOL FSFSNAMEContainsWildcards( const wchar_t* const pwszPath )
	{
	UNICODE_STRING	Path;

	//	verify input

	Assert( pwszPath );

	//	prepare to call FsRtlDoesNameContainWildCards

	Path.Length = USHORT( LOSSTRLengthW( pwszPath ) * sizeof( wchar_t ) );
	Path.MaximumLength = Path.Length;
	Path.Buffer = const_cast< wchar_t *const >( pwszPath );

	//	do the work

	return FsRtlDoesNameContainWildCards( &Path );
	}


//	tokenize a file path by separating the first subdirectory/file from the rest of the path.
//	the token and the resulting path are returned in separate, private buffers.
//	(see the comment in FsRtlDissectName for specific details)

VOID SFSNAMETokenize(	const wchar_t *const	pwszPath,
						wchar_t *const			pwszToken,
						wchar_t *const			pwszLeftoverPath )
	{
	UNICODE_STRING	Path;
	UNICODE_STRING	FirstName;
	UNICODE_STRING	RemainingName;

	//	verify input

	Assert( pwszPath );
	Assert( pwszToken );
	Assert( pwszLeftoverPath );

	//	prepare to call FsRtlDissectName

	Path.Length = USHORT( LOSSTRLengthW( pwszPath ) * sizeof( wchar_t ) );
	Path.MaximumLength = Path.Length;
	Path.Buffer = const_cast< wchar_t *const >( pwszPath );

	//	do the work

	FsRtlDissectName( Path, &FirstName, &RemainingName );
	Assert( FirstName.Length % sizeof( wchar_t ) == 0 );
	Assert( RemainingName.Length % sizeof( wchar_t ) == 0 );

	//	copy the output to the private buffers

	if ( FirstName.Buffer )
		{
		memcpy( pwszToken, FirstName.Buffer, FirstName.Length );
		}
	pwszToken[FirstName.Length / sizeof( wchar_t )] = L'\0';
	if ( RemainingName.Buffer )
		{
		memcpy( pwszLeftoverPath, RemainingName.Buffer, RemainingName.Length * sizeof( wchar_t ) );
		}
	pwszLeftoverPath[RemainingName.Length / sizeof( wchar_t )] = L'\0';
	}


//	in-place version of the function above
//	NOTE: inserts a NULL separator between the token and the leftover path

VOID SFSNAMETokenize(	const wchar_t* const	pwszPath,
						wchar_t** const			ppwszToken,
						wchar_t** const			ppwszLeftoverPath )
	{
	UNICODE_STRING	Path;
	UNICODE_STRING	FirstName;
	UNICODE_STRING	RemainingName;

	//	verify input

	Assert( pwszPath );
	Assert( ppwszToken );
	Assert( ppwszLeftoverPath );

	//	reset output

	*ppwszToken			= NULL;
	*ppwszLeftoverPath	= NULL;

	//	prepare to call FsRtlDissectName

	Path.Length = USHORT( LOSSTRLengthW( pwszPath ) * sizeof( wchar_t ) );
	Path.MaximumLength = Path.Length;
	Path.Buffer = const_cast< wchar_t *const >( pwszPath );

	//	do the work

	FsRtlDissectName( Path, &FirstName, &RemainingName );
	Assert( FirstName.Length % sizeof( wchar_t ) == 0 );
	Assert( RemainingName.Length % sizeof( wchar_t ) == 0 );

	//	prepare the resulting pointers

	Assert( 0 == RemainingName.Length || FirstName.Length > 0 );
	Assert( !RemainingName.Buffer || FirstName.Buffer );

	if ( FirstName.Buffer )
		{

		//	set the pointer to the new token

		*ppwszToken = FirstName.Buffer;

		//	replace the path delimitere with a NULL character to terminate the token

		FirstName.Buffer[ FirstName.Length / sizeof( wchar_t ) ] = L'\0';

		if ( RemainingName.Buffer )
			{

			//	set the pointer to the remaining token(s)

			*ppwszLeftoverPath = RemainingName.Buffer;
			}
		}
	}


//	parse the given path into the components (dir, file name, and file extension)

VOID SFSNAMEParse(	const wchar_t *const	pwszPath,
					wchar_t *const			pwszDir,
					wchar_t *const			pwszFileBase,
					wchar_t *const			pwszFileExt )
	{
	UNICODE_STRING	Path;
	UNICODE_STRING	FirstName;
	UNICODE_STRING	RemainingName;
	wchar_t			*pwszNameT;
	wchar_t			*pwszExtT;
	USHORT			cchT;

	//	verify input

	Assert( pwszPath );

	//	prepare to call FsRtlDissectName

	Path.Length = USHORT( LOSSTRLengthW( pwszPath ) * sizeof( wchar_t ) );
	Path.MaximumLength = Path.Length;
	Path.Buffer = const_cast< wchar_t *const >( pwszPath );

	//	dissect the name until we end up with nothing left

	while ( fTrue )
		{
		FsRtlDissectName( Path, &FirstName, &RemainingName );
		Assert( FirstName.Length % sizeof( wchar_t ) == 0 );
		Assert( RemainingName.Length % sizeof( wchar_t ) == 0 );

		if ( !RemainingName.Buffer )
			{
			break;
			}
		Path.Length = RemainingName.Length;
		Path.MaximumLength = RemainingName.Length;
		Path.Buffer = RemainingName.Buffer;
		}

	if ( FirstName.Buffer )
		{

		//	set the file name ptr

		pwszNameT = FirstName.Buffer;

		//	find the last '.' (it marks the start of the file extention)

		pwszExtT = FirstName.Buffer + ( FirstName.Length / sizeof( wchar_t ) );
		while ( pwszExtT > FirstName.Buffer && L'.' != *pwszExtT )
			{
			pwszExtT--;
			}
		if ( L'.' != *pwszExtT )
			{

			//	no file extention was given

			Assert( pwszExtT == FirstName.Buffer );
			pwszExtT = FirstName.Buffer + ( FirstName.Length / sizeof( wchar_t ) );
			}
		}
	else
		{

		//	no file name was given

		pwszNameT = const_cast< wchar_t *const >( pwszPath ) + LOSSTRLengthW( pwszPath );
		pwszExtT = pwszNameT;
		}

	//	return the results

	if ( pwszDir )
		{
		cchT = USHORT( pwszNameT - const_cast< wchar_t *const >( pwszPath ) );
		if ( cchT )
			{
			memcpy( pwszDir, pwszPath, cchT * sizeof( wchar_t ) );
			}
		pwszDir[cchT] = L'\0';
		}

	if ( pwszFileBase )
		{
		cchT = USHORT( pwszExtT - pwszNameT );
		if ( cchT )
			{
			memcpy( pwszFileBase, pwszNameT, cchT * sizeof( wchar_t ) );
			}
		pwszFileBase[cchT] = L'\0';
		}

	if ( pwszFileExt )
		{
		OSSTRCopyW( pwszFileExt, pwszExtT );
		}
	}


//	build a path from the given components (dir, file name, and file extension)

VOID SFSNAMEBuild(	const wchar_t *const	pwszDir,
					const wchar_t *const	pwszFileBase,
					const wchar_t *const	pwszFileExt,
					wchar_t *const			pwszPath )
	{
	ULONG	cchT;
	wchar_t	*pwszPathT;

	//	verify input

	Assert( pwszDir );
	Assert( pwszFileBase );
	Assert( pwszFileExt );
	Assert( pwszPath );

	pwszPathT = pwszPath;

	//	start with the directory

	cchT = LOSSTRLengthW( pwszDir );
	if ( cchT )
		{

		//	copy the directory

		memcpy( pwszPathT, pwszDir, cchT * sizeof( wchar_t ) );
		pwszPathT += cchT;

		//	append a trailing path delimiter if necessary

		if ( !FsRtlIsPathDelimiter( pwszDir[cchT - 1] ) )
			{
			*pwszPathT++ = L'\\';
			}
		}

	//	continue with the file name

	cchT = LOSSTRLengthW( pwszFileBase );
	if ( cchT )
		{

		//	copy the file name

		memcpy( pwszPathT, pwszFileBase, cchT * sizeof( wchar_t ) );
		pwszPathT += cchT;
		}

	//	finish with the file extention

	cchT = LOSSTRLengthW( pwszFileExt );
	if ( cchT )
		{

		//	prepend a dot if necessary

		if ( L'.' != pwszFileExt[0] )
			{
			*pwszPathT++ = L'.';
			}

		//	copy the file extention

		memcpy( pwszPathT, pwszFileExt, cchT * sizeof( wchar_t ) );
		pwszPathT += cchT;
		}

	//	add a null terminator

	*pwszPathT = L'\0';
	}


//	strip away the path leaving only the file name

VOID SFSNAMEStripPath(	const wchar_t *const	pwszPath,
						wchar_t *const			pwszFileName )
	{
	UNICODE_STRING	Path;
	UNICODE_STRING	FirstName;
	UNICODE_STRING	RemainingName;

	//	verify input

	Assert( pwszPath );
	Assert( pwszFileName );

	//	prepare to call FsRtlDissectName

	Path.Length = USHORT( LOSSTRLengthW( pwszPath ) * sizeof( wchar_t ) );
	Path.MaximumLength = Path.Length;
	Path.Buffer = const_cast< wchar_t *const >( pwszPath );

	//	dissect the name until we end up with nothing left

	while ( fTrue )
		{
		FsRtlDissectName( Path, &FirstName, &RemainingName );
		Assert( FirstName.Length % sizeof( wchar_t ) == 0 );
		Assert( RemainingName.Length % sizeof( wchar_t ) == 0 );

		if ( !RemainingName.Buffer )
			{
			break;
			}
		Path.Length = RemainingName.Length;
		Path.MaximumLength = RemainingName.Length;
		Path.Buffer = RemainingName.Buffer;
		}

	if ( FirstName.Buffer )
		{
		memcpy( pwszFileName, FirstName.Buffer, FirstName.Length );
		}
	else
		{
		FirstName.Length = 0;	//	no file name was given
		}
	pwszFileName[FirstName.Length / sizeof( wchar_t )] = L'\0';
	}


//	check a file name against an expression which possibly contains wildcards

ERR ErrSFSNAMEMatchesExpression(	const wchar_t *const	pwszName,
									const wchar_t *const	pwszExpression,
									BOOL *const				pfMatch )
	{
	UNICODE_STRING	Expression;
	UNICODE_STRING	Name;

	//	verify input

	Assert( pwszName );
	Assert( pwszExpression );
	Assert( pfMatch );

	//	prepare for call to FsRtlIsNameInExpression

	Expression.Length = USHORT( LOSSTRLengthW( pwszExpression ) * sizeof( wchar_t ) );
	Expression.MaximumLength = Expression.Length;
	Expression.Buffer = const_cast< wchar_t *const >( pwszExpression );
	Name.Length = USHORT( LOSSTRLengthW( pwszName ) * sizeof( wchar_t ) );
	Name.MaximumLength = Name.Length;
	Name.Buffer = const_cast< wchar_t *const >( pwszName );

	//	do the work

	return FsRtlIsNameInExpression( &Expression, &Name, pfMatch );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\eseperf\perfutil.cxx ===
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <tchar.h>
#include <aclapi.h>

#include "perfutil.hxx"
#include "perfmon.hxx"


	/*  DLL entry point for JETPERF.DLL  */

extern "C"
	{
	BOOL WINAPI DLLEntryPoint( HINSTANCE, DWORD, LPVOID )
		{
		return( TRUE );
		}
	}


	/*  Registry support functions  */

DWORD DwPerfUtilRegOpenKeyEx(HKEY hkeyRoot,LPCTSTR lpszSubKey,PHKEY phkResult)
{
	return RegOpenKeyEx(hkeyRoot,lpszSubKey,0,KEY_QUERY_VALUE,phkResult);
}


DWORD DwPerfUtilRegCloseKeyEx(HKEY hkey)
{
	return RegCloseKey(hkey);
}


DWORD DwPerfUtilRegCreateKeyEx(HKEY hkeyRoot,LPCTSTR lpszSubKey,PHKEY phkResult,LPDWORD lpdwDisposition)
{
	return RegCreateKeyEx(hkeyRoot,lpszSubKey,0,NULL,REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS,NULL,phkResult,lpdwDisposition);
}


DWORD DwPerfUtilRegDeleteKeyEx(HKEY hkeyRoot,LPCTSTR lpszSubKey)
{
	return RegDeleteKey(hkeyRoot,lpszSubKey);
}


DWORD DwPerfUtilRegDeleteValueEx(HKEY hkey,LPTSTR lpszValue)
{
	return RegDeleteValue(hkey,lpszValue);
}


DWORD DwPerfUtilRegSetValueEx(HKEY hkey,LPCTSTR lpszValue,DWORD fdwType,CONST BYTE *lpbData,DWORD cbData)
{
		/*  make sure type is set correctly by deleting value first  */

	(VOID)DwPerfUtilRegDeleteValueEx(hkey,(LPTSTR)lpszValue);
	return RegSetValueEx(hkey,lpszValue,0,fdwType,lpbData,cbData);
}


	/*  DwPerfUtilRegQueryValueEx() adds to the functionality of RegQueryValueEx() by returning
	/*  the data in callee malloc()ed memory and automatically converting REG_EXPAND_SZ
	/*  strings using ExpandEnvironmentStrings() to REG_SZ strings.
	/*
	/*  NOTE:  references to nonexistent env vbles will be left unexpanded :-(  (Ex.  %UNDEFD% => %UNDEFD%)
	/**/

DWORD DwPerfUtilRegQueryValueEx(HKEY hkey,LPTSTR lpszValue,LPDWORD lpdwType,LPBYTE *lplpbData)
{
	DWORD cbData;
	LPBYTE lpbData;
	DWORD errWin;
	DWORD cbDataExpanded;
	LPBYTE lpbDataExpanded;

	*lplpbData = NULL;
	if ((errWin = RegQueryValueEx(hkey,lpszValue,0,lpdwType,NULL,&cbData)) != ERROR_SUCCESS)
		return errWin;

	if ((lpbData = reinterpret_cast<LPBYTE>(malloc(cbData))) == NULL)
		return ERROR_OUTOFMEMORY;
	if ((errWin = RegQueryValueEx(hkey,lpszValue,0,lpdwType,lpbData,&cbData)) != ERROR_SUCCESS)
	{
		free(lpbData);
		return errWin;
	}

	if (*lpdwType == REG_EXPAND_SZ)
	{
		cbDataExpanded = ExpandEnvironmentStrings((const char *)lpbData,NULL,0);
		if ((lpbDataExpanded = reinterpret_cast<LPBYTE>(malloc(cbDataExpanded))) == NULL)
		{
			free(lpbData);
			return ERROR_OUTOFMEMORY;
		}
		if (!ExpandEnvironmentStrings((const char *)lpbData,(char *)lpbDataExpanded,cbDataExpanded))
		{
			free(lpbData);
			free(lpbDataExpanded);
			return GetLastError();
		}
		free(lpbData);
		*lplpbData = lpbDataExpanded;
		*lpdwType = REG_SZ;
	}
	else  /*  lpdwType != REG_EXPAND_SZ  */
	{
		*lplpbData = lpbData;
	}

	return ERROR_SUCCESS;
}


	/*  shared performance data area resources  */

HANDLE	hPERFInstanceMutex	= NULL;
HANDLE	hPERFGDAMMF			= NULL;
PGDA	pgdaPERFGDA			= NULL;


	/*  Event Logging support  */

HANDLE hOurEventSource = NULL;

void PerfUtilLogEvent( DWORD evncat, WORD evntyp, const char *szDescription )
{
    const char *rgsz[3];

    	/*  convert args from internal types to event log types  */

	rgsz[0]	= "";
	rgsz[1] = "";
	rgsz[2] = (char *)szDescription;

		/*  write to our event log, if it has been opened  */

	if (hOurEventSource)
	{
		ReportEvent(
			hOurEventSource,
			(WORD)evntyp,
			(WORD)evncat,
			0,
			0,
			3,
			0,
			rgsz,
			0 );
	}

	return;
}


	/*  Init/Term routines for system indirection layer  */

DWORD dwInitCount = 0;

inline _TCHAR* SzPerfGlobal()
	{
	OSVERSIONINFO osverinfo;
	osverinfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
	if ( !GetVersionEx( &osverinfo ) ) 
		{
		return _T("");
		}
	//	Under Win2000 terminal server object names must be preceded by Global\
	//	to share the same name space
	return ( VER_PLATFORM_WIN32_NT == osverinfo.dwPlatformId && 5 <= osverinfo.dwMajorVersion )? _T("Global\\"): _T("");
	}

DWORD DwPerfUtilInit( VOID )
{
	DWORD						err							= ERROR_SUCCESS;
	SID_IDENTIFIER_AUTHORITY	siaWorldSidAuthority		= SECURITY_WORLD_SID_AUTHORITY;
	SID_IDENTIFIER_AUTHORITY	siaLocalSystemSidAuthority	= SECURITY_NT_AUTHORITY;
	PSID						psidWorldSid				= NULL;
	PSID						psidLocalSystemSid			= NULL;
	size_t						cbAcl						= 0;
	PACL						pacl						= NULL;
	PSECURITY_DESCRIPTOR		pSD							= NULL;
	SECURITY_ATTRIBUTES			sa							= { 0 };
	_TCHAR						szT[ 256 ];

		/*  if we haven't been initialized already, perform init  */

	if (!dwInitCount)
	{
			/*  open the event log  */

	    if (!(hOurEventSource = RegisterEventSource( NULL, SZVERSIONNAME )))
	    	return GetLastError();
		
		/*  create a SD that will be used to create our global objects
		/**/
		if ( !AllocateAndInitializeSid (	&siaWorldSidAuthority,
											1,
											SECURITY_WORLD_RID,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											&psidWorldSid ) )
			{
			err = GetLastError();
			goto CloseEventLog;
			}

		if ( !AllocateAndInitializeSid (	&siaLocalSystemSidAuthority,
											2,
											SECURITY_BUILTIN_DOMAIN_RID,
											DOMAIN_ALIAS_RID_ADMINS,
											0,
											0,
											0,
											0,
											0,
											0,
											&psidLocalSystemSid ) )
			{
			err = GetLastError();
			goto CloseEventLog;
			}

		cbAcl =	sizeof( ACL ) +
				2 * sizeof( ACCESS_ALLOWED_ACE ) +
				GetLengthSid( psidWorldSid ) +
				GetLengthSid( psidLocalSystemSid );

		if ( !( pacl = (PACL)LocalAlloc( 0, cbAcl ) ) )
			{
			err = GetLastError();
			goto CloseEventLog;
			}

		if ( !InitializeAcl(	pacl,
								cbAcl,
								ACL_REVISION2 ) )
			{
			err = GetLastError();
			goto CloseEventLog;
			}

		if ( !AddAccessAllowedAce (	pacl,
									ACL_REVISION2,
									GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
									psidWorldSid ) )
			{
			err = GetLastError();
			goto CloseEventLog;
			}

		if ( !AddAccessAllowedAce (	pacl,
									ACL_REVISION2,
									GENERIC_ALL,
									psidLocalSystemSid ) )
			{
			err = GetLastError();
			goto CloseEventLog;
			}

		if ( !( pSD = (PSECURITY_DESCRIPTOR)LocalAlloc( 0, SECURITY_DESCRIPTOR_MIN_LENGTH ) ) )
			{
			err = GetLastError();
			goto CloseEventLog;
			}

		if ( !InitializeSecurityDescriptor(	pSD,
											SECURITY_DESCRIPTOR_REVISION ) )
			{
			err = GetLastError();
			goto CloseEventLog;
			}

		if ( !SetSecurityDescriptorDacl(	pSD,
											TRUE,
											pacl,
											FALSE ) )
			{
			err = GetLastError();
			goto CloseEventLog;
			}

	    sa.nLength = sizeof( SECURITY_DESCRIPTOR );
	    sa.lpSecurityDescriptor = pSD;
	    sa.bInheritHandle = FALSE;

		/*  create/open the instance mutex, but do not acquire
		/**/
		_stprintf( szT, _T( "%sInstance:  %s" ), SzPerfGlobal(), szPERFVersion );
		if ( !( hPERFInstanceMutex = CreateMutex( &sa, FALSE, szT ) ) )
			{
			err = GetLastError();
			goto CloseEventLog;
			}

		/*  open/create the shared global data area
		/**/
		_stprintf( szT, _T( "%sGDA:  %s" ), SzPerfGlobal(), szPERFVersion );
		if ( !( hPERFGDAMMF = CreateFileMapping(	INVALID_HANDLE_VALUE,
													&sa,
													PAGE_READWRITE | SEC_COMMIT,
													0,
													PERF_SIZEOF_GLOBAL_DATA,
													szT ) ) )
			{
			err = GetLastError();
			goto FreeInstanceMutex;
			}
		if ( !( pgdaPERFGDA = PGDA( MapViewOfFile(	hPERFGDAMMF,
													FILE_MAP_WRITE,
													0,
													0,
													0 ) ) ) )
			{
			err = GetLastError();
			goto CloseFileMap;
			}

	}

		/*  init succeeded   */

	dwInitCount++;

	if ( err != ERROR_SUCCESS )
		{
CloseFileMap:
		CloseHandle( hPERFGDAMMF );
		hPERFGDAMMF = NULL;
FreeInstanceMutex:
		CloseHandle( hPERFInstanceMutex );
		hPERFInstanceMutex = NULL;
CloseEventLog:
		DeregisterEventSource( hOurEventSource );
		hOurEventSource = NULL;
		}

	LocalFree( pacl );
	LocalFree( pSD );
	if ( psidWorldSid )
		{
		FreeSid( psidWorldSid );
		}
	if ( psidLocalSystemSid )
		{
		FreeSid( psidLocalSystemSid );
		}
	return err;
}


VOID PerfUtilTerm( VOID )
{
		/*  last one out, turn out the lights!  */

	if (!dwInitCount)
		return;
	dwInitCount--;
	if (!dwInitCount)
	{
		UnmapViewOfFile( pgdaPERFGDA );
		pgdaPERFGDA = NULL;

		CloseHandle( hPERFGDAMMF );
		hPERFGDAMMF = NULL;

		CloseHandle( hPERFInstanceMutex );
		hPERFInstanceMutex = NULL;

		DeregisterEventSource( hOurEventSource );
		hOurEventSource = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\_oswinnt\trace.cxx ===
#include "osstd.hxx"

#include < stdio.h >


//  Info Strings

class COSInfoString
	{
	public:

		COSInfoString( const size_t cch ) { memset( m_szInfo + cch, 0, sizeof( COSInfoString ) - offsetof( COSInfoString, m_szInfo ) ); }
		~COSInfoString() {}

		char* String() { return m_szInfo; }

	public:

		static SIZE_T OffsetOfILE() { return offsetof( COSInfoString, m_ile ); }

	private:

		CInvasiveList< COSInfoString, OffsetOfILE >::CElement	m_ile;
		char													m_szInfo[ 1 ];
	};

class COSThreadContext
	{
	public:

		COSThreadContext();
		~COSThreadContext();

		char* AllocInfoString( const size_t cch );
		void FreeInfoStrings();

		void Indent( const int dLevel );
		int Indent();

	private:

		friend class COSThreadInfo;

		ULONG	m_cref;

	private:

		CInvasiveList< COSInfoString, COSInfoString::OffsetOfILE >	m_listInfoString;
		int															m_cIndent;
	};

inline COSThreadContext::COSThreadContext()
	:	m_cref( 0 ),
		m_cIndent( 0 )
	{
	}

inline COSThreadContext::~COSThreadContext()
	{
	FreeInfoStrings();
	}

inline char* COSThreadContext::AllocInfoString( const size_t cch )
	{
	const size_t			cbAlloc		= sizeof( COSInfoString ) + cch;
	COSInfoString* const	pinfostr	= reinterpret_cast< COSInfoString* >( new char[ cbAlloc ] );

	if ( pinfostr )
		{
		new( pinfostr ) COSInfoString( cch );
		m_listInfoString.InsertAsNextMost( pinfostr );
		}

	return pinfostr->String();
	}
	
inline void COSThreadContext::FreeInfoStrings()
	{
	while ( m_listInfoString.PrevMost() )
		{
		COSInfoString* const pinfostr = m_listInfoString.PrevMost();
		m_listInfoString.Remove( pinfostr );
		
		pinfostr->~COSInfoString();
		delete [] (char*)pinfostr;
		}
	}

inline void COSThreadContext::Indent( const int dLevel )
	{
	m_cIndent = dLevel ? m_cIndent + dLevel : 0;
	}

inline int COSThreadContext::Indent()
	{
	return m_cIndent;
	}


class COSThreadInfo
	{
	public:

		COSThreadInfo()
			{
			m_tid	= -1;
			m_ptc	= NULL;
			}

		COSThreadInfo(	const DWORD&			tid,
						COSThreadContext* const	ptc )
			{
			m_tid	= tid;
			m_ptc	= ptc;

			if ( m_ptc )
				{
				m_ptc->m_cref++;
				}
			}

		~COSThreadInfo()
			{
			if ( m_ptc && !( --( m_ptc->m_cref ) ) )
				{
				delete m_ptc;
				}

			m_tid	= -1;
			m_ptc	= NULL;
			}

		COSThreadInfo& operator=( const COSThreadInfo& threadinfo )
			{
			if ( m_ptc && !( --( m_ptc->m_cref ) ) )
				{
				delete m_ptc;
				}
				
			m_tid	= threadinfo.m_tid;
			m_ptc	= threadinfo.m_ptc;

			if ( m_ptc )
				{
				m_ptc->m_cref++;
				}
			
			return *this;
			}

	public:

		DWORD				m_tid;
		COSThreadContext*	m_ptc;
	};

typedef CTable< DWORD, COSThreadInfo > COSThreadTable;

inline int COSThreadTable::CKeyEntry:: Cmp( const DWORD& tid ) const
	{
	return m_tid - tid;
	}

inline int COSThreadTable::CKeyEntry:: Cmp( const COSThreadTable::CKeyEntry& keyentry ) const
	{
	return Cmp( keyentry.m_tid );
	}

CReaderWriterLock	g_rwlThreadTable( CLockBasicInfo( CSyncBasicInfo( "g_rwlThreadTable" ), -1000, 0 ) );
COSThreadTable		g_threadtable;

// rlanser:  01/30/2001: VisualStudio7#206324; NTBUG#301132
//#if defined(_M_IX86) && (_MSC_FULL_VER <= 13009037)
//#pragma optimize("g",off)
//#elif defined(_M_IA64) && (_MSC_FULL_VER <= 13009076)
//#pragma optimize("t",on)
//#endif
// rlanser:  01/31/2001:  less aggressive fix for the above problem
#if (defined(_M_IX86) && (_MSC_FULL_VER <= 13009037)) || (defined(_M_IA64) && (_MSC_FULL_VER <= 13009076))
#pragma inline_recursion(off)
#endif

COSThreadContext* OSThreadContext()
	{
	ERR err = JET_errSuccess;

	g_rwlThreadTable.EnterAsReader();
	const COSThreadInfo* pthreadinfo = g_threadtable.SeekEQ( GetCurrentThreadId() );
	g_rwlThreadTable.LeaveAsReader();

	if ( !pthreadinfo )
		{
		COSThreadInfo threadinfo( GetCurrentThreadId(), new COSThreadContext );
		Alloc( threadinfo.m_ptc );

		g_rwlThreadTable.EnterAsWriter();
		(void)g_threadtable.ErrLoad( 1, &threadinfo );

		pthreadinfo = g_threadtable.SeekEQ( GetCurrentThreadId() );
		g_rwlThreadTable.LeaveAsWriter();
		}
		
HandleError:
	return pthreadinfo ? pthreadinfo->m_ptc : NULL;
	}


char* OSAllocInfoString( const size_t cch )
	{
	COSThreadContext* const ptc = OSThreadContext();

	return ptc ? ptc->AllocInfoString( cch ) : NULL;
	}

void OSFreeInfoStrings()
	{
	__try
		{
		COSThreadContext* const ptc = OSThreadContext();

		if ( ptc )
			{
			ptc->FreeInfoStrings();
			}
		}
	__except( EXCEPTION_EXECUTE_HANDLER )
		{
		}
	}


//  Tracing

ERR ErrOSTraceDeferInit();

OSTraceLevel	g_ostlEffective		= ostlLow;

const char		g_mpostlsz[ ostlMax ][ 16 ] =
	{
	"None",
	"Low",
	"Medium",
	"High",
	"Very High",
	"Full",
	};

WCHAR			g_wszMutexTrace[]	= L"Global\\{5E5C36C0-5E7C-471f-84D7-110FDC1AFD0D}";
HANDLE			g_hMutexTrace		= NULL;
WCHAR			g_wszFileTrace[]	= L"\\Debug\\ESE.TXT";
HANDLE			g_hFileTrace		= NULL;

void OSTraceEmit( const char* const szRawTrace )
	{
	const size_t	cchPrefixMax				= 127;
	char			szPrefix[ cchPrefixMax + 1 ];
					szPrefix[ cchPrefixMax ]	= 0;
	size_t			cchPrefix					= 0;
	int				cchConsumed					= 0;

	const size_t	cchLocalMax					= 255;
	char			szLocal[ cchLocalMax + 1 ];
					szLocal[ cchLocalMax ]		= 0;
	char			szEOL[]						= "\r\n";

	size_t			cchTraceMax					= cchLocalMax;
	char*			szTrace						= szLocal;
	size_t			cchTrace					= 0;

	__try
		{
		//  build the prefix string
		
		SYSTEMTIME systemtime;
		GetLocalTime( &systemtime );

		//  get the current indent level and restrict it to a sane range
		
		COSThreadContext* const	ptc			= OSThreadContext();
		const int				cIndentMin	= 0;
		const int				cIndentMax	= 16;
		const int				cIndent		= ptc ? min( cIndentMax, max( cIndentMin, ptc->Indent() ) ) : 0;
		const int				cchIndent	= 2;

		cchConsumed = _snprintf(	szPrefix + cchPrefix,
									cchPrefixMax - cchPrefix,
									"[%s %03x.%03x %04d%02d%02d%02d%02d%02d]  %*s",
									SzUtilImageVersionName(),
									GetCurrentProcessId(),
									GetCurrentThreadId(),
									systemtime.wYear,
									systemtime.wMonth,
									systemtime.wDay,
									systemtime.wHour,
									systemtime.wMinute,
									systemtime.wSecond,
									cchIndent * cIndent,
									"" );
		cchPrefix = cchConsumed < 0 ? cchPrefixMax : cchPrefix + cchConsumed;

		//  try building the trace string in memory until it all fits

		do	{
			//  build the trace string
			
			cchTrace				= 0;
			szTrace[ cchTrace ]		= 0;

			const char*	szLast	= szRawTrace ? szRawTrace : "{null}";
			const char*	szCurr	= szRawTrace ? szRawTrace : "{null}";
			BOOL		fBOL	= TRUE;
			
			while ( *szCurr )
				{
				if ( fBOL )
					{
					cchConsumed = _snprintf(	szTrace + cchTrace,
												cchTraceMax - cchTrace,
												"%s",
												szPrefix );
					cchTrace = cchConsumed < 0 ? cchTraceMax : cchTrace + cchConsumed;

					fBOL = FALSE;
					}

				szCurr = szLast + strcspn( szLast, "\r\n" );

				cchConsumed = _snprintf(	szTrace + cchTrace,
											cchTraceMax - cchTrace,
											"%.*s%s",
											szCurr - szLast,
											szLast, 
											szEOL );
				cchTrace = cchConsumed < 0 ? cchTraceMax : cchTrace + cchConsumed;

				while ( *szCurr == '\r' )
					{
					szCurr++;
					fBOL = TRUE;
					}
				if ( *szCurr == '\n' )
					{
					szCurr++;
					fBOL = TRUE;
					}
				szLast = szCurr;
				}

			if ( cchTrace == cchTraceMax )
				{
				if ( szTrace != szLocal )
					{
					LocalFree( szTrace );
					}

				cchTraceMax	= 2 * cchTraceMax;
				szTrace		= (char*)LocalAlloc( 0, cchTraceMax + 1 );
				if ( szTrace )
					{
					szTrace[ cchTraceMax ] = 0;
					}
				cchTrace	= cchTraceMax;
				}
			}
		while ( cchTrace == cchTraceMax && szTrace );

		//  emit the trace

		if ( szTrace )
			{
			OutputDebugStringA( szTrace );

			DWORD cbT;
			WaitForSingleObjectEx( g_hMutexTrace, INFINITE, FALSE );
			if ( SetFilePointer( g_hFileTrace, 0, NULL, FILE_END ) != INVALID_SET_FILE_POINTER )
				{
				WriteFile( g_hFileTrace, szTrace, min( DWORD( -1 ), cchTrace ), &cbT, NULL );
				}
			ReleaseMutex( g_hMutexTrace );
			}

		if ( szTrace != szLocal )
			{
			LocalFree( szTrace );
			}
		}
	__except( EXCEPTION_EXECUTE_HANDLER )
		{
		__try
			{
			if ( szTrace != szLocal )
				{
				LocalFree( szTrace );
				}
			}
		__except( EXCEPTION_EXECUTE_HANDLER )
			{
			}
		}
	}

void OSTrace_( const char* const szTrace )
	{
	__try
		{
		//  emit the trace

		if ( ErrOSTraceDeferInit() >= JET_errSuccess )
			{
			OSTraceEmit( szTrace );
			}

		//  garbage-collect info strings.  note that we must always do this if
		//  this function is called because info strings may have been created
		//  when computing the variable argument list

		OSFreeInfoStrings();
		}
	__except( EXCEPTION_EXECUTE_HANDLER )
		{
		__try
			{
			OSFreeInfoStrings();
			}
		__except( EXCEPTION_EXECUTE_HANDLER )
			{
			}
		}
	}

void OSTraceIndent_( const int dLevel )
	{
	__try
		{
		//  change our indent level
		
		COSThreadContext* const ptc = OSThreadContext();

		if ( ptc )
			{
			ptc->Indent( dLevel );
			}
		}
	__except( EXCEPTION_EXECUTE_HANDLER )
		{
		}
	}


//  Trace Formatting

const char* OSFormat_( const char* const szFormat, va_list arglist )
	{
	const size_t	cchLocalMax					= 256;
	char			szLocal[ cchLocalMax ];

	size_t			cchBufferMax				= cchLocalMax;
	char*			szBuffer					= szLocal;

	char*			szInfoString				= NULL;

	__try
		{
		//  try formatting the string in memory until it all fits

		size_t	cchRawMax;
		char*	szRaw;
		size_t	cchRaw;
		int		cchConsumed;

		do	{
			cchRawMax				= cchBufferMax - 1;
			szRaw					= szBuffer;
			szRaw[ cchRawMax ]		= 0;
			cchRaw					= 0;
			
			cchConsumed = _vsnprintf(	szRaw + cchRaw,
										cchRawMax - cchRaw,
										szFormat,
										arglist );
			cchRaw = cchConsumed < 0 ? cchRawMax : cchRaw + cchConsumed;

			if ( cchRaw == cchRawMax )
				{
				if ( szBuffer != szLocal )
					{
					LocalFree( szBuffer );
					}

				cchBufferMax	= 2 * cchBufferMax;
				szBuffer		= (char*)LocalAlloc( 0, cchBufferMax );
				}
			}
		while ( cchRaw == cchRawMax && szBuffer );

		//  copy the finished string into an Info String for return

		if ( szBuffer )
			{
			szInfoString = OSAllocInfoString( cchRaw );
			if ( szInfoString )
				{
				memcpy( szInfoString, szRaw, cchRaw );
				}
			}

		if ( szBuffer != szLocal )
			{
			LocalFree( szBuffer );
			}
		}
	__except( EXCEPTION_EXECUTE_HANDLER )
		{
		__try
			{
			if ( szBuffer != szLocal )
				{
				LocalFree( szBuffer );
				}
			}
		__except( EXCEPTION_EXECUTE_HANDLER )
			{
			}
		}

	return szInfoString;
	}

const char* __cdecl OSFormat( const char* const szFormat, ... )
	{
	va_list arglist;
	va_start( arglist, szFormat );

	return OSFormat_( szFormat, arglist );
	}

const char* OSFormatFileLine( const char* const szFile, const int iLine )
	{
	const char*	szFilename1	= strrchr( szFile, '/' );
	const char*	szFilename2	= strrchr( szFile, '\\' );
	const char*	szFilename	= (	szFilename1 ?
									(	szFilename2 ?
											max( szFilename1, szFilename2 ) + 1 :
											szFilename1 + 1 ) :
									(	szFilename2 ?
											szFilename2 + 1 :
											szFile ) );

	return OSFormat( "%s(%i)", szFilename, iLine );
	}

const char* OSFormatImageVersion()
	{
	return OSFormat(	"%s version %d.%02d.%04d.%04d (%s)",
						SzUtilImageVersionName(),
						DwUtilImageVersionMajor(),
						DwUtilImageVersionMinor(),
						DwUtilImageBuildNumberMajor(),
						DwUtilImageBuildNumberMinor(),
						SzUtilImageBuildClass() );
	}

const char* OSFormatBoolean( const BOOL f )
	{
	return f ? "True" : "False";
	}

const char* OSFormatPointer( const void* const pv )
	{
	return pv ? OSFormat( "%0*I64X", 2 * sizeof( pv ), __int64( pv ) ) : "NULL";
	}

const char* OSFormatError( const ERR err )
	{
	extern VOID JetErrorToString( JET_ERR err, const char** szError, const char** szErrorText );

	const char* 	szError			= NULL;
	const char*		szErrorText		= NULL;

	JetErrorToString( err, &szError, &szErrorText );

	return szError ? szError : OSFormat( "JET API error %dL", err );
	}

const char* OSFormatSigned( const LONG_PTR l )
	{
	return OSFormat( "%I64d", __int64( l ) );
	}
	
const char* OSFormatUnsigned( const ULONG_PTR ul )
	{
	return OSFormat( "%I64u", __int64( ul ) );
	}

const char* OSFormatRawData(	const BYTE* const	rgbData,
								const size_t		cbData,
								const size_t		cbAddr,
								const size_t		cbLine,
								const size_t		cbWord,
								const size_t		ibData )
	{
	//  00000000:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
	
	const size_t	cchAddr	= 2 * cbAddr + ( cbAddr ? 1 : 0 );
	const size_t	cchHex	= 2 * cbLine + ( cbLine + cbWord - 1 ) / cbWord - 1;
	const size_t	cchChar	= cbLine;
	const size_t	cchLine	= cchAddr + ( cchAddr ? 2 : 0 ) + cchHex + 2 + cchChar + 1;
	
	char* const		szLine	= OSAllocInfoString( cchLine );
	char* const		szAddr	= szLine;
	char* const		szHex	= szLine + cchAddr + ( cchAddr ? 2 : 0 );
	char* const		szChar	= szLine + cchAddr + ( cchAddr ? 2 : 0 ) + cchHex + 2;

	//  build line

	static const char rgchHex[] = "0123456789abcdef";

	memset( szLine, ' ', cchLine );
	
	for ( size_t ibAddr = 0; ibAddr < cbAddr; ibAddr++ )
		{
		szAddr[ 2 * ibAddr ]		= rgchHex[ ( ibData >> ( 8 * ( cbAddr - ibAddr - 1 ) + 4 ) ) & 0xf ];
		szAddr[ 2 * ibAddr + 1 ]	= rgchHex[ ( ibData >> ( 8 * ( cbAddr - ibAddr - 1 ) ) ) & 0xf ];
		}
	if ( cbAddr )
		{
		szAddr[ 2 * cbAddr ] = ':';
		}

	for ( size_t ibLine = 0; ibLine < cbLine && ibData + ibLine < cbData; ibLine += cbWord )
		{
		for ( size_t ibWord = 0; ibWord < cbWord; ibWord++ )
			{
			const size_t	ibDataRead	= ibData + ibLine + cbWord - ibWord - 1;
			BOOL			fVisible	= ibDataRead < cbData;
			char			bDataRead	= '\0';
			const size_t	ichHex		= 2 * ( ibLine + ibWord ) + ibLine / cbWord;
			const size_t	ichChar		= ibLine + cbWord - ibWord - 1;

			__try
				{
				bDataRead = rgbData[ ibDataRead ];
				}
			__except( EXCEPTION_EXECUTE_HANDLER )
				{
				fVisible = fFalse;
				}
			
			szHex[ ichHex ]		= !fVisible ? '?' : rgchHex[ ( bDataRead >> 4 ) & 0xf ];
			szHex[ ichHex + 1 ]	= !fVisible ? '?' : rgchHex[ bDataRead & 0xf ];
			szChar[ ichChar ]	= !fVisible ? '?' : ( isprint( bDataRead ) ? bDataRead : '.' );
			}
		}

	szLine[ cchLine - 1 ] = '\n';

	//  build stream of lines

	if ( ibData + cbLine >= cbData )
		{
		return szLine;
		}
	else
		{
		const char*	szSuffix	= OSFormatRawData(	rgbData,
													cbData,
													cbAddr,
													cbLine,
													cbWord,
													ibData + cbLine );
		char* const	szTotal		= OSAllocInfoString( strlen( szLine ) + strlen( szSuffix ) );

		strcpy( szTotal, szLine );
		strcat( szTotal, szSuffix );

		return szTotal;
		}
	}


//  Trace Init / Term

void OSTracePostterm()
	{
	//  nop
	}

BOOL FOSTracePreinit()
	{
	const int		cbBuf			= 256;
	_TCHAR			szBuf[ cbBuf ];

	if (	FOSConfigGet( _T( "DEBUG" ), _T( "Trace Level" ), szBuf, cbBuf ) &&
			szBuf[ 0 ] )
		{
		_TCHAR*			szT	= NULL;
		const DWORD		dw	= _tcstoul( szBuf, &szT, 0 );
		if ( !( *szT ) )
			{
			g_ostlEffective = OSTraceLevel( min( ostlMax - 1, dw ) );
			}
		}

	return fTrue;
	}

void OSTraceTerm()
	{
	//  nop
	}

ERR ErrOSTraceInit()
	{
	//  nop

	return JET_errSuccess;
	}

ERR ErrOSTraceIGetSystemWindowsDirectory( LPWSTR lpBuffer, UINT uSize )
	{
	typedef WINBASEAPI UINT WINAPI PFNGetSystemWindowsDirectoryW( LPWSTR, UINT );

	ERR								err								= JET_errSuccess;
	HMODULE							hmodKernel32					= NULL;
	PFNGetSystemWindowsDirectoryW*	pfnGetSystemWindowsDirectoryW	= NULL;

	if (	( hmodKernel32 = LoadLibrary( "kernel32.dll" ) ) &&
			( pfnGetSystemWindowsDirectoryW = (PFNGetSystemWindowsDirectoryW*)GetProcAddress( hmodKernel32, "GetSystemWindowsDirectoryW" ) ) )
		{
		if ( !pfnGetSystemWindowsDirectoryW( lpBuffer, uSize ) )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		}
	else
		{
		if ( !GetWindowsDirectoryW( lpBuffer, uSize ) )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		}

HandleError:
	if ( hmodKernel32 )
		{
		FreeLibrary( hmodKernel32 );
		}
	return err;
	}

void OSTraceITerm()
	{
	OSTrace(	ostlMedium,
				OSFormat(	"%s unloaded.",
							OSFormatImageVersion() ) );
				
	if ( g_hFileTrace )
		{
		CloseHandle( g_hFileTrace );
		g_hFileTrace = NULL;
		}
	if ( g_hMutexTrace )
		{
		CloseHandle( g_hMutexTrace );
		g_hMutexTrace = NULL;
		}
	}
	
ERR ErrOSTraceIInit()
	{
	ERR				err				= JET_errSuccess;
	const size_t	cchPathTrace	= 2 * _MAX_PATH;
	WCHAR			wszPathTrace[ cchPathTrace ];

	if (	!( g_hMutexTrace = CreateMutexW( NULL, FALSE, g_wszMutexTrace ) ) &&
			!( g_hMutexTrace = CreateMutexW( NULL, FALSE, wcsrchr( g_wszMutexTrace, L'\\' ) + 1 ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	Call( ErrOSTraceIGetSystemWindowsDirectory( wszPathTrace, cchPathTrace * sizeof( WCHAR ) ) );
	wcscat( wszPathTrace, g_wszFileTrace );

	if ( ( g_hFileTrace = CreateFileW(	wszPathTrace,
										GENERIC_WRITE,
										FILE_SHARE_READ | FILE_SHARE_WRITE,
										NULL,
										OPEN_ALWAYS,
										FILE_ATTRIBUTE_NORMAL,
										NULL ) ) == INVALID_HANDLE_VALUE )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

HandleError:
	OSTrace(	ostlMedium,
				OSFormat(	"%s loaded.\r\n"
							"  Image:              \"%s\"\r\n"
							"  Process:            \"%s\"\r\n"
							"  Trace File:         \"%S\"%s\r\n"
							"  Trace Level:        %s\r\n",
							OSFormatImageVersion(),
							SzUtilImagePath(),
							SzUtilProcessPath(),
							wszPathTrace,
 							g_hFileTrace ? "" : " (open failed)",
							g_mpostlsz[ g_ostlEffective ] ) );

	if ( err < JET_errSuccess )
		{
		if ( g_hFileTrace )
			{
			CloseHandle( g_hFileTrace );
			g_hFileTrace = NULL;
			}
		if ( g_hMutexTrace )
			{
			CloseHandle( g_hMutexTrace );
			g_hMutexTrace = NULL;
			}
		}
	return err;
	}


class COSTraceDeferInit
	{
	public:

		COSTraceDeferInit();
		~COSTraceDeferInit();

		ERR ErrInit();
		void Term();

	private:

		BOOL						m_fInit;
		CNestableCriticalSection	m_ncritInit;
		BOOL						m_fInitInProgress;
		ERR							m_errInit;
	};

COSTraceDeferInit::COSTraceDeferInit()
	:	m_fInit( fFalse ),
		m_ncritInit( CLockBasicInfo( CSyncBasicInfo( "COSTraceDeferInit::m_ncritInit" ), 0, 0 ) ),
		m_fInitInProgress( fFalse ),
		m_errInit( JET_errSuccess )
	{
	}

COSTraceDeferInit::~COSTraceDeferInit()
	{
	Term();
	}

ERR COSTraceDeferInit::ErrInit()
	{
	if ( !m_fInit )
		{
		m_ncritInit.Enter();
		if ( !m_fInit )
			{
			if ( !m_fInitInProgress )
				{
				m_fInitInProgress	= fTrue;
				m_errInit			= ErrOSTraceIInit();
				m_fInitInProgress	= fFalse;
				m_fInit				= fTrue;
				}
			}
		m_ncritInit.Leave();
		}

	return m_errInit;
	}

void COSTraceDeferInit::Term()
	{
	OSTraceITerm();
	}

COSTraceDeferInit g_ostracedeferinit;

ERR ErrOSTraceDeferInit()
	{
	return g_ostracedeferinit.ErrInit();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\_errstr\makefile.inc ===
$(O)\err.cxx: ..\..\export\jet.h .\err.pl
        perl .\err.pl < ..\..\export\jet.h > $(O)\err.cxx
        
clean:
        -del $(O)\err.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\_perfctrs\makefile.inc ===
# Build team will use checked-in multi-lang ESENTPRF.INI.
# In order to generate a multi-lang ESENTPRF.INI, must
# first define JET_ESENTPRF_BUILD, then run a build to
# generate a single-lang ESENTPRF.INI, and finally
# run genloc.bat to generate a multi-lang ESENTPRF.INI.

$(O)\esentprf.hxx $(O)\esentprf.ini: perfdata.txt
        copy perfdata.pl $(O)
        copy perfdata.txt $(O)
        cd $(O)
        perl .\perfdata.pl perfdata.txt
        cd ..\..
!ifndef JET_ESENTPRF_BUILD
        copy ..\..\lang\ini\esentprf.ini $(O)
        touch $(O)\esentprf.ini
!endif

        
clean:
        -del $(O)\esentprf.hxx $(O)\esentprf.ini
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\_esefile\status.cxx ===
#include "esefile.hxx"

static int iLastPercentage;

//  ================================================================
void PrintWindowsError( const wchar_t * const szMessage )
//  ================================================================
	{
	LPVOID lpMsgBuf = NULL;
	if( FormatMessage( 
		    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		    NULL,
		    GetLastError(),
		    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		    (LPTSTR) &lpMsgBuf,
		    0,
		    NULL ) )
		{
		(void)fwprintf( stderr, L"%ls%ls", szMessage, (wchar_t *)lpMsgBuf );
		}

	LocalFree( lpMsgBuf );
	}

void InitStatus( const wchar_t * const szOperation )
	{
	const SIZE_T	cbOper		= wcslen( szOperation );
	const SIZE_T	cbPadding	= ( 51 - cbOper ) / 2;

	wprintf( L"          %*ls\r\n\r\n", cbPadding+cbOper, szOperation );
	wprintf( L"          0    10   20   30   40   50   60   70   80   90  100\r\n" );
	wprintf( L"          |----|----|----|----|----|----|----|----|----|----|\r\n" );
	wprintf( L"          " );

	iLastPercentage = 0;
	}


void UpdateStatus( const int iPercentage )
	{
	int dPercentage = min( iPercentage, 100 ) - iLastPercentage;
	while ( dPercentage >= 2 )
		{
		wprintf( L"." );
		iLastPercentage += 2;
		dPercentage -= 2;
		}
	}


void TermStatus()
	{
	UpdateStatus( 100 );
	wprintf( L".\r\n" );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\eseutil\eseutil.cxx ===
#include <windows.h>

#if defined(DEBUG) && !defined(NDEBUG)
#define NDEBUG
#endif

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <conio.h>
#include <tchar.h>

#include "jet.h"
#include "ntverp.h"

#include "_edbutil.hxx"
#include "utilmsg.h"		// UNDONE: Header file generated by MC, which currently only generates .h files.

#include "esefile.hxx"
#undef UNICODE				//	esefile.hxx enables UNICODE


#include <esebcli2.h>
#define ESEBCLI2_DLL_NAME	"ESEBCLI2.DLL"

// the sever simulation functionality will be available in
// both debug and retail but the help will be DEBUG only
// (like an unsupported functionality)
#define RESTORE_SERVER_SIMULATION

#ifdef DEBUG
#define RESTORE_SERVER_SIMULATION_HELP
#endif

#ifdef RESTORE_SERVER_SIMULATION
#include <eseback2.h>
#define ESEBACK2_DLL_NAME	"ESEBACK2.DLL"
#endif // RESTORE_SERVER_SIMULATION

#ifdef DEBUG
#define RECORD_FORMAT_UPGRADE
#endif

//#define LOG_SHIPPING


//	use this to protect invalid code paths that PREfix complains about

#ifdef _PREFIX_
#define AssertPREFIX( exp )			( ( exp ) ? (void)0 : exit(-1) )
#else
#define AssertPREFIX( exp )			assert( exp )
#endif


LOCAL const char	* const szUser			= "user";
LOCAL const char	* const szPassword		= "";


// UNDONE:  Must still be localised, but centralising all the localisable strings
// here makes my job easier.

LOCAL const char	* const	szCurrDir					= ".";

LOCAL const char	* const szStreamingFileExt			= "STM";

LOCAL const char	* const szDefaultTempDBFormat		= "TEMP%d.EDB";
LOCAL const char	* const szDefaultDefragDBFormat		= "TEMPDFRG%d.EDB";
LOCAL const char	* const szDefaultUpgradeDBFormat	= "TEMPUPGD%d.EDB";
LOCAL const char	* const szDefaultRepairDBFormat		= "TEMPREPAIR%d.EDB";
LOCAL const char	* const szDefaultIntegDBFormat		= "TEMPINTEG%d.EDB";
LOCAL const char	* const szDefaultScrubDBFormat		= "TEMPSCRUB%d.EDB";

LOCAL char szDefaultTempDB[64];
LOCAL char szDefaultDefragDB[64];
LOCAL char szDefaultUpgradeDB[64];
LOCAL char szDefaultRepairDB[64];
LOCAL char szDefaultIntegDB[64];
LOCAL char szDefaultScrubDB[64];

LOCAL char szSourceStreamFileName[ _MAX_PATH + 1 ];
LOCAL char szTempStreamFileName[ _MAX_PATH + 1 ];

LOCAL const char	* const szDefrag				= "Defragmentation";
LOCAL const char	* const szUpgrade				= "Upgrade";
LOCAL const char	* const szRestore				= "Restore";
LOCAL const char	* const szRepair				= "Scanning";
LOCAL const char	* const szScrub					= "Securing";
LOCAL const char	* const szUpgradeRecordFormat	= "Upgrading Record Format";
LOCAL const char	* const szIntegrity				= "Integrity";
LOCAL const char	* const szChecksum				= "Checksum";

LOCAL const char	* const szStatusMsg		= " Status (% complete)";

LOCAL const char	* const szMoveFile		= "Moving '%s' to '%s'...";
LOCAL const char	* const szMoveDone		= " DONE!";
LOCAL const char	* const szMoveFailed	= " FAILED!";
LOCAL const char	* const szCopyFile		= " Copying...";
LOCAL const char	* const szCopyFileStatus= "File Copy";

LOCAL const char	cNewLine				= '\n';

LOCAL const char	* const szSwitches		= "-/";

LOCAL const char	* const szRegistryMsg	= "Using Registry environment...";

LOCAL const char	* const szErr1			= "Error: Source database specification '%s' is invalid.";
LOCAL const char	* const szErr2			= "Error: Temporary database specification '%s' is invalid.";
LOCAL const char	* const szErr3			= "Error: Source database '%s' cannot be the same as the temporary database.";
LOCAL const char	* const szErr4			= "Error: Could not backup to '%s'.";
LOCAL const char	* const szErr5			= "Error: Could not re-instate '%s'. It may be manually re-instated by manually copying '%s' to '%s' (this will overwrite the original copy of the file with the defragmented copy).";
LOCAL const char	* const szErr6			= "Error: Failed loading Registry Environment.";

LOCAL const _TCHAR	* const szErr7			= _T( "Error: Failed to load DLL %s.\r\n" );
LOCAL const _TCHAR	* const szErr8			= _T( "Error: Failed to load function %s from DLL.\r\n" );

LOCAL const char	* const szUsageErr1		= "Usage Error: Missing %s specification.";
LOCAL const char	* const szUsageErr2		= "Usage Error: Duplicate %s specification.";
LOCAL const char	* const szUsageErr3		= "Usage Error: Only one type of recovery allowed.";
LOCAL const char	* const szUsageErr4		= "Usage Error: Invalid option '%s'.";
LOCAL const char	* const szUsageErr5		= "Usage Error: Invalid argument '%s'. Options must be preceded by '-' or '/'.";
LOCAL const char	* const szUsageErr6		= "Usage Error: Invalid buffer cache size.";
LOCAL const char	* const szUsageErr7		= "Usage Error: Invalid batch I/O size.";
LOCAL const char	* const szUsageErr8		= "Usage Error: Invalid database extension size.";
LOCAL const char	* const szUsageErr9		= "Usage Error: No mode specified.";
LOCAL const char	* const szUsageErr10	= "Usage Error: Mode selection must be preceded by '-' or '/'.";
LOCAL const char	* const szUsageErr11	= "Usage Error: Old .DLL required in order to upgrade.";
LOCAL const char	* const szUsageErr12	= "Usage Error: Invalid mode.";
LOCAL const char	* const szUsageErr13	= "Usage Error: Invalid node/lgpos specification.";
LOCAL const char	* const szUsageErr14	= "Usage Error: Invalid logfile size: %s kbytes.";

#ifdef ESENT
LOCAL const char	* const szHelpDesc1		= "DESCRIPTION:  Maintenance utilities for Microsoft(R) Windows databases.";
#else  //  !ESENT
LOCAL const char	* const szHelpDesc1		= "DESCRIPTION:  Maintenance utilities for Microsoft(R) Exchange Server databases.";
#endif  //  ESENT
LOCAL const char	* const szHelpSyntax	= "MODES OF OPERATION:";
LOCAL const char	* const szHelpModes1	= "      Defragmentation:  %s /d <database name> [options]";
LOCAL const char	* const szHelpModes2	= "             Recovery:  %s /r [options]";
LOCAL const char	* const szHelpModes3	= "            Integrity:  %s /g <database name> [options]";
LOCAL const char	* const szHelpModes5	= "             Checksum:  %s /k <database name> [options]";
LOCAL const char	* const szHelpModes4	= "               Repair:  %s /p <database name> [options]";
LOCAL const char	* const szHelpModes6	= "            File Dump:  %s /m[mode-modifier] <filename>";
LOCAL const char	* const szHelpModes7	= "              Restore:  %s /c[mode-modifier] <path name> [options]";
LOCAL const char	* const szHelpModes8	= "               Backup:  %s /b <backup path> [options]";
LOCAL const char	* const szHelpModes9	= "             SLV Move:  %s /s <database name> /p<page>";
LOCAL const char	* const szHelpModes10	= "Record format Upgrade:  %s /f <database name>";
LOCAL const char	* const szHelpModes11	= "              Upgrade:  %s /u <database name> [options]";
LOCAL const char	* const	szHelpModes12	= "               Secure:  %s /z <database name> [options]";

LOCAL const char	* const szHelpPrompt1	= "<<<<<  Press a key for more help  >>>>>";
LOCAL const char	* const szHelpPrompt2	= "D=Defragmentation, R=Recovery, G=inteGrity, K=checKsum, P=rePair, M=file duMp";
#ifdef DEBUG
LOCAL const char	* const szHelpPrompt3	= "C=restore, B=Backup, S=Slv move, F=record Format upgrade, U=upgrade, Z=secure";
#endif
LOCAL const char	* const szHelpPromptCursor	= "=> ";

LOCAL const char	szRepairMessage[]		=
	"You should only run Repair on damaged or corrupted databases. Repair will not apply information in the "
	"transaction log files to the database, and may cause information to be lost. Do you wish to proceed?";

LOCAL const char	szRepairCaption[]		= "Warning";

LOCAL const char * const	szOperSuccess			= "Operation completed successfully in %d.%d seconds.";
LOCAL const char * const	szOperWarn				= "Operation completed successfully with %d (%s) after %d.%d seconds.";
LOCAL const char * const	szOperFailWithError		= "Operation terminated with error %d (%s) after %d.%d seconds.";
LOCAL const char * const	szOperFailUnknownError	= "Operation terminated unsuccessfully after %d.%d seconds.";

#define cbMsgBufMax	256

extern void JetErrorToString( JET_ERR err, const char **szError, const char **szErrorText );

typedef JET_ERR (__stdcall FNJETINIT)( JET_INSTANCE *pinstance );               
typedef JET_ERR (__stdcall FNJETINIT2)( JET_INSTANCE *pinstance, JET_GRBIT grbit );               
typedef JET_ERR (__stdcall FNJETTERM2)( JET_INSTANCE instance, JET_GRBIT grbit );
typedef JET_ERR (__stdcall FNJETSETSYSTEMPARAMETER)(                          
                                        JET_INSTANCE *pinstance,              
                                        JET_SESID sesid,                      
                                        unsigned long paramid,                
                                        JET_API_PTR lParam,                 
                                        const char *sz );                      
typedef JET_ERR (__stdcall FNJETGETSYSTEMPARAMETER)(
										JET_INSTANCE	instance,
										JET_SESID		sesid,
										unsigned long	paramid,
										JET_API_PTR		*plParam,
										char			*sz,
										unsigned long	cbMax );
typedef JET_ERR (__stdcall FNJETCOMPACT)(
										JET_SESID		sesid,
										const char		*szDatabaseSrc,
										const char		*szDatabaseDest,
										JET_PFNSTATUS	pfnStatus,
										JET_CONVERT		*pconvert,
										JET_GRBIT		grbit );
typedef JET_ERR (__stdcall FNJETBEGINSESSION)(
										JET_INSTANCE	instance,
										JET_SESID		*psesid,
										const char		*szUsername,
										const char		*szPassword );
typedef JET_ERR (__stdcall FNJETDETACHDATABASE)(
										JET_SESID sesid,
										const char *szFilename );
typedef JET_ERR (__stdcall FNJETENDSESSION)( JET_SESID sesid, JET_GRBIT grbit );
typedef JET_ERR (__stdcall FNJETRESTORE2)(
										const char *sz,
										const char *szDest,
										JET_PFNSTATUS pfn );
typedef JET_ERR (__stdcall FNJETBACKUP)(
										const char		*szBackupPath,
										JET_GRBIT		grbit,
										JET_PFNSTATUS	pfnStatus );
typedef JET_ERR (__stdcall FNJETDBUTILITIES)( JET_DBUTIL *pdbutil );

LOCAL HMODULE					g_hmod 	= NULL;

LOCAL FNJETINIT					* g_pfnJetInit 				= JetInit;
LOCAL FNJETINIT2   				* g_pfnJetInit2				= JetInit2;
LOCAL FNJETTERM2				* g_pfnJetTerm2				= JetTerm2;
LOCAL FNJETSETSYSTEMPARAMETER	* g_pfnJetSetSystemParameter= JetSetSystemParameter;
LOCAL FNJETGETSYSTEMPARAMETER	* g_pfnJetGetSystemParameter= JetGetSystemParameter;
LOCAL FNJETCOMPACT				* g_pfnJetCompact			= JetCompact;
LOCAL FNJETBEGINSESSION			* g_pfnJetBeginSession		= JetBeginSession;
LOCAL FNJETDETACHDATABASE		* g_pfnJetDetachDatabase	= JetDetachDatabase;
LOCAL FNJETENDSESSION			* g_pfnJetEndSession		= JetEndSession;
LOCAL FNJETRESTORE2				* g_pfnJetRestore2			= JetRestore2;
LOCAL FNJETBACKUP				* g_pfnJetBackup			= JetBackup;
LOCAL FNJETDBUTILITIES			* g_pfnJetDBUtilities		= JetDBUtilities;

#define JetInit (*g_pfnJetInit)
#define JetInit2 (*g_pfnJetInit2)
#define JetTerm2 (*g_pfnJetTerm2)
#define JetSetSystemParameter (*g_pfnJetSetSystemParameter)
#define JetGetSystemParameter (*g_pfnJetGetSystemParameter)
#define JetCompact (*g_pfnJetCompact)
#define JetBeginSession (*g_pfnJetBeginSession)
#define JetDetachDatabase (*g_pfnJetDetachDatabase)
#define JetEndSession (*g_pfnJetEndSession)
#define JetRestore2 (*g_pfnJetRestore2)
#define JetBackup (*g_pfnJetBackup)
#define JetDBUtilities (*g_pfnJetDBUtilities)

const _TCHAR * const szJetInit 					= _T( "JetInit");
const _TCHAR * const szJetInit2 				= _T( "JetInit2");
const _TCHAR * const szJetTerm2 				= _T( "JetTerm2");
const _TCHAR * const szJetSetSystemParameter	= _T( "JetSetSystemParameter");
const _TCHAR * const szJetGetSystemParameter	= _T( "JetGetSystemParameter");
const _TCHAR * const szJetCompact				= _T( "JetCompact");
const _TCHAR * const szJetBeginSession			= _T( "JetBeginSession");
const _TCHAR * const szJetDetachDatabase		= _T( "JetDetachDatabase");
const _TCHAR * const szJetEndSession			= _T( "JetEndSession");
const _TCHAR * const szJetRestore2				= _T( "JetRestore2");
const _TCHAR * const szJetBackup				= _T( "JetBackup");
const _TCHAR * const szJetDBUtilities			= _T( "JetDBUtilities");

//  ================================================================
JET_ERR ErrGetProcAddress(
			const HMODULE hmod,
			const _TCHAR * const szFunc,
			VOID ** const pvPfn )
//  ================================================================
	{
	if( NULL == ( (*pvPfn) = GetProcAddress( hmod, szFunc ) ) )
		{
		_tprintf( szErr8, szFunc );
		return JET_errCallbackNotResolved;
		}
	return JET_errSuccess;
	}

//  ================================================================
JET_ERR ErrUseDifferentDLL(	const _TCHAR * const szLibrary )
//  ================================================================
	{
	JET_ERR 		err;

	assert( NULL == g_hmod );

	_tprintf( "Loading %s...\r\n", szLibrary );
	
	g_hmod = LoadLibraryEx( szLibrary, NULL, 0 );
	if( NULL == g_hmod )
		{
		_tprintf( szErr7, szLibrary );
		Call( JET_errCallbackNotResolved );
		}

	Call( ErrGetProcAddress( g_hmod, szJetInit, (VOID **)&g_pfnJetInit ) );
///	Call( ErrGetProcAddress( g_hmod, szJetInit2, (VOID **)&g_pfnJetInit2 ) );
	Call( ErrGetProcAddress( g_hmod, szJetTerm2, (VOID **)&g_pfnJetTerm2 ) );
	Call( ErrGetProcAddress( g_hmod, szJetSetSystemParameter, (VOID **)&g_pfnJetSetSystemParameter ) );
	Call( ErrGetProcAddress( g_hmod, szJetGetSystemParameter, (VOID **)&g_pfnJetGetSystemParameter ) );
	Call( ErrGetProcAddress( g_hmod, szJetCompact, (VOID **)&g_pfnJetCompact ) );
	Call( ErrGetProcAddress( g_hmod, szJetBeginSession, (VOID **)&g_pfnJetBeginSession ) );
	Call( ErrGetProcAddress( g_hmod, szJetDetachDatabase, (VOID **)&g_pfnJetDetachDatabase ) );
	Call( ErrGetProcAddress( g_hmod, szJetEndSession, (VOID **)&g_pfnJetEndSession ) );
	Call( ErrGetProcAddress( g_hmod, szJetRestore2, (VOID **)&g_pfnJetRestore2 ) );
	Call( ErrGetProcAddress( g_hmod, szJetBackup, (VOID **)&g_pfnJetBackup ) );
	Call( ErrGetProcAddress( g_hmod, szJetDBUtilities, (VOID **)&g_pfnJetDBUtilities ) );

HandleError:
	return err;
	}
	
LOCAL CHAR	*GetNextArg();
LOCAL CHAR	*GetPrevArg();
LOCAL VOID	SetCurArgID( const INT id );
LOCAL INT	GetArgCount();
LOCAL INT	GetCurArgID();
LOCAL CHAR	*GetCurArg();

INLINE VOID EDBUTLFormatMessage( ULONG ulMsgId, CHAR *szMsgBuf, CHAR *szMsgArg )
	{
	DWORD	err;
	CHAR	*rgszMsgArgs[1] = { szMsgArg };		// Currently only support one argument.
	
	if ( szMsgArg )
		{
		err = FormatMessage(
			FORMAT_MESSAGE_FROM_HMODULE|FORMAT_MESSAGE_ARGUMENT_ARRAY,
			NULL,
			ulMsgId,
			LANG_USER_DEFAULT,
			szMsgBuf,
			cbMsgBufMax,
			reinterpret_cast<va_list *>( rgszMsgArgs )  );
		}
	else
		{
		err = FormatMessage(
			FORMAT_MESSAGE_FROM_HMODULE,
			NULL,
			ulMsgId,
			LANG_USER_DEFAULT,
			szMsgBuf,
			cbMsgBufMax,
			NULL );
		}
	if ( err == 0 )
		{
		// Format message failed.  No choice but to dump the error message
		// in English, then bail out.
		printf( "Unexpected Win32 error: %dL\n\n", GetLastError() );
		exit(1);
		}
	}
	

// Allocates a local buffer for the message, retrieves the message, and prints it out.
LOCAL VOID EDBUTLPrintMessage( ULONG ulMsgId, CHAR *szMsgArg )
	{
	CHAR	szMsgBuf[cbMsgBufMax];

	EDBUTLFormatMessage( ulMsgId, szMsgBuf, szMsgArg );
	printf( szMsgBuf );
	}
		

LOCAL VOID EDBUTLPrintLogo( void )
	{
	CHAR	szVersion[8];

	sprintf( szVersion, "%d.%d", VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION );
	
#ifdef ESENT
	EDBUTLPrintMessage( NTPRODUCTNAME_ID, NULL );
#else  //  !ESENT
	EDBUTLPrintMessage( PRODUCTNAME_ID, NULL );
#endif  //  ESENT
	EDBUTLPrintMessage( VERSION_ID, szVersion );
	EDBUTLPrintMessage( COPYRIGHT_ID, NULL );
	}

LOCAL VOID EDBUTLHelpDefrag( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "DEFRAGMENTATION/COMPACTION:%c", cNewLine );
	printf( "    DESCRIPTION:  Performs off-line compaction of a database.%c", cNewLine );
	printf( "         SYNTAX:  %s /d <database name> [options]%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  <database name> - filename of database to compact%c", cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /s<file>   - set streaming file name (default: NONE)%c", cNewLine );
	printf( "                  /t<db>     - set temp. database name (default: TEMPDFRG*.EDB)%c", cNewLine );
	printf( "                  /f<file>   - set temp. streaming file name%c", cNewLine );
	printf( "                               (default: TEMPDFRG*.STM)%c", cNewLine );
	printf( "                  /i         - do not defragment streaming file%c", cNewLine );
	printf( "                  /p         - preserve temporary database (ie. don't instate)%c", cNewLine );
	printf( "                  /b<db>     - make backup copy under the specified name%c", cNewLine );
#ifdef DEBUG	// Undocumented switches.
	printf( "                  /n         - dump defragmentation information to DFRGINFO.TXT%c", cNewLine );
	printf( "                  /x<#>      - database extension size, in pages (default: 256)%c", cNewLine );
	printf( "                  /w         - set batch IO size%c", cNewLine );
#endif	
	printf( "                  /8         - set 8k database page size (default: auto-detect)%c", cNewLine );
	printf( "                  /o         - suppress logo%c", cNewLine );
	printf( "          NOTES:  1) If instating is disabled (ie. /p), the original database%c", cNewLine );
	printf( "                     is preserved uncompacted, and the temporary database will%c", cNewLine );
	printf( "                     contain the defragmented version of the database.%c", cNewLine );
	}

LOCAL VOID EDBUTLHelpRecovery( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "RECOVERY:%c", cNewLine );
	printf( "    DESCRIPTION:  Performs recovery, bringing all databases to a%c", cNewLine );
	printf( "                  consistent state.%c", cNewLine );
	printf( "         SYNTAX:  %s /r <3-character logfile base name> [options]%c", szAppName, cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /l<path>   - location of log files%c", cNewLine );
	printf( "                               (default: current directory)%c", cNewLine );
	printf( "                  /s<path>   - location of system files (eg. checkpoint file)%c", cNewLine );
	printf( "                               (default: current directory)%c", cNewLine );
#ifdef LOG_SHIPPING	
	printf( "                  /f         - replaying replicated log files%c", cNewLine );
#endif	
	printf( "                  /i         - ignore mismatched/missing database attachments%c", cNewLine );
	printf( "                  /d[path]   - location of database files, or current directory%c", cNewLine );
	printf( "                               if [path] not specified (default: directory%c", cNewLine );
	printf( "                               originally logged in log files)%c", cNewLine ); 
#ifdef DEBUG
	printf( "                  /b<path>   - restore from backup (ie. hard recovery) from the%c", cNewLine );
	printf( "                               specified location%c", cNewLine );
	printf( "                  /r<path>   - restore to specified location (only valid when%c", cNewLine );
	printf( "                               the /b switch is also specified)%c", cNewLine );
#endif
	printf( "                  /8         - set 8k database page size (default: auto-detect)%c", cNewLine );
	printf( "                  /o         - suppress logo%c", cNewLine );
#ifdef DEBUG
	printf( "          NOTES:  1) Soft recovery is always performed unless the /b switch is%c", cNewLine );
	printf( "                     specified, in which case hard recovery is performed.%c", cNewLine );
#endif
	}

LOCAL VOID EDBUTLHelpIntegrity( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "INTEGRITY:%c", cNewLine );
	printf( "    DESCRIPTION:  Verifies integrity of a database.%c", cNewLine );
	printf( "         SYNTAX:  %s /g <database name> [options]%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  <database name> - filename of database to verify%c", cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /s<file>  - set streaming file name (default: NONE)%c", cNewLine );
	printf( "                  /t<db>    - set temp. database name (default: TEMPINTEG*.EDB)%c", cNewLine );
	printf( "                  /f<name>  - set prefix to use for name of report files%c", cNewLine );
	printf( "                              (default: <database>.integ.raw)%c", cNewLine );
#ifdef DEBUG	// Undocumented switches.
	printf( "                  /b        - don't rebuild and compare indexes%c", cNewLine );
	printf( "                  /n        - dump table statistics to INTGINFO.TXT%c", cNewLine );
#endif	//	DEBUG
	printf( "                  /8        - set 8k database page size (default: auto-detect)%c", cNewLine );
	printf( "                  /o        - suppress logo%c", cNewLine );
	printf( "          NOTES:  1) Integrity-check does not run database recovery.  If%c", cNewLine );
	printf( "                     a database is in an inconsistent state it is strongly%c", cNewLine );
	printf( "                     recommended that recovery is run to ensure the database%c", cNewLine );
	printf( "                     is consistent before proceeding with integrity-check.%c", cNewLine );
	}

LOCAL VOID EDBUTLHelpChecksum( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "CHECKSUM:%c", cNewLine );
	printf( "    DESCRIPTION:  Verifies the individual checksum of each page of a database.%c", cNewLine );
	printf( "         SYNTAX:  %s /k <database name> [options]%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  <database name> - filename of database to verify%c", cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /8   - set 8k database page size (default: auto-detect)%c", cNewLine );
	printf( "                  /o   - suppress logo%c", cNewLine );
	}

LOCAL VOID EDBUTLHelpRepair( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "REPAIR:%c", cNewLine );
	printf( "    DESCRIPTION:  Repairs a corrupted or damaged database.%c", cNewLine );
	printf( "         SYNTAX:  %s /p <database name> [options]%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  <database name> - filename of database to repair%c", cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /s<file>   - set streaming file name (default: NONE)%c", cNewLine );
	printf( "                  /t<db>     - set temp. database name%c", cNewLine );
	printf( "                               (default: TEMPREPAIR*.EDB)%c", cNewLine );
	printf( "                  /f<name>   - set prefix to use for name of report files%c", cNewLine );
	printf( "                               (default: <database>.integ.raw)%c", cNewLine );
#ifdef DEBUG	// Undocumented switches.
	printf( "                  /n         - dump table statistics to INTGINFO.TXT%c", cNewLine );
#endif	//	DEBUG
	printf( "                  /8         - set 8k database page size (default: auto-detect)%c", cNewLine );
	printf( "                  /o         - suppress logo%c", cNewLine );
	printf( "          NOTES:  1) Repair does not run database recovery.  If a database%c", cNewLine );
	printf( "                     is in an inconsistent state it is strongly recommended%c", cNewLine );
	printf( "                     that recovery is run to ensure the database is%c", cNewLine );
	printf( "                     consistent before proceeding with repair.%c", cNewLine );
	}

LOCAL VOID EDBUTLHelpDump( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "FILE DUMP:%c", cNewLine );
	printf( "    DESCRIPTION:  Generates formatted output of various database file types.%c", cNewLine );
	printf( "         SYNTAX:  %s /m[mode-modifier] <filename> [options]%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  [mode-modifier] - an optional letter designating the type of%c", cNewLine );
	printf( "                                    file dump to perform. Valid values are:%c", cNewLine );
	printf( "                                    h - dump database header (default)%c", cNewLine );
	printf( "                                    k - dump checkpoint file%c", cNewLine );
	printf( "                                    l - dump log file or set of logs%c", cNewLine );
#ifdef DEBUG
	printf( "                                    f - force database to a consistent state%c", cNewLine );
#endif
	printf( "                                    m - dump meta-data%c", cNewLine );
	printf( "                                    s - dump space usage%c", cNewLine );
#ifdef DEBUG	
	printf( "                                    n - dump nodes%c", cNewLine );
#endif	
	printf( "                  <filename>      - name of file to dump. The type of the%c", cNewLine );
	printf( "                                    specified file should match the dump type%c", cNewLine );
	printf( "                                    being requested (eg. if using /mh, then%c", cNewLine );
	printf( "                                    <filename> must be the name of a database).%c", cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
#ifdef DEBUG
	printf( "                  /k<node>@<lgpos>%c", cNewLine );
	printf( "                             - track a specific node in the logfile%c", cNewLine );
	printf( "                               starting from the given lgpos%c", cNewLine );
	printf( "                  /p<page>   - dump the given page from the database%c", cNewLine );
	printf( "                  /n<node>   - dump the given node from the database%c", cNewLine );
#endif	//	DEBUG
	printf( "                  /s<file>   - set streaming file name (default: NONE)%c", cNewLine );
	printf( "                  /t<table>  - perform dump for specified table only%c", cNewLine );
#ifdef DEBUG	
	printf( "                  /a         - dump all nodes including deleted ones%c", cNewLine );
	printf( "                               (dump-nodes mode only)%c", cNewLine );
#endif
	printf( "                  /v         - verbose%c", cNewLine );
	printf( "                  /8         - set 8k database page size (default: auto-detect)%c", cNewLine );
	printf( "                  /o         - suppress logo%c", cNewLine );
	}

#ifdef DEBUG

LOCAL VOID EDBUTLHelpHardRecovery( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "RESTORE:%c", cNewLine );
	printf( "    DESCRIPTION:  Restore information and completion.%c", cNewLine );
#ifdef RESTORE_SERVER_SIMULATION_HELP
	printf( "         SYNTAX:  %s /c[mode-modifier] <path name|file name> [options]%c", szAppName, cNewLine );
#else // RESTORE_SERVER_SIMULATION_HELP
	printf( "         SYNTAX:  %s /c[mode-modifier] <path name> [options]%c", szAppName, cNewLine );
#endif // RESTORE_SERVER_SIMULATION_HELP
	printf( "     PARAMETERS:  [mode-modifier] - a letter designating the type of operation%c", cNewLine );
	printf( "                                    to be done%c", cNewLine );
	printf( "                                    m - dump Restore.Env %c", cNewLine );
	printf( "                                    c - start recovery for a Restore.Env%c", cNewLine );
#ifdef RESTORE_SERVER_SIMULATION_HELP
	printf( "                                    s - simulate server based on description%c", cNewLine );
 	printf( "                  <path name>     - (/cm and /cc) directory of the restore%c", cNewLine );
 	printf( "                                    (Restore.Env location)%c", cNewLine );
	printf( "                                  OR%c", cNewLine );
	printf( "                  <file name>     - (/cs) name of the server description file%c", cNewLine );
#else // RESTORE_SERVER_SIMULATION_HELP
	printf( "                  <path name>     - directory of the restore%c", cNewLine );
	printf( "                                    (Restore.Env location)%c", cNewLine );
#endif // RESTORE_SERVER_SIMULATION_HELP
 	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /t<Instance>    - name of the instance where the play forward%c", cNewLine );
	printf( "                                    log file (default: from backup)%c", cNewLine );
	printf( "                                    If <Instance> is blank, don't play forward%c", cNewLine );
	printf( "                                    any log files.%c", cNewLine );
	printf( "                  /k              - preserves the log files used for recovery%c", cNewLine );
	printf( "                  /8              - set 8k database page size (default: auto-detect)%c", cNewLine );
	printf( "                  /o              - suppress logo%c", cNewLine );
	}

LOCAL VOID EDBUTLHelpBackup( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "BACKUP:%c", cNewLine );
	printf( "    DESCRIPTION:  Performs backup, bringing all databases to a%c", cNewLine );
	printf( "                  consistent state.%c", cNewLine );
	printf( "         SYNTAX:  %s /b <backup path> [options]%c", szAppName, cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /l<path>   - location of log files%c", cNewLine );
	printf( "                               (default: current directory)%c", cNewLine );
	printf( "                  /s<path>   - location of system files (eg. checkpoint file)%c", cNewLine );
	printf( "                               (default: current directory)%c", cNewLine );
	printf( "                  /c<path>   - incremental backup%c", cNewLine );
	printf( "                  /8         - set 8k database page size (default: auto-detect)%c", cNewLine );
	printf( "                  /o         - suppress logo%c", cNewLine );
	}

LOCAL VOID EDBUTLHelpSLVMove( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "SLV MOVE:%c", cNewLine );
	printf( "    DESCRIPTION:  Moves a SLV run that contains a certain SLV file page.%c", cNewLine );
	printf( "         SYNTAX:  %s /s <database name> /p<page>%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  <database name> - filename of database to use%c", cNewLine );
	printf( "                  <page>          - page number from the SLV file%c", cNewLine );
	}

#endif // DEBUG

#ifdef RECORD_FORMAT_UPGRADE
LOCAL VOID EDBUTLHelpUpgradeRecordFormat( const char * const szAppName )
	{
	printf( "%c", cNewLine );
	printf( "RECORD UPGRADE:%c", cNewLine );
	printf( "    DESCRIPTION:  Upgrades the record format for all pages in the database.%c", cNewLine );
	printf( "     PARAMETERS:  <database name> - filename of database to convert%c", cNewLine );
	}
#endif	

LOCAL VOID EDBUTLHelpUpgrade( char *szAppName )
	{
	printf( "%c", cNewLine );
	printf( "UPGRADE:%c", cNewLine );
	printf( "    DESCRIPTION:  Upgrades a database (created using a previous release of%c", cNewLine );
	printf( "                  Microsoft(R) Windows NT) to the current version.%c", cNewLine );
	printf( "         SYNTAX:  %s /u <database name> /d<previous .DLL> [options]%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  <database name>   - filename of the database to upgrade.%c", cNewLine );
	printf( "                  /d<previous .DLL> - pathed filename of the .DLL that came%c", cNewLine );
	printf( "                                      with the release of Microsoft(R)%c", cNewLine );
	printf( "                                      Windows NT from which you are upgrading.%c", cNewLine );
	printf( "        OPTIONS:  zero or more of the following switches, separated by a space:%c", cNewLine );
	printf( "                  /b<db>  - make backup copy under the specified name%c", cNewLine );
	printf( "                  /t<db>  - set temporary database name (default: TEMPUPGD.EDB)%c", cNewLine );
	printf( "                  /p      - preserve temporary database (ie. don't instate)%c", cNewLine );
#ifdef DEBUG	// Undocumented switches.
	printf( "                  /n      - dump upgrade information to UPGDINFO.TXT%c", cNewLine );
	printf( "                  /x<#>   - database extension size, in 4k pages (default: 256)%c", cNewLine );
	printf( "                  /a      - perform an in-place upgrade%c", cNewLine );
#endif	//	DEBUG
	printf( "                  /8      - set 8k database page size (default: auto-detect)%c", cNewLine );
	printf( "                  /o      - suppress logo%c", cNewLine );
	printf( "          NOTES:  1) This utility should only be used to upgrade a database%c", cNewLine );
	printf( "                     after an internal database format change has taken place.%c", cNewLine );
	printf( "                     If necessary, this will usually only coincide with the%c", cNewLine );
	printf( "                     release of a major, new revision of Microsoft(R)%c", cNewLine );
	printf( "                     Windows NT.%c", cNewLine );
	printf( "                  2) Before upgrading, the database should be in a consistent%c", cNewLine );
	printf( "                     state. An error will be returned if otherwise.%c", cNewLine );
	printf( "                  3) If instating is disabled (ie. /p), the original database%c", cNewLine );
	printf( "                     is preserved unchanged, and the temporary database will%c", cNewLine );
	printf( "                     contain the upgraded version of the database.%c", cNewLine );
	}

LOCAL VOID EDBUTLHelpScrub( const char * const szAppName )
	{
	printf( "%c", cNewLine );
	printf( "SECURE:%c", cNewLine );
	printf( "    DESCRIPTION:  Removes all deleted records from database.%c", cNewLine );
	printf( "         SYNTAX:  %s /s <database name>%c", szAppName, cNewLine );
	printf( "     PARAMETERS:  <database name> - filename of database to secure%c", cNewLine );
	printf( "                  /8   - set 8k database page size (default: auto-detect)%c", cNewLine );
	printf( "                  /o   - suppress logo%c", cNewLine );
	}


LOCAL VOID EDBUTLHelp( char *szAppName )
	{
	char c;

	EDBUTLPrintLogo();
	printf( szHelpDesc1 );
	printf( "%c%c", cNewLine, cNewLine );
	printf( szHelpSyntax );
	printf( "%c", cNewLine );
	printf( szHelpModes1, szAppName );
	printf( "%c", cNewLine );
	printf( szHelpModes2, szAppName );
	printf( "%c", cNewLine );
	printf( szHelpModes3, szAppName );
	printf( "%c", cNewLine );
	printf( szHelpModes4, szAppName );
	printf( "%c", cNewLine );
	printf( szHelpModes5, szAppName );
	printf( "%c", cNewLine );
	printf( szHelpModes6, szAppName );
	printf( "%c", cNewLine );
#ifdef DEBUG
	printf( szHelpModes7, szAppName );	//	mode 7 is Restore
	printf( "%c", cNewLine );

	printf( szHelpModes8, szAppName );	//	mode 8 is Backup
	printf( "%c", cNewLine );

	printf( szHelpModes9, szAppName );	//	mode 9 is OLDSLV
	printf( "%c", cNewLine );

#ifdef RECORD_FORMAT_UPGRADE
	printf( szHelpModes10, szAppName );	//	mode 10 is Record Format Upgrade
	printf( "%c", cNewLine );
#endif

	printf( szHelpModes11, szAppName );	//	mode 11 is Upgrade (undocumented in RETAIL)
	printf( "%c", cNewLine );

	printf( szHelpModes12, szAppName );	//	mode 12 is Scrub (undocumented in RETAIL )
	printf( "%c", cNewLine );
#endif	//	DEBUG

	printf( "%c", cNewLine );
	printf( "%s%c", szHelpPrompt1, cNewLine );
#ifdef DEBUG	
	printf( "%s,%c", szHelpPrompt2, cNewLine );
	printf( "%s%c", szHelpPrompt3, cNewLine );
#else
	printf( "%s%c", szHelpPrompt2, cNewLine );
#endif	
	printf( "%s", szHelpPromptCursor );
	c = (char)_getch();

	printf( "%c%c", cNewLine, cNewLine );

	switch ( c )
		{
		case 'd':
		case 'D':
			EDBUTLHelpDefrag( szAppName );
			break;
		case 'r':
		case 'R':
			EDBUTLHelpRecovery( szAppName );
			break;
		case 'g':
		case 'G':
			EDBUTLHelpIntegrity( szAppName );
			break;
		case 'k':
		case 'K':
			EDBUTLHelpChecksum( szAppName );
			break;			
		case 'p':
		case 'P':
			EDBUTLHelpRepair( szAppName );
			break;
		case 'm':
		case 'M':
			EDBUTLHelpDump( szAppName );
			break;

#ifdef DEBUG
		case 'c':
		case 'C':
			EDBUTLHelpHardRecovery( szAppName );
			break;			
		case 'b':
		case 'B':
			EDBUTLHelpBackup( szAppName );
			break;
		case 's':
		case 'S':
			EDBUTLHelpSLVMove( szAppName );
			break;
#endif

#ifdef RECORD_FORMAT_UPGRADE
		case 'f':
		case 'F':
			EDBUTLHelpUpgradeRecordFormat( szAppName );
			break;
#endif

		//	NOTE: Upgrade is undocumented in RETAIL
		case 'u':
		case 'U':
			EDBUTLHelpUpgrade( szAppName );
			break;

		//	NOTE: Scrub is undocumented in RETAIL
		case 'z':
		case 'Z':
			EDBUTLHelpScrub( szAppName );
			break;
		}
	}


#ifdef ESENT
//	Easter eggs are a fireable offense.
#else
static void EDBUTLSplash()
	{
	static const char foo[] =
	"..................................................."
	"                                                   "
	;
	
	static const char bar[] =
	"..................................................."
	"Laurion.Burchall"
	"....."
	"Adam.Foxman"
	"....."
	"Andrew.Goodsell"
	"....."
	"Adam.Green"
	"....."
	"Phillip.Hupf"
	"....."
	"Stephen.Jiang"
	"....."
	"Chris.Larson"
	"....."
	"Jonathan.Liem"
	"....."
	"Andrei.Marinescu"
	"....."	
	"Stuart.Padley"
	"....."
	"Michael.Rorke"
	"....."
	"Ivan.Trindev"
	"....."
	"Mark.Wistrom"
	"..................................................."
	;
	
	static const char baz[] =
	"                                                   "
	"..................................................."
	;

	const int cchWidth = 51;
	
	_cprintf( "\r\n                  Defragmentation Status (%% complete)\r\n\r\n" );
	_cprintf( "          0    10   20   30   40   50   60   70   80   90  100\r\n" );
	_cprintf( "          |----|----|----|----|----|----|----|----|----|----|\r\n" );
	_cprintf( "          " );

	int i;
	
	for( i = sizeof( foo ) - cchWidth - 1; i >= 0; --i )
		{
		_cprintf( "\r          %*.*s", cchWidth, cchWidth, foo + i );
		Sleep( 75 );
		}

	for( i = 0; i <= sizeof( bar ) - cchWidth - 1; ++i )
		{
		_cprintf( "\r          %*.*s", cchWidth, cchWidth, bar + i );
		Sleep( 75 );
		}

	for( i = sizeof( baz ) - cchWidth - 1; i >= 0; --i )
		{
		_cprintf( "\r          %*.*s", cchWidth, cchWidth, baz + i );
		Sleep( 75 );
		}

	_cprintf( "\r\n\r\n" );
	}
#endif	//	ESENT	


LOCAL VOID EDBUTLGetTime( ULONG timerStart, INT *piSec, INT *piMSec )
	{
	ULONG	timerEnd;

	timerEnd = GetTickCount();
	
	*piSec = ( timerEnd - timerStart ) / 1000;
	*piMSec = ( timerEnd - timerStart ) % 1000;
	}

LOCAL JET_ERR __stdcall PrintStatus( JET_SESID sesid, JET_SNP snp, JET_SNT snt, void *pv )
	{
	static int	iLastPercentage;
	int 		iPercentage;
	int			dPercentage;
	char		*szOperation = NULL;

	switch ( snp )
		{
		case -1:				// during Begin pv will point ot szOperation
		case JET_snpCompact:
		case JET_snpUpgrade:
		case JET_snpRestore:
		case JET_snpRepair:
		case JET_snpScrub:
		case JET_snpUpgradeRecordFormat:
			switch( snt )
				{
				case JET_sntProgress:
					assert( pv );
					iPercentage = static_cast< int >( ( __int64( reinterpret_cast< JET_SNPROG* >( pv )->cunitDone ) * __int64( 100 ) ) / __int64( reinterpret_cast< JET_SNPROG* >( pv )->cunitTotal ) );
					dPercentage = iPercentage - iLastPercentage;
					assert( dPercentage >= 0 );
					while ( dPercentage >= 2 )
						{
						printf( "." );
						iLastPercentage += 2;
						dPercentage -= 2;
						}
					break;

				case JET_sntBegin:
					{
					const char*	szOperation;
					SIZE_T		cbPadding, cbOper;

					switch ( snp )
						{
						default:
							szOperation = szDefrag;
							break;
						case JET_snpUpgrade:
							szOperation = szUpgrade;
							break;
						case JET_snpRestore:
							szOperation = szRestore;
							break;
						case JET_snpRepair:
							szOperation = szRepair;
							break;
						case JET_snpScrub:
							szOperation = szScrub;
							break;
						case JET_snpUpgradeRecordFormat:
							szOperation = szUpgradeRecordFormat;
							break;
						case -1:
							assert( NULL != pv );
							szOperation = (char *)pv;
						}

					printf( "%c", cNewLine );

					// Center the status message above the status bar.
					// Formula is: ( length of status bar - length of message ) / 2
					cbOper = strlen( szOperation );
					cbPadding = ( 51 - ( cbOper + (ULONG)strlen( szStatusMsg ) ) ) / 2;
					assert( cbPadding >= 0 );

					printf( "          %*s%s%c%c", cbPadding+cbOper, szOperation, szStatusMsg, cNewLine, cNewLine );
					printf( "          0    10   20   30   40   50   60   70   80   90  100\n" );
					printf( "          |----|----|----|----|----|----|----|----|----|----|\n" );
					printf( "          " );

					iLastPercentage = 0;
					break;
					}

				case JET_sntComplete:
					dPercentage = 100 - iLastPercentage;
					assert( dPercentage >= 0 );
					while ( dPercentage >= 2 )
						{
						printf( "." );
						iLastPercentage += 2;
						dPercentage -= 2;
						}

					printf( ".%c%c", cNewLine, cNewLine );
					break;
				}
			break;				
		}

	return JET_errSuccess;
	}

const EDBUTL_errInvalidPath = 1;	//	Does not form right path. param1 = file type
const EDBUTL_errSharedName	= 2;	//	Two file types share one file name. param1, param2 - files types
const EDBUTL_errInvalidDB	= 3;	//	cannot read source database header. param1 - error code
const EDBUTL_errNoSLVFile	= 4;	//	Source database does not have SLV file but such is specified

const EDBUTL_paramSrcDB		= 1;
const EDBUTL_paramSrcSLV	= 2;
const EDBUTL_paramTempDB	= 3;
const EDBUTL_paramTempSLV	= 4;
const EDBUTL_paramLast		= 5;

LOCAL VOID PrintErrorMessage( int const err, const UTILOPTS * const popts, int param1 = 0, int param2 = 0 )
	{
	assert( NULL != popts );
	
	static const char * const szObjectName[2*EDBUTL_paramLast] = 
		{
		"",
		"Source database",
		"Source streaming file",
		"Temporary database",
		"Temporary streaming file",
		"",
		"source database",
		"source streaming file",
		"temporary database",
		"temporary streaming file",
		};

	const char *const szObjectData[EDBUTL_paramLast] = 
		{
		"",
		popts->szSourceDB,
		popts->szSourceSLV,
		popts->szTempDB,
		popts->szTempSLV
		};
		
	switch ( err )
		{
		case EDBUTL_errInvalidPath:
			assert( 0 < param1 );
			assert( EDBUTL_paramLast > param1 );
			printf( "Error: %s specification '%s' is invalid.", 
				szObjectName[param1], szObjectData[param1] );
			break;
		case EDBUTL_errSharedName:
			assert( 0 < param1 );
			assert( EDBUTL_paramLast > param1 );
			assert( 0 < param2 );
			assert( EDBUTL_paramLast > param2 );
			printf( "Error: %s '%s' cannot be the same as %s.", 
				szObjectName[param1], szObjectData[param1], szObjectName[param2+EDBUTL_paramLast] );
			break;
		case EDBUTL_errInvalidDB:
			printf( "Error: Access to source database '%s' failed with Jet error %i.", 
				szObjectData[EDBUTL_paramSrcDB], param1 );
			break;
		case EDBUTL_errNoSLVFile:
			assert( 0 < param1 );
			assert( EDBUTL_paramLast > param1 );
			printf( "Usage Error: Source database has no streaming file but %s '%s' was specified.",
				szObjectName[param1+EDBUTL_paramLast], szObjectData[param1] );
			break;
		default:
			assert( 0 );
			return;
		}
	printf( "%c%c", cNewLine, cNewLine );
	}

LOCAL VOID EDBUTLGetSLVNameFromDbName( const CHAR *const szDbName, CHAR *const szSLVName )
	{
	CHAR	szDbDrive[_MAX_DRIVE+1];
	CHAR	szDbDir[_MAX_DIR+1];
	CHAR	szDbBaseName[_MAX_FNAME+1];

	assert( szSLVName != NULL );
	
	_tsplitpath( szDbName, szDbDrive, szDbDir, szDbBaseName, NULL );

	_tmakepath( szSLVName, szDbDrive, szDbDir, szDbBaseName, szStreamingFileExt );
	}

//	Check database and streaming file:
LOCAL JET_ERR ErrEDBUTLCheckDBSLVNames( 
	UTILOPTS*			popts, 
	const char * const	szTempDB, 
	char*				szSrcSLV		= NULL, 
	char*				szTempSLV		= NULL )
//	Parameters:
//		options structure
//		default temporaty database name
//		space to store names of SrcSLV & TempSLV
//			if NULL is passed they will not be retrieved at all
	{
	assert( NULL != popts );
	assert( NULL != szTempDB );
	assert( NULL == szTempSLV || NULL != szSrcSLV );

	CHAR	szFullpathSrcDB[ _MAX_PATH + 1] = "";
	CHAR	szFullpathTempDB[ _MAX_PATH + 1 ] = "";
	CHAR	szFullpathSrcSLV[ _MAX_PATH + 1] = "";
	CHAR	szFullpathTempSLV[ _MAX_PATH + 1 ] = "";

	//	if TempDB is not defined
	if ( NULL == popts->szTempDB )
		{ 
		//	set TempDB to DefaultTempDB
		popts->szTempDB = (char *)szTempDB;
		}

	//  if temp db is not valid path then ERROR
	if ( NULL == _fullpath( szFullpathTempDB, popts->szTempDB, _MAX_PATH ) )
		{
		PrintErrorMessage( EDBUTL_errInvalidPath, popts, EDBUTL_paramTempDB );
		return JET_errInvalidPath;
		}

	//	if SrcDB is not defined or is invalid path then ERROR
	if ( NULL == popts->szSourceDB )
		{
		printf( szUsageErr1, "source database" );
		printf( "%c%c", cNewLine, cNewLine );
		return JET_errInvalidParameter;
		}
	if ( NULL == _fullpath( szFullpathSrcDB, popts->szSourceDB, _MAX_PATH ) )
		{
		PrintErrorMessage( EDBUTL_errInvalidPath, popts, EDBUTL_paramSrcDB );
		return JET_errInvalidPath;
		}

	//	if 8k pages NOT specified, try to consult the database header
	//	to see if the database actually uses 8k pages
	//	WARNING: if a database uses 4k pages and this code erroneously
	//	(due to a bug, corruption, etc.) detects 8k pages, there is
	//	currently no way to override this code and force 4k pages
	ULONG	cbPageSize	= 0;
	if ( !FUTILOPTS8KPage( popts->fUTILOPTSFlags )
		&& JET_errSuccess == JetGetDatabaseFileInfo( popts->szSourceDB, &cbPageSize, sizeof(cbPageSize), JET_DbInfoPageSize )
		&& cbPageSize == 8192 )
		{
		const ERR	err		= JetSetSystemParameter( NULL, 0, JET_paramDatabasePageSize, 8192, NULL );
		if ( err < JET_errSuccess )
			return err;
		UTILOPTSSet8KPage( popts->fUTILOPTSFlags );
		}

	//	if need SrcSTM and SrcDB has a SLV file
	BOOL fDBHasSLV = fFalse;
	if ( szSrcSLV )
		{
		const ERR	err		= JetGetDatabaseFileInfo( popts->szSourceDB, &fDBHasSLV, sizeof( fDBHasSLV ), JET_DbInfoHasSLVFile );
		if ( err < JET_errSuccess )
			{
			PrintErrorMessage( EDBUTL_errInvalidDB, popts, err );
			return err;
			}
		}
	if ( fDBHasSLV )
		{
		//	if SrcSLV is not defined
		if ( NULL == popts->szSourceSLV )
			{
			assert( szSrcSLV != NULL );
			//	retrieve SrcSLV from SrcDB
			EDBUTLGetSLVNameFromDbName( popts->szSourceDB, szSrcSLV );
			popts->szSourceSLV = szSrcSLV;
			}
		//	if SrcSLV is not valid path ERROR
		if ( NULL == _fullpath( szFullpathSrcSLV, popts->szSourceSLV, _MAX_PATH ) )
			{
			PrintErrorMessage( EDBUTL_errInvalidPath, popts, EDBUTL_paramSrcSLV );
			return JET_errInvalidPath;
			}			
		//	if SrcSLV is the same as SrcDB then ERROR
		if ( 0 == _strcmpi( szFullpathSrcDB, szFullpathSrcSLV ) )
			{
			PrintErrorMessage( EDBUTL_errSharedName, popts, EDBUTL_paramSrcDB, EDBUTL_paramSrcSLV );
			return JET_errInvalidDatabase;
			}
		}
	//	if SrcSLV is defined but not expected then ERROR
	else if ( NULL != popts->szSourceSLV )
		{
		PrintErrorMessage( EDBUTL_errNoSLVFile, popts, EDBUTL_paramSrcSLV );
		return JET_errInvalidParameter;
		}

	//	if TempDB is the same as SrcDB or as SrcSLV then ERROR
	if ( 0 == _strcmpi( szFullpathSrcDB, szFullpathTempDB ) )
		{
		PrintErrorMessage( EDBUTL_errSharedName, popts, EDBUTL_paramSrcDB, EDBUTL_paramTempDB );
		return JET_errInvalidDatabase;
		}
	if ( 0 == _strcmpi( szFullpathSrcSLV, szFullpathTempDB ) )
		{
		PrintErrorMessage( EDBUTL_errSharedName, popts, EDBUTL_paramSrcSLV, EDBUTL_paramTempDB );
		return JET_errInvalidDatabase;
		}

	//	if SrcDB has SLV file and need tempSLV
	if ( fDBHasSLV && NULL != szTempSLV )
		{
		//	if TempSLV is not defined
		if ( NULL == popts->szTempSLV )
			{
			//	retrieve TempSLV from TempDB
			EDBUTLGetSLVNameFromDbName( popts->szTempDB, szTempSLV );
			popts->szTempSLV = szTempSLV;
			}
		//	if TempSLV is not valid path then ERROR
		if ( NULL == _fullpath( szFullpathTempSLV, popts->szTempSLV, _MAX_PATH ) )
			{
			PrintErrorMessage( EDBUTL_errInvalidPath, popts, EDBUTL_paramTempSLV );
			return JET_errInvalidPath;
			}			
		//	if TempSLV is the same as TempDB or as SrcDB or as SrcSLV then ERROR
		if ( 0 == _strcmpi( szFullpathSrcDB, szFullpathTempSLV ) )
			{
			PrintErrorMessage( EDBUTL_errSharedName, popts, EDBUTL_paramSrcDB, EDBUTL_paramTempSLV );
			return JET_errInvalidDatabase;
			}
		if ( 0 == _strcmpi( szFullpathSrcSLV, szFullpathTempSLV ) )
			{
			PrintErrorMessage( EDBUTL_errSharedName, popts, EDBUTL_paramSrcSLV, EDBUTL_paramTempSLV );
			return JET_errInvalidDatabase;
			}
		if ( 0 == _strcmpi( szFullpathTempDB, szFullpathTempSLV ) )
			{
			PrintErrorMessage( EDBUTL_errSharedName, popts, EDBUTL_paramTempDB, EDBUTL_paramTempSLV );
			return JET_errInvalidDatabase;
			}
		}
	//	else if TempSLV is defined but not expected then ERROR
	else if ( NULL != popts->szTempSLV )
		{
		PrintErrorMessage( EDBUTL_errNoSLVFile, popts, EDBUTL_paramSrcSLV );
		return JET_errInvalidParameter;
		}
	return JET_errSuccess;
	}

#ifdef DEBUG
LOCAL JET_ERR ErrEDBUTLCheckBackupPath( UTILOPTS *popts )
	{
	CHAR	szFullpathBackup[ _MAX_PATH + 1];

	if ( popts->szBackup == NULL )
		{
		printf( szUsageErr1, "backup path" );
		printf( "%c%c", cNewLine, cNewLine );
		return JET_errInvalidParameter;
		}
	
	if ( _fullpath( szFullpathBackup, popts->szBackup, _MAX_PATH ) == NULL )
		{
		printf( szErr1, popts->szBackup );
		printf( "%c%c", cNewLine, cNewLine );
		return JET_errInvalidPath;
		}

	return JET_errSuccess;
	}
#endif

LOCAL BOOL FEDBUTLParsePath( char *arg, char **pszParam, char *szParamDesc, BOOL fAllowEmpty = fFalse )
	{
	BOOL	fResult = fTrue;

	// if the argument is empty try to read next one argument
	if ( '\0' == *arg )
		{
		char *argT = arg;
		arg = GetNextArg();
		// if it was last argument or option follows it means we passed empty argument
		if ( NULL == arg || NULL != strchr( szSwitches, *arg ) )
			{
			arg = argT;
			SetCurArgID( GetCurArgID() - 1 );
			}
		}

	// no path should contain leading ':'(s)
	while ( ':' == *arg )
		{
		arg++;
		}

	
	if ( '\0' == *arg && !fAllowEmpty )
		{
		printf( szUsageErr1, szParamDesc );			// Missing spec.
		printf( "%c%c", cNewLine, cNewLine );
		fResult = fFalse;
		}
	else if ( NULL == *pszParam )
		{
		*pszParam = arg;
		}
	else
		{
		printf( szUsageErr2, szParamDesc );			// Duplicate spec.
		printf( "%c%c", cNewLine, cNewLine );
		fResult = fFalse;
		}
		
	return fResult;
	}


LOCAL BOOL FEDBUTLParseDefragment( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fTrue;

	switch( arg[1] )
		{
		case 'b':
		case 'B':
			fResult = FEDBUTLParsePath( arg+2, &popts->szBackup, "backup database" );
			break;

		case 'n':		
		case 'N':
			UTILOPTSSetDefragInfo( popts->fUTILOPTSFlags );
			break;
			
		case 'p':
		case 'P':
			UTILOPTSSetPreserveTempDB( popts->fUTILOPTSFlags );
			break;
			
		case 't':
		case 'T':
			fResult = FEDBUTLParsePath( arg+2, &popts->szTempDB, "temporary database" );
			break;

		case 'w':
		case 'W':				
			popts->cpageBatchIO = atol( arg + 2 );
			if ( popts->cpageBatchIO <= 0 )
				{
				printf( szUsageErr7 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				}
			break;

		case 'x':
		case 'X':
			popts->cpageDbExtension = atol( arg + 2 );
			if ( popts->cpageDbExtension <= 0 )
				{
				printf( szUsageErr8 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				}
			break;

		case 'i':
		case 'I':
			UTILOPTSSetDefragSLVDontCopy( popts->fUTILOPTSFlags );
			break;

		case 's':
		case 'S':
			fResult = FEDBUTLParsePath( arg+2, &popts->szSourceSLV, "streaming file" );
			break;

		case 'f':
		case 'F':
			fResult = FEDBUTLParsePath( arg+2, &popts->szTempSLV, "temp. streaming file" );
			break;

		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	return fResult;
	}

LOCAL BOOL FEDBUTLParseRecovery( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fTrue;

	switch( arg[1] )
		{
#ifdef LOG_SHIPPING		
		case 'f':
		case 'F':
			popts->grbitInit |= JET_bitReplayReplicatedLogFiles;
			break;
#endif			

		case 'i':
		case 'I':
			popts->grbitInit |= JET_bitReplayIgnoreMissingDB;
			break;

		case 'l':
		case 'L':
			fResult = FEDBUTLParsePath( arg+2, &popts->szLogfilePath, "logfile path" );
			break;

		case 's':
		case 'S':
			fResult = FEDBUTLParsePath( arg+2, &popts->szSystemPath, "system path" );
			break;

		case 't':
		case 'T':
			popts->pageTempDBMin = atol( arg + 2 );
			fResult = fTrue;
			break;

		case 'd':
		case 'D':
			if ( NULL != popts->szBackup || NULL != popts->szRestore )
				{
				printf( szUsageErr3 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				}
			else
				{
				//	if no directory specified, use current directory
				fResult = FEDBUTLParsePath( arg+2, &popts->szSourceDB, "database directory", fTrue );
				if ( fResult && '\0' == popts->szSourceDB[0] )
					popts->szSourceDB = (CHAR *)szCurrDir;
				}
			break;

#ifdef DEBUG
		case 'b':
		case 'B':
			if ( NULL != popts->szSourceDB )
				{
				printf( szUsageErr3 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				}
			else
				{
				fResult = FEDBUTLParsePath( arg+2, &popts->szBackup, "backup directory" );
				}
			break;

		case 'r':
		case 'R':
			if ( NULL != popts->szSourceDB )
				{
				printf( szUsageErr3 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				}
			else
				{
				fResult = FEDBUTLParsePath( arg+2, &popts->szRestore, "destination directory" );
				}
			break;
#endif

		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	return fResult;
	}	

LOCAL BOOL FEDBUTLParseIntegrity( char *arg, UTILOPTS *popts )
	{
	BOOL		fResult = fTrue;

	switch( arg[1] )
		{
		case 'b':
		case 'B':
			UTILOPTSSetDontBuildIndexes( popts->fUTILOPTSFlags );
			break;

		case 'n':
		case 'N':
			UTILOPTSSetDumpStats( popts->fUTILOPTSFlags );
			break;

		case 't':
		case 'T':
			fResult = FEDBUTLParsePath( arg+2, &popts->szTempDB, "temporary database" );
			break;

		case 's':
		case 'S':
			fResult = FEDBUTLParsePath( arg+2, &popts->szSourceSLV, "streaming file" );
			break;

		case 'f':
		case 'F':
			fResult = FEDBUTLParsePath( arg+2, &popts->szIntegPrefix, "report file name prefix" );
			break;
			
		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	return fResult;
	}

LOCAL BOOL FEDBUTLParseRepair( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fTrue;

	switch( arg[1] )
		{
		case 't':
		case 'T':
			fResult = FEDBUTLParsePath( arg+2, &popts->szTempDB, "temporary database" );
			break;

		case 'n':
		case 'N':
			UTILOPTSSetDumpStats( popts->fUTILOPTSFlags );
			break;

		case 's':
		case 'S':
			fResult = FEDBUTLParsePath( arg+2, &popts->szSourceSLV, "streaming file" );
			break;

		case 'f':
		case 'F':
			fResult = FEDBUTLParsePath( arg+2, &popts->szIntegPrefix, "report file name prefix" );
			break;
			
		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	return fResult;
	}

LOCAL VOID EDBUTLGetBaseName( const CHAR * const szLogfile, CHAR * const szBaseName )
	{
	CHAR	szNameT[_MAX_FNAME+1];

	assert( szBaseName != NULL );
	
	_tsplitpath( szLogfile, NULL, NULL, szNameT, NULL );
	_tcsncpy( szBaseName, szNameT, 3 );
	szBaseName[ 3 ] = 0;
	}

LOCAL BOOL FEDBUTLParseDump( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fFalse;

	switch( arg[1] )
		{
		case 'a':
		case 'A':
			{
			JET_DBUTIL * pdbutil;
			pdbutil = reinterpret_cast<JET_DBUTIL *>( popts->pv );
			
			if (pdbutil->op != opDBUTILDumpData)
				fResult = fFalse;
			else
				{	
				pdbutil->grbitOptions |= JET_bitDBUtilOptionAllNodes;
				fResult	= fTrue;
				}
			}
			break;

		case 'v':
		case 'V':
			{
			JET_DBUTIL * pdbutil;
			pdbutil = reinterpret_cast<JET_DBUTIL *>( popts->pv );

			pdbutil->grbitOptions |= JET_bitDBUtilOptionDumpVerbose;
			fResult = fTrue;
			}
			break;

		case 's':
		case 'S':
			fResult = FEDBUTLParsePath( arg+2, &popts->szSourceSLV, "streaming file" );
			break;
			
		case 't':
		case 'T':
			{
			JET_DBUTIL * pdbutil;
			pdbutil = reinterpret_cast<JET_DBUTIL *>( popts->pv );

			switch ( pdbutil->op )
				{
				case opDBUTILDumpData:
				case opDBUTILDumpMetaData:
				case opDBUTILDumpSpace:
					pdbutil->szTable = arg+2;
					fResult = fTrue;
					break;
				default:
					fResult = fFalse;
				}
			}
			break;

		case 'p':
		case 'P':
			{
			char 	szPage[256];
			strcpy( szPage, arg+2 );

			JET_DBUTIL * pdbutil;
			pdbutil = reinterpret_cast<JET_DBUTIL *>( popts->pv );

			pdbutil->op 	= opDBUTILDumpPage;
			pdbutil->pgno	= atoi( szPage );

			fResult			= fTrue;
			}
			break;

#ifdef DEBUG
		case 'k':
		case 'K':
			{			
			const char * pchSep;
			if( NULL == ( pchSep = strchr( arg, '@' ) ) )
				{
				printf( "%s (1)", szUsageErr13 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				break;
				}

			char 	szNode[1024];
			char	szLgpos[1024];
			strncpy( szNode, arg+2, UINT( pchSep - arg + 1 ) );
			strcpy( szLgpos, pchSep + 1 );
			
			int 	dbid;
			int		pgno;
			int		iline;
			if( sscanf( szNode, "[%d:%d:%d]", &dbid, &pgno, &iline ) != 3 
				&& sscanf( szNode, "%d:%d:%d", &dbid, &pgno, &iline ) != 3 )
				{
				printf( "%s (2)", szUsageErr13 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				break;
				}

			long		lGeneration;
			long		isec;
			long		ib;
			if( sscanf( szLgpos, "%x,%x,%x", &lGeneration, &isec, &ib ) != 3 )
				{
				printf( "%s (3)", szUsageErr13 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				break;
				}

			JET_DBUTIL * pdbutil;
			pdbutil = reinterpret_cast<JET_DBUTIL *>( popts->pv );
			
			pdbutil->op 	= opDBUTILDumpLogfileTrackNode;
			pdbutil->dbid	= dbid;
			pdbutil->pgno	= pgno;
			pdbutil->iline	= iline;
			pdbutil->lGeneration = lGeneration;
			pdbutil->isec	= isec;
			pdbutil->ib		= ib;
			
			fResult = fTrue;
			}
			break;

		/*
		case 's':
		case 'S':
			{
			char 	szPage[256];
			strcpy( szPage, arg+2 );

			JET_DBUTIL * pdbutil;
			pdbutil = reinterpret_cast<JET_DBUTIL *>( popts->pv );

			pdbutil->op 	= opDBUTILSLVMove;
			pdbutil->pgno	= atoi( szPage );

			fResult			= fTrue;
			}
			break;
		*/
		
		case 'n':
		case 'N':
			{
			char 	szNode[256];
			strcpy( szNode, arg+2 );

			int 	dbid 	= 0;
			int		pgno	= 0;
			int		iline	= 0;
			if(
				sscanf( szNode, "[%d:%d:%d]", &dbid, &pgno, &iline ) != 3 
				&& sscanf( szNode, "%d:%d:%d", &dbid, &pgno, &iline ) != 3
				&& sscanf( szNode, "[%d:%d]", &pgno, &iline ) != 2
				&& sscanf( szNode, "%d:%d", &pgno, &iline ) != 2
				)
				{
				printf( "%s (2)", szUsageErr13 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				break;
				}

			JET_DBUTIL * pdbutil;
			pdbutil = reinterpret_cast<JET_DBUTIL *>( popts->pv );

			pdbutil->op 	= opDBUTILDumpNode;
			pdbutil->dbid	= dbid;
			pdbutil->pgno	= pgno;
			pdbutil->iline	= iline;

			fResult			= fTrue;
			}
			break;

#endif	//	DEBUG

#ifdef ESENT
#else  //  !ESENT			
		case 'e':
		case 'E':
			if ( 0 == stricmp( arg+1, "exslv" ) )
				{
				JET_DBUTIL * const	pdbutil		= reinterpret_cast<JET_DBUTIL *>( popts->pv );

				pdbutil->op = opDBUTILDumpExchangeSLVInfo;
				fResult = fTrue;
				break;
				}
#endif  //  ESENT

		//	FALL THROUGH

		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	return fResult;
	}	

#ifdef DEBUG

LOCAL BOOL FEDBUTLParseHardRecovery( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fTrue;

	switch( arg[1] )
		{
		case 'k':
		case 'K':
			if ( !FUTILOPTSDumpRestoreEnv(popts->fUTILOPTSFlags) )
				{
				UTILOPTSSetPreserveTempDB( popts->fUTILOPTSFlags );
				break;
				}
			// no /t allowed if dump mode specified
		case 't':
		case 'T':
			if ( !FUTILOPTSDumpRestoreEnv(popts->fUTILOPTSFlags) )
				{
				// allow NULL target name. It means : no play forward
				fResult = FEDBUTLParsePath( arg+2, &popts->szRestore, "Target Instance", fTrue );
				break;
				}
			// no /t allowed if dump mode specified
		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	return fResult;
	}	
				
LOCAL BOOL FEDBUTLParseBackup( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fFalse;	// backup directory must be set at least.

	switch( arg[1] )
		{
		case 'l':
		case 'L':
			fResult = FEDBUTLParsePath( arg+2, &popts->szLogfilePath, "logfile path" );
			break;

		case 's':
		case 'S':
			fResult = FEDBUTLParsePath( arg+2, &popts->szSystemPath, "system path" );
			break;

		case 'c':
		case 'C':
			UTILOPTSSetIncrBackup( popts->fUTILOPTSFlags );
			break;

		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	return fResult;
	}

LOCAL BOOL FEDBUTLParseSLVMove( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fFalse;

	switch( arg[1] )
		{
		case 'p':
		case 'P':
			{
			char 	szPage[256];
			strcpy( szPage, arg+2 );

			JET_DBUTIL * pdbutil;
			pdbutil = reinterpret_cast<JET_DBUTIL *>( popts->pv );

			pdbutil->op 	= opDBUTILDumpPage;
			pdbutil->pgno	= atoi( szPage );

			fResult			= fTrue;
			}
			break;

		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	if ( NULL == popts->szSourceDB )
		{
		fResult = fFalse;
		}
		
	return fResult;
	}	
	
#endif	//	DEBUG

#ifdef RECORD_FORMAT_UPGRADE
LOCAL BOOL FEDBUTLParseUpgradeRecordFormat( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fTrue;

	switch( arg[1] )
		{
		case 'd':	//	add a non-default case to avoid compiler warnings
		case 'D':
			popts->lDirtyLevel = atol( arg + 2 );
			break;
			
		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	return fResult;
	}
#endif

LOCAL BOOL FEDBUTLParseUpgrade( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fTrue;

	switch( arg[1] )
		{
		case 'd':
		case 'D':
			fResult = FEDBUTLParsePath( arg+2, &((JET_CONVERT *)(popts->pv))->szOldDll, "old .DLL" );
			break;

		case 'b':
		case 'B':
			fResult = FEDBUTLParsePath( arg+2, &popts->szBackup, "backup database" );
			break;
			
		case 'n':
		case 'N':
			UTILOPTSSetDefragInfo( popts->fUTILOPTSFlags );
			break;
			
		case 'p':
		case 'P':
			UTILOPTSSetPreserveTempDB( popts->fUTILOPTSFlags );
			break;
			
		case 't':
		case 'T':
			fResult = FEDBUTLParsePath( arg+2, &popts->szTempDB, "temporary database" );
			break;
			
		case 'x':
		case 'X':
			popts->cpageDbExtension = atol( arg + 2 );
			if ( popts->cpageDbExtension <= 0 )
				{
				printf( szUsageErr8 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;
				}
			break;

		case 'a':
		case 'A':
			UTILOPTSSetInPlaceUpgrade( popts->fUTILOPTSFlags );
			break;

		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
		}

	return fResult;
	}	

LOCAL BOOL FEDBUTLParseScrub( char *arg, UTILOPTS *popts )
	{
	BOOL	fResult = fTrue;

	switch( arg[1] )
		{
		case 's':
		case 'S':
			fResult = FEDBUTLParsePath( arg+2, &popts->szSourceSLV, "streaming file" );
			break;

		default:
			printf( szUsageErr4, arg );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
			break;
		}

	return fResult;
	}


LOCAL CHAR **g_argv = NULL;
LOCAL INT	g_argMaxID = 0;
LOCAL INT	g_argCurID = -1;

//	initalizes argument index, and set to point before firts index
LOCAL VOID InitArg( int argc, char *argv[] )
	{
	g_argMaxID = argc;
	g_argv = argv;
	g_argCurID = -1;
	}

//	returns current argument index
//	returns -1 if is before first argument
//	return  ArgCount after last argument
LOCAL INT GetCurArgID()
	{
	return g_argCurID;
	}

LOCAL INT GetArgCount()
	{
	return g_argMaxID;
	}

LOCAL VOID SetCurArgID( const INT id )
	{
	if ( -1 > id )
		{
		g_argCurID = -1;
		}
	else if ( g_argMaxID < id )
		{
		g_argCurID = g_argMaxID;
		}
	else
		{
		g_argCurID = id;
		}
	}

LOCAL CHAR *GetCurArg()
	{
	AssertPREFIX( -1 <= g_argCurID );
	AssertPREFIX( 0 != g_argMaxID );
	AssertPREFIX( g_argMaxID >= g_argCurID );
	if ( -1 == g_argCurID || g_argMaxID == g_argCurID )
		{
		return NULL;
		}
	return g_argv[g_argCurID];
	}

LOCAL CHAR *GetNextArg()
	{
	SetCurArgID( GetCurArgID()+1 );
	return GetCurArg();
	}

LOCAL CHAR *GetPrevArg()
	{
	SetCurArgID( GetCurArgID()-1 );
	return GetCurArg();
	}

LOCAL BOOL FSetDumpModeModifier( char chMode, JET_DBUTIL *pdbutil )
	{
	switch( chMode )
		{
		case 0:
		case 'h':
		case 'H':
			pdbutil->op = opDBUTILDumpHeader;
			break;

		case 'k':
		case 'K':
			pdbutil->op = opDBUTILDumpCheckpoint;
			break;

		case 'm':
		case 'M':
			pdbutil->op = opDBUTILDumpMetaData;
			break;

#ifdef DEBUG
		case 'f':
		case 'F':
			pdbutil->op = opDBUTILSetHeaderState;
			break;

		case 'n':
		case 'N':
			pdbutil->op = opDBUTILDumpData;
			break;

#endif
			
		case 'l':
		case 'L':
			pdbutil->op = opDBUTILDumpLogfile;
			break;

		case 's':
		case 'S':
			pdbutil->op = opDBUTILDumpSpace;
			break;

		default:
			return fFalse;
		}
		return fTrue;
	}

LOCAL BOOL FSetHardRecoveryModeModifier( char chMode, UTILOPTS *popts )
	{
	switch( chMode )
		{
		case 'c':
		case 'C':
			break;
		case 'm':
		case 'M':
			UTILOPTSSetDumpRestoreEnv( popts->fUTILOPTSFlags );
			break;
#ifdef RESTORE_SERVER_SIMULATION
		case 's':
		case 'S':
			UTILOPTSSetServerSim ( popts->fUTILOPTSFlags );
			break;
#endif // RESTORE_SERVER_SIMULATION
		default:
			return fFalse;
		}
	return fTrue;
	}

LOCAL BOOL FEDBUTLParseOptions(
	UTILOPTS	*popts,
	BOOL		(*pFEDBUTLParseMode)( char *arg, UTILOPTS *popts ) )
	{
	BOOL		fResult = fTrue;
	char		*arg = GetCurArg();
	INT 		iSkipID = -1; // argument ID to skip. Related to dump and hard recovery hacks

	assert( NULL != arg );
	assert( NULL != strchr( szSwitches, *arg ) );
	assert( '\0' != *arg + 1 );

	//	HACK for dump 
	if ( modeDump == popts->mode ) 
		{
		// when we have only one char after mode it is mode modifier
		if ( '\0' != arg[2] && '\0' == arg[3] )
			{
			fResult = FSetDumpModeModifier( arg[2], (JET_DBUTIL *)popts->pv );
			arg++;
			}
		else	// run search to set mode specifier
			{
			INT curid = GetCurArgID();
			char *argT;
			fResult = fFalse;
			while ( !fResult && NULL != ( argT = GetNextArg() ) )
				{
				if ( NULL != strchr( szSwitches, *argT ) && '\0' != argT[1] && '\0' == argT[2] )
					{
					fResult = FSetDumpModeModifier( argT[1], (JET_DBUTIL *)popts->pv );
					}
				}
			if ( !fResult )
				{
				fResult = FSetDumpModeModifier( '\0', (JET_DBUTIL *)popts->pv );
				}
			iSkipID = GetCurArgID();
			SetCurArgID( curid );
			assert( GetCurArgID() == curid );
			}
		}
	//	HACK for hard recovery
	else if ( modeHardRecovery == popts->mode )
		{
		// when we have only one char afret mode it is mode modifier
		if ( '\0' != arg[2] && '\0' == arg[3] )
			{
			fResult = FSetHardRecoveryModeModifier( arg[2], popts );
			arg ++;	// ignore mode modifier
			}
		else	// run search to set mode specifier
			{
			INT curid = GetCurArgID();
			char *argT;
			fResult = fFalse;
			while ( !fResult && NULL != ( argT = GetNextArg() ) )
				{
				if ( NULL != strchr( szSwitches, *argT ) && '\0' != argT[1] && '\0' == argT[2] )
					{
					fResult = FSetHardRecoveryModeModifier( argT[1], popts );
					}
				}
			iSkipID = GetCurArgID();
			SetCurArgID( curid );
			assert( GetCurArgID() == curid );
			}
		}
		
	if ( !fResult )
		{
		printf( szUsageErr12 );
		printf( "%c%c", cNewLine, cNewLine );
		}
		
	arg += 2;
	if ( '\0' == *arg )
		{
		arg = GetNextArg();
		}

	// First option specifies the mode, so start with the second option.
	for ( ; fResult && NULL != arg; arg = GetNextArg() )
		{
		//	dump and hard recovery hack
		if ( GetCurArgID() == iSkipID )
			{
			continue;
			}
			
		if ( strchr( szSwitches, arg[0] ) == NULL )
			{
			// SPECIAL CASE: Backup mode does not DB specification.
			switch ( popts->mode )
				{
				case modeRecovery:
					if ( fResult = ( NULL == popts->szBase ) )
						{
						popts->szBase = arg;
						}
					break;
				case modeBackup:
					if ( fResult = ( NULL == popts->szBackup ) )
						{
						popts->szBackup = arg;
						}
					break;
				default:
					if ( fResult = ( NULL == popts->szSourceDB ) )
						{
						popts->szSourceDB = arg;
						}
					break;
				}

			if ( !fResult )
				{
				printf( szUsageErr5, arg );
				printf( "%c%c", cNewLine, cNewLine );
				}
			}

		else
			{
			// Parse options common to all modes.  Pass off unique options to the
			// custom parsers.
			switch ( arg[1] )
				{
				case '8':
					UTILOPTSSet8KPage( popts->fUTILOPTSFlags );
					break;

				case 'o':
				case 'O':
					UTILOPTSSetSuppressLogo( popts->fUTILOPTSFlags );
					break;

				case '!':
					//	logfile size param no longer needed (Jet now
					//	auto-detects logfile size when needed)
					break;

				default:
					if ( pFEDBUTLParseMode )
						{
						fResult = (*pFEDBUTLParseMode)( arg, popts );
						}
					else
						{
						printf( szUsageErr4, arg );
						printf( "%c%c", cNewLine, cNewLine );
						fResult = fFalse;
						}
					break;
				}
			}
		}

	return fResult;		
	}


//  ================================================================
LOCAL JET_ERR ErrEDBUTLRepair(
	const JET_SESID	sesid,
	const char * const szDatabase,
	const char * const szSLV,
	const char * const szBackup,
	const char * const szTable,
	const char * const szIntegPrefix,
	const JET_PFNSTATUS pfnStatus,
	const JET_GRBIT grbit
	)
//  ================================================================
	{
	JET_DBUTIL dbutil;
	memset( &dbutil, 0, sizeof( dbutil ) );

	dbutil.cbStruct			= sizeof( JET_DBUTIL );
	dbutil.op				= opDBUTILEDBRepair;
	dbutil.szDatabase 		= const_cast<char *>( szDatabase );
	dbutil.szSLV 			= const_cast<char *>( szSLV );
	dbutil.szBackup			= const_cast<char *>( szBackup );
	dbutil.szTable			= const_cast<char *>( szTable );
	dbutil.szIntegPrefix	= const_cast<char *>( szIntegPrefix );
	dbutil.sesid			= sesid;
	dbutil.grbitOptions		= grbit;	
	dbutil.pfnCallback		= pfnStatus;

	const JET_ERR err = JetDBUtilities( &dbutil );
	return err;
	}


//  ================================================================
LOCAL JET_ERR ErrEDBUTLScrub(
	JET_SESID	sesid,
	const char * const szDatabase,
	const char * const szSLV,
	JET_PFNSTATUS pfnStatus,
	JET_GRBIT grbit
	)
//  ================================================================
	{
	JET_DBUTIL dbutil;
	memset( &dbutil, 0, sizeof( dbutil ) );

	dbutil.cbStruct			= sizeof( JET_DBUTIL );
	dbutil.op				= opDBUTILEDBScrub;
	dbutil.szDatabase 		= const_cast<char *>( szDatabase );
	dbutil.szSLV 			= const_cast<char *>( szSLV );
	dbutil.sesid			= sesid;
	dbutil.grbitOptions		= grbit;	
	dbutil.pfnCallback		= pfnStatus;

	const JET_ERR err = JetDBUtilities( &dbutil );
	return err;
	}


#ifdef RECORD_FORMAT_UPGRADE
//  ================================================================
LOCAL JET_ERR ErrEDBUTLUpgradeRecordFormat(
	JET_SESID	sesid,
	const char * const szDatabase,
	JET_PFNSTATUS pfnStatus,
	JET_GRBIT grbit
	)
//  ================================================================
	{
	JET_DBUTIL dbutil;
	memset( &dbutil, 0, sizeof( dbutil ) );

	dbutil.cbStruct			= sizeof( JET_DBUTIL );
	dbutil.op				= opDBUTILDBConvertRecords;
	dbutil.szDatabase 		= const_cast<char *>( szDatabase );
	dbutil.szSLV 			= NULL;
	dbutil.sesid			= sesid;
	dbutil.grbitOptions		= grbit;	
	dbutil.pfnCallback		= pfnStatus;

	const JET_ERR err = JetDBUtilities( &dbutil );
	return err;
	}
#endif


//	callback function used by CopyFileEx
LOCAL DWORD CALLBACK DwEDBUTILCopyProgressRoutine(
	LARGE_INTEGER	cTotalFileSize,          // file size
	LARGE_INTEGER	cTotalBytesTransferred,  // bytes transferred
	LARGE_INTEGER	cStreamSize,             // bytes in stream
	LARGE_INTEGER	cStreamBytesTransferred, // bytes transferred for stream
	DWORD			dwStreamNumber,			// current stream
	DWORD			dwCallbackReason,		// callback reason
	HANDLE			hSourceFile,			// handle to source file
	HANDLE			hDestinationFile,		// handle to destination file
	INT				*pcShift				// from CopyFileEx. How much to shift file size to fit in INT value
)
	{
	enum { LITOI_LOW = 1, LITOI_HIGH, LITOI_SHIFT };
	//	zero sized file?
	if ( 0 == cTotalFileSize.QuadPart )
		{
		return PROGRESS_CONTINUE;
		}
	JET_SNPROG snpprog;
	assert( NULL != pcShift );
	if ( -1 == *pcShift )
		{ 
		PrintStatus( 0, -1, JET_sntBegin, (void *)szCopyFileStatus );
		assert( sizeof( ULONG ) == sizeof( INT ) );
		assert( sizeof( LARGE_INTEGER ) > sizeof( INT ) );
		//  if all data fits in INT value
		if ( 0 == (ULONG)cTotalFileSize.HighPart )
			{
			*pcShift = LITOI_LOW;
			}
		//  if High part can be used as 1% change detector
		else if ( 100 <= (ULONG)cTotalFileSize.HighPart )
			{
			*pcShift = LITOI_HIGH;
			}
		else
			{
			*pcShift = LITOI_SHIFT;
			}
		}
	snpprog.cbStruct = sizeof( snpprog );
	switch ( *pcShift )
		{
		//  if all data fits in INT value
		case LITOI_LOW:
			assert( 0 == cTotalFileSize.HighPart );
			snpprog.cunitTotal = cTotalFileSize.LowPart;
			snpprog.cunitDone = cTotalBytesTransferred.LowPart;
			break;
		//  if High part can be used as 1% change detector
		case LITOI_HIGH:
			assert( 100 <= cTotalFileSize.HighPart );
			snpprog.cunitTotal = cTotalFileSize.HighPart;
			snpprog.cunitDone = cTotalBytesTransferred.HighPart;
			break;
		//  if none of the above shift it 7 times because 2^7 > 100 and it will move 
		//	all High Part data to Low Part
		case LITOI_SHIFT:
			assert( 100 > cTotalFileSize.HighPart && 0 < cTotalFileSize.HighPart );
			snpprog.cunitTotal = (INT)( cTotalFileSize.QuadPart >> 7 );
			snpprog.cunitDone = (INT)( cTotalBytesTransferred.QuadPart >> 7 );
			break;
		default:
			assert( fFalse );
		}
	if ( cTotalBytesTransferred.QuadPart == cTotalFileSize.QuadPart )
		{
		PrintStatus( 0, -1, JET_sntComplete, &snpprog );
		}
	else
		{
		PrintStatus( 0, -1, JET_sntProgress, &snpprog );
		}
	return PROGRESS_CONTINUE;
	}

LOCAL JET_ERR ErrEDBUTLMoveFile(
	const char * const szExistingFileName,  // file name
	const char * const szNewFileName,       // new file name
	const DWORD dwFlags )
	{
	printf( szMoveFile, szExistingFileName, szNewFileName );
	if ( !MoveFileEx( szExistingFileName, szNewFileName, dwFlags ) )
		{
		DWORD dw = GetLastError();
		
		if ( ( dwFlags & ~MOVEFILE_REPLACE_EXISTING ) != 0 )
			{
			// unsupported move flag
			assert( fFalse );
			printf( "%s%c", szMoveFailed, cNewLine );
			return JET_errFileAccessDenied;
			}

		if ( dw == ERROR_CALL_NOT_IMPLEMENTED )
			{
			//	MoveFileEx is not implemented in Win9x
			dw = 0;
			if ( dwFlags & MOVEFILE_REPLACE_EXISTING )
				{
				DeleteFile( szNewFileName );
				}
			if ( !MoveFile( szExistingFileName, szNewFileName ) )
				{
				dw = GetLastError();
				if ( dw == ERROR_NOT_SAME_DEVICE )
					{
					//	the source file is on a different device -- we must copy it instead
					dw = 0;
					printf( szCopyFile );
					if ( !CopyFile( szExistingFileName, szNewFileName, ( dwFlags & MOVEFILE_REPLACE_EXISTING ? FALSE : TRUE ) ) )
						{
						dw = GetLastError();
						}
					}
				}
			}
		else if ( dw == ERROR_NOT_SAME_DEVICE )
			{
			typedef WINBASEAPI BOOL WINAPI PFNCopyFileEx( LPCTSTR, LPCTSTR, LPPROGRESS_ROUTINE, LPVOID, LPBOOL, DWORD );

#ifdef UNICODE
			PFNCopyFileEx*	pfnCopyFileEx = (PFNCopyFileEx*)GetProcAddress( GetModuleHandle( _T( "kernel32.dll" ) ), _T( "CopyFileExW" ) );
#else  //  !UNICODE
			PFNCopyFileEx*	pfnCopyFileEx = (PFNCopyFileEx*)GetProcAddress( GetModuleHandle( _T( "kernel32.dll" ) ), _T( "CopyFileExA" ) );
#endif  //  UNICODE

			//	the source file is on a different device -- we must copy it instead
			BOOL		fCancel		= fFalse;
			INT			cShift		= -1;		// used from progress routine
			const BOOL	fSuccess	= (	pfnCopyFileEx &&
										pfnCopyFileEx(	szExistingFileName,
														szNewFileName,
														LPPROGRESS_ROUTINE( DwEDBUTILCopyProgressRoutine ),
														&cShift,
														&fCancel,
														(	dwFlags & MOVEFILE_REPLACE_EXISTING ?
																0 :
																COPY_FILE_FAIL_IF_EXISTS ) ) );
			return ( fSuccess ? JET_errSuccess : JET_errFileAccessDenied );
			}
			
		if ( dw != 0 )
			{
			printf( "%s%c", szMoveFailed, cNewLine );
			return JET_errFileAccessDenied;
			}
		}

	printf( "%s%c", szMoveDone, cNewLine );
	return JET_errSuccess;
	}


LOCAL VOID EDBUTLDeleteTemp( const UTILOPTS * const popts )
	{
	assert( NULL != popts->szTempDB );
	DeleteFile( popts->szTempDB);
	if ( NULL != popts->szTempSLV )
		{
		DeleteFile( popts->szTempSLV );
		}
	}

// Backs up source database if required, then copies temporary database over
// source database if required.  Should be called after Jet has terminated.	
LOCAL JET_ERR ErrEDBUTLBackupAndInstateDB(
	JET_SESID	sesid,
	UTILOPTS	*popts )
	{
	JET_ERR		err = JET_errSuccess;;

	assert( popts->szSourceDB != NULL );
	assert( popts->szTempDB != NULL );

	// backup/instate cannot be respected on in-place upgrade.

	if ( FUTILOPTSInPlaceUpgrade( popts->fUTILOPTSFlags ) )
		{
		return JET_errSuccess;
		}

	//	BUGFIX (X5:123014): upgrade from 8.3 to full filename
	
	_TCHAR	szSourceDB[_MAX_PATH+1];
	_TCHAR	szSourceSLV[_MAX_PATH+1];

	WIN32_FIND_DATA wfd;
	HANDLE 			hFind;
		
	hFind = FindFirstFile( popts->szSourceDB, &wfd );
	if( INVALID_HANDLE_VALUE != hFind )
		{
		_TCHAR	szDrive[_MAX_PATH+1];
		_TCHAR	szDir[_MAX_PATH+1];
		
		_tsplitpath( popts->szSourceDB, szDrive, szDir, NULL, NULL );
		_makepath( szSourceDB, szDrive, szDir, NULL, NULL );
		_tcscat( szSourceDB, wfd.cFileName );
		FindClose( hFind );
		}
	else
		{
		_tcscpy( szSourceDB, popts->szSourceDB );
		}

	if ( !FUTILOPTSDefragSLVDontCopy( popts->fUTILOPTSFlags ) )
		{
		assert( NULL != popts->szSourceSLV );
		assert( NULL != popts->szTempSLV );
		
		hFind = FindFirstFile( popts->szSourceSLV, &wfd );
		if( INVALID_HANDLE_VALUE != hFind )
			{
			_TCHAR	szDrive[_MAX_PATH+1];
			_TCHAR	szDir[_MAX_PATH+1];
		
			_tsplitpath( popts->szSourceSLV, szDrive, szDir, NULL, NULL );
			_makepath( szSourceSLV, szDrive, szDir, NULL, NULL );
			_tcscat( szSourceSLV, wfd.cFileName );
			FindClose( hFind );
			}
		else
			{
			_tcscpy( szSourceSLV, popts->szSourceSLV );
			}
		}


	// Make backup before instating, if requested.

	if ( popts->szBackup != NULL )
		{
		err = ErrEDBUTLMoveFile( szSourceDB, popts->szBackup, 0 );
		if ( err < 0 )
			{
			printf( szErr4, popts->szBackup );
			printf( "%c%c", cNewLine, cNewLine );
			Call( err );
			}
		if ( !FUTILOPTSDefragSLVDontCopy( popts->fUTILOPTSFlags ) )
			{
			_TCHAR	szBackupSLV[_MAX_PATH+1];

			EDBUTLGetSLVNameFromDbName( popts->szBackup, szBackupSLV );
			err = ErrEDBUTLMoveFile( szSourceSLV, szBackupSLV, 0 );
			if ( err < 0 )
				{
				printf( szErr4, popts->szBackup );
				printf( "%c%c", cNewLine, cNewLine );
				Call( err );
				}
			}
		}

	if ( !FUTILOPTSPreserveTempDB( popts->fUTILOPTSFlags ) )
		{
		err = ErrEDBUTLMoveFile( popts->szTempDB, szSourceDB, MOVEFILE_REPLACE_EXISTING );
		if ( err < 0 )
			{
			printf( szErr5, szSourceDB, popts->szTempDB, szSourceDB );
			printf( "%c%c", cNewLine, cNewLine );
			Call( err );
			}
		if ( !FUTILOPTSDefragSLVDontCopy( popts->fUTILOPTSFlags ) )
			{
			err = ErrEDBUTLMoveFile( popts->szTempSLV, szSourceSLV, MOVEFILE_REPLACE_EXISTING );
			if ( err < 0 )
				{
				printf( szErr5, szSourceSLV, popts->szTempSLV, szSourceSLV );
				printf( "%c%c", cNewLine, cNewLine );
				Call( err );
				}
			}
		// Delete temporary database only if everything was successful.			
		EDBUTLDeleteTemp( popts );
		}

HandleError:
	return err;
	}


// Load registry environment, if enabled.  Then load command-line overrides.
LOCAL JET_ERR ErrEDBUTLUserSystemParameters( JET_INSTANCE *pinstance, UTILOPTS *popts )
	{
	JET_ERR	err;

	// Facilitate debugging.
	Call( JetSetSystemParameter( pinstance, 0, JET_paramAssertAction, JET_AssertMsgBox, NULL ) );

	// Command-line parameters override all default and registry values.
	if ( popts->szLogfilePath != NULL )
		{
		Call( JetSetSystemParameter( pinstance, 0, JET_paramLogFilePath, 0, popts->szLogfilePath ) );
		}
	if ( popts->szSystemPath != NULL )
		{
		Call( JetSetSystemParameter( pinstance, 0, JET_paramSystemPath, 0, popts->szSystemPath ) );
		}
	if ( popts->cpageBuffers != 0 )
		{
#if 0	// no longer needed because of DBA
		unsigned long ulCacheSizeMax;
		Call( JetGetSystemParameter( *pinstance, 0, JET_paramCacheSizeMax, &ulCacheSizeMax, NULL, 0 ) );
		if ( (long)ulCacheSizeMax < popts->cpageBuffers )
			{
			Call( JetSetSystemParameter( pinstance, 0, JET_paramCacheSizeMax, popts->cpageBuffers, NULL ) );
			Call( JetSetSystemParameter( pinstance, 0, JET_paramStopFlushThreshold, popts->cpageBuffers, NULL ) );
			Call( JetSetSystemParameter( pinstance, 0, JET_paramStartFlushThreshold, popts->cpageBuffers * 1 / 100, NULL ) );
			Call( JetSetSystemParameter( pinstance, 0, JET_paramStopFlushThreshold, popts->cpageBuffers * 10 / 100, NULL ) );
			}
		else
			{
			Call( JetSetSystemParameter( pinstance, 0, JET_paramStartFlushThreshold, 1, NULL ) );
			Call( JetSetSystemParameter( pinstance, 0, JET_paramStopFlushThreshold, popts->cpageBuffers * 10 / 100, NULL ) );
			Call( JetSetSystemParameter( pinstance, 0, JET_paramStartFlushThreshold, popts->cpageBuffers * 1 / 100, NULL ) );
			Call( JetSetSystemParameter( pinstance, 0, JET_paramCacheSizeMax, popts->cpageBuffers, NULL ) );
			}
#endif	//	0
		}
	if ( popts->cpageBatchIO != 0 )
		{
		Call( JetSetSystemParameter( pinstance, 0, JET_paramBatchIOBufferMax, popts->cpageBatchIO * 4, NULL ) );
		}
	if ( popts->cpageDbExtension != 0 )
		{
		Call( JetSetSystemParameter( pinstance, 0, JET_paramDbExtensionSize, popts->cpageDbExtension, NULL ) );
		}

	if ( NULL != popts->szBase )
		{
		Call( JetSetSystemParameter( pinstance, 0, JET_paramBaseName, NULL, popts->szBase ) );
		}
HandleError:
	return err;
	}


// Teminate Jet, either normally or abnormally.
LOCAL JET_ERR ErrEDBUTLCleanup( JET_INSTANCE instance, JET_SESID sesid, JET_ERR err )
	{
	if ( 0 != sesid && JET_sesidNil != sesid )
		{
		JET_ERR	errT = JetEndSession( sesid, 0 );

		if ( err >= 0 )
			err = errT;
		}

	if ( err < 0 ) 
		{
		// On error, terminate abruptly and throw out return code from JetTerm2().
		JetTerm2( instance, JET_bitTermAbrupt );
		}
	else 
		{
		err = JetTerm2( instance, JET_bitTermComplete );
		}

	return err;
	}


LOCAL BOOL FAquireBackupRestoreRights()
{

   BOOL		ret_val = TRUE ;
   HANDLE 	ProcessHandle;
   DWORD  	DesiredAccess;
   HANDLE 	TokenHandle;
   LUID   	BackupValue;
   LUID   	RestoreValue;
   TOKEN_PRIVILEGES NewState;


   // get process handle

   ProcessHandle = GetCurrentProcess();

   // open process token

   DesiredAccess = MAXIMUM_ALLOWED;

   if ( ! OpenProcessToken( ProcessHandle, DesiredAccess, &TokenHandle ) ) {
      return FALSE;
   }

   // adjust backup token privileges
   if ( ! LookupPrivilegeValue( NULL, TEXT("SeRestorePrivilege"), &RestoreValue ) ) {
      ret_val = FALSE;
   }

   if ( ! LookupPrivilegeValue( NULL, TEXT("SeBackupPrivilege"), &BackupValue ) ) {
      ret_val = FALSE;
   }

   // Enable backup privilege for this process

   NewState.PrivilegeCount = 1;
   NewState.Privileges[0].Luid = BackupValue;
   NewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

   if ( ! AdjustTokenPrivileges( TokenHandle, FALSE, &NewState, (DWORD)0, NULL, NULL ) ) {
      ret_val = FALSE;
   }


   NewState.PrivilegeCount = 1;
   NewState.Privileges[0].Luid = RestoreValue;
   NewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

   if ( ! AdjustTokenPrivileges( TokenHandle, FALSE, &NewState, (DWORD)0, NULL, NULL ) ) {
      ret_val = FALSE;
   }
// AdjustTokenPriv always returns SUCCESS, call GetLast to see if it worked.

   if ( GetLastError() != ERROR_SUCCESS ) {
      ret_val = FALSE;
   }

   // close process token

   CloseHandle( TokenHandle );
   return( ret_val );
}

#define JET_errReturnedForESEBCLI2		JET_errInternalError
#define JET_errReturnedForESEBACK2		JET_errInternalError

#define CallHr( func )									\
	{ 													\
	hr = func; 											\
	hrGLE = GetLastError(); 							\
	if ( hrNone != hr ) 								\
		{												\
		goto HandleError;								\
		}												\
	}

unsigned long WszFromSzGetSize( const char * sz )
	{
	return MultiByteToWideChar(CP_OEMCP, 0, sz, -1, NULL, 0);
	}

WCHAR * WszFromSz( const char *  sz )
	{
	WCHAR *  wsz;
	long cw;

	if ( 0 == ( cw = WszFromSzGetSize(sz) ) )
		return(NULL);

	if ( ( wsz = (WCHAR *) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, cw * sizeof(WCHAR) ) ) == NULL )
		return(NULL);

	if ( MultiByteToWideChar(CP_OEMCP, 0, sz, -1, wsz, cw ) == 0 )
		{
		LocalFree(wsz);
		return(NULL);
		}

	return(wsz);
	}

WCHAR * WszCopy( const WCHAR *  wsz )
	{
	WCHAR *  wszCopy;
	long cw;

	assert ( wsz );
	cw = (ULONG)wcslen( wsz ) + 1;

	if ( ( wszCopy = (WCHAR *) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, cw * sizeof(WCHAR) ) ) == NULL )
		return(NULL);

	wcscpy ( wszCopy, wsz );
	return( wszCopy );
	}


void PrintESEBCLI2Error ( HRESULT hr, HRESULT hrGLE, HMODULE hESEBCLI2 )
	{		
	LPVOID 		lpMsgBuf 				= NULL;
	char *		szFinalMsg 				= NULL;

	if ( hrNone == hr )
		return;
		
	if ( 0 == FormatMessage( 
			    FORMAT_MESSAGE_FROM_HMODULE | 
			    FORMAT_MESSAGE_FROM_SYSTEM | 
			    FORMAT_MESSAGE_IGNORE_INSERTS |
		    	FORMAT_MESSAGE_ALLOCATE_BUFFER,
			    hESEBCLI2,
			    hr,
			    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			    (LPTSTR) &lpMsgBuf,
		    	0,
			    NULL ) )
	    {
		lpMsgBuf = NULL;
	    }

	if ( lpMsgBuf )
		{
		if ( hr == hrErrorFromESECall || hr == hrErrorFromCallbackCall )
			{
			szFinalMsg = (char *) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,	sizeof( char ) * ( strlen( (char *)lpMsgBuf ) + 1 ) + 32 );
			if ( szFinalMsg )						
				{
				sprintf( szFinalMsg, (char *) lpMsgBuf, hrGLE );
				LocalFree( lpMsgBuf );	
				}
			else
				{
				// print the message without error number
				szFinalMsg = (char *)lpMsgBuf;
				}				
			}
		else
			{
			szFinalMsg = (char *)lpMsgBuf;
			}
			
		printf( szFinalMsg );
		LocalFree ( szFinalMsg );		
		}
	}

typedef HRESULT (ESEBACK_API * PfnHrESERestoreReopen)(
	IN  WCHAR *					wszServerName,
	IN  WCHAR *					wszServiceAnnotation,
	IN  WCHAR *		 			wszRestoreLogPath,
	OUT HCCX *					phccxRestoreContext);
	
typedef HRESULT (ESEBACK_API * PfnHrESERestoreClose)(
	IN HCCX hccxRestoreContext,
	IN unsigned long fRestoreAbort);

typedef HRESULT (ESEBACK_API * PfnHrESERestoreComplete)(
	IN  HCCX 				hccxRestoreContext,
	IN  WCHAR *				wszRestoreInstanceSystemPath,
	IN  WCHAR *				wszRestoreInstanceLogPath,
	IN  WCHAR *				wszTargetInstanceName,
	IN  unsigned long 		fFlags);

typedef HRESULT (ESEBACK_API * PfnHrESERestoreLoadEnvironment)(
	IN	WCHAR *				wszServerName,
	IN	WCHAR *				wszRestoreLogPath,
	OUT RESTORE_ENVIRONMENT ** 	ppRestoreEnvironment);

typedef HRESULT (ESEBACK_API * PfnHrESERestoreGetEnvironment)(
	IN  HCCX 					hccxRestoreContext,
	OUT RESTORE_ENVIRONMENT ** 	ppRestoreEnvironment);

typedef void (ESEBACK_API * PfnESERestoreFreeEnvironment)(
	IN  RESTORE_ENVIRONMENT * 	pRestoreEnvironment);

LOCAL void PrintField( const WCHAR * wszDesc, int cDesc, const WCHAR * wszData, const BOOL fNewLine = TRUE )
	{
	wprintf( L"%*s %s%s", cDesc, wszDesc, wszData?wszData:L"", fNewLine?L"\n":L"" );
	}

WCHAR * rwszRecoverStatus[] = { 
	L"recoverInvalid",
	L"recoverNotStarted",
	L"recoverStarted",
	L"recoverEnded"
	};


LOCAL BOOL FDBUTLLoadLibrary( const _TCHAR* szLibrary, HMODULE *plibrary )
	{
	while ( NULL == ( *plibrary = LoadLibrary( (LPTSTR)szLibrary ) ) )
		{		
		_TCHAR szMessage[256];
		(void)_stprintf(
			szMessage,
			_T( 	"Unable to find the callback library %s (or one of its dependencies).\r\n"
					"Copy in the file and hit OK to retry, or hit Cancel to abort.\r\n" ),
			szLibrary );

		const int id = MessageBox(
							NULL,
							szMessage,
							_T( "Callback DLL not found" ),
							MB_SERVICE_NOTIFICATION | MB_SYSTEMMODAL | MB_ICONSTOP |
							MB_OKCANCEL );

		if ( IDOK != id )
			{
			break;
			}
		}
		
	return ( NULL != *plibrary );
	}


LOCAL JET_ERR ErrDBUTLDumpRestoreEnv( const char * szRestorePath )
	{
	JET_ERR			err 				= JET_errSuccess;
	HRESULT 		hr 					= hrNone;
	HRESULT 		hrGLE 				= hrNone;
	WCHAR * 		wszRestorePath 		= NULL;
	HMODULE 		hESEBCLI2 			= NULL;	
	int 			cDesc 				= 30;

	RESTORE_ENVIRONMENT * 				pREnv 					= NULL;
	PfnHrESERestoreLoadEnvironment 		pfnHrESERestoreLoadEnv 	= NULL;
	PfnESERestoreFreeEnvironment 		pfnESERestoreFreeEnv 	= NULL;

	unsigned long 	iDb;

	assert ( szRestorePath );

	if ( !FDBUTLLoadLibrary( ESEBCLI2_DLL_NAME, &hESEBCLI2 ) )
		{
		Call ( JET_errCallbackNotResolved );
		}

	pfnHrESERestoreLoadEnv = (PfnHrESERestoreLoadEnvironment) GetProcAddress( hESEBCLI2, "HrESERestoreLoadEnvironment" );
	pfnESERestoreFreeEnv = (PfnESERestoreFreeEnvironment) GetProcAddress( hESEBCLI2, "ESERestoreFreeEnvironment" );

	if ( !pfnESERestoreFreeEnv || !pfnHrESERestoreLoadEnv )
		{
		Call ( JET_errCallbackNotResolved );
		}
			
	wszRestorePath = WszFromSz( szRestorePath );
	if ( !wszRestorePath )
		{
		Call ( JET_errOutOfMemory );
		}
		
	PrintField( L"Restore log file:", cDesc, wszRestorePath );
	PrintField( L"", cDesc, NULL );

	assert ( pfnHrESERestoreLoadEnv );
	CallHr ( (*pfnHrESERestoreLoadEnv)( 	NULL,
											wszRestorePath,
											&pREnv ) );

	// dump Restore.Env
	assert ( pREnv );

	PrintField( L"Restore Path:", cDesc, pREnv->m_wszRestoreLogPath );
	PrintField( L"Annotation:", cDesc, pREnv->m_wszAnnotation );	

	PrintField( L"Backup Instance:", cDesc, pREnv->m_wszSrcInstanceName );
	PrintField( L"Target Instance:", cDesc, pREnv->m_wszTargetInstanceName );

	PrintField( L"Restore Instance System Path:", cDesc, pREnv->m_wszRestoreInstanceSystemPath );
	PrintField( L"Restore Instance Log Path:", cDesc, pREnv->m_wszRestoreInstanceLogPath );

	PrintField( L"", cDesc, NULL );

	{
	WCHAR wszBuffer[32];
	swprintf( wszBuffer, L"%d database(s)", pREnv->m_cDatabases );
	PrintField( L"Databases:", cDesc, wszBuffer );
	}

	assert ( pREnv->m_wszDatabaseDisplayName || 0 == pREnv->m_cDatabases);
	assert ( pREnv->m_rguidDatabase || 0 == pREnv->m_cDatabases);
	assert ( pREnv->m_wszDatabaseStreamsS || 0 == pREnv->m_cDatabases);
	assert ( pREnv->m_wszDatabaseStreamsD || 0 == pREnv->m_cDatabases);

	cDesc += 8;
	for (iDb = 0; iDb < pREnv->m_cDatabases; iDb++)
		{		
		assert ( pREnv->m_wszDatabaseDisplayName[iDb] );
		assert ( pREnv->m_wszDatabaseStreamsS[iDb] );
		assert ( pREnv->m_wszDatabaseStreamsS[iDb] );

		WCHAR guidStr[256];
		WCHAR * wszStreams;
		GUID guid = pREnv->m_rguidDatabase[iDb];
		
		PrintField( L"Database Name:", cDesc, pREnv->m_wszDatabaseDisplayName[iDb] );
		// like: 6B29FC40-CA47-1067-B31D-00DD010662DA
		swprintf(	guidStr,
					L"%08X-%04X-%04X-%08X%08X",
					guid.Data1, guid.Data2, guid.Data3,
					*(DWORD *)&guid.Data3,*( 1 + (DWORD *)&guid.Data3 ) );

		PrintField( L"GUID:", cDesc, guidStr );

		wszStreams = pREnv->m_wszDatabaseStreamsS[iDb];
		PrintField( L"Source Files:", cDesc, NULL, FALSE );
		while ( L'\0' != wszStreams[0] )
			{
			wprintf( L"%s ", wszStreams );
			wszStreams += wcslen( wszStreams ) + 1;
			}
		wprintf( L"\n" );
		wszStreams = pREnv->m_wszDatabaseStreamsD[iDb];
		PrintField( L"Destination Files:", cDesc, NULL, FALSE );
		while ( L'\0' != wszStreams[0] )
			{
			wprintf( L"%s ", wszStreams );
			wszStreams += wcslen( wszStreams ) + 1;
			}
		PrintField( L"", cDesc, NULL );
		PrintField( L"", cDesc, NULL );
		}
		
	cDesc -= 8;
	PrintField( L"", cDesc, NULL );
	PrintField( L"", cDesc, NULL );
		
	{
	WCHAR wszBuffer[32];
	
	if ( pREnv->m_wszLogBaseName )
		{
		assert ( 0 != pREnv->m_ulGenLow );
		assert ( 0 != pREnv->m_ulGenHigh );
		assert ( pREnv->m_ulGenLow <= pREnv->m_ulGenHigh );
		swprintf( wszBuffer, L"%s%05X.log - %s%05X.log", 
			pREnv->m_wszLogBaseName,
			pREnv->m_ulGenLow,
			pREnv->m_wszLogBaseName,
			pREnv->m_ulGenHigh);
		}
	else
		{
		assert ( 0 == pREnv->m_ulGenLow );
		assert ( 0 == pREnv->m_ulGenHigh );
		swprintf( wszBuffer, L"no log files restored");
		}
	PrintField( L"Log files range:", cDesc, wszBuffer );
	
	PrintField( L"Last Restore Time:", cDesc, _wctime ( &pREnv->m_timeLastRestore) );

	RECOVER_STATUS status = pREnv->m_statusLastRecover;

	if ( status >= sizeof(rwszRecoverStatus)/ sizeof(rwszRecoverStatus[0] ) )
		status = recoverInvalid;
		
	PrintField( L"Recover Status:", cDesc, rwszRecoverStatus [ status ] );

	swprintf( wszBuffer, L"0x%08X", pREnv->m_hrLastRecover);
	PrintField( L"Recover Error:", cDesc, wszBuffer );
	
	PrintField( L"Recover Time:", cDesc, _wctime ( &pREnv->m_timeLastRecover ) );
	}

											
HandleError:

	LocalFree ( wszRestorePath );

	if ( pREnv )
		{
		assert ( pfnESERestoreFreeEnv );
		(*pfnESERestoreFreeEnv)( pREnv );
		pREnv = NULL;
		}

	if ( hrNone != hr )
		{
		assert ( hESEBCLI2 );
		PrintESEBCLI2Error ( hr, hrGLE, hESEBCLI2 );
		err = JET_errReturnedForESEBCLI2;
		}
	
	if ( NULL != hESEBCLI2 )
		{
		FreeLibrary( hESEBCLI2 );
		hESEBCLI2 = NULL;
		}

	return err;	
	}

LOCAL JET_ERR ErrDBUTLRestoreComplete( const char * szFullRestorePath, const char * szTargetInstance, BOOL fKeepLogs )
	{
	JET_ERR			err 				= JET_errSuccess;
	HRESULT 		hr 					= hrNone;
	HRESULT 		hrGLE;

	WCHAR * 		wszRestorePath 		= NULL;
	WCHAR * 		wszTargetInstance 	= NULL;
	WCHAR * 		wszComputerName 	= NULL;
	
	DWORD 			nSize ;
	char 			szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	
	HCCX 			hccxRestoreContext 	= NULL;	

	HMODULE 		hESEBCLI2 = NULL;
	
	PfnHrESERestoreReopen 				pfnErrESERestoreReopen =	 NULL;
	PfnHrESERestoreClose 				pfnErrESERestoreClose 		= NULL;
	PfnHrESERestoreComplete 			pfnErrESERestoreComplete 	= NULL;

	RESTORE_ENVIRONMENT * 				pREnv 						= NULL;
	PfnHrESERestoreGetEnvironment 		pfnHrESERestoreGetEnv 		= NULL;
	PfnESERestoreFreeEnvironment 		pfnESERestoreFreeEnv 		= NULL;

	assert ( szFullRestorePath );
	
	if ( !FDBUTLLoadLibrary( ESEBCLI2_DLL_NAME, &hESEBCLI2 ) )
		{
		Call ( JET_errCallbackNotResolved );
		}

	pfnErrESERestoreReopen = (PfnHrESERestoreReopen) GetProcAddress( hESEBCLI2, "HrESERestoreReopen" );
	pfnErrESERestoreClose = (PfnHrESERestoreClose) GetProcAddress( hESEBCLI2, "HrESERestoreClose" );
	pfnErrESERestoreComplete = (PfnHrESERestoreComplete) GetProcAddress( hESEBCLI2, "HrESERestoreComplete" );
	pfnHrESERestoreGetEnv = (PfnHrESERestoreGetEnvironment) GetProcAddress( hESEBCLI2, "HrESERestoreGetEnvironment" );
	pfnESERestoreFreeEnv = (PfnESERestoreFreeEnvironment) GetProcAddress( hESEBCLI2, "ESERestoreFreeEnvironment" );

	if ( 	!pfnErrESERestoreReopen || !pfnErrESERestoreClose || !pfnErrESERestoreComplete ||
			!pfnHrESERestoreGetEnv || !pfnESERestoreFreeEnv)
		{
		Call ( JET_errCallbackNotResolved );
		}

	if ( !FAquireBackupRestoreRights() )
		{
		Call ( JET_errReturnedForESEBCLI2 ); 
		}

	nSize = sizeof(szComputerName);		
	if ( !GetComputerName ( szComputerName, &nSize ) )
		{
		Call ( JET_errNTSystemCallFailed );
		}
	
	wszRestorePath = WszFromSz( szFullRestorePath );
	wszComputerName = WszFromSz( szComputerName );

	if ( !wszRestorePath || !wszComputerName )
		{
		Call ( JET_errOutOfMemory );
		}
		
	printf( "Restore log files: %s\n", szFullRestorePath );

	assert ( pfnErrESERestoreReopen );
	CallHr ( (*pfnErrESERestoreReopen)( 	wszComputerName,
											NULL,
											wszRestorePath,
											&hccxRestoreContext ) );
	
	if ( szTargetInstance )
		{
		if ( szTargetInstance[0] == '\0' )
			{
			// no play forward 
			wszTargetInstance = NULL;
			}
		else
			{
			wszTargetInstance = WszFromSz( szTargetInstance );
			if ( !wszTargetInstance )
				{
				Call ( JET_errOutOfMemory );
				}
			}
		}
	else
		{
		// get the instance form the Restore.Env, as the Source Instance Name
		assert ( pfnHrESERestoreGetEnv );
		CallHr ( (*pfnHrESERestoreGetEnv)( 	hccxRestoreContext,
											&pREnv ) );

		// dump Restore.Env
		assert ( pREnv );
		assert ( pREnv->m_wszSrcInstanceName );
		wszTargetInstance = WszCopy( pREnv->m_wszSrcInstanceName );

		assert ( pfnESERestoreFreeEnv );
		(*pfnESERestoreFreeEnv)( pREnv );
		pREnv = NULL;

		if ( !wszTargetInstance )
			{
			Call ( JET_errOutOfMemory );
			}
		}
		
	wprintf( L"  Target Instance: %s\n", wszTargetInstance?wszTargetInstance:L"" );
	
	assert ( pfnErrESERestoreComplete );
	CallHr ( (*pfnErrESERestoreComplete)( 	hccxRestoreContext,
									wszRestorePath,
									wszRestorePath,
									wszTargetInstance,
									fKeepLogs?ESE_RESTORE_KEEP_LOG_FILES:0 // no db mount, wait restore complete
									) );	
									
HandleError:

	LocalFree ( wszRestorePath );
	LocalFree ( wszTargetInstance );
	LocalFree ( wszComputerName );

	if ( pREnv )
		{
		assert ( pfnESERestoreFreeEnv );
		(*pfnESERestoreFreeEnv)( pREnv );
		pREnv = NULL;
		}

	if ( hccxRestoreContext )
		{
		assert ( pfnErrESERestoreClose );
		(void) (*pfnErrESERestoreClose)( hccxRestoreContext, (hrNone == hr) ? RESTORE_CLOSE_NORMAL:RESTORE_CLOSE_ABORT );
		hccxRestoreContext = NULL;
		}

	if ( hrNone != hr )
		{
		assert ( hESEBCLI2 );
		PrintESEBCLI2Error ( hr, hrGLE, hESEBCLI2 );
		err = JET_errReturnedForESEBCLI2;
		}
	
	if ( NULL != hESEBCLI2 )
		{
		FreeLibrary( hESEBCLI2 );
		hESEBCLI2 = NULL;
		}

	return err;
	}

#ifdef RESTORE_SERVER_SIMULATION

// must match the definition from ESEBACK2\srvsim.cxx
typedef HRESULT (__stdcall * PfnServerSim)( const char * szFileDef );

LOCAL JET_ERR ErrDBUTLServerSim( const char * szSimulationDef )
	{
	JET_ERR			err 			= JET_errSuccess;
	HRESULT 		hr 				= hrNone;
	HRESULT 		hrGLE;
	HMODULE 		hESEBACK2 		= NULL;
	PfnServerSim 	pfnServerSim 	= NULL;

	if ( !FDBUTLLoadLibrary( ESEBACK2_DLL_NAME, &hESEBACK2 ) )
		{
		Call ( JET_errCallbackNotResolved );
		}

	pfnServerSim = (PfnServerSim) GetProcAddress( hESEBACK2, "ServerSim" );
	if ( !pfnServerSim )
		{
		Call ( JET_errCallbackNotResolved );
		}

	CallHr ( (*pfnServerSim)( szSimulationDef ) );
	
HandleError:

	if ( hrNone != hr )
		{
		assert ( hESEBACK2 );
		PrintESEBCLI2Error ( hr, hrGLE, hESEBACK2 );
		err = JET_errReturnedForESEBACK2;
		}

	if ( NULL != hESEBACK2 )
		{
		FreeLibrary( hESEBACK2 );
		hESEBACK2 = NULL;
		}

	return err;
	
	}

#endif // RESTORE_SERVER_SIMULATION

int _cdecl main( int argc, char *argv[] )
	{
	JET_INSTANCE	instance			= 0;
	JET_SESID		sesid				= JET_sesidNil;
	JET_ERR			err					= JET_errSuccess;
	JET_ERR			errRepaired			= JET_errSuccess;
	BOOL			fResult				= fTrue;
	UTILOPTS		opts;
	JET_CONVERT		convert;
	JET_DBUTIL		dbutil;
	ULONG			timer				= GetTickCount();
	INT				iSec, iMSec;
	BOOL			fWhitespaceOnErr	= fFalse;
	BOOL			fUnknownError		= fFalse;

	InitArg( argc, argv );
	memset( &opts, 0, sizeof(UTILOPTS) );
	opts.lDirtyLevel = 2;
	memset( &dbutil, 0, sizeof(JET_DBUTIL) );
	dbutil.cbStruct	= sizeof( dbutil );
	
	printf( "%c", cNewLine );

	const INT pid = GetCurrentProcessId();
	
	if ( GetArgCount() < 2 )
		{
		printf( szUsageErr9 );
		printf( "%c%c", cNewLine, cNewLine );
		goto Usage;
		}

	SetCurArgID(1);
	assert( GetCurArgID() == 1 );
	if ( strchr( szSwitches, GetCurArg()[0] ) == NULL )
		{
		printf( szUsageErr10 );
		printf( "%c%c", cNewLine, cNewLine );
		goto Usage;
		}

	sprintf( szDefaultTempDB, szDefaultTempDBFormat, pid );
	sprintf( szDefaultDefragDB, szDefaultDefragDBFormat, pid );
	sprintf( szDefaultUpgradeDB, szDefaultUpgradeDBFormat, pid );
	sprintf( szDefaultRepairDB, szDefaultRepairDBFormat, pid );
	sprintf( szDefaultIntegDB, szDefaultIntegDBFormat, pid );
	sprintf( szDefaultScrubDB, szDefaultScrubDBFormat, pid );

	assert( NULL == opts.pv );

	switch( GetCurArg()[1] )
		{
		case 'd':		// Defragment
		case 'D':
			opts.mode	= modeDefragment;
			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseDefragment );
			break;

		case 'r':		// Recovery
		case 'R':
			opts.mode = modeRecovery;
			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseRecovery );
			break;

		case 'g':		// inteGrity
		case 'G':
			opts.mode = modeIntegrity;
			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseIntegrity );
			break;

		case 'k':		// esefile - checksum
		case 'K':
			opts.mode = modeChecksum;
			fResult = FEDBUTLParseOptions( &opts, NULL );
			break;

		case 'p':		// rePair
		case 'P':
			opts.mode 	= modeRepair;
			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseRepair );
			break;

		case 'm':		// file duMp.
		case 'M':
			opts.mode = modeDump;
			opts.pv = &dbutil;

			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseDump );
			break;

#ifdef DEBUG
		case 'c':		// Hard Recovery (dump Restore.Env or/and RestoreComplete)
		case 'C':
			opts.mode = modeHardRecovery;
			opts.pv = &dbutil;

			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseHardRecovery );
			break;

		case 'b':		// Backup
		case 'B':
			opts.mode = modeBackup;
			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseBackup );
			break;

		case 's':
		case 'S':
			opts.mode 	= modeSLVMove;
			opts.pv 	= &dbutil;

			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseSLVMove );
			// db name and pgno are mandatory
			if ( NULL == opts.szSourceDB || 0 == dbutil.pgno )
				{
				fResult = fFalse;
				}
			dbutil.op = opDBUTILSLVMove;
			break;
#endif

#ifdef RECORD_FORMAT_UPGRADE
		case 'f':		// upgrade record Format
		case 'F':
			opts.mode 	= modeUpgradeRecordFormat;
			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseUpgradeRecordFormat );
			break;
#endif			

		case 'u':		// Upgrade/convert
		case 'U':
			opts.mode = modeUpgrade;
			memset( &convert, 0, sizeof(JET_CONVERT) );
			opts.pv = &convert;
			UTILOPTSSetDefragSLVDontCopy( opts.fUTILOPTSFlags );
			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseUpgrade );
			if ( fResult  &&  convert.szOldDll == NULL )
				{
				printf( szUsageErr11 );
				printf( "%c%c", cNewLine, cNewLine );
				fResult = fFalse;					
				}				
			break;		

		case 'z':		// Zero out deleted portions of the database
		case 'Z':
			opts.mode 	= modeScrub;
			fResult = FEDBUTLParseOptions( &opts, FEDBUTLParseScrub );
			break;

		case '?':
			goto Usage;			

#ifdef ESENT
#else
		case 'e':
		case 'E':
			if( !_strcmpi( argv[1]+1, "ese" ) )
				{
				opts.mode = modeSplash;
				break;
				}
#endif				

			//  else FALLTHRU
		default:
			printf( szUsageErr12 );
			printf( "%c%c", cNewLine, cNewLine );
			fResult = fFalse;
		}
		
	if ( !fResult )
		goto Usage;


	if( modeUpgrade == opts.mode ) 
		{
		Call( ErrUseDifferentDLL( _T( "ESENT97.DLL" ) ) );
		}

	Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "ESEUTIL" ) );

	//	generate a new temporary database name
	//	this may be overwritten later
	
	Call( JetSetSystemParameter( &instance, 0, JET_paramTempPath, 0, szDefaultTempDB ) );
	
	if ( !FUTILOPTSSuppressLogo( opts.fUTILOPTSFlags ) )
		{
		EDBUTLPrintLogo();
		}

	if ( FUTILOPTS8KPage( opts.fUTILOPTSFlags ) )
		{
		Call( JetSetSystemParameter( &instance, 0, JET_paramDatabasePageSize, 8192, NULL ) );
		}

	// Lights, cameras, action...
	timer = GetTickCount();

	switch ( opts.mode )
		{
		case modeRecovery:
			if ( NULL == opts.szBase )
				{
				printf( szUsageErr1, "logfile base name" );
				printf( "%c%c", cNewLine, cNewLine );
				Call( JET_errInvalidParameter );
				}

			printf( "Initiating RECOVERY mode...%c", cNewLine );
			printf( "    Logfile base name: %s%c", opts.szBase, cNewLine );

			if( 0 != opts.pageTempDBMin )
				{
				printf( "   Temp database size: %d%c", opts.pageTempDBMin, cNewLine );
				Call( JetSetSystemParameter( &instance, 0, JET_paramPageTempDBMin , opts.pageTempDBMin, NULL ) );
				}
			
			printf( "            Log files: %s%c", opts.szLogfilePath ? opts.szLogfilePath : "<current directory>", cNewLine );
			printf( "         System files: %s%c", opts.szSystemPath ? opts.szSystemPath : "<current directory>", cNewLine, cNewLine );

			if ( NULL != opts.szSourceDB )
				{
				//	HACK: Need some way of specifying an alternate database directory
				//	without having to expose a new system param
				printf( "   Database Directory: %s%c", opts.szSourceDB != szCurrDir ? opts.szSourceDB : "<current directory>", cNewLine, cNewLine );
				Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0xE5E, opts.szSourceDB ) );
				}

			Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "on" ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramCacheSizeMax, 500, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTables, 10000, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxCursors, 10000, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxSessions, 16, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxVerPages, 128, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxTemporaryTables, 10000, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramLogBuffers, 41, NULL ) );
			printf( "%c", cNewLine );

			// Set user overrides.
			Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

			if ( opts.szBackup == NULL )
				{
				
				// Soft recovery.
				fWhitespaceOnErr = fTrue;
				printf( "Performing soft recovery..." );
				err = JetInit2( &instance, opts.grbitInit );
				Call( ErrEDBUTLCleanup( instance, 0, err ) );
				printf( "%c%c", cNewLine, cNewLine );
				}
			else
				{

				// Hard recovery.

				if ( opts.szRestore )
					{
					printf( "Restoring to '%s' from '%s'...", opts.szRestore, opts.szBackup );
					}
				else
					{
					printf( "Restoring to <current directory> from '%s'...", opts.szBackup );
					}
				err = JetRestore2( opts.szBackup, opts.szRestore, PrintStatus );
				printf( "%c%c", cNewLine, cNewLine );
				Call( err );
				}
			break;
	
#ifdef DEBUG
		case modeBackup:

			Call( ErrEDBUTLCheckBackupPath( &opts ) );
			printf( "Initiating BACKUP mode...%c", cNewLine );
			printf( "       Log files: %s%c", opts.szLogfilePath ? opts.szLogfilePath : "<current directory>", cNewLine );
			printf( "    System files: %s%c%c", opts.szSystemPath ? opts.szSystemPath : "<current directory>", cNewLine, cNewLine );

			Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "on" ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramCacheSizeMax, 500, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTables, 10000, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxCursors, 10000, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxSessions, 16, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxVerPages, 128, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxTemporaryTables, 10000, NULL ) );
///			Call( JetSetSystemParameter( &instance, 0, JET_paramLogBuffers, 41, NULL ) );

			// Set user overrides.
			Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

			fWhitespaceOnErr = fTrue;
			if ( FUTILOPTSIncrBackup( opts.fUTILOPTSFlags ) )
				{
				printf( "Performing incremental backup..." );
				Call( JetInit( &instance ) );
				CallJ( JetBackup( opts.szBackup, JET_bitBackupIncremental | JET_bitBackupAtomic, NULL ), Cleanup );
				}
			else
				{
				printf( "Performing full backup..." );
				Call( JetInit( &instance ) );
				CallJ( JetBackup( opts.szBackup, JET_bitBackupAtomic, NULL ), Cleanup );
				}
			fWhitespaceOnErr = fFalse;

			printf( "%c%c", cNewLine, cNewLine );
			Call( ErrEDBUTLCleanup( instance, sesid, JET_errSuccess ) );
			break;
#endif

		case modeDefragment:
				{
				JET_GRBIT	grbitDefrag = 0;
				if( FUTILOPTSDefragInfo( opts.fUTILOPTSFlags ) )
					grbitDefrag |= JET_bitCompactStats;
				if( FUTILOPTSDefragRepair( opts.fUTILOPTSFlags ) )
					grbitDefrag |= JET_bitCompactRepair;
				if ( !FUTILOPTSDefragSLVDontCopy( opts.fUTILOPTSFlags ) )
					grbitDefrag |= JET_bitCompactSLVCopy;
				
				CallJ( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultDefragDB, szSourceStreamFileName, szTempStreamFileName ), Cleanup );

				//	there is no streaming file attached to database
				if ( NULL == opts.szSourceSLV )
					{
					UTILOPTSSetDefragSLVDontCopy( opts.fUTILOPTSFlags );
					grbitDefrag &= ~JET_bitCompactSLVCopy;
					}
				
				printf( "Initiating DEFRAGMENTATION mode...%c", cNewLine );
				printf( "            Database: %s%c", opts.szSourceDB, cNewLine );
				if( opts.szSourceSLV )
					{
					printf( "      Streaming File: %s%c", opts.szSourceSLV, cNewLine );
					}
				printf( "      Temp. Database: %s%c", opts.szTempDB, cNewLine );
				if( opts.szTempSLV )
					{
					printf( "Temp. Streaming File: %s%c", opts.szTempSLV, cNewLine );
					}

				fWhitespaceOnErr = fTrue;

				// Restart with logging/recovery disabled.
				Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "off" ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableOnlineDefrag, 0, NULL ) );
				ULONG_PTR cbfCacheMax;
				Call( JetGetSystemParameter( instance, 0, JET_paramCacheSizeMax, &cbfCacheMax, NULL, 0 ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramStopFlushThreshold, 10 * cbfCacheMax / 100, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramStartFlushThreshold, 1 * cbfCacheMax / 100, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramDbExtensionSize, 256, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableTempTableVersioning, fFalse, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexChecking, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTables, 10000, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramPreferredMaxOpenTables, 10000, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramDisableCallbacks, fTrue, NULL ) );

				// Set user overrides.
				Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

				Call( JetInit( &instance ) );
				CallJ( JetBeginSession( instance, &sesid, szUser, szPassword ), Cleanup );

				// Detach temporary database and delete file if present (ignore errors).
				EDBUTLDeleteTemp( &opts );

				dbutil.sesid		= sesid;
				dbutil.op			= opDBUTILDBDefragment;
				dbutil.szDatabase	= opts.szSourceDB;
				dbutil.szSLV 		= opts.szSourceSLV;
				dbutil.szTable		= opts.szTempDB;
				dbutil.szIndex		= opts.szTempSLV;
				dbutil.grbitOptions	= grbitDefrag;
				dbutil.pfnCallback	= PrintStatus;
				
				CallJ( JetDBUtilities( &dbutil ), Cleanup );
				
				Call( ErrEDBUTLCleanup( instance, sesid, JET_errSuccess ) );

				Call( ErrEDBUTLBackupAndInstateDB( sesid, &opts ) );

				printf( "%cNote:%c", cNewLine, cNewLine );
				printf( "  It is recommended that you immediately perform a full backup%c", cNewLine );
				printf( "  of this database. If you restore a backup made before the%c", cNewLine );
				printf( "  defragmentation, the database will be rolled back to the state%c", cNewLine );
				printf( "  it was in at the time of that backup.%c%c", cNewLine, cNewLine );
				}
			break;

		case modeRepair:
				{			
				if( !FUTILOPTSSuppressLogo( opts.fUTILOPTSFlags ) )
					{
					const int id = MessageBox(
								NULL,
								szRepairMessage,
								szRepairCaption,
								MB_ICONSTOP | MB_OKCANCEL );
					if ( IDCANCEL == id )
						{
						err = JET_errInvalidParameter;
						Call( err );
						}
					}

				Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultRepairDB, szSourceStreamFileName ) );

				printf( "Initiating REPAIR mode...%c", cNewLine );
				printf( "        Database: %s%c", opts.szSourceDB, cNewLine );
				if( opts.szSourceSLV )
					{
					printf( "  Streaming File: %s%c", opts.szSourceSLV, cNewLine );
					}
				printf( "  Temp. Database: %s%c", opts.szTempDB, cNewLine );

				fWhitespaceOnErr = fTrue;

				Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "repair_off" ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramTempPath, 0, opts.szTempDB ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableTempTableVersioning, fFalse, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableOnlineDefrag, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramDbExtensionSize, 256, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexChecking, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTables, 10000, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramPreferredMaxOpenTables, 10000, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramDisableCallbacks, fTrue, NULL ) );
				//  create plenty of sessions for multi-threaded integrity/repair
				//  need to have plenty of pages to have that many sessions
				Call( JetSetSystemParameter( &instance, 0, JET_paramCacheSizeMin, 4096, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxSessions, 128, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxTemporaryTables, 10000, NULL ) );

				// Set user overrides.
				Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

				Call( JetInit( &instance ) );
				CallJ( JetBeginSession( instance, &sesid, szUser, szPassword ), Cleanup );
				
				JET_GRBIT grbit;
				grbit = 0;
				if( FUTILOPTSDontRepair( opts.fUTILOPTSFlags ) )
					{
					grbit |= JET_bitDBUtilOptionDontRepair;
					}
				if( FUTILOPTSDumpStats( opts.fUTILOPTSFlags ) )
					{
					grbit |= JET_bitDBUtilOptionStats;
					}

				CallJ( ErrEDBUTLRepair(
					sesid,
					opts.szSourceDB,
					opts.szSourceSLV,
					opts.szBackup,
					(char *)(opts.pv),
					opts.szIntegPrefix,
					PrintStatus,
					grbit ), Cleanup );

				errRepaired = err;
				
				Call( ErrEDBUTLCleanup( instance, sesid, JET_errSuccess ) );
				
				printf( "Note:%c", cNewLine );
				printf( "  It is recommended that you immediately perform a full backup%c", cNewLine );
				printf( "  of this database. If you restore a backup made before the%c", cNewLine );
				printf( "  repair, the database will be rolled back to the state%c", cNewLine );
				printf( "  it was in at the time of that backup.%c%c", cNewLine, cNewLine );
				}			
			break;
			
		case modeChecksum:
				{			
				wchar_t szFile[_MAX_PATH+1];	//	UNDONE: don't know if +1 is really needed, but add it to be safe

				Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultTempDB ) );

				if ( !MultiByteToWideChar(
						CP_ACP,
						0,
						opts.szSourceDB,
						-1,
						szFile,
						_MAX_PATH ) )
					{
					Call( JET_errUnicodeTranslationFail );
					}
					
				printf( "Initiating CHECKSUM mode...%c%c", cNewLine, cNewLine );
				fWhitespaceOnErr = fTrue;

				if ( FChecksumFile( szFile, FUTILOPTS8KPage( opts.fUTILOPTSFlags ), NULL ) )
					{
					err = JET_errSuccess;
					}
				else
					{
					fUnknownError = fTrue;
					goto HandleError;
					}
				}			
			break;

		case modeSLVMove:
				{
				printf( "Initiating SLV Move mode...%c", cNewLine );
				printf( "        Database: %s%c", opts.szSourceDB, cNewLine );

				fWhitespaceOnErr = fTrue;

				Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "on" ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableOnlineDefrag, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexChecking, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramDisableCallbacks, fTrue, NULL ) );
				//  create enough sessions for multi-threadeding
				//  need to have plenty of pages to have that many sessions
				Call( JetSetSystemParameter( &instance, 0, JET_paramCacheSizeMin, 16 * 4, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxSessions, 16, NULL ) );
				ULONG_PTR cbfCacheMax;
				Call( JetGetSystemParameter( instance, 0, JET_paramCacheSizeMax, &cbfCacheMax, NULL, 0 ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramStopFlushThreshold, 30 * cbfCacheMax / 100, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramStartFlushThreshold, 20 * cbfCacheMax / 100, NULL ) );

				// Set user overrides.
				Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

				dbutil.szDatabase = opts.szSourceDB;
 
				Call( JetDBUtilities( &dbutil ) );
				printf( "%c", cNewLine );		
				}		
			break;

		case modeScrub:
				{			

				Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultScrubDB, szSourceStreamFileName ) );

				printf( "Initiating SECURE mode...%c", cNewLine );
				printf( "        Database: %s%c", opts.szSourceDB, cNewLine );
				if( opts.szSourceSLV )
					{
					printf( "  Streaming File: %s%c", opts.szSourceSLV, cNewLine );
					}

				fWhitespaceOnErr = fTrue;

				Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "scrub_off" ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableOnlineDefrag, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexChecking, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramDisableCallbacks, fTrue, NULL ) );
				//  create enough sessions for multi-threadeding
				//  need to have plenty of pages to have that many sessions
				Call( JetSetSystemParameter( &instance, 0, JET_paramCacheSizeMin, 16 * 4, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxSessions, 16, NULL ) );
				ULONG_PTR cbfCacheMax;
				Call( JetGetSystemParameter( instance, 0, JET_paramCacheSizeMax, &cbfCacheMax, NULL, 0 ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramStopFlushThreshold, 30 * cbfCacheMax / 100, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramStartFlushThreshold, 20 * cbfCacheMax / 100, NULL ) );

				// Set user overrides.
				Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

				Call( JetInit( &instance ) );
				CallJ( JetBeginSession( instance, &sesid, szUser, szPassword ), Cleanup );
									
				CallJ( ErrEDBUTLScrub(
					sesid,
					opts.szSourceDB,
					opts.szSourceSLV,
					PrintStatus,
					0 ), Cleanup );
				
				Call( ErrEDBUTLCleanup( instance, sesid, JET_errSuccess ) );

				printf( "Warning:%c", cNewLine );
				printf( "  You MUST delete the logfiles for this database%c%c", cNewLine, cNewLine );
				
				printf( "Note:%c", cNewLine );
				printf( "  It is recommended that you immediately perform a full backup%c", cNewLine );
				printf( "  of this database. If you restore a backup made before the%c", cNewLine );
				printf( "  repair, the database will be rolled back to the state%c", cNewLine );
				printf( "  it was in at the time of that backup.%c%c", cNewLine, cNewLine );				
				}			
			break;

#ifdef RECORD_FORMAT_UPGRADE
		case modeUpgradeRecordFormat:
				{
				Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultScrubDB ) );

				printf( "Initiating RECORD UPGRADE mode...%c", cNewLine );
				printf( "        Database: %s%c", opts.szSourceDB, cNewLine );
				printf( "     Dirty Level: %d%c", opts.lDirtyLevel, cNewLine );

				fWhitespaceOnErr = fTrue;

				Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "record_upgrade_off" ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableOnlineDefrag, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexChecking, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramDisableCallbacks, fTrue, NULL ) );
				//  create enough sessions for multi-threadeding
				//  need to have plenty of pages to have that many sessions
				Call( JetSetSystemParameter( &instance, 0, JET_paramCacheSizeMin, 16 * 4, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxSessions, 16, NULL ) );
				ULONG_PTR cbfCacheMax;
				Call( JetGetSystemParameter( instance, 0, JET_paramCacheSizeMax, &cbfCacheMax, NULL, 0 ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramStopFlushThreshold, 30 * cbfCacheMax / 100, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramStartFlushThreshold, 20 * cbfCacheMax / 100, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramRecordUpgradeDirtyLevel, opts.lDirtyLevel, NULL ) );

				// Set user overrides.
				
				Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

				Call( JetInit( &instance ) );
				CallJ( JetBeginSession( instance, &sesid, szUser, szPassword ), Cleanup );

				CallJ( ErrEDBUTLUpgradeRecordFormat(
					sesid,
					opts.szSourceDB,
					PrintStatus,
					0 ), Cleanup );
				
				Call( ErrEDBUTLCleanup( instance, sesid, JET_errSuccess ) );
				}			
			break;
#endif	//	RECORD_FORMAT_UPGRADE

		case modeIntegrity:
				{		
				Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultIntegDB, szSourceStreamFileName ) );

				printf( "Initiating INTEGRITY mode...%c", cNewLine );
				printf( "        Database: %s%c", opts.szSourceDB, cNewLine );
				if( opts.szSourceSLV )
					{
					printf( "  Streaming File: %s%c", opts.szSourceSLV, cNewLine );
					}
				printf( "  Temp. Database: %s%c", opts.szTempDB, cNewLine );
				if( NULL != opts.pv )
					{
					printf( "           Table: %s%c", (char *)opts.pv, cNewLine );
					}

				fWhitespaceOnErr = fTrue;

				Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "off" ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramTempPath, 0, opts.szTempDB ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableOnlineDefrag, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableTempTableVersioning, fFalse, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexChecking, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTables, 10000, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramPreferredMaxOpenTables, 10000, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramDisableCallbacks, fTrue, NULL ) );
				//  create plenty of sessions for multi-threaded integrity/repair
				//  need to have plenty of pages to have that many sessions
				Call( JetSetSystemParameter( &instance, 0, JET_paramCacheSizeMin, 128 * 4, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxSessions, 128, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramMaxTemporaryTables, 10000, NULL ) );

				// Set user overrides.
				Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

				Call( JetInit( &instance ) );
				CallJ( JetBeginSession( instance, &sesid, szUser, szPassword ), Cleanup );
				
				JET_GRBIT grbit;
				grbit = JET_bitDBUtilOptionDontRepair;
				if( FUTILOPTSDumpStats( opts.fUTILOPTSFlags ) )
					{
					grbit |= JET_bitDBUtilOptionStats;
					}	
				if( FUTILOPTSDontBuildIndexes( opts.fUTILOPTSFlags ) )
					{
					grbit |= JET_bitDBUtilOptionDontBuildIndexes;
					}	
				assert( grbit & JET_bitDBUtilOptionDontRepair );

				CallJ( ErrEDBUTLRepair(
					sesid,
					opts.szSourceDB,
					opts.szSourceSLV,
					opts.szBackup,
					(char *)(opts.pv),
					opts.szIntegPrefix,
					PrintStatus,
					grbit ), Cleanup );
				
				Call( ErrEDBUTLCleanup( instance, sesid, JET_errSuccess ) );
				}
			break;

		case modeUpgrade:		
			Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultUpgradeDB ) );

			Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "off" ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramEnableOnlineDefrag, 0, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramDbExtensionSize, 256, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramEnableTempTableVersioning, fFalse, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxOpenTables, 10000, NULL ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramPreferredMaxOpenTables, 10000, NULL ) );

			fWhitespaceOnErr = fTrue;

			// Set user overrides.
			Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

			Call( JetInit( &instance ) );
			CallJ( JetBeginSession( instance, &sesid, szUser, szPassword ), Cleanup );

			// Detach temporary database and delete file if present (ignore errors).
			JetDetachDatabase( sesid, opts.szTempDB );
			DeleteFile( opts.szTempDB );

			assert( opts.pv == &convert );
			CallJ( JetCompact(
				sesid,
				opts.szSourceDB,
				FUTILOPTSInPlaceUpgrade( opts.fUTILOPTSFlags ) ? opts.szSourceDB : opts.szTempDB,
				PrintStatus,
				&convert,
				FUTILOPTSDefragInfo( opts.fUTILOPTSFlags ) ? JET_bitCompactStats : 0 ), Cleanup );

			Call( ErrEDBUTLCleanup( instance, sesid, JET_errSuccess ) );

			Call( ErrEDBUTLBackupAndInstateDB( sesid, &opts ) );
			
			break;

#ifdef ESENT
#else
		case modeSplash:
			EDBUTLSplash();
			break;
#endif			

		case modeHardRecovery:
			{
			char * 	szTargetInstance = opts.szRestore;
			char 	szFullRestorePath[_MAX_PATH + 1];

			// if missing, get current directory
			if ( _fullpath( szFullRestorePath, opts.szSourceDB?opts.szSourceDB:".", _MAX_PATH ) == NULL )
				{
				Call ( JET_errInvalidPath );
				}

			if ( FUTILOPTSServerSim ( opts.fUTILOPTSFlags ) )
				{
#ifdef RESTORE_SERVER_SIMULATION
				// if no definition file was provided, call with NULL and
				// it will print a sample of such a file
				Call ( ErrDBUTLServerSim( opts.szSourceDB?szFullRestorePath:NULL ) );
#else // RESTORE_SERVER_SIMULATION
				// FUTILOPTSServerSim() set only with RESTORE_SERVER_SIMULATION 
				// defined, check command line parsing above
				assert ( fFalse );
#endif // RESTORE_SERVER_SIMULATION
				}
			else if ( FUTILOPTSDumpRestoreEnv( opts.fUTILOPTSFlags ) )
				{
				Call ( ErrDBUTLDumpRestoreEnv(szFullRestorePath) );
				}
			else
				{
				Call ( ErrDBUTLRestoreComplete( szFullRestorePath, szTargetInstance, FUTILOPTSPreserveTempDB( opts.fUTILOPTSFlags ) ) );
				}
			}
			break;				

		case modeDump:
		default:
			{
			char	szBaseName[4];

			// Make the most innocuous operation the fall-through (to cover
			// ourselves in the unlikely event we messed up the modes).
			assert( opts.mode == modeDump );
			assert( opts.pv == &dbutil );

			if ( opts.mode == modeDump )
				{
				Call( JetSetSystemParameter( &instance, 0, JET_paramEnableIndexChecking, 0, NULL ) );
				Call( JetSetSystemParameter( &instance, 0, JET_paramDisableCallbacks, fTrue, NULL ) );

				if ( opts.szSourceDB == NULL )
					{
					printf( szUsageErr1, "database/filename" );			// Missing spec.
					printf( "%c%c", cNewLine, cNewLine );
					Call( JET_errInvalidParameter );
					}

				printf( "Initiating FILE DUMP mode...%c", cNewLine );

				switch( dbutil.op )	//lint !e644
					{
					case opDBUTILDumpLogfile:
						opts.szBase = szBaseName;
						EDBUTLGetBaseName( opts.szSourceDB, opts.szBase );
						break;
					case opDBUTILDumpLogfileTrackNode:
						printf( "      Log file: %s%c", opts.szSourceDB, cNewLine );
						printf( "          Node: %d:%d:%d%c", dbutil.dbid, dbutil.pgno, dbutil.iline, cNewLine );
						printf( "         Lgpos: %06X,%04X,%04X%c", dbutil.lGeneration, dbutil.isec, dbutil.ib, cNewLine );
						break;
					case opDBUTILDumpCheckpoint:
						printf( "      Checkpoint file: %s%c", opts.szSourceDB, cNewLine );
						break;
					case opDBUTILSetHeaderState:
						printf( "      Database %s will be forced to a consistent state.%c",
							opts.szSourceDB, cNewLine );
						break;

					case opDBUTILSLVMove:
					case opDBUTILDumpPage:
						Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultTempDB ) );
						printf( "      Database: %s%c", opts.szSourceDB, cNewLine );
						printf( "          Page: %d%c", dbutil.pgno, cNewLine );
						break;
					case opDBUTILDumpNode:
						Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultTempDB ) );
						printf( "      Database: %s%c", opts.szSourceDB, cNewLine );
						printf( "          Node: %d:%d%c", dbutil.pgno, dbutil.iline, cNewLine );
						break;
					case opDBUTILDumpHeader:
					case opDBUTILDumpMetaData:
					case opDBUTILDumpSpace:
					case opDBUTILDumpData:
					case opDBUTILDumpExchangeSLVInfo:
						Call( ErrEDBUTLCheckDBSLVNames( &opts, szDefaultTempDB ) );
						printf( "      Database: %s%c", opts.szSourceDB, cNewLine );
						if( opts.szSourceSLV )
							{
							printf( " Streaming File: %s%c", opts.szSourceSLV, cNewLine );
							}

						break;					
					default:
						assert( 0 );
					}
				}

			printf( "%c", cNewLine );

			Call( JetSetSystemParameter( &instance, 0, JET_paramRecovery, 0, "off" ) );
			Call( JetSetSystemParameter( &instance, 0, JET_paramEnableOnlineDefrag, 0, NULL ) );

			//	set temp table size to be 0 so that no temp db will be created
			
			Call( JetSetSystemParameter( &instance, 0, JET_paramMaxTemporaryTables, 0, NULL ) );

			//	set user overrides.
			
			Call( ErrEDBUTLUserSystemParameters( &instance, &opts ) );

			dbutil.szDatabase = opts.szSourceDB;
			dbutil.szSLV = opts.szSourceSLV;
			Call( JetDBUtilities( &dbutil ) );
			printf( "%c", cNewLine );
			break;
			}
		}
		
	EDBUTLGetTime( timer, &iSec, &iMSec );

	if( JET_errSuccess != errRepaired ) //db is repaired
		{
		ULONG_PTR	ulWarn		= errRepaired;
		CHAR		szWarn[512];
		szWarn[0] = 0;
		(void)JetGetSystemParameter(
			instance,
			JET_sesidNil,
			JET_paramErrorToString,
			(ULONG_PTR *)&ulWarn,
			szWarn,
			sizeof( szWarn ) );
		if ( fWhitespaceOnErr )
			printf( "%c%c", cNewLine, cNewLine );
		printf( szOperWarn, errRepaired, szWarn, iSec, iMSec );
		}	
	else // JET_errSuccess == err 
		{ 
		printf( szOperSuccess, iSec, iMSec );
		}
	printf( "%c%c", cNewLine, cNewLine );
	return 0;
	

Cleanup:
	ErrEDBUTLCleanup( instance, sesid, err );

HandleError:
	EDBUTLGetTime( timer, &iSec, &iMSec );

	if ( fUnknownError )
		{
		if ( fWhitespaceOnErr )
			printf( "%c%c", cNewLine, cNewLine );
		printf( szOperFailUnknownError, iSec, iMSec );
		}
	else
		{
		assert( err < 0 );
		ULONG_PTR	ulErr		= err;
		CHAR		szError[512];

		szError[0] = 0;
		(void)JetGetSystemParameter(
			instance,
			JET_sesidNil,
			JET_paramErrorToString,
			(ULONG_PTR *)&ulErr,
			szError,
			sizeof( szError ) );
		if ( fWhitespaceOnErr )
		
			printf( "%c%c", cNewLine, cNewLine );
		printf( szOperFailWithError, err, szError, iSec, iMSec );
		}	

	printf( "%c%c", cNewLine, cNewLine );
	return err;


Usage:
	SetCurArgID( 0 );
	assert( GetCurArgID() == 0 );
	EDBUTLHelp( _strupr( GetCurArg() ) );
	return -1;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\_esefile\checksum.cxx ===
#include "esefile.hxx"

//  Checksum a file in ESE format
//
//  For optimal performance the file is read in 64K chunks. As each
//	read completes it is posted to a completion port. Threads take
//	reads off the completion port, checksum the data and issue a
//	new read (if there is more data to read).
//
//	The basic unit of a read is the BLOCKIO. When it is no longer
//	possible to read from a file a signal is set in the BLOCKIO.
//	When all BLOCKIO's are signalled the checksum has completed.
//
//	The status of the checksum is kept is global variables and updated
//	with interlocked operations.
//
//	The main thread starts reading the files and creates the threads
//	which pull completed reads off the completion port. The main thread
//	wakes up periodically to update the status bar
//

int g_cbPage;
int g_shfCbLower;
int g_shfCbUpper;
int g_cpagesPerBlock;

static const int cblocks		= 256;						//	16M of buffers used to read
static const int cthreads		= 8;


struct CHECKSUM_STATS
	{
	DWORD				cpagesSeen;
	DWORD				cpagesBadChecksum;
	DWORD				cpagesUninit;
	DWORD				cpagesWrongPgno;
	unsigned __int64	dbtimeHighest;
	DWORD				pgnoDbtimeHighest;
	};
	

static long cpageMax;
static long cblockMax;
static long cblockCurr;

static HANDLE rghThreads[cthreads];

typedef DWORD (*PFNCHECKSUM)( const BYTE * const, const DWORD );


//  ================================================================
struct JETPAGE
//  ================================================================
	{
	DWORD				dwChecksum;
	DWORD				pgno;
	unsigned __int64	dbtime;
//	BYTE				rgbRestOfPage[];
	};


//  ================================================================
struct BLOCKIO
//  ================================================================
	{
	OVERLAPPED		overlapped;		//  overlapped must be the first member
	JETPAGE *		rgpage;
	HANDLE			hFile;
	DWORD			cbRead;
	DWORD 			cpage;
	DWORD 			ipage;
	CHECKSUM_STATS	checksumstats;
	HANDLE			hEvent;
	};


static BLOCKIO rgblockio[cblocks];


//  ================================================================
static void PrintChecksumStats( const CHECKSUM_STATS * const pchecksumstats )
//  ================================================================
	{
	(void)wprintf( L"\r\n\r\n" );
	(void)wprintf( L"%d pages seen\r\n", pchecksumstats->cpagesSeen );
	(void)wprintf( L"%d bad checksums\r\n", pchecksumstats->cpagesBadChecksum );
	(void)wprintf( L"%d uninitialized pages\r\n", pchecksumstats->cpagesUninit );
	(void)wprintf( L"%d wrong page numbers\r\n", pchecksumstats->cpagesWrongPgno );
	(void)wprintf( L"0x%I64x highest dbtime (pgno 0x%x)\r\n", pchecksumstats->dbtimeHighest, pchecksumstats->pgnoDbtimeHighest );
	(void)wprintf( L"\r\n" );
	}


//  ================================================================
static BOOL FChecksumCorrect( const CHECKSUM_STATS * const pchecksumstats )
//  ================================================================
	{
	return ( 0 == pchecksumstats->cpagesBadChecksum && 0 == pchecksumstats->cpagesWrongPgno );
	}


//  ================================================================
static void IssueNextIO( BLOCKIO * const pblockio )
//  ================================================================
	{
	const long cblock 	= InterlockedIncrement( &cblockCurr ) - 1;
	if( cblock >= cblockMax )
		{
		if( !SetEvent( pblockio->hEvent ) )
			{
			PrintWindowsError( L"FAILURE: SetEvent: " );
			}
		return;
		}

	pblockio->cpage 	= min( g_cpagesPerBlock, cpageMax - ( cblock * g_cpagesPerBlock ) );
	pblockio->ipage 	= cblock * g_cpagesPerBlock;
	pblockio->cbRead	= pblockio->cpage * g_cbPage;

	pblockio->overlapped.Offset		= pblockio->ipage << g_shfCbLower;
	pblockio->overlapped.OffsetHigh	= pblockio->ipage >> g_shfCbUpper;

	if( !ReadFile( pblockio->hFile, pblockio->rgpage, pblockio->cbRead, NULL, &(pblockio->overlapped) )
		&& ERROR_IO_PENDING != GetLastError() )
		{
		PrintWindowsError( L"FAILURE: ReadFile: " );
		if( !SetEvent( pblockio->hEvent ) )
			{
			PrintWindowsError( L"FAILURE: SetEvent: " );
			}
		return;
		}

	return;
	}


//  ================================================================
inline void CachePrefetch ( const void * const p )
//  ================================================================
	{
#ifdef _X86_
	  _asm
	  {
	   mov  eax,p
 
	   _emit 0x0f  // PrefetchNTA
	   _emit 0x18
	   _emit 0x00
	  }
#endif
	}
 

//  ================================================================
static BOOL FHardwareCanPrefetch()
//  ================================================================
	{
	BOOL fCanPrefetch = FALSE;
	
#ifdef _X86_
    ULONG    Features;
    ULONG    i;
    DWORD    OriginalAffinity;

 	SYSTEM_INFO system_inf;
 	GetSystemInfo( &system_inf );
 
    //
    // First check to see that I have at least Intel Pentium.  This simplifies
    // the cpuid
    //
    if (system_inf.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL ||
        system_inf.wProcessorLevel < 5)
 	{
	return fCanPrefetch;
	}
	
	fCanPrefetch = TRUE;
 
    //
    // Affinity thread to boot processor
    //
 
	OriginalAffinity = SetThreadAffinityMask(GetCurrentThread(), 1);
 
	// Here we want to go through each CPU, so use the systeminfo # of
	// processors instead of gdwSchedulerCount
	//
	for ( i = 0; i < system_inf.dwNumberOfProcessors && fCanPrefetch; i++ )
		{
		if ( i != 0 )
			{
			SetThreadAffinityMask(GetCurrentThread(), 1 << i);
			}
 
		_asm
			{
			push   ebx
            mov    eax, 1	; cpuid
            _emit  0fh
            _emit  0a2h
 
            mov    Features, edx
            pop    ebx
			}
 
        //
        // Check for Prefetch Present
        //
        if (!(Features & 0x02000000))
			{
 
            //
            // All processors must have prefetch before we can use it.
            // We start with it enabled, if any processor does not have
            // it, we clear it and bail
 
            fCanPrefetch = FALSE;
			}
		}
		SetThreadAffinityMask(GetCurrentThread(), OriginalAffinity);		
#endif

	return fCanPrefetch;
	}


//  ================================================================
static DWORD DwChecksumESEPrefetch( const BYTE * const pb, const DWORD cb )
//  ================================================================
	{
	PFNCHECKSUM pfn = DwChecksumESEPrefetch;
	
	const DWORD	* pdw 			= (DWORD *)pb;
	INT cbT						= cb;

	//	touching this memory puts the page in the processor TLB (needed
	//	for prefetch) and brings in the first cacheline (cacheline 0)
	
	DWORD	dwChecksum = 0x89abcdef ^ pdw[0];

	do
		{
		CachePrefetch ( pdw + 16 );	
		dwChecksum 	^= pdw[0]
					^ pdw[1]
					^ pdw[2]
					^ pdw[3]
					^ pdw[4]
					^ pdw[5]
					^ pdw[6]
					^ pdw[7];
		cbT -= 32;
		pdw += 8;
		} while ( cbT );

	return dwChecksum;
	}


//  ================================================================
static DWORD DwChecksumESENoPrefetch( const BYTE * const pb, const DWORD cb )
//  ================================================================
	{
	PFNCHECKSUM pfn = DwChecksumESENoPrefetch;
	
	const DWORD	* pdw 			= (DWORD *)pb;
	INT cbT						= cb;
	
	DWORD	dwChecksum = 0x89abcdef ^ pdw[0];

	do
		{
		dwChecksum 	^= pdw[0]
					^ pdw[1]
					^ pdw[2]
					^ pdw[3]
					^ pdw[4]
					^ pdw[5]
					^ pdw[6]
					^ pdw[7];
		cbT -= 32;
		pdw += 8;
		} while ( cbT );

	return dwChecksum;
	}


//  ================================================================
static DWORD DwChecksumESE64Bit( const BYTE * const pb, const DWORD cb )
//  ================================================================
	{
	const unsigned __int64	* pqw 	= (unsigned __int64 *)pb;
	unsigned __int64	qwChecksum	= 0;
	DWORD cbT						= cb;
	
	//	checksum the first four bytes twice to remove the checksum
	
	qwChecksum ^= pqw[0] & 0x00000000FFFFFFFF;
		
	do
		{
		qwChecksum ^= pqw[0];
		qwChecksum ^= pqw[1];
		qwChecksum ^= pqw[2];
		qwChecksum ^= pqw[3];
		cbT -= ( 4 * sizeof( unsigned __int64 ) );
		pqw += 4;
		} while ( cbT );

	const unsigned __int64 qwUpper = ( qwChecksum >> ( sizeof( DWORD ) * 8 ) );
	const unsigned __int64 qwLower = qwChecksum & 0x00000000FFFFFFFF;
	qwChecksum = qwUpper ^ qwLower;
	
	const DWORD ulChecksum = static_cast<DWORD>( qwChecksum ) ^ 0x89abcdef;
	return ulChecksum;
	}


//  ================================================================
DWORD DwChecksumESE( const BYTE * const pb, const DWORD cb )
//  ================================================================
	{
	static PFNCHECKSUM pfnChecksumESE = NULL;
	
	if( NULL == pfnChecksumESE )
		{
		if( sizeof( DWORD_PTR ) == sizeof( DWORD ) * 2 )
			{
			pfnChecksumESE = DwChecksumESE64Bit;
			}
		else if( FHardwareCanPrefetch() )
			{
			pfnChecksumESE = DwChecksumESEPrefetch;
			}
		else
			{
			pfnChecksumESE = DwChecksumESENoPrefetch;
			}
		}
	return (*pfnChecksumESE)( pb, cb );
	}


//  ================================================================
static void ProcessESEPages(
	const JETPAGE * const	rgpage,
	const DWORD				cpage,
	const DWORD				ipageStart,
	CHECKSUM_STATS * const	pchecksumstats )
//  ================================================================
	{
	DWORD	ipage;
	for( ipage = 0; ipage < cpage; ++ipage )
		{
		pchecksumstats->cpagesSeen++;

		const JETPAGE * const	ppageCurr	= (JETPAGE *)( (BYTE *)rgpage + ( ipage * g_cbPage ) );
		const DWORD * const		pdwUninit	= (DWORD *)ppageCurr + 1;	//	first DWORD is the checksum

		if ( 0 == *pdwUninit
			&& 0 == *( pdwUninit + 1 )
			&& 0 == *( pdwUninit + 2 )
			&& 0 == *( pdwUninit + 3 ) )
			{
			pchecksumstats->cpagesUninit++;
			}
		else
			{
			const DWORD	pgno			= ppageCurr->pgno;
			const DWORD	pgnoPhysical	= ipageStart + ipage + 1;
			const long	fHeaderPage		= ( pgnoPhysical <= g_cpgDBReserved );
			const DWORD	pgnoReal		= ( fHeaderPage ? 0 : pgnoPhysical - g_cpgDBReserved );

			//	pgnoReal==-1 for db header and 0 for shadow
			if( pgno != pgnoReal && !fHeaderPage )
				{
				(void)fwprintf( stderr, L"ERROR: page %d returned page %d\r\n", pgnoReal, pgno );
				pchecksumstats->cpagesWrongPgno++;
				}
			const DWORD dwChecksum = DwChecksumESE( (BYTE *)ppageCurr, g_cbPage );
			if( dwChecksum != ppageCurr->dwChecksum )
				{
				(void)fwprintf( stderr, L"ERROR: page %d checksum failed ( 0x%x / 0x%x )\r\n", (int)pgnoReal, dwChecksum, ppageCurr->dwChecksum );
				pchecksumstats->cpagesBadChecksum++;
				}
			else if ( !fHeaderPage )
				{
				if ( ppageCurr->dbtime > pchecksumstats->dbtimeHighest )
					{
					pchecksumstats->dbtimeHighest = ppageCurr->dbtime;
					pchecksumstats->pgnoDbtimeHighest = pgnoReal;
					}
				}
			}
		}
	}


//  ================================================================
static DWORD WINAPI ESEThreadProc( LPVOID lpParam )
//  ================================================================
	{
	// Raid 137809
	SetThreadPriorityBoost( GetCurrentThread(), TRUE );

	const HANDLE hIOCP = (HANDLE)lpParam;
	while( 1 )
		{
		DWORD 		dwBytesTransferred;
		DWORD_PTR	dwCompletionKey;
		OVERLAPPED 	* poverlapped;
		if( !GetQueuedCompletionStatus(
				hIOCP,
				&dwBytesTransferred,
				&dwCompletionKey,
				&poverlapped,
				INFINITE ) )
			{
			PrintWindowsError( L"FAILURE: GetQueuedCompletionsStatus: " );
			break;
			}
		BLOCKIO * const pblockio = (BLOCKIO *)poverlapped;	//	overlapped is the first structure
		if( dwBytesTransferred != pblockio->cbRead )
			{
			PrintWindowsError( L"FAILURE: GetQueuedCompletionsStatus got the wrong number of bytes: " );
			break;
			}
		ProcessESEPages( pblockio->rgpage, pblockio->cpage, pblockio->ipage, &pblockio->checksumstats );
		IssueNextIO( pblockio );
		}
	return 0;
	}


//  ================================================================
BOOL FChecksumFile(
	const wchar_t * const	szFile,
	const BOOL				f8kPages,
	BOOL * const			pfBadPagesDetected )
//  ================================================================
	{	
	BOOL	fSuccess = FALSE;

	HANDLE hFile = INVALID_HANDLE_VALUE;
	HANDLE hIOCP = NULL;

	int iblockio;
	int ithread;

	DWORD cbSizeLow;
	DWORD cbSizeHigh;

	wprintf( L"File: %.64ls", ( iswascii( szFile[0] ) ? szFile : L"<unprintable>" ) );
	wprintf( L"\r\n\r\n" );

	//	init

	InitPageSize( f8kPages );

	cpageMax			= 0;
	cblockMax			= 0;
	cblockCurr			= 0;

	for( ithread = 0; ithread < cthreads; ++ithread )
		{
		rghThreads[ithread] = NULL;
		}

	for( iblockio = 0; iblockio < cblocks; ++iblockio )
		{
		rgblockio[iblockio].rgpage							= NULL;
		rgblockio[iblockio].overlapped.hEvent 				= NULL;
		rgblockio[iblockio].hEvent 							= NULL;
		rgblockio[iblockio].checksumstats.cpagesSeen		= 0;
		rgblockio[iblockio].checksumstats.cpagesBadChecksum	= 0;
		rgblockio[iblockio].checksumstats.cpagesUninit		= 0;
		rgblockio[iblockio].checksumstats.cpagesWrongPgno	= 0;
		rgblockio[iblockio].checksumstats.dbtimeHighest		= 0;
		rgblockio[iblockio].checksumstats.pgnoDbtimeHighest	= 0;
		}

	//  open the file
	
	hFile = CreateFile(					
						szFile,
						GENERIC_READ,
						FILE_SHARE_READ | FILE_SHARE_WRITE,
						NULL,
						OPEN_EXISTING,
						FILE_FLAG_OVERLAPPED | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_NO_BUFFERING,
						NULL );
	if( INVALID_HANDLE_VALUE == hFile )
		{
		PrintWindowsError( L"FAILURE: CreateFile: " );
		goto LHandleError;
		}

	//  create the I/O completion port
	
	hIOCP = CreateIoCompletionPort (
		hFile,
		NULL,
		0,
		0 );
	if( NULL == hIOCP )
		{
		PrintWindowsError( L"FAILURE: CreateIoCompletionPort: " );
		goto LHandleError;
		}

	//  start the threads running

	for( ithread = 0; ithread < cthreads; ++ithread )
		{
		rghThreads[ithread] = CreateThread( 
											NULL,
											0,
											ESEThreadProc,
											(LPVOID)hIOCP,
											0,
											NULL );

		if( NULL == rghThreads[ithread] )
			{
			PrintWindowsError( L"FAILURE: CreateThread: " );
			goto LHandleError;
			}
	  	}

  	//  get the size of the file
	
	cbSizeLow = GetFileSize (hFile, &cbSizeHigh) ;
	if ( 0xFFFFFFFF == cbSizeLow && GetLastError() != NO_ERROR )
		{ 
		PrintWindowsError( L"FAILURE: GetFileSize: " );
		goto LHandleError;
		}

	cpageMax 	= ( cbSizeHigh << g_shfCbUpper ) + ( cbSizeLow >> g_shfCbLower );
	cblockMax 	= ( cpageMax + g_cpagesPerBlock - 1 ) / g_cpagesPerBlock;

	//  setup the BLOCKIO structures and start the IOs

	for( iblockio = 0; iblockio < cblocks; ++iblockio )
		{
		rgblockio[iblockio].hFile	 			= hFile;
		rgblockio[iblockio].rgpage 				= (JETPAGE *)VirtualAlloc( NULL, g_cbPage * g_cpagesPerBlock, MEM_COMMIT, PAGE_READWRITE );
		if( NULL == rgblockio[iblockio].rgpage )
			{
			PrintWindowsError( L"FAILURE: VirtualAlloc: " );
			goto LHandleError;
			}
		rgblockio[iblockio].hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
		if( NULL == rgblockio[iblockio].hEvent )
			{
			PrintWindowsError( L"FAILURE: CreateEvent: " );
			goto LHandleError;
			}

		IssueNextIO( rgblockio + iblockio );
		}

	InitStatus( L"Checksum Status (% complete)" );

	//  wait until the first block is done
	//  wake up to update the status bar

	while( 1 )
		{
		const DWORD dw = WaitForSingleObjectEx( rgblockio[0].hEvent, 200, FALSE );
		if( WAIT_TIMEOUT == dw )
			{
			const int  iPercentage	= ( cblockCurr * 100 ) / cblockMax;
			UpdateStatus( iPercentage );
			}
		else if( WAIT_OBJECT_0 == dw )
			{
			break;
			}
		else
			{
			PrintWindowsError( L"FAILURE: WaitForSingleObjectEx: " );
			goto LHandleError;
			}
		}

	//  do the other blocks 
	
	for( iblockio = 1; iblockio < cblocks; ++iblockio )
		{
		if( WAIT_OBJECT_0 != WaitForSingleObjectEx( rgblockio[iblockio].hEvent, INFINITE, FALSE ) )
			{
			PrintWindowsError( L"FAILURE: WaitForSingleObjectEx: " );
			goto LHandleError;
			}

		//	use the checksum stats in the first IO block to store the final totals
		rgblockio[0].checksumstats.cpagesSeen += rgblockio[iblockio].checksumstats.cpagesSeen;
		rgblockio[0].checksumstats.cpagesBadChecksum += rgblockio[iblockio].checksumstats.cpagesBadChecksum;
		rgblockio[0].checksumstats.cpagesUninit += rgblockio[iblockio].checksumstats.cpagesUninit;
		rgblockio[0].checksumstats.cpagesWrongPgno += rgblockio[iblockio].checksumstats.cpagesWrongPgno;
		if ( rgblockio[0].checksumstats.dbtimeHighest < rgblockio[iblockio].checksumstats.dbtimeHighest )
			{
			rgblockio[0].checksumstats.dbtimeHighest = rgblockio[iblockio].checksumstats.dbtimeHighest;
			rgblockio[0].checksumstats.pgnoDbtimeHighest = rgblockio[iblockio].checksumstats.pgnoDbtimeHighest;
			}
	  	}

	TermStatus();
	PrintChecksumStats( &rgblockio[0].checksumstats );

	if ( NULL != pfBadPagesDetected )
		*pfBadPagesDetected = FChecksumCorrect( &rgblockio[0].checksumstats );

	fSuccess = TRUE;

LHandleError:

	if( INVALID_HANDLE_VALUE != hFile )
		{
		CloseHandle( hFile );
		}
		
	if( NULL != hIOCP )
		{
		CloseHandle( hFile );
		}

	for( iblockio = 0; iblockio < cblocks; ++iblockio )
		{
		if( NULL != rgblockio[iblockio].rgpage )
			{
			VirtualFree( (void *)rgblockio[iblockio].rgpage, 0, MEM_RELEASE );
			}
		if( NULL != rgblockio[iblockio].hEvent )
			{
			CloseHandle( rgblockio[iblockio].hEvent );
			}
		}

	for( ithread = 0; ithread < cthreads; ++ithread )
		{
		if( NULL != rghThreads[ithread] )
			{
			CloseHandle( rghThreads[ithread] );
			}
		}

	return fSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\sync\sync.cxx ===
#include "sync.hxx"

//  Performance Monitoring Support

long cOSSYNCThreadBlock;
long LOSSYNCThreadBlockCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = cOSSYNCThreadBlock;
		}
		
	return 0;
	}

long cOSSYNCThreadResume;
long LOSSYNCThreadsBlockedCEFLPv( long iInstance, void* pvBuf )
	{
	if ( pvBuf )
		{
		*( (unsigned long*) pvBuf ) = cOSSYNCThreadBlock - cOSSYNCThreadResume;
		}
		
	return 0;
	}


namespace OSSYNC {


//  system max spin count

int cSpinMax;


//  Page Memory Allocation

void* PvPageAlloc( const size_t cbSize, void* const pv );
void PageFree( void* const pv );


//  Performance Data Dump

void OSSyncStatsDump(	const char*			szTypeName,
						const char*			szInstanceName,
						const CSyncObject*	psyncobj,
						DWORD				group,
						QWORD				cWait,
						double				csecWaitElapsed,
						QWORD				cAcquire,
						QWORD				cContend,
						QWORD				cHold,
						double				csecHoldElapsed );


//  Kernel Semaphore Pool

//  ctor

CKernelSemaphorePool::CKernelSemaphorePool()
	{
	}

//  dtor

CKernelSemaphorePool::~CKernelSemaphorePool()
	{
	}

//  init

const BOOL CKernelSemaphorePool::FInit()
	{
	//  semaphore pool should be terminated

	OSSYNCAssert( !FInitialized() );

	//  reset members

	m_mpirksemrksem	= NULL;
	m_cksem			= 0;
	
	//  allocate kernel semaphore array

	if ( !( m_mpirksemrksem = (CReferencedKernelSemaphore*)PvPageAlloc( sizeof( CReferencedKernelSemaphore ) * 65536, NULL ) ) )
		{
		Term();
		return fFalse;
		}

	//  init successful

	return fTrue;
	}

//  term

void CKernelSemaphorePool::Term()
	{
	//  the kernel semaphore array is allocated

	if ( m_mpirksemrksem )
		{
		//  terminate all initialized kernel semaphores

		for ( m_cksem-- ; m_cksem >= 0; m_cksem-- )
			{
			m_mpirksemrksem[m_cksem].Term();
			m_mpirksemrksem[m_cksem].~CReferencedKernelSemaphore();
			}

		//  delete the kernel semaphore array
		
		PageFree( m_mpirksemrksem );
		}
	
	//  reset data members

	m_mpirksemrksem	= 0;
	m_cksem			= 0;
	}

//  Referenced Kernel Semaphore

//  ctor

CKernelSemaphorePool::CReferencedKernelSemaphore::CReferencedKernelSemaphore()
	:	CKernelSemaphore( CSyncBasicInfo( "CKernelSemaphorePool::CReferencedKernelSemaphore" ) )
	{
	//  reset data members

	m_cReference	= 0;
	m_fInUse		= 0;
	m_fAvailable	= 0;
#ifdef SYNC_VALIDATE_IRKSEM_USAGE
	m_psyncobjUser	= 0;
#endif  //  SYNC_VALIDATE_IRKSEM_USAGE
	}

//  dtor

CKernelSemaphorePool::CReferencedKernelSemaphore::~CReferencedKernelSemaphore()
	{
	}

//  init

const BOOL CKernelSemaphorePool::CReferencedKernelSemaphore::FInit()
	{
	//  reset data members

	m_cReference	= 0;
	m_fInUse		= 0;
	m_fAvailable	= 0;
#ifdef SYNC_VALIDATE_IRKSEM_USAGE
	m_psyncobjUser	= 0;
#endif  //  SYNC_VALIDATE_IRKSEM_USAGE

	//  initialize the kernel semaphore
	
	return CKernelSemaphore::FInit();
	}

//  term

void CKernelSemaphorePool::CReferencedKernelSemaphore::Term()
	{
	//  terminate the kernel semaphore

	CKernelSemaphore::Term();
	
	//  reset data members

	m_cReference	= 0;
	m_fInUse		= 0;
	m_fAvailable	= 0;
#ifdef SYNC_VALIDATE_IRKSEM_USAGE
	m_psyncobjUser	= 0;
#endif  //  SYNC_VALIDATE_IRKSEM_USAGE
	}


//  Global Kernel Semaphore Pool

CKernelSemaphorePool ksempoolGlobal;


//  Synchronization Object Performance:  Acquisition

//  ctor

CSyncPerfAcquire::CSyncPerfAcquire()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	m_cAcquire = 0;
	m_cContend = 0;

#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  dtor

CSyncPerfAcquire::~CSyncPerfAcquire()
	{
	}


//  Semaphore

//  ctor

CSemaphore::CSemaphore( const CSyncBasicInfo& sbi )
	:	CEnhancedStateContainer< CSemaphoreState, CSyncStateInitNull, CSemaphoreInfo, CSyncBasicInfo >( syncstateNull, sbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CSemaphore" );
	State().SetInstance( (CSyncObject*)this );
	}

//  dtor

CSemaphore::~CSemaphore()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	OSSyncStatsDump(	State().SzTypeName(),
						State().SzInstanceName(),
						State().Instance(),
						-1,
						State().CWaitTotal(),
						State().CsecWaitElapsed(),
						State().CAcquireTotal(),
						State().CContendTotal(),
						0,
						0 );

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  attempts to acquire a count from the semaphore, returning fFalse if unsuccessful
//  in the time permitted.  Infinite and Test-Only timeouts are supported.

const BOOL CSemaphore::_FAcquire( const int cmsecTimeout )
	{
	//  if we spin, we will spin for the full amount recommended by the OS
	
	int cSpin = cSpinMax;

	//  we start with no kernel semaphore allocated
	
	CKernelSemaphorePool::IRKSEM irksemAlloc = CKernelSemaphorePool::irksemNil;

	//  try forever until we successfully change the state of the semaphore
	
	OSSYNC_FOREVER
		{
		//  read the current state of the semaphore
		
		const CSemaphoreState stateCur = (CSemaphoreState&) State();

		//  there is an available count

		if ( stateCur.FAvail() )
			{
			//  we successfully took a count
			
			if ( State().FChange( stateCur, CSemaphoreState( stateCur.CAvail() - 1 ) ) )
				{
				//  if we allocated a kernel semaphore, release it
				
				if ( irksemAlloc != CKernelSemaphorePool::irksemNil )
					{
					ksempoolGlobal.Unreference( irksemAlloc );
					}

				//  return success

				State().SetAcquire();
				return fTrue;
				}
			}

		//  there is no available count and we still have spins left
		
		else if ( cSpin )
			{
			//  spin once and try again
			
			cSpin--;
			continue;
			}

		//  there are no waiters and no available counts
		
		else if ( stateCur.FNoWaitAndNoAvail() )
			{
			//  allocate and reference a kernel semaphore if we haven't already
			
			if ( irksemAlloc == CKernelSemaphorePool::irksemNil )
				{
				irksemAlloc = ksempoolGlobal.Allocate( this );
				}

			//  we successfully installed ourselves as the first waiter
				
			if ( State().FChange( stateCur, CSemaphoreState( 1, irksemAlloc ) ) )
				{
				//  wait for next available count on semaphore

				State().StartWait();
				const BOOL fCompleted = ksempoolGlobal.Ksem( irksemAlloc, this ).FAcquire( cmsecTimeout );
				State().StopWait();

				//  our wait completed

				if ( fCompleted )
					{
					//  unreference the kernel semaphore
					
					ksempoolGlobal.Unreference( irksemAlloc );

					//  we successfully acquired a count

					State().SetAcquire();
					return fTrue;
					}

				//  our wait timed out
				
				else
					{
					//  try forever until we successfully change the state of the semaphore

					OSSYNC_FOREVER
						{
						//  read the current state of the semaphore
						
						const CSemaphoreState stateAfterWait = (CSemaphoreState&) State();

						//  there are no waiters or the kernel semaphore currently
						//  in the semaphore is not the same as the one we allocated

						if ( stateAfterWait.FNoWait() || stateAfterWait.Irksem() != irksemAlloc )
							{
							//  the kernel semaphore we allocated is no longer in
							//  use, so another context released it.  this means that
							//  there is a count on the kernel semaphore that we must
							//  absorb, so we will
							
							//  NOTE:  we could end up blocking because the releasing
							//  context may not have released the semaphore yet
							
							ksempoolGlobal.Ksem( irksemAlloc, this ).Acquire();

							//  unreference the kernel semaphore

							ksempoolGlobal.Unreference( irksemAlloc );

							//  we successfully acquired a count

							return fTrue;
							}

						//  there is one waiter and the kernel semaphore currently
						//  in the semaphore is the same as the one we allocated

						else if ( stateAfterWait.CWait() == 1 )
							{
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == irksemAlloc );

							//  we successfully changed the semaphore to have no
							//  available counts and no waiters
							
							if ( State().FChange( stateAfterWait, CSemaphoreState( 0 ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( irksemAlloc );

								//  we did not successfully acquire a count

								return fFalse;
								}
							}

						//  there are many waiters and the kernel semaphore currently
						//  in the semaphore is the same as the one we allocated

						else
							{
							OSSYNCAssert( stateAfterWait.CWait() > 1 );
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == irksemAlloc );

							//  we successfully reduced the number of waiters on the
							//  semaphore by one
							
							if ( State().FChange( stateAfterWait, CSemaphoreState( stateAfterWait.CWait() - 1, stateAfterWait.Irksem() ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( irksemAlloc );

								//  we did not successfully acquire a count

								return fFalse;
								}
							}
						}
					}
				}
			}

		//  there are waiters
		
		else
			{
			OSSYNCAssert( stateCur.FWait() );

			//  reference the kernel semaphore already in use

			ksempoolGlobal.Reference( stateCur.Irksem() );

			//  we successfully added ourself as another waiter
			
			if ( State().FChange( stateCur, CSemaphoreState( stateCur.CWait() + 1, stateCur.Irksem() ) ) )
				{
				//  if we allocated a kernel semaphore, unreference it

				if ( irksemAlloc != CKernelSemaphorePool::irksemNil )
					{
					ksempoolGlobal.Unreference( irksemAlloc );
					}

				//  wait for next available count on semaphore
				
				State().StartWait();
				const BOOL fCompleted = ksempoolGlobal.Ksem( stateCur.Irksem(), this ).FAcquire( cmsecTimeout );
				State().StopWait();

				//  our wait completed

				if ( fCompleted )
					{
					//  unreference the kernel semaphore
				
					ksempoolGlobal.Unreference( stateCur.Irksem() );

					//  we successfully acquired a count
					
					State().SetAcquire();
					return fTrue;
					}
					
				//  our wait timed out
				
				else
					{
					//  try forever until we successfully change the state of the semaphore

					OSSYNC_FOREVER
						{
						//  read the current state of the semaphore
						
						const CSemaphoreState stateAfterWait = (CSemaphoreState&) State();

						//  there are no waiters or the kernel semaphore currently
						//  in the semaphore is not the same as the one we waited on

						if ( stateAfterWait.FNoWait() || stateAfterWait.Irksem() != stateCur.Irksem() )
							{
							//  the kernel semaphore we waited on is no longer in
							//  use, so another context released it.  this means that
							//  there is a count on the kernel semaphore that we must
							//  absorb, so we will
							
							//  NOTE:  we could end up blocking because the releasing
							//  context may not have released the semaphore yet
							
							ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Acquire();

							//  unreference the kernel semaphore

							ksempoolGlobal.Unreference( stateCur.Irksem() );

							//  we successfully acquired a count

							return fTrue;
							}

						//  there is one waiter and the kernel semaphore currently
						//  in the semaphore is the same as the one we waited on

						else if ( stateAfterWait.CWait() == 1 )
							{
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == stateCur.Irksem() );

							//  we successfully changed the semaphore to have no
							//  available counts and no waiters
							
							if ( State().FChange( stateAfterWait, CSemaphoreState( 0 ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( stateCur.Irksem() );

								//  we did not successfully acquire a count

								return fFalse;
								}
							}

						//  there are many waiters and the kernel semaphore currently
						//  in the semaphore is the same as the one we waited on

						else
							{
							OSSYNCAssert( stateAfterWait.CWait() > 1 );
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == stateCur.Irksem() );

							//  we successfully reduced the number of waiters on the
							//  semaphore by one
							
							if ( State().FChange( stateAfterWait, CSemaphoreState( stateAfterWait.CWait() - 1, stateAfterWait.Irksem() ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( stateCur.Irksem() );

								//  we did not successfully acquire a count

								return fFalse;
								}
							}
						}
					}
				}

			//  unreference the kernel semaphore
				
			ksempoolGlobal.Unreference( stateCur.Irksem() );
			}
		}
	}

//  releases the given number of counts to the semaphore, waking the appropriate
//  number of waiters

void CSemaphore::_Release( const int cToRelease )
	{
	//  try forever until we successfully change the state of the semaphore
	
	OSSYNC_FOREVER
		{
		//  read the current state of the semaphore
		
		const CSemaphoreState stateCur = State();

		//  there are no waiters

		if ( stateCur.FNoWait() )
			{
			//  we successfully added the count to the semaphore
			
			if ( State().FChange( stateCur, CSemaphoreState( stateCur.CAvail() + cToRelease ) ) )
				{
				//  we're done
				
				return;
				}
			}

		//  there are waiters
		
		else
			{
			OSSYNCAssert( stateCur.FWait() );

			//  we are releasing more counts than waiters (or equal to)

			if ( stateCur.CWait() <= cToRelease )
				{
				//  we successfully changed the semaphore to have an available count
				//  that is equal to the specified release count minus the number of
				//  waiters to release
				
				if ( State().FChange( stateCur, CSemaphoreState( cToRelease - stateCur.CWait() ) ) )
					{
					//  release all waiters
					
					ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Release( stateCur.CWait() );

					//  we're done
					
					return;
					}
				}

			//  we are releasing less counts than waiters
			
			else
				{
				OSSYNCAssert( stateCur.CWait() > cToRelease );

				//  we successfully reduced the number of waiters on the semaphore by
				//  the number specified
				
				if ( State().FChange( stateCur, CSemaphoreState( stateCur.CWait() - cToRelease, stateCur.Irksem() ) ) )
					{
					//  release the specified number of waiters
					
					ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Release( cToRelease );

					//  we're done
					
					return;
					}
				}
			}
		}
	}


//  Auto-Reset Signal

//  ctor

CAutoResetSignal::CAutoResetSignal( const CSyncBasicInfo& sbi )
	:	CEnhancedStateContainer< CAutoResetSignalState, CSyncStateInitNull, CAutoResetSignalInfo, CSyncBasicInfo >( syncstateNull, sbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CAutoResetSignal" );
	State().SetInstance( (CSyncObject*)this );
	}

//  dtor

CAutoResetSignal::~CAutoResetSignal()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	OSSyncStatsDump(	State().SzTypeName(),
						State().SzInstanceName(),
						State().Instance(),
						-1,
						State().CWaitTotal(),
						State().CsecWaitElapsed(),
						State().CAcquireTotal(),
						State().CContendTotal(),
						0,
						0 );

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  waits for the signal to be set, returning fFalse if unsuccessful in the time
//  permitted.  Infinite and Test-Only timeouts are supported.

const BOOL CAutoResetSignal::_FWait( const int cmsecTimeout )
	{
	//  if we spin, we will spin for the full amount recommended by the OS
	
	int cSpin = cSpinMax;

	//  we start with no kernel semaphore allocated
	
	CKernelSemaphorePool::IRKSEM irksemAlloc = CKernelSemaphorePool::irksemNil;

	//  try forever until we successfully change the state of the signal
	
	OSSYNC_FOREVER
		{
		//  read the current state of the signal
		
		const CAutoResetSignalState stateCur = (CAutoResetSignalState&) State();

		//  the signal is set

		if ( stateCur.FNoWaitAndSet() )
			{
			//  we successfully changed the signal state to reset with no waiters
			
			if ( State().FChange( stateCur, CAutoResetSignalState( 0 ) ) )
				{
				//  if we allocated a kernel semaphore, release it
				
				if ( irksemAlloc != CKernelSemaphorePool::irksemNil )
					{
					ksempoolGlobal.Unreference( irksemAlloc );
					}

				//  return success

				State().SetAcquire();
				return fTrue;
				}
			}

		//  the signal is not set and we still have spins left
		
		else if ( cSpin )
			{
			//  spin once and try again
			
			cSpin--;
			continue;
			}

		//  the signal is not set and there are no waiters
		
		else if ( stateCur.FNoWaitAndNotSet() )
			{
			//  allocate and reference a kernel semaphore if we haven't already
			
			if ( irksemAlloc == CKernelSemaphorePool::irksemNil )
				{
				irksemAlloc = ksempoolGlobal.Allocate( this );
				}

			//  we successfully installed ourselves as the first waiter
				
			if ( State().FChange( stateCur, CAutoResetSignalState( 1, irksemAlloc ) ) )
				{
				//  wait for signal to be set
				
				State().StartWait();
				const BOOL fCompleted = ksempoolGlobal.Ksem( irksemAlloc, this ).FAcquire( cmsecTimeout );
				State().StopWait();

				//  our wait completed

				if ( fCompleted )
					{
					//  unreference the kernel semaphore
					
					ksempoolGlobal.Unreference( irksemAlloc );

					//  we successfully waited for the signal

					State().SetAcquire();
					return fTrue;
					}

				//  our wait timed out
				
				else
					{
					//  try forever until we successfully change the state of the signal

					OSSYNC_FOREVER
						{
						//  read the current state of the signal
						
						const CAutoResetSignalState stateAfterWait = (CAutoResetSignalState&) State();

						//  there are no waiters or the kernel semaphore currently
						//  in the signal is not the same as the one we allocated

						if ( stateAfterWait.FNoWait() || stateAfterWait.Irksem() != irksemAlloc )
							{
							//  the kernel semaphore we allocated is no longer in
							//  use, so another context released it.  this means that
							//  there is a count on the kernel semaphore that we must
							//  absorb, so we will
							
							//  NOTE:  we could end up blocking because the releasing
							//  context may not have released the semaphore yet
							
							ksempoolGlobal.Ksem( irksemAlloc, this ).Acquire();

							//  unreference the kernel semaphore

							ksempoolGlobal.Unreference( irksemAlloc );

							//  we successfully waited for the signal

							return fTrue;
							}

						//  there is one waiter and the kernel semaphore currently
						//  in the signal is the same as the one we allocated

						else if ( stateAfterWait.CWait() == 1 )
							{
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == irksemAlloc );

							//  we successfully changed the signal to the reset with
							//  no waiters state
							
							if ( State().FChange( stateAfterWait, CAutoResetSignalState( 0 ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( irksemAlloc );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}

						//  there are many waiters and the kernel semaphore currently
						//  in the signal is the same as the one we allocated

						else
							{
							OSSYNCAssert( stateAfterWait.CWait() > 1 );
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == irksemAlloc );

							//  we successfully reduced the number of waiters on the
							//  signal by one
							
							if ( State().FChange( stateAfterWait, CAutoResetSignalState( stateAfterWait.CWait() - 1, stateAfterWait.Irksem() ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( irksemAlloc );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}
						}
					}
				}
			}

		//  there are waiters
		
		else
			{
			OSSYNCAssert( stateCur.FWait() );

			//  reference the kernel semaphore already in use

			ksempoolGlobal.Reference( stateCur.Irksem() );

			//  we successfully added ourself as another waiter
			
			if ( State().FChange( stateCur, CAutoResetSignalState( stateCur.CWait() + 1, stateCur.Irksem() ) ) )
				{
				//  if we allocated a kernel semaphore, unreference it

				if ( irksemAlloc != CKernelSemaphorePool::irksemNil )
					{
					ksempoolGlobal.Unreference( irksemAlloc );
					}

				//  wait for signal to be set
				
				State().StartWait();
				const BOOL fCompleted = ksempoolGlobal.Ksem( stateCur.Irksem(), this ).FAcquire( cmsecTimeout );
				State().StopWait();

				//  our wait completed

				if ( fCompleted )
					{
					//  unreference the kernel semaphore
				
					ksempoolGlobal.Unreference( stateCur.Irksem() );

					//  we successfully waited for the signal
					
					State().SetAcquire();
					return fTrue;
					}
					
				//  our wait timed out
				
				else
					{
					//  try forever until we successfully change the state of the signal

					OSSYNC_FOREVER
						{
						//  read the current state of the signal
						
						const CAutoResetSignalState stateAfterWait = (CAutoResetSignalState&) State();

						//  there are no waiters or the kernel semaphore currently
						//  in the signal is not the same as the one we waited on

						if ( stateAfterWait.FNoWait() || stateAfterWait.Irksem() != stateCur.Irksem() )
							{
							//  the kernel semaphore we waited on is no longer in
							//  use, so another context released it.  this means that
							//  there is a count on the kernel semaphore that we must
							//  absorb, so we will
							
							//  NOTE:  we could end up blocking because the releasing
							//  context may not have released the semaphore yet
							
							ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Acquire();

							//  unreference the kernel semaphore

							ksempoolGlobal.Unreference( stateCur.Irksem() );

							//  we successfully waited for the signal

							return fTrue;
							}

						//  there is one waiter and the kernel semaphore currently
						//  in the signal is the same as the one we waited on

						else if ( stateAfterWait.CWait() == 1 )
							{
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == stateCur.Irksem() );

							//  we successfully changed the signal to the reset with
							//  no waiters state
							
							if ( State().FChange( stateAfterWait, CAutoResetSignalState( 0 ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( stateCur.Irksem() );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}

						//  there are many waiters and the kernel semaphore currently
						//  in the signal is the same as the one we waited on

						else
							{
							OSSYNCAssert( stateAfterWait.CWait() > 1 );
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == stateCur.Irksem() );

							//  we successfully reduced the number of waiters on the
							//  signal by one
							
							if ( State().FChange( stateAfterWait, CAutoResetSignalState( stateAfterWait.CWait() - 1, stateAfterWait.Irksem() ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( stateCur.Irksem() );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}
						}
					}
				}

			//  unreference the kernel semaphore
				
			ksempoolGlobal.Unreference( stateCur.Irksem() );
			}
		}
	}

//  sets the signal, releasing up to one waiter.  if a waiter is released, then
//  the signal will be reset.  if a waiter is not released, the signal will
//  remain set

void CAutoResetSignal::_Set()
	{
	//  try forever until we successfully change the state of the signal
	
	OSSYNC_FOREVER
		{
		//  read the current state of the signal
		
		const CAutoResetSignalState stateCur = (CAutoResetSignalState&) State();

		//  there are no waiters

		if ( stateCur.FNoWait() )
			{
			//  we successfully changed the signal state from reset with no
			//  waiters to set or from set to set (a nop)
			
			if ( State().FSimpleSet() )
				{
				//  we're done
				
				return;
				}
			}

		//  there are waiters
		
		else
			{
			OSSYNCAssert( stateCur.FWait() );

			//  there is only one waiter

			if ( stateCur.CWait() == 1 )
				{
				//  we successfully changed the signal to the reset with no waiters state
				
				if ( State().FChange( stateCur, CAutoResetSignalState( 0 ) ) )
					{
					//  release the lone waiter
					
					ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Release();

					//  we're done
					
					return;
					}
				}

			//  there is more than one waiter
			
			else
				{
				OSSYNCAssert( stateCur.CWait() > 1 );

				//  we successfully reduced the number of waiters on the signal by one
				
				if ( State().FChange( stateCur, CAutoResetSignalState( stateCur.CWait() - 1, stateCur.Irksem() ) ) )
					{
					//  release one waiter
					
					ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Release();

					//  we're done
					
					return;
					}
				}
			}
		}
	}

//  resets the signal, releasing up to one waiter

void CAutoResetSignal::_Pulse()
	{
	//  try forever until we successfully change the state of the signal
	
	OSSYNC_FOREVER
		{
		//  read the current state of the signal
		
		const CAutoResetSignalState stateCur = (CAutoResetSignalState&) State();

		//  there are no waiters

		if ( stateCur.FNoWait() )
			{
			//  we successfully changed the signal state from set to reset with
			//  no waiters or from reset with no waiters to reset with no
			//  waiters (a nop)
			
			if ( State().FSimpleReset() )
				{
				//  we're done
				
				return;
				}
			}

		//  there are waiters
		
		else
			{
			OSSYNCAssert( stateCur.FWait() );

			//  there is only one waiter

			if ( stateCur.CWait() == 1 )
				{
				//  we successfully changed the signal to the reset with no waiters state
				
				if ( State().FChange( stateCur, CAutoResetSignalState( 0 ) ) )
					{
					//  release the lone waiter
					
					ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Release();

					//  we're done
					
					return;
					}
				}

			//  there is more than one waiter
			
			else
				{
				OSSYNCAssert( stateCur.CWait() > 1 );

				//  we successfully reduced the number of waiters on the signal by one
				
				if ( State().FChange( stateCur, CAutoResetSignalState( stateCur.CWait() - 1, stateCur.Irksem() ) ) )
					{
					//  release one waiter
					
					ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Release();

					//  we're done
					
					return;
					}
				}
			}
		}
	}


//  Manual-Reset Signal

//  ctor

CManualResetSignal::CManualResetSignal( const CSyncBasicInfo& sbi )
	:	CEnhancedStateContainer< CManualResetSignalState, CSyncStateInitNull, CManualResetSignalInfo, CSyncBasicInfo >( syncstateNull, sbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CManualResetSignal" );
	State().SetInstance( (CSyncObject*)this );
	}

//  dtor

CManualResetSignal::~CManualResetSignal()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	OSSyncStatsDump(	State().SzTypeName(),
						State().SzInstanceName(),
						State().Instance(),
						-1,
						State().CWaitTotal(),
						State().CsecWaitElapsed(),
						State().CAcquireTotal(),
						State().CContendTotal(),
						0,
						0 );

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  waits for the signal to be set, returning fFalse if unsuccessful in the time
//  permitted.  Infinite and Test-Only timeouts are supported.

const BOOL CManualResetSignal::_FWait( const int cmsecTimeout )
	{
	//  if we spin, we will spin for the full amount recommended by the OS
	
	int cSpin = cSpinMax;

	//  we start with no kernel semaphore allocated
	
	CKernelSemaphorePool::IRKSEM irksemAlloc = CKernelSemaphorePool::irksemNil;

	//  try forever until we successfully change the state of the signal
	
	OSSYNC_FOREVER
		{
		//  read the current state of the signal
		
		const CManualResetSignalState stateCur = (CManualResetSignalState&) State();

		//  the signal is set

		if ( stateCur.FNoWaitAndSet() )
			{
			//  if we allocated a kernel semaphore, release it
			
			if ( irksemAlloc != CKernelSemaphorePool::irksemNil )
				{
				ksempoolGlobal.Unreference( irksemAlloc );
				}

			//  we successfully waited for the signal

			State().SetAcquire();
			return fTrue;
			}

		//  the signal is not set and we still have spins left
		
		else if ( cSpin )
			{
			//  spin once and try again
			
			cSpin--;
			continue;
			}

		//  the signal is not set and there are no waiters
		
		else if ( stateCur.FNoWaitAndNotSet() )
			{
			//  allocate and reference a kernel semaphore if we haven't already
			
			if ( irksemAlloc == CKernelSemaphorePool::irksemNil )
				{
				irksemAlloc = ksempoolGlobal.Allocate( this );
				}

			//  we successfully installed ourselves as the first waiter
				
			if ( State().FChange( stateCur, CManualResetSignalState( 1, irksemAlloc ) ) )
				{
				//  wait for signal to be set
				
				State().StartWait();
				const BOOL fCompleted = ksempoolGlobal.Ksem( irksemAlloc, this ).FAcquire( cmsecTimeout );
				State().StopWait();

				//  our wait completed

				if ( fCompleted )
					{
					//  unreference the kernel semaphore
					
					ksempoolGlobal.Unreference( irksemAlloc );

					//  we successfully waited for the signal

					State().SetAcquire();
					return fTrue;
					}

				//  our wait timed out
				
				else
					{
					//  try forever until we successfully change the state of the signal

					OSSYNC_FOREVER
						{
						//  read the current state of the signal
						
						const CManualResetSignalState stateAfterWait = (CManualResetSignalState&) State();

						//  there are no waiters or the kernel semaphore currently
						//  in the signal is not the same as the one we allocated

						if ( stateAfterWait.FNoWait() || stateAfterWait.Irksem() != irksemAlloc )
							{
							//  the kernel semaphore we allocated is no longer in
							//  use, so another context released it.  this means that
							//  there is a count on the kernel semaphore that we must
							//  absorb, so we will
							
							//  NOTE:  we could end up blocking because the releasing
							//  context may not have released the semaphore yet
							
							ksempoolGlobal.Ksem( irksemAlloc, this ).Acquire();

							//  unreference the kernel semaphore

							ksempoolGlobal.Unreference( irksemAlloc );

							//  we successfully waited for the signal

							return fTrue;
							}

						//  there is one waiter and the kernel semaphore currently
						//  in the signal is the same as the one we allocated

						else if ( stateAfterWait.CWait() == 1 )
							{
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == irksemAlloc );

							//  we successfully changed the signal to the reset with
							//  no waiters state
							
							if ( State().FChange( stateAfterWait, CManualResetSignalState( 0 ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( irksemAlloc );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}

						//  there are many waiters and the kernel semaphore currently
						//  in the signal is the same as the one we allocated

						else
							{
							OSSYNCAssert( stateAfterWait.CWait() > 1 );
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == irksemAlloc );

							//  we successfully reduced the number of waiters on the
							//  signal by one
							
							if ( State().FChange( stateAfterWait, CManualResetSignalState( stateAfterWait.CWait() - 1, stateAfterWait.Irksem() ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( irksemAlloc );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}
						}
					}
				}
			}

		//  there are waiters
		
		else
			{
			OSSYNCAssert( stateCur.FWait() );

			//  reference the kernel semaphore already in use

			ksempoolGlobal.Reference( stateCur.Irksem() );

			//  we successfully added ourself as another waiter
			
			if ( State().FChange( stateCur, CManualResetSignalState( stateCur.CWait() + 1, stateCur.Irksem() ) ) )
				{
				//  if we allocated a kernel semaphore, unreference it

				if ( irksemAlloc != CKernelSemaphorePool::irksemNil )
					{
					ksempoolGlobal.Unreference( irksemAlloc );
					}

				//  wait for signal to be set
				
				State().StartWait();
				const BOOL fCompleted = ksempoolGlobal.Ksem( stateCur.Irksem(), this ).FAcquire( cmsecTimeout );
				State().StopWait();

				//  our wait completed

				if ( fCompleted )
					{
					//  unreference the kernel semaphore
				
					ksempoolGlobal.Unreference( stateCur.Irksem() );

					//  we successfully waited for the signal
					
					State().SetAcquire();
					return fTrue;
					}
					
				//  our wait timed out
				
				else
					{
					//  try forever until we successfully change the state of the signal

					OSSYNC_FOREVER
						{
						//  read the current state of the signal
						
						const CManualResetSignalState stateAfterWait = (CManualResetSignalState&) State();

						//  there are no waiters or the kernel semaphore currently
						//  in the signal is not the same as the one we waited on

						if ( stateAfterWait.FNoWait() || stateAfterWait.Irksem() != stateCur.Irksem() )
							{
							//  the kernel semaphore we waited on is no longer in
							//  use, so another context released it.  this means that
							//  there is a count on the kernel semaphore that we must
							//  absorb, so we will
							
							//  NOTE:  we could end up blocking because the releasing
							//  context may not have released the semaphore yet
							
							ksempoolGlobal.Ksem( stateCur.Irksem(), this ).Acquire();

							//  unreference the kernel semaphore

							ksempoolGlobal.Unreference( stateCur.Irksem() );

							//  we successfully waited for the signal

							return fTrue;
							}

						//  there is one waiter and the kernel semaphore currently
						//  in the signal is the same as the one we waited on

						else if ( stateAfterWait.CWait() == 1 )
							{
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == stateCur.Irksem() );

							//  we successfully changed the signal to the reset with
							//  no waiters state
							
							if ( State().FChange( stateAfterWait, CManualResetSignalState( 0 ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( stateCur.Irksem() );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}

						//  there are many waiters and the kernel semaphore currently
						//  in the signal is the same as the one we waited on

						else
							{
							OSSYNCAssert( stateAfterWait.CWait() > 1 );
							OSSYNCAssert( stateAfterWait.FWait() );
							OSSYNCAssert( stateAfterWait.Irksem() == stateCur.Irksem() );

							//  we successfully reduced the number of waiters on the
							//  signal by one
							
							if ( State().FChange( stateAfterWait, CManualResetSignalState( stateAfterWait.CWait() - 1, stateAfterWait.Irksem() ) ) )
								{
								//  unreference the kernel semaphore

								ksempoolGlobal.Unreference( stateCur.Irksem() );

								//  we did not successfully wait for the signal

								return fFalse;
								}
							}
						}
					}
				}

			//  unreference the kernel semaphore
				
			ksempoolGlobal.Unreference( stateCur.Irksem() );
			}
		}
	}


//  Lock Object Basic Information

//  ctor

CLockBasicInfo::CLockBasicInfo( const CSyncBasicInfo& sbi, const int rank, const int subrank )
	:	CSyncBasicInfo( sbi )
	{
#ifdef SYNC_DEADLOCK_DETECTION

	m_rank			= rank;
	m_subrank		= subrank;

#endif  //  SYNC_DEADLOCK_DETECTION
	}

//  dtor

CLockBasicInfo::~CLockBasicInfo()
	{
	}
	

//  Lock Object Performance:  Hold

//  ctor

CLockPerfHold::CLockPerfHold()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	m_cHold = 0;
	m_qwHRTHoldElapsed = 0;

#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  dtor

CLockPerfHold::~CLockPerfHold()
	{
	}


//  Lock Owner Record

//  ctor

COwner::COwner()
	{
#ifdef SYNC_DEADLOCK_DETECTION

	m_pclsOwner			= NULL;
	m_pownerContextNext	= NULL;
	m_plddiOwned		= NULL;
	m_pownerLockNext	= NULL;
	m_group				= 0;
	
#endif  //  SYNC_DEADLOCK_DETECTION
	}

//  dtor

COwner::~COwner()
	{
	}


//  Lock Object Deadlock Detection Information

//  ctor

#ifdef SYNC_DEADLOCK_DETECTION

CLockDeadlockDetectionInfo::CLockDeadlockDetectionInfo( const CLockBasicInfo& lbi )
	:	m_semOwnerList( CSyncBasicInfo( "CLockDeadlockDetectionInfo::m_semOwnerList" ) )
	{
	m_plbiParent = &lbi;
	m_semOwnerList.Release();
	}

#else  //  !SYNC_DEADLOCK_DETECTION

CLockDeadlockDetectionInfo::CLockDeadlockDetectionInfo( const CLockBasicInfo& lbi )
	{
	}

#endif  //  SYNC_DEADLOCK_DETECTION

//  dtor

CLockDeadlockDetectionInfo::~CLockDeadlockDetectionInfo()
	{
	}


//  Critical Section (non-nestable) State

//  ctor

CCriticalSectionState::CCriticalSectionState( const CSyncBasicInfo& sbi )
	:	m_sem( sbi )
	{
	}

//  dtor

CCriticalSectionState::~CCriticalSectionState()
	{
	}


//  Critical Section (non-nestable)

//  ctor

CCriticalSection::CCriticalSection( const CLockBasicInfo& lbi )
	:	CEnhancedStateContainer< CCriticalSectionState, CSyncBasicInfo, CCriticalSectionInfo, CLockBasicInfo >( (CSyncBasicInfo&) lbi, lbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CCriticalSection" );
	State().SetInstance( (CSyncObject*)this );
	
	//  release semaphore

	State().Semaphore().Release();
	}

//  dtor

CCriticalSection::~CCriticalSection()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	OSSyncStatsDump(	State().SzTypeName(),
						State().SzInstanceName(),
						State().Instance(),
						-1,
						0,
						0,
						0,
						0,
						State().CHoldTotal(),
						State().CsecHoldElapsed() );

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}


//  Nestable Critical Section State

//  ctor

CNestableCriticalSectionState::CNestableCriticalSectionState( const CSyncBasicInfo& sbi )
	:	m_sem( sbi ),
		m_pclsOwner( 0 ),
		m_cEntry( 0 )
	{
	}

//  dtor

CNestableCriticalSectionState::~CNestableCriticalSectionState()
	{
	}


//  Nestable Critical Section

//  ctor

CNestableCriticalSection::CNestableCriticalSection( const CLockBasicInfo& lbi )
	:	CEnhancedStateContainer< CNestableCriticalSectionState, CSyncBasicInfo, CNestableCriticalSectionInfo, CLockBasicInfo >( (CSyncBasicInfo&) lbi, lbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CNestableCriticalSection" );
	State().SetInstance( (CSyncObject*)this );
	
	//  release semaphore

	State().Semaphore().Release();
	}

//  dtor

CNestableCriticalSection::~CNestableCriticalSection()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	OSSyncStatsDump(	State().SzTypeName(),
						State().SzInstanceName(),
						State().Instance(),
						-1,
						0,
						0,
						0,
						0,
						State().CHoldTotal(),
						State().CsecHoldElapsed() );

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}


//  Gate State

//  ctor

CGateState::CGateState( const int cWait, const int irksem )
	{
	//  validate IN args
	
	OSSYNCAssert( cWait >= 0 );
	OSSYNCAssert( cWait <= 0x7FFF );
	OSSYNCAssert( irksem >= 0 );
	OSSYNCAssert( irksem <= 0xFFFE );

	//  set waiter count
	
	m_cWait = (unsigned short) cWait;

	//  set semaphore
	
	m_irksem = (unsigned short) irksem;
	}


//  Gate

//  ctor

CGate::CGate( const CSyncBasicInfo& sbi )
	:	CEnhancedStateContainer< CGateState, CSyncStateInitNull, CGateInfo, CSyncBasicInfo >( syncstateNull, sbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CGate" );
	State().SetInstance( (CSyncObject*)this );
	}

//  dtor

CGate::~CGate()
	{
	//  no one should be waiting

	// if a thread waiting is killed, the CWait() can be != 0
	// OSSYNCAssert( State().CWait() == 0 );
	
	//OSSYNCAssert( State().Irksem() == CKernelSemaphorePool::irksemNil );

#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	OSSyncStatsDump(	State().SzTypeName(),
						State().SzInstanceName(),
						State().Instance(),
						-1,
						State().CWaitTotal(),
						State().CsecWaitElapsed(),
						0,
						0,
						0,
						0 );

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  waits forever on the gate until released by someone else.  this function
//  expects to be called while in the specified critical section.  when the
//  function returns, the caller will NOT be in the critical section

void CGate::Wait( CCriticalSection& crit )
	{
	//  we must be in the specified critical section

	OSSYNCAssert( crit.FOwner() );

	//  there can not be too many waiters on the gate

	OSSYNCAssert( State().CWait() < 0x7FFF );
	
	//  add ourselves as a waiter

	const int cWait = State().CWait() + 1;
	State().SetWaitCount( cWait );

	//  we are the first waiter

	CKernelSemaphorePool::IRKSEM irksem;
#ifdef DEBUG
	irksem = CKernelSemaphorePool::irksemNil;
#endif  //  DEBUG
	if ( cWait == 1 )
		{
		//  allocate a semaphore for the gate and remember it before leaving
		//  the critical section

		OSSYNCAssert( State().Irksem() == CKernelSemaphorePool::irksemNil );
		irksem = ksempoolGlobal.Allocate( this );
		State().SetIrksem( irksem );
		}

	//  we are not the first waiter

	else
		{
		//  reference the semaphore already in the gate and remember it before
		//  leaving the critical section

		OSSYNCAssert( State().Irksem() != CKernelSemaphorePool::irksemNil );
		irksem = State().Irksem();
		ksempoolGlobal.Reference( irksem );
		}
	OSSYNCAssert( irksem != CKernelSemaphorePool::irksemNil );

	//  leave critical section, never to return

	crit.Leave();

	//  wait to be released

	State().StartWait();
	ksempoolGlobal.Ksem( irksem, this ).Acquire();
	State().StopWait();

	//  unreference the semaphore

	ksempoolGlobal.Unreference( irksem );
	}

//  releases the specified number of waiters from the gate.  this function
//  expects to be called while in the specified critical section.  when the
//  function returns, the caller will NOT be in the critical section
//
//  NOTE:  it is illegal to release more waiters than are waiting on the gate
//         and it is also illegal to release less than one waiter

void CGate::Release( CCriticalSection& crit, const int cToRelease )
	{
	//  we must be in the specified critical section

	OSSYNCAssert( crit.FOwner() );

	//  you must release at least one waiter

	OSSYNCAssert( cToRelease > 0 );
	
	//  we cannot release more waiters than are waiting on the gate

	OSSYNCAssert( cToRelease <= State().CWait() );

	//  reduce the waiter count

	State().SetWaitCount( State().CWait() - cToRelease );

	//  remember semaphore to release before leaving the critical section

	const CKernelSemaphorePool::IRKSEM irksem = State().Irksem();

#ifdef DEBUG

	//  we released all the waiters

	if ( State().CWait() == 0 )
		{
		//  set the semaphore to nil

		State().SetIrksem( CKernelSemaphorePool::irksemNil );
		}

#endif  //  DEBUG

	//  leave critical section, never to return

	crit.Leave();

	//  release the specified number of waiters

	ksempoolGlobal.Ksem( irksem, this ).Release( cToRelease );
	}

//  releases the specified number of waiters from the gate.  this function
//  expects to be called while in the specified critical section.  it is
//  guaranteed that the caller will remain in the critical section at all times
//
//  NOTE:  it is illegal to release more waiters than are waiting on the gate
//         and it is also illegal to release less than one waiter

void CGate::ReleaseAndHold( CCriticalSection& crit, const int cToRelease )
	{
	//  we must be in the specified critical section

	OSSYNCAssert( crit.FOwner() );

	//  you must release at least one waiter

	OSSYNCAssert( cToRelease > 0 );
	
	//  we cannot release more waiters than are waiting on the gate

	OSSYNCAssert( cToRelease <= State().CWait() );

	//  reduce the waiter count

	State().SetWaitCount( State().CWait() - cToRelease );

	//  remember semaphore to release before leaving the critical section

	const CKernelSemaphorePool::IRKSEM irksem = State().Irksem();

#ifdef DEBUG

	//  we released all the waiters

	if ( State().CWait() == 0 )
		{
		//  set the semaphore to nil

		State().SetIrksem( CKernelSemaphorePool::irksemNil );
		}

#endif  //  DEBUG

	//  release the specified number of waiters

	ksempoolGlobal.Ksem( irksem, this ).Release( cToRelease );
	}


//  Null Lock Object State Initializer

const CLockStateInitNull lockstateNull;


//  Binary Lock State

//  ctor

CBinaryLockState::CBinaryLockState( const CSyncBasicInfo& sbi )
	:	m_cw( 0 ),
		m_cOwner( 0 ),
		m_sem1( sbi ),
		m_sem2( sbi )
	{
	}

//  dtor

CBinaryLockState::~CBinaryLockState()
	{
	}


//  Binary Lock

//  ctor

CBinaryLock::CBinaryLock( const CLockBasicInfo& lbi )
	:	CEnhancedStateContainer< CBinaryLockState, CSyncBasicInfo, CBinaryLockInfo, CLockBasicInfo >( (CSyncBasicInfo&) lbi, lbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CBinaryLock" );
	State().SetInstance( (CSyncObject*)this );
	}

//  dtor
	
CBinaryLock::~CBinaryLock()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	for ( int iGroup = 0; iGroup < 2; iGroup++ )
		{
		OSSyncStatsDump(	State().SzTypeName(),
							State().SzInstanceName(),
							State().Instance(),
							iGroup,
							State().CWaitTotal( iGroup ),
							State().CsecWaitElapsed( iGroup ),
							State().CAcquireTotal( iGroup ),
							State().CContendTotal( iGroup ),
							State().CHoldTotal( iGroup ),
							State().CsecHoldElapsed( iGroup ) );
		}

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  maps an arbitrary combination of zero and non-zero components into a
//  valid state number of the invalid state number (-1)

const int mpindexstate[16] =
	{
	 0, -1, -1, -1,
	-1, -1,  1, -1,
	-1,  2, -1,  3,
	-1, -1,  4,  5,
	};

//  returns the state number of the specified control word or -1 if it is not
//  a legal state

int CBinaryLock::_StateFromControlWord( const ControlWord cw )
	{
	//  convert the control word into a state index

	int index = 0;
	index = index | ( ( cw & 0x80000000 ) ? 8 : 0 );
	index = index | ( ( cw & 0x7FFF0000 ) ? 4 : 0 );
	index = index | ( ( cw & 0x00008000 ) ? 2 : 0 );
	index = index | ( ( cw & 0x00007FFF ) ? 1 : 0 );

	//  convert the state index into a state number

	const int state = mpindexstate[index];

	//  return the computed state number

	return state;
	}

//  state transition reachability matrix (starting state is the major axis)
//
//  each entry contains bits representing valid reasons for making the
//  transition (made by oring together the valid TransitionReasons)

#define NO	CBinaryLock::trIllegal
#define E1	CBinaryLock::trEnter1
#define L1	CBinaryLock::trLeave1
#define E2	CBinaryLock::trEnter2
#define L2	CBinaryLock::trLeave2

const DWORD mpstatestatetrmask[6][6] =
	{
		{ NO, E2, E1, NO, NO, NO, },
		{ L2, E2 | L2, NO, E1, NO, NO, },
		{ L1, NO, E1 | L1, NO, E2, NO, },
		{ NO, NO, L2, E1 | L2, NO, E2, },
		{ NO, L1, NO, NO, L1 | E2, E1, },
		{ NO, NO, NO, L1, L2, E1 | L1 | E2 | L2, },
	};

#undef NO
#undef E1
#undef L1
#undef E2
#undef L2

//  returns fTrue if the specified control word is in a legal state

BOOL CBinaryLock::_FValidStateTransition( const ControlWord cwBI, const ControlWord cwAI, const TransitionReason tr )
	{
	//  convert the specified control words into state numbers

	const int stateBI = _StateFromControlWord( cwBI );
	const int stateAI = _StateFromControlWord( cwAI );

	//  if either state is invalid, the transition is invalid

	if ( stateBI < 0 || stateAI < 0 )
		{
		return fFalse;
		}

	//  verify that cOOW2 and cOOW1 only change by +1, 0, -1, or go to 0

	const long dcOOW2 = ( ( cwAI & 0x7FFF0000 ) >> 16 ) - ( ( cwBI & 0x7FFF0000 ) >> 16 );
	if ( ( dcOOW2 < -1 || dcOOW2 > 1 ) && ( cwAI & 0x7FFF0000 ) != 0 )
		{
		return fFalse;
		}

	const long dcOOW1 = ( cwAI & 0x00007FFF ) - ( cwBI & 0x00007FFF );
	if ( ( dcOOW1 < -1 || dcOOW1 > 1 ) && ( cwAI & 0x00007FFF ) != 0 )
		{
		return fFalse;
		}

	//  return the reachability of stateAI from stateBI

	OSSYNCAssert( tr == trEnter1 || tr == trLeave1 || tr == trEnter2 || tr == trLeave2 );
	return ( mpstatestatetrmask[stateBI][stateAI] & tr ) != 0;
	}

//  wait for ownership of the lock as a member of Group 1

void CBinaryLock::_Enter1( const ControlWord cwBIOld )
	{
	//  we just jumped from state 1 to state 3

	if ( ( cwBIOld & 0x80008000 ) == 0x00008000 )
		{
		//  update the quiesced owner count with the owner count that we displaced from
		//  the control word, possibly releasing waiters.  we update the count as if we
		//  were a member of Group 2 as members of Group 1 can be released

		_UpdateQuiescedOwnerCountAsGroup2( ( cwBIOld & 0x7FFF0000 ) >> 16 );
		}

	//  wait for ownership of the lock on our semaphore

	State().AddAsWaiter( 0 );
	State().StartWait( 0 );
	
	State().m_sem1.Acquire();
	
	State().StopWait( 0 );
	State().RemoveAsWaiter( 0 );
	}

//  wait for ownership of the lock as a member of Group 2

void CBinaryLock::_Enter2( const ControlWord cwBIOld )
	{
	//  we just jumped from state 2 to state 4

	if ( ( cwBIOld & 0x80008000 ) == 0x80000000 )
		{
		//  update the quiesced owner count with the owner count that we displaced from
		//  the control word, possibly releasing waiters.  we update the count as if we
		//  were a member of Group 1 as members of Group 2 can be released

		_UpdateQuiescedOwnerCountAsGroup1( cwBIOld & 0x00007FFF );
		}

	//  wait for ownership of the lock on our semaphore

	State().AddAsWaiter( 1 );
	State().StartWait( 1 );
	
	State().m_sem2.Acquire();
	
	State().StopWait( 1 );
	State().RemoveAsWaiter( 1 );
	}

//  updates the quiesced owner count as a member of Group 1

void CBinaryLock::_UpdateQuiescedOwnerCountAsGroup1( const DWORD cOwnerDelta )
	{
	//  update the quiesced owner count using the provided delta

	const DWORD cOwnerBI = AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDelta );
	const DWORD cOwnerAI = cOwnerBI + cOwnerDelta;

	//  our update resulted in a zero quiesced owner count

	if ( !cOwnerAI )
		{
		//  we must release the waiters for Group 2 because we removed the last
		//  quiesced owner count

		//  try forever until we successfully change the lock state

		ControlWord cwBI;
		OSSYNC_FOREVER
			{
			//  read the current state of the control word as our expected before image

			const ControlWord cwBIExpected = State().m_cw;

			//  compute the after image of the control word such that we jump from state
			//  state 4 to state 1 or from state 5 to state 3, whichever is appropriate

			const ControlWord cwAI =	ControlWord( cwBIExpected &
										( ( ( LONG_PTR( long( ( cwBIExpected + 0xFFFF7FFF ) << 16 ) ) >> 31 ) &
										0xFFFF0000 ) ^ 0x8000FFFF ) );

			//  validate the transaction

			OSSYNCAssert( _FValidStateTransition( cwBIExpected, cwAI, trLeave1 ) );

			//  attempt to perform the transacted state transition on the control word

			cwBI = AtomicCompareExchange( (long*)&State().m_cw, cwBIExpected, cwAI );

			//  the transaction failed because another context changed the control word

			if ( cwBI != cwBIExpected )
				{
				//  try again

				continue;
				}

			//  the transaction succeeded

			else
				{
				//  we're done

				break;
				}
			}

		//  we just jumped from state 5 to state 3

		if ( cwBI & 0x00007FFF )
			{
			//  update the quiesced owner count with the owner count that we displaced
			//  from the control word
			//
			//  NOTE:  we do not have to worry about releasing any more waiters because
			//  either this context owns one of the owner counts or at least one context
			//  that owns an owner count are currently blocked on the semaphore

			const DWORD cOwnerDelta = ( cwBI & 0x7FFF0000 ) >> 16;
			AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDelta );
			}

		//  release the waiters for Group 2 that we removed from the lock state

		State().m_sem2.Release( ( cwBI & 0x7FFF0000 ) >> 16 );
		}
	}

//  updates the quiesced owner count as a member of Group 2

void CBinaryLock::_UpdateQuiescedOwnerCountAsGroup2( const DWORD cOwnerDelta )
	{
	//  update the quiesced owner count using the provided delta

	const DWORD cOwnerBI = AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDelta );
	const DWORD cOwnerAI = cOwnerBI + cOwnerDelta;

	//  our update resulted in a zero quiesced owner count

	if ( !cOwnerAI )
		{
		//  we must release the waiters for Group 1 because we removed the last
		//  quiesced owner count

		//  try forever until we successfully change the lock state

		ControlWord cwBI;
		OSSYNC_FOREVER
			{
			//  read the current state of the control word as our expected before image

			const ControlWord cwBIExpected = State().m_cw;

			//  compute the after image of the control word such that we jump from state
			//  state 3 to state 2 or from state 5 to state 4, whichever is appropriate

			const ControlWord cwAI =	ControlWord( cwBIExpected &
										( ( ( LONG_PTR( long( cwBIExpected + 0x7FFF0000 ) ) >> 31 ) &
										0x0000FFFF ) ^ 0xFFFF8000 ) );

			//  validate the transaction

			OSSYNCAssert( _FValidStateTransition( cwBIExpected, cwAI, trLeave2 ) );

			//  attempt to perform the transacted state transition on the control word

			cwBI = AtomicCompareExchange( (long*)&State().m_cw, cwBIExpected, cwAI );

			//  the transaction failed because another context changed the control word

			if ( cwBI != cwBIExpected )
				{
				//  try again

				continue;
				}

			//  the transaction succeeded

			else
				{
				//  we're done

				break;
				}
			}

		//  we just jumped from state 5 to state 4

		if ( cwBI & 0x7FFF0000 )
			{
			//  update the quiesced owner count with the owner count that we displaced
			//  from the control word
			//
			//  NOTE:  we do not have to worry about releasing any more waiters because
			//  either this context owns one of the owner counts or at least one context
			//  that owns an owner count are currently blocked on the semaphore

			const DWORD cOwnerDelta = cwBI & 0x00007FFF;
			AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDelta );
			}

		//  release the waiters for Group 1 that we removed from the lock state

		State().m_sem1.Release( cwBI & 0x00007FFF );
		}
	}


//  Reader / Writer Lock State

//  ctor

CReaderWriterLockState::CReaderWriterLockState( const CSyncBasicInfo& sbi )
	:	m_cw( 0 ),
		m_cOwner( 0 ),
		m_semWriter( sbi ),
		m_semReader( sbi )
	{
	}

//  dtor

CReaderWriterLockState::~CReaderWriterLockState()
	{
	}


//  Reader / Writer Lock


//  ctor

CReaderWriterLock::CReaderWriterLock( const CLockBasicInfo& lbi )
	:	CEnhancedStateContainer< CReaderWriterLockState, CSyncBasicInfo, CReaderWriterLockInfo, CLockBasicInfo >( (CSyncBasicInfo&) lbi, lbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CReaderWriterLock" );
	State().SetInstance( (CSyncObject*)this );
	}

//  dtor
	
CReaderWriterLock::~CReaderWriterLock()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	for ( int iGroup = 0; iGroup < 2; iGroup++ )
		{
		OSSyncStatsDump(	State().SzTypeName(),
							State().SzInstanceName(),
							State().Instance(),
							iGroup,
							State().CWaitTotal( iGroup ),
							State().CsecWaitElapsed( iGroup ),
							State().CAcquireTotal( iGroup ),
							State().CContendTotal( iGroup ),
							State().CHoldTotal( iGroup ),
							State().CsecHoldElapsed( iGroup ) );
		}

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  maps an arbitrary combination of zero and non-zero components into a
//  valid state number of the invalid state number (-1)

const int mpindexstateRW[16] =
	{
	 0, -1, -1, -1,
	-1, -1,  1, -1,
	-1,  2, -1,  3,
	-1, -1,  4,  5,
	};

//  returns the state number of the specified control word or -1 if it is not
//  a legal state

int CReaderWriterLock::_StateFromControlWord( const ControlWord cw )
	{
	//  convert the control word into a state index

	int index = 0;
	index = index | ( ( cw & 0x80000000 ) ? 8 : 0 );
	index = index | ( ( cw & 0x7FFF0000 ) ? 4 : 0 );
	index = index | ( ( cw & 0x00008000 ) ? 2 : 0 );
	index = index | ( ( cw & 0x00007FFF ) ? 1 : 0 );

	//  convert the state index into a state number

	const int state = mpindexstateRW[index];

	//  return the computed state number

	return state;
	}

//  state transition reachability matrix (starting state is the major axis)
//
//  each entry contains bits representing valid reasons for making the
//  transition (made by oring together the valid TransitionReasons)

#define NO	CReaderWriterLock::trIllegal
#define EW	CReaderWriterLock::trEnterAsWriter
#define LW	CReaderWriterLock::trLeaveAsWriter
#define ER	CReaderWriterLock::trEnterAsReader
#define LR	CReaderWriterLock::trLeaveAsReader

const DWORD mpstatestatetrmaskRW[6][6] =
	{
		{ NO, ER, EW, NO, NO, NO, },
		{ LR, ER | LR, NO, EW, NO, NO, },
		{ LW, NO, EW | LW, NO, ER, ER, },
		{ NO, NO, LR, EW | LR, NO, ER, },
		{ NO, LW, NO, NO, ER, EW, },
		{ NO, NO, NO, LW, LR, EW | ER | LR, },
	};

#undef NO
#undef EW
#undef LW
#undef ER
#undef LR

//  returns fTrue if the specified control word is in a legal state

BOOL CReaderWriterLock::_FValidStateTransition( const ControlWord cwBI, const ControlWord cwAI, const TransitionReason tr )
	{
	//  convert the specified control words into state numbers

	const int stateBI = _StateFromControlWord( cwBI );
	const int stateAI = _StateFromControlWord( cwAI );

	//  if either state is invalid, the transition is invalid

	if ( stateBI < 0 || stateAI < 0 )
		{
		return fFalse;
		}

	//  verify that cOOW2 and cOOW1 only change by +1, 0, -1, or cOOW2 can go to 0

	const long dcOOW2 = ( ( cwAI & 0x7FFF0000 ) >> 16 ) - ( ( cwBI & 0x7FFF0000 ) >> 16 );
	if ( ( dcOOW2 < -1 || dcOOW2 > 1 ) && ( cwAI & 0x7FFF0000 ) != 0 )
		{
		return fFalse;
		}

	const long dcOOW1 = ( cwAI & 0x00007FFF ) - ( cwBI & 0x00007FFF );
	if ( dcOOW1 < -1 || dcOOW1 > 1 )
		{
		return fFalse;
		}

	//  return the reachability of stateAI from stateBI

	OSSYNCAssert(	tr == trEnterAsWriter ||
			tr == trLeaveAsWriter ||
			tr == trEnterAsReader ||
			tr == trLeaveAsReader );
	return ( mpstatestatetrmaskRW[stateBI][stateAI] & tr ) != 0;
	}

//  wait for ownership of the lock as a writer

void CReaderWriterLock::_EnterAsWriter( const ControlWord cwBIOld )
	{
	//  we just jumped from state 1 to state 3

	if ( ( cwBIOld & 0x80008000 ) == 0x00008000 )
		{
		//  update the quiesced owner count with the owner count that we displaced from
		//  the control word, possibly releasing a waiter.  we update the count as if we
		//  were a reader as a writer can be released

		_UpdateQuiescedOwnerCountAsReader( ( cwBIOld & 0x7FFF0000 ) >> 16 );
		}

	//  wait for ownership of the lock on our semaphore

	State().AddAsWaiter( 0 );
	State().StartWait( 0 );
	
	State().m_semWriter.Acquire();
	
	State().StopWait( 0 );
	State().RemoveAsWaiter( 0 );
	}

//  wait for ownership of the lock as a reader

void CReaderWriterLock::_EnterAsReader( const ControlWord cwBIOld )
	{
	//  we just jumped from state 2 to state 4 or from state 2 to state 5

	if ( ( cwBIOld & 0x80008000 ) == 0x80000000 )
		{
		//  update the quiesced owner count with the owner count that we displaced from
		//  the control word, possibly releasing waiters.  we update the count as if we
		//  were a writer as readers can be released

		_UpdateQuiescedOwnerCountAsWriter( 0x00000001 );
		}

	//  wait for ownership of the lock on our semaphore

	State().AddAsWaiter( 1 );
	State().StartWait( 1 );
	
	State().m_semReader.Acquire();
	
	State().StopWait( 1 );
	State().RemoveAsWaiter( 1 );
	}

//  updates the quiesced owner count as a writer

void CReaderWriterLock::_UpdateQuiescedOwnerCountAsWriter( const DWORD cOwnerDelta )
	{
	//  update the quiesced owner count using the provided delta

	const DWORD cOwnerBI = AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDelta );
	const DWORD cOwnerAI = cOwnerBI + cOwnerDelta;

	//  our update resulted in a zero quiesced owner count

	if ( !cOwnerAI )
		{
		//  we must release the waiting readers because we removed the last
		//  quiesced owner count

		//  try forever until we successfully change the lock state

		ControlWord cwBI;
		OSSYNC_FOREVER
			{
			//  read the current state of the control word as our expected before image

			const ControlWord cwBIExpected = State().m_cw;

			//  compute the after image of the control word such that we jump from state
			//  state 4 to state 1 or from state 5 to state 3, whichever is appropriate

			const ControlWord cwAI =	ControlWord( cwBIExpected &
										( ( ( LONG_PTR( long( ( cwBIExpected + 0xFFFF7FFF ) << 16 ) ) >> 31 ) &
										0xFFFF0000 ) ^ 0x8000FFFF ) );

			//  validate the transaction

			OSSYNCAssert( _FValidStateTransition( cwBIExpected, cwAI, trLeaveAsWriter ) );

			//  attempt to perform the transacted state transition on the control word

			cwBI = AtomicCompareExchange( (long*)&State().m_cw, cwBIExpected, cwAI );

			//  the transaction failed because another context changed the control word

			if ( cwBI != cwBIExpected )
				{
				//  try again

				continue;
				}

			//  the transaction succeeded

			else
				{
				//  we're done

				break;
				}
			}

		//  we just jumped from state 5 to state 3

		if ( cwBI & 0x00007FFF )
			{
			//  update the quiesced owner count with the owner count that we displaced
			//  from the control word
			//
			//  NOTE:  we do not have to worry about releasing any more waiters because
			//  either this context owns one of the owner counts or at least one context
			//  that owns an owner count are currently blocked on the semaphore

			const DWORD cOwnerDelta = ( cwBI & 0x7FFF0000 ) >> 16;
			AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDelta );
			}

		//  release the waiting readers that we removed from the lock state

		State().m_semReader.Release( ( cwBI & 0x7FFF0000 ) >> 16 );
		}
	}

//  updates the quiesced owner count as a reader

void CReaderWriterLock::_UpdateQuiescedOwnerCountAsReader( const DWORD cOwnerDelta )
	{
	//  update the quiesced owner count using the provided delta

	const DWORD cOwnerBI = AtomicExchangeAdd( (long*)&State().m_cOwner, cOwnerDelta );
	const DWORD cOwnerAI = cOwnerBI + cOwnerDelta;

	//  our update resulted in a zero quiesced owner count

	if ( !cOwnerAI )
		{
		//  we must release a waiting writer because we removed the last
		//  quiesced owner count

		//  try forever until we successfully change the lock state

		ControlWord cwBI;
		OSSYNC_FOREVER
			{
			//  read the current state of the control word as our expected before image

			const ControlWord cwBIExpected = State().m_cw;

			//  compute the after image of the control word such that we jump from state
			//  state 3 to state 2, from state 5 to state 4, or from state 5 to state 5,
			//  whichever is appropriate

			const ControlWord cwAI =	cwBIExpected + ( ( cwBIExpected & 0x7FFF0000 ) ?
											0xFFFFFFFF :
											0xFFFF8000 );

			//  validate the transaction

			OSSYNCAssert( _FValidStateTransition( cwBIExpected, cwAI, trLeaveAsReader ) );

			//  attempt to perform the transacted state transition on the control word

			cwBI = AtomicCompareExchange( (long*)&State().m_cw, cwBIExpected, cwAI );

			//  the transaction failed because another context changed the control word

			if ( cwBI != cwBIExpected )
				{
				//  try again

				continue;
				}

			//  the transaction succeeded

			else
				{
				//  we're done

				break;
				}
			}

		//  we just jumped from state 5 to state 4 or from state 5 to state 5

		if ( cwBI & 0x7FFF0000 )
			{
			//  update the quiesced owner count with the owner count that we displaced
			//  from the control word
			//
			//  NOTE:  we do not have to worry about releasing any more waiters because
			//  either this context owns one of the owner counts or at least one context
			//  that owns an owner count are currently blocked on the semaphore

			AtomicExchangeAdd( (long*)&State().m_cOwner, 1 );
			}

		//  release the waiting writer that we removed from the lock state

		State().m_semWriter.Release();
		}
	}


//  S / X / W Latch State

//  ctor

CSXWLatchState::CSXWLatchState( const CSyncBasicInfo& sbi )
	:	m_cw( 0 ),
		m_cQS( 0 ),
		m_semS( sbi ),
		m_semX( sbi ),
		m_semW( sbi )
	{
	}

//  dtor

CSXWLatchState::~CSXWLatchState()
	{
	}


//  S / X / W Latch


//  ctor

CSXWLatch::CSXWLatch( const CLockBasicInfo& lbi )
	:	CEnhancedStateContainer< CSXWLatchState, CSyncBasicInfo, CSXWLatchInfo, CLockBasicInfo >( (CSyncBasicInfo&) lbi, lbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CSXWLatch" );
	State().SetInstance( (CSyncObject*)this );
	}

//  dtor
	
CSXWLatch::~CSXWLatch()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	for ( int iGroup = 0; iGroup < 3; iGroup++ )
		{
		OSSyncStatsDump(	State().SzTypeName(),
							State().SzInstanceName(),
							State().Instance(),
							iGroup,
							State().CWaitTotal( iGroup ),
							State().CsecWaitElapsed( iGroup ),
							State().CAcquireTotal( iGroup ),
							State().CContendTotal( iGroup ),
							State().CHoldTotal( iGroup ),
							State().CsecHoldElapsed( iGroup ) );
		}

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}


};  //  namespace OSSYNC


//////////////////////////////////////////////////
//  Everything below this line is OS dependent


#include <nt.h>
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif  //  WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <imagehlp.h>
#include <wdbgexts.h>

#include <math.h>
#include <process.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <tchar.h>

namespace OSSYNC {


//  Global Synchronization Constants

//    wait time used for testing the state of the kernel object

const int cmsecTest = 0;

//    wait time used for infinite wait on a kernel object

const int cmsecInfinite = INFINITE;

//    maximum wait time on a kernel object before a deadlock is suspected

const int cmsecDeadlock = 600000;

//    wait time used for infinite wait on a kernel object without deadlock

const int cmsecInfiniteNoDeadlock = INFINITE - 1;

//    cache line size
//
//		the following chart describes cache-line configurations for each supported
//		architecture.
//
//		cache line size			= read size (prefetch)
//		cache line sector size	= write size (flush)
//
//
//		Pocessor	Cache Line Size		Cache Line Sector Size
//
//		Pentium			16B					16B
//		PPro			32B					32B
//		PII				32B					32B
//		PIII			32B					32B
//		AXP				64B					64B
//		Willamette		128B				64B
//		Merced			128B?				128B?
//
//		NOTE:	when changing this, you must fix all structures/classes whose definitions
//			 	are based on its present value
//				(e.g. the object has space rsvd as filler for the rest of the cache line)

const int cbCacheLine = 32;


//  Page Memory Allocation

//  reserves and commits a range of virtual addresses of the specifed size,
//  returning NULL if there is insufficient address space or backing store to
//  satisfy the request.  Note that the page reserve granularity applies to
//  this range

void* PvPageAlloc( const size_t cbSize, void* const pv )
	{
	//  allocate address space and backing store of the specified size

	void* const pvRet = VirtualAlloc( pv, cbSize, MEM_COMMIT, PAGE_READWRITE );
	if ( !pvRet )
		{
		return pvRet;
		}
	OSSYNCAssert( !pv || pvRet == pv );

	return pvRet;
	}

//  free the reserved range of virtual addresses starting at the specified
//  address, freeing any backing store committed to this range

void PageFree( void* const pv )
	{
	if ( pv )
		{
		//  free backing store and address space for the specified range

		BOOL fMemFreed = VirtualFree( pv, 0, MEM_RELEASE );
		OSSYNCAssert( fMemFreed );
		}
	}


//  Context Local Storage

//  Internal CLS structure

struct _CLS
	{
	DWORD				cAttach;		//  context attach refcount
	DWORD				dwContextId;	//  context ID
	HANDLE				hContext;		//  context handle

	_CLS*				pclsNext;		//  next CLS in global list
	_CLS**				ppclsNext;		//  pointer to the pointer to this CLS

	CLS					cls;			//  external CLS structure
	};

//  Global CLS List

CRITICAL_SECTION csClsSyncGlobal;
_CLS* pclsSyncGlobal;
_CLS* pclsSyncCleanGlobal;
DWORD cclsSyncGlobal;

//  Allocated CLS Entries

//NOTE:	Cannot initialise this variable because the code that allocates
//		TLS and uses this variable to store the index executes before
//		CRTInit, which would subsequently re-initialise the variable
//		with the value specified here
//DWORD dwClsSyncIndex		= dwClsInvalid;
//DWORD dwClsProcIndex		= dwClsInvalid;
DWORD		dwClsSyncIndex;
DWORD		dwClsProcIndex;

const DWORD	dwClsInvalid			= 0xFFFFFFFF;		//	this is the value returned by TlsAlloc() on error

const long	lOSSyncUnlocked			= 0x7fffffff;
const long	lOSSyncLocked			= 0x80000000;
const long	lOSSyncLockedForInit	= 0x80000001;
const long	lOSSyncLockedForTerm	= 0x80000000;

static BOOL	FOSSyncIInit();
static void	OSSyncITerm();
static void	OSSyncIDetach( _CLS* pcls );

//  registers the given CLS structure as the CLS for this context

BOOL FOSSyncIClsRegister( _CLS* pcls )
	{
	BOOL	fAllocatedCls	= fFalse;

	//  we are the first to register CLS

	EnterCriticalSection( &csClsSyncGlobal );

	if ( NULL == pclsSyncGlobal )
		{
		//  allocate our CLS entries
		
		dwClsSyncIndex = TlsAlloc();
		if ( dwClsInvalid == dwClsSyncIndex )
			{
			LeaveCriticalSection( &csClsSyncGlobal );
			return fFalse;
			}
			
		dwClsProcIndex = TlsAlloc();
		if ( dwClsInvalid == dwClsProcIndex )
			{
			const BOOL	fTLSFreed	= TlsFree( dwClsSyncIndex );
			OSSYNCAssert( fTLSFreed );		//	leak the TLS entries if we fail
			dwClsSyncIndex = dwClsInvalid;

			LeaveCriticalSection( &csClsSyncGlobal );
			return fFalse;
			}

		fAllocatedCls = fTrue;
		}

	OSSYNCAssert( dwClsInvalid != dwClsSyncIndex );
	OSSYNCAssert( dwClsInvalid != dwClsProcIndex );

	//  save the pointer to the given CLS

	const BOOL	fTLSPointerSet	= TlsSetValue( dwClsSyncIndex, pcls );
	if ( !fTLSPointerSet )
		{
		if ( fAllocatedCls )
			{
			OSSYNCAssert( NULL == pclsSyncGlobal );

			const BOOL	fTLSFreed1	= TlsFree( dwClsSyncIndex );
			const BOOL	fTLSFreed2	= TlsFree( dwClsProcIndex );

			OSSYNCAssert( fTLSFreed1 );		//	leak the TLS entries if we fail
			OSSYNCAssert( fTLSFreed2 );

			dwClsSyncIndex = dwClsInvalid;
			dwClsProcIndex = dwClsInvalid;
			}

		LeaveCriticalSection( &csClsSyncGlobal );
		return fFalse;
		}

	//  add this CLS into the global list

	pcls->pclsNext = pclsSyncGlobal;
	if ( pcls->pclsNext )
		{
		pcls->pclsNext->ppclsNext = &pcls->pclsNext;
		}
	pcls->ppclsNext = &pclsSyncGlobal;
	pclsSyncGlobal = pcls;
	cclsSyncGlobal++;
	OSSYNCEnforceSz(	cclsSyncGlobal <= 32768,
				"Too many threads are attached to the Synchronization Library!" );

	//  try to cleanup two entries in the global CLS list

	for ( int i = 0; i < 2; i++ )
		{
		//  we have a CLS to clean

		_CLS* pclsClean = pclsSyncCleanGlobal ? pclsSyncCleanGlobal : pclsSyncGlobal;

		if ( pclsClean )
			{
			//  set the next CLS to clean

			pclsSyncCleanGlobal = pclsClean->pclsNext;

			//  we can cleanup this CLS if the thread has exited
			
			DWORD dwExitCode;
            if (	pclsClean->hContext &&
            		GetExitCodeThread( pclsClean->hContext, &dwExitCode ) &&
            		dwExitCode != STILL_ACTIVE )
				{
				//  detach this CLS

				OSSyncIDetach( pclsClean );
				}
			}
		}

	LeaveCriticalSection( &csClsSyncGlobal );
	return fTrue;
	}

//  unregisters the given CLS structure as the CLS for this context

void OSSyncIClsUnregister( _CLS* pcls )
	{
	//  there should be CLSs registered

	EnterCriticalSection( &csClsSyncGlobal );
	OSSYNCAssert( pclsSyncGlobal != NULL );

	//  make sure that the clean pointer is not pointing at this CLS

	if ( pclsSyncCleanGlobal == pcls )
		{
		pclsSyncCleanGlobal = pcls->pclsNext;
		}
	
	//  remove our CLS from the global CLS list
	
	if( pcls->pclsNext )
		{
		pcls->pclsNext->ppclsNext = pcls->ppclsNext;
		}
	*( pcls->ppclsNext ) = pcls->pclsNext;
	cclsSyncGlobal--;

	//  we are the last to unregister our CLS

	if ( pclsSyncGlobal == NULL )
		{
		//  deallocate CLS entries

		OSSYNCAssert( dwClsInvalid != dwClsSyncIndex );
		OSSYNCAssert( dwClsInvalid != dwClsProcIndex );

		const BOOL	fTLSFreed1	= TlsFree( dwClsSyncIndex );
		const BOOL	fTLSFreed2	= TlsFree( dwClsProcIndex );

		OSSYNCAssert( fTLSFreed1 );		//	leak the TLS entries if we fail
		OSSYNCAssert( fTLSFreed2 );

		dwClsSyncIndex = dwClsInvalid;
		dwClsProcIndex = dwClsInvalid;
		}

	LeaveCriticalSection( &csClsSyncGlobal );
	}
	
//  attaches to the current context, returning fFalse on failure

static BOOL OSSYNCAPI FOSSyncIAttach()
	{
	//  we don't yet have any CLS

	_CLS* pcls = ( NULL != pclsSyncGlobal ?
						reinterpret_cast<_CLS *>( TlsGetValue( dwClsSyncIndex ) ) :
						NULL );
	if ( NULL == pcls )
		{
		//  allocate memory for this context's CLS

		if ( !( pcls = (_CLS*) LocalAlloc( LMEM_ZEROINIT, sizeof( _CLS ) ) ) )
			{
			return fFalse;
			}

		//  initialize internal CLS fields

		pcls->dwContextId	= GetCurrentThreadId();
		if ( DuplicateHandle(	GetCurrentProcess(),
								GetCurrentThread(),
								GetCurrentProcess(),
								&pcls->hContext,
								THREAD_QUERY_INFORMATION,
								FALSE,
								0 ) )
			{
			SetHandleInformation( pcls->hContext, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
			}


		//  register our CLS

		if ( !FOSSyncIClsRegister( pcls ) )
			{
			if ( pcls->hContext )
				{
				SetHandleInformation( pcls->hContext, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
				CloseHandle( pcls->hContext );
				}
			LocalFree( (void*) pcls );
			return fFalse;
			}

		//  set our initial processor number to be defer init

		OSSyncSetCurrentProcessor( -1 );
		}

	//	UNDONE: this refcount is currently not correctly maintained/respected
	pcls->cAttach++;

	return fTrue;
	}

BOOL OSSYNCAPI FOSSyncAttach()
	{
	//  make sure we are initialized
	//	add add ref for this thread
	if ( FOSSyncIInit() )
		{
		if ( FOSSyncIAttach() )
			{
			return fTrue;
			}
		else
			{
			//	deref this thread
			OSSyncITerm();
			}
		}

	return fFalse;
	}

//  detaches from the specified context

static void OSSyncIDetach( _CLS* pcls )
	{
#ifdef SYNC_DEADLOCK_DETECTION
	//	UNDONE: detect if we're trying to detach
	//	when this context is holding locks
#endif	

	//  unregister our CLS

	OSSyncIClsUnregister( pcls );

	//  close our context handle

	if ( pcls->hContext )
		{
		SetHandleInformation( pcls->hContext, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		const BOOL	fCloseOK	= CloseHandle( pcls->hContext );
		OSSYNCAssert( fCloseOK );
		}

	//  free our CLS

	const BOOL	fFreedCLSOK	= !LocalFree( pcls );
	OSSYNCAssert( fFreedCLSOK );

	//	deref this thread
	OSSyncITerm();
	}

//  detaches from the current context

void OSSYNCAPI OSSyncDetach()
	{
    //  save our CLS pointer

    _CLS* pcls = ( NULL != pclsSyncGlobal ?
    					reinterpret_cast<_CLS *>( TlsGetValue( dwClsSyncIndex ) ) :
    					NULL );

	//  deref our CLS

	if ( pcls )
		{
		//  clear our CLS pointer from our TLS entry

		const BOOL	fTLSPointerSet	= TlsSetValue( dwClsSyncIndex, NULL );
		OSSYNCAssert( fTLSPointerSet );

		//  detech using this CLS pointer

		OSSyncIDetach( pcls );
		}
	}


//  returns the pointer to the current context's local storage.  if the context
//  does not yet have CLS, allocate it.

CLS* const OSSYNCAPI Pcls()
	{
	_CLS* pcls = ( NULL != pclsSyncGlobal ?
						reinterpret_cast<_CLS *>( TlsGetValue( dwClsSyncIndex ) ) :
						NULL );
	if ( NULL == pcls )
		{
		while ( !FOSSyncAttach() )
			{
			Sleep( 1000 );
			}

		OSSYNCAssert( dwClsInvalid != dwClsSyncIndex );
		pcls = reinterpret_cast<_CLS *>( TlsGetValue( dwClsSyncIndex ) );
		}

	OSSYNCAssert( NULL != pcls );
	return &( pcls->cls );
	}


//  Processor Information

//  returns the maximum number of processors this process can utilize

DWORD g_cProcessorMax;

int OSSYNCAPI OSSyncGetProcessorCountMax()
	{
	return g_cProcessorMax;
	}

//  returns the current number of processors this process can utilize

DWORD g_cProcessor;

int OSSYNCAPI OSSyncGetProcessorCount()
	{
	return g_cProcessor;
	}

//  returns the processor number that the current context _MAY_ be executing on
//
//  NOTE:  the current context may change processors at any time

BOOL g_fGetCurrentProcFromTEB;

int OSSYNCAPI OSSyncGetCurrentProcessor()
	{
	//  HACK:  we cannot currently determine the current processor that this
	//  HACK:  thread is executing on in user mode so we must fake it for
	//  HACK:  now with a realistic number.  hopefully, NT will give us this
	//  HACK:  number some day.  in the mean time, we will use either the value
	//  HACK:  set via OSSyncSetCurrentProcessor(), the thread's existing soft/
	//  HACK:  hard affinity, or a random number

//	NT:338172: Silence the following assert, because it's possible
//	to have an invalid dwClsProcIndex in the init code path if the
//	thread initialising Jet was present before ESENT.DLL was
//	LoadLibrary()'d (in which case DLL_THREAD_ATTACH is not
//	called for the thread).  For such a case, TlsGetValue()
//	will return 0, which is fine (we'll just use that as
//	the iProc to use).
///	OSSYNCAssert( dwClsInvalid != dwClsProcIndex );

	int iProc = (	g_fGetCurrentProcFromTEB ?
						NtCurrentTeb()->IdealProcessor:
						int( INT_PTR( TlsGetValue( dwClsProcIndex ) ) ) );

	//  we don't know what number to return yet

	if ( iProc == -1 )
		{
		//  get the current thread's soft affinity via a destructive read

		iProc = SetThreadIdealProcessor( GetCurrentThread(), MAXIMUM_PROCESSORS );
		SetThreadIdealProcessor( GetCurrentThread(), iProc );

		//  if there is no soft affinity then choose a random soft affinity
		
		if ( iProc == -1 || iProc == MAXIMUM_PROCESSORS )
			{
			iProc = abs( ( _rotr( GetCurrentThreadId(), 8 ) % 997 ) % OSSyncGetProcessorCount() );
			}

		//  get the current process' hard affinity

		DWORD_PTR	dwMaskProc;
		DWORD_PTR	dwMaskSys;
		GetProcessAffinityMask( GetCurrentProcess(), &dwMaskProc, &dwMaskSys );

		//  get the current thread's hard affinity via a destructive read

		DWORD_PTR	dwMask;
		dwMask = SetThreadAffinityMask( GetCurrentThread(), dwMaskProc );
		SetThreadAffinityMask( GetCurrentThread(), dwMask );
		dwMask = dwMask ? dwMask : dwMaskProc;

		//  compute the processor number to conform first to the hard affinity
		//  and then to the soft affinity.  if the soft affinity is to a proc
		//  that the thread cannot use due to its hard affinity then use
		//  the soft affinity to hash across the processors that it can run on

		int ibit;
		int cbitSet;
		for ( ibit = 0, cbitSet = 0; ibit < sizeof( dwMask ) * 8; ibit++ )
			{
			if ( dwMask & ( 1 << ibit ) )
				{
				cbitSet++;
				}
			}
		int ibitSet;
		int ibitBest;
		for ( ibit = 0, ibitSet = 0, ibitBest = 0; ibit < sizeof( dwMask ) * 8; ibit++ )
			{
			if ( dwMask & ( 1 << ibit ) )
				{
				if ( ibitSet == iProc % cbitSet )
					{
					ibitBest = ibit;
					}
				ibitSet++;
				}
			}
		if ( dwMask & ( 1 << iProc ) )
			{
			ibitBest = iProc;
			}
		iProc = ibitBest;
		
		//  remember our newly computed processor number
		
		OSSyncSetCurrentProcessor( iProc );
		}

	return iProc;
	}

//  sets the processor number returned by OSSyncGetCurrentProcessor()

void OSSYNCAPI OSSyncSetCurrentProcessor( const int iProc )
	{
	OSSYNCAssert( dwClsInvalid != dwClsProcIndex );
	TlsSetValue( dwClsProcIndex, (void*) INT_PTR( iProc == -1 ? -1 : iProc % OSSyncGetProcessorCount() ) );
	}


//  High Resolution Timer

#if defined( _M_IX86 ) && defined( SYNC_USE_X86_ASM )

//    QWORDX - used for 32 bit access to a 64 bit integer
//	  For intel pentium only

union QWORDX {
		QWORD	qw;
		struct
			{
			DWORD l;
			DWORD h;
			};
		};
#endif

//    High Resolution Timer Type

enum HRTType
	{
	hrttNone,
	hrttWin32,
#if defined( _M_IX86 ) && defined( SYNC_USE_X86_ASM )
	hrttPentium,
#endif  //  _M_IX86 && SYNC_USE_X86_ASM
	} hrttSync;

//    HRT Frequency

QWORD qwSyncHRTFreq;

#if defined( _M_IX86 ) && defined( SYNC_USE_X86_ASM )

//    Pentium Time Stamp Counter Fetch

#define rdtsc __asm _emit 0x0f __asm _emit 0x31

#endif  //  _MM_IX86 && SYNC_USE_X86_ASM

//  returns fTrue if we are allowed to use RDTSC

BOOL IsRDTSCAvailable()
	{
	typedef WINBASEAPI BOOL WINAPI PFNIsProcessorFeaturePresent( IN DWORD ProcessorFeature );

	HMODULE							hmodKernel32					= NULL;
	PFNIsProcessorFeaturePresent*	pfnIsProcessorFeaturePresent	= NULL;
	BOOL							fRDTSCAvailable					= fFalse;

	if ( !( hmodKernel32 = GetModuleHandle( _T( "kernel32.dll" ) ) ) )
		{
		goto NoIsProcessorFeaturePresent;
		}
	if ( !( pfnIsProcessorFeaturePresent = (PFNIsProcessorFeaturePresent*)GetProcAddress( hmodKernel32, _T( "IsProcessorFeaturePresent" ) ) ) )
		{
		goto NoIsProcessorFeaturePresent;
		}

	fRDTSCAvailable = pfnIsProcessorFeaturePresent( PF_RDTSC_INSTRUCTION_AVAILABLE );

NoIsProcessorFeaturePresent:
	return fRDTSCAvailable;
	}

//  initializes the HRT subsystem

void OSTimeHRTInit()
	{
	//  if we have already been initialized, we're done

	if ( qwSyncHRTFreq )
		{
		return;
		}

	//  Win32 high resolution counter is available

	if ( QueryPerformanceFrequency( (LARGE_INTEGER *) &qwSyncHRTFreq ) )
		{
		hrttSync = hrttWin32;
		}

	//  Win32 high resolution counter is not available
	
	else

		{
		//  fall back on GetTickCount() (ms since Windows has started)
		
		qwSyncHRTFreq = 1000;
		hrttSync = hrttNone;
		}

#if defined( _M_IX86 ) && defined( SYNC_USE_X86_ASM )

	//  can we use the TSC?
	
	if ( IsRDTSCAvailable() )
		{
		//  use pentium TSC register, but first find clock frequency experimentally
		
		QWORDX qwxTime1a;
		QWORDX qwxTime1b;
		QWORDX qwxTime2a;
		QWORDX qwxTime2b;
		if ( hrttSync == hrttWin32 )
			{
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime1a.l,eax	//lint !e530
			__asm mov		qwxTime1a.h,edx	//lint !e530
			QueryPerformanceCounter( (LARGE_INTEGER*) &qwxTime1b.qw );
			Sleep( 50 );
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime2a.l,eax	//lint !e530
			__asm mov		qwxTime2a.h,edx	//lint !e530
			QueryPerformanceCounter( (LARGE_INTEGER*) &qwxTime2b.qw );
			qwSyncHRTFreq =	( qwSyncHRTFreq * ( qwxTime2a.qw - qwxTime1a.qw ) ) /
						( qwxTime2b.qw - qwxTime1b.qw );
			qwSyncHRTFreq = ( ( qwSyncHRTFreq + 50000 ) / 100000 ) * 100000;
			}
		else
			{
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime1a.l,eax
			__asm mov		qwxTime1a.h,edx
			qwxTime1b.l = GetTickCount();
			qwxTime1b.h = 0;
			Sleep( 2000 );
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwxTime2a.l,eax
			__asm mov		qwxTime2a.h,edx
			qwxTime2b.l = GetTickCount();
			qwxTime2b.h = 0;
			qwSyncHRTFreq =	( qwSyncHRTFreq * ( qwxTime2a.qw - qwxTime1a.qw ) ) /
						( qwxTime2b.qw - qwxTime1b.qw );
			qwSyncHRTFreq = ( ( qwSyncHRTFreq + 500000 ) / 1000000 ) * 1000000;
			}

		hrttSync = hrttPentium;
		}
		
#endif  //  _M_IX86 && SYNC_USE_X86_ASM

	}

//  returns the current HRT frequency

QWORD OSSYNCAPI QwOSTimeHRTFreq()
	{
	return qwSyncHRTFreq;
	}

//  returns the current HRT count

QWORD OSSYNCAPI QwOSTimeHRTCount()
	{
	QWORD qw;

	switch ( hrttSync )
		{
		case hrttNone:
			qw = GetTickCount();
			break;

		case hrttWin32:
			QueryPerformanceCounter( (LARGE_INTEGER*) &qw );
			break;

#if defined( _M_IX86 ) && defined( SYNC_USE_X86_ASM )

		case hrttPentium:
			{
			QWORDX qwx;
			__asm xchg		eax, edx  //  HACK:  cl 11.00.7022 needs this
			__asm rdtsc
			__asm mov		qwx.l,eax
			__asm mov		qwx.h,edx

			qw = qwx.qw;
			}
			break;
			
#endif  //  _M_IX86 && SYNC_USE_X86_ASM

		}

	return qw;
	}


//  Timer

//  returns the current tick count where one tick is one millisecond

DWORD OSSYNCAPI DwOSTimeGetTickCount()
	{
	return GetTickCount();
	}


//  Atomic Memory Manipulations

#if defined( _M_IX86 ) && defined( SYNC_USE_X86_ASM )
#elif defined( _M_AMD64 ) || defined( _M_IA64 )
#else

//  atomically compares the current value of the target with the specified
//  initial value and if equal sets the target to the specified final value.
//  the initial value of the target is returned.  the exchange is successful
//  if the value returned equals the specified initial value.  the target
//  must be aligned to a four byte boundary

long OSSYNCAPI AtomicCompareExchange( long* const plTarget, const long lInitial, const long lFinal )
	{
	OSSYNCAssert( IsAtomicallyModifiable( plTarget ) );
	
	return InterlockedCompareExchange( plTarget, lFinal, lInitial );
	}
	
void* OSSYNCAPI AtomicCompareExchangePointer( void** const ppvTarget, void* const pvInitial, void* const pvFinal )
	{
	OSSYNCAssert( IsAtomicallyModifiablePointer( ppvTarget ) );
	
	return (void*) InterlockedCompareExchange( (long*) ppvTarget, (long) pvFinal, (long) pvInitial );
	}

//  atomically sets the target to the specified value, returning the target's
//  initial value.  the target must be aligned to a four byte boundary

long OSSYNCAPI AtomicExchange( long* const plTarget, const long lValue )
	{
	OSSYNCAssert( IsAtomicallyModifiable( plTarget ) );
	
	return InterlockedExchange( plTarget, lValue );
	}
	
void* OSSYNCAPI AtomicExchangePointer( void* const * ppvTarget, void* const pvValue )
	{
	OSSYNCAssert( IsAtomicallyModifiablePointer( ppvTarget ) );
	
	return (void*)InterlockedExchange( (long*) ppvTarget, (long) pvValue );
	}

//  atomically adds the specified value to the target, returning the target's
//  initial value.  the target must be aligned to a four byte boundary

long OSSYNCAPI AtomicExchangeAdd( long* const plTarget, const long lValue )
	{
	OSSYNCAssert( IsAtomicallyModifiable( plTarget ) );
	
	return InterlockedExchangeAdd( plTarget, lValue );
	}

#endif
//  Enhanced Synchronization Object State Container

struct MemoryBlock
	{
	MemoryBlock*	pmbNext;
	MemoryBlock**	ppmbNext;
	SIZE_T			cAlloc;
	SIZE_T			ibFreeMic;
	};

SIZE_T				g_cbMemoryBlock;
MemoryBlock*		g_pmbRoot;
MemoryBlock			g_mbSentry;
MemoryBlock*		g_pmbRootFree;
MemoryBlock			g_mbSentryFree;
CRITICAL_SECTION	g_csESMemory;

void* OSSYNCAPI ESMemoryNew( size_t cb )
	{
	if ( !FOSSyncInitForES() )
		{
		return NULL;
		}
		
	cb += sizeof( QWORD ) - 1;
	cb -= cb % sizeof( QWORD );
	
	EnterCriticalSection( &g_csESMemory );
	
	MemoryBlock* pmb = g_pmbRoot;

	if ( pmb->ibFreeMic + cb > g_cbMemoryBlock )
		{
		if ( g_pmbRootFree != &g_mbSentryFree )
			{
			pmb = g_pmbRootFree;
			
			*pmb->ppmbNext			= pmb->pmbNext;
			pmb->pmbNext->ppmbNext	= pmb->ppmbNext;
			}
		
		else if ( !( pmb = (MemoryBlock*) VirtualAlloc( NULL, g_cbMemoryBlock, MEM_COMMIT, PAGE_READWRITE ) ) )
			{
			LeaveCriticalSection( &g_csESMemory );
			OSSyncTermForES();
			return pmb;
			}
			
		pmb->pmbNext	= g_pmbRoot;
		pmb->ppmbNext	= &g_pmbRoot;
		pmb->cAlloc		= 0;
		pmb->ibFreeMic	= sizeof( MemoryBlock );

		g_pmbRoot->ppmbNext	= &pmb->pmbNext;
		g_pmbRoot			= pmb;
		}

	void* pv = (BYTE*)pmb + pmb->ibFreeMic;
	pmb->cAlloc++;
	pmb->ibFreeMic += cb;

	LeaveCriticalSection( &g_csESMemory );
	return pv;
	}
	
void OSSYNCAPI ESMemoryDelete( void* pv )
	{
	if ( pv )
		{
		EnterCriticalSection( &g_csESMemory );
		
		MemoryBlock* const pmb = (MemoryBlock*) ( UINT_PTR( pv ) - UINT_PTR( pv ) % g_cbMemoryBlock );
		
		if ( !( --pmb->cAlloc ) )
			{
			*pmb->ppmbNext = pmb->pmbNext;
			pmb->pmbNext->ppmbNext = pmb->ppmbNext;

			pmb->pmbNext	= g_pmbRootFree;
			pmb->ppmbNext	= &g_pmbRootFree;
			
			g_pmbRootFree->ppmbNext	= &pmb->pmbNext;
			g_pmbRootFree			= pmb;
			}

		LeaveCriticalSection( &g_csESMemory );

		OSSyncTermForES();
		}
	}


//  Synchronization Object Basic Information

//  ctor

CSyncBasicInfo::CSyncBasicInfo( const char* szInstanceName )
	{
#ifdef SYNC_ENHANCED_STATE

	m_szInstanceName	= szInstanceName;
	m_szTypeName		= NULL;
	m_psyncobj			= NULL;

#endif  //  SYNC_ENHANCED_STATE
	}

//  dtor

CSyncBasicInfo::~CSyncBasicInfo()
	{
	}
	

//  Synchronization Object Performance:  Wait Times

//  ctor

CSyncPerfWait::CSyncPerfWait()
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	m_cWait = 0;
	m_qwHRTWaitElapsed = 0;

#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  dtor

CSyncPerfWait::~CSyncPerfWait()
	{
	}


//  Null Synchronization Object State Initializer

const CSyncStateInitNull syncstateNull;


//  Kernel Semaphore

//  ctor

CKernelSemaphore::CKernelSemaphore( const CSyncBasicInfo& sbi )
	:	CEnhancedStateContainer< CKernelSemaphoreState, CSyncStateInitNull, CKernelSemaphoreInfo, CSyncBasicInfo >( syncstateNull, sbi )
	{
	//  further init of CSyncBasicInfo

	State().SetTypeName( "CKernelSemaphore" );
	State().SetInstance( (CSyncObject*)this );
	}

//  dtor

CKernelSemaphore::~CKernelSemaphore()
	{
	//  semaphore should not be initialized
	
	OSSYNCAssert( !FInitialized() );

#ifdef SYNC_ANALYZE_PERFORMANCE
#ifdef SYNC_DUMP_PERF_DATA

	//  dump performance data

	OSSyncStatsDump(	State().SzTypeName(),
						State().SzInstanceName(),
						State().Instance(),
						-1,
						State().CWaitTotal(),
						State().CsecWaitElapsed(),
						0,
						0,
						0,
						0 );

#endif  //  SYNC_DUMP_PERF_DATA
#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

//  initialize the semaphore, returning 0 on failure

const BOOL CKernelSemaphore::FInit()
	{
	//  semaphore should not be initialized
	
	OSSYNCAssert( !FInitialized() );
	
	//  allocate kernel semaphore object

	State().SetHandle( CreateSemaphore( 0, 0, 0x7FFFFFFFL, 0 ) );

	if ( State().Handle() )
		{
		SetHandleInformation( State().Handle(), HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
		}
	
	//  semaphore should have no available counts, if allocated

	OSSYNCAssert( State().Handle() == 0 || FReset() );

	//  return result of init

	return State().Handle() != 0;
	}

//  terminate the semaphore

void CKernelSemaphore::Term()
	{
	//  semaphore should be initialized

	OSSYNCAssert( FInitialized() );
	
	//  semaphore should have no available counts

	OSSYNCAssert( FReset() );

	//  deallocate kernel semaphore object

	SetHandleInformation( State().Handle(), HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
	int fSuccess = CloseHandle( State().Handle() );
	OSSYNCAssert( fSuccess );

	//  reset state

	State().SetHandle( 0 );
	}

//  acquire one count of the semaphore, waiting only for the specified interval.
//  returns 0 if the wait timed out before a count could be acquired

const BOOL CKernelSemaphore::FAcquire( const int cmsecTimeout )
	{
	//  semaphore should be initialized

	OSSYNCAssert( FInitialized() );

	//  wait for semaphore

	BOOL fSuccess;

	if ( cmsecTimeout != cmsecTest )
		{
		AtomicIncrement( (long*)&cOSSYNCThreadBlock );
		}
	State().StartWait();
	
#ifdef SYNC_DEADLOCK_DETECTION

	if ( cmsecTimeout == cmsecInfinite || cmsecTimeout > cmsecDeadlock )
		{
		fSuccess = WaitForSingleObjectEx( State().Handle(), cmsecDeadlock, FALSE ) == WAIT_OBJECT_0;
		
		OSSYNCAssertSzRTL( fSuccess, "Potential Deadlock Detected (Timeout)" );

		if ( !fSuccess )
			{
			const int cmsecWait =	cmsecTimeout == cmsecInfinite ?
										cmsecInfinite :
										cmsecTimeout - cmsecDeadlock;

			fSuccess = WaitForSingleObjectEx( State().Handle(), cmsecWait, FALSE ) == WAIT_OBJECT_0;
			}
		}
	else
		{
		OSSYNCAssert(	cmsecTimeout == cmsecInfiniteNoDeadlock ||
				cmsecTimeout <= cmsecDeadlock );

		const int cmsecWait =	cmsecTimeout == cmsecInfiniteNoDeadlock ?
									cmsecInfinite :
									cmsecTimeout;

		fSuccess = WaitForSingleObjectEx( State().Handle(), cmsecWait, FALSE ) == WAIT_OBJECT_0;
		}

#else  //  !SYNC_DEADLOCK_DETECTION

	const int cmsecWait =	cmsecTimeout == cmsecInfiniteNoDeadlock ?
								cmsecInfinite :
								cmsecTimeout;
	
	fSuccess = WaitForSingleObjectEx( State().Handle(), cmsecWait, FALSE ) == WAIT_OBJECT_0;
	
#endif  //  SYNC_DEADLOCK_DETECTION

	State().StopWait();
	if ( cmsecTimeout != cmsecTest )
		{
		AtomicIncrement( (long*)&cOSSYNCThreadResume );
		}
	
	return fSuccess;
	}

//  releases the given number of counts to the semaphore, waking the appropriate
//  number of waiters

void CKernelSemaphore::Release( const int cToRelease )
	{
	//  semaphore should be initialized

	OSSYNCAssert( FInitialized() );

	//  release semaphore
	
	const BOOL fSuccess = ReleaseSemaphore( HANDLE( State().Handle() ), cToRelease, 0 );
	OSSYNCAssert( fSuccess );
	}


//  performance data dumping

#include<stdarg.h>
#include<stdio.h>
#include<tchar.h>

//  ================================================================
class CPrintF
//  ================================================================
	{
	public:
		CPrintF() {}
		virtual ~CPrintF() {}

	public:
		virtual void __cdecl operator()( const _TCHAR* szFormat, ... ) = 0;
	};

//  ================================================================
class CIPrintF : public CPrintF
//  ================================================================
	{
	public:
		CIPrintF( CPrintF* pprintf );
	
		void __cdecl operator()( const _TCHAR* szFormat, ... );

		virtual void Indent();
		virtual void Unindent();
		
	protected:
		CIPrintF();
		
	private:
		CPrintF* const		m_pprintf;
		int					m_cindent;
		BOOL				m_fBOL;
	};

//  ================================================================
inline CIPrintF::CIPrintF( CPrintF* pprintf ) :
//  ================================================================
	m_cindent( 0 ),
	m_pprintf( pprintf ),
	m_fBOL( fTrue )
	{
	}
	
//  ================================================================
inline void __cdecl CIPrintF::operator()( const _TCHAR* szFormat, ... )
//  ================================================================
	{
	_TCHAR szT[ 1024 ];
	va_list arg_ptr;
	va_start( arg_ptr, szFormat );
	_vstprintf( szT, szFormat, arg_ptr );
	va_end( arg_ptr );

	_TCHAR*	szLast	= szT;
	_TCHAR*	szCurr	= szT;
	while ( *szCurr )
		{
		if ( m_fBOL )
			{
			for ( int i = 0; i < m_cindent; i++ )
				{
				(*m_pprintf)( _T( "\t" ) );
				}
			m_fBOL = fFalse;
			}

		szCurr = szLast + _tcscspn( szLast, _T( "\r\n" ) );
		while ( *szCurr == _T( '\r' ) )
			{
			szCurr++;
			m_fBOL = fTrue;
			}
		if ( *szCurr == _T( '\n' ) )
			{
			szCurr++;
			m_fBOL = fTrue;
			}

		(*m_pprintf)( _T( "%.*s" ), szCurr - szLast, szLast );

		szLast = szCurr;
		}
	}

//  ================================================================
inline void CIPrintF::Indent()
//  ================================================================
	{
	++m_cindent;
	}

//  ================================================================
inline void CIPrintF::Unindent()
//  ================================================================
	{
	if ( m_cindent > 0 )
		{
		--m_cindent;
		}
	}

//  ================================================================
inline CIPrintF::CIPrintF( ) :
//  ================================================================
	m_cindent( 0 ),
	m_pprintf( 0 ),
	m_fBOL( fTrue )
	{
	}

//  ================================================================
class CFPrintF : public CPrintF
//  ================================================================
	{
	public:
		CFPrintF( const char* szFile );
		~CFPrintF();
		
		void __cdecl operator()( const char* szFormat, ... );
			
	private:
		void* m_hFile;
		void* m_hMutex;
	};

CFPrintF::CFPrintF( const char* szFile )
	{
	//  open the file for append

	if ( ( m_hFile = (void*)CreateFile( szFile, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ) ) == INVALID_HANDLE_VALUE )
		{
		return;
		}
	SetHandleInformation( HANDLE( m_hFile ), HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	if ( !( m_hMutex = (void*)CreateMutex( NULL, FALSE, NULL ) ) )
		{
		SetHandleInformation( HANDLE( m_hFile ), HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( HANDLE( m_hFile ) );
		m_hFile = INVALID_HANDLE_VALUE;
		return;
		}
	SetHandleInformation( HANDLE( m_hMutex ), HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );
	}

CFPrintF::~CFPrintF()
	{
	//  close the file

	if ( m_hMutex )
		{
		SetHandleInformation( HANDLE( m_hMutex ), HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( HANDLE( m_hMutex ) );
		m_hMutex = NULL;
		}

	if ( m_hFile != INVALID_HANDLE_VALUE )
		{
		SetHandleInformation( HANDLE( m_hFile ), HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( HANDLE( m_hFile ) );
		m_hFile = INVALID_HANDLE_VALUE;
		}
	}

//  ================================================================
void __cdecl CFPrintF::operator()( const char* szFormat, ... )
//  ================================================================
	{
	if ( HANDLE( m_hFile ) != INVALID_HANDLE_VALUE )
		{
		const SIZE_T cchBuf = 1024;
		char szBuf[ cchBuf ];

		//  print into a temp buffer, truncating the string if too large
		
		va_list arg_ptr;
		va_start( arg_ptr, szFormat );
		_vsnprintf( szBuf, cchBuf - 1, szFormat, arg_ptr );
		szBuf[ cchBuf - 1 ] = 0;
		va_end( arg_ptr );
		
		//  append the string to the file

		WaitForSingleObject( HANDLE( m_hMutex ), INFINITE );

		SetFilePointer( HANDLE( m_hFile ), 0, NULL, FILE_END );

		DWORD cbWritten;
		WriteFile( HANDLE( m_hFile ), szBuf, DWORD( strlen( szBuf ) * sizeof( char ) ), &cbWritten, NULL );

		ReleaseMutex( HANDLE( m_hMutex ) );
		}
	}


#ifdef DEBUGGER_EXTENSION

#define LOCAL static


namespace OSSYM {

#include <imagehlp.h>
#include <psapi.h>


typedef DWORD IMAGEAPI WINAPI PFNUnDecorateSymbolName( PCSTR, PSTR, DWORD, DWORD );
typedef DWORD IMAGEAPI PFNSymSetOptions( DWORD );
typedef BOOL IMAGEAPI PFNSymCleanup( HANDLE );
typedef BOOL IMAGEAPI PFNSymInitialize( HANDLE, PSTR, BOOL );
typedef BOOL IMAGEAPI PFNSymGetSymFromAddr( HANDLE, DWORD_PTR, DWORD_PTR*, PIMAGEHLP_SYMBOL );
typedef BOOL IMAGEAPI PFNSymGetSymFromName( HANDLE, PSTR, PIMAGEHLP_SYMBOL );
typedef BOOL IMAGEAPI PFNSymGetSearchPath( HANDLE, PSTR, DWORD );
typedef BOOL IMAGEAPI PFNSymSetSearchPath( HANDLE, PSTR );
typedef BOOL IMAGEAPI PFNSymGetModuleInfo( HANDLE, DWORD_PTR, PIMAGEHLP_MODULE );
typedef DWORD IMAGEAPI PFNSymLoadModule( HANDLE, HANDLE, PSTR, PSTR, DWORD_PTR, DWORD );
typedef PIMAGE_NT_HEADERS IMAGEAPI PFNImageNtHeader( PVOID );

PFNUnDecorateSymbolName*	pfnUnDecorateSymbolName;
PFNSymSetOptions*			pfnSymSetOptions;
PFNSymCleanup*				pfnSymCleanup;
PFNSymInitialize*			pfnSymInitialize;
PFNSymGetSymFromAddr*		pfnSymGetSymFromAddr;
PFNSymGetSymFromName*		pfnSymGetSymFromName;
PFNSymGetSearchPath*		pfnSymGetSearchPath;
PFNSymSetSearchPath*		pfnSymSetSearchPath;
PFNSymGetModuleInfo*		pfnSymGetModuleInfo;
PFNSymLoadModule*			pfnSymLoadModule;
PFNImageNtHeader*			pfnImageNtHeader;

HMODULE hmodImagehlp;

typedef BOOL WINAPI PFNEnumProcessModules( HANDLE, HMODULE*, DWORD, LPDWORD );
typedef DWORD WINAPI PFNGetModuleFileNameExA( HANDLE, HMODULE, LPSTR, DWORD );
typedef DWORD WINAPI PFNGetModuleBaseNameA( HANDLE, HMODULE, LPSTR, DWORD );
typedef BOOL WINAPI PFNGetModuleInformation( HANDLE, HMODULE, LPMODULEINFO, DWORD );

PFNEnumProcessModules*		pfnEnumProcessModules;
PFNGetModuleFileNameExA*	pfnGetModuleFileNameExA;
PFNGetModuleBaseNameA*		pfnGetModuleBaseNameA;
PFNGetModuleInformation*	pfnGetModuleInformation;

HMODULE hmodPsapi;

LOCAL const DWORD symopt =	SYMOPT_CASE_INSENSITIVE |
							SYMOPT_UNDNAME |
							SYMOPT_OMAP_FIND_NEAREST |
							SYMOPT_DEFERRED_LOADS;
LOCAL CHAR szParentImageName[_MAX_FNAME];
LOCAL HANDLE ghDbgProcess;


//  ================================================================
LOCAL BOOL SymLoadAllModules( HANDLE hProcess )
//  ================================================================
	{
	HMODULE* rghmodDebuggee = NULL;

	//  fetch all modules in the debuggee process and manually load their symbols.
	//  we do this because telling imagehlp to invade the debugee process doesn't
	//  work when we are already running in the context of a debugger

	DWORD cbNeeded;
	if ( !pfnEnumProcessModules( hProcess, NULL, 0, &cbNeeded ) )
		{
		goto HandleError;
		}

	DWORD cbActual;
	do	{
		cbActual = cbNeeded;
		rghmodDebuggee = (HMODULE*)LocalAlloc( 0, cbActual );

		if ( !pfnEnumProcessModules( hProcess, rghmodDebuggee, cbActual, &cbNeeded ) )
			{
			goto HandleError;
			}
		}
	while ( cbNeeded > cbActual );

	SIZE_T ihmod;
	SIZE_T ihmodLim;

	ihmodLim = cbNeeded / sizeof( HMODULE );
	for ( ihmod = 0; ihmod < ihmodLim; ihmod++ )
		{
		char szModuleImageName[ _MAX_PATH ];
		if ( !pfnGetModuleFileNameExA( hProcess, rghmodDebuggee[ ihmod ], szModuleImageName, _MAX_PATH ) )
			{
			goto HandleError;
			}

		char szModuleBaseName[ _MAX_FNAME ];
		if ( !pfnGetModuleBaseNameA( hProcess, rghmodDebuggee[ ihmod ], szModuleBaseName, _MAX_FNAME ) )
			{
			goto HandleError;
			}

		MODULEINFO mi;
		if ( !pfnGetModuleInformation( hProcess, rghmodDebuggee[ ihmod ], &mi, sizeof( mi ) ) )
			{
			goto HandleError;
			}
			
		if ( !pfnSymLoadModule(	hProcess,
								NULL,
								szModuleImageName,
								szModuleBaseName,
								DWORD_PTR( mi.lpBaseOfDll ),
								mi.SizeOfImage ) )
			{
			goto HandleError;
			}

		IMAGEHLP_MODULE im;
		im.SizeOfStruct = sizeof( IMAGEHLP_MODULE );

		if ( !pfnSymGetModuleInfo( hProcess, DWORD_PTR( mi.lpBaseOfDll ), &im ) )
			{
			goto HandleError;
			}
		}

	return fTrue;

HandleError:
	LocalFree( (void*)rghmodDebuggee );
	return fFalse;
	}

//  ================================================================
LOCAL BOOL SymInitializeEx(	HANDLE hProcess, HANDLE* phProcess )
//  ================================================================
	{
	//  init our out param

	*phProcess = NULL;

	//  duplicate the given debuggee process handle so that we have our own
	//  sandbox in imagehlp

	if ( !DuplicateHandle(	GetCurrentProcess(),
							hProcess,
							GetCurrentProcess(),
							phProcess,
							0,
							FALSE,
							DUPLICATE_SAME_ACCESS ) )
		{
		goto HandleError;
		}
	SetHandleInformation( *phProcess, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE );

	//  init imagehlp for the debuggee process

	if ( !pfnSymInitialize( *phProcess, NULL, FALSE ) )
		{
		goto HandleError;
		}

	//  we're done

	return fTrue;

HandleError:
	if ( *phProcess )
		{
		SetHandleInformation( *phProcess, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( *phProcess );
		*phProcess = NULL;
		}
	return fFalse;
	}

//  ================================================================
LOCAL void SymTerm()
//  ================================================================
	{
	//  shut down imagehlp
	
	if ( pfnSymCleanup )
		{
		if ( ghDbgProcess )
			{
			pfnSymCleanup( ghDbgProcess );
			}
		pfnSymCleanup = NULL;
		}

	//  free psapi

	if ( hmodPsapi )
		{
		FreeLibrary( hmodPsapi );
		hmodPsapi = NULL;
		}

	//  free imagehlp

	if ( hmodImagehlp )
		{
		FreeLibrary( hmodImagehlp );
		hmodImagehlp = NULL;
		}

	//  close our process handle

	if ( ghDbgProcess )
		{
		SetHandleInformation( ghDbgProcess, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( ghDbgProcess );
		ghDbgProcess = NULL;
		}
	}

//  ================================================================
LOCAL BOOL FSymInit( HANDLE hProc )
//  ================================================================
	{
	HANDLE hThisProcess = NULL;
	
	//  reset all pointers
	
	ghDbgProcess	= NULL;
	hmodImagehlp	= NULL;
	pfnSymCleanup	= NULL;
	hmodPsapi		= NULL;

	//  load all calls in imagehlp
	
	if ( !( hmodImagehlp = LoadLibrary( "imagehlp.dll" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetSymFromAddr = (PFNSymGetSymFromAddr*)GetProcAddress( hmodImagehlp, "SymGetSymFromAddr" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetSymFromName = (PFNSymGetSymFromName*)GetProcAddress( hmodImagehlp, "SymGetSymFromName" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymInitialize = (PFNSymInitialize*)GetProcAddress( hmodImagehlp, "SymInitialize" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymCleanup = (PFNSymCleanup*)GetProcAddress( hmodImagehlp, "SymCleanup" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymSetOptions = (PFNSymSetOptions*)GetProcAddress( hmodImagehlp, "SymSetOptions" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnUnDecorateSymbolName = (PFNUnDecorateSymbolName*)GetProcAddress( hmodImagehlp, "UnDecorateSymbolName" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetSearchPath = (PFNSymGetSearchPath*)GetProcAddress( hmodImagehlp, "SymGetSearchPath" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymSetSearchPath = (PFNSymSetSearchPath*)GetProcAddress( hmodImagehlp, "SymSetSearchPath" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymGetModuleInfo = (PFNSymGetModuleInfo*)GetProcAddress( hmodImagehlp, "SymGetModuleInfo" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnSymLoadModule = (PFNSymLoadModule*)GetProcAddress( hmodImagehlp, "SymLoadModule" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnImageNtHeader = (PFNImageNtHeader*)GetProcAddress( hmodImagehlp, "ImageNtHeader" ) ) )
		{
		goto HandleError;
		}

	//  load all calls in psapi

	if ( !( hmodPsapi = LoadLibrary( "psapi.dll" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnEnumProcessModules = (PFNEnumProcessModules*)GetProcAddress( hmodPsapi, "EnumProcessModules" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnGetModuleFileNameExA = (PFNGetModuleFileNameExA*)GetProcAddress( hmodPsapi, "GetModuleFileNameExA" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnGetModuleBaseNameA = (PFNGetModuleBaseNameA*)GetProcAddress( hmodPsapi, "GetModuleBaseNameA" ) ) )
		{
		goto HandleError;
		}
	if ( !( pfnGetModuleInformation = (PFNGetModuleInformation*)GetProcAddress( hmodPsapi, "GetModuleInformation" ) ) )
		{
		goto HandleError;
		}

	//  get the name of our parent image in THIS process.  we need this name so
	//  that we can prefix symbols with the default module name and so that we
	//  can add the image path to the symbol path

	MEMORY_BASIC_INFORMATION mbi;
	if ( !VirtualQueryEx( GetCurrentProcess(), FSymInit, &mbi, sizeof( mbi ) ) )
		{
		goto HandleError;
		}
	char szImage[_MAX_PATH];
	if ( !GetModuleFileNameA( HINSTANCE( mbi.AllocationBase ), szImage, sizeof( szImage ) ) )
		{
		goto HandleError;
		}
	_splitpath( (const _TCHAR *)szImage, NULL, NULL, szParentImageName, NULL );

	//  init imagehlp for the debuggee process

	if ( !SymInitializeEx( hProc, &ghDbgProcess ) )
		{
		goto HandleError;
		}

	//  set our symbol path to include the path of this image and the process
	//  executable

	char szOldPath[ 4 * _MAX_PATH ];
	if ( pfnSymGetSearchPath( ghDbgProcess, szOldPath, sizeof( szOldPath ) ) )
		{
		char szNewPath[ 6 * _MAX_PATH ];
		char szDrive[ _MAX_DRIVE ];
		char szDir[ _MAX_DIR ];
		char szPath[ _MAX_PATH ];

		szNewPath[ 0 ] = 0;
		
		strcat( szNewPath, szOldPath );
		strcat( szNewPath, ";" );
		
		HMODULE hImage = GetModuleHandle( szParentImageName );
		GetModuleFileName( hImage, szPath, _MAX_PATH );
		_splitpath( szPath, szDrive, szDir, NULL, NULL );
		_makepath( szPath, szDrive, szDir, NULL, NULL );
		strcat( szNewPath, szPath );
		strcat( szNewPath, ";" );
		
		GetModuleFileName( NULL, szPath, _MAX_PATH );
		_splitpath( szPath, szDrive, szDir, NULL, NULL );
		_makepath( szPath, szDrive, szDir, NULL, NULL );
		strcat( szNewPath, szPath );
		
		pfnSymSetSearchPath( ghDbgProcess, szNewPath );
		}

	//  set our default symbol options
	
	pfnSymSetOptions( symopt );

	//  prepare symbols for the debuggee process

	if ( !SymLoadAllModules( ghDbgProcess ) )
		{
		goto HandleError;
		}

	return fTrue;

HandleError:
	if ( hThisProcess )
		{
		SetHandleInformation( hThisProcess, HANDLE_FLAG_PROTECT_FROM_CLOSE, 0 );
		CloseHandle( hThisProcess );
		}
	SymTerm();
	return fFalse;
	}

//  ================================================================
LOCAL BOOL FUlFromSz( const char* const sz, ULONG* const pul, const int base = 16 )
//  ================================================================
	{
	if( sz && *sz )
		{
		char* pchEnd;
		*pul = strtoul( sz, &pchEnd, base );
		return !( *pchEnd );
		}
	return fFalse;
	}

//  ================================================================
template< class T >
LOCAL BOOL FAddressFromSz( const char* const sz, T** const ppt )
//  ================================================================
	{
	if ( sz && *sz )
		{
		int		n;
		QWORD	first;
		DWORD	second;
		int		cchRead;
		BOOL	f;

		n = sscanf( sz, "%I64x%n%*[` ]%8lx%n", &first, &cchRead, &second, &cchRead );

		switch ( n )
			{
			case 2:
				*ppt = (T*)( ( first << 32 ) | second );
				f = fTrue;
				break;

			case 1:
				*ppt = (T*)( first );
				f = fTrue;
				break;

			default:
				f = fFalse;
				break;
			};
		if ( cchRead != int( strlen( sz ) ) )
			{
			f = fFalse;
			}

		return f;
		}
	return fFalse;
	}

//  ================================================================
template< class T >
LOCAL BOOL FAddressFromGlobal( const char* const szGlobal, T** const ppt )
//  ================================================================
	{
	//  add the module prefix to the global name to form the symbol
	
	SIZE_T	cchSymbol	= strlen( szParentImageName ) + 1 + strlen( szGlobal );
	char*	szSymbol	= (char*)LocalAlloc( 0, ( cchSymbol + 1 ) * sizeof( char ) );
	if ( !szSymbol )
		{
		return fFalse;
		}
	szSymbol[ 0 ] = 0;
	if ( !strchr( szGlobal, '!' ) )
		{
		strcat( szSymbol, szParentImageName );
		strcat( szSymbol, "!" );
		}
	strcat( szSymbol, szGlobal );

	//  try forever until we manage to retrieve the entire undecorated symbol
	//  and address corresponding to this symbol

	SIZE_T cbBuf = 1024;
	BYTE* rgbBuf = (BYTE*)LocalAlloc( 0, cbBuf );
	if ( !rgbBuf )
		{
		LocalFree( (void*)szSymbol );
		return fFalse;
		}

	IMAGEHLP_SYMBOL* pis;
	do	{
		pis							= (IMAGEHLP_SYMBOL*)rgbBuf;
		pis->SizeOfStruct			= sizeof( IMAGEHLP_SYMBOL );
		pis->MaxNameLength			= DWORD( ( cbBuf - sizeof( IMAGEHLP_SYMBOL ) ) / sizeof( char ) );

		DWORD	symoptOld	= pfnSymSetOptions( symopt );
		BOOL	fSuccess	= pfnSymGetSymFromName( ghDbgProcess, PSTR( szSymbol ), pis );
		DWORD	symoptNew	= pfnSymSetOptions( symoptOld );
		
		if ( !fSuccess )
			{
			LocalFree( (void*)szSymbol );
			LocalFree( (void*)rgbBuf );
			return fFalse;
			}

		if ( strlen( pis->Name ) == cbBuf - 1 )
			{
			LocalFree( (void*)rgbBuf );
			cbBuf *= 2;
			if ( !( rgbBuf = (BYTE*)LocalAlloc( 0, cbBuf ) ) )
				{
				LocalFree( (void*)szSymbol );
				return fFalse;
				}
			}
		}
	while ( strlen( pis->Name ) == cbBuf - 1 );

	//  validate the symbols for the image containing this address

	IMAGEHLP_MODULE		im	= { sizeof( IMAGEHLP_MODULE ) };
	IMAGE_NT_HEADERS*	pnh;
	
	if (	!pfnSymGetModuleInfo( ghDbgProcess, pis->Address, &im ) ||
			!( pnh = pfnImageNtHeader( (void*)im.BaseOfImage ) ) ||
			pnh->FileHeader.TimeDateStamp != im.TimeDateStamp ||
			pnh->FileHeader.SizeOfOptionalHeader >= IMAGE_SIZEOF_NT_OPTIONAL_HEADER &&
			pnh->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC &&
			pnh->OptionalHeader.CheckSum != im.CheckSum &&
			(	pnh->FileHeader.TimeDateStamp != im.TimeDateStamp ||
				_stricmp( im.ModuleName, "kernel32" ) &&
				_stricmp( im.ModuleName, "ntdll" ) ) )
		{
		LocalFree( (void*)szSymbol );
		LocalFree( (void*)rgbBuf );
		return fFalse;
		}

	//  return the address of the symbol

	*ppt = (T*)pis->Address;

	LocalFree( (void*)szSymbol );
	LocalFree( (void*)rgbBuf );
	return fTrue;
	}

//  ================================================================
template< class T >
LOCAL BOOL FGlobalFromAddress( T* const pt, char* szGlobal, const SIZE_T cchMax, DWORD_PTR* const pdwOffset = NULL )
//  ================================================================
	{
	//  validate the symbols for the image containing this address

	IMAGEHLP_MODULE		im	= { sizeof( IMAGEHLP_MODULE ) };
	IMAGE_NT_HEADERS*	pnh;
	
	if (	!pfnSymGetModuleInfo( ghDbgProcess, DWORD_PTR( pt ), &im ) ||
			!( pnh = pfnImageNtHeader( (void*)im.BaseOfImage ) ) ||
			pnh->FileHeader.TimeDateStamp != im.TimeDateStamp ||
			pnh->FileHeader.SizeOfOptionalHeader >= IMAGE_SIZEOF_NT_OPTIONAL_HEADER &&
			pnh->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC &&
			pnh->OptionalHeader.CheckSum != im.CheckSum &&
			(	pnh->FileHeader.TimeDateStamp != im.TimeDateStamp ||
				_stricmp( im.ModuleName, "kernel32" ) &&
				_stricmp( im.ModuleName, "ntdll" ) ) )
		{
		return fFalse;
		}

	//  try forever until we manage to retrieve the entire undecorated symbol
	//  corresponding to this address

	SIZE_T cbBuf = 1024;
	BYTE* rgbBuf = (BYTE*)LocalAlloc( 0, cbBuf );
	if ( !rgbBuf )
		{
		return fFalse;
		}

	IMAGEHLP_SYMBOL* pis;
	do	{
		DWORD_PTR	dwT;
		DWORD_PTR*	pdwDisp	= pdwOffset ? pdwOffset : &dwT;

		pis							= (IMAGEHLP_SYMBOL*)rgbBuf;
		pis->SizeOfStruct			= sizeof( IMAGEHLP_SYMBOL );
		pis->MaxNameLength			= DWORD( cbBuf - sizeof( IMAGEHLP_SYMBOL ) );

		DWORD	symoptOld	= pfnSymSetOptions( symopt );
		BOOL	fSuccess	= pfnSymGetSymFromAddr( ghDbgProcess, DWORD_PTR( pt ), pdwDisp, pis );
		DWORD	symoptNew	= pfnSymSetOptions( symoptOld );
		
		if ( !fSuccess )
			{
			LocalFree( (void*)rgbBuf );
			return fFalse;
			}

		if ( strlen( pis->Name ) == cbBuf - 1 )
			{
			LocalFree( (void*)rgbBuf );
			cbBuf *= 2;
			if ( !( rgbBuf = (BYTE*)LocalAlloc( 0, cbBuf ) ) )
				{
				return fFalse;
				}
			}
		}
	while ( strlen( pis->Name ) == cbBuf - 1 );

	//  undecorate the symbol (if possible).  if not, use the decorated symbol

	char* szSymbol = (char*)LocalAlloc( 0, cchMax );
	if ( !szSymbol )
		{
		LocalFree( (void*)rgbBuf );
		return fFalse;
		}

	if ( !pfnUnDecorateSymbolName( pis->Name, szSymbol, DWORD( cchMax ), UNDNAME_COMPLETE ) )
		{
		strncpy( szSymbol, pis->Name, size_t( cchMax ) );
		szGlobal[ cchMax - 1 ] = 0;
		}

	//  write the module!symbol into the user's buffer

	_snprintf( szGlobal, size_t( cchMax ), "%s!%s", im.ModuleName, szSymbol );

	LocalFree( (void*)szSymbol );
	LocalFree( (void*)rgbBuf );
	return fTrue;
	}

//  ================================================================
template< class T >
LOCAL BOOL FFetchVariable( T* const rgtDebuggee, T** const prgt, SIZE_T ct = 1 )
//  ================================================================
	{
	//  allocate enough storage to retrieve the requested type array

	const SIZE_T cbrgt = sizeof( T ) * ct;

	if ( !( *prgt = (T*)LocalAlloc( 0, cbrgt ) ) )
		{
		return fFalse;
		}

	//  retrieve the requested type array

	if ( !ExtensionApis.lpReadProcessMemoryRoutine( (ULONG_PTR)rgtDebuggee, (void*)*prgt, DWORD( cbrgt ), NULL ) )
		{
		LocalFree( (void*)*prgt );
		return fFalse;
		}

	return fTrue;
	}

//  ================================================================
template< class T >
LOCAL BOOL FFetchGlobal( const char* const szGlobal, T** const prgt, SIZE_T ct = 1 )
//  ================================================================
	{
	//  get the address of the global in the debuggee and fetch it

	T*	rgtDebuggee;

	if ( FAddressFromGlobal( szGlobal, &rgtDebuggee )
		&& FFetchVariable( rgtDebuggee, prgt, ct ) )
		return fTrue;
	else
		{
		dprintf( "Error: Could not fetch global variable '%s'.\n", szGlobal );
		return fFalse;
		}
	}

//  ================================================================
template< class T >
LOCAL BOOL FFetchSz( T* const szDebuggee, T** const psz )
//  ================================================================
	{
	//  scan for the null terminator in the debuggee starting at the given
	//  address to get the size of the string

	const SIZE_T	ctScan				= 256;
	const SIZE_T	cbScan				= ctScan * sizeof( T );
	BYTE			rgbScan[ cbScan ];
	T*				rgtScan				= (T*)rgbScan;  //  because T can be const
	SIZE_T			itScan				= -1;
	SIZE_T			itScanLim			= 0;

	do	{
		if ( !( ++itScan % ctScan ) )
			{
			ULONG	cbRead;
			ExtensionApis.lpReadProcessMemoryRoutine(
								ULONG_PTR( szDebuggee + itScan ),
								(void*)rgbScan,
								cbScan,
								&cbRead );
				
			itScanLim = itScan + cbRead / sizeof( T );
			}
		}
	while ( itScan < itScanLim && rgtScan[ itScan % ctScan ] );

	//  we found a null terminator

	if ( itScan < itScanLim )
		{
		//  fetch the string using the determined string length

		return FFetchVariable( szDebuggee, psz, itScan + 1 );
		}

	//  we did not find a null terminator

	else
		{
		//  fail the operation

		return fFalse;
		}
	}

//  ================================================================
template< class T >
LOCAL void Unfetch( T* const rgt )
//  ================================================================
	{
	LocalFree( (void*)rgt );
	}

}  //  namespace OSSYM


using namespace OSSYM;


//  member dumping functions

class CDumpContext
	{
	public:

		CDumpContext(	CIPrintF&		iprintf,
						const DWORD_PTR	dwOffset,
						const int		cLevel )
			:	m_iprintf( iprintf ),
				m_dwOffset( dwOffset ),
				m_cLevel( cLevel )
			{
			}
	
		void* operator new( size_t cb ) { return LocalAlloc( 0, cb ); }
		void operator delete( void* pv ) { LocalFree( pv ); }

	public:

		CIPrintF&		m_iprintf;
		const DWORD_PTR	m_dwOffset;
		const int		m_cLevel;
	};

#define SYMBOL_LEN_MAX		24
#define VOID_CB_DUMP		8

//  ================================================================
LOCAL VOID SprintHex(
	CHAR * const 		szDest,
	const BYTE * const 	rgbSrc,
	const INT 			cbSrc,
	const INT 			cbWidth,
	const INT 			cbChunk,
	const INT			cbAddress,
	const INT			cbStart)
//  ================================================================
	{
	static const CHAR rgchConvert[] =	{ '0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f' };
			
	const BYTE * const pbMax = rgbSrc + cbSrc;
	const INT cchHexWidth = ( cbWidth * 2 ) + (  cbWidth / cbChunk );

	const BYTE * pb = rgbSrc;
	CHAR * sz = szDest;
	while( pbMax != pb )
		{
		sz += ( 0 == cbAddress ) ? 0 : sprintf( sz, "%*.*lx    ", cbAddress, cbAddress, pb - rgbSrc + cbStart );
		CHAR * szHex	= sz;
		CHAR * szText	= sz + cchHexWidth;
		do
			{
			for( INT cb = 0; cbChunk > cb && pbMax != pb; ++cb, ++pb )
				{
				*szHex++ 	= rgchConvert[ *pb >> 4 ];
				*szHex++ 	= rgchConvert[ *pb & 0x0F ];
				*szText++ 	= isprint( *pb ) ? *pb : '.';
				}
			*szHex++ = ' ';
			} while( ( ( pb - rgbSrc ) % cbWidth ) && pbMax > pb );
		while( szHex != sz + cchHexWidth )
			{
			*szHex++ = ' ';
			}
		*szText++ = '\n';
		*szText = '\0';
		sz = szText;
		}
	}

template< class M >
inline void DumpMemberValue(	CDumpContext&	dc,
								const M&		m )
	{
	char szHex[ 1024 ] = "\n";
	
	SprintHex(	szHex,
				(BYTE *)&m,
				min( sizeof( M ), VOID_CB_DUMP ),
				min( sizeof( M ), VOID_CB_DUMP ) + 1,
				4,
				0,
				0 );

	dc.m_iprintf( _T( "%s" ), szHex );
	}

template< class M >
inline void DumpMember_(	CDumpContext&		dc,
							const M&			m,
							const _TCHAR* const	szM )
	{
	if ( dc.m_cLevel > 0 )
		{
		dc.m_iprintf.Indent();
		
		dc.m_iprintf(	_T( "%*.*s <0x%0*I64x,%3i>:  " ),
						SYMBOL_LEN_MAX,
						SYMBOL_LEN_MAX,
						szM,
						sizeof( void* ) * 2,
						QWORD( (char*)&m + dc.m_dwOffset ),
						sizeof( M ) );
		DumpMemberValue( CDumpContext( dc.m_iprintf, dc.m_dwOffset, dc.m_cLevel - 1 ), m );

		dc.m_iprintf.Unindent();
		}
	}

#define DumpMember( dc, member ) ( DumpMember_( dc, member, #member ) )

template< class M >
inline void DumpMemberValueBF(	CDumpContext&	dc,
								const M			m )
	{
	if ( M( 0 ) - M( 1 ) < M( 0 ) )
		{
		dc.m_iprintf(	_T( "%I64i (0x%0*I64x)\n" ),
						QWORD( m ),
						sizeof( m ) * 2,
						QWORD( m ) & ( ( QWORD( 1 ) << ( sizeof( m ) * 8 ) ) - 1 ) );
		}
	else
		{
		dc.m_iprintf(	_T( "%I64u (0x%0*I64x)\n" ),
						QWORD( m ),
						sizeof( m ) * 2,
						QWORD( m ) & ( ( QWORD( 1 ) << ( sizeof( m ) * 8 ) ) - 1 ) );
		}
	}

template< class M >
inline void DumpMemberBF_(	CDumpContext&		dc,
							const M				m,
							const _TCHAR* const	szM )
	{
	if ( dc.m_cLevel > 0 )
		{
		dc.m_iprintf.Indent();

		dc.m_iprintf(	_T( "%*.*s <%-*.*s>:  " ),
						SYMBOL_LEN_MAX,
						SYMBOL_LEN_MAX,
						szM,
						2 + sizeof( void* ) * 2 + 1 + 3,
						2 + sizeof( void* ) * 2 + 1 + 3,
						_T( "Bit-Field" ) );
		DumpMemberValueBF( CDumpContext( dc.m_iprintf, dc.m_dwOffset, dc.m_cLevel - 1 ), m );

		dc.m_iprintf.Unindent();
		}
	}

#define DumpMemberBF( dc, member ) ( DumpMemberBF_( dc, member, #member ) )


LOCAL WINDBG_EXTENSION_APIS ExtensionApis;

LOCAL BOOL fInit 		= fFalse;	//	debugger extensions have geen initialized

//  ================================================================
class CDPrintF : public CPrintF
//  ================================================================
	{
	public:
		VOID __cdecl operator()( const char * szFormat, ... )
			{
			va_list arg_ptr;
			va_start( arg_ptr, szFormat );
			_vsnprintf( szBuf, sizeof( szBuf ), szFormat, arg_ptr );
			va_end( arg_ptr );
			szBuf[ sizeof( szBuf ) - 1 ] = 0;
			(ExtensionApis.lpOutputRoutine)( "%s", szBuf );
			}

		static CPrintF& PrintfInstance();
		
		~CDPrintF() {}

	private:
		CDPrintF() {}
		static CHAR szBuf[1024];	//  WARNING: not multi-threaded safe!
	};

CHAR CDPrintF::szBuf[1024];

//  ================================================================
CPrintF& CDPrintF::PrintfInstance()
//  ================================================================
	{
	static CDPrintF s_dprintf;
	return s_dprintf;
	}

CIPrintF g_idprintf( &CDPrintF::PrintfInstance() );


//  ================================================================
class CDUMP
//  ================================================================
	{
	public:
		CDUMP() {}
		virtual ~CDUMP() {}
		
		virtual VOID Dump( HANDLE, HANDLE, DWORD, PWINDBG_EXTENSION_APIS, INT, const CHAR * const [] ) = 0;
	};
	

//  ================================================================
template< class _STRUCT>
class CDUMPA : public CDUMP
//  ================================================================
	{
	public:		
		VOID Dump(
			    HANDLE hCurrentProcess,
			    HANDLE hCurrentThread,
			    DWORD dwCurrentPc,
			    PWINDBG_EXTENSION_APIS lpExtensionApis,
			    INT argc,
			    const CHAR * const argv[] );
		static CDUMPA	instance;
	};

template< class _STRUCT>
CDUMPA<_STRUCT> CDUMPA<_STRUCT>::instance;


//  ****************************************************************
//  PROTOTYPES
//  ****************************************************************

#define DEBUG_EXT( name )					\
	LOCAL VOID name(						\
		const HANDLE hCurrentProcess,		\
		const HANDLE hCurrentThread,		\
		const DWORD dwCurrentPc,			\
	    const PWINDBG_EXTENSION_APIS lpExtensionApis,	\
	    const INT argc,						\
	    const CHAR * const argv[]  )

DEBUG_EXT( EDBGDump );
DEBUG_EXT( EDBGTest );
#ifdef SYNC_DEADLOCK_DETECTION
DEBUG_EXT( EDBGLocks );
#endif  //  SYNC_DEADLOCK_DETECTION
DEBUG_EXT( EDBGHelp );
DEBUG_EXT( EDBGHelpDump );


//  ****************************************************************
//  COMMAND DISPATCH
//  ****************************************************************


typedef VOID (*EDBGFUNC)(
	const HANDLE hCurrentProcess,
	const HANDLE hCurrentThread,
	const DWORD dwCurrentPc,
    const PWINDBG_EXTENSION_APIS lpExtensionApis,
    const INT argc,
    const CHAR * const argv[]
    );


//  ================================================================
struct EDBGFUNCMAP
//  ================================================================
	{
	const char * 	szCommand;
	EDBGFUNC		function;
	const char * 	szHelp;
	};


//  ================================================================
struct CDUMPMAP
//  ================================================================
	{
	const char * 	szCommand;
	CDUMP 	   *	pcdump;
	const char * 	szHelp;
	};


//  ================================================================
LOCAL EDBGFUNCMAP rgfuncmap[] = {
//  ================================================================

	{
		"Help",		EDBGHelp,
		"Help                   - Print this help message"
	},
	{
		"Dump",		EDBGDump,
		"Dump <Object> <Address> [<Depth>|*]\n\t"
		"                       - Dump a given synchronization object's state"
	},
#ifdef SYNC_DEADLOCK_DETECTION
	{
		"Locks",		EDBGLocks,
		"Locks [<tid>|* [<OSSYNC::pclsSyncGlobal>]]\n\t"
		"                       - List all locks owned by the specified thread or by all threads"
	},
#endif  //  SYNC_DEADLOCK_DETECTION
	{
		"Test",		EDBGTest,
		"Test                   - Test function"
	},
	};

LOCAL const int cfuncmap = sizeof( rgfuncmap ) / sizeof( EDBGFUNCMAP );


#define DUMPA(_struct)	{ #_struct, &(CDUMPA<_struct>::instance), #_struct " <Address> [<Depth>|*]" }

//  ================================================================
LOCAL CDUMPMAP rgcdumpmap[] = {
//  ================================================================

	DUMPA( CAutoResetSignal ),
	DUMPA( CBinaryLock ),
	DUMPA( CCriticalSection ),
	DUMPA( CGate ),
	DUMPA( CKernelSemaphore ),
	DUMPA( CManualResetSignal ),
	DUMPA( CMeteredSection ),
	DUMPA( CNestableCriticalSection ),
	DUMPA( CReaderWriterLock ),
	DUMPA( CSemaphore ),
	DUMPA( CSXWLatch )
	};

LOCAL const int ccdumpmap = sizeof( rgcdumpmap ) / sizeof( CDUMPMAP );


//  ================================================================
LOCAL BOOL FArgumentMatch( const CHAR * const sz, const CHAR * const szCommand )
//  ================================================================
	{
	const BOOL fMatch = ( ( strlen( sz ) == strlen( szCommand ) )
			&& !( _strnicmp( sz, szCommand, strlen( szCommand ) ) ) );
	return fMatch;
	}


//  ================================================================
DEBUG_EXT( EDBGDump )
//  ================================================================
	{
	if( argc < 2 )
		{
		EDBGHelpDump( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, argv );
		return;
		}
		
	for( int icdumpmap = 0; icdumpmap < ccdumpmap; ++icdumpmap )
		{
		if( FArgumentMatch( argv[0], rgcdumpmap[icdumpmap].szCommand ) )
			{
			(rgcdumpmap[icdumpmap].pcdump)->Dump(
				hCurrentProcess,
				hCurrentThread,
				dwCurrentPc,
				lpExtensionApis,
				argc - 1, argv + 1 );
			return;
			}
		}
	EDBGHelpDump( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, argv );
	}


//  ================================================================
DEBUG_EXT( EDBGHelp )
//  ================================================================
	{
	for( int ifuncmap = 0; ifuncmap < cfuncmap; ifuncmap++ )
		{
		dprintf( "\t%s\n", rgfuncmap[ifuncmap].szHelp );
		}
	dprintf( "\n--------------------\n\n" );
	}


//  ================================================================
DEBUG_EXT( EDBGHelpDump )
//  ================================================================
	{
	dprintf( "Supported objects:\n\n" );
	for( int icdumpmap = 0; icdumpmap < ccdumpmap; icdumpmap++ )
		{
		dprintf( "\t%s\n", rgcdumpmap[icdumpmap].szHelp );
		}
	dprintf( "\n--------------------\n\n" );
	}


//  ================================================================
DEBUG_EXT( EDBGTest )
//  ================================================================
	{
	if ( argc >= 1 )
		{
		void* pv;
		if ( FAddressFromGlobal( argv[ 0 ], &pv ) )
			{
			dprintf(	"The address of %s is 0x%0*I64X.\n",
						argv[ 0 ],
						sizeof( void* ) * 2,
						QWORD( pv ) );
			}
		else
			{
			dprintf( "Could not find the symbol.\n" );
			}
		}
	if ( argc >= 2 )
		{
		void* pv;
		if ( FAddressFromSz( argv[ 1 ], &pv ) )
			{
			char		szGlobal[ 1024 ];
			DWORD_PTR	dwOffset;
			if ( FGlobalFromAddress( pv, szGlobal, sizeof( szGlobal ), &dwOffset ) )
				{
				dprintf(	"The symbol closest to 0x%0*I64X is %s+0x%I64X.\n",
							sizeof( void* ) * 2,
							QWORD( pv ),
							szGlobal,
							QWORD( dwOffset ) );
				}
			else
				{
				dprintf( "Could not map this address to a symbol.\n" );
				}
			}
		else
			{
			dprintf( "That is not a valid address.\n" );
			}
		}

	dprintf( "\n--------------------\n\n" );
	}


#ifdef SYNC_DEADLOCK_DETECTION

//  ================================================================
DEBUG_EXT( EDBGLocks )
//  ================================================================
	{
	//  load default arguments

	_CLS*	pclsDebuggee				= NULL;
	DWORD	tid							= 0;
	BOOL	fFoundLock					= fFalse;
	BOOL	fValidUsage;

	//  load actual arguments

	switch ( argc )
		{
		case 0:
			//	use defaults
			fValidUsage = fTrue;
			break;
		case 1:
			//	thread-id only
			fValidUsage = ( FUlFromSz( argv[0], &tid )
							|| '*' == argv[0][0] );
			break;
		case 2:
			//	thread-id followed by <pclsSyncGlobal>
			fValidUsage = ( ( FUlFromSz( argv[0], &tid ) || '*' == argv[0][0] )
							&& FAddressFromSz( argv[1], &pclsDebuggee ) );
			break;
		default:
			fValidUsage = fFalse;
			break;
			}

	if ( !fValidUsage )
		{
		dprintf( "Usage: Locks [<tid>|* [<OSSYNC::pclsSyncGlobal>]]\n" );
		return;
		}

	if ( NULL == pclsDebuggee )
		{
		_CLS**	ppclsDebuggee	= NULL;
		if ( FFetchGlobal( "OSSYNC::pclsSyncGlobal", &ppclsDebuggee ) )
			{
			pclsDebuggee = *ppclsDebuggee;
			Unfetch( ppclsDebuggee );
			}
		else
			{
			dprintf( "Error: Could not find the global TLS list in the debuggee.\n" );
			return;
			}
		}

	while ( pclsDebuggee )
		{
		_CLS* pcls;
		if ( !FFetchVariable( pclsDebuggee, &pcls ) )
			{
			dprintf( "An error occurred while scanning Thread IDs.\n" );
			break;
			}

		if ( !tid || pcls->dwContextId == tid )
			{
			if ( pcls->cls.plddiLockWait )
				{
				CLockDeadlockDetectionInfo*	plddi			= NULL;
				const CLockBasicInfo*		plbi			= NULL;
				const char*					pszTypeName		= NULL;
				const char*					pszInstanceName	= NULL;
				
				if (	FFetchVariable( pcls->cls.plddiLockWait, &plddi ) &&
						FFetchVariable( &plddi->Info(), &plbi ) &&
						FFetchSz( plbi->SzTypeName(), &pszTypeName ) &&
						FFetchSz( plbi->SzInstanceName(), &pszInstanceName ) )
					{
					fFoundLock = fTrue;

					dprintf(	"TID %d is a waiter for %s 0x%0*I64X ( \"%s\", %d, %d )",
								pcls->dwContextId,
								pszTypeName,
								sizeof( void* ) * 2,
								QWORD( plbi->Instance() ),
								pszInstanceName,
								plbi->Rank(),
								plbi->SubRank() );
					if ( pcls->cls.groupLockWait != -1 )
						{
						dprintf( " as Group %d", pcls->cls.groupLockWait );
						}
					dprintf( ".\n" );
					}
				else
					{
					dprintf(	"An error occurred while reading TLS for Thread ID %d.\n",
								pcls->dwContextId );
					}

				Unfetch( pszInstanceName );
				Unfetch( pszTypeName );
				Unfetch( plbi );
				Unfetch( plddi );
				}
					
			COwner* pownerDebuggee;
			pownerDebuggee = pcls->cls.pownerLockHead;
			
			while ( pownerDebuggee )
				{
				COwner*						powner			= NULL;
				CLockDeadlockDetectionInfo*	plddi			= NULL;
				const CLockBasicInfo*		plbi			= NULL;
				const char*					pszTypeName		= NULL;
				const char*					pszInstanceName	= NULL;
				
				if (	FFetchVariable( pownerDebuggee, &powner ) &&
						FFetchVariable( powner->m_plddiOwned, &plddi ) &&
						FFetchVariable( &plddi->Info(), &plbi ) &&
						FFetchSz( plbi->SzTypeName(), &pszTypeName ) &&
						FFetchSz( plbi->SzInstanceName(), &pszInstanceName ) )
						
					{
					fFoundLock = fTrue;

					dprintf(	"TID %d is an owner of %s 0x%0*I64X ( \"%s\", %d, %d )",
								pcls->dwContextId,
								pszTypeName,
								sizeof( void* ) * 2,
								QWORD( plbi->Instance() ),
								pszInstanceName,
								plbi->Rank(),
								plbi->SubRank() );
					if ( powner->m_group != -1 )
						{
						dprintf( " as Group %d", powner->m_group );
						}
					dprintf( ".\n" );
					}
				else
					{
					dprintf(	"An error occurred while scanning the lock chain for Thread ID %d.\n",
								pcls->dwContextId );
					}

				pownerDebuggee = powner ? powner->m_pownerLockNext : NULL;

				Unfetch( pszInstanceName );
				Unfetch( pszTypeName );
				Unfetch( plbi );
				Unfetch( plddi );
				Unfetch( powner );
				}
			}

		pclsDebuggee = pcls ? pcls->pclsNext : NULL;
			
		Unfetch( pcls );
		}

	if ( fFoundLock )
		{
		dprintf( "\n--------------------\n\n" );
		}
	else if ( !tid )
		{
		dprintf( "No thread owns or is waiting for any locks.\n" );
		}
	else
		{
		dprintf( "This thread does not own and is not waiting for any locks.\n" );
		}
	}

#endif  //  SYNC_DEADLOCK_DETECTION

//  ================================================================
template< class _STRUCT>
VOID CDUMPA<_STRUCT>::Dump(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    INT argc, const CHAR * const argv[]
    )
//  ================================================================
	{
	_STRUCT*	ptDebuggee;
	ULONG		cLevelInput;
	if (	argc < 1 ||
			argc > 2 ||
			!FAddressFromSz( argv[ 0 ], &ptDebuggee ) ||
			argc == 2 && !FUlFromSz( argv[ 1 ], &cLevelInput, 10 ) && strcmp( argv[ 1 ], "*" ) )
		{
		dprintf( "Usage: Dump <Object> <Address> [<Depth>|*]\n" );
		return;
		}

	int cLevel;
	if ( argc == 2 )
		{
		if ( FUlFromSz( argv[ 1 ], &cLevelInput, 10 ) )
			{
			cLevel = int( cLevelInput );
			}
		else
			{
			cLevel = INT_MAX;
			}
		}
	else
		{
		cLevel = 1;
		}

	_STRUCT* pt;
	if ( FFetchVariable( ptDebuggee, &pt ) )
		{
		dprintf(	"0x%0*I64X bytes @ 0x%0*I64X\n",
					sizeof( size_t ) * 2,
					QWORD( sizeof( _STRUCT ) ),
					sizeof( _STRUCT* ) * 2,
					QWORD( ptDebuggee ) );

		pt->Dump( CDumpContext( g_idprintf, (BYTE*)ptDebuggee - (BYTE*)pt, cLevel ) );
			
		Unfetch( pt );
		}
	else
		{
		dprintf( "Error: Could not fetch the requested object.\n" );
		}
	}


VOID OSSYNCAPI OSSyncDebuggerExtension(	HANDLE hCurrentProcess,
										HANDLE hCurrentThread,
										DWORD dwCurrentPc,
										PWINDBG_EXTENSION_APIS lpExtensionApis,
										const INT argc,
										const CHAR * const argv[] )
	{
    ExtensionApis 	= *lpExtensionApis;

	if ( !fInit )
		{
		//  get our containing image name so that we can look up our variables

		if ( !FSymInit( hCurrentProcess ) )
			{
			return;
			}
		
		fInit = fTrue;
		}

	if( argc < 1 )
		{
		EDBGHelp( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, (const CHAR **)argv );
		return;
		}

	INT ifuncmap;
	for( ifuncmap = 0; ifuncmap < cfuncmap; ifuncmap++ )
		{
		if( FArgumentMatch( argv[0], rgfuncmap[ifuncmap].szCommand ) )
			{
			(rgfuncmap[ifuncmap].function)(
				hCurrentProcess,
				hCurrentThread,
				dwCurrentPc,
				lpExtensionApis,
				argc - 1, (const CHAR **)( argv + 1 ) );
			return;
			}
		}
	EDBGHelp( hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis, argc, (const CHAR **)argv );
	}

#endif  //  DEBUGGER_EXTENSION


//  custom member dump functions

template<>
inline void DumpMemberValue< const char* >(	CDumpContext&		dc,
											const char* const &	sz )
	{
	const char* szFetch = NULL;
	
	dc.m_iprintf( "0x%0*I64x ", sizeof( sz ) * 2, QWORD( sz ) );
	if ( FFetchSz( sz, &szFetch ) )
		{
		dc.m_iprintf( "\"%s\"", szFetch );
		}
	dc.m_iprintf( "\n" );
		
	Unfetch( szFetch );
	}

template<>
inline void DumpMemberValue< CSemaphore >(	CDumpContext&		dc,
											const CSemaphore&	sem )
	{
	dc.m_iprintf( "\n" );
	sem.Dump( dc );
	}


//  Enhanced Synchronization Object State Container Dump Support

template< class CState, class CStateInit, class CInformation, class CInformationInit >
void CEnhancedStateContainer< CState, CStateInit, CInformation, CInformationInit >::
Dump( CDumpContext& dc ) const
	{
#ifdef SYNC_ENHANCED_STATE

	CEnhancedState* pes = NULL;

	if ( FFetchVariable( m_pes, &pes ) )
		{
		CDumpContext dcES( dc.m_iprintf, (BYTE*)m_pes - (BYTE*)pes, dc.m_cLevel );
		
		pes->CState::Dump( dcES );
		pes->CInformation::Dump( dcES );
		}
	else
		{
		dprintf( "Error: Could not fetch the enhanced state of the requested object.\n" );
		}

	Unfetch( pes );

#else  //  !SYNC_ENHANCED_STATE

	CEnhancedState* pes = (CEnhancedState*) m_rgbState;

	pes->CState::Dump( dc );
	pes->CInformation::Dump( dc );

#endif  //  SYNC_ENHANCED_STATE
	}


//  Synchronization Object Basic Information Dump Support

void CSyncBasicInfo::Dump( CDumpContext& dc ) const
	{
#ifdef SYNC_ENHANCED_STATE

	DumpMember( dc, m_szInstanceName );
	DumpMember( dc, m_szTypeName );
	DumpMember( dc, m_psyncobj );

#endif  //  SYNC_ENHANCED_STATE
	}


//  Synchronization Object Performance Dump Support

void CSyncPerfWait::Dump( CDumpContext& dc ) const
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	DumpMember( dc, m_cWait );
	DumpMember( dc, m_qwHRTWaitElapsed );

#endif  //  SYNC_ANALYZE_PERFORMANCE
	}

void CSyncPerfAcquire::Dump( CDumpContext& dc ) const
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	DumpMember( dc, m_cAcquire );
	DumpMember( dc, m_cContend );

#endif  //  SYNC_ANALYZE_PERFORMANCE
	}


//  Lock Object Basic Information Dump Support

void CLockBasicInfo::Dump( CDumpContext& dc ) const
	{
	CSyncBasicInfo::Dump( dc );

#ifdef SYNC_DEADLOCK_DETECTION

	DumpMember( dc, m_rank );
	DumpMember( dc, m_subrank );

#endif  //  SYNC_DEADLOCK_DETECTION
	}


//  Lock Object Performance Dump Support

void CLockPerfHold::Dump( CDumpContext& dc ) const
	{
#ifdef SYNC_ANALYZE_PERFORMANCE

	DumpMember( dc, m_cHold );
	DumpMember( dc, m_qwHRTHoldElapsed );

#endif  //  SYNC_ANALYZE_PERFORMANCE
	}


//  Lock Object Deadlock Detection Information Dump Support

void CLockDeadlockDetectionInfo::Dump( CDumpContext& dc ) const
	{
#ifdef SYNC_DEADLOCK_DETECTION

	DumpMember( dc, m_plbiParent );
	DumpMember( dc, m_semOwnerList );
	DumpMember( dc, m_ownerHead );

#endif  //  SYNC_DEADLOCK_DETECTION
	}


//  Kernel Semaphore Dump Support

void CKernelSemaphoreState::Dump( CDumpContext& dc ) const
	{
	DumpMember( dc, m_handle );
	}

void CKernelSemaphoreInfo::Dump( CDumpContext& dc ) const
	{
	CSyncBasicInfo::Dump( dc );
	CSyncPerfWait::Dump( dc );
	}

void CKernelSemaphore::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CKernelSemaphoreState, CSyncStateInitNull, CKernelSemaphoreInfo, CSyncBasicInfo >::Dump( dc );
	}


//  Semaphore Dump Support

void CSemaphoreState::Dump( CDumpContext& dc ) const
	{
	if ( FNoWait() )
		{
		DumpMember( dc, m_cAvail );
		}
	else
		{
		DumpMember( dc, m_irksem );
		DumpMember( dc, m_cWaitNeg );
		}
	}

void CSemaphoreInfo::Dump( CDumpContext& dc ) const
	{
	CSyncBasicInfo::Dump( dc );
	CSyncPerfWait::Dump( dc );
	CSyncPerfAcquire::Dump( dc );
	}

void CSemaphore::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CSemaphoreState, CSyncStateInitNull, CSemaphoreInfo, CSyncBasicInfo >::Dump( dc );
	}


//  Auto-Reset Signal Dump Support

void CAutoResetSignalState::Dump( CDumpContext& dc ) const
	{
	if ( FNoWait() )
		{
		DumpMember( dc, m_fSet );
		}
	else
		{
		DumpMember( dc, m_irksem );
		DumpMember( dc, m_cWaitNeg );
		}
	}

void CAutoResetSignalInfo::Dump( CDumpContext& dc ) const
	{
	CSyncBasicInfo::Dump( dc );
	CSyncPerfWait::Dump( dc );
	CSyncPerfAcquire::Dump( dc );
	}

void CAutoResetSignal::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CAutoResetSignalState, CSyncStateInitNull, CAutoResetSignalInfo, CSyncBasicInfo >::Dump( dc );
	}


//  Manual-Reset Signal Dump Support

void CManualResetSignalState::Dump( CDumpContext& dc ) const
	{
	if ( FNoWait() )
		{
		DumpMember( dc, m_fSet );
		}
	else
		{
		DumpMember( dc, m_irksem );
		DumpMember( dc, m_cWaitNeg );
		}
	}

void CManualResetSignalInfo::Dump( CDumpContext& dc ) const
	{
	CSyncBasicInfo::Dump( dc );
	CSyncPerfWait::Dump( dc );
	CSyncPerfAcquire::Dump( dc );
	}

void CManualResetSignal::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CManualResetSignalState, CSyncStateInitNull, CManualResetSignalInfo, CSyncBasicInfo >::Dump( dc );
	}


//  Critical Section (non-nestable) Dump Support

void CCriticalSectionState::Dump( CDumpContext& dc ) const
	{
	DumpMember( dc, m_sem );
	}

void CCriticalSectionInfo::Dump( CDumpContext& dc ) const
	{
	CLockBasicInfo::Dump( dc );
	CLockPerfHold::Dump( dc );
	CLockDeadlockDetectionInfo::Dump( dc );
	}

void CCriticalSection::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CCriticalSectionState, CSyncBasicInfo, CCriticalSectionInfo, CLockBasicInfo >::Dump( dc );
	}


//  Nestable Critical Section Dump Support

void CNestableCriticalSectionState::Dump( CDumpContext& dc ) const
	{
	DumpMember( dc, m_sem );
	DumpMember( dc, m_pclsOwner );
	DumpMember( dc, m_cEntry );
	}

void CNestableCriticalSectionInfo::Dump( CDumpContext& dc ) const
	{
	CLockBasicInfo::Dump( dc );
	CLockPerfHold::Dump( dc );
	CLockDeadlockDetectionInfo::Dump( dc );
	}
	
void CNestableCriticalSection::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CNestableCriticalSectionState, CSyncBasicInfo, CNestableCriticalSectionInfo, CLockBasicInfo >::Dump( dc );
	}


//  Gate Dump Support

void CGateState::Dump( CDumpContext& dc ) const
	{
	DumpMember( dc, m_cWait );
	DumpMember( dc, m_irksem );
	}

void CGateInfo::Dump( CDumpContext& dc ) const
	{
	CSyncBasicInfo::Dump( dc );
	CSyncPerfWait::Dump( dc );
	}
	
void CGate::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CGateState, CSyncStateInitNull, CGateInfo, CSyncBasicInfo >::Dump( dc );
	}


//  Binary Lock Dump Support

void CBinaryLockState::Dump( CDumpContext& dc ) const
	{
	DumpMember( dc, m_cw );
	DumpMemberBF( dc, m_cOOW1 );
	DumpMemberBF( dc, m_fQ1 );
	DumpMemberBF( dc, m_cOOW2 );
	DumpMemberBF( dc, m_fQ2 );
	DumpMember( dc, m_cOwner );
	DumpMember( dc, m_sem1 );
	DumpMember( dc, m_sem2 );
	}

void CBinaryLockPerfInfo::Dump( CDumpContext& dc ) const
	{
	CSyncPerfWait::Dump( dc );
	CSyncPerfAcquire::Dump( dc );
	CLockPerfHold::Dump( dc );
	}

void CBinaryLockGroupInfo::Dump( CDumpContext& dc ) const
	{
	for ( int iGroup = 0; iGroup < 2; iGroup++ )
		{
		m_rginfo[iGroup].Dump( dc );
		}
	}

void CBinaryLockInfo::Dump( CDumpContext& dc ) const
	{
	CLockBasicInfo::Dump( dc );
	CBinaryLockGroupInfo::Dump( dc );
	CLockDeadlockDetectionInfo::Dump( dc );
	}

void CBinaryLock::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CBinaryLockState, CSyncBasicInfo, CBinaryLockInfo, CLockBasicInfo >::Dump( dc );
	}


//  Reader / Writer Lock Dump Support

void CReaderWriterLockState::Dump( CDumpContext& dc ) const
	{
	DumpMember( dc, m_cw );
	DumpMemberBF( dc, m_cOAOWW );
	DumpMemberBF( dc, m_fQW );
	DumpMemberBF( dc, m_cOOWR );
	DumpMemberBF( dc, m_fQR );
	DumpMember( dc, m_cOwner );
	DumpMember( dc, m_semWriter );
	DumpMember( dc, m_semReader );
	}

void CReaderWriterLockPerfInfo::Dump( CDumpContext& dc ) const
	{
	CSyncPerfWait::Dump( dc );
	CSyncPerfAcquire::Dump( dc );
	CLockPerfHold::Dump( dc );
	}

void CReaderWriterLockGroupInfo::Dump( CDumpContext& dc ) const
	{
	for ( int iGroup = 0; iGroup < 2; iGroup++ )
		{
		m_rginfo[iGroup].Dump( dc );
		}
	}

void CReaderWriterLockInfo::Dump( CDumpContext& dc ) const
	{
	CLockBasicInfo::Dump( dc );
	CReaderWriterLockGroupInfo::Dump( dc );
	CLockDeadlockDetectionInfo::Dump( dc );
	}

void CReaderWriterLock::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CReaderWriterLockState, CSyncBasicInfo, CReaderWriterLockInfo, CLockBasicInfo >::Dump( dc );
	}


//  Metered Section Dump Support

void CMeteredSection::Dump( CDumpContext& dc ) const
	{
	DumpMember( dc, m_pfnPartitionComplete );
	DumpMember( dc, m_dwPartitionCompleteKey );

	DumpMember( dc, m_cw );
	DumpMemberBF( dc, m_cCurrent );
	DumpMemberBF( dc, m_groupCurrent );
	DumpMemberBF( dc, m_cQuiesced );
	DumpMemberBF( dc, m_groupQuiesced );
	}


//  S / X / W Latch Dump Support

void CSXWLatchState::Dump( CDumpContext& dc ) const
	{
	DumpMember( dc, m_cw );
	DumpMemberBF( dc, m_cOAWX );
	DumpMemberBF( dc, m_cOOWS );
	DumpMemberBF( dc, m_fQS );
	DumpMemberBF( dc, m_cQS );
	DumpMember( dc, m_semS );
	DumpMember( dc, m_semX );
	DumpMember( dc, m_semW );
	}

void CSXWLatchPerfInfo::Dump( CDumpContext& dc ) const
	{
	CSyncPerfWait::Dump( dc );
	CSyncPerfAcquire::Dump( dc );
	CLockPerfHold::Dump( dc );
	}

void CSXWLatchGroupInfo::Dump( CDumpContext& dc ) const
	{
	for ( int iGroup = 0; iGroup < 3; iGroup++ )
		{
		m_rginfo[iGroup].Dump( dc );
		}
	}

void CSXWLatchInfo::Dump( CDumpContext& dc ) const
	{
	CLockBasicInfo::Dump( dc );
	CSXWLatchGroupInfo::Dump( dc );
	CLockDeadlockDetectionInfo::Dump( dc );
	}

void CSXWLatch::Dump( CDumpContext& dc ) const
	{
	CEnhancedStateContainer< CSXWLatchState, CSyncBasicInfo, CSXWLatchInfo, CLockBasicInfo >::Dump( dc );
	}


//  Sync Stats support

CIPrintF*		piprintfPerfData;
CFPrintF*		pfprintfPerfData;

//  dump column descriptors

void OSSyncStatsDumpColumns()
	{
	(*piprintfPerfData)(	"Type Name\t"
							"Instance Name\t"
							"Instance ID\t"
							"Group ID\t"
							"Wait Count\t"
							"Wait Time Elapsed\t"
							"Acquire Count\t"
							"Contention Count\t"
							"Hold Count\t"
							"Hold Time Elapsed\r\n" );
	}

//  dump cooked stats from provided raw stats

void OSSyncStatsDump(	const char*			szTypeName,
						const char*			szInstanceName,
						const CSyncObject*	psyncobj,
						DWORD				group,
						QWORD				cWait,
						double				csecWaitElapsed,
						QWORD				cAcquire,
						QWORD				cContend,
						QWORD				cHold,
						double				csecHoldElapsed )
	{
	//  dump data, if interesting
		
	if ( cWait || cAcquire || cContend || cHold )
		{
		(*piprintfPerfData)(	"\"%s\"\t"
								"\"%s\"\t"
								"\"0x%0*I64X\"\t"
								"%d\t"
								"%I64d\t"
								"%f\t"
								"%I64d\t"
								"%I64d\t"
								"%I64d\t"
								"%f\r\n",
								szTypeName,
								szInstanceName,
								sizeof(LONG_PTR) * 2,			//	need 2 hex digits for each byte
								QWORD( LONG_PTR( psyncobj ) ),	//	assumes QWORD is largest pointer size we'll ever use
								group,
								cWait,
								csecWaitElapsed,
								cAcquire,
								cContend,
								cHold,
								csecHoldElapsed );
		}
	}


volatile DWORD cOSSyncInit;  //  assumed init to 0 by the loader

//	cleanup sync subsystem for term (or error on init)

static void OSSYNCAPI OSSyncICleanup()
	{
	OSSYNCAssert( (long)cOSSyncInit == lOSSyncLockedForTerm
				|| (long)cOSSyncInit == lOSSyncLockedForInit );

#ifdef SYNC_DUMP_PERF_DATA

	//  terminate performance data dump context

	if ( NULL != piprintfPerfData )
		{
		((CIPrintF*)piprintfPerfData)->~CIPrintF();
		LocalFree( piprintfPerfData );
		piprintfPerfData = NULL;
		}

	if ( NULL != piprintfPerfData )
		{
		((CFPrintF*)pfprintfPerfData)->~CFPrintF();
		LocalFree( pfprintfPerfData );
		pfprintfPerfData = NULL;
		}

#endif  //  SYNC_DUMP_PERF_DATA

	//  terminate the Kernel Semaphore Pool

	if ( ksempoolGlobal.FInitialized() )
		{
		ksempoolGlobal.Term();
		}

	//  terminate the CEnhancedState allocator

	OSSYNCAssert( g_pmbRoot == &g_mbSentry );
	while ( g_pmbRootFree != &g_mbSentryFree )
		{
		MemoryBlock* const pmb = g_pmbRootFree;

		*pmb->ppmbNext = pmb->pmbNext;
		pmb->pmbNext->ppmbNext = pmb->ppmbNext;
		
		BOOL fMemFreed = VirtualFree( pmb, 0, MEM_RELEASE );
		OSSYNCAssert( fMemFreed );
		}
	DeleteCriticalSection( &g_csESMemory );
	
	DeleteCriticalSection( &csClsSyncGlobal );

	//  term OSSYM

	SymTerm();

	//	unlock sync subsystem

	OSSYNCAssert( (long)cOSSyncInit == lOSSyncLockedForTerm
				|| (long)cOSSyncInit == lOSSyncLockedForInit );
	AtomicExchange( (long*)&cOSSyncInit, 0 );
	}


//  init sync subsystem

static BOOL OSSYNCAPI FOSSyncIInit()
	{
	BOOL	fInitRequired	= fFalse;

	OSSYNC_FOREVER
		{
		const long	lInitial	= ( cOSSyncInit & lOSSyncUnlocked );
		const long	lFinal		= ( 0 == lInitial ? lOSSyncLockedForInit : lInitial + 1 );

		//	if multiple threads try to init/term simultaneously, one will win
		//	and the others will loop until he's done

		if ( lInitial == AtomicCompareExchange( (long*)&cOSSyncInit, lInitial, lFinal ) )
			{
			fInitRequired = ( 0 == lInitial );
			break;
			}
		else if ( cOSSyncInit & lOSSyncLocked )
			{
			//	our AtomicCompareExchange() appears to have failed because
			//	the sync subsystem is locked for init/term, so sleep a bit
			//	to allow time for the init/term to complete
			Sleep( 1 );
			}
		}

	if ( fInitRequired )
		{
		//  reset all pointers

		piprintfPerfData	= NULL;
		pfprintfPerfData	= NULL;
		
		//  reset global CLS list

		InitializeCriticalSection( &csClsSyncGlobal );
		pclsSyncGlobal		= NULL;
		pclsSyncCleanGlobal	= NULL;
		cclsSyncGlobal		= 0;
		dwClsSyncIndex		= dwClsInvalid;
		dwClsProcIndex		= dwClsInvalid;
		
		//  iniitalize the HRT

		OSTimeHRTInit();
		
		//  initialize the CEnhancedState allocator

		SYSTEM_INFO sinf;
		GetSystemInfo( &sinf );
		g_cbMemoryBlock = sinf.dwAllocationGranularity;
		g_pmbRoot = &g_mbSentry;
		g_mbSentry.pmbNext = NULL;
		g_mbSentry.ppmbNext = &g_pmbRoot;
		g_mbSentry.cAlloc = 1;
		g_mbSentry.ibFreeMic = g_cbMemoryBlock;
		g_pmbRootFree = &g_mbSentryFree;
		g_mbSentryFree.pmbNext = NULL;
		g_mbSentryFree.ppmbNext = &g_pmbRootFree;
		g_mbSentryFree.cAlloc = 0;
		g_mbSentryFree.ibFreeMic = 0;
		InitializeCriticalSection( &g_csESMemory );

		//  initialize the Kernel Semaphore Pool

		if ( !ksempoolGlobal.FInit() )
			{
			goto HandleError;
			}

		//  cache the processor count

		DWORD_PTR maskProcess;
		DWORD_PTR maskSystem;
		BOOL fGotAffinityMask;
		fGotAffinityMask = GetProcessAffinityMask(	GetCurrentProcess(),
													&maskProcess,
													&maskSystem );
		OSSYNCAssert( fGotAffinityMask );

		g_cProcessorMax = sizeof( maskSystem ) * 8;

		for ( g_cProcessor = 0; maskProcess != 0; maskProcess >>= 1 )
			{
			if ( maskProcess & 1 )
				{
				g_cProcessor++;
				}
			}

	    //  cache system max spin count
	    //
	    //  NOTE:  spins heavily as WaitForSingleObject() is extremely expensive
	    //
	    //  CONSIDER:  get spin count from persistent configuration

	    cSpinMax = g_cProcessor == 1 ? 0 : 256;

	    //  if we are running on NT build 2463 and later then we can read the
	    //  current processor from the TEB

		OSVERSIONINFO osvi;
		memset( &osvi, 0, sizeof( osvi ) );
		osvi.dwOSVersionInfoSize = sizeof( osvi );
		if ( !GetVersionEx( &osvi ) )
			{
			goto HandleError;
			}

	    g_fGetCurrentProcFromTEB = (	osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
	    								osvi.dwBuildNumber >= 2463 );

#ifdef SYNC_DUMP_PERF_DATA

		//  initialize performance data dump context

		char szTempPath[_MAX_PATH];
		if ( !GetTempPath( _MAX_PATH, szTempPath ) )
			{
			goto HandleError;
			}

		char szProcessPath[_MAX_PATH];
		char szProcess[_MAX_PATH];
		if ( !GetModuleFileName( NULL, szProcessPath, _MAX_PATH ) )
			{
			goto HandleError;
			}
		_splitpath( szProcessPath, NULL, NULL, szProcess, NULL );

		MEMORY_BASIC_INFORMATION mbi;
		if ( !VirtualQueryEx( GetCurrentProcess(), FOSSyncIInit, &mbi, sizeof( mbi ) ) )
			{
			goto HandleError;
			}
		char szModulePath[_MAX_PATH];
		char szModule[_MAX_PATH];
		if ( !GetModuleFileName( HINSTANCE( mbi.AllocationBase ), szModulePath, sizeof( szModulePath ) ) )
			{
			goto HandleError;
			}
		_splitpath( szModulePath, NULL, NULL, szModule, NULL );

		SYSTEMTIME systemtime;
		GetLocalTime( &systemtime );

		char szPerfData[_MAX_PATH];
		sprintf(	szPerfData,
					"%s%s %s Sync Stats %04d%02d%02d%02d%02d%02d.TXT",
					szTempPath,
					szProcess,
					szModule,
					systemtime.wYear,
					systemtime.wMonth,
					systemtime.wDay,
					systemtime.wHour,
					systemtime.wMinute,
					systemtime.wSecond );

		if ( !( pfprintfPerfData = (CFPrintF*)LocalAlloc( 0, sizeof( CFPrintF ) ) ) )
			{
			goto HandleError;
			}
		new( (CFPrintF*)pfprintfPerfData ) CFPrintF( szPerfData );

		if ( !( piprintfPerfData = (CIPrintF*)LocalAlloc( 0, sizeof( CIPrintF ) ) ) )
			{
			goto HandleError;
			}
		new( (CIPrintF*)piprintfPerfData ) CIPrintF( pfprintfPerfData );

		OSSyncStatsDumpColumns();

#endif  //  SYNC_DUMP_PERF_DATA


		//	unlock sync subsystem

		OSSYNCAssert( (long)cOSSyncInit == lOSSyncLockedForInit );
		AtomicExchange( (long*)&cOSSyncInit, 1 );
		}

	return fTrue;

HandleError:
	OSSyncICleanup();
	return fFalse;
	}

const BOOL OSSYNCAPI FOSSyncPreinit()
	{
	//  make sure we are initialized and
	//	add an initial ref for the process
	return FOSSyncIInit();
	}


//  terminate sync subsystem

static void OSSYNCAPI OSSyncITerm()
	{
	OSSYNC_FOREVER
		{
		const long	lInitial		= ( cOSSyncInit & lOSSyncUnlocked );
		if ( 0 == lInitial )
			{
			//	sync subsystem not initialised
			//	(or someone else is already
			//	terminating it)
			break;
			}

#ifdef SYNC_ENHANCED_STATE
		const BOOL	fTermRequired	= ( ksempoolGlobal.CksemAlloc() + 1 == lInitial );
#else
		const BOOL	fTermRequired	= ( 1 == lInitial );
#endif
		const long	lFinal			= ( fTermRequired ? lOSSyncLockedForTerm : lInitial - 1 );

		//	if multiple threads try to init/term simultaneously, one will win
		//	and the others will loop until he's done

		if ( lInitial == AtomicCompareExchange( (long*)&cOSSyncInit, lInitial, lFinal ) )
			{
			if ( fTermRequired )
				OSSyncICleanup();
			break;
			}
		else if ( cOSSyncInit & lOSSyncLocked )
			{
			//	our AtomicCompareExchange() appears to have failed because
			//	the sync subsystem is locked for init/term, so sleep a bit
			//	to allow time for the init/term to complete
			Sleep( 1 );
			}
		}
	}

void OSSYNCAPI OSSyncPostterm()
	{
	//	remove any remaining CLS allocated by NT thread pool threads,
	//	which don't seem to perform a DLL_THREAD_DETACH when the
	//	process dies (this will also free any other CLS that got
	//	orphaned for whatever unknown reason)

	while ( NULL != pclsSyncGlobal )
		{
		OSSyncIDetach( pclsSyncGlobal );
		}

	//	on a normal shutdown, there should be exactly 1 refcount left,
	//	but there may also be none if this is being called as
	//	part of error-handling during init
	OSSYNCAssert( 0 == cOSSyncInit || 1 == cOSSyncInit );
	OSSyncITerm();
	}



const BOOL OSSYNCAPI FOSSyncInitForES()
	{
#ifdef SYNC_ENHANCED_STATE
	return FOSSyncIInit();
#else
	return fTrue;
#endif
	}

void OSSYNCAPI OSSyncTermForES()
	{
#ifdef SYNC_ENHANCED_STATE
	if ( lOSSyncLockedForTerm == cOSSyncInit )
		{
		//	SPECIAL CASE: we're in the middle of
		//	terminating the subsystem and end up
		//	recursively calling OSSyncTermForES
		//	when we clean up ksempoolGlobal
		return;
		}

	OSSyncITerm();
#endif
	}

};  //  namespace OSSYNC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\inc\atq.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1997           **/
/**********************************************************************/

/*
    atq.h

    This module contains async thread queue (atq) for async IO and thread
    pool sharing among various services.

    Brief Description of ATQ:
      For description, please see iis\spec\isatq.doc

*/

#ifndef _ATQ_H_
#define _ATQ_H_


#ifdef __cplusplus
extern "C" {
#endif


// Include Standard headers

# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
# include <windows.h>
# include <winsock2.h>
# include <mswsock.h>


#ifndef dllexp
#define dllexp __declspec( dllexport )
#endif


/*++
  ATQ API Overview:

  Global per module:
     AtqInitialize()
     AtqTerminate()

     AtqGetInfo()
     AtqSetInfo()

  ATQ Endpoint functions:
     AtqCreateEndpoint()
        AtqStartEndpoint()
        AtqEndpointGetInfo()
        AtqEndpointSetInfo()
        AtqStopCloseEndpoint()
     AtqCloseCloseEndpoint()

     AtqStopAndCloseEndpoint()  <-- soon to be killed
  Per ATQ Context Functions:
     AtqAddAsyncHandle()  <-- for non AcceptEx() sockets

     AtqGetAcceptExAddrs()       <-- for AcceptEx() sockets

     AtqContextSetInfo()

     AtqCloseFileHandle()
     AtqCloseSocket()
     AtqFreeContext()

  Bandwidth Throttler Functions:
     AtqCreateBandwidthInfo()
     AtqFreeBandwidthInfo()
     AtqBandwidthSetInfo()
     AtqBandwidthGetInfo()

  IO Functions:

     AtqReadFile()
     AtqWriteFile()
     AtqReadSocket()
     AtqWriteSocket()
     AtqTransmitFile()
     AtqTransmitFileAndRecv()
     AtqSendAndRecv()

  Utility Functions:

     AtqCreateFile()
     AtqCreateFileW()
     AtqOplockAcknowledge()
     AtqSpudInitialized()
     AtqReadDirChanges()
     AtqPostCompletionStatus()


--*/


/*----------------------------------------------------------
  Registry Parameters used by ATQ during AtqInitialize()
  ATQ loads some of the parameters from
  HKLM\System\CurrentControlSet\Services\InetInfo\Parameters

  Most of these parameters are for INTERNAL ANALYSIS and
   development/testing. Setup should not install values
   for the same. Setup can include values for items marked SETUP.
------------------------------------------------------------*/

// Names

#define ATQ_REG_PER_PROCESSOR_ATQ_THREADS TEXT("MaxPoolThreads")
#define ATQ_REG_POOL_THREAD_LIMIT         TEXT("PoolThreadLimit") // SETUP
#define ATQ_REG_PER_PROCESSOR_CONCURRENCY TEXT("MaxConcurrency")
#define ATQ_REG_THREAD_TIMEOUT            TEXT("ThreadTimeout")
#define ATQ_REG_USE_ACCEPTEX              TEXT("UseAcceptEx")
#define ATQ_REG_MIN_KB_SEC                TEXT("MinFileKbSec")    // SETUP
#define ATQ_REG_LISTEN_BACKLOG            TEXT("ListenBacklog")   // SETUP

// Default Values

#define ATQ_REG_DEF_PER_PROCESSOR_ATQ_THREADS         (4)
#define ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY         (0)
// special value of 0 means that system will determine this dynamically.

//
// thread limit settings
//

#define ATQ_REG_MIN_POOL_THREAD_LIMIT                 (64)
#define ATQ_REG_DEF_POOL_THREAD_LIMIT                 (128)
#define ATQ_REG_MAX_POOL_THREAD_LIMIT                 (256)

//
// How often to check for thread progress.
//
#define ATQ_THREAD_MONITOR_PERIOD                     (2*60) // 2 Minutes

//
// How many IO's a temp thread should handle before 
// exiting
//

#define ATQ_TEMP_THREAD_IO_COUNT                      (100)

//
// THREAD_TIMEOUTs are high to prevent async ios from being cancelled
//  when the thread goes away.
//

#define ATQ_REG_DEF_THREAD_TIMEOUT                    (12*60*60) // 12 hours
#define ATQ_REG_DEF_USE_ACCEPTEX                      (TRUE)
#define ATQ_REG_DEF_MIN_KB_SEC                        (1000)  // 1000 bytes
#define ATQ_REG_DEF_LISTEN_BACKLOG                    (25)

//
// fake xmit file buffer size
//

#define ATQ_REG_DEF_NONTF_BUFFER_SIZE                 (4096)


/*----------------------------------------------------------
  Global Functions of ATQ module
-----------------------------------------------------------*/

// Flags for AtqInitialize()
# define ATQ_INIT_SPUD_FLAG          (0x00000001)

BOOL
AtqInitialize(
    IN DWORD dwFlags
    );

BOOL
AtqTerminate(
    VOID
    );

/*
 *  Sets various context information in Atq Module for global modifications
 *
 *
 *  Bandwidth Throttle:   Sets the throttle level in Bytes/Second.
 *        If INFINITE, then it is assumed that
 *                      there is no throttle value (default)
 *
 *  Max Pool Threads: Sets the maximum number of pool threads Atq will allow
 *        to be created per processor
 *
 *  MaxConcurrency: tells how many threads to permit per processor
 *
 *  Thread Timeout: Indicates how long a thread should be kep alive
 *        waiting on GetQueuedCompletionStatus() before commiting suicide
 *        (in seconds)
 *
 *  Inc/Dec max pool threads: If a server will be doing extended processing
 *        in an ATQ pool thread, they should increase the max pool threads
 *        while the extended processing is occurring.  This prevents starvation
 *        of other requests
 *
 *  AtqMinKbSec: set the assumed minimum KB per second for AtqTransmitFile()
 *        This value is used in calculating the timeout for file transfer
 *        operation
 *
 */

typedef enum _ATQ_INFO {

    AtqBandwidthThrottle = 0,
    AtqExitThreadCallback,
    AtqMaxPoolThreads,    // per processor values
    AtqMaxConcurrency,    // per processor concurrency value
    AtqThreadTimeout,
    AtqUseAcceptEx,       // Use AcceptEx if available
    AtqIncMaxPoolThreads, // Up the max thread count
    AtqDecMaxPoolThreads, // Decrease the max thread count
    AtqMinKbSec,          // Minimum assumed transfer rate for AtqTransmitFile
    AtqBandwidthThrottleMaxBlocked,  // Max number of blocked requests
    AtqUpdatePerfCounterCallback,
    AtqMaxDGramSend       // Max bytes in a single datagram send

} ATQ_INFO;

//
// ATQ_THREAD_EXIT_CALLBACK
// Type of callback function to be called when an ATQ thread exits so
// that the user of ATQ may clen up thread specific data.
//

typedef
VOID
(*ATQ_THREAD_EXIT_CALLBACK) ( VOID );

//
// ATQ_PERF_UPDATE_CALLBACK
// Type of callback function to be called when ATQ needs to update
// PerfMon counters that do no reside within ATQ.
//

typedef
VOID
(*ATQ_UPDATE_PERF_CALLBACK) (
    IN DWORD            dwStat,
    IN DWORD            dwOperation,
    IN DWORD            dwChange
);


dllexp
DWORD_PTR
AtqSetInfo(
    IN ATQ_INFO atqInfo,
    IN DWORD_PTR Data
    );

dllexp
DWORD_PTR
AtqGetInfo(
    IN ATQ_INFO atqInfo
    );



typedef struct _ATQ_STATISTICS {

    DWORD  cAllowedRequests;
    DWORD  cBlockedRequests;
    DWORD  cRejectedRequests;
    DWORD  cCurrentBlockedRequests;
    DWORD  MeasuredBandwidth;

} ATQ_STATISTICS;


dllexp
BOOL AtqGetStatistics( IN OUT ATQ_STATISTICS * pAtqStats);

dllexp
BOOL AtqClearStatistics(VOID);




/*----------------------------------------------------------
  ATQ Endpoint functions
-----------------------------------------------------------*/

//
//  endpoint data
//

typedef enum _ATQ_ENDPOINT_INFO {

    EndpointInfoListenPort,
    EndpointInfoListenSocket,
    EndpointInfoAcceptExOutstanding,
    EndpointInfoConsumerType

}  ATQ_ENDPOINT_INFO;



//
//  ATQ_COMPLETION
//  This is the routine that is called upon IO completion (on
//  error or success).
//
//  Context is the context passed to AtqAddAsyncHandle
//  BytesWritten is the number of bytes written to the file or
//      bytes written to the client's buffer
//  CompletionStatus is the WinError completion code
//  lpOverLapped is the filled in overlap structure
//
//  If the timeout thread times out an IO request, the completion routine
//  will be called by the timeout thread with IOCompletion FALSE and
//  CompletionStatus == ERROR_SEM_TIMEOUT.  The IO request is *still*
//  outstanding in this instance.  Generally it will be completed when
//  the file handle is closed.
//

typedef
VOID
(*ATQ_COMPLETION)(
            IN PVOID        Context,
            IN DWORD        BytesWritten,
            IN DWORD        CompletionStatus,  // Win32 Error code
            IN OVERLAPPED * lpo
            );

//
// Type of callback function to be called when a new connection is established.
//  This function should be defined before including conninfo.hxx
//

typedef
VOID
(*ATQ_CONNECT_CALLBACK) (
                IN SOCKET sNew,
                IN LPSOCKADDR_IN pSockAddr,
                IN PVOID EndpointContext,
                IN PVOID EndpointObject
                );



typedef struct _ATQ_ENDPOINT_CONFIGURATION {

    //
    // Port to listen on.  If 0, system will assign
    //

    USHORT ListenPort;

    //
    // Is connectionless
    //

    BOOL  fDatagram;
    
    // The next two are datagram only.
    BOOL  fReverseQueuing;     // If set then winsock will drop the oldest rather
                               // than the newest datagram buffers when winsock buffers 
                               // overflow.

    INT   cbDatagramWSBufSize; // How much buffer space to tell winsock to reserve
                               // for this datagram socket.
    
    //
    // Prevent others from using this?
    //

    BOOL  fLockDownPort;

    //
    // IP address to bind to. 0 (INADDR_ANY) == wildcard.
    //

    DWORD IpAddress;

    DWORD cbAcceptExRecvBuffer;
    DWORD nAcceptExOutstanding;
    DWORD AcceptExTimeout;

    //
    // Callbacks
    //

    ATQ_CONNECT_CALLBACK pfnConnect;
    ATQ_COMPLETION pfnConnectEx;
    ATQ_COMPLETION pfnIoCompletion;

} ATQ_ENDPOINT_CONFIGURATION, *PATQ_ENDPOINT_CONFIGURATION;

dllexp
PVOID
AtqCreateEndpoint(
    IN PATQ_ENDPOINT_CONFIGURATION Configuration,
    IN PVOID EndpointContext
    );

dllexp
BOOL
AtqStartEndpoint(
    IN PVOID Endpoint
    );

dllexp
DWORD_PTR
AtqEndpointGetInfo(
    IN PVOID Endpoint,
    IN ATQ_ENDPOINT_INFO EndpointInfo
    );

dllexp
DWORD_PTR
AtqEndpointSetInfo(
    IN PVOID Endpoint,
    IN ATQ_ENDPOINT_INFO EndpointInfo,
    IN DWORD_PTR dwInfo
    );

dllexp
BOOL
AtqStopEndpoint(
    IN PVOID Endpoint
    );

dllexp
BOOL
AtqCloseEndpoint(
    IN PVOID Endpoint
    );

dllexp
BOOL
AtqStopAndCloseEndpoint(
    IN PVOID Endpoint,
    IN LPTHREAD_START_ROUTINE lpCompletion,
    IN PVOID lpCompletionContext
    );



/*----------------------------------------------------------
  ATQ CONTEXT functions
-----------------------------------------------------------*/

//
//  This is the public portion of an ATQ Context.  It should be treated
//  as read only
//
//  !!! Changes made to this structure should also be made to
//  ATQ_CONTEXT in atqtypes.hxx !!!
//

typedef struct _ATQ_CONTEXT_PUBLIC {

    HANDLE         hAsyncIO;       // handle for async i/o object: socket/file
    OVERLAPPED     Overlapped;     // Overlapped structure used for IO

} ATQ_CONTEXT_PUBLIC, *PATQ_CONTEXT;


dllexp
BOOL
AtqAddAsyncHandle(
    OUT PATQ_CONTEXT * ppatqContext,
    IN  PVOID          EndpointObject,
    IN  PVOID          Cli