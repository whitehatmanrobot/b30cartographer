ivate            = 0xc0
} TagClass_e;

struct Tag_s {
    TagList_t Next;
    TagType_e Type;
    TagClass_e Class;
    Value_t *Tag;
};

Tag_t *NewTag(TagType_e type);
Tag_t *DupTag(Tag_t *src);

/* --- Extension --- */

typedef enum {
    eExtension_Unconstrained,
    eExtension_Unextended,
    eExtension_Extendable,
    eExtension_Extended
} Extension_e;

/* --- Assignment --- */

typedef enum {
    eAssignment_Undefined,
    eAssignment_ModuleIdentifier,
    eAssignment_Type,
    eAssignment_Value,
    eAssignment_ObjectClass,
    eAssignment_Object,
    eAssignment_ObjectSet,
    eAssignment_Macro,
    eAssignment_Reference,
    eAssignment_NextPass
} Assignment_e;

typedef enum {
    eAssignmentFlags_Exported = 1,
    eAssignmentFlags_LongName = 2
} AssignmentFlags_e;

struct Assignment_s {
    AssignmentList_t Next;
    char *Identifier;
    ModuleIdentifier_t *Module;
    Assignment_e Type;
    AssignmentFlags_e Flags;
    int fImportedLocalDuplicate;
    int fGhost;
    TagType_e eDefTagType;
    union {
            struct {
            Type_t *Type;
        } Type;
        struct {
            Value_t *Value;
        } Value;
        struct {
            ObjectClass_t *ObjectClass;
        } ObjectClass;
        struct {
            Object_t *Object;
        } Object;
        struct {
            ObjectSet_t *ObjectSet;
        } ObjectSet;
        struct {
            Macro_t *Macro;
        } Macro;
        struct {
            char *Identifier;
            ModuleIdentifier_t *Module;
        } Reference;
    } U;
};

Assignment_t *NewAssignment(Assignment_e type);
Assignment_t *DupAssignment(Assignment_t *src);
Assignment_t *FindAssignment(AssignmentList_t a, Assignment_e type, char *ide, ModuleIdentifier_t *mod);
Assignment_t *FindExportedAssignment(AssignmentList_t a, Assignment_e type, char *ide, ModuleIdentifier_t *mod);
Assignment_t *FindAssignmentInCurrentPass(AssignmentList_t a, char *ide, ModuleIdentifier_t *mod);
Assignment_t *GetAssignment(AssignmentList_t ass, Assignment_t *a);
Assignment_e GetAssignmentType(AssignmentList_t ass, Assignment_t *a);
int AssignType(AssignmentList_t *ass, Type_t *lhs, Type_t *rhs);
int AssignValue(AssignmentList_t *ass, Value_t *lhs, Value_t *rhs);
int AssignModuleIdentifier(AssignmentList_t *ass, ModuleIdentifier_t *module);

/* --- AssignedObjIds --- */

struct AssignedObjId_s {
    AssignedObjIdList_t Next;
    StringList_t Names;
    uint32_t Number;
    AssignedObjId_t *Child;
};

AssignedObjId_t *NewAssignedObjId(void);
AssignedObjId_t *DupAssignedObjId(AssignedObjId_t *src);

typedef struct DefinedObjectID_s
{
    struct DefinedObjectID_s    *next;
    char                        *pszName;
    Value_t                     *pValue;
}
    DefinedObjectID_t;

extern DefinedObjectID_t *g_pDefinedObjectIDs;
Value_t *GetDefinedOIDValue ( char *pszName );
void AddDefinedOID ( char *pszName, Value_t *pValue );

/* --- TypeRules --- */

typedef enum {
    eTypeRules_Normal = 0x00,
    eTypeRules_Pointer = 0x01, // lonchanc: don't know what it is
    eTypeRules_SinglyLinkedList = 0x02, // --<LINKED>--
    eTypeRules_DoublyLinkedList = 0x04,
    eTypeRules_LengthPointer = 0x08, // --<UNBOUNDED>--
    eTypeRules_FixedArray = 0x10, // default
    eTypeRules_PointerToElement = 0x20, // --<POINTER>--
    eTypeRules_ZeroTerminated = 0x40,

    eTypeRules_LinkedListMask = (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList),
    eTypeRules_PointerArrayMask = (eTypeRules_LengthPointer | eTypeRules_FixedArray),
    eTypeRules_PointerMask = (eTypeRules_LengthPointer | eTypeRules_PointerToElement),
    eTypeRules_IndirectMask = (eTypeRules_Pointer | eTypeRules_LinkedListMask | eTypeRules_PointerMask),
} TypeRules_e;

/* --- TypeFlags --- */

typedef enum {
    eTypeFlags_Null = 1,        /* type is not present in C, 'cause it's NULL */
    eTypeFlags_NullChoice = 2,        /* type is CHOICE with NULL-alternatives */
    eTypeFlags_ExtensionMarker = 4, /* type is extended */
    eTypeFlags_Simple = 8,        /* type has empty freefn, memcpy copyfn */
    eTypeFlags_Done = 0x10,
    eTypeFlags_GenType = 0x20,        /* generate a type */
    eTypeFlags_GenEncode = 0x40,        /* generate an encoding fn */
    eTypeFlags_GenDecode = 0x80,        /* generate a decoding fn */
    eTypeFlags_GenFree = 0x100,        /* generate a free fn */
    eTypeFlags_GenCheck = 0x200,        /* generate a check fn */
    eTypeFlags_GenCompare = 0x400,/* generate a cmp fn */
    eTypeFlags_GenCopy = 0x800,        /* generate a copy fn */
    eTypeFlags_GenPrint = 0x1000,        /* generate a print fn */
    eTypeFlags_GenPdu = 0x2000,        /* generate a pdu number */
    eTypeFlags_GenAll = 0x20+0x40+0x80+0x100+0x400+0x2000,
    eTypeFlags_GenSimple = 0x20+0x40+0x80+0x400+0x2000,
    eTypeFlags_MiddlePDU = 0x8000,
} TypeFlags_e;

/* ------ hack directives ------ */

typedef struct PrivateDirectives_s
{
    char   *pszTypeName;
    char   *pszFieldName;
    char   *pszValueName;
    int     fSLinked;
    int     fDLinked;
    int     fPublic;
    int     fLenPtr;
    int     fPointer; // pointer to fixed array, in PER SeqOf/SetOf only
    int     fArray;
    int     fIntx;
    int     fNoCode;
    int     fNoMemCopy;
    int     fOidPacked;
    int     fOidArray;
} PrivateDirectives_t;

void PropagatePrivateDirectives ( Type_t *pDst, PrivateDirectives_t *pSrc );
void PropagateReferenceTypePrivateDirectives ( Type_t *pDst, PrivateDirectives_t *pSrc );
char *GetPrivateValueName(PrivateDirectives_t *pPrivateDirectives, char *pszDefValueName);

/* --- ExtensionType --- */

typedef enum {
    eExtensionType_Automatic,
    eExtensionType_None
} ExtensionType_e;

/* --- PERConstraint --- */

struct PERConstraint_s {
    Extension_e Type;
    ValueConstraintList_t Root;
    ValueConstraintList_t Additional;
};

/* --- PERConstraints --- */

struct PERConstraints_s {
    PERConstraint_t Value;
    PERConstraint_t Size;
    PERConstraint_t PermittedAlphabet;
};

/* --- PERSimpleTypeInfo --- */

typedef enum {
    ePERSTIConstraint_Unconstrained,
    ePERSTIConstraint_Semiconstrained,
    ePERSTIConstraint_Upperconstrained,
    ePERSTIConstraint_Constrained
} PERSTIConstraint_e;

typedef enum {
    ePERSTIAlignment_BitAligned,
    ePERSTIAlignment_OctetAligned
} PERSTIAlignment_e;

typedef enum {
    ePERSTIData_Null,
    ePERSTIData_Boolean,
    ePERSTIData_Unsigned,
    ePERSTIData_Integer,
    ePERSTIData_Real,
    ePERSTIData_BitString,
    ePERSTIData_RZBBitString,
    ePERSTIData_OctetString,
    ePERSTIData_UTF8String,
    ePERSTIData_SequenceOf,
    ePERSTIData_SetOf,
    ePERSTIData_ObjectIdentifier,
    ePERSTIData_NormallySmall,
    ePERSTIData_String,
    ePERSTIData_TableString,
    ePERSTIData_ZeroString,
    ePERSTIData_ZeroTableString,
    ePERSTIData_Reference,
    ePERSTIData_Extension,
    ePERSTIData_External,
    ePERSTIData_EmbeddedPdv,
    ePERSTIData_MultibyteString,
    ePERSTIData_UnrestrictedString,
    ePERSTIData_GeneralizedTime,
    ePERSTIData_UTCTime,
    ePERSTIData_Open
} PERSTIData_e;

typedef enum {
    ePERSTILength_NoLength,
    ePERSTILength_Length,
    ePERSTILength_BitLength,
    ePERSTILength_SmallLength,
    ePERSTILength_InfiniteLength
} PERSTILength_e;

struct PERSimpleTypeInfo_s {
    PERSTIData_e Data;                        /* data type of value */
    char *TableIdentifier;                /* name of stringtable to use */
    ValueConstraintList_t Table;        /* stringtable values */
    Type_t *SubType;                        /* subtype */
    char *SubIdentifier;                /* name of subtype */
    NamedValue_t *Identification;        /* identification of EMB.PDV/CH.STR */
    PERSTIConstraint_e Constraint;        /* constraint of type values */
    intx_t LowerVal;                        /* lower bound of type values */
    intx_t UpperVal;                        /* upper bound of type values */
    uint32_t NBits;                        /* number of bits to use */
    PERSTIAlignment_e Alignment;        /* alignment for encoded value */
    PERSTILength_e Length;                /* type of length encoding */
    PERSTIConstraint_e LConstraint;        /* constraint of length */
    uint32_t LLowerVal;                        /* lower bound of length */
    uint32_t LUpperVal;                        /* upper bound of length */
    uint32_t LNBits;                        /* number of bits to use for length */
    PERSTIAlignment_e LAlignment;        /* alignment for encoded length */
    uint32_t cbFixedSizeBitString;      // number of bits in the bit string of fixed size
};

/* --- PERTypeInfo --- */

typedef enum {
    eBERSTIData_Null,
    eBERSTIData_Boolean,
    eBERSTIData_Unsigned,
    eBERSTIData_Integer,
    eBERSTIData_Real,
    eBERSTIData_BitString,
    eBERSTIData_RZBBitString,
    eBERSTIData_OctetString,
    eBERSTIData_UTF8String,
    eBERSTIData_SequenceOf,
    eBERSTIData_SetOf,
    eBERSTIData_Choice,
    eBERSTIData_Sequence,
    eBERSTIData_Set,
    eBERSTIData_ObjectIdentifier,
    eBERSTIData_ObjectIdEncoded,
    eBERSTIData_String,
    eBERSTIData_ZeroString,
    eBERSTIData_Reference,
    eBERSTIData_External,
    eBERSTIData_EmbeddedPdv,
    eBERSTIData_MultibyteString,
    eBERSTIData_UnrestrictedString,
    eBERSTIData_GeneralizedTime,
    eBERSTIData_UTCTime,
    eBERSTIData_Open
} BERSTIData_e;

struct PERTypeInfo_s {
    char *Identifier;                        /* the complete name of the type */
    TypeFlags_e Flags;                        /* encoding flags */
    TypeRules_e Rules;                        /* encoding directive rules */
    intx_t **EnumerationValues;                /* values of enumeration */
    int32_t NOctets;                        /* size of string chars/integer type */
    Extension_e Type;                        /* extension type */
    PERSimpleTypeInfo_t Root;                /* info for the extension root */
    PERSimpleTypeInfo_t Additional;        /* info for the extensions */
    PrivateDirectives_t *pPrivateDirectives;
};

/* --- BERTypeInfo --- */

struct BERTypeInfo_s {
    char *Identifier;                        /* the complete name of the type */
    TypeFlags_e Flags;                        /* encoding flags */
    TypeRules_e Rules;                        /* encoding directive rules */
    int32_t NOctets;                        /* size of string chars/integer type */
    BERSTIData_e Data;                        /* data type of value */
    Type_t *SubType;                        /* subtype */
    char *SubIdentifier;                /* name of subtype */
    TagList_t Tags;                        /* tags of this type */
    PrivateDirectives_t *pPrivateDirectives;
};

/* --- Type --- */

/* bit 0..4:  universal tag;
   bit 14:    internal bit to distingish types using same universal tag;
   bit 15:    set for internal types */
typedef enum {
    eType_Boolean                = 0x0001,
    eType_Integer                = 0x0002,
    eType_BitString                = 0x0003,
    eType_OctetString                = 0x0004,
    eType_Null                        = 0x0005,
    eType_ObjectIdentifier        = 0x0006,
    eType_ObjectDescriptor        = 0x0007,
    eType_External                = 0x0008,
    eType_InstanceOf                = 0x4008,
    eType_Real                        = 0x0009,
    eType_Enumerated                = 0x000a,
    eType_EmbeddedPdv                = 0x000b,
    eType_UTF8String                = 0x000c,
    eType_Sequence                = 0x0010,
    eType_SequenceOf                = 0x4010,
    eType_Set                        = 0x0011,
    eType_SetOf                        = 0x4011,
    eType_NumericString                = 0x0012,
    eType_PrintableString        = 0x0013,
    eType_TeletexString                = 0x0014,
    eType_T61String                = 0x4014,
    eType_VideotexString        = 0x0015,
    eType_IA5String                = 0x0016,
    eType_UTCTime                = 0x0017,
    eType_GeneralizedTime        = 0x0018,
    eType_GraphicString                = 0x0019,
    eType_VisibleString                = 0x001a,
    eType_ISO646String                = 0x401a,
    eType_GeneralString                = 0x001b,
    eType_UniversalString        = 0x001c,
    eType_CharacterString        = 0x001d,
    eType_BMPString                = 0x001e,
    eType_Choice                = 0x8000,
    eType_Selection                = 0x8001,
    eType_Reference                = 0x8002,
    eType_FieldReference        = 0x8003,
    eType_RestrictedString        = 0x8004,
    eType_Open                        = 0x8005,
    eType_Undefined                = 0x8006,
    eType_Macro                        = 0x8007
} Type_e;

struct Type_s {
    TagList_t Tags;
    TagList_t AllTags;
    TagList_t FirstTags;
    Constraint_t *Constraints;
    DirectiveList_t Directives;
    Type_e Type;
    TypeFlags_e Flags;
    TypeRules_e Rules;
    PERConstraints_t PERConstraints;
    PERTypeInfo_t PERTypeInfo;
    BERTypeInfo_t BERTypeInfo;
    TagType_e TagDefault;
    ExtensionType_e ExtensionDefault;
    PrivateDirectives_t PrivateDirectives;
    union {
        struct {
            NamedNumberList_t NamedNumbers;
        } Integer, Enumerated, BitString, IEB;
        struct {
            ComponentList_t Components;
            uint32_t Optionals;     /* not for Choice */
            uint32_t Alternatives;  /* only for Choice */
            uint32_t Extensions;
            uint8_t  Autotag[2];
        } Sequence, Set, Choice, SSC,
          Real, External, EmbeddedPdv, CharacterString, InstanceOf;
        struct {
            Type_t *Type;
            DirectiveList_t Directives;
        } SequenceOf, SetOf, SS;
        struct {
            char *Identifier;
            Type_t *Type;
        } Selection;
        struct {
            ModuleIdentifier_t *Module;
            char *Identifier;
        } Reference;
        struct {
            ObjectClass_t *ObjectClass;
            char *Identifier;
        } FieldReference;
        struct {
            Macro_t *Macro;
            MacroLocalAssignmentList_t LocalAssignments;
        } Macro;
    } U;
};
#define UndefType ((Type_t *)UNDEFINED_VALUE)

Type_t *NewType(Type_e type);
Type_t *DupType(Type_t *src);
Assignment_t *GetAssignedExternalType(AssignmentList_t *a, ModuleIdentifier_t *module, char *identifier);
Type_t *GetType(AssignmentList_t ass, Type_t *type);
Type_e GetTypeType(AssignmentList_t ass, Type_t *type);
TypeRules_e GetTypeRules(AssignmentList_t ass, Type_t *type);
int IsRestrictedString(Type_e type);
int IsStructuredType(Type_t *type);
int IsSequenceType(Type_t *type);
int IsReferenceType(Type_t *type);
Type_t *GetReferencedType(AssignmentList_t a, Type_t *type);

/* --- EndPoint --- */

typedef enum {
    eEndPoint_Min = 1,
    eEndPoint_Max = 2,
    eEndPoint_Open = 4
} EndPoint_e;

struct EndPoint_s {
    EndPoint_e Flags;
    Value_t *Value;
};

EndPoint_t *NewEndPoint();
EndPoint_t *GetLowerEndPoint(AssignmentList_t ass, EndPoint_t *e);
EndPoint_t *GetUpperEndPoint(AssignmentList_t ass, EndPoint_t *e);
int CmpLowerEndPoint(AssignmentList_t ass, EndPoint_t *v1, EndPoint_t *v2);
int CmpUpperEndPoint(AssignmentList_t ass, EndPoint_t *v1, EndPoint_t *v2);
int CmpLowerUpperEndPoint(AssignmentList_t ass, EndPoint_t *v1, EndPoint_t *v2);
int CheckEndPointsJoin(AssignmentList_t ass, EndPoint_t *v1, EndPoint_t *v2);

/* --- Constraint --- */

struct Constraint_s {
    Extension_e Type;
    ElementSetSpec_t *Root;
    ElementSetSpec_t *Additional;
    /*XXX exception spec */
};

Constraint_t *NewConstraint();
Constraint_t *DupConstraint(Constraint_t *src);
void IntersectConstraints(Constraint_t **ret, Constraint_t *c1, Constraint_t *c2);

/* --- ElementSetSpec --- */

typedef enum {
    eElementSetSpec_AllExcept,
    eElementSetSpec_Union,
    eElementSetSpec_Intersection,
    eElementSetSpec_Exclusion,
    eElementSetSpec_SubtypeElement,
    eElementSetSpec_ObjectSetElement
} ElementSetSpec_e;

struct ElementSetSpec_s {
    ElementSetSpec_e Type;
    union {
        struct {
            ElementSetSpec_t *Elements;
        } AllExcept;
        struct {
            ElementSetSpec_t *Elements1;
            ElementSetSpec_t *Elements2;
        } Union, Intersection, Exclusion, UIE;
        struct {
            SubtypeElement_t *SubtypeElement;
        } SubtypeElement;
        struct {
            ObjectSetElement_t *ObjectSetElement;
        } ObjectSetElement;
    } U;
};

ElementSetSpec_t *NewElementSetSpec(ElementSetSpec_e type);
ElementSetSpec_t *DupElementSetSpec(ElementSetSpec_t *src);

/* --- SubtypeElement --- */

typedef enum {
    eSubtypeElement_ValueRange,
    eSubtypeElement_Size,
    eSubtypeElement_SingleValue,
    eSubtypeElement_PermittedAlphabet,
    eSubtypeElement_ContainedSubtype,
    eSubtypeElement_Type,
    eSubtypeElement_SingleType,
    eSubtypeElement_FullSpecification,
    eSubtypeElement_PartialSpecification,
    eSubtypeElement_ElementSetSpec
} SubtypeElement_e;

struct SubtypeElement_s {
    SubtypeElement_e Type;
    union {
        struct {
            EndPoint_t Lower;
            EndPoint_t Upper;
        } ValueRange;
        struct {
            Constraint_t *Constraints;
        } Size, PermittedAlphabet, SingleType, SPS;
        struct {
            Value_t *Value;
        } SingleValue;
        struct {
            Type_t *Type;
        } ContainedSubtype;
        struct {
            Type_t *Type;
        } Type;
        struct {
            NamedConstraintList_t NamedConstraints;
        } FullSpecification, PartialSpecification, FP;
        struct {
            ElementSetSpec_t *ElementSetSpec;
        } ElementSetSpec;
    } U;
};

SubtypeElement_t *NewSubtypeElement(SubtypeElement_e type);
SubtypeElement_t *DupSubtypeElement(SubtypeElement_t *src);

/* --- ObjectSetElement --- */

typedef enum {
    eObjectSetElement_Object,
    eObjectSetElement_ObjectSet,
    eObjectSetElement_ElementSetSpec
} ObjectSetElement_e;

struct ObjectSetElement_s {
    ObjectSetElement_e Type;
    union {
        struct {
            Object_t *Object;
        } Object;
        struct {
            ObjectSet_t *ObjectSet;
        } ObjectSet;
        struct {
            ElementSetSpec_t *ElementSetSpec;
        } ElementSetSpec;
    } U;
};

ObjectSetElement_t *NewObjectSetElement(ObjectSetElement_e type);
ObjectSetElement_t *DupObjectSetElement(ObjectSetElement_t *src);

/* --- NamedConstraints --- */

typedef enum {
    ePresence_Present,
    ePresence_Absent,
    ePresence_Optional,
    ePresence_Normal
} Presence_e;

struct NamedConstraint_s {
    NamedConstraintList_t Next;
    char *Identifier;
    Constraint_t *Constraint;
    Presence_e Presence;
};

NamedConstraint_t *NewNamedConstraint(void);
NamedConstraint_t *DupNamedConstraint(NamedConstraint_t *src);

/* --- NamedNumber --- */

typedef enum {
    eNamedNumber_Normal,
    eNamedNumber_ExtensionMarker
} NamedNumbers_e;

struct NamedNumber_s {
    NamedNumberList_t Next;
    NamedNumbers_e Type;
    union {
        struct {
            char *Identifier;
            Value_t *Value;
        } Normal;
        struct {
            int dummy; /* ExceptionSpec */
        } ExtensionMarker;
    } U;
};

NamedNumber_t *NewNamedNumber(NamedNumbers_e type);
NamedNumber_t *DupNamedNumber(NamedNumber_t *src);
NamedNumber_t *FindNamedNumber(NamedNumberList_t numbers, char *identifier);

/* --- ValueConstraints --- */

struct ValueConstraint_s {
    ValueConstraintList_t Next;
    EndPoint_t Lower;
    EndPoint_t Upper;
};

ValueConstraint_t *NewValueConstraint();
ValueConstraint_t *DupValueConstraint(ValueConstraint_t *src);
int CountValues(AssignmentList_t ass, ValueConstraintList_t v, intx_t *n);
int HasNoValueConstraint(ValueConstraintList_t v);
int HasNoSizeConstraint(AssignmentList_t ass, ValueConstraintList_t v);
int HasNoPermittedAlphabetConstraint(AssignmentList_t ass, ValueConstraintList_t v);
NamedValue_t *GetFixedIdentification(AssignmentList_t ass, Constraint_t *constraints);

/* --- NamedType --- */

struct NamedType_s {
    char *Identifier;
    Type_t *Type;
};

NamedType_t *NewNamedType(char *identifier, Type_t *type);
NamedType_t *DupNamedType(NamedType_t *src);

/* --- Components --- */

typedef enum {
    eComponent_Normal,
    eComponent_Optional,
    eComponent_Default,
    eComponent_ComponentsOf,
    eComponent_ExtensionMarker
} Components_e;

struct Component_s {
    ComponentList_t Next;
    Components_e Type;
    union {
        struct {
            NamedType_t *NamedType;
            Value_t *Value; /* only Default */
        } Normal, Optional, Default, NOD;
        struct {
            Type_t *Type;
        } ComponentsOf;
        struct {
            int dummy; /* ExceptionSpec */
        } ExtensionMarker;
    } U;
};

Component_t *NewComponent(Components_e type);
Component_t *DupComponent(Component_t *src);
Component_t *FindComponent(AssignmentList_t ass, ComponentList_t components, char *identifier);

/* --- NamedValues --- */

struct NamedValue_s {
    NamedValueList_t Next;
    char *Identifier;
    Value_t *Value;
};

NamedValue_t *NewNamedValue(char *identifier, Value_t *value);
NamedValue_t *DupNamedValue(NamedValue_t *src);
NamedValue_t *FindNamedValue(NamedValueList_t namedValues, char *identifier);

/* --- NamedObjIdValue --- */

typedef enum {
    eNamedObjIdValue_NameForm,
    eNamedObjIdValue_NumberForm,
    eNamedObjIdValue_NameAndNumberForm
} NamedObjIdValue_e;

struct NamedObjIdValue_s {
    NamedObjIdValueList_t Next;
    NamedObjIdValue_e Type;
    char *Name;
    uint32_t Number;
};

NamedObjIdValue_t *NewNamedObjIdValue(NamedObjIdValue_e type);
NamedObjIdValue_t *DupNamedObjIdValue(NamedObjIdValue_t *src);
int GetAssignedObjectIdentifier(AssignedObjIdList_t *aoi, Value_t *parent, NamedObjIdValueList_t named, Value_t **val);

/* --- asn1c_objectidentifier_t --- */

typedef struct asn1c_objectidentifier_s
{
    ASN1uint32_t        length;
    objectnumber_t     *value;
}   asn1c_objectidentifier_t;

/* --- Value --- */

typedef enum {
    eValueFlags_GenValue = 1, /* generate value definition */
    eValueFlags_GenExternValue = 2, /* generate external value declaration */
    eValueFlags_GenAll = 3,
    eValueFlags_Done = 4      /* examination done */
} ValueFlags_e;

struct Value_s {
    Value_t *Next;
    Type_t *Type;
    ValueFlags_e Flags;
    union {
        struct {
            uint32_t Value;
        } Boolean;
        struct {
            intx_t Value;
        } Integer;
        struct {
            uint32_t Value;
        } Enumerated;
        struct {
            real_t Value;
        } Real;
        struct {
            bitstring_t Value;
        } BitString;
        struct {
            octetstring_t Value;
        } OctetString;
        struct {
            ASN1wstring_t Value;
        } UTF8String;
        struct {
            NamedValueList_t NamedValues;
        } Sequence, Set, Choice, SSC,
          External, EmbeddedPdv, CharacterString, InstanceOf;
        struct {
            ValueList_t Values;
        } SequenceOf, SetOf, SS;
        struct {
            asn1c_objectidentifier_t Value;
        } ObjectIdentifier;
        struct {
            char32string_t Value;
        } RestrictedString, ObjectDescriptor;
        struct {
            generalizedtime_t Value;
        } GeneralizedTime;
        struct {
            utctime_t Value;
        } UTCTime;
        struct {
            ModuleIdentifier_t *Module;
            char *Identifier;
        } Reference;
    } U;
};
#define UndefValue ((Value_t *)UNDEFINED_VALUE)

Value_t *NewValue(AssignmentList_t ass, Type_t *type);
Value_t *DupValue(Value_t *src);
Value_t *GetValue(AssignmentList_t ass, Value_t *value);
Assignment_t *GetAssignedExternalValue(AssignmentList_t *a, ModuleIdentifier_t *module, char *identifier);
int CmpValue(AssignmentList_t ass, Value_t *v1, Value_t *v2);
int SubstractValues(AssignmentList_t ass, intx_t *dst, Value_t *src1, Value_t *src2);

/* --- ValueSet --- */

struct ValueSet_s {
    ElementSetSpec_t *Elements;
    Type_t *Type;
};

ValueSet_t *NewValueSet();
ValueSet_t *DupValueSet(ValueSet_t *src);

/* --- Macro --- */

typedef enum {
    eMacro_Macro,
    eMacro_Reference
} Macro_e;

struct Macro_s {
    Macro_e Type;
    union {
        struct {
            MacroProduction_t *TypeProduction;
            MacroProduction_t *ValueProduction;
            NamedMacroProductionList_t SupportingProductions;
        } Macro;
        struct {
            ModuleIdentifier_t *Module;
            char *Identifier;
        } Reference;
    } U;
};

Macro_t *NewMacro(Macro_e type);
Macro_t *DupMacro(Macro_t *src);
Macro_t *GetMacro(AssignmentList_t ass, Macro_t *src);

/* --- MacroProduction --- */

typedef enum {
    eMacroProduction_Alternative,
    eMacroProduction_Sequence,
    eMacroProduction_AString,
    eMacroProduction_ProductionReference,
    eMacroProduction_String,
    eMacroProduction_Identifier,
    eMacroProduction_Number,
    eMacroProduction_Empty,
    eMacroProduction_Type,
    eMacroProduction_Value,
    eMacroProduction_LocalTypeAssignment,
    eMacroProduction_LocalValueAssignment
} MacroProduction_e;

struct MacroProduction_s {
    MacroProduction_e Type;
    union {
        struct {
            MacroProduction_t *Production1;
            MacroProduction_t *Production2;
        } Alternative, Sequence;
        struct {
            char *String;
        } AString;
        struct {
            char *Reference;
        } ProductionReference;
        struct {
            char *LocalTypeReference;
        } Type;
        struct {
            char *LocalValueReference;
            char *LocalTypeReference;
            Type_t *Type;
        } Value;
        struct {
            char *LocalTypeReference;
            Type_t *Type;
        } LocalTypeAssignment;
        struct {
            char *LocalValueReference;
            Value_t *Value;
        } LocalValueAssignment;
    } U;
};
#define UndefProduction ((MacroProduction_t *)UNDEFINED_VALUE)

MacroProduction_t *NewMacroProduction(MacroProduction_e type);
MacroProduction_t *DupMacroProduction(MacroProduction_t *src);

/* --- NamedMacroProduction --- */

struct NamedMacroProduction_s {
    NamedMacroProductionList_t Next;
    char *Identifier;
    MacroProduction_t *Production;
};

NamedMacroProduction_t *NewNamedMacroProduction();
NamedMacroProduction_t *DupNamedMacroProduction(NamedMacroProduction_t *src);

/* --- MacroLocalAssignment --- */

typedef enum {
    eMacroLocalAssignment_Type,
    eMacroLocalAssignment_Value
} MacroLocalAssignment_e;

struct MacroLocalAssignment_s {
    MacroLocalAssignmentList_t Next;
    char *Identifier;
    MacroLocalAssignment_e Type;
    union {
        Type_t *Type;
        Value_t *Value;
    } U;
};

MacroLocalAssignment_t *NewMacroLocalAssignment(MacroLocalAssignment_e type);
MacroLocalAssignment_t *DupMacroLocalAssignment(MacroLocalAssignment_t *src);
MacroLocalAssignment_t *FindMacroLocalAssignment(MacroLocalAssignmentList_t la, char *ide);

/* --- Quadruple --- */

struct Quadruple_s {
    uint32_t Group;
    uint32_t Plane;
    uint32_t Row;
    uint32_t Cell;
};

/* --- Tuple --- */

struct Tuple_s {
    uint32_t Column;
    uint32_t Row;
};

/* --- Directive --- */

typedef enum {
    eDirective_None,
    eDirective_FixedArray,
    eDirective_DoublyLinkedList,
    eDirective_SinglyLinkedList,
    eDirective_LengthPointer,
    eDirective_ZeroTerminated,
    eDirective_Pointer,
    eDirective_NoPointer
} Directives_e;

struct Directive_s {
    DirectiveList_t Next;
    Directives_e Type;
    /* may be extended in future ... */
};

Directive_t *NewDirective(Directives_e type);
Directive_t *DupDirective(Directive_t *src);

/* --- ModuleIdentifier --- */

struct ModuleIdentifier_s {
    char *Identifier;
    Value_t *ObjectIdentifier;
};

ModuleIdentifier_t *NewModuleIdentifier(void);
ModuleIdentifier_t *DupModuleIdentifier(ModuleIdentifier_t *src);
int CmpModuleIdentifier(AssignmentList_t ass, ModuleIdentifier_t *mod1, ModuleIdentifier_t *mod2);

/* --- ObjectClass --- */

typedef enum {
    eObjectClass_ObjectClass,
    eObjectClass_Reference,
    eObjectClass_FieldReference
} ObjectClass_e;

struct ObjectClass_s {
    ObjectClass_e Type;
    union {
        struct {
            FieldSpecList_t FieldSpec;
            SyntaxSpecList_t SyntaxSpec;
        } ObjectClass;
        struct {
            ModuleIdentifier_t *Module;
            char *Identifier;
        } Reference;
        struct {
            ObjectClass_t *ObjectClass;
            char *Identifier;
        } FieldReference;
    } U;
};

ObjectClass_t *NewObjectClass(ObjectClass_e type);
ObjectClass_t *DupObjectClass(ObjectClass_t *src);
ObjectClass_t *GetObjectClass(AssignmentList_t ass, ObjectClass_t *oc);
int AssignObjectClass(AssignmentList_t *ass, ObjectClass_t *lhs, ObjectClass_t *rhs);
Assignment_t *GetAssignedExternalObjectClass(ModuleIdentifier_t *module, char *identifier);

/* --- Object --- */

typedef enum {
    eObject_Object,
    eObject_Reference
} Object_e;

struct Object_s {
    Object_e Type;
    union {
        struct {
            ObjectClass_t *ObjectClass;
            SettingList_t Settings;
        } Object;
        struct {
            ModuleIdentifier_t *Module;
            char *Identifier;
        } Reference;
    } U;
};

Object_t *NewObject(Object_e type);
Object_t *DupObject(Object_t *src);
Object_t *GetObject(AssignmentList_t ass, Object_t *src);
int AssignObject(AssignmentList_t *ass, Object_t *lhs, Object_t *rhs);
Assignment_t *GetAssignedExternalObject(ModuleIdentifier_t *module, char *identifier);

/* --- ObjectSet --- */

typedef enum {
    eObjectSet_ObjectSet,
    eObjectSet_Reference,
    eObjectSet_ExtensionMarker
} ObjectSet_e;

struct ObjectSet_s {
    ObjectSet_e Type;
    union {
        struct {
            ObjectClass_t *ObjectClass;
            ElementSetSpec_t *Elements; /* only for ObjectSet */
        } ObjectSet, ExtensionMarker, OE;
        struct {
            ModuleIdentifier_t *Module;
            char *Identifier;
        } Reference;
    } U;
};

ObjectSet_t *NewObjectSet(ObjectSet_e type);
ObjectSet_t *DupObjectSet(ObjectSet_t *src);
ObjectSet_t *GetObjectSet(AssignmentList_t ass, ObjectSet_t *src);
int AssignObjectSet(AssignmentList_t *ass, ObjectSet_t *lhs, ObjectSet_t *rhs);
Assignment_t *GetAssignedExternalObjectSet(ModuleIdentifier_t *module, char *identifier);

/* --- Settings --- */

typedef enum {
    eSetting_Type,
    eSetting_Value,
    eSetting_ValueSet,
    eSetting_Object,
    eSetting_ObjectSet,
    eSetting_Undefined
} Settings_e;

struct Setting_s {
    SettingList_t Next;
    Settings_e Type;
    char *Identifier;
    union {
        struct {
            Type_t *Type;
        } Type;
        struct {
            Value_t *Value;
        } Value;
        struct {
            ValueSet_t *ValueSet;
        } ValueSet;
        struct {
            Object_t *Object;
        } Object;
        struct {
            ObjectSet_t *ObjectSet;
        } ObjectSet;
    } U;
};

Setting_t *NewSetting(Settings_e type);
Setting_t *DupSetting(Setting_t *src);
Settings_e GetSettingType(Setting_t *src);
Setting_t *FindSetting(SettingList_t se, char *identifier);

/* --- SyntaxSpec --- */

typedef enum {
    eSyntaxSpec_Literal,
    eSyntaxSpec_Field,
    eSyntaxSpec_Optional
} SyntaxSpecs_e;

struct SyntaxSpec_s {
    SyntaxSpecList_t Next;
    SyntaxSpecs_e Type;
    union {
        struct {
            char *Literal;
        } Literal;
        struct {
            char *Field;
        } Field;
        struct {
            SyntaxSpecList_t SyntaxSpec;
        } Optional;
    } U;
};
#define UndefSyntaxSpecs ((SyntaxSpec_t *)UNDEFINED_VALUE)

SyntaxSpec_t *NewSyntaxSpec(SyntaxSpecs_e type);
SyntaxSpec_t *DupSyntaxSpec(SyntaxSpec_t *src);

/* --- Optionality --- */

typedef enum {
    eOptionality_Normal,
    eOptionality_Optional,
    eOptionality_Default_Type,
    eOptionality_Default_Value,
    eOptionality_Default_ValueSet,
    eOptionality_Default_Object,
    eOptionality_Default_ObjectSet
} Optionality_e;

struct Optionality_s {
    Optionality_e Type;
    union {
        Type_t *Type;                        /* only for Default_Type */
        Value_t *Value;                        /* only for Default_Value */
        ValueSet_t *ValueSet;                /* only for Default_ValueSet */
        Object_t *Object;                /* only for Default_Object */
        ObjectSet_t *ObjectSet;                /* only for Default_ObjectSet */
    } U;
};

Optionality_t *NewOptionality(Optionality_e opt);
Optionality_t *DupOptionality(Optionality_t *src);

/* --- FieldSpec --- */

typedef enum {
    eFieldSpec_Type,
    eFieldSpec_FixedTypeValue,
    eFieldSpec_VariableTypeValue,
    eFieldSpec_FixedTypeValueSet,
    eFieldSpec_VariableTypeValueSet,
    eFieldSpec_Object,
    eFieldSpec_ObjectSet,
    eFieldSpec_Undefined
} FieldSpecs_e;

struct FieldSpec_s {
    FieldSpecList_t Next;
    FieldSpecs_e Type;
    char *Identifier;
    union {
        struct {
            Optionality_t *Optionality;
        } Type;
        struct {
            Type_t *Type;
            uint32_t Unique;
            Optionality_t *Optionality;
        } FixedTypeValue;
        struct {
            StringList_t Fields;
            Optionality_t *Optionality;
        } VariableTypeValue;
        struct {
            Type_t *Type;
            Optionality_t *Optionality;
        } FixedTypeValueSet;
        struct {
            StringList_t Fields;
            Optionality_t *Optionality;
        } VariableTypeValueSet;
        struct {
            ObjectClass_t *ObjectClass;
            Optionality_t *Optionality;
        } Object;
        struct {
            ObjectClass_t *ObjectClass;
            Optionality_t *Optionality;
        } ObjectSet;
    } U;
};

FieldSpec_t *NewFieldSpec(FieldSpecs_e type);
FieldSpec_t *DupFieldSpec(FieldSpec_t *src);
FieldSpec_t *GetFieldSpec(AssignmentList_t ass, FieldSpec_t *fs);
FieldSpecs_e GetFieldSpecType(AssignmentList_t ass, FieldSpec_t *fs);
FieldSpec_t *FindFieldSpec(FieldSpecList_t fs, char *identifier);

/* --- UndefinedSymbol --- */

typedef enum {
    eUndefinedSymbol_SymbolNotDefined,
    eUndefinedSymbol_SymbolNotExported,
    eUndefinedSymbol_FieldNotDefined,
    eUndefinedSymbol_FieldNotExported
} UndefinedSymbol_e;

struct UndefinedSymbol_s {
    UndefinedSymbolList_t Next;
    UndefinedSymbol_e Type;
    union {
        struct {
            char *Identifier;
            ModuleIdentifier_t *Module;
            Assignment_e ReferenceType;
        } Symbol;
        struct {
            char *Identifier;
            ModuleIdentifier_t *Module;
            Settings_e ReferenceFieldType;
            ObjectClass_t *ObjectClass;
        } Field;
    } U;
};

UndefinedSymbol_t *NewUndefinedSymbol(UndefinedSymbol_e type, Assignment_e reftype);
UndefinedSymbol_t *NewUndefinedField(UndefinedSymbol_e type, ObjectClass_t *oc, Settings_e reffieldtype);
int CmpUndefinedSymbol(AssignmentList_t ass, UndefinedSymbol_t *u1, UndefinedSymbol_t *u2);
int CmpUndefinedSymbolList(AssignmentList_t ass, UndefinedSymbolList_t u1, UndefinedSymbolList_t u2);
UndefinedSymbol_t *FindUndefinedSymbol(AssignmentList_t ass, UndefinedSymbolList_t a, Assignment_e type, char *ide, ModuleIdentifier_t *mod);
UndefinedSymbol_t *FindUndefinedField(AssignmentList_t ass, UndefinedSymbolList_t u, Settings_e fieldtype, ObjectClass_t *oc, char *ide, ModuleIdentifier_t *mod);

/* --- String --- */

struct String_s {
    StringList_t Next;
    char *String;
};
String_t *NewString(void);
String_t *DupString(String_t *src);
String_t *FindString(StringList_t list, char *str);
#define EXPORT_ALL ((String_t *)1)

/* --- StringModule --- */

struct StringModule_s {
    StringModuleList_t Next;
    char *String;
    ModuleIdentifier_t *Module;
};
StringModule_t *NewStringModule(void);
StringModule_t *DupStringModule(StringModule_t *src);
StringModule_t *FindStringModule(AssignmentList_t ass, StringModuleList_t list, char *str, ModuleIdentifier_t *module);
#define IMPORT_ALL ((StringModule_t *)1)

/* --- Language --- */

typedef enum {
    eLanguage_C,
    eLanguage_Cpp
} Language_e;

/* --- Alignment --- */

typedef enum {
    eAlignment_Unaligned,
    eAlignment_Aligned
} Alignment_e;

/* --- Encoding --- */

typedef enum {
    eEncoding_Basic,
    eEncoding_Packed
} Encoding_e;

/* --- SubEncoding --- */

typedef enum {
    eSubEncoding_Basic = 'B',
    eSubEncoding_Canonical = 'C',
    eSubEncoding_Distinguished = 'D'
} SubEncoding_e;

/* --- generation entities --- */

typedef enum { eStringTable, eEncode, eDecode, eCheck, ePrint, eFree, eCompare, eCopy } TypeFunc_e;
typedef enum { eDecl, eDefh, eDefn, eInit, eFinit } ValueFunc_e;

struct Arguments_s {
    char *enccast;
    char *encfunc;
    char *Pencfunc;
    char *deccast;
    char *decfunc;
    char *Pdecfunc;
    char *freecast;
    char *freefunc;
    char *Pfreefunc;
    char *cmpcast;
    char *cmpfunc;
    char *Pcmpfunc;
};

/* --- ghost file --- */

typedef struct GhostFile_s {
    char    *pszFileName;
    char    *pszModuleName;
}
    GhostFile_t;

/* --- utility functions --- */

char *GetIntType(AssignmentList_t ass, EndPoint_t *lower, EndPoint_t *upper, int32_t *sign);
char *GetIntegerType(AssignmentList_t ass, Type_t *type, int32_t *sign);
char *GetRealType(Type_t *type);
char *GetBooleanType(void);
char *GetEnumeratedType(AssignmentList_t ass, Type_t *type, int32_t *sign);
char *GetChoiceType(Type_t *type);
char *GetStringType(AssignmentList_t ass, Type_t *type, int32_t *noctets, uint32_t *zero);
uint32_t GetIntBits(intx_t *range);

void GetPERConstraints(AssignmentList_t ass, Constraint_t *constraints, PERConstraints_t *per);

char *Identifier2C(char *identifier);
char *Reference(char *expression);
char *Dereference(char *expression);

extern int ForceAllTypes;
extern char *IntegerRestriction;
extern char *UIntegerRestriction;
extern char *RealRestriction;
extern int Has64Bits;
extern Language_e g_eProgramLanguage;
extern Encoding_e g_eEncodingRule;
extern Alignment_e Alignment;
extern SubEncoding_e g_eSubEncodingRule;

int GetUndefined(AssignmentList_t ass, UndefinedSymbol_t *undef);
void UndefinedError(AssignmentList_t ass, UndefinedSymbolList_t undef, UndefinedSymbolList_t baddef);

extern FILE *g_finc, *g_fout;

void InitBuiltin();
void InitBuiltinASN1CharacterModule();
void Examination(AssignmentList_t *ass, ModuleIdentifier_t *mainmodule);
void GenInc(AssignmentList_t ass, FILE *finc, char *module);
void GenPrg(AssignmentList_t ass, FILE *fprg, char *module, char *incfilename);
void GenFuncSequenceSetDefaults(AssignmentList_t ass, char *valref, ComponentList_t components, char *obuf, TypeFunc_e et);
void GenFuncSequenceSetOptionals(AssignmentList_t ass, char *valref, ComponentList_t components, uint32_t optionals, uint32_t extensions, char *obuf, TypeFunc_e et);
void GenPERHeader();
void GenPERInit(AssignmentList_t ass, char *module);
void GenPERFuncType(AssignmentList_t ass, char *module, Assignment_t *at, TypeFunc_e et);
void GenBERHeader();
void GenBERInit(AssignmentList_t ass, char *module);
void GenBERFuncType(AssignmentList_t ass, char *module, Assignment_t *at, TypeFunc_e et);

void GetMinMax(AssignmentList_t ass, ValueConstraintList_t constraints,
    EndPoint_t *lower, EndPoint_t *upper);
char *GetTypeName(AssignmentList_t ass, Type_t *type);
char *PGetTypeName(AssignmentList_t ass, Type_t *type);
char *GetValueName(AssignmentList_t ass, Value_t *value);
char *GetObjectClassName(AssignmentList_t ass, ObjectClass_t *oc);
char *GetName(Assignment_t *a);
char *PGetName(AssignmentList_t ass, Assignment_t *a);
Tag_t *GetTag(AssignmentList_t ass, Type_t *type);
int32_t GetOctets(char *inttype);
void AutotagType(AssignmentList_t ass, Type_t *type);
void SortAssignedTypes(AssignmentList_t *ass);
void ExamineBER(AssignmentList_t ass);
void ExaminePER(AssignmentList_t ass);
void GetBERPrototype(Arguments_t *args);
void GetPERPrototype(Arguments_t *args);

int String2GeneralizedTime(generalizedtime_t *time, char32string_t *string);
int String2UTCTime(utctime_t *time, char32string_t *string);

FieldSpec_t *GetObjectClassField(AssignmentList_t ass, ObjectClass_t *oc, char *field);
FieldSpec_t *GetFieldSpecFromObjectClass(AssignmentList_t ass, ObjectClass_t *oc, StringList_t fields);
Setting_t *GetSettingFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl);
Setting_t *GetSettingFromSettings(AssignmentList_t ass, SettingList_t se, StringList_t sl);

ObjectClass_t *GetObjectClassFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elems);
Value_t *GetValueFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl);
ValueSet_t *GetValueSetFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl);
Type_t *GetTypeFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl);
Object_t *GetObjectFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl);
ObjectSet_t *GetObjectSetFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl);
ElementSetSpec_t *ConvertElementSetSpecToElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elems, StringList_t sl, ElementSetSpec_t *(*fn)(AssignmentList_t ass, Object_t *o, StringList_t sl));
ElementSetSpec_t *ConvertObjectSetToElementSetSpec(AssignmentList_t ass, ObjectSet_t *os, StringList_t sl, ElementSetSpec_t *(*fn)(AssignmentList_t ass, Object_t *o, StringList_t sl));
ValueSet_t *GetValueSetFromObjectSet(AssignmentList_t ass, ObjectSet_t *os, StringList_t sl);
ObjectSet_t *GetObjectSetFromObjectSet(AssignmentList_t ass, ObjectSet_t *os, StringList_t sl);
Type_t *GetTypeOfValueSet(AssignmentList_t ass, ValueSet_t *vs);
int IsPSetOfType(AssignmentList_t ass, Assignment_t *a);


// --- The following is added by Microsoft ---

int IsReservedWord ( char *psz );
void KeepEnumNames ( char *pszEnumName );
void KeepOptNames ( char *pszOptName );
void KeepChoiceNames ( char *pszChoiceName );
int DoesEnumNameConflict ( char *pszEnumName );
int DoesOptNameConflict ( char *pszOptName );
int DoesChoiceNameConflict ( char *pszChoiceName );

void SetDirective(char *psz);
void PrintVerbatim(void);

/* ------ char.c ------ */

int ASN1is16space(ASN1char16_t c);
int ASN1str16len(ASN1char16_t *p);
int ASN1is32space(ASN1char32_t c);
int ASN1str32len(ASN1char32_t *p);

int IsImportedLocalDuplicate(AssignmentList_t ass, ModuleIdentifier_t *pMainModule, Assignment_t *curr);

extern TagType_e g_eDefTagType;

extern TypeRules_e g_eDefTypeRuleSS_NonSized;
extern TypeRules_e g_eDefTypeRuleSS_Sized;
extern int g_fOidArray;

extern char *g_pszOrigModuleNameLowerCase;
extern int g_fLongNameForImported;
extern int g_fExtraStructPtrTypeSS;

extern int g_fMicrosoftExtensions;

extern int g_chDirectiveBegin;
extern int g_chDirectiveEnd;
extern int g_chDirectiveAND;

extern char *g_pszApiPostfix;
extern char *g_pszChoicePostfix;
extern char *g_pszOptionPostfix;
extern char *g_pszOptionValue;

extern void StripModuleName(char *pszDst, char *pszSrc);

extern int g_cGhostFiles;
extern GhostFile_t g_aGhostFiles[16];

#endif // _ASN1C_DEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\examine.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "error.h"
#include "util.h"

typedef enum {
    eNull, eSingle, eMultiple, eString
} RepresentationGroup_e;

void BuildTypeFlags(AssignmentList_t ass, Type_t *type);
Type_t *RebuildTypeWithoutSelectionType(AssignmentList_t ass, Type_t *type);

/* name the sub types of a type */
/* returns 1 if any naming has been performed */
int
NameSubType(AssignmentList_t *ass, char *identifier, Type_t *type, ModuleIdentifier_t *module)
{
    char name[256], *n;
    char *p;
    Component_t *components;
    Type_t *subtype;
    int ret = 0;

    /* build the prefix for the subtypes */
    strcpy(name, identifier);
    strcat(name, "_");
    p = name + strlen(name);

    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:

	/* check all components */
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:

		/* do not name unstructured types */
		if (!IsStructuredType(components->U.NOD.NamedType->Type))
		    break;

		/* name the type of the component and use a type */
		/* reference instead */
		strcpy(p, components->U.NOD.NamedType->Identifier);
		n = Identifier2C(name);
		subtype = NewType(eType_Reference);
		subtype->U.Reference.Identifier = n;
		subtype->U.Reference.Module = module;
		AssignType(ass, subtype, components->U.NOD.NamedType->Type);
		components->U.NOD.NamedType->Type = subtype;
		if (components->Type == eComponent_Default)
		    components->U.NOD.Value->Type = subtype;
		ret = 1;
		break;
	    }
	}
	break;

    case eType_SequenceOf:
    case eType_SetOf:
	
	/* already named? */
	if (type->U.SS.Type->Type == eType_Reference)
	    break;

	/* name the type of the elements and use a type reference instead */
	strcpy(p, type->Type == eType_SequenceOf ? "Seq" : "Set");
	n = Identifier2C(name);
	subtype = NewType(eType_Reference);
	subtype->U.Reference.Identifier = n;
	subtype->U.Reference.Module = module;
	AssignType(ass, subtype, type->U.SS.Type);
	type->U.SS.Type = subtype;
	ret = 1;
	break;

    case eType_Selection:

	/* do not name unstructured types */
	if (!IsStructuredType(type->U.Selection.Type))
	    break;

	/* name the type of the selected type and use a type reference */
	/* instead */
	strcpy(p, "Sel");
	n = Identifier2C(name);
	subtype = NewType(eType_Reference);
	subtype->U.Reference.Identifier = n;
	subtype->U.Reference.Module = module;
	AssignType(ass, subtype, type->U.Selection.Type);
	type->U.Selection.Type = subtype;
	ret = 1;
	break;
    }

    /* return 1 if any naming has been performed */
    return ret;
}

/* name the default value of a type */
/* return 1 if any naming has been performed */
int
NameValueOfType(AssignmentList_t *ass, char *identifier, Type_t *type, ModuleIdentifier_t *module)
{
    char name[256], *n;
    char *p;
    Component_t *components;
    Value_t *subvalue;
    int ret = 0;

    /* build the prefix for the subtypes */
    strcpy(name, identifier);
    strcat(name, "_");
    p = name + strlen(name);

    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:

	/* check all components */
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Default:

		/* already named? */
		if (!components->U.NOD.Value->Type)
		    break;

		/* name the value of the default component and use a value */
		/* reference instead */
		strcpy(p, components->U.NOD.NamedType->Identifier);
		strcat(p, "_default");
		n = Identifier2C(name);
		subvalue = NewValue(NULL, NULL);
		subvalue->U.Reference.Identifier = n;
		subvalue->U.Reference.Module = module;
		AssignValue(ass, subvalue, components->U.NOD.Value);
		components->U.NOD.Value = subvalue;
		ret = 1;
		break;
	    }
	}
	break;
    }

    /* return 1 if any naming has been performed */
    return ret;
}

/* name the types of typefields of the settings of an object */
/* return 1 if any naming has been performed */
int
NameSettings(AssignmentList_t *ass, char *identifier, SettingList_t se, ModuleIdentifier_t *module)
{
    int ret = 0;
    char name[256], *n;
    char *p;
    Type_t *subtype;

    /* build the prefix for the subtypes */
    strcpy(name, identifier);
    strcat(name, "_");
    p = name + strlen(name);

    /* check all settings */
    for (; se; se = se->Next) {
	strcpy(p, se->Identifier + 1);
	switch (se->Type) {
	case eSetting_Type:

	    /* name field type if not already named */
	    if (se->U.Type.Type->Type != eType_Reference) {
		n = Identifier2C(name);
		subtype = NewType(eType_Reference);
		subtype->U.Reference.Identifier = n;
		subtype->U.Reference.Module = module;
		ret = AssignType(ass, subtype, se->U.Type.Type);
	    }

	    /* mark field type for generation */
	    se->U.Type.Type->Flags |= eTypeFlags_GenAll;
	    break;
	}
    }

    /* return 1 if any naming has been performed */
    return ret;
}

/* name the default types of typefields of the field specs of an object class */
/* return 1 if any naming has been performed */
int
NameDefaultTypes(AssignmentList_t *ass, char *identifier, ObjectClass_t *oc, SettingList_t se, ModuleIdentifier_t *module)
{
    int ret = 0;
    char name[256], *n;
    char *p;
    Type_t *subtype;
    FieldSpec_t *fs;

    /* build the prefix for the subtypes */
    strcpy(name, identifier);
    strcat(name, "_");
    p = name + strlen(name);
    oc = GetObjectClass(*ass, oc);

    /* check all field specs */
    for (fs = oc->U.ObjectClass.FieldSpec; fs; fs = fs->Next) {
	strcpy(p, fs->Identifier + 1);
	switch (fs->Type) {
	case eFieldSpec_Type:

	    /* check if typefield has a default type */
	    if (fs->U.Type.Optionality->Type != eOptionality_Default_Type ||
	        FindSetting(se, fs->Identifier))
		break;

	    /* name field type if not already named */
	    if (fs->U.Type.Optionality->U.Type->Type != eType_Reference) {
		n = Identifier2C(name);
		subtype = NewType(eType_Reference);
		subtype->U.Reference.Identifier = n;
		subtype->U.Reference.Module = module;
		ret = AssignType(ass, subtype, fs->U.Type.Optionality->U.Type);
	    }

	    /* mark field type for generation */
	    fs->U.Type.Optionality->U.Type->Flags |= eTypeFlags_GenAll;
	    break;
	}
    }

    /* return 1 if any naming has been performed */
    return ret;
}

/* name the types of type fields of an object and the default types of */
/* typefields of the field specs of an object class */
/* return 1 if any naming has been performed */
int
NameSettingsOfObject(AssignmentList_t *ass, char *identifier, Object_t *object, ModuleIdentifier_t *module)
{
    int ret = 0;

    switch (object->Type) {
    case eObject_Object:
	ret = NameSettings(ass, identifier, object->U.Object.Settings,
	    module);
	ret |= NameDefaultTypes(ass, identifier, object->U.Object.ObjectClass,
	    object->U.Object.Settings, module);
	break;
    }

    /* return 1 if any naming has been performed */
    return ret;
}

/* name the identification value of embedded pdv/character string types */
void
NameIdentificationValueOfType(AssignmentList_t *ass, char *identifier, Type_t *type, ModuleIdentifier_t *module)
{
    char name[256], *n;
    char *p;
    Component_t *components;
    NamedValue_t *namedValues;
    Value_t *subvalue;

    /* build the prefix for the subtypes */
    strcpy(name, identifier);
    strcat(name, "_");
    p = name + strlen(name);

    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:
	
	/* check all components */
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		strcpy(p, components->U.NOD.NamedType->Identifier);
		NameIdentificationValueOfType(ass, name,
		    components->U.NOD.NamedType->Type, module);
		break;
	    }
	}
	break;

    case eType_SequenceOf:
    case eType_SetOf:

	/* check the subtype */
	strcpy(p, type->Type == eType_SequenceOf ? "Seq" : "Set");
	NameIdentificationValueOfType(ass, name, type->U.SS.Type, module);
	break;

    case eType_EmbeddedPdv:
    case eType_CharacterString:

	/* check if type has a fixed identification syntaxes constraint */
	namedValues = GetFixedIdentification(*ass, type->Constraints);
	if (namedValues && !strcmp(namedValues->Identifier, "syntaxes")) {

	    /* name the identification and use a value reference instead */
	    for (namedValues = namedValues->Value->U.SSC.NamedValues;
		namedValues; namedValues = namedValues->Next) {
		strcpy(p, "identification_syntaxes_");
		strcat(p, namedValues->Identifier);
		n = Identifier2C(name);
		subvalue = NewValue(NULL, NULL);
		subvalue->U.Reference.Identifier = n;
		subvalue->U.Reference.Module = module;
		AssignValue(ass, subvalue, namedValues->Value);
	    }
	}
	break;
    }
}

/* name the type of a value */
/* returns 1 if any naming has been performed */
int
NameTypeOfValue(AssignmentList_t *ass, char *identifier, Value_t *value, ModuleIdentifier_t *module)
{
    Type_t *type;
    char name[256], *n;
    Type_t *subtype;
    int ret = 0;

    type = value->Type;

    /* do not name types of value references or unstructured types */
    if (type && IsStructuredType(type)) {

	/* build the prefix for the subtype */
	strcpy(name, identifier);
	strcat(name, "_");
	strcat(name, "Type");
	n = Identifier2C(name);

	/* name the type and use a type reference instead */
	subtype = NewType(eType_Reference);
	subtype->U.Reference.Identifier = n;
	subtype->U.Reference.Module = module;
	AssignType(ass, subtype, type);
	value->Type = subtype;
	ret = 1;
    }
    return ret;
}

/* replace any components of by the components of the referenced type */
ComponentList_t
RebuildComponentsWithoutComponentsOf(AssignmentList_t ass, ComponentList_t components)
{
    Component_t *newcomponents, *subcomponents, **pcomponents;
    Type_t *subtype;
    int ext;

    ext = 0;
    pcomponents = &newcomponents;
    for (; components; components = components->Next) {
	switch (components->Type) {
	case eComponent_ComponentsOf:

	    /* components of should not be used in an extension */
	    if (ext)
		error(E_COMPONENTS_OF_in_extension, NULL);

	    /* get the components of the referenced type */
	    subtype = GetType(ass, components->U.ComponentsOf.Type);
	    switch (subtype->Type) {
	    case eType_Sequence:
	    case eType_Set:
	    case eType_Choice:
	    case eType_External:
	    case eType_EmbeddedPdv:
	    case eType_CharacterString:
	    case eType_Real:
	    case eType_InstanceOf:
		subcomponents = subtype->U.SSC.Components;
		break;
	    default:
		error(E_applied_COMPONENTS_OF_to_bad_type, NULL);
	    }

	    /* get the real components of the referenced type */
	    /*XXX self-referencing components of types will idle forever */
	    *pcomponents = RebuildComponentsWithoutComponentsOf(ass,
		subcomponents);

	    /* find end of components of referenced type */
	    while (*pcomponents) {
		if ((*pcomponents)->Type == eComponent_ExtensionMarker)
		    error(E_COMPONENTS_OF_extended_type, NULL);
		pcomponents = &(*pcomponents)->Next;
	    }
	    break;

	case eComponent_ExtensionMarker:

	    /* copy extension marker */
	    ext = 1;
	    *pcomponents = DupComponent(components);
	    pcomponents = &(*pcomponents)->Next;
	    break;
	default:

	    /* copy other components */
	    *pcomponents = DupComponent(components);
	    pcomponents = &(*pcomponents)->Next;
	    break;
	}
    }

    /* terminate and return component list */
    *pcomponents = NULL;
    return newcomponents;
}

/* replace any components of by the components of the referenced type */
Type_t *
RebuildTypeWithoutComponentsOf(AssignmentList_t ass, Type_t *type)
{
    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
	type->U.SSC.Components =
	    RebuildComponentsWithoutComponentsOf(ass, type->U.SSC.Components);
	break;
    }
    return type;
}

/* replace any selection type by the component of the selected type */
ComponentList_t
RebuildComponentsWithoutSelectionType(AssignmentList_t ass, ComponentList_t components)
{
    Component_t *c;

    for (c = components; c; c = c->Next) {
	switch (c->Type) {
	case eComponent_Normal:
	case eComponent_Optional:
	case eComponent_Default:
	    c->U.NOD.NamedType->Type = RebuildTypeWithoutSelectionType(
		ass, c->U.NOD.NamedType->Type);
	    break;
	}
    }
    return components;
}

/* replace any selection type by the component of the selected type */
Type_t *RebuildTypeWithoutSelectionType(AssignmentList_t ass, Type_t *type)
{
    Type_t *subtype;
    Component_t *components;

    switch (type->Type) {
    case eType_Selection:
	subtype = GetType(ass, type->U.Selection.Type);
	switch (subtype->Type) {
	case eType_Sequence:
	case eType_Set:
	case eType_Choice:
	case eType_External:
	case eType_EmbeddedPdv:
	case eType_CharacterString:
	case eType_Real:
	case eType_InstanceOf:

	    /* get the components of the referenced type */
	    components = FindComponent(ass, subtype->U.SSC.Components,
		type->U.Selection.Identifier);
	    if (!components)
		error(E_bad_component_in_selectiontype, NULL);

	    /* get the real type of the referenced type */
	    /*XXX self-referencing selection types will idle forever */
	    type = RebuildTypeWithoutSelectionType(ass,
		components->U.NOD.NamedType->Type);
	    break;
	default:
	    error(E_selection_of_bad_type, NULL);
	}
	break;

    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
	type->U.SSC.Components =
	    RebuildComponentsWithoutSelectionType(ass, type->U.SSC.Components);
	break;

    case eType_SequenceOf:
    case eType_SetOf:
	type->U.SS.Type = RebuildTypeWithoutSelectionType(ass, type->U.SS.Type);
	break;
    }
    return type;
}

/* mark a type for autotagging */
void
MarkTypeForAutotagging(AssignmentList_t ass, Type_t *type)
{
    Component_t *components;
    int ext;

    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
	ext = 0;

	/* set flags for autotagging */
	type->U.SSC.Autotag[0] = 1;
	type->U.SSC.Autotag[1] = 1;

	/* reset flags for autotagging if a tag has been used */
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		if (GetTag(ass, components->U.NOD.NamedType->Type))
		    type->U.SSC.Autotag[ext] = 0;
		break;
	    case eComponent_ExtensionMarker:
		ext = 1;
		break;
	    case eComponent_ComponentsOf:
		break;
	    }
	}
	break;
    }
}

/* autotag a marked type */
void
AutotagType(AssignmentList_t ass, Type_t *type)
{
    Component_t *components;
    Type_t *subtype;
    int ext;
    int tag;
    Tag_t *tags;

    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
	ext = 0;

	/* tag number to use */
	tag = 0;

	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		subtype = components->U.NOD.NamedType->Type;
		tags = subtype->Tags;

		/* check if type needs autotagging */
		if (!tags &&
		    type->TagDefault == eTagType_Automatic &&
		    type->U.SSC.Autotag[ext]) {

		    /* create a tagged version of the type */
		    components->U.NOD.NamedType->Type = subtype =
			DupType(subtype);

		    /* use explicit tag for choice components types and */
		    /* for open type and dummy reference, implicit tag */
		    /* otherwise */
		    if (subtype->Type == eType_Choice ||
			subtype->Type == eType_Open
			/*XXX || DummyReference*/) {
			subtype->Tags = NewTag(eTagType_Explicit);
		    } else {
			subtype->Tags = NewTag(eTagType_Implicit);
		    }
		    subtype->Tags->Tag = NewValue(NULL, Builtin_Type_Integer);
		    intx_setuint32(&subtype->Tags->Tag->U.Integer.Value,
			tag++);
		}
		break;

	    case eComponent_ExtensionMarker:
		ext = 1;
		break;
	    }
	}
	break;
    }
}

/* mark constraints extendable */
void
AutoextendConstraints(Constraint_t *constraints)
{
    if (!constraints)
	return;
    if (constraints->Type == eExtension_Unextended)
	constraints->Type = eExtension_Extendable;
}

/* autoextend a type if desired */
void
AutoextendType(AssignmentList_t ass, Type_t *type)
{
    Component_t *c, **cc;
    Type_t *subtype;
    int ext;

    /* already done? */
    if (type->Flags & eTypeFlags_Done)
	return;
    type->Flags |= eTypeFlags_Done;

    /* auto extending wanted? */
    if (type->ExtensionDefault != eExtensionType_Automatic)
	return;

    /* check all sub types */
    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:

	/* extend a sequence/set/choice type */
	ext = 0;
	for (cc = &type->U.SSC.Components, c = *cc; c;
	    c = c->Next, cc = &(*cc)->Next) {
	    *cc = DupComponent(c);
	    switch (c->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		subtype = c->U.NOD.NamedType->Type;
		AutoextendType(ass, subtype);
		break;
	    case eComponent_ExtensionMarker:
		ext = 1;
		break;
	    }
	}
	if (!ext) {
	    *cc = NewComponent(eComponent_ExtensionMarker);
	    cc = &(*cc)->Next;
	}
	*cc = NULL;
	break;

    case eType_SequenceOf:
    case eType_SetOf:
	subtype = type->U.SS.Type;
	AutoextendType(ass, subtype);
	break;
    }

    /* mark type as extendable */
    AutoextendConstraints(type->Constraints);
}

/* set the tag type of unspecified tags to explicit or implicit, */
/* create list of all tags (including the type's universal tag and the */
/* tags of the referenced type if applicable), */
/* and create list of first tags (esp. for choice types) */
void
BuildTags(AssignmentList_t ass, Type_t *type, TagType_e eParentDefTagType)
{
    Tag_t *t, *t2, **tt;
    Component_t *components;
    Type_t *reftype;
    Type_e te;
    uint32_t i;

    /* already done? */
    if (type->Flags & eTypeFlags_Done)
	return;
    type->Flags |= eTypeFlags_Done;

    // update default tag type
	if (type->TagDefault == eTagType_Unknown &&
	    (eParentDefTagType == eTagType_Explicit || eParentDefTagType == eTagType_Implicit))
	{
		type->TagDefault = eParentDefTagType;
	}

    /* set tag type of unspecified tags to explicit or implicit */
    /* use explicit tags when: */
    /* - TagDefault indicates explicit tags, */
    /* - Type is choice/open type/dummy reference and no other explicit tag */
    /*   will follow */
    te = GetTypeType(ass, type);
	if (type->Tags)
	{
		for (tt = &type->Tags, t = type->Tags; t; tt = &(*tt)->Next, t = t->Next)
		{
			*tt = DupTag(t);
			if ((*tt)->Type == eTagType_Unknown)
			{
				for (t2 = t->Next; t2; t2 = t2->Next)
				{
				    if (t2->Type != eTagType_Implicit)
					    break;
				}
				if (type->TagDefault == eTagType_Explicit ||
				    (!t2 && (te == eType_Choice || te == eType_Open /*XXX || DummyReference*/)))
				{
				    (*tt)->Type = eTagType_Explicit;
				}
				else
				{
				    (*tt)->Type = eTagType_Implicit;
				}
			}
		}
	}

    /* copy given tags to AllTags list */
    for (tt = &type->AllTags, t = type->Tags;
         t;
	     tt = &(*tt)->Next, t = t->Next)
	{
    	*tt = DupTag(t);
    }

    /* build tags of subtypes and copy tags of reference type */
    switch (type->Type)
    {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:
    	for (components = type->U.SSC.Components;
    	     components;
    	     components = components->Next)
    	{
    	    switch (components->Type)
    	    {
    	    case eComponent_Normal:
    	    case eComponent_Optional:
    	    case eComponent_Default:
    		    BuildTags(ass, components->U.NOD.NamedType->Type, type->TagDefault);
    		    break;
    	    }
    	}
    	break;
    case eType_SequenceOf:
    case eType_SetOf:
    	BuildTags(ass, type->U.SS.Type, eTagType_Unknown);
	    break;
    case eType_Reference:
    	reftype = GetReferencedType(ass, type);
    	BuildTags(ass, reftype, type->TagDefault);
    	for (t = reftype->AllTags; t; tt = &(*tt)->Next, t = t->Next)
    	{
    	    *tt = DupTag(t);
    	}
    	break;
    }

    /* add the type's universal tag to the AllTags list if the type is */
    /* not an internal type */
    if (!(type->Type & 0x8000))
    {
    	*tt = NewTag(eTagType_Implicit);
    	(*tt)->Class = eTagClass_Universal;
    	(*tt)->Tag = NewValue(NULL, Builtin_Type_Integer);
    	intx_setuint32(&(*tt)->Tag->U.Integer.Value, type->Type & 0x1f);
    }

    /* build list of FirstTags containing the possible tag values of the type */
    tt = &type->FirstTags;
    if (type->AllTags)
    {
    	/* if type has any tags, only the first tag is needed */
    	*tt = DupTag(type->AllTags);
    	tt = &(*tt)->Next;
    }
    else
    {
    	/* otherwise we have to examine the type */
    	switch (type->Type)
    	{
    	case eType_Choice:

    	    /* get the first tags of all components of a choice as FirstTags */
    	    for (components = type->U.SSC.Components;
    	         components;
    		     components = components->Next)
    		{
        		switch (components->Type)
        		{
        		case eComponent_Normal:
        		case eComponent_Optional:
        		case eComponent_Default:
        		    for (t = components->U.NOD.NamedType->Type->FirstTags;
        		         t;
        			     t = t->Next)
        			{
            			*tt = DupTag(t);
            			tt = &(*tt)->Next;
        		    }
        		    break;
        		}
    	    }
    	    break;

    	case eType_Open:

    	    /* create a list of all tags for open type */
    	    for (i = 1; i < 0x20; i++)
    	    {
        		*tt = NewTag(eTagType_Unknown);
        		(*tt)->Class = eTagClass_Unknown;
        		(*tt)->Tag = NewValue(NULL, Builtin_Type_Integer);
        		intx_setuint32(&(*tt)->Tag->U.Integer.Value, i);
        		tt = &(*tt)->Next;
    	    }
    	    break;

    	case eType_Reference:

    	    /* get the tags of the referenced type */
    	    for (t = reftype->FirstTags; t; t = t->Next)
    	    {
        		*tt = DupTag(t);
        		tt = &(*tt)->Next;
    	    }
    	    break;
    	}
    }
    *tt = NULL;
}

/* get the smallest tag of a tag list */
Tag_t *
FindSmallestTag(AssignmentList_t ass, TagList_t tags)
{
    Tag_t *mintag, *t;

    mintag = tags;
    for (t = tags->Next; t; t = t->Next) {
	if (mintag->Class > t->Class ||
	    mintag->Class == t->Class && intx_cmp(
	    &GetValue(ass, mintag->Tag)->U.Integer.Value,
	    &GetValue(ass, t->Tag)->U.Integer.Value) > 0)
	    mintag = t;
    }
    return mintag;
}

/* compare two tags by tag class and tag value */
int
CmpTags(const void *p1, const void *p2, void *ctx)
{
    Tag_t *tags1 = (Tag_t *)p1;
    Tag_t *tags2 = (Tag_t *)p2;
    Assignment_t *ass = (Assignment_t *)ctx;

    if (tags1->Class != tags2->Class)
	return tags1->Class - tags2->Class;
    return intx2uint32(&GetValue(ass, tags1->Tag)->U.Integer.Value) -
	intx2uint32(&GetValue(ass, tags2->Tag)->U.Integer.Value);
}

/* compare two components by their smallest tag */
int
CmpComponentsBySmallestTag(const void *p1, const void *p2, void *ctx)
{
    Component_t *c1 = (Component_t *)p1;
    Component_t *c2 = (Component_t *)p2;
    Assignment_t *ass = (Assignment_t *)ctx;
    Tag_t *tags1, *tags2;

    tags1 = FindSmallestTag(ass, c1->U.NOD.NamedType->Type->FirstTags);
    tags2 = FindSmallestTag(ass, c2->U.NOD.NamedType->Type->FirstTags);
    if (tags1->Class != tags2->Class)
	return tags1->Class - tags2->Class;
    return intx2uint32(&tags1->Tag->U.Integer.Value) -
	intx2uint32(&tags2->Tag->U.Integer.Value);
}

/* sort the components of a set or choice by their smallest tag */
void
SortTypeTags(AssignmentList_t ass, Type_t *type)
{
    Component_t **pcomponents, *extensions;

    switch (type->Type) {
    case eType_Set:
    case eType_Choice:
	/* remove extensions */
	for (pcomponents = &type->U.SSC.Components; *pcomponents;
	    pcomponents = &(*pcomponents)->Next) {
	    if ((*pcomponents)->Type == eComponent_ExtensionMarker)
		break;
	}
	extensions = *pcomponents;
	*pcomponents = NULL;

	/* sort extension root */
	qsortSL((void **)&type->U.SSC.Components, offsetof(Component_t, Next),
	    CmpComponentsBySmallestTag, ass);

	/* sort extensions */
	if (extensions && extensions->Next)
	    qsortSL((void **)&extensions->Next, offsetof(Component_t, Next),
		CmpComponentsBySmallestTag, ass);

	/* merge extension root and extensions */
	for (pcomponents = &type->U.SSC.Components; *pcomponents;
	    pcomponents = &(*pcomponents)->Next) {}
	*pcomponents = extensions;
	break;
    }
}

/* check if two lists of tags have common tags */
void
CheckCommonTags(AssignmentList_t ass, TagList_t tags1, TagList_t tags2)
{
    Tag_t *t1, *t2;
    int ret;

    qsortSL((void **)&tags1, offsetof(Tag_t, Next), CmpTags, ass);
    qsortSL((void **)&tags2, offsetof(Tag_t, Next), CmpTags, ass);
    for (t1 = tags1, t2 = tags2; t1 && t2; ) {
	ret = CmpTags((const void *)t1, (const void *)t2, (void *)ass);
	if (ret == 0) {
	    error(E_duplicate_tag, NULL);
	} else if (ret < 0) {
	    t1 = t1->Next;
	} else {
	    t2 = t2->Next;
	}
    }
}

/* check if a list of tags and the first tags of components have common tags */
void
CheckTagsInComponents(AssignmentList_t ass, TagList_t tags, ComponentList_t components, int untilnormal)
{
    for (; components; components = components->Next) {
	switch (components->Type) {
	case eComponent_Normal:
	case eComponent_Optional:
	case eComponent_Default:
	    CheckCommonTags(ass, tags,
		components->U.NOD.NamedType->Type->FirstTags);
	    if (untilnormal && components->Type == eComponent_Normal)
		return;
	    break;
	}
    }
}

/* check for common tags */
void
CheckTags(AssignmentList_t ass, Type_t *type)
{
    Component_t *c;
    Type_t *subtype;
    Tag_t *tag;

    switch (type->Type) {
    case eType_Sequence:

	/* check for common tags in a sequence: */
	/* the first tags of an optional/default component and the first */
	/* tags of the following components (up to and including the next */
	/* non-optional/non-default component) must not have common first */
	/* tags */
	for (c = type->U.Sequence.Components; c; c = c->Next) {
	    switch (c->Type) {
	    case eComponent_Optional:
	    case eComponent_Default:
		subtype = c->U.NOD.NamedType->Type;
		tag = subtype->FirstTags;
		CheckTagsInComponents(ass, tag, c->Next, 1);
		break;
	    }
	}
	break;

    case eType_Set:
    case eType_Choice:

	/* check for common tags in a set/choice: */
	/* the first tags of all components must be destinct */
	for (c = type->U.Sequence.Components; c; c = c->Next) {
	    switch (c->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		subtype = c->U.NOD.NamedType->Type;
		tag = subtype->FirstTags;
		CheckTagsInComponents(ass, tag, c->Next, 0);
		break;
	    }
	}
	break;
    }
}

/* build the list of PER-visible constraints */
void BuildConstraints(AssignmentList_t ass, Type_t *type)
{
    Type_t *reftype;
    Constraint_t *cons, *c1, *c2;
    Component_t *components;

    /* already done? */
    if (type->Flags & eTypeFlags_Done)
	return;
    type->Flags |= eTypeFlags_Done;

    switch (type->Type) {
    case eType_Reference:

	/* create an intersection of the constraints of the reference type */
	/* and the constraints of the referenced type */
	reftype = GetReferencedType(ass, type);
	BuildConstraints(ass, reftype);
	c1 = reftype->Constraints;
	c2 = type->Constraints;
	if (c1) {
	    if (c2) {
		IntersectConstraints(&cons, c1, c2);
	    } else {
		cons = c1;
	    }
	} else {
	    cons = c2;
	}
	type->Constraints = cons;

	/* get the PER-visible constraints */
	GetPERConstraints(ass, cons, &type->PERConstraints);
	break;

    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:

	/* build the constraints of any component */
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		reftype = components->U.NOD.NamedType->Type;
		BuildConstraints(ass, reftype);
		break;
	    }
	}

	/* get the PER-visible constraints */
	GetPERConstraints(ass, type->Constraints, &type->PERConstraints);
	break;

    case eType_SequenceOf:
    case eType_SetOf:

	/* build the constraints of the subtype */
	reftype = type->U.SS.Type;
	BuildConstraints(ass, reftype);

	/* get the PER-visible constraints */
	GetPERConstraints(ass, type->Constraints, &type->PERConstraints);
	break;

    default:

	/* get the PER-visible constraints */
	GetPERConstraints(ass, type->Constraints, &type->PERConstraints);
	break;
    }
}

/* build type flags from the directives */
void BuildDirectives(AssignmentList_t ass, Type_t *type, int isComponent)
{
    int pointer = 0;
    TypeRules_e rule = 0;
    RepresentationGroup_e grp;
    int32_t noctets;
    uint32_t zero;
    Directive_t *d;
    Component_t *components;
    Type_t *reftype;

    /* already done? */
    if (type->Flags & eTypeFlags_Done)
	return;
    type->Flags |= eTypeFlags_Done;

    /* get directive group which may be applied to the type */
    switch (type->Type)
    {
    case eType_Boolean:
    case eType_Integer:
    case eType_ObjectIdentifier:
    case eType_ObjectDescriptor:
    case eType_External:
    case eType_Real:
    case eType_Enumerated:
    case eType_EmbeddedPdv:
    case eType_Sequence:
    case eType_Set:
    case eType_InstanceOf:
    case eType_UTCTime:
    case eType_GeneralizedTime:
    case eType_Choice:
    case eType_BitString:
    case eType_OctetString:
        grp = eSingle;
        break;
    case eType_Reference:
        grp = eSingle;
        break;
    case eType_CharacterString:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_VideotexString:
    case eType_IA5String:
    case eType_GraphicString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GeneralString:
    case eType_UniversalString:
    case eType_BMPString:
    case eType_RestrictedString:
    case eType_UTF8String:
        grp = eString;
        /*XXX rule = zero ? eTypeRules_ZeroTerminated : eTypeRules_FixedArray;
          for upperconstrained size */
        // lonchanc: it was eTypeRules_LengthPointer
        if (type->PrivateDirectives.fLenPtr)
        {
            rule = eTypeRules_LengthPointer;
        }
        else
        if (type->PrivateDirectives.fArray)
        {
            rule = eTypeRules_FixedArray;
        }
        else
        {
            GetStringType(ass, type, &noctets, &zero);
            rule = zero ? eTypeRules_ZeroTerminated : eTypeRules_LengthPointer;
        }
        break;
    case eType_Null:
        grp = eNull;
        break;
    case eType_SequenceOf:
    case eType_SetOf:
        grp = eMultiple;
        // lonchanc: it was eTypeRules_LengthPointer
        if (type->PrivateDirectives.fSLinked)
        {
            rule = eTypeRules_SinglyLinkedList;
        }
        else
        if (type->PrivateDirectives.fLenPtr)
        {
            rule = eTypeRules_LengthPointer;
        }
        else
        if (type->PrivateDirectives.fArray)
        {
            rule = eTypeRules_FixedArray;
        }
        else
        if (type->PrivateDirectives.fPointer)
        {
            rule = eTypeRules_PointerToElement | eTypeRules_FixedArray;
        }
        else
        if (type->PrivateDirectives.fDLinked)
        {
            rule = eTypeRules_DoublyLinkedList;
        }
        else
        {
            if (eExtension_Unconstrained == type->PERConstraints.Size.Type)
            {
                rule = g_eDefTypeRuleSS_NonSized;
            }
            else
            {
                rule = g_eDefTypeRuleSS_Sized;
            }
        }
        break;
    case eType_Selection:
	MyAbort();
	/*NOTREACHED*/
    case eType_Undefined:
	MyAbort();
	/*NOTREACHED*/
    }

    /* parse list of directives */
    for (d = type->Directives; d; d = d->Next) {
	switch (d->Type) {
	case eDirective_LengthPointer:
	    if (grp != eString)
		error(E_bad_directive, NULL);
	    rule = eTypeRules_LengthPointer;
	    break;
	case eDirective_ZeroTerminated:
	    if (grp != eString)
		error(E_bad_directive, NULL);
	    rule = eTypeRules_ZeroTerminated;
	    break;
	case eDirective_Pointer:
	    if (!isComponent)
		error(E_bad_directive, NULL);
	    pointer = eTypeRules_Pointer;
	    break;
	case eDirective_NoPointer:
	    if (!isComponent)
		error(E_bad_directive, NULL);
	    pointer = 0;
	    break;
	}
    }

    /* parse list of size directives of sequence of/set of */
    if (type->Type == eType_SequenceOf || type->Type == eType_SetOf) {
	for (d = type->U.SS.Directives; d; d = d->Next) {
	    switch (d->Type) {
	    case eDirective_FixedArray:
		rule = eTypeRules_FixedArray;
		break;
	    case eDirective_DoublyLinkedList:
		rule = eTypeRules_DoublyLinkedList;
		break;
	    case eDirective_SinglyLinkedList:
		rule = eTypeRules_SinglyLinkedList;
		break;
	    case eDirective_LengthPointer:
		rule = eTypeRules_LengthPointer;
		break;
	    }
	}
    }

    /* lists are always pointered, no additional pointer needed */
    if (rule & (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList))
	pointer = 0;

    /* set type flags according to directive rule and pointer flag */
    type->Rules = rule | pointer;

    /* build directives of subtypes */
    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:
	components = type->U.SSC.Components;
	for (; components; components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		reftype = components->U.NOD.NamedType->Type;
		BuildDirectives(ass, reftype, 1);
		break;
	    case eComponent_ExtensionMarker:
		break;
	    }
	}
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	reftype = type->U.SS.Type;
	BuildDirectives(ass, reftype, 0);
	break;
    }
}

/* build type flags and counters for components */
/* will set eTypeFlags_Null if type has only null components */
/* will set eTypeFlags_Simple if type has only simple components */
/* will count optional/default components in the extension root (optionals) */
/* will count components in the extension root (alternatives) */
/* will count components in the extension (extensions) */
void
BuildComponentsTypeFlags(AssignmentList_t ass, ComponentList_t components, TypeFlags_e *flags, uint32_t *alternatives, uint32_t *optionals, uint32_t *extensions)
{
    int extended = 0;
    TypeFlags_e f = eTypeFlags_Null | eTypeFlags_Simple;

    while (components) {
	switch (components->Type) {
	case eComponent_Normal:
	case eComponent_Optional:
	case eComponent_Default:
	    BuildTypeFlags(ass, components->U.NOD.NamedType->Type);
	    if (!(components->U.NOD.NamedType->Type->Flags & eTypeFlags_Null))
		f &= ~eTypeFlags_Null;
	    if ((components->U.NOD.NamedType->Type->Rules &
		eTypeRules_Pointer) ||
		!(components->U.NOD.NamedType->Type->Flags & eTypeFlags_Simple))
		f &= ~eTypeFlags_Simple;
	    if (extended) {
		if (extensions)
		    (*extensions)++;
	    } else {
		if (alternatives)
		    (*alternatives)++;
		if (optionals && components->Type != eComponent_Normal)
		    (*optionals)++;
	    }
	    break;
	case eComponent_ExtensionMarker:
	    f |= eTypeFlags_ExtensionMarker;
	    extended = 1;
	    break;
	}
	components = components->Next;
    }
    *flags |= f;
}

/* build type flags and count components of sequence/set/choice types */
void
BuildTypeFlags(AssignmentList_t ass, Type_t *type)
{
    Assignment_t *a;
    Type_t *subtype;
    char *itype;
    int32_t sign;

    /* already done? */
    if (type->Flags & eTypeFlags_Done)
	return;
    type->Flags |= eTypeFlags_Done;


    switch (type->Type) {
    case eType_Null:

	/* null is null and simple */
	type->Flags |= eTypeFlags_Null | eTypeFlags_Simple;
	break;

    case eType_Boolean:
    case eType_Enumerated:

	/* boolean and enumerated are simple if no pointer is used  */
	if (!(type->Rules & eTypeRules_Pointer))
	    type->Flags |= eTypeFlags_Simple;
	break;

    case eType_Integer:

	/* integer is simple if no pointer is used and no intx_t is used */
	itype = GetIntegerType(ass, type, &sign);
	if (strcmp(itype, "ASN1intx_t") && !(type->Rules & eTypeRules_Pointer))
	    type->Flags |= eTypeFlags_Simple;
	break;

    case eType_Real:

	/* real is simple if no pointer is used and no real_t is used */
	itype = GetRealType(type);
	if (strcmp(itype, "ASN1real_t") && !(type->Rules & eTypeRules_Pointer))
	    type->Flags |= eTypeFlags_Simple;
	break;

    case eType_Sequence:
    case eType_Set:

	/* build type flags and counters for the components */
	BuildComponentsTypeFlags(ass, type->U.SSC.Components, &type->Flags,
	    NULL, &type->U.SSC.Optionals, &type->U.Sequence.Extensions);

	/* an extended type or a type containing optionals is not null */
	if ((type->Flags & eTypeFlags_ExtensionMarker) || type->U.SSC.Optionals)
	    type->Flags &= ~eTypeFlags_Null;
	break;

    case eType_SequenceOf:
    case eType_SetOf:

	/* never null nor simple */
    	BuildTypeFlags(ass, type->U.SS.Type);
    	break;

    case eType_Choice:

	/* build type flags and counters for the components */
	BuildComponentsTypeFlags(ass, type->U.Choice.Components, &type->Flags,
	    &type->U.Choice.Alternatives, NULL, &type->U.Choice.Extensions);

	/* a choice of nulls with more than one alternative or extensions */
	/* is not null because an offset has to be encoded */
	/* set the nullchoice flag instead */
	if ((type->Flags & eTypeFlags_Null) && 
	    ((type->Flags & eTypeFlags_ExtensionMarker) ||
	    type->U.Choice.Alternatives > 1)) {
	    type->Flags &= ~eTypeFlags_Null;
	    type->Flags |= eTypeFlags_NullChoice;
	}
	break;

    case eType_Reference:

	/* get the flags of the referenced type */
	a = FindAssignment(ass, eAssignment_Type,
	    type->U.Reference.Identifier, type->U.Reference.Module);
	a = GetAssignment(ass, a);
	subtype = a->U.Type.Type;
	BuildTypeFlags(ass, subtype);
	type->Flags = subtype->Flags;
	break;
    }
}

/* Mark non-structured types (or all types if wanted) for generation */
void MarkTypeForGeneration(AssignmentList_t ass, Type_t *type, TypeFlags_e needed)
{
    Assignment_t *a;
    Component_t *components;

    /* already done? */
    if (type->Flags & eTypeFlags_Done) {
	type->Flags |= needed;
	return;
    }
    type->Flags |= eTypeFlags_Done | needed;

    if (!IsStructuredType(GetType(ass, type)) && !ForceAllTypes) {

	/* generate type only */
	type->Flags |= eTypeFlags_GenType;
    } else {
	
	if (type->Flags & eTypeFlags_Simple) {

	    /* generate encoding/decoding/compare */
	    type->Flags |= eTypeFlags_GenSimple;
	} else {

	    /* generate encoding/decoding/free/compare */
	    type->Flags |= eTypeFlags_GenAll;
	}
    }

    /* mark subtypes for generation */
    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		MarkTypeForGeneration(ass, components->U.NOD.NamedType->Type,
		    needed);
		break;
	    }
	}
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	MarkTypeForGeneration(ass, type->U.SS.Type,
	    needed | eTypeFlags_GenCompare);
	break;
    case eType_Reference:
	a = FindAssignment(ass, eAssignment_Type,
	    type->U.Reference.Identifier, type->U.Reference.Module);
	a = GetAssignment(ass, a);
	MarkTypeForGeneration(ass, a->U.Type.Type, needed);
	break;
    }
}

/* mark a value for generation */
void
MarkValueForGeneration(AssignmentList_t ass, Value_t *value)
{

    /* already done? */
    if (value->Flags & eValueFlags_Done)
	return;
    value->Flags |= eValueFlags_GenAll | eValueFlags_Done;

    /* mark type of value for generation */
    if (value->Type)
	MarkTypeForGeneration(ass, value->Type, 0);
}

/* mark assignments for generation */
void
MarkForGeneration(AssignmentList_t ass, ModuleIdentifier_t *mainmodule, Assignment_t *a)
{
    /* builtin elements need not to be generated */
    if (!CmpModuleIdentifier(ass, a->Module, Builtin_Module) ||
        !CmpModuleIdentifier(ass, a->Module, Builtin_Character_Module))
	return;

    /* non-main module elements will require long names and are only */
    /* generated if they are referenced by elements of the main module */
    if (CmpModuleIdentifier(ass, a->Module, mainmodule)) {
	a->Flags |= eAssignmentFlags_LongName;
	return;
    }

    /* mark type/value for generation */
    switch (a->Type) {
    case eAssignment_Type:
	MarkTypeForGeneration(ass, a->U.Type.Type, 0);
	break;
    case eAssignment_Value:
	MarkValueForGeneration(ass, a->U.Value.Value);
	break;
    }
}

/* clear done flags of types */
void
ClearTypeDone(Type_t *type)
{
    Component_t *components;

    type->Flags &= ~eTypeFlags_Done;
    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		ClearTypeDone(components->U.NOD.NamedType->Type);
		break;
	    }
	}
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	ClearTypeDone(type->U.SS.Type);
	break;
    }
}

/* clear done flags of values */
void
ClearValueDone(Value_t *value)
{
    value->Flags &= ~eValueFlags_Done;
    if (value->Type)
	ClearTypeDone(value->Type);
}

/* clear done flags of assignments */
void
ClearDone(AssignmentList_t ass)
{
    for (; ass; ass = ass->Next) {
	switch (ass->Type) {
	case eAssignment_Type:
	    ClearTypeDone(ass->U.Type.Type);
	    break;
	case eAssignment_Value:
	    ClearValueDone(ass->U.Value.Value);
	    break;
	}
    }
}

/* examination of assignments */
void Examination(AssignmentList_t *ass, ModuleIdentifier_t *mainmodule)
{
    Assignment_t *a, *nexta, **aa;
    Type_t *subtype;
    Value_t *subvalue;
    ObjectClass_t *subobjclass;
    Object_t *subobject;
    ObjectSet_t *subobjset;
    int redo;

    /* drop results of previous passes */
    for (aa = ass; *aa;) {
	if ((*aa)->Type == eAssignment_NextPass)
	    *aa = NULL;
	else
	    aa = &(*aa)->Next;
    }

    /* reverse order of assignments to get the original order */
    for (a = *ass, *ass = NULL; a; a = nexta) {
	nexta = a->Next;
	a->Next = *ass;
	*ass = a;
    }

    /* replace references from IMPORT by corresponding type-/value-/...-refs */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Reference) {
	    a->Type = GetAssignmentType(*ass, a);
	    switch (a->Type) {
	    case eAssignment_Type:
		subtype = NewType(eType_Reference);
		subtype->U.Reference.Identifier = a->U.Reference.Identifier;
		subtype->U.Reference.Module = a->U.Reference.Module;
		a->U.Type.Type = subtype;
		break;
	    case eAssignment_Value:
		subvalue = NewValue(NULL, NULL);
		subvalue->U.Reference.Identifier = a->U.Reference.Identifier;
		subvalue->U.Reference.Module = a->U.Reference.Module;
		a->U.Value.Value = subvalue;
		break;
	    case eAssignment_ObjectClass:
		subobjclass = NewObjectClass(eObjectClass_Reference);
		subobjclass->U.Reference.Identifier = a->U.Reference.Identifier;
		subobjclass->U.Reference.Module = a->U.Reference.Module;
		a->U.ObjectClass.ObjectClass = subobjclass;
		break;
	    case eAssignment_Object:
		subobject = NewObject(eObject_Reference);
		subobject->U.Reference.Identifier = a->U.Reference.Identifier;
		subobject->U.Reference.Module = a->U.Reference.Module;
		a->U.Object.Object = subobject;
		break;
	    case eAssignment_ObjectSet:
		subobjset = NewObjectSet(eObjectSet_Reference);
		subobjset->U.Reference.Identifier = a->U.Reference.Identifier;
		subobjset->U.Reference.Module = a->U.Reference.Module;
		a->U.ObjectSet.ObjectSet = subobjset;
		break;
	    default:
		MyAbort();
	    }
	}
    }

    /* name types in types, values in types, types of values, types of objects*/
    do {
	redo = 0;
	for (a = *ass; a; a = a->Next) {
	    switch (a->Type) {
	    case eAssignment_Type:
		redo |= NameSubType(ass, Identifier2C(a->Identifier),
		    a->U.Type.Type, a->Module);
		redo |= NameValueOfType(ass, Identifier2C(a->Identifier),
		    a->U.Type.Type, a->Module);
		break;
	    case eAssignment_Value:
		redo |= NameTypeOfValue(ass, Identifier2C(a->Identifier),
		    a->U.Value.Value, a->Module);
		break;
	    case eAssignment_Object:
		redo |= NameSettingsOfObject(ass,
		    Identifier2C(a->Identifier),
		    a->U.Object.Object, a->Module);
		break;
	    }
	}
    } while (redo);

    /* name identification of embedded pdv/character strings */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    NameIdentificationValueOfType(ass, Identifier2C(a->Identifier),
		a->U.Type.Type, a->Module);
    }

    /* mark types that will be automatically tagged */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    MarkTypeForAutotagging(*ass, a->U.Type.Type);
    }

    /* replace components of by corresponding components */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    a->U.Type.Type = RebuildTypeWithoutComponentsOf(*ass,
		a->U.Type.Type);
    }

    /* replace selection types by corresponding component types */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    a->U.Type.Type = RebuildTypeWithoutSelectionType(*ass,
		a->U.Type.Type);
    }

    /* perform automatic tagging */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    AutotagType(*ass, a->U.Type.Type);
    }

    /* perform automatic extension */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    AutoextendType(*ass, a->U.Type.Type);
    }

    /* build tags of Sequence/Set/Choice/InstanceOf */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next)
	{
		if (a->Type == eAssignment_Type)
		{
			switch (a->U.Type.Type->Type)
			{
			case eType_Sequence:
			case eType_Set:
			case eType_Choice:
			case eType_InstanceOf:
				BuildTags(*ass, a->U.Type.Type, a->eDefTagType);
				break;
			}
		}
    }

    /* build tags of other types */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next)
	{
		if (a->Type == eAssignment_Type)
		{
			switch (a->U.Type.Type->Type)
			{
			case eType_Sequence:
			case eType_Set:
			case eType_Choice:
			case eType_InstanceOf:
				break;
			default:
			    BuildTags(*ass, a->U.Type.Type, a->eDefTagType);
				break;
			}
		}
    }

    /* sort set and choice types by tag */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    SortTypeTags(*ass, a->U.Type.Type);
    }

    /* check for duplicate tags */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    CheckTags(*ass, a->U.Type.Type);
    }

    /* derive constraints of referenced types to referencing types */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    BuildConstraints(*ass, a->U.Type.Type);
    }

    /* derive constraints of referenced types to referencing types of values */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Value)
	    BuildConstraints(*ass, GetValue(*ass, a->U.Value.Value)->Type);
    }

    /* examine directives of types */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    BuildDirectives(*ass, a->U.Type.Type, 0);
    }

    /* examine types to be empty/simple/choice of nulls */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    BuildTypeFlags(*ass, a->U.Type.Type);
    }

    /* mark types and values that shall be generated */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next) {
	MarkForGeneration(*ass, mainmodule, a);
    }

    /* sort assignments so that no forward references will be needed */
    SortAssignedTypes(ass);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\genber.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "optcase.h"

// encode
#define LEN_OFFSET_STR2     "nExplTagLenOff"
#define LEN_OFFSET_STR      "nLenOff"

// decode
#define DECODER_NAME        "dd"
#define STREAM_END_NAME     "di"
#define DECODER_NAME2       "pExplTagDec"
#define STREAM_END_NAME2    "pbExplTagDataEnd"

void GenBERFuncSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, TypeFunc_e et, char *encref, char *tagref);
void GenBERStringTableSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref);
void GenBEREncSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, char *encref, char *tagref);
void GenBEREncGenericUnextended(
    AssignmentList_t ass,
    BERTypeInfo_t *info,
    char *valref,
    char *lenref,
    char *encref,
    char *tagref);
void GenBERFuncComponents(AssignmentList_t ass, char *module, uint32_t optindex, ComponentList_t components, char *valref, char *encref, char *oref, TypeFunc_e et, BERTypeInfo_t *, int *);
void GenBERFuncSequenceSetType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et, char *tagref);
void GenBERFuncChoiceType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et, char *tagref);
void GenBERDecSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, char *encref, char *tagref);
void GenBERDecGenericUnextended(
    AssignmentList_t ass,
    BERTypeInfo_t *info,
    char *valref,
    char *lenref,
    char *encref,
    char *tagref);

extern int g_fDecZeroMemory;
extern int g_nDbgModuleName;
extern int g_fCaseBasedOptimizer;
extern int g_fNoAssert;

extern unsigned g_cPDUs;

int IsComponentOpenType(Component_t *com)
{
    if (eType_Open == com->U.NOD.NamedType->Type->Type)
    {
        return 1;
    }
    if (eType_Reference == com->U.NOD.NamedType->Type->Type)
    {
        if (eBERSTIData_Open == com->U.NOD.NamedType->Type->BERTypeInfo.Data)
        {
            return 1;
        }
    }
    return 0;
}

Component_t * FindOpenTypeComponent(ComponentList_t components)
{
    Component_t *com = NULL;
    for (com = components; com; com = com->Next)
    {
        if (IsComponentOpenType(com))
        {
            break;
        }
    }
    return com;
}

/* write header needed for BER encodings */
void
GenBERHeader()
{
//    output("#include \"berfnlib.h\"\n");
}

/* set prototypes and function args of BER functions */
void
GetBERPrototype(Arguments_t *args)
{
    args->enccast = "ASN1encoding_t, ASN1uint32_t, void *";
    args->encfunc = "ASN1encoding_t enc, ASN1uint32_t tag, %s *val";
    args->Pencfunc = "ASN1encoding_t enc, ASN1uint32_t tag, P%s *val";
    args->deccast = "ASN1decoding_t, ASN1uint32_t, void *";
    args->decfunc = "ASN1decoding_t dec, ASN1uint32_t tag, %s *val";
    args->Pdecfunc = "ASN1decoding_t dec, ASN1uint32_t tag, P%s *val";
    args->freecast = "void *";
    args->freefunc = "%s *val";
    args->Pfreefunc = "P%s *val";
    args->cmpcast = "void *, void *";
    args->cmpfunc = "%s *val1, %s *val2";
    args->Pcmpfunc = "P%s *val1, P%s *val2";
}

/* write initialization function needed for BER encodings */
void
GenBERInit(AssignmentList_t ass, char *module)
{
    char *pszRule;
    switch (g_eSubEncodingRule)
    {
    default:
    case eSubEncoding_Basic:
        pszRule = "ASN1_BER_RULE_BER";
        break;
    case eSubEncoding_Canonical:
        pszRule = "ASN1_BER_RULE_CER";
        break;
    case eSubEncoding_Distinguished:
        pszRule = "ASN1_BER_RULE_DER";
        break;
    }
    output("%s = ASN1_CreateModule(0x%x, %s, %s, %d, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x%lx);\n",
        module,
        ASN1_THIS_VERSION,
        pszRule,
        g_fNoAssert ? "ASN1FLAGS_NOASSERT" : "ASN1FLAGS_NONE",
        g_cPDUs,
        g_nDbgModuleName);
}

/* convert a tag to an uint32_t: */
/* bits  0..29: tag value */
/* bits 30..31: tag class */
uint32_t
Tag2uint32(AssignmentList_t ass, Tag_t *tag)
{
    uint32_t tagvalue;
    uint32_t tagclass;

    tagvalue = intx2uint32(&GetValue(ass, tag->Tag)->U.Integer.Value);
    tagclass = tag->Class; /* multiple of 0x40 */
    return (tagclass << 24) | tagvalue;
}

/* generate encoding of a tag */
uint32_t GenBEREncTag(char *pszLenOffName, AssignmentList_t ass, BERTypeInfo_t *info, char *encref, char **tagref)
{
    Tag_t *tag;
    uint32_t tagvalue;
    uint32_t neoc;
    char tagbuf[64];
    int first;

    neoc = 0;
    first = 1;
    if (*tagref)
        strcpy(tagbuf, *tagref);
    else
        strcpy(tagbuf, "0");

    /* we have to examine all tags */
    for (tag = info->Tags; tag; tag = tag ? tag->Next : NULL) {

        /* get value of tag */
        tagvalue = Tag2uint32(ass, tag);
        while (tag && tag->Type == eTagType_Implicit)
            tag = tag->Next;

        /* get tag */
        if (first && *tagref) {
            sprintf(tagbuf, "%s ? %s : 0x%x", *tagref, *tagref, tagvalue);
        } else {
            sprintf(tagbuf, "0x%x", tagvalue);
        }

        /* encode explicit tag */
        if (tag) {
            char szLenOff[24];
            sprintf(&szLenOff[0], "%s%u", pszLenOffName, neoc);
            outputvar("ASN1uint32_t %s;\n", &szLenOff[0]);
            output("if (!ASN1BEREncExplicitTag(%s, %s, &%s))\n", encref, tagbuf, &szLenOff[0]);
            output("return 0;\n");
            neoc++;
            strcpy(tagbuf, "0");
        }
        first = 0;
    }

    /* return last implicit tag */
    *tagref = strdup(tagbuf);

    return neoc;
}

/* generate encoding of end of tag */
void
GenBEREncTagEnd(char *pszLenOffName, uint32_t neoc, char *encref)
{
    while (neoc--)
    {
        char szLenOff[24];
        sprintf(&szLenOff[0], "%s%u", pszLenOffName, neoc);
        outputvar("ASN1uint32_t %s;\n", &szLenOff[0]);
        output("if (!ASN1BEREncEndOfContents(%s, %s))\n", encref, &szLenOff[0]);
        output("return 0;\n");
    }
}

/* generate decoding of a tag */
uint32_t
GenBERDecTag(char *pszDecoderName, char *pszOctetPtrName, AssignmentList_t ass, BERTypeInfo_t *info, char **encref, char **tagref)
{
    Tag_t *tag;
    uint32_t tagvalue;
    uint32_t depth;
    char encbuf[16];
    char tagbuf[64];
    int first;

    depth = 0;
    first = 1;
    if (*tagref)
        strcpy(tagbuf, *tagref);
    else
        strcpy(tagbuf, "0");

    /* we have to examine all tags */
    for (tag = info->Tags; tag; tag = tag ? tag->Next : NULL) {

        /* get value of tag */
        tagvalue = Tag2uint32(ass, tag);
        while (tag && tag->Type == eTagType_Implicit)
            tag = tag->Next;

        /* get tag */
        if (first && *tagref) {
            sprintf(tagbuf, "%s ? %s : 0x%x", *tagref, *tagref, tagvalue);
        } else {
            sprintf(tagbuf, "0x%x", tagvalue);
        }
        
        /* decode explicit tag */
        if (tag)
        {
            char szDecName[24];
            char szPtrName[24];
            sprintf(&szDecName[0], "%s%u", pszDecoderName, depth);
            sprintf(&szPtrName[0], "%s%u", pszOctetPtrName, depth);
            outputvar("ASN1decoding_t %s;\n",&szDecName[0]);
            outputvar("ASN1octet_t *%s;\n", &szPtrName[0]);
            output("if (!ASN1BERDecExplicitTag(%s, %s, &%s, &%s))\n",
                *encref, tagbuf, &szDecName[0], &szPtrName[0]);
            output("return 0;\n");
            *encref = strdup(&szDecName[0]);
            depth++;
            strcpy(tagbuf, "0");
        }
        first = 0;
    }

    /* return last implicit tag */
    *tagref = strdup(tagbuf);

    return depth;
}

/* generate decoding of end of tag */
void
GenBERDecTagEnd(char *pszDecoderName, char *pszOctetPtrName, uint32_t depth, char *encref)
{
    char szDecName[24];
    char szPtrName[24];
    uint32_t i;

    for (i = 0; i < depth; i++)
    {
        sprintf(&szDecName[0], "%s%u", pszDecoderName, depth - i - 1);
        sprintf(&szPtrName[0], "%s%u", pszOctetPtrName, depth - i - 1);
        if (i != depth - 1)
        {
            output("if (!ASN1BERDecEndOfContents(%s%u, %s, %s))\n",
                pszDecoderName, depth - i - 2, &szDecName[0], &szPtrName[0]);
        }
        else
        {
            output("if (!ASN1BERDecEndOfContents(%s, %s, %s))\n",
                encref, &szDecName[0], &szPtrName[0]);
        }
        output("return 0;\n");
    }
}

/* generate function body for a type */
void GenBERFuncType(AssignmentList_t ass, char *module, Assignment_t *at, TypeFunc_e et)
{
    Type_t *type;
    char *encref;
    char *valref;

    /* get some informations */
    type = at->U.Type.Type;
    switch (et) {
    case eStringTable:
        valref = encref = "";
        break;
    case eEncode:
        encref = "enc";
        valref = "val";
        break;
    case eDecode:
        encref = "dec";
        valref = "val";
        break;
    }

    /* function body */
    switch (type->Type) {
    case eType_Boolean:
    case eType_Integer:
    case eType_Enumerated:
    case eType_Real:
    case eType_BitString:
    case eType_OctetString:
    case eType_UTF8String:
    case eType_Null:
    case eType_EmbeddedPdv:
    case eType_External:
    case eType_ObjectIdentifier:
    case eType_BMPString:
    case eType_GeneralString:
    case eType_GraphicString:
    case eType_IA5String:
    case eType_ISO646String:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_UniversalString:
    case eType_VideotexString:
    case eType_VisibleString:
    case eType_CharacterString:
    case eType_GeneralizedTime:
    case eType_UTCTime:
    case eType_ObjectDescriptor:
    case eType_RestrictedString:
    case eType_Open:
    case eType_Reference:
    case eType_SequenceOf:
    case eType_SetOf:
        GenBERFuncSimpleType(ass, &type->BERTypeInfo, Dereference(valref), et, encref, "tag");
        break;

    case eType_Sequence:
    case eType_Set:
    case eType_InstanceOf:
        GenBERFuncSequenceSetType(ass, module, at, valref, encref, et, "tag");
        break;

    case eType_Choice:
        GenBERFuncChoiceType(ass, module, at, valref, encref, et, "tag");
        break;

    case eType_Selection:
    case eType_Undefined:
        MyAbort();
        /*NOTREACHED*/
    }
}

/* generate function body for components */
void GenBERFuncComponents(AssignmentList_t ass, char *module, uint32_t optindex, ComponentList_t components, char *valref, char *encref, char *oref, TypeFunc_e et, BERTypeInfo_t *info, int *pfContainOpenTypeComWithDefTags)
{
    BERSTIData_e data = info->Data;
    Component_t *com;
    NamedType_t *namedType;
    char *ide;
    int conditional, inextension;
    uint32_t flg;
    Tag_t *tags;
    unsigned int first_tag, last_tag;
    int fDefTags;
    int fOpenTypeComponent;
    char valbuf[256];
    char typebuf[256];

    *pfContainOpenTypeComWithDefTags = 0;

    /* emit components */
    inextension = 0;
    for (com = components; com; com = com->Next)
    {
        fDefTags = 0; // safety net
        fOpenTypeComponent = 0; // safety net

        /* check for extension marker */
        if (com->Type == eComponent_ExtensionMarker) {
            inextension = 1;

            /* update index into optional field for sequence/set */
            if (data != eBERSTIData_Choice)
                optindex = (optindex + 7) & ~7;
            continue;
        }

        /* get some information */
        namedType = com->U.NOD.NamedType;
        ide = Identifier2C(namedType->Identifier);

        /* check if optional/default component is present or choice is */
        /* selected*/
        conditional = 0;
        switch (et) {
        case eStringTable:
            break;
        case eEncode:
            if (data == eBERSTIData_Choice) {
                output("case %d:\n", optindex);
                conditional = 1;
                optindex++;
            } else {
                if (com->Type == eComponent_Optional ||
                    com->Type == eComponent_Default ||
                    inextension) {
                    output("if (%s[%u] & 0x%x) {\n", oref,
                        optindex / 8, 0x80 >> (optindex & 7));
                    conditional = 1;
                    optindex++;
                }
            }
            break;
        case eDecode:
            if (data == eBERSTIData_Sequence &&
                com->Type != eComponent_Optional &&
                com->Type != eComponent_Default &&
                !inextension)
                break;

            fOpenTypeComponent = IsComponentOpenType(com);
            if (fOpenTypeComponent)
            {
                const unsigned int c_nDefFirstTag = 0x80000001;
                const unsigned int c_nDefLastTag  = 0x8000001f;
                unsigned int nTag = c_nDefFirstTag;
                tags = com->U.NOD.NamedType->Type->FirstTags;
                first_tag = Tag2uint32(ass, com->U.NOD.NamedType->Type->FirstTags);
                fDefTags = 1; // initial value
                while (tags->Next)
                {
                    fDefTags = fDefTags && (Tag2uint32(ass, tags) == nTag++);
                    tags = tags->Next;
                }
                last_tag = Tag2uint32(ass, tags);
                fDefTags = fDefTags && (c_nDefFirstTag == first_tag) && (c_nDefLastTag == last_tag);
                *pfContainOpenTypeComWithDefTags = *pfContainOpenTypeComWithDefTags || fDefTags;
            }
            if (data == eBERSTIData_Sequence)
            {
                if (fOpenTypeComponent)
                {
                    outputvar("ASN1uint32_t t;\n");
                    output("if (ASN1BERDecPeekTag(%s, &t)) {\n", encref);
                }
                else
                {
                    outputvar("ASN1uint32_t t;\n");
                    output("ASN1BERDecPeekTag(%s, &t);\n", encref);
                }
                if (! fDefTags)
                {
                    output("if (");
                }
                flg = 0;
            }
            if (eBERSTIData_Sequence == data && fDefTags && fOpenTypeComponent)
            {
            #if 0
                if (first_tag == last_tag)
                {
                    output("0x%x == t", first_tag);
                }
                else
                {
                    output("0x%x <= t && t <= 0x%x", first_tag, last_tag);
                }
            #endif
                conditional = 1;
            }
            else
            if (eBERSTIData_Set == data && fDefTags && fOpenTypeComponent)
            {
                output("default:\n");
            #if 1
                if (info->Flags & eTypeFlags_ExtensionMarker)
                {
                    output("#error \"Untagged open type cannot be in the SET construct with an extension mark.\nPlease manually fix the source code.\"");
                    output("ASSERT(0); /* Untagged open type cannot be in the SET construct with an extension mark */\n");
                    output("if (1) {\n");
                }
            #else
                if (first_tag == last_tag)
                {
                    output("if (0x%x == t) {\n", first_tag);
                }
                else
                {
                    output("if (0x%x <= t && t <= 0x%x) {\n", first_tag, last_tag);
                }
            #endif
                conditional = 1;
            }
            else
            if (eBERSTIData_Choice == data && fDefTags && fOpenTypeComponent)
            {
                output("default:\n");
            #if 1
                if (info->Flags & eTypeFlags_ExtensionMarker)
                {
                    output("#error \"Untagged open type cannot be in the CHOICE construct with an extension mark.\nPlease manually fix the source code.\"");
                    output("ASSERT(0); /* Untagged open type cannot be in the CHOICE construct with an extension mark */\n");
                    output("if (1) {\n");
                }
            #else
                if (first_tag == last_tag)
                {
                    output("if (0x%x == t) {\n", first_tag);
                }
                else
                {
                    output("if (0x%x <= t && t <= 0x%x) {\n", first_tag, last_tag);
                }
            #endif
                conditional = 1;
            }
            else
            {
                for (tags = com->U.NOD.NamedType->Type->FirstTags; tags; tags = tags->Next)
                {
                    switch (data)
                    {
                    case eBERSTIData_Choice:
                        output("case 0x%x:\n", Tag2uint32(ass, tags));
                        break;
                    case eBERSTIData_Set:
                        output("case 0x%x:\n", Tag2uint32(ass, tags));
                        break;
                    case eBERSTIData_Sequence:
                        if (flg)
                            output(" || ");
                        output("t == 0x%x", Tag2uint32(ass, tags));
                        flg = 1;
                        break;
                    default:
                        if (flg)
                            output(" || ");
                        output("t == 0x%x", Tag2uint32(ass, tags));
                        flg = 1;
                        break;
                    }
                }
            }
            if (data == eBERSTIData_Choice) {
                output("(%s)->choice = %d;\n", valref, optindex);
                conditional = 1;
                optindex++;
                break;
            } else {
                if (data == eBERSTIData_Sequence)
                {
                    if (! fDefTags)
                    {
                        output(") {\n");
                    }
                }
                if (com->Type == eComponent_Optional ||
                    com->Type == eComponent_Default ||
                    inextension) {
                    output("%s[%u] |= 0x%x;\n", oref,
                        optindex / 8, 0x80 >> (optindex & 7));
                    optindex++;
                }
                conditional = 1;
            }
            break;
        }

        /* dereference pointer if pointer directive used */
        if (data == eBERSTIData_Choice) {
            if (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer)
                sprintf(valbuf, "*(%s)->u.%s", valref, ide);
            else
                sprintf(valbuf, "(%s)->u.%s", valref, ide);
        } else {
            if (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer)
                sprintf(valbuf, "*(%s)->%s", valref, ide);
            else
                sprintf(valbuf, "(%s)->%s", valref, ide);
        }

        /* allocate memory if decoding and pointer directive used */
        if (et == eDecode &&
            (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer) &&
            !(GetType(ass, namedType->Type)->Flags & eTypeFlags_Null)) {
            sprintf(typebuf, "%s *",
                GetTypeName(ass, namedType->Type));
            output("if (!(%s = (%s)ASN1DecAlloc(%s, sizeof(%s))))\n",
                Reference(valbuf), typebuf, encref, valbuf);
            output("return 0;\n");
        }

        /* handle subtype value */
        GenBERFuncSimpleType(ass, &namedType->Type->BERTypeInfo,
            valbuf, et, encref, NULL);

        if (eDecode == et && fOpenTypeComponent)
        {
            if (eBERSTIData_Set == data && fDefTags)
            {
                if (info->Flags & eTypeFlags_ExtensionMarker)
                {
                    output("} else {\n");
                    output("if (!ASN1BERDecSkip(%s))\n", encref);
                    output("return 0;\n");
                    output("}\n");
                }
            }
            else
            if (eBERSTIData_Sequence == data)
            {
                if (! fDefTags)
                {
                    output("}\n");
                }
            }
        }
        /* end of check for presence of optional/default component */
        if (data == eBERSTIData_Set && et == eDecode ||
            data == eBERSTIData_Choice)
        {
            if (conditional)
                output("break;\n");
        }
        else
        {
            if (conditional)
                output("}\n");
        }
    }
}

/* generate function body for sequence/set type */
void
GenBERFuncSequenceSetType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et, char *tagref)
{
    Type_t *type = at->U.Type.Type;
    BERTypeInfo_t *info = &type->BERTypeInfo;
    uint32_t optionals, extensions;
    ComponentList_t components;
    char *oldencref;
    char *oldencref2;
    uint32_t neoc, depth;
    int fContainOpenTypeComWithDefTags = 0;
    char obuf[256];
    
    optionals = type->U.SSC.Optionals;
    extensions = type->U.SSC.Extensions;
    components = type->U.SSC.Components;

    /* handle tag and length */
    switch (et) {
    case eEncode:
        neoc = GenBEREncTag(LEN_OFFSET_STR2, ass, info, encref, &tagref);
        outputvar("ASN1uint32_t %s;\n", LEN_OFFSET_STR);
        output("if (!ASN1BEREncExplicitTag(%s, %s, &%s))\n", encref, tagref, LEN_OFFSET_STR);
        output("return 0;\n");
        // neoc++;
        break;
    case eDecode:
        outputvar("ASN1decoding_t dd;\n");
        outputvar("ASN1octet_t *di;\n");
        oldencref = encref;
        depth = GenBERDecTag(DECODER_NAME2, STREAM_END_NAME2, ass, info, &encref, &tagref);
        oldencref2 = encref;
        output("if (!ASN1BERDecExplicitTag(%s, %s, &dd, &di))\n",
            encref, tagref);
        output("return 0;\n");
        encref = "dd";
        if (optionals || extensions)
            output("ZeroMemory((%s)->o, %d);\n", valref,
                (optionals + 7) / 8 + (extensions + 7) / 8);
        break;
    }

    /* set/clear missing bits in optional/default bit field */
    GenFuncSequenceSetOptionals(ass, valref, components, optionals, extensions,
        obuf, et);

    /* create switch statement */
    if (et == eDecode) {
        switch (info->Data) {
        case eBERSTIData_Set:
            outputvar("ASN1uint32_t t;\n");
            output("while (ASN1BERDecNotEndOfContents(%s, di)) {\n", encref);
            output("if (!ASN1BERDecPeekTag(%s, &t))\n", encref);
            output("return 0;\n");
            output("switch (t) {\n");
            break;
        }
    }

    /* emit components */
    GenBERFuncComponents(ass, module, 0, components,
        valref, encref, obuf, et, info, &fContainOpenTypeComWithDefTags);

    /* end of switch statement */
    if (et == eDecode) {
        switch (info->Data) {
        case eBERSTIData_Set:
            // if (NULL == FindOpenTypeComponent(components))
            if (! fContainOpenTypeComWithDefTags)
            {
                output("default:\n");
                if (info->Flags & eTypeFlags_ExtensionMarker) {
                    output("if (!ASN1BERDecSkip(%s))\n", encref);
                    output("return 0;\n");
                    output("break;\n");
                } else {
                    output("ASN1DecSetError(%s, ASN1_ERR_CORRUPT);\n", encref);
                    output("return 0;\n");
                }
            }
            output("}\n");
            output("}\n");
            break;
        }
    }

    /* some user-friendly assignments for non-present optional/default */
    /* components */
    GenFuncSequenceSetDefaults(ass, valref, components, obuf, et);

    /* generate end of contents */
    switch (et) {
    case eEncode:
        /* encode the end-of-contents octets */
        output("if (!ASN1BEREncEndOfContents(%s, %s))\n", encref, LEN_OFFSET_STR);
        output("return 0;\n");

        GenBEREncTagEnd(LEN_OFFSET_STR2, neoc, encref);
        break;
    case eDecode:
        if ((info->Flags & eTypeFlags_ExtensionMarker) &&
            info->Data != eBERSTIData_Set) {
            output("while (ASN1BERDecNotEndOfContents(%s, di)) {\n", encref);
            output("if (!ASN1BERDecSkip(%s))\n", encref);
            output("return 0;\n");
            output("}\n");
        }
        output("if (!ASN1BERDecEndOfContents(%s, dd, di))\n", oldencref2);
        output("return 0;\n");
        GenBERDecTagEnd(DECODER_NAME2, STREAM_END_NAME2, depth, oldencref);
        break;
    }
}

/* generate function body for choice type */
// lonchanc: we should re-visit the work about ASN1_CHOICE_BASE.
// the change for BER is not complete!!! BUGBUG
void
GenBERFuncChoiceType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et, char *tagref)
{
    Type_t *type;
    BERTypeInfo_t *info;
    Component_t *components, *c;
    uint32_t neoc, depth;
    char *oldencref;
    uint32_t ncomponents;
    int fContainOpenTypeComWithDefTags = 0;

    /* get some informations */
    type = at->U.Type.Type;
    info = &type->BERTypeInfo;
    components = type->U.SSC.Components;
    for (c = components, ncomponents = 0; c; c = c->Next) {
        switch (c->Type) {
        case eComponent_Normal:
            ncomponents++;
            break;
        }
    }

    /* encode explicit tags */
    switch (et) {
    case eEncode:
        neoc = GenBEREncTag(LEN_OFFSET_STR2, ass, info, encref, &tagref);
        break;
    case eDecode:
        oldencref = encref;
        depth = GenBERDecTag(DECODER_NAME2, STREAM_END_NAME2, ass, info, &encref, &tagref);
        break;
    }

    /* create switch statement */
    switch (et) {
    case eStringTable:
        break;
    case eEncode:
        output("switch ((%s)->choice) {\n", valref);
        break;
    case eDecode:
        outputvar("ASN1uint32_t t;\n");
        output("if (!ASN1BERDecPeekTag(%s, &t))\n", encref);
        output("return 0;\n");
        output("switch (t) {\n");
        break;
    }

    /* generate components */
    GenBERFuncComponents(ass, module, ASN1_CHOICE_BASE, components,
        valref, encref, NULL, et, info, &fContainOpenTypeComWithDefTags);

    /* end of switch statement */
    switch (et) {
    case eStringTable:
        break;
    case eEncode:
        output("}\n");
        break;
    case eDecode:
        if (fContainOpenTypeComWithDefTags)
        {
            if (info->Flags & eTypeFlags_ExtensionMarker)
            {
                output("} else {\n");
                output("(%s)->choice = %d;\n", valref, ASN1_CHOICE_BASE + ncomponents); /* unknown extens.*/
                output("if (!ASN1BERDecSkip(%s))\n", encref);
                output("return 0;\n");
                output("}\n");
                output("break;\n");
            }
        }
        else
        {
            output("default:\n");
            if (info->Flags & eTypeFlags_ExtensionMarker) {
                output("(%s)->choice = %d;\n", valref, ASN1_CHOICE_BASE + ncomponents); /* unknown extens.*/
                output("if (!ASN1BERDecSkip(%s))\n", encref);
                output("return 0;\n");
                output("break;\n");
            } else {
                output("ASN1DecSetError(%s, ASN1_ERR_CORRUPT);\n", encref);
                output("return 0;\n");
            }
        }
        output("}\n");
        break;
    }

    /* generate end of contents */
    switch (et) {
    case eEncode:
        GenBEREncTagEnd(LEN_OFFSET_STR2, neoc, encref);
        break;
    case eDecode:
        GenBERDecTagEnd(DECODER_NAME2, STREAM_END_NAME2, depth, oldencref);
    }
}

/* generate function body for simple type */
void
GenBERFuncSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, TypeFunc_e et, char *encref, char *tagref)
{
    switch (et) {
    case eStringTable:
        break;
    case eEncode:
        GenBEREncSimpleType(ass, info, valref, encref, tagref);
        break;
    case eDecode:
        GenBERDecSimpleType(ass, info, valref, encref, tagref);
        break;
    }
}

/* generate encoding statements for a simple value */
void
GenBEREncSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, char *encref, char *tagref)
{
    char *lenref;
    char lenbuf[256], valbuf[256];
    BERTypeInfo_t inf;

    inf = *info;

    /* examine type for special handling */
    switch (inf.Data) {
    case eBERSTIData_BitString:
    case eBERSTIData_RZBBitString:
    case eBERSTIData_OctetString:
    case eBERSTIData_UTF8String:
    case eBERSTIData_String:

        /* length and value of bit string, octet string and string */
        if (*valref != '*')
        {
            sprintf(lenbuf, "(%s).length", valref);
            sprintf(valbuf, "(%s).value", valref);
        }
        else
        {
            sprintf(lenbuf, "(%s)->length", Reference(valref));
            sprintf(valbuf, "(%s)->value", Reference(valref));
        }
        lenref = lenbuf;
        valref = valbuf;

        /* check for remove-zero-bits bit string */
        if (inf.Data == eBERSTIData_RZBBitString) {
            outputvar("ASN1uint32_t r;\n");
            output("r = %s;\n", lenref);
            output("ASN1BEREncRemoveZeroBits(&r, %s);\n",
                valref);
            lenref = "r";
        }
        break;

    case eBERSTIData_SequenceOf:
    case eBERSTIData_SetOf:

        if (inf.Rules & eTypeRules_PointerArrayMask)
        {
            /* length and value of sequence of/set of value with */
            /* length-pointer representation */
            sprintf(lenbuf, "(%s)->count", Reference(valref));
            sprintf(valbuf, "(%s)->value", Reference(valref));
            lenref = lenbuf;
            valref = valbuf;
        }
        else
        if (inf.Rules & eTypeRules_LinkedListMask)
        {
            lenref = "t";
        }
        else
        {
            MyAbort();
        }
        break;

    case eBERSTIData_ZeroString:

        /* length of a zero-terminated string value */
        outputvar("ASN1uint32_t t;\n");
        output("t = lstrlenA(%s);\n", valref);
        lenref = "t";
        break;

    case eBERSTIData_Boolean:

        if (g_fCaseBasedOptimizer)
        {
            if (BerOptCase_IsBoolean(&inf))
            {
                break;
            }
        }

        /* value of a boolean value */
        sprintf(valbuf, "(%s) ? 255 : 0", valref);
        valref = valbuf;
        inf.Data = eBERSTIData_Unsigned;
        break;

    default:

        /* other values have no additional length */
        lenref = NULL;
        break;
    }

    /* generate the encoding of the value */
    GenBEREncGenericUnextended(ass, &inf, valref, lenref, encref, tagref);
}

/* generate encoding statements for a simple value (after some special */
/* handling has been done) */
void
GenBEREncGenericUnextended(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, char *lenref, char *encref, char *tagref)
{
    uint32_t neoc;
    char *p;
    char valbuf[256];

    /* encode tags */
    neoc = GenBEREncTag(LEN_OFFSET_STR, ass, info, encref, &tagref);

    /* encode length and value */
    switch (info->Data) {
    case eBERSTIData_Null:

        /* encode null value */
        output("if (!ASN1BEREncNull(%s, %s))\n", encref, tagref);
        output("return 0;\n");
        break;

    case eBERSTIData_Unsigned:
    case eBERSTIData_Integer:

        /* encode integer value; check for intx_t representation */
        if (info->NOctets) {
            if (info->Data == eBERSTIData_Unsigned) {
                output("if (!ASN1BEREncU32(%s, %s, %s))\n",
                    encref, tagref, valref);
            } else {
                output("if (!ASN1BEREncS32(%s, %s, %s))\n",
                    encref, tagref, valref);
            }
            output("return 0;\n");
        } else {
            output("if (!ASN1BEREncSX(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
            output("return 0;\n");
        }
        break;

    case eBERSTIData_Real:

        /* encode real value; check for real_t representation */
        if (info->NOctets)
            output("if (!ASN1BEREncDouble(%s, %s, %s))\n",
                encref, tagref, valref);
        else
            output("if (!ASN1BEREncReal(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_BitString:
    case eBERSTIData_RZBBitString:

        /* encode bit string value */
        output("if (!ASN1%cEREncBitString(%s, %s, %s, %s))\n",
            g_eSubEncodingRule, encref, tagref, lenref, valref);
        output("return 0;\n");
        break;

    case eBERSTIData_OctetString:

        /* encode octet string value */
        output("if (!ASN1%cEREncOctetString(%s, %s, %s, %s))\n",
            g_eSubEncodingRule, encref, tagref, lenref, valref);
        output("return 0;\n");
        break;

    case eBERSTIData_UTF8String:

        /* encode octet string value */
        output("if (!ASN1%cEREncUTF8String(%s, %s, %s, %s))\n",
            g_eSubEncodingRule, encref, tagref, lenref, valref);
        output("return 0;\n");
        break;

    case eBERSTIData_SetOf:

        /* encoding of a set of value */
        if (eSubEncoding_Canonical      == g_eSubEncodingRule ||
            eSubEncoding_Distinguished  == g_eSubEncodingRule)
        {
            /* encoding of a set of value for DER/CER */

            /* lists will require an additional iterator */
            if (info->Rules &
                (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList))
            {
                outputvar("P%s f;\n", info->Identifier);
            }

            /* encode the tag and infinite-length first */
            outputvar("ASN1uint32_t %s;\n", LEN_OFFSET_STR);
            output("if (!ASN1BEREncExplicitTag(%s, %s, &%s))\n", encref, tagref, LEN_OFFSET_STR);
            output("return 0;\n");

            /* create the SetOf block */
            outputvar("void *pBlk;\n");
            output("if (!ASN1DEREncBeginBlk(%s, ASN1_DER_SET_OF_BLOCK, &pBlk))\n", encref);
            output("return 0;\n");

            /* encode all elements */
            /* get the name of the elements */
            /* advance the iterator for lists */
            if (info->Rules & eTypeRules_PointerArrayMask)
            {
                outputvar("ASN1uint32_t i;\n");
                output("for (i = 0; i < %s; i++) {\n", lenref);
                sprintf(valbuf, "(%s)[i]", valref);
            }
            else if (info->Rules & eTypeRules_LinkedListMask)
            {
                output("for (f = %s; f; f = f->next) {\n", valref);
                sprintf(valbuf, "f->value");
            }
            else
            {
                MyAbort();
            }

            /* create the secondary encoder structure */
            outputvar("ASN1encoding_t enc2;\n");
            output("if (!ASN1DEREncNewBlkElement(pBlk, &enc2))\n");
            output("return 0;\n");

            /* encode the element */
            GenBERFuncSimpleType(ass, &info->SubType->BERTypeInfo, valbuf,
                eEncode, "enc2", NULL);

            /* create the secondary encoder structure */
            output("if (!ASN1DEREncFlushBlkElement(pBlk))\n");
            output("return 0;\n");

            /* end of loop */
            output("}\n");

            /* create the secondary encoder structure */
            output("if (!ASN1DEREncEndBlk(pBlk))\n");
            output("return 0;\n");

            /* encode the end-of-contents octets */
            output("if (!ASN1BEREncEndOfContents(%s, %s))\n", encref, LEN_OFFSET_STR);
            output("return 0;\n");
            break;
        }

        /*FALLTHROUGH*/

    case eBERSTIData_SequenceOf:

        /* encoding of a sequence of value */

        /* lists will require an additional iterator */
        if (info->Rules & eTypeRules_LinkedListMask)
        {
            outputvar("P%s f;\n", info->Identifier);
        }

        /* encode the tag and infinite-length first */
        outputvar("ASN1uint32_t %s;\n", LEN_OFFSET_STR);
        output("if (!ASN1BEREncExplicitTag(%s, %s, &%s))\n", encref, tagref, LEN_OFFSET_STR);
        output("return 0;\n");

        /* encode all elements */
        /* get the name of the elements */
        /* advance the iterator for lists */
        if (info->Rules & eTypeRules_PointerArrayMask)
        {
            outputvar("ASN1uint32_t i;\n");
            output("for (i = 0; i < %s; i++) {\n", lenref);
            sprintf(valbuf, "(%s)[i]", valref);
        }
        else if (info->Rules & eTypeRules_LinkedListMask)
        {
            output("for (f = %s; f; f = f->next) {\n", valref);
            sprintf(valbuf, "f->value");
        }
        else
		{
            MyAbort();
		}

        /* encode the element */
        GenBERFuncSimpleType(ass, &info->SubType->BERTypeInfo, valbuf,
            eEncode, encref, NULL);

        /* end of loop */
        output("}\n");

        /* encode the end-of-contents octets */
        output("if (!ASN1BEREncEndOfContents(%s, %s))\n", encref, LEN_OFFSET_STR);
        output("return 0;\n");
        break;

    case eBERSTIData_ObjectIdentifier:

        /* encode an object identifier value */
        if (info->pPrivateDirectives->fOidArray  || g_fOidArray)
        {
            output("if (!ASN1BEREncObjectIdentifier2(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        }
        else
        {
            output("if (!ASN1BEREncObjectIdentifier(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        }
        output("return 0;\n");
        break;

    case eBERSTIData_ObjectIdEncoded:

        /* encode an encoded object identifier value */
        output("if (!ASN1BEREncEoid(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_String:
    case eBERSTIData_ZeroString:

        /* encode a string value */
        if (info->NOctets == 1) {
            p = "Char";
        } else if (info->NOctets == 2) {
            p = "Char16";
        } else if (info->NOctets == 4) {
            p = "Char32";
        } else
            MyAbort();
        output("if (!ASN1%cEREnc%sString(%s, %s, %s, %s))\n",
            g_eSubEncodingRule, p, encref, tagref, lenref, valref);
        output("return 0;\n");
        break;

    case eBERSTIData_External:

        /* encode an external value */
        output("if (!ASN1BEREncExternal(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_EmbeddedPdv:

        /* encode an embedded pdv value */
        output("if (!ASN1BEREncEmbeddedPdv(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_MultibyteString:

        /* encode a multibyte string value */
        if (info->Rules & eTypeRules_LengthPointer)
        {
            output("if (!ASN1%cEREncMultibyteString(%s, %s, %s))\n",
                g_eSubEncodingRule, encref, tagref, Reference(valref));
        }
        else
        {
            output("if (!ASN1%cEREncZeroMultibyteString(%s, %s, %s))\n",
                g_eSubEncodingRule, encref, tagref, valref);
        }
        output("return 0;\n");
        break;

    case eBERSTIData_UnrestrictedString:

        /* encode an character string value */
        output("if (!ASN1BEREncCharacterString(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_GeneralizedTime:

        /* encode a generalized time value */
        output("if (!ASN1%cEREncGeneralizedTime(%s, %s, %s))\n",
            g_eSubEncodingRule, encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_UTCTime:

        /* encode a utc time value */
        output("if (!ASN1%cEREncUTCTime(%s, %s, %s))\n",
            g_eSubEncodingRule, encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_Open:
        
        /* encode an open type value */
        output("if (!ASN1BEREncOpenType(%s, %s))\n",
            encref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_Reference:

        /* call other encoding function for reference types */
        output("if (!ASN1Enc_%s(%s, %s, %s))\n",
            Identifier2C(info->SubIdentifier),
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_Boolean:
        if (g_fCaseBasedOptimizer)
        {
            output("if (!ASN1BEREncBool(%s, %s, %s))\n", encref, tagref, valref);
            output("return 0;\n");
        }
        break;
    }

    /* encode the end of tag octets */
    GenBEREncTagEnd(LEN_OFFSET_STR, neoc, encref);
}

/* generate decoding statements for a simple value */
void
GenBERDecSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, char *encref, char *tagref)
{
    char valbuf[256], lenbuf[256];
    char *lenref;
    BERTypeInfo_t inf;

    inf = *info;

    /* examine type for special handling */
    switch (inf.Data) {
    case eBERSTIData_SequenceOf:
    case eBERSTIData_SetOf:

        if (inf.Rules & eTypeRules_PointerArrayMask)
        {
            /* length and value of sequence of/set of value with */
            /* length-pointer representation */
            sprintf(lenbuf, "(%s)->count", Reference(valref));
            sprintf(valbuf, "(%s)->value", Reference(valref));
            lenref = lenbuf;
            valref = valbuf;
        }
        else
        if (inf.Rules & eTypeRules_LinkedListMask)
        {
            /* use a loop for sequence of/set of value with */
            /* list representation */
            outputvar("P%s *f;\n", inf.Identifier);
            lenref = NULL;
        }
        else
        {
            MyAbort();
        }
        break;

    case eBERSTIData_Boolean:

        if (g_fCaseBasedOptimizer)
        {
            if (BerOptCase_IsBoolean(&inf))
            {
                break;
            }
        }

        /* boolean value */
        inf.Data = eBERSTIData_Unsigned;
        lenref = NULL;
        break;

    default:

        /* other values have no additional length */
        lenref = NULL;
        break;
    }

    /* generate the decoding of the value */
    GenBERDecGenericUnextended(ass, &inf, valref, lenref, encref, tagref);
}

/* generate decoding statements for a simple value (after some special */
/* handling has been done) */
void
GenBERDecGenericUnextended(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, char *lenref, char *encref, char *tagref)
{
    uint32_t depth;
    char *p;
    char *oldencref;
    char *oldencref2;
    char valbuf[256];

    /* decode tags */
    oldencref = encref;
    depth = GenBERDecTag(DECODER_NAME, STREAM_END_NAME, ass, info, &encref, &tagref);

    /* decode length and value */
    switch (info->Data) {
    case eBERSTIData_Null:

        /* decode null value */
        output("if (!ASN1BERDecNull(%s, %s))\n", encref, tagref);
        output("return 0;\n");
        break;

    case eBERSTIData_Integer:

        /* decode integer value; check for intx_t representation */
        if (!info->NOctets) {
            output("if (!ASN1BERDecSXVal(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
            output("return 0;\n");
        } else {
            output("if (!ASN1BERDecS%dVal(%s, %s, %s))\n",
                info->NOctets * 8, encref, tagref, Reference(valref));
            output("return 0;\n");
        }
        break;

    case eBERSTIData_Unsigned:
        if (!info->NOctets) {
            output("if (!ASN1BERDecSXVal(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
            output("return 0;\n");
        } else {
            unsigned long cBits = info->NOctets * 8;
            if (32 == cBits)
            {
                output("if (!ASN1BERDecU32Val(%s, %s, (ASN1uint32_t *) %s))\n",
                    encref, tagref, Reference(valref));
            }
            else
            {
                output("if (!ASN1BERDecU%uVal(%s, %s, %s))\n",
                    cBits, encref, tagref, Reference(valref));
            }
            output("return 0;\n");
        }
        break;

    case eBERSTIData_Real:

        /* decode real value; check for real_t representation */
        if (info->NOctets)
            output("if (!ASN1BERDecDouble(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        else
            output("if (!ASN1BERDecReal(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_BitString:
    case eBERSTIData_RZBBitString:

        /* decode bit string value */
        output("if (!ASN1BERDecBitString%s(%s, %s, %s))\n",
            info->pPrivateDirectives->fNoMemCopy ? "2" : "",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_OctetString:

        /* decode octet string value */
        output("if (!ASN1BERDecOctetString%s(%s, %s, %s))\n",
            info->pPrivateDirectives->fNoMemCopy ? "2" : "",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_UTF8String:

        /* decode octet string value */
        output("if (!ASN1BERDecUTF8String(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_SetOf:
    case eBERSTIData_SequenceOf:

        /* encoding of a set of/sequence of value */
        outputvar("ASN1decoding_t dd;\n");
        outputvar("ASN1octet_t *di;\n");

        /* decode the tag and length first */
        output("if (!ASN1BERDecExplicitTag(%s, %s, &dd, &di))\n",
            encref, tagref);
        output("return 0;\n");

        oldencref2 = encref;
        encref = "dd";
        outputvar("ASN1uint32_t t;\n");
        if (info->Rules & eTypeRules_LengthPointer)
		{
            /* get length and value of sequence of/set of value with */
            /* length-pointer representation */
            outputvar("ASN1uint32_t n;\n");
            output("%s = n = 0;\n", lenref);
            output("%s = NULL;\n", valref);
        }
		else
        if (info->Rules & eTypeRules_FixedArray)
		{
            /* get length and value of sequence of/set of value with */
			/* fixed-array representation*/
            output("%s = 0;\n", lenref);
		}
		else
		if (info->Rules & eTypeRules_SinglyLinkedList)
		{
            /* use additional iterator for sequence of/set of value with */
            /* singly-linked-list representation */
            outputvar("P%s *f;\n", info->Identifier);
            output("f = %s;\n", Reference(valref));

        }
		else
		if (info->Rules & eTypeRules_DoublyLinkedList)
		{
            /* use additional iterator and iterator pointer for sequence of/ */
            /* set of value with doubly-linked-list representation */
            outputvar("P%s *f;\n", info->Identifier);
            outputvar("%s b;\n", info->Identifier);
            output("f = %s;\n", Reference(valref));
            output("b = NULL;\n");
        }

        /* decode while not constructed is not empty */
        output("while (ASN1BERDecNotEndOfContents(%s, di)) {\n", encref);

        /* get next tag */
        output("if (!ASN1BERDecPeekTag(%s, &t))\n", encref);
        output("return 0;\n");

        if (info->Rules & eTypeRules_PointerArrayMask)
        {
            if (info->Rules & eTypeRules_LengthPointer)
            {
                /* resize allocated array if it is too small */
                output("if (%s >= n) {\n", lenref);
                output("n = n ? (n << 1) : 16;\n");
                output("if (!(%s = (%s *)ASN1DecRealloc(%s, %s, n * sizeof(%s))))\n",
                    valref, GetTypeName(ass, info->SubType), encref,
                    valref, Dereference(valref));
                output("return 0;\n");
                output("}\n");
            }
            /* get the name of the value */
            sprintf(valbuf, "(%s)[%s]", valref, lenref);
        }
        else
        if (info->Rules & eTypeRules_LinkedListMask)
        {
            /* allocate one element */
            output("if (!(*f = (P%s)ASN1DecAlloc(%s, sizeof(**f))))\n",
                info->Identifier, encref);
            output("return 0;\n");

            /* get the name of the value */
            sprintf(valbuf, "(*f)->value");
        }

        /* decode the element */
        GenBERFuncSimpleType(ass, &info->SubType->BERTypeInfo, valbuf,
            eDecode, encref, NULL);

        if (info->Rules &
            (eTypeRules_LengthPointer | eTypeRules_FixedArray)) {

            /* advance the length of the array contents */
            output("(%s)++;\n", lenref);

        } else if (info->Rules & eTypeRules_SinglyLinkedList) {

            /* adjust the pointer for the next element */
            output("f = &(*f)->next;\n");

        } else if (info->Rules & eTypeRules_DoublyLinkedList) {

            /* adjust the pointer for the next element and */
            /* update the back pointer */
            output("(*f)->prev = b;\n");
            output("b = *f;\n");
            output("f = &b->next;\n");
        }

        /* end of loop */
        output("}\n");

        if (info->Rules & eTypeRules_LengthPointer)
        {
        #if 0 // lonchanc: no need to shrink the memory thru realloc
            // lonchanc: no need to allocate memory for eTypeRules_FixedArray
            /* resize allocated array to real size */
            output("if (n != %s) {\n", lenref);
            output("if (!(%s = (%s *)ASN1DecRealloc(%s, %s, %s * sizeof(%s))))\n",
                valref, GetTypeName(ass, info->SubType), encref,
                valref, lenref, Dereference(valref));
            output("return 0;\n");
            output("}\n");
        #endif // 0
        }
        else
        if (info->Rules & eTypeRules_LinkedListMask)
        {
            /* terminate the list */
            output("*f = NULL;\n");
        }

        /* decode end-of-contents */
        output("if (!ASN1BERDecEndOfContents(%s, dd, di))\n", oldencref2);
        output("return 0;\n");
        break;

    case eBERSTIData_ObjectIdentifier:

        if (info->pPrivateDirectives->fOidArray || g_fOidArray)
        {
            /* decode an object identifier value */
            output("if (!ASN1BERDecObjectIdentifier2(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        }
        else
        {
            /* decode an object identifier value */
            output("if (!ASN1BERDecObjectIdentifier(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        }
        output("return 0;\n");
        break;

    case eBERSTIData_ObjectIdEncoded:

        /* decode an encoded object identifier value */
        output("if (!ASN1BERDecEoid(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_String:

        /* decode a string value */
        if (info->NOctets == 1) {
            p = "Char";
        } else if (info->NOctets == 2) {
            p = "Char16";
        } else if (info->NOctets == 4) {
            p = "Char32";
        } else
            MyAbort();
        output("if (!ASN1BERDec%sString(%s, %s, %s))\n",
            p, encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_ZeroString:

        /* decode a zero-termianted string value */
        if (info->NOctets == 1) {
            p = "Char";
        } else if (info->NOctets == 2) {
            p = "Char16";
        } else if (info->NOctets == 4) {
            p = "Char32";
        } else
            MyAbort();
        output("if (!ASN1BERDecZero%sString(%s, %s, %s))\n",
            p, encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_External:

        /* decode an external value */
        output("if (!ASN1BERDecExternal(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_EmbeddedPdv:

        /* decode an embedded pdv value */
        output("if (!ASN1BERDecEmbeddedPdv(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_MultibyteString:

        /* decode a multibyte string value */
        if (info->Rules & eTypeRules_LengthPointer)
        {
            output("if (!ASN1BERDecMultibyteString(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        }
        else
        {
            output("if (!ASN1BERDecZeroMultibyteString(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        }
        output("return 0;\n");
        break;

    case eBERSTIData_UnrestrictedString:

        /* decode an character string value */
        output("if (!ASN1BERDecCharacterString(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_GeneralizedTime:

        /* decode a generalized time value */
        output("if (!ASN1BERDecGeneralizedTime(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_UTCTime:

        /* decode a utc time value */
        output("if (!ASN1BERDecUTCTime(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_Reference:

        /* call other encoding function for reference types */
        output("if (!ASN1Dec_%s(%s, %s, %s))\n",
            Identifier2C(info->SubIdentifier),
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_Open:

        /* decode an open type value */
        output("if (!ASN1BERDecOpenType%s(%s, %s))\n",
            info->pPrivateDirectives->fNoMemCopy ? "2" : "",
            encref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_Boolean:
        if (g_fCaseBasedOptimizer)
        {
            output("if (!ASN1BERDecBool(%s, %s, %s))\n", encref, tagref, Reference(valref));
            output("return 0;\n");
        }
        break;
    }

    /* check length/get eoc for explicit tags */
    GenBERDecTagEnd(DECODER_NAME, STREAM_END_NAME, depth, oldencref);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\geninc.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

const ASN1uint32_t c_BitMaskMap[sizeof(ASN1uint32_t) * 8] =
{
#ifdef USE_BIG_ENDIAN
        0x80000000, 0x40000000, 0x20000000, 0x10000000,
        0x08000000, 0x04000000, 0x02000000, 0x01000000,

        0x800000,   0x400000,   0x200000,   0x100000,
        0x080000,   0x040000,   0x020000,   0x010000,

        0x8000,     0x4000,     0x2000,     0x1000,
        0x0800,     0x0400,     0x0200,     0x0100,

        0x80,       0x40,       0x20,       0x10,
        0x08,       0x04,       0x02,       0x01,
#else // little endian 
        0x80,       0x40,       0x20,       0x10,
        0x08,       0x04,       0x02,       0x01,

        0x8000,     0x4000,     0x2000,     0x1000,
        0x0800,     0x0400,     0x0200,     0x0100,

        0x800000,   0x400000,   0x200000,   0x100000,
        0x080000,   0x040000,   0x020000,   0x010000,

        0x80000000, 0x40000000, 0x20000000, 0x10000000,
        0x08000000, 0x04000000, 0x02000000, 0x01000000,
#endif
};

void GenComponents(AssignmentList_t ass, ComponentList_t components,
    char *identifier, char *completeidentifier, int *choiceoffset,
    int *optionaloffset);
void GenType(AssignmentList_t ass, char *identifier, char *completeidentifier,
    Type_t *type, int withmodule, int pointer, int array, int fTypeDef);

void GenEnumeration(AssignmentList_t ass, ComponentList_t components,
    char *identifier, char *completeidentifier, int *choiceoffset,
    int *optionaloffset);

int NotInFunTbl(Assignment_t *a);

unsigned g_cPDUs = 0;

unsigned g_cOptionValueSize = 0;

extern int g_fAllEndians;

/* generate include file */
void
GenInc(AssignmentList_t ass, FILE *finc, char *module)
{
    Assignment_t *a;
    char *identifier;
    int offset, i;
    Type_t *type, *subtype;
    Value_t *value;
    unsigned npdu;
    char *pszPrivateValueName;
    unsigned cOptionValueSizeSave;

    setoutfile(finc);

    module = Identifier2C(module);

    // print verbatim
    PrintVerbatim();

    /* file header */
    output("#ifndef _%s_H_\n", module);
    output("#define _%s_H_\n\n", module);

    switch (g_eEncodingRule)
    {
    case eEncoding_Packed:
        output("#include \"msper.h\"\n");
        break;
    case eEncoding_Basic:
        output("#include \"msber.h\"\n");
        break;
    default:
        ASSERT(0);
        break;
    }
    output("\n");

    for (i = 0; i < g_cGhostFiles; i++)
    {
        StripModuleName(g_aGhostFiles[i].pszFileName, g_aGhostFiles[i].pszFileName);
        strcat(g_aGhostFiles[i].pszFileName, ".h");
        output("#include \"%s\"\n", g_aGhostFiles[i].pszFileName);
    }
    if (g_cGhostFiles)
    {
        output("\n");
    }

    // ghost all the data structures from the ghost asn1 files
    for (a = ass; a; a = a->Next)
    {
        if (a->Type != eAssignment_Type)
            continue;
        type = a->U.Type.Type;
        if (type->Flags & eTypeFlags_Null)
            continue;
        if (!(type->Flags & eTypeFlags_GenType))
            continue;
        if (a->Module && a->Module->Identifier)
        {
            for (i = 0; i < g_cGhostFiles; i++)
            {
                if (! strcmp(a->Module->Identifier, g_aGhostFiles[i].pszModuleName))
                {
                    a->fGhost = 1;
                    break;
                }
            }
        }
    }

    /* language dependent interface */
    switch (g_eProgramLanguage) {
    case eLanguage_C:
        // output("#include \"cinterf.h\"\n\n");
        output("#ifdef __cplusplus\n");
        outputni("extern \"C\" {\n");
        output("#endif\n\n");
        break;
    case eLanguage_Cpp:
        // output("#include \"cppinterf.h\"\n\n");
        // break;
    default:
        ASSERT(0);
        break;
    }

    /* create endian independent macros */
    if (g_fAllEndians)
    {
        output("#ifdef ASN1_BIG_ENDIAN\n");
        output("#define ASN1_LITE_TO_BIGE_16(n16)    ((((n16) & 0xFF) << 8)  | (((n16) & 0xFF00) >> 8))\n");
        output("#define ASN1_LITE_TO_BIGE_32(n32)    ((((n32) & 0xFF) << 24) | (((n32) & 0xFF00) << 8)) | (((n32) & 0xFF0000) >> 8) | (((n32) & 0xFF000000) >> 24)\n");
        output("#define ASN1_ENDIAN_16(n16)         ASN1_LITE_TO_BIGE_16(n16)\n");
        output("#define ASN1_ENDIAN_32(n32)         ASN1_LITE_TO_BIGE_32(n32)\n");
        output("#else\n");
        output("#define ASN1_ENDIAN_16(n16)         (n16)\n");
        output("#define ASN1_ENDIAN_32(n32)         (n32)\n");
        output("#endif // ASN1_BIG_ENDIAN\n\n");
    }

    /* typedefs for sequence of/set of with list representation */
    npdu = 0;
    for (a = ass; a; a = a->Next) {
        if (a->Type != eAssignment_Type)
            continue;
        type = a->U.Type.Type;
        if (type->Flags & eTypeFlags_Null)
            continue;
        if (!(type->Flags & eTypeFlags_GenType))
            continue;
        if (a->fGhost)
            continue;
        identifier = GetName(a);
        switch (type->Type) {
        case eType_SequenceOf:
        case eType_SetOf:
            if (GetTypeRules(ass, type) & (eTypeRules_LinkedListMask | eTypeRules_PointerToElement))
            {
                if (g_fExtraStructPtrTypeSS)
                {
                    output("typedef struct %s_s * P%s;\n",
                        identifier, identifier);
                }
                else
                {
                    output("typedef struct %s * P%s;\n",
                        identifier, identifier);
                }
                output("\n");
            }
            break;
        default:
            break;
        }
    }

    /* other type definitions */
    for (a = ass; a; a = a->Next) {
        if (a->Type != eAssignment_Type)
            continue;
        type = a->U.Type.Type;

        /* skip null type */
        if (type->Flags & eTypeFlags_Null)
        {
                if (type->Type == eType_Sequence)
                {
                        identifier = GetName(a);
                        output("typedef struct %s {\n", identifier);
                        output("char placeholder;\n");
                        output("} %s;\n\n", identifier);
                }
                continue;
        }

        /* type definition wanted? */
        if (!(type->Flags & eTypeFlags_GenType))
            continue;

        if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
            continue;

        if (a->fGhost)
            continue;

        /* assign an id number to the type */
        identifier = GetName(a);

        /* write type definitions */
        switch (type->Type) {
        case eType_Sequence:
        case eType_Set:
        case eType_InstanceOf:

            // save
            cOptionValueSizeSave = g_cOptionValueSize;

            // generate scope-free enumeration
            offset = 0;
            GenEnumeration(ass, type->U.SSC.Components, identifier, identifier, NULL, &offset);

            /* use struct for sequence/set/instanceof type */
            /* add a bit field for optional components */
            output("typedef struct %s {\n", identifier);
            if (type->U.SSC.Optionals || type->U.SSC.Extensions) {
                int cOctets = (type->U.SSC.Optionals + 7) / 8 +
                              (type->U.SSC.Extensions + 7) / 8;
                g_cOptionValueSize = (cOctets <= 2) ? 16 : 32;
                output("union {\nASN1uint%u_t %s;\nASN1octet_t o[%d];\n};\n",
                    g_cOptionValueSize, g_pszOptionValue, cOctets);
            }
            offset = 0;
            GenComponents(ass, type->U.SSC.Components,
                identifier, identifier, NULL, &offset);
            output("} %s;\n", identifier);

            // restore
            g_cOptionValueSize = cOptionValueSizeSave;
            break;

        case eType_Choice:

            // generate scope-free enumeration
            offset = 0;
            GenEnumeration(ass, type->U.SSC.Components, identifier, identifier, NULL, &offset);

            /* use a struct of an selector and a union for choice type */
            output("typedef struct %s {\n", identifier);
            // output("%s o;\n", GetChoiceType(type));
            output("ASN1choice_t choice;\n");
            if (!(type->Flags & eTypeFlags_NullChoice))
                output("union {\n");
            offset = ASN1_CHOICE_BASE;
            GenComponents(ass, type->U.Choice.Components,
                identifier, identifier, &offset, NULL);
            if (!(type->Flags & eTypeFlags_NullChoice))
                output("} u;\n");
            output("} %s;\n", identifier);
            break;

        case eType_SequenceOf:
        case eType_SetOf:

            //
            // LONCHANC: The following two lines of code do not apply to
            // SEQUENCE OF and SET OF.
            //
            // generate scope-free enumeration
            // offset = 0;
            // GenEnumeration(ass, type->U.SSC.Components, identifier, identifier, NULL, &offset);

            /* use a struct of length+values for sequence of/set of with */
            /* length-pointer representation */
            /* use a struct of next+value for sequence of/set of with */
            /* singly-linked-list representation */
            /* use a struct of next+prev+value for sequence of/set of with */
            /* doubly-linked-list representation */
            subtype = type->U.SS.Type;
            if (g_fExtraStructPtrTypeSS &&
                (type->Rules & (eTypeRules_LinkedListMask | eTypeRules_PointerToElement)))
            {
                output("typedef struct %s_s {\n", identifier);
            }
            else
            {
                output("typedef struct %s {\n", identifier);
            }
            // fix (xyz..MAX) problem.
            if (type->Rules == eTypeRules_FixedArray && type->PERTypeInfo.Root.LUpperVal == 0)
            {
                type->Rules &= ~ eTypeRules_FixedArray;
                type->Rules |= g_eDefTypeRuleSS_NonSized;
                type->PERTypeInfo.Rules &= ~ eTypeRules_FixedArray;
                type->PERTypeInfo.Rules |= g_eDefTypeRuleSS_NonSized;
                type->BERTypeInfo.Rules &= ~ eTypeRules_FixedArray;
                type->BERTypeInfo.Rules |= g_eDefTypeRuleSS_NonSized;
            }
            pszPrivateValueName = GetPrivateValueName(&type->PrivateDirectives, "value");
            if (type->Rules & eTypeRules_FixedArray)
            {
                output("ASN1uint32_t count;\n");
                GenType(ass, pszPrivateValueName, pszPrivateValueName, subtype,
                    0, 0, type->PERTypeInfo.Root.LUpperVal, 0);
            }
            else
            if (type->Rules & eTypeRules_LengthPointer)
            {
                output("ASN1uint32_t count;\n");
                GenType(ass, pszPrivateValueName, pszPrivateValueName, subtype,
                    0, 1, 0, 0);
            }
            else
            if (type->Rules & eTypeRules_DoublyLinkedList)
            {
                output("P%s next;\n", identifier);
                output("P%s prev;\n", identifier);
                GenType(ass, pszPrivateValueName, pszPrivateValueName, subtype,
                    0, 0, 0, 0);
            }
            else
            if (type->Rules & eTypeRules_SinglyLinkedList)
            {
                output("P%s next;\n", identifier);
                GenType(ass, pszPrivateValueName, pszPrivateValueName, subtype,
                    0, 0, 0, 0);
            }
            else
            {
                MyAbort();
            }
            if (type->Rules & eTypeRules_LinkedListMask)
            {
                if (g_fExtraStructPtrTypeSS)
                {
                    output("} %s_Element, *%s;\n", identifier, identifier);
                }
                else
                {
                    output("} %s_Element;\n", identifier);
                }
            } else {
                output("} %s;\n", identifier);
            }
            break;

        default:

            /* use the builtin type for other types */
            output("typedef ");
            GenType(ass, a->Identifier, identifier, type, 1, 0, 0, 1);
            break;
        }

        if (! NotInFunTbl(a))
        {
            output("#define %s_%s %u\n", identifier, g_pszApiPostfix, npdu);
            switch (type->Type)
            {
            case eType_SequenceOf:
            case eType_SetOf:
                if (type->Rules & eTypeRules_LinkedListMask)
                {
                    output("#define SIZE_%s_%s_%u sizeof(%s_Element)\n", module, g_pszApiPostfix, npdu, identifier);
                    break;
                }
                // intentionally fall through
            default:
                output("#define SIZE_%s_%s_%u sizeof(%s)\n", module, g_pszApiPostfix, npdu, identifier);
                break;
            }
            npdu++;
        }

        output("\n");
    }

    /* write extern declarations for values */
    for (a = ass; a; a = a->Next)
    {
        if (a->Type != eAssignment_Value)
            continue;

        /* extern value wanted? */
        if (!(a->U.Value.Value->Flags & eValueFlags_GenExternValue))
            continue;
        value = GetValue(ass, a->U.Value.Value);

        /* skip value of null type */
        if (value->Type->Flags & eTypeFlags_Null)
            continue;

        /* output an extern declaration */
        switch (value->Type->Type)
        {
        case eType_ObjectIdentifier:
            if (value->Type->PrivateDirectives.fOidPacked)
            {
                output("extern ASN1encodedOID_t %s;\n", GetName(a));
                break;
            }
            else
            if (value->Type->PrivateDirectives.fOidArray || g_fOidArray)
            {
                output("extern ASN1objectidentifier2_t %s;\n", GetName(a));
                break;
            }
            // intentionally fall through
        default:
            output("extern %s %s;\n", GetTypeName(ass, value->Type), GetName(a));
            break;
        }
    }
    output("\n");

    /* write vars, functions and macros for the interface */
    output("extern ASN1module_t %s;\n", module);
    output("extern void ASN1CALL %s_Startup(void);\n", module);
    output("extern void ASN1CALL %s_Cleanup(void);\n", module);
    output("\n");

    output("/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */\n");

    g_cPDUs = npdu;
}

/* generate a type */
void
GenType(AssignmentList_t ass, char *identifier, char *completeidentifier, Type_t *type, int withmodule, int pointer, int array, int fTypeDef)
{
    char *ptr, *pszOldEnumName;
    NamedNumber_t *namedNumbers;
        char arr[20];
    char modide[256];

    /* skip null type */
    // if (type->Flags & eTypeFlags_Null)
        // return;

    /* get type name */
    ptr = pointer ? "*" : "";
    if (array)
        sprintf(arr, "[%u]", array);
    else
        arr[0] = '\0';
    identifier = Identifier2C(identifier);
    if (withmodule)
        sprintf(modide, "%s%s%s", ptr, completeidentifier, arr);
    else
        sprintf(modide, "%s%s%s", ptr, identifier, arr);

    /* output type declaration */
    switch (type->Type) {
    case eType_Reference:

        /* use struct ..._s syntax for pointer to structured type */
        if (pointer && IsStructuredType(GetReferencedType(ass, type))) {
            output("struct %s %s;\n", GetTypeName(ass, type), modide);
        } else {
            char *psz = PGetTypeName(ass, type);
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }
        break;

    case eType_OctetString:
        if (g_eEncodingRule == eEncoding_Packed)
        {
            if (type->PERTypeInfo.Root.LConstraint == ePERSTIConstraint_Constrained &&
                (! type->PrivateDirectives.fLenPtr))
            {
                if (strcmp(completeidentifier, modide) == 0)
                {
                    output("struct %s {\nASN1uint32_t length;\nASN1octet_t value[%u];\n} %s;\n",
                        modide, type->PERTypeInfo.Root.LUpperVal, modide);
                }
                else
                {
                    output("struct %s_%s {\nASN1uint32_t length;\nASN1octet_t value[%u];\n} %s;\n",
                        completeidentifier, modide, type->PERTypeInfo.Root.LUpperVal, modide);
                }
            }
            else
            {
                char *psz = GetTypeName(ass, type);
                char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
                output("%s %s%s;\n", psz, modide, psz2);
            }
        }
        else
        {
            // only support unbounded in BER
            char *psz = GetTypeName(ass, type);
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }
        break;

    case eType_UTF8String:
        {
            char *psz = GetTypeName(ass, type);
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }
        break;

    case eType_InstanceOf:
    case eType_SequenceOf:
    case eType_SetOf:

    case eType_Boolean:
    case eType_Real:
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_External:
    case eType_ObjectIdentifier:
    case eType_ObjectDescriptor:
    case eType_BMPString:
    case eType_UniversalString:
    case eType_GeneralizedTime:
    case eType_UTCTime:
    case eType_EmbeddedPdv:
    case eType_Open:

        /* use struct ..._s syntax for pointer to structured type */
        if (pointer && IsStructuredType(type)) {
            output("struct %s %s;\n", GetTypeName(ass, type), modide);
        } else {
            char *psz = GetTypeName(ass, type);
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }
        break;

    case eType_NumericString:
    case eType_PrintableString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GraphicString:
    case eType_GeneralString:
    case eType_VideotexString:
    case eType_IA5String:
    case eType_T61String:
    case eType_TeletexString:
    case eType_CharacterString:
#ifdef ENABLE_CHAR_STR_SIZE
    {
        char *psz = GetTypeName(ass, type);
        if (g_eEncodingRule == eEncoding_Packed &&
            type->PERTypeInfo.Root.LConstraint == ePERSTIConstraint_Constrained &&
            strcmp(psz, "ASN1char_t") == 0)
        {
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s[%u];\n", psz, modide, psz2, type->PERTypeInfo.Root.LUpperVal + 1);
        }
        else
        {
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }
    }
#else
    {
        char *psz = GetTypeName(ass, type);
        char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
        output("%s %s%s;\n", psz, modide, psz2);
    }
#endif
        break;

    case eType_Enumerated:

        /* use name of the type */
    if (fTypeDef)
    {
        if (type->PrivateDirectives.pszTypeName)
        {
            output("enum %s {\n", type->PrivateDirectives.pszTypeName);
            pszOldEnumName = type->PrivateDirectives.pszTypeName;
        }
        else
        {
                output("enum %s {\n", modide);
            pszOldEnumName = "";
        }

            /* dump named numbers */
            namedNumbers = type->U.IEB.NamedNumbers;
            while (namedNumbers) {
                switch (namedNumbers->Type) {
                case eNamedNumber_Normal:
                    if (intxisuint32(&GetValue(ass,
                        namedNumbers->U.Normal.Value)->U.Integer.Value)) {
                        char *psz = Identifier2C(namedNumbers->U.Normal.Identifier);
                        if (IsReservedWord(psz) || DoesEnumNameConflict(psz))
                        {
                    output("%s_%s = %u,\n", *pszOldEnumName ? pszOldEnumName : modide, psz,
                                intx2uint32(&GetValue(ass,
                                namedNumbers->U.Normal.Value)->U.Integer.Value));
                        }
                        else
                        {
                            output("%s = %u,\n", psz,
                                intx2uint32(&GetValue(ass,
                                namedNumbers->U.Normal.Value)->U.Integer.Value));
                }
                    } else if (intxisint32(&GetValue(ass,
                        namedNumbers->U.Normal.Value)->U.Integer.Value)) {
                        char *psz = Identifier2C(namedNumbers->U.Normal.Identifier);
                        if (IsReservedWord(psz) || DoesEnumNameConflict(psz))
                        {
                            output("%s_%s = %d,\n", *pszOldEnumName ? pszOldEnumName : modide, psz,
                                intx2uint32(&GetValue(ass,
                                namedNumbers->U.Normal.Value)->U.Integer.Value));
                }
                else
                {
                            output("%s = %d,\n", psz,
                                intx2uint32(&GetValue(ass,
                                namedNumbers->U.Normal.Value)->U.Integer.Value));
                    }
                    }
                    break;
                case eNamedNumber_ExtensionMarker:
                    break;
                }
                namedNumbers = namedNumbers->Next;
            }

            output("} %s;\n", type->PrivateDirectives.pszTypeName ? type->PrivateDirectives.pszTypeName : modide);
    }
    else
    {
        if (type->PrivateDirectives.pszTypeName)
        {
            pszOldEnumName = type->PrivateDirectives.pszTypeName;
        }
        else
        {
            pszOldEnumName = modide;
        }

        output("%s %s;\n", pszOldEnumName, modide);
    }
    break;

    case eType_Integer:

        /* use name of the type */
        {
            char *psz = GetTypeName(ass, type);
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }

        /* dump named numbers */
        namedNumbers = type->U.IEB.NamedNumbers;
        while (namedNumbers) {
            switch (namedNumbers->Type) {
            case eNamedNumber_Normal:
                if (intxisuint32(&GetValue(ass,
                    namedNumbers->U.Normal.Value)->U.Integer.Value)) {
                    output("#define %s_%s %u\n", completeidentifier,
                        Identifier2C(namedNumbers->U.Normal.Identifier),
                        intx2uint32(&GetValue(ass,
                        namedNumbers->U.Normal.Value)->U.Integer.Value));
                } else if (intxisint32(&GetValue(ass,
                    namedNumbers->U.Normal.Value)->U.Integer.Value)) {
                    output("#define %s_%s %d\n", completeidentifier,
                        Identifier2C(namedNumbers->U.Normal.Identifier),
                        intx2uint32(&GetValue(ass,
                        namedNumbers->U.Normal.Value)->U.Integer.Value));
                }
                break;
            case eNamedNumber_ExtensionMarker:
                break;
            }
            namedNumbers = namedNumbers->Next;
        }
        break;

    case eType_BitString: // lonchanc: split from eType_Integer

        /* use name of the type */
        if (g_eEncodingRule == eEncoding_Packed)
        {
            if (type->PERTypeInfo.Root.cbFixedSizeBitString)
            {
                output("ASN1uint%u_t %s;\n",
                    type->PERTypeInfo.Root.cbFixedSizeBitString * 8, modide);
            }
            else
            {
                char *psz = GetTypeName(ass, type);
                char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
                output("%s %s%s;\n", psz, modide, psz2);
            }
        }
        else
        {
            // only support unbounded in BER
            char *psz = GetTypeName(ass, type);
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }

        /* dump named numbers */
        namedNumbers = type->U.IEB.NamedNumbers;
        while (namedNumbers) {
            switch (namedNumbers->Type) {
            case eNamedNumber_Normal:
                if (intxisuint32(&GetValue(ass,
                    namedNumbers->U.Normal.Value)->U.Integer.Value)) {
                    char *psz = Identifier2C(namedNumbers->U.Normal.Identifier);
                    ASN1uint32_t idx = intx2uint32(&GetValue(ass,
                                namedNumbers->U.Normal.Value)->U.Integer.Value);
                    if (IsReservedWord(psz) || DoesEnumNameConflict(psz))
                    {
                        output("#define %s_%s 0x%lx\n", completeidentifier,
                                psz, c_BitMaskMap[idx]);
                    }
                    else
                    {
                        output("#define %s 0x%lx\n", psz, c_BitMaskMap[idx]);
                    }
                } else if (intxisint32(&GetValue(ass,
                    namedNumbers->U.Normal.Value)->U.Integer.Value)) {
                    char *psz = Identifier2C(namedNumbers->U.Normal.Identifier);
                    ASN1uint32_t idx = intx2uint32(&GetValue(ass,
                                namedNumbers->U.Normal.Value)->U.Integer.Value);
                    if (IsReservedWord(psz) || DoesEnumNameConflict(psz))
                    {
                        output("#define %s_%s 0x%lx\n", completeidentifier,
                                psz, c_BitMaskMap[idx]);
                    }
                    else
                    {
                        output("#define %s 0x%lx\n", psz, c_BitMaskMap[idx]);
                    }
                }
                break;
            case eNamedNumber_ExtensionMarker:
                break;
            }
            namedNumbers = namedNumbers->Next;
        }
        break;

    case eType_Null:
        break;

    case eType_Undefined:
        MyAbort();
        /*NOTREACHED*/
    }
}

/* write declarations for components */
void
GenComponents(AssignmentList_t ass, ComponentList_t components, char *identifier, char *completeidentifier, int *choiceoffset, int *optionaloffset)
{
    NamedType_t *namedType;
    int extended = 0;
    char cidebuf[256];

    /* add dummy for empty components */
    if (components && !components->Next &&
        components->Type == eComponent_ExtensionMarker) {
        output("char placeholder;\n");
        return;
    }

    /* write a declaration for every component */
    for (; components; components = components->Next) {
        switch (components->Type) {
        case eComponent_Normal:
        case eComponent_Optional:
        case eComponent_Default:
            /* write a selector for optional/default components */
            namedType = components->U.NOD.NamedType;
            if ((extended && optionaloffset) ||
                components->Type == eComponent_Optional ||
                components->Type == eComponent_Default)
           {
                char *psz;
                // construct the option value
                char szOptionValue[64];
                if (g_fAllEndians)
                {
                    sprintf(szOptionValue, "ASN1_ENDIAN_%u(0x%lx)", g_cOptionValueSize, c_BitMaskMap[*optionaloffset]);
                }
                else
                {
                    sprintf(szOptionValue, "0x%lx", c_BitMaskMap[*optionaloffset]);
                }

                psz = Identifier2C(namedType->Identifier);
                if (IsReservedWord(psz) || DoesOptNameConflict(psz))
                // lonchanc: do we always put in _preset definition after extended mark???
                // yes, we do. take an example of Setup-UUIE in q931asn.asn.
                // but, the extension mark does not have option-flag definition associated.
                // || (extended && optionaloffset))
                {
                    output("#define %s_%s_%s %s\n",
                        identifier, psz, g_pszOptionPostfix,
                        &szOptionValue[0]);
                }
                else
                {
                    output("#define %s_%s %s\n",
                        psz, g_pszOptionPostfix,
                        &szOptionValue[0]);
                }
                (*optionaloffset)++;
            }
            /* write a selector for choice alternatives */
            if (choiceoffset)
            {
                char *psz = Identifier2C(namedType->Identifier);
                if (IsReservedWord(psz) || DoesChoiceNameConflict(psz))
                {
                    output("#define %s_%s_%s %d\n",
                        identifier, psz, g_pszChoicePostfix,
                        *choiceoffset);
                }
                else
                {
                    output("#define %s_%s %d\n",
                        psz, g_pszChoicePostfix,
                        *choiceoffset);
                }
                (*choiceoffset)++;
            }            
            /* write the declaration itself */
            sprintf(cidebuf, "%s_%s", completeidentifier,
                Identifier2C(namedType->Identifier));
            GenType(ass, namedType->Identifier, cidebuf, namedType->Type,
                0, GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer, 0, 0);
            break;

        case eComponent_ExtensionMarker:

            /* update the offset when an extension marker is met for a */
            /* sequence/set type */
            extended = 1;
            // lonchanc: however, the code generated by TELES handles this properly.
            // moreover, the code requires it to be rounded up.
            // as a result, we should enable this feature.
            if (optionaloffset)
                *optionaloffset = (*optionaloffset + 7) & ~7;
            break;
        }
    }
}

// The following is added by Microsoft

/* write enumerations for components */
void
GenEnumeration(AssignmentList_t ass, ComponentList_t components, char *identifier, char *completeidentifier, int *choiceoffset, int *optionaloffset)
{
    NamedType_t *namedType;
    int extended = 0;
    char cidebuf[256];

    /* write a declaration for every component */
    for (; components; components = components->Next)
    {
        switch (components->Type)
        {
        case eComponent_Normal:
        case eComponent_Optional:
        case eComponent_Default:
            namedType = components->U.NOD.NamedType;
            if (namedType && namedType->Type && namedType->Type->Type == eType_Enumerated)
            {
                output("typedef ");
                /* write the declaration itself */
                sprintf(cidebuf, "%s_%s", completeidentifier,
                    Identifier2C(namedType->Identifier));
                    GenType(ass, namedType->Identifier, cidebuf, namedType->Type,
                    0, GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer, 0, 1);
            }
        break;
        }
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\genper.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "optcase.h"

void GenPERFuncSimpleType(AssignmentList_t ass, PERTypeInfo_t *info, char *valref, TypeFunc_e et, char *encref);
void GenPERStringTableSimpleType(AssignmentList_t ass, PERTypeInfo_t *info);

void GenPEREncSimpleType(AssignmentList_t ass, PERTypeInfo_t *info, char *valref, char *encref);
void GenPEREncGenericUnextended(
    AssignmentList_t ass,
    PERTypeInfo_t *info,
    PERSimpleTypeInfo_t *sinfo,
    char *valref,
    char *lenref,
    char *encref);
void GenPERFuncSequenceSetType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et);
void GenPERFuncChoiceType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et);

void GenPERDecSimpleType(AssignmentList_t ass, PERTypeInfo_t *info, char *valref, char *encref);
void GenPERDecGenericUnextended(
    AssignmentList_t ass,
    PERTypeInfo_t *info,
    PERSimpleTypeInfo_t *sinfo,
    char *valref,
    char *lenref,
    char *encref);

int IsUnconstrainedInteger(PERSimpleTypeInfo_t *sinfo);

extern int g_fDecZeroMemory;
extern int g_nDbgModuleName;
extern unsigned g_cPDUs;
extern int g_fCaseBasedOptimizer;
extern int g_fNoAssert;


/* write header needed for PER encodings */
void
GenPERHeader()
{
//    output("#include \"perfnlib.h\"\n");
}

/* set prototypes and function args of PER functions */
void
GetPERPrototype(Arguments_t *args)
{
    args->enccast = "ASN1encoding_t, void *";
    args->encfunc = "ASN1encoding_t enc, %s *val";
    args->Pencfunc = "ASN1encoding_t enc, P%s *val";
    args->deccast = "ASN1decoding_t, void *";
    args->decfunc = "ASN1decoding_t dec, %s *val";
    args->Pdecfunc = "ASN1decoding_t dec, P%s *val";
    args->freecast = "void *";
    args->freefunc = "%s *val";
    args->Pfreefunc = "P%s *val";
    args->cmpcast = "void *, void *";
    args->cmpfunc = "%s *val1, %s *val2";
    args->Pcmpfunc = "P%s *val1, P%s *val2";
}

/* write initialization function needed for PER encodings */
void
GenPERInit(AssignmentList_t ass, char *module)
{
    output("%s = ASN1_CreateModule(0x%x, ASN1_PER_RULE_ALIGNED, %s, %d, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x%lx);\n",
        module,
        ASN1_THIS_VERSION,
        g_fNoAssert ? "ASN1FLAGS_NOASSERT" : "ASN1FLAGS_NONE",
        g_cPDUs,
        g_nDbgModuleName);
}

/* generate function body for a type */
void GenPERFuncType(AssignmentList_t ass, char *module, Assignment_t *at, TypeFunc_e et)
{
    Type_t *type;
    char *encref;
    char *valref;

    /* get some informations */
    type = at->U.Type.Type;
    switch (et) {
    case eStringTable:
        valref = encref = "";
        break;
    case eEncode:
        encref = "enc";
        valref = "val";
        break;
    case eDecode:
        encref = "dec";
        valref = "val";
        break;
    }

    /* function body */
    switch (type->Type) {
    case eType_Boolean:
    case eType_Integer:
    case eType_Enumerated:
    case eType_Real:
    case eType_BitString:
    case eType_OctetString:
    case eType_UTF8String:
    case eType_Null:
    case eType_EmbeddedPdv:
    case eType_External:
    case eType_ObjectIdentifier:
    case eType_BMPString:
    case eType_GeneralString:
    case eType_GraphicString:
    case eType_IA5String:
    case eType_ISO646String:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_UniversalString:
    case eType_VideotexString:
    case eType_VisibleString:
    case eType_CharacterString:
    case eType_GeneralizedTime:
    case eType_UTCTime:
    case eType_ObjectDescriptor:
    case eType_RestrictedString:
    case eType_Open:
    case eType_Reference:
        GenPERFuncSimpleType(ass, &type->PERTypeInfo, Dereference(valref), et, encref);
        break;

    case eType_SequenceOf:
    case eType_SetOf:
        GenPERFuncSimpleType(ass, &type->PERTypeInfo, Dereference(valref), et, encref);
        break;

    case eType_Sequence:
    case eType_Set:
    case eType_InstanceOf:
        GenPERFuncSequenceSetType(ass, module, at, valref, encref, et);
        break;

    case eType_Choice:
        GenPERFuncChoiceType(ass, module, at, valref, encref, et);
        break;

    case eType_Selection:
    case eType_Undefined:
        MyAbort();
        /*NOTREACHED*/
    }
}

/* generate function body for components */
void
GenPERFuncComponents(AssignmentList_t ass, char *module, uint32_t optindex, ComponentList_t components, char *valref, char *encref, char *oref, TypeFunc_e et, int inextension, int inchoice)
{
    Component_t *com;
    NamedType_t *namedType;
    char *ide;
    char valbuf[256];
    char typebuf[256];
    int conditional, skip;

    /* get a parented encoding_t/decoding_t for sequence/set */
    if (inextension && !inchoice) {
        switch (et) {
        case eStringTable:
            break;
        case eEncode:
            outputvar("ASN1encoding_t ee;\n");
            output("if (ASN1_CreateEncoder(%s->module, &ee, NULL, 0, %s) < 0)\n",
                encref, encref);
            output("return 0;\n");
            break;
        case eDecode:
            outputvar("ASN1decoding_t dd;\n");
            break;
        }
    }

    /* emit components of extension root */
    for (com = components; com; com = com->Next) {
        if (com->Type == eComponent_ExtensionMarker)
            break;

        /* get some information */
        namedType = com->U.NOD.NamedType;
        ide = Identifier2C(namedType->Identifier);

        /* skip unnecessary elements */
        skip = (namedType->Type->Flags & eTypeFlags_Null) && !inextension;

        /* check if optional/default component is present or choice is */
        /* selected */
        conditional = 0;
        switch (et) {
        case eStringTable:
            break;
        case eEncode:
        case eDecode:
            if (inchoice) {
            // lonchanc: we should not skip any case in Decode
            // because we cannot tell skipped cases from extension.
            // on the other hand, in Encode, we'd better not either.
            // when people put in customization in extension,
            // we cannot tell as well.
                if (skip)
                {
                    output("case %d:\nbreak;\n", optindex);
                }
                else
                {
                    output("case %d:\n", optindex);
                    conditional = 1;
                }
                optindex++;
            } else {
                if (com->Type == eComponent_Optional ||
                    com->Type == eComponent_Default ||
                    inextension) {
                    if (!skip) {
                        output("if (%s[%u] & 0x%x) {\n", oref,
                            optindex / 8, 0x80 >> (optindex & 7));
                        conditional = 1;
                    }
                    optindex++;
                }
            }
            break;
        }

        /* get a parented encoding_t/decoding_t for choice */
        if (inextension && inchoice) {
            /* get a parented encoding_t/decoding_t */
            switch (et) {
            case eStringTable:
                break;
            case eEncode:
                outputvar("ASN1encoding_t ee;\n");
                output("if (ASN1_CreateEncoder(%s->module, &ee, NULL, 0, %s) < 0)\n",
                    encref, encref);
                output("return 0;\n");
                break;
            case eDecode:
                outputvar("ASN1decoding_t dd;\n");
                break;
            }
        }

        /* dereference pointer if pointer directive used */
        if (inchoice) {
            if (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer)
                sprintf(valbuf, "*(%s)->u.%s", valref, ide);
            else
                sprintf(valbuf, "(%s)->u.%s", valref, ide);
        } else {
            if (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer)
                sprintf(valbuf, "*(%s)->%s", valref, ide);
            else
                sprintf(valbuf, "(%s)->%s", valref, ide);
        }

        /* allocate memory if decoding and pointer directive used */
        if (et == eDecode &&
            (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer) &&
            !(GetType(ass, namedType->Type)->Flags & eTypeFlags_Null)) {
            sprintf(typebuf, "%s *",
                GetTypeName(ass, namedType->Type));
            output("if (!(%s = (%s)ASN1DecAlloc(%s, sizeof(%s))))\n",
                Reference(valbuf), typebuf, encref, valbuf);
            output("return 0;\n");
        }

        /* handle subtype value */
        if (!skip) {
            if (!inextension) {
                GenPERFuncSimpleType(ass, &namedType->Type->PERTypeInfo,
                    valbuf, et, encref);
            } else {
                switch (et) {
                case eStringTable:
                    GenPERFuncSimpleType(ass, &namedType->Type->PERTypeInfo,
                        valbuf, et, encref);
                    break;
                case eEncode:
                    GenPERFuncSimpleType(ass, &namedType->Type->PERTypeInfo,
                        valbuf, et, "ee");
                        // lonchanc: added the following API to replace the following
                        // chunk of code.
                        output("if (!ASN1PEREncFlushFragmentedToParent(ee))\n");
                    // output("if (!ASN1PEREncFlush(ee))\n");
                    // output("return 0;\n");
                    // output("if (!ASN1PEREncFragmented(%s, ee->len, ee->buf, 8))\n",
                        // encref);
                    output("return 0;\n");
                    break;
                case eDecode:
                    outputvar("ASN1octet_t *db;\n");
                    outputvar("ASN1uint32_t ds;\n");
                    output("if (!ASN1PERDecFragmented(%s, &ds, &db, 8))\n",
                        encref);
                    output("return 0;\n");
                    output("if (ASN1_CreateDecoder(%s->module, &dd, db, ds, %s) < 0)\n",
                        encref, encref);
                    output("return 0;\n");
                    GenPERFuncSimpleType(ass, &namedType->Type->PERTypeInfo,
                        valbuf, et, "dd");
                    output("ASN1_CloseDecoder(dd);\n");
                    output("ASN1Free(db);\n");
                    break;
                }
            }
        }

        /* drop the parented encoding_t/decoding_t for choice */
        if (inextension && inchoice) {
            if (et == eEncode) {
                output("ASN1_CloseEncoder2(ee);\n");
            }
        }

        /* end of check for presence of optional/default component */
        if (inchoice) {
            if (conditional)
                output("break;\n");
        } else {
            if (conditional)
                output("}\n");
        }
    }

    /* drop the parented encoding_t/decoding_t for sequence/set */
    if (inextension && !inchoice) {
        if (et == eEncode) {
            output("ASN1_CloseEncoder2(ee);\n");
        }
    }
}

/* generate function body for sequence/set type */
void GenPERFuncSequenceSetType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et)
{
    uint32_t optionals, extensions;
    Component_t *components, *com;
    PERTypeInfo_t inf;
    Type_t *type;
    char valbuf[256];
    int conditional;
    char obuf[256];

    type = at->U.Type.Type;
    optionals = type->U.SSC.Optionals;
    extensions = type->U.SSC.Extensions;
    components = type->U.SSC.Components;
    inf.Identifier = NULL;
    inf.Flags = 0;
    inf.Rules = 0;
    inf.EnumerationValues = NULL;
    inf.NOctets = 0;
    inf.Type = eExtension_Unextended;
    inf.Root.TableIdentifier = NULL;
    inf.Root.Table = NULL;
    inf.Root.Data = ePERSTIData_Extension;
    inf.Root.SubType = NULL;
    inf.Root.SubIdentifier = NULL;
    inf.Root.NBits = 0;
    inf.Root.Constraint = ePERSTIConstraint_Unconstrained;
    intx_setuint32(&inf.Root.LowerVal, 0);
    intx_setuint32(&inf.Root.UpperVal, 0);
    inf.Root.Alignment = ePERSTIAlignment_BitAligned;
    inf.Root.Length = ePERSTILength_NoLength;
    inf.Root.LConstraint = ePERSTIConstraint_Unconstrained;
    inf.Root.LLowerVal = 0;
    inf.Root.LUpperVal = 0;
    inf.Root.LNBits = 0;
    inf.Root.LAlignment = ePERSTIAlignment_OctetAligned;

    /* set/clear missing bits in optional/default bit field */
    GenFuncSequenceSetOptionals(ass, valref, components,
        optionals, extensions, obuf, et);

    /* emit/get extension bit if needed */
    if (type->Flags & eTypeFlags_ExtensionMarker) {
        switch (et) {
        case eStringTable:
            break;
        case eEncode:
            if (type->Flags & eTypeFlags_ExtensionMarker) {
                if (!extensions) {
                    if (g_fCaseBasedOptimizer)
                    {
                        output("if (!ASN1PEREncExtensionBitClear(%s))\n", encref);
                    }
                    else
                    {
                        output("if (!ASN1PEREncBitVal(%s, 1, 0))\n", encref);
                    }
                    output("return 0;\n");
                } else {
                    outputvar("ASN1uint32_t y;\n");
                    output("y = ASN1PEREncCheckExtensions(%d, %s + %d);\n",
                        extensions, strcmp(obuf, "o") ? obuf : "(val)->o", (optionals + 7) / 8);
                    output("if (!ASN1PEREncBitVal(%s, 1, y))\n",
                        encref);
                    output("return 0;\n");
                }
            }
            break;
        case eDecode:
            if (type->Flags & eTypeFlags_ExtensionMarker) {
                outputvar("ASN1uint32_t y;\n");
                if (g_fCaseBasedOptimizer)
                {
                    output("if (!ASN1PERDecExtensionBit(%s, &y))\n", encref);
                }
                else
                {
                    output("if (!ASN1PERDecBit(%s, &y))\n", encref);
                }
                output("return 0;\n");
            }
            break;
        }
    }

    /* emit/get bit field of optionals */
    if (optionals) {
        inf.Root.NBits = optionals;
        inf.Root.Length = ePERSTILength_NoLength;
        if (optionals >= 0x10000)
            MyAbort();
        GenPERFuncSimpleType(ass, &inf, obuf, et, encref);
    }

    /* emit components of extension root */
    GenPERFuncComponents(ass, module, 0, components,
        valref, encref, obuf, et, 0, 0);

    /* handle extensions */
    if (type->Flags & eTypeFlags_ExtensionMarker) {
        conditional = 0;
        if (!extensions) {

            /* skip unknown extension bit field */
            if (et == eDecode) {
                output("if (y) {\n");
                inf.Root.NBits = 1;
                inf.Root.Length = ePERSTILength_SmallLength;
                inf.Root.LConstraint = ePERSTIConstraint_Semiconstrained;
                inf.Root.LLowerVal = 1;
                if (g_fCaseBasedOptimizer)
                {
                    output("if (!ASN1PERDecSkipNormallySmallExtensionFragmented(%s))\n",
                            encref);
                    output("return 0;\n");
                    output("}\n");
                    goto FinalTouch;
                }
                else
                {
                    GenPERFuncSimpleType(ass, &inf, NULL, et, encref);
                    conditional = 1;
                }
            }

        } else {

            /* check if extension bit is set */
            switch (et) {
            case eStringTable:
                break;
            case eEncode:
                output("if (y) {\n");
                conditional = 1;
                break;
            case eDecode:
                output("if (!y) {\n");
                output("ZeroMemory(%s + %d, %d);\n", obuf,
                    (optionals + 7) / 8, (extensions + 7) / 8);
                output("} else {\n");
                conditional = 1;
                break;
            }

            /* emit/get bit field of extensions */
            inf.Root.NBits = extensions;
            inf.Root.Length = ePERSTILength_SmallLength;
            inf.Root.LConstraint = ePERSTIConstraint_Semiconstrained;
            inf.Root.LLowerVal = 1;
            sprintf(valbuf, "%s + %d", obuf, (optionals + 7) / 8);
            GenPERFuncSimpleType(ass, &inf, valbuf, et, encref);

            /* get start of extensions */
            for (com = components; com; com = com->Next) {
                if (com->Type == eComponent_ExtensionMarker) {
                    com = com->Next;
                    break;
                }
            }

            /* emit components of extension */
            GenPERFuncComponents(ass, module, (optionals + 7) & ~7, com,
                valref, encref, obuf, et, 1, 0);
        }

        /* skip unknown extensions */
        if (et == eDecode) {
            outputvar("ASN1uint32_t i;\n");
            outputvar("ASN1uint32_t e;\n");
            output("for (i = 0; i < e; i++) {\n");
            output("if (!ASN1PERDecSkipFragmented(%s, 8))\n",
                encref);
            output("return 0;\n");
            output("}\n");
        }

        /* end of extension handling */
        if (conditional)
            output("}\n");
    }

FinalTouch:

    /* some user-friendly assignments for non-present optional/default */
    /* components */
    GenFuncSequenceSetDefaults(ass, valref, components, obuf, et);
}

/* generate function body for choice type */
void GenPERFuncChoiceType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et)
{
    Type_t *type;
    char valbuf[256];
    uint32_t alternatives;
    Component_t *components, *com;
    int fOptimizeCase = 0;

    /* get some informations */
    type = at->U.Type.Type;
    alternatives = type->U.SSC.Alternatives;
    components = type->U.SSC.Components;

    /* encode choice selector */
    switch (et) {
    case eStringTable:
        sprintf(valbuf, "(%s)->choice", valref);
        break;
    case eEncode:
        sprintf(valbuf, "(%s)->choice", valref);
        if (g_fCaseBasedOptimizer)
        {
            switch (type->PERTypeInfo.Type)
            {
            case eExtension_Unconstrained:
                break;
            case eExtension_Unextended: // no extension mark at all
                output("if (!ASN1PEREncSimpleChoice(%s, %s, %u))\n",
                        encref, valbuf, type->PERTypeInfo.Root.NBits);
                output("return 0;\n");
                fOptimizeCase = 1;
                break;
            case eExtension_Extendable: // extension mark exists, but no choice appears after the mark
                output("if (!ASN1PEREncSimpleChoiceEx(%s, %s, %u))\n",
                        encref, valbuf, type->PERTypeInfo.Root.NBits);
                output("return 0;\n");
                fOptimizeCase = 1;
                break;
            case eExtension_Extended: // extension mark exists, but some choices appear after the mark
                output("if (!ASN1PEREncComplexChoice(%s, %s, %u, %u))\n",
                        encref, valbuf, type->PERTypeInfo.Root.NBits, intx2uint32(&(type->PERTypeInfo.Additional.LowerVal)));
                output("return 0;\n");
                fOptimizeCase = 1;
                break;
            }
        }
        if (ASN1_CHOICE_BASE)
        {
            sprintf(valbuf, "(%s)->choice - %d", valref, ASN1_CHOICE_BASE);
        }
        break;
    case eDecode:
        sprintf(valbuf, "(%s)->choice", valref);
        if (g_fCaseBasedOptimizer)
        {
            switch (type->PERTypeInfo.Type)
            {
            case eExtension_Unconstrained:
                break;
            case eExtension_Unextended: // no extension mark at all
                output("if (!ASN1PERDecSimpleChoice(%s, %s, %u))\n",
                        encref, Reference(valbuf), type->PERTypeInfo.Root.NBits);
                output("return 0;\n");
                fOptimizeCase = 1;
                break;
            case eExtension_Extendable: // extension mark exists, but no choice appears after the mark
                output("if (!ASN1PERDecSimpleChoiceEx(%s, %s, %u))\n",
                        encref, Reference(valbuf), type->PERTypeInfo.Root.NBits);
                output("return 0;\n");
                fOptimizeCase = 1;
                break;
            case eExtension_Extended: // extension mark exists, but some choices appear after the mark
                output("if (!ASN1PERDecComplexChoice(%s, %s, %u, %u))\n",
                        encref, Reference(valbuf), type->PERTypeInfo.Root.NBits, intx2uint32(&(type->PERTypeInfo.Additional.LowerVal)));
                output("return 0;\n");
                fOptimizeCase = 1;
                break;
            }
        }
        break;
    }

    if (! fOptimizeCase)
    {
        if (eDecode == et)
        {
            output("%s = %d;\n", valbuf, ASN1_CHOICE_INVALID);
        }
        GenPERFuncSimpleType(ass, &type->PERTypeInfo, valbuf, et, encref);

        // lonchanc: in case of decoding, we need to increment choice value
        // by the amount of ASN1_CHOICE_BASE
        if (et == eDecode && ASN1_CHOICE_BASE)
        {
            output("(%s)->choice += %d;\n", valref, ASN1_CHOICE_BASE);
        }
    }

    /* finished if choice only contains NULL alternatives or if choice */
    /* contains no data to free */
    if (type->Flags & eTypeFlags_NullChoice)
        return;

    /* create switch statement */
    switch (et) {
    case eStringTable:
        break;
    case eDecode:
    case eEncode:
        output("switch ((%s)->choice) {\n", valref);
        break;
    }

    /* generate components of extension root */
    GenPERFuncComponents(ass, module, ASN1_CHOICE_BASE, components,
        valref, encref, NULL, et, 0, 1);

    /* get start of extensions */
    for (com = components; com; com = com->Next) {
        if (com->Type == eComponent_ExtensionMarker) {
            com = com->Next;
            break;
        }
    }

    /* generate components of extension */
    GenPERFuncComponents(ass, module, ASN1_CHOICE_BASE + alternatives, com,
        valref, encref, NULL, et, 1, 1);

    /* skip unknown extensions */
    if (et == eDecode && (type->Flags & eTypeFlags_ExtensionMarker)) {
        output("case %d:\n\t/* extension case */\n", ASN1_CHOICE_INVALID + 1);
        output("if (!ASN1PERDecSkipFragmented(%s, 8))\n", encref);
        output("return 0;\n");
        output("break;\n");
    }

    // debug purpose
    switch (et)
    {
    case eEncode:
        output("default:\n\t/* impossible */\n");
        output("ASN1EncSetError(%s, ASN1_ERR_CHOICE);\n", encref);
        output("return 0;\n");
        break;
    case eDecode:
        output("default:\n\t/* impossible */\n");
        output("ASN1DecSetError(%s, ASN1_ERR_CHOICE);\n", encref);
        output("return 0;\n");
        break;
    }

    /* end of switch statement */
    switch (et) {
    case eStringTable:
        break;
    case eEncode:
    case eDecode:
        output("}\n");
        break;
    }
}

/* generate function body for simple type */
void
GenPERFuncSimpleType(AssignmentList_t ass, PERTypeInfo_t *info, char *valref, TypeFunc_e et, char *encref)
{
    switch (et) {
    case eStringTable:
        GenPERStringTableSimpleType(ass, info);
        break;
    case eEncode:
        GenPEREncSimpleType(ass, info, valref, encref);
        break;
    case eDecode:
        GenPERDecSimpleType(ass, info, valref, encref);
        break;
    }
}

/* generate string table for a simple type */
void
GenPERStringTableSimpleType(AssignmentList_t ass, PERTypeInfo_t *info)
{
    ValueConstraint_t *pc;
    uint32_t i, n, lo, up;

    switch (info->Root.Data) {
    case ePERSTIData_String:
    case ePERSTIData_TableString:
    case ePERSTIData_ZeroString:
    case ePERSTIData_ZeroTableString:
        if (info->Root.TableIdentifier) {
            if (!strcmp(info->Root.TableIdentifier, "ASN1NumericStringTable"))
                break;
            output("static ASN1stringtableentry_t %sEntries[] = {\n",
                info->Root.TableIdentifier);
            i = n = 0;
            for (pc = info->Root.Table; pc; pc = pc->Next) {
                lo = GetValue(ass, pc->Lower.Value)->
                    U.RestrictedString.Value.value[0];
                up = GetValue(ass, pc->Upper.Value)->
                    U.RestrictedString.Value.value[0];
                output("{ %u, %u, %u }, ", lo, up, n);
                n += (up - lo) + 1;
                i++;
                if ((i & 3) == 3 || !pc->Next)
                    output("\n");
            }
            output("};\n");
            output("\n");
            output("static ASN1stringtable_t %s = {\n",
                info->Root.TableIdentifier);
            output("%d, %sEntries\n", i, info->Root.TableIdentifier);
            output("};\n");
            output("\n");
        }
        break;

    case ePERSTIData_SetOf:
    case ePERSTIData_SequenceOf:
        GenPERFuncSimpleType(ass, &info->Root.SubType->PERTypeInfo, "", eStringTable, "");
        break;
    }
}

/* generate encoding statements for a simple value */
void
GenPEREncSimpleType(AssignmentList_t ass, PERTypeInfo_t *info, char *valref, char *encref)
{
    uint32_t i;
    char lbbuf[256], ubbuf[256];
    char *lenref;
    char lenbuf[256], valbuf[256];
    char *p;
    PERTypeInfo_t inf;

    inf = *info;

    /* examine type for special handling */
    switch (inf.Root.Data) {
    case ePERSTIData_BitString:
    case ePERSTIData_RZBBitString:

        if (inf.Root.cbFixedSizeBitString)
        {
            sprintf(lenbuf, "%u", inf.Root.LUpperVal);
            sprintf(valbuf, "&(%s)", valref);
            lenref = lenbuf;
            valref = valbuf;
            break;
        }

        // lonchanc: intentionally fall through

    case ePERSTIData_OctetString:

        if (g_fCaseBasedOptimizer)
        {
            if (inf.Root.Data == ePERSTIData_OctetString && inf.Type == eExtension_Unextended)
            {
                switch (inf.Root.Length)
                {
                case ePERSTILength_NoLength:
                    if (inf.Root.LConstraint == ePERSTIConstraint_Constrained &&
                        inf.Root.LLowerVal == inf.Root.LUpperVal &&
                        inf.Root.LUpperVal < 64 * 1024)
                    {
                        // fixed size constraint, eg. OCTET STRING (SIZE (8))
                        if (inf.pPrivateDirectives->fLenPtr)
                        {
                            output("if (!ASN1PEREncOctetString_FixedSizeEx(%s, %s, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal);
                        }
                        else
                        {
                            output("if (!ASN1PEREncOctetString_FixedSize(%s, (ASN1octetstring2_t *) %s, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal);
                        }
                        output("return 0;\n");
                        return;
                    }
                    break;
                case ePERSTILength_Length:
                    break;
                case ePERSTILength_BitLength:
                    if (inf.Root.LConstraint == ePERSTIConstraint_Constrained &&
                        inf.Root.LLowerVal < inf.Root.LUpperVal &&
                        inf.Root.LUpperVal < 64 * 1024)
                    {
                        // variable size constraint, eg. OCTET STRING (SIZE (4..16))
                        if (inf.pPrivateDirectives->fLenPtr)
                        {
                            output("if (!ASN1PEREncOctetString_VarSizeEx(%s, %s, %u, %u, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal, inf.Root.LUpperVal, inf.Root.LNBits);
                        }
                        else
                        {
                            output("if (!ASN1PEREncOctetString_VarSize(%s, (ASN1octetstring2_t *) %s, %u, %u, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal, inf.Root.LUpperVal, inf.Root.LNBits);
                        }
                        output("return 0;\n");
                        return;
                    }
                    break;
                case ePERSTILength_SmallLength:
                    break;
                case ePERSTILength_InfiniteLength: // no size constraint, eg OCTET STRING
                    /* encode octet string in fragmented format */
                    output("if (!ASN1PEREncOctetString_NoSize(%s, %s))\n",
                        encref, Reference(valref));
                    output("return 0;\n");
                    return;
                } // switch
            } // if
        }

        /* length and value of bit string, octet string and string */
        sprintf(lenbuf, "(%s).length", valref);
        sprintf(valbuf, "(%s).value", valref);
        lenref = lenbuf;
        valref = valbuf;
        break;

    case ePERSTIData_UTF8String:

        /* length and value of bit string, octet string and string */
        sprintf(lenbuf, "(%s).length", valref);
        sprintf(valbuf, "(%s).value", valref);
        lenref = lenbuf;
        valref = valbuf;
        break;

    case ePERSTIData_String:
    case ePERSTIData_TableString:

        /* length and value of bit string, octet string and string */
        sprintf(lenbuf, "(%s).length", valref);
        sprintf(valbuf, "(%s).value", valref);
        lenref = lenbuf;
        valref = valbuf;
        break;

    case ePERSTIData_SequenceOf:
    case ePERSTIData_SetOf:

        if (inf.Rules & eTypeRules_PointerArrayMask)
        {
            /* length and value of sequence of/set of value with */
            /* length-pointer representation */
            if (inf.Rules & eTypeRules_PointerToElement)
            {
                sprintf(lenbuf, "(%s)->count", valref);
                sprintf(valbuf, "(%s)->%s", valref, GetPrivateValueName(inf.pPrivateDirectives, "value"));
            }
            else
            {
                sprintf(lenbuf, "(%s)->count", Reference(valref));
                sprintf(valbuf, "(%s)->%s", Reference(valref), GetPrivateValueName(inf.pPrivateDirectives, "value"));
            }
            lenref = lenbuf;
            valref = valbuf;
        }
        else
        if (inf.Rules & eTypeRules_LinkedListMask)
        {
            /* use a loop for sequence of/set of value with */
            /* list representation */

            if (g_fCaseBasedOptimizer)
            {
                if (PerOptCase_IsTargetSeqOf(&inf))
                {
                    // generate the iterator
                    char szElmFn[128];
                    char szElmFnDecl[256];
                    sprintf(szElmFn, "ASN1Enc_%s_ElmFn", inf.Identifier);
                    sprintf(szElmFnDecl, "int ASN1CALL %s(ASN1encoding_t %s, P%s val)",
                        szElmFn, encref, inf.Identifier);

                    setoutfile(g_finc);
                    output("extern %s;\n", szElmFnDecl);
                    setoutfile(g_fout);

                    if ((inf.Root.LLowerVal == 0 && inf.Root.LUpperVal == 0) ||
                        (inf.Root.LUpperVal >= 64 * 1024)
                       )
                    {
                        output("return ASN1PEREncSeqOf_NoSize(%s, (ASN1iterator_t **) %s, (ASN1iterator_encfn) %s);\n",
                            encref, Reference(valref), szElmFn);
                    }
                    else
                    {
                        if (inf.Root.LLowerVal == inf.Root.LUpperVal)
                            MyAbort();
                        output("return ASN1PEREncSeqOf_VarSize(%s, (ASN1iterator_t **) %s, (ASN1iterator_encfn) %s, %u, %u, %u);\n",
                            encref, Reference(valref), szElmFn,
                            inf.Root.LLowerVal, inf.Root.LUpperVal, inf.Root.LNBits);
                    }
                    output("}\n\n"); // end of iterator body

                    // generate the element function
                    output("static %s\n", szElmFnDecl);
                    output("{\n");
                    sprintf(valbuf, "val->%s", GetPrivateValueName(inf.pPrivateDirectives, "value"));
                    GenPERFuncSimpleType(ass, &inf.Root.SubType->PERTypeInfo, valbuf,
                        eEncode, encref);
                    // end of element body
                    return;
                }
            }

            outputvar("ASN1uint32_t t;\n");
            outputvar("P%s f;\n", inf.Identifier);
            output("for (t = 0, f = %s; f; f = f->next)\n", valref);
            output("t++;\n");
            lenref = "t";

        } else {
            MyAbort();
        }
        break;

    case ePERSTIData_ZeroString:
    case ePERSTIData_ZeroTableString:

        /* length of a zero-terminated string value */
        outputvar("ASN1uint32_t t;\n");
        output("t = lstrlenA(%s);\n", valref);
        lenref = "t";
        break;

    case ePERSTIData_Boolean:

        /* value of a boolean value */

        if (g_fCaseBasedOptimizer)
        {
            if (PerOptCase_IsBoolean(&inf.Root))
            {
                lenref = NULL;
                break;
            }
        }

        sprintf(valbuf, "(%s) ? 1 : 0", valref);
        valref = valbuf;
        lenref = NULL;
        inf.Root.Data = ePERSTIData_Unsigned;
        break;

    default:

        /* other values have no additional length */
        lenref = NULL;
        break;
    }

    /* map enumeration values */
    if (inf.EnumerationValues) {
        outputvar("ASN1uint32_t u;\n");
        output("switch (%s) {\n", valref);
        for (i = 0; inf.EnumerationValues[i]; i++) {
            output("case %u:\n", intx2uint32(inf.EnumerationValues[i]));
            output("u = %u;\n", i);
            output("break;\n");
        }
        output("}\n");
        valref = "u";
        inf.NOctets = 4;
    }

    /* check for extended values */
    if (inf.Type == eExtension_Extended) {
        switch (inf.Root.Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
            switch (inf.Root.Constraint) {
            case ePERSTIConstraint_Unconstrained:
                inf.Type = eExtension_Extendable;
                break;
            case ePERSTIConstraint_Semiconstrained:
                if (inf.NOctets == 0) {
                    sprintf(lbbuf, "%s_lb", inf.Identifier);
                    outputvarintx(lbbuf, &inf.Root.LowerVal);
                    output("if (ASN1intx_cmp(%s, &%s) >= 0) {\n",
                        Reference(valref), lbbuf);
                } else if (inf.Root.Data == ePERSTIData_Integer) {
                    output("if (%s >= %d) {\n",
                        valref, intx2int32(&inf.Root.LowerVal));
                } else {
                    if (intx2uint32(&inf.Root.LowerVal) > 0) {
                        output("if (%s >= %u) {\n",
                            valref, intx2uint32(&inf.Root.LowerVal));
                    } else {
                        inf.Type = eExtension_Extendable;
                    }
                }
                break;
            case ePERSTIConstraint_Upperconstrained:
                if (inf.NOctets == 0) {
                    sprintf(ubbuf, "%s_ub", inf.Identifier);
                    outputvarintx(ubbuf, &inf.Root.UpperVal);
                    output("if (ASN1intx_cmp(%s, &%s) <= 0) {\n",
                        Reference(valref), ubbuf);
                } else if (inf.Root.Data == ePERSTIData_Integer) {
                    output("if (%s <= %d) {\n",
                        valref, intx2int32(&inf.Root.UpperVal));
                } else {
                    output("if (%s <= %u) {\n",
                        valref, intx2uint32(&inf.Root.UpperVal));
                }
                break;
            case ePERSTIConstraint_Constrained:
                if (inf.NOctets == 0) {
                    sprintf(lbbuf, "%s_lb", inf.Identifier);
                    sprintf(ubbuf, "%s_ub", inf.Identifier);
                    outputvarintx(lbbuf, &inf.Root.LowerVal);
                    outputvarintx(ubbuf, &inf.Root.UpperVal);
                    output("if (ASN1intx_cmp(%s, &%s) >= 0 && ASN1intx_cmp(%s, &%s) <= 0) {\n",
                        Reference(valref), lbbuf, Reference(valref), ubbuf);
                } else if (inf.Root.Data == ePERSTIData_Integer) {
                    output("if (%s >= %d && %s <= %d) {\n",
                        valref, intx2int32(&inf.Root.LowerVal),
                        valref, intx2int32(&inf.Root.UpperVal));
                } else {
                    if (intx2uint32(&inf.Root.LowerVal) > 0) {
                        output("if (%s >= %u && %s <= %u) {\n",
                            valref, intx2uint32(&inf.Root.LowerVal),
                            valref, intx2uint32(&inf.Root.UpperVal));
                    } else {
                        output("if (%s <= %u) {\n",
                            valref, intx2uint32(&inf.Root.UpperVal));
                    }
                }
                break;
            }
            break;
        case ePERSTIData_SequenceOf:
        case ePERSTIData_SetOf:
        case ePERSTIData_OctetString:
        case ePERSTIData_UTF8String:
        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:
        case ePERSTIData_Extension:
            switch (inf.Root.LConstraint) {
            case ePERSTIConstraint_Semiconstrained:
                if (inf.Root.LLowerVal != 0) {
                    output("if (%s >= %u) {\n",
                        lenref, inf.Root.LLowerVal);
                } else {
                    inf.Type = eExtension_Extendable;
                }
                break;
            case ePERSTIConstraint_Constrained:
                if (inf.Root.LLowerVal != 0) {
                    output("if (%s >= %u && %s <= %u) {\n",
                        lenref, inf.Root.LLowerVal, lenref, inf.Root.LUpperVal);
                } else {
                    output("if (%s <= %u) {\n",
                        lenref, inf.Root.LUpperVal);
                }
                break;
            }
            break;
        case ePERSTIData_String:
        case ePERSTIData_TableString:
        case ePERSTIData_ZeroString:
        case ePERSTIData_ZeroTableString:
            inf.Type = eExtension_Extendable;
            switch (inf.Root.LConstraint) {
            case ePERSTIConstraint_Semiconstrained:
                if (inf.Root.LLowerVal != 0) {
                    output("if (%s >= %u",
                        lenref, inf.Root.LLowerVal);
                    inf.Type = eExtension_Extended;
                }
                break;
            case ePERSTIConstraint_Constrained:
                output("if (%s >= %u && %s <= %u",
                    lenref, inf.Root.LLowerVal, lenref, inf.Root.LUpperVal);
                inf.Type = eExtension_Extended;
                break;
            }
            if (inf.Root.TableIdentifier) {
                if (inf.Type == eExtension_Extended)
                    output(" && ");
                else
                    output("if (");
                if (inf.NOctets == 1) {
                    p = "Char";
                } else if (inf.NOctets == 2) {
                    p = "Char16";
                } else if (inf.NOctets == 4) {
                    p = "Char32";
                } else
                    MyAbort();
                output("ASN1PEREncCheckTable%sString(%s, %s, %s)",
                    p, lenref, valref, Reference(inf.Root.TableIdentifier));
                inf.Type = eExtension_Extended;
            }
            if (inf.Type == eExtension_Extended)
                output(") {\n");
            break;
        }
    }

    /* encode unset extension bit */
    if (inf.Type > eExtension_Unextended) {
        if (g_fCaseBasedOptimizer)
        {
            output("if (!ASN1PEREncExtensionBitClear(%s))\n", encref);
        }
        else
        {
            output("if (!ASN1PEREncBitVal(%s, 1, 0))\n", encref);
        }
        output("return 0;\n");
    }

    /* encode unextended value (of extension root) */
    GenPEREncGenericUnextended(ass, &inf, &inf.Root, valref, lenref, encref);

    /* type is extended? */
    if (inf.Type == eExtension_Extended) {
        output("} else {\n");

        /* encode set extension bit */
        if (g_fCaseBasedOptimizer)
        {
            output("if (!ASN1PEREncExtensionBitSet(%s))\n", encref);
        }
        else
        {
            output("if (!ASN1PEREncBitVal(%s, 1, 1))\n", encref);
        }
        output("return 0;\n");

        /* encode extended value (of extension addition) */
        GenPEREncGenericUnextended(ass, &inf, &inf.Additional, valref, lenref, encref);
        output("}\n");
    }
}

/* generate encoding statements for a simple value (after some special */
/* handling has been done, esp. the evaluation of the extension) */
void GenPEREncGenericUnextended(AssignmentList_t ass, PERTypeInfo_t *info, PERSimpleTypeInfo_t *sinfo, char *valref, char *lenref, char *encref)
{
    char valbuf[256];
    char *lvref, lvbuf[256];
    char lbbuf[256];
    char *p;

    /* check for empty field */
    if (sinfo->NBits == 0)
        return;

    /* initial calculations for value encoding: */
    /* substract lower bound of constraint/semiconstraint value */
    /* for Integer and NormallySmall */
    switch (sinfo->Constraint) {
    case ePERSTIConstraint_Semiconstrained:
    case ePERSTIConstraint_Constrained:
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
        case ePERSTIData_NormallySmall:
            if (!info->NOctets) {

                /* calculate value-lowerbound for intx_t values */
                if (intx_cmp(&sinfo->LowerVal, &intx_0) != 0) {
                    sprintf(lbbuf, "%s_lb", info->Identifier);
                    outputvar("ASN1intx_t newval;\n");
                    outputvarintx(lbbuf, &sinfo->LowerVal);
                    output("ASN1intx_sub(&newval, %s, &%s);\n",
                        Reference(valref), lbbuf);
                    valref = "newval";
                }
            } else if (sinfo->Data == ePERSTIData_Integer) {

                /* calculate value-lowerbound for intx_t values */
                if (intx_cmp(&sinfo->LowerVal, &intx_0)) {
                    char szLowB[24];
                    sprintf(&szLowB[0], "%d", intx2int32(&sinfo->LowerVal));
                    if (szLowB[0] == '-')
                        sprintf(valbuf, "%s + %s", valref, &szLowB[1]); // minus minus become plus
                    else
                        sprintf(valbuf, "%s - %s", valref, &szLowB[0]);
                    valref = valbuf;
                }
            } else {

                /* calculate value-lowerbound for integer values */
                if (intx_cmp(&sinfo->LowerVal, &intx_0)) {
                    sprintf(valbuf, "%s - %u", valref, intx2uint32(&sinfo->LowerVal));
                    valref = valbuf;
                }
            }

            /* semiconstraint/constraint values will be encoded as unsigned */
            if (sinfo->Data == ePERSTIData_Integer)
                sinfo->Data = ePERSTIData_Unsigned;
            break;
        }
        break;
    }

    /* general rules */
    if (sinfo->LAlignment == ePERSTIAlignment_OctetAligned &&
        sinfo->Length == ePERSTILength_BitLength &&
        !(sinfo->LNBits & 7))
        sinfo->Alignment = ePERSTIAlignment_BitAligned;
                                /* octet alignment will be given by length */
    if (sinfo->Length == ePERSTILength_InfiniteLength &&
        (sinfo->Data == ePERSTIData_Integer && info->NOctets == 0 ||
        sinfo->Data == ePERSTIData_Unsigned && info->NOctets == 0 ||
        sinfo->Data == ePERSTIData_BitString ||
        sinfo->Data == ePERSTIData_RZBBitString ||
        sinfo->Data == ePERSTIData_Extension ||
        sinfo->Data == ePERSTIData_OctetString ||
        sinfo->Data == ePERSTIData_UTF8String ||
        sinfo->Data == ePERSTIData_SequenceOf ||
        sinfo->Data == ePERSTIData_SetOf ||
        sinfo->Data == ePERSTIData_String ||
        sinfo->Data == ePERSTIData_TableString ||
        sinfo->Data == ePERSTIData_ZeroString ||
        sinfo->Data == ePERSTIData_ZeroTableString) ||
        sinfo->Data == ePERSTIData_ObjectIdentifier ||
        sinfo->Data == ePERSTIData_Real ||
        sinfo->Data == ePERSTIData_GeneralizedTime ||
        sinfo->Data == ePERSTIData_UTCTime ||
        sinfo->Data == ePERSTIData_External ||
        sinfo->Data == ePERSTIData_EmbeddedPdv ||
        sinfo->Data == ePERSTIData_MultibyteString ||
        sinfo->Data == ePERSTIData_UnrestrictedString ||
        sinfo->Data == ePERSTIData_Open)
        sinfo->LAlignment = sinfo->Alignment = ePERSTIAlignment_BitAligned;
                                /* alignment will be done by encoding fn */
    if (sinfo->Length == ePERSTILength_NoLength ||
        sinfo->Length == ePERSTILength_SmallLength)
        sinfo->LAlignment = ePERSTIAlignment_BitAligned;
                                /* no alignment of no/small length */

    /* special initial calculations */
    switch (sinfo->Data) {
    case ePERSTIData_RZBBitString:

        /* remove trailing zero-bits */
        outputvar("ASN1uint32_t r;\n");
        output("r = %s;\n", lenref);
        output("ASN1PEREncRemoveZeroBits(&r, %s, %u);\n",
            valref, sinfo->LLowerVal);
        if (sinfo->LLowerVal) {
            outputvar("ASN1uint32_t s;\n");
            output("s = r < %u ? %u : r;\n", sinfo->LLowerVal, sinfo->LLowerVal);
            lenref = "s";
        } else {
            lenref = "r";
        }
            break;
    }

    if (g_fCaseBasedOptimizer)
    {
        // lonchanc: special handling for macro operations
        if (PerOptCase_IsSignedInteger(sinfo))
        {
            output("if (!ASN1PEREncInteger(%s, %s))\n", encref, valref);
            output("return 0;\n");
            return;
        }
        if (PerOptCase_IsUnsignedInteger(sinfo))
        {
            output("if (!ASN1PEREncUnsignedInteger(%s, %s))\n", encref, valref);
            output("return 0;\n");
            return;
        }
        if (PerOptCase_IsUnsignedShort(sinfo))
        {
            output("if (!ASN1PEREncUnsignedShort(%s, %s))\n", encref, valref);
            output("return 0;\n");
            return;
        }
        if (PerOptCase_IsBoolean(sinfo))
        {
            output("if (!ASN1PEREncBoolean(%s, %s))\n", encref, valref);
            output("return 0;\n");
            return;
        }
    }

    /* initial calculations for length: */
    /* get length of integer numbers if length req. */
    switch (sinfo->Length) {
    case ePERSTILength_BitLength:
    case ePERSTILength_InfiniteLength:
        switch (sinfo->Constraint) {
        case ePERSTIConstraint_Unconstrained:
        case ePERSTIConstraint_Upperconstrained:
            switch (sinfo->Data) {
            case ePERSTIData_Integer:
            case ePERSTIData_Unsigned:
                if (info->NOctets != 0) {
                    outputvar("ASN1uint32_t l;\n");
                    if (sinfo->Data == ePERSTIData_Integer)
                        output("l = ASN1int32_octets(%s);\n", valref);
                    else
                        output("l = ASN1uint32_octets(%s);\n", valref);
                    lenref = "l";
                } else {
                    if (sinfo->Length != ePERSTILength_InfiniteLength) {
                        outputvar("ASN1uint32_t l;\n");
                        output("l = ASN1intx_octets(%s);\n",
                            Reference(valref));
                        lenref = "l";
                    }
                }
                break;
            }
            break;
        case ePERSTIConstraint_Semiconstrained:
        case ePERSTIConstraint_Constrained:
            switch (sinfo->Data) {
            case ePERSTIData_Integer:
            case ePERSTIData_Unsigned:
                if (info->NOctets != 0) {
                    outputvar("ASN1uint32_t l;\n");
                    output("l = ASN1uint32_uoctets(%s);\n", valref);
                    lenref = "l";
                } else {
                    if (sinfo->Length != ePERSTILength_InfiniteLength) {
                        outputvar("ASN1uint32_t l;\n");
                        output("l = ASN1intx_uoctets(%s);\n",
                            Reference(valref));
                        lenref = "l";
                    }
                }
                break;
            }
            break;
        }
        break;
    }

    /* initial settings for length enconding: */
    /* substract lower bound of length from length */
    if (sinfo->LLowerVal != 0 && lenref) {
        sprintf(lvbuf, "%s - %u", lenref, sinfo->LLowerVal);
        lvref = lvbuf;
    } else {
        lvref = lenref;
    }

    /* length encoding */
    if (sinfo->LAlignment == ePERSTIAlignment_OctetAligned) {
        output("ASN1PEREncAlignment(%s);\n", encref);
    }
    switch (sinfo->Length) {
    case ePERSTILength_NoLength:

        /* not length used */
        break;

    case ePERSTILength_BitLength:

        /* length will be encoded in a bit field */
        output("if (!ASN1PEREncBitVal(%s, %u, %s))\n",
            encref, sinfo->LNBits, lvref);
        output("return 0;\n");
        break;

    case ePERSTILength_InfiniteLength:

        /* infinite length case: encode length only for integer values, */
        /* other length encodings will be the encoding function */
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
            if (info->NOctets != 0) {
                output("if (!ASN1PEREncBitVal(%s, 8, %s))\n",
                    encref, lvref);
                output("return 0;\n");
            }
            break;
        }
        break;
    }

    /* special initial calculations */
    switch (sinfo->Data) {
    case ePERSTIData_RZBBitString:

        /* real length of the bit string */
        lenref = "r";
        break;
    }

    /* value encoding */
    switch (sinfo->Length) {
    case ePERSTILength_NoLength:

        /* encode alignment of the value */
        if (sinfo->Alignment == ePERSTIAlignment_OctetAligned) {
            output("ASN1PEREncAlignment(%s);\n", encref);
        }

        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:

            /* encode the value as bit field */
            if (info->NOctets != 0) {
                output("if (!ASN1PEREncBitVal(%s, %u, %s))\n",
                    encref, sinfo->NBits, valref);
                output("return 0;\n");
            } else {
                output("if (!ASN1PEREncBitIntx(%s, %u, %s))\n",
                    encref, sinfo->NBits, Reference(valref));
                output("return 0;\n");
            }
            break;

        case ePERSTIData_NormallySmall:

            /* encode the value as normally small number */
            output("if (!ASN1PEREncNormallySmall(%s, %s))\n",
                encref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:

            /* encode bit string in a bit field */
            output("if (!ASN1PEREncBits(%s, %s, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_OctetString:

            /* encode octet string in a bit field */
            output("if (!ASN1PEREncBits(%s, %s * 8, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_UTF8String:

            /* encode octet string in a bit field */
            output("if (!ASN1PEREncUTF8String(%s, %s, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_Extension:

            /* encode extension bits in a bit field */
            output("if (!ASN1PEREncBits(%s, %u, %s))\n",
                encref, sinfo->NBits, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_SetOf:

            /* same as BitLength encoding */
            goto SetOfEncoding;

        case ePERSTIData_SequenceOf:

            /* same as BitLength encoding */
            goto SequenceOfEncoding;

        case ePERSTIData_String:
        case ePERSTIData_ZeroString:

            /* same as BitLength encoding */
            goto StringEncoding;

        case ePERSTIData_TableString:
        case ePERSTIData_ZeroTableString:

            /* same as BitLength encoding */
            goto TableStringEncoding;
            
        case ePERSTIData_Reference:

            /* call encoding function of referenced type */
            output("if (!ASN1Enc_%s(%s, %s))\n",
                Identifier2C(sinfo->SubIdentifier),
                encref, Reference(valref));
            output("return 0;\n");
            break;

        case ePERSTIData_Real:

            /* encode real value */
            if (info->NOctets)
                output("if (!ASN1PEREncDouble(%s, %s))\n",
                    encref, valref);
            else
                output("if (!ASN1PEREncReal(%s, %s))\n",
                    encref, Reference(valref));
            output("return 0;\n");
            break;

        case ePERSTIData_GeneralizedTime:

            /* encode generalized time value */
            output("if (!ASN1PEREncGeneralizedTime(%s, %s, %d))\n",
                encref, Reference(valref), sinfo->NBits);
            output("return 0;\n");
            break;

        case ePERSTIData_UTCTime:

            /* encode utc time value */
            output("if (!ASN1PEREncUTCTime(%s, %s, %d))\n",
                encref, Reference(valref), sinfo->NBits);
            output("return 0;\n");
            break;
        }
        break;

    case ePERSTILength_BitLength:

        /* encode alignment of the value */
        if (sinfo->Alignment == ePERSTIAlignment_OctetAligned) {
            output("ASN1PEREncAlignment(%s);\n", encref);
        }

        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:

            /* encode the value as bit field */
            if (info->NOctets != 0) {
                output("if (!ASN1PEREncBitVal(%s, %s * 8, %s))\n",
                    encref, lenref, valref);
                output("return 0;\n");
            } else {
                output("if (!ASN1PEREncBitIntx(%s, %s * 8, %s))\n",
                    encref, lenref, Reference(valref));
                output("return 0;\n");
            }
            break;

        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:

            /* encode the value as bit field */
            output("if (!ASN1PEREncBits(%s, %s, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_OctetString:

            /* encode the value as bit field */
            output("if (!ASN1PEREncBits(%s, %s * 8, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_UTF8String:

            /* encode the value as bit field */
            output("if (!ASN1PEREncUTF8String(%s, %s, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_SetOf:
        SetOfEncoding:

            /* skip null set of */
            if (sinfo->SubType->Flags & eTypeFlags_Null)
                break;

            /* canonical PER? */
            if (g_eSubEncodingRule == eSubEncoding_Canonical) {

                /* encode the elements one by one and sort them */
                outputvar("ASN1uint32_t i;\n");
                outputvar("ASN1encoding_t e, *p;\n");
                if (info->Rules &
                    (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList))
                    MyAbort(); /*XXX*/
                output("if (%s) {\n", lenref);
                output("e = p = (ASN1encoding_t)malloc(%s * sizeof(ASN1encoding_t));\n",
                    lenref);
                output("ZeroMemory(b, %s * sizeof(ASN1encoding_t));\n", lenref);
                output("for (i = 0; i < %s; i++, p++) {\n", lenref);
                sprintf(valbuf, "(%s)[i]", valref);
                GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, valbuf, eEncode, encref);
                output("}\n");
                output("qsort(e, %s, sizeof(ASN1encoding_t), ASN1PEREncCmpEncodings);\n",
                    lenref);
                output("}\n");

                /* then dump them */
                output("for (p = e, i = 0; i < %s; i++, p++) {\n", lenref);
                output("if (!ASN1PEREncBits(%s, (p->pos - p->buf) * 8 + p->bit, p->buf))\n",
                    encref);
                output("return 0;\n");
                output("}\n");
                break;
            }

            /* again in non-canonical PER: */
            /*FALLTHROUGH*/
        case ePERSTIData_SequenceOf:
        SequenceOfEncoding:

            /* skip null sequence of */
            if (sinfo->SubType->Flags & eTypeFlags_Null)
                break;

            if (info->Rules & eTypeRules_PointerArrayMask)
            {
                /* loop over all elements */
                outputvar("ASN1uint32_t i;\n");
                output("for (i = 0; i < %s; i++) {\n", lenref);
                sprintf(valbuf, "(%s)[i]", valref);

            }
            else
            if (info->Rules & eTypeRules_LinkedListMask)
            {
                /* iterate over all elements */
                outputvar("P%s f;\n", info->Identifier);
                output("for (f = %s; f; f = f->next) {\n", valref);
                sprintf(valbuf, "f->%s", GetPrivateValueName(info->pPrivateDirectives, "value"));
            }

            /* encode the element */
            GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, valbuf,
                eEncode, encref);

            /* loop end */
            output("}\n");
            break;

        case ePERSTIData_String:
        case ePERSTIData_ZeroString:
        StringEncoding:

            /* encode string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            output("if (!ASN1PEREnc%sString(%s, %s, %s, %u))\n",
                p, encref, lenref, valref, sinfo->NBits);
            output("return 0;\n");
            break;

        case ePERSTIData_TableString:
        case ePERSTIData_ZeroTableString:
        TableStringEncoding:

            /* encode table string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            output("if (!ASN1PEREncTable%sString(%s, %s, %s, %u, %s))\n",
                p, encref, lenref, valref, sinfo->NBits, Reference(sinfo->TableIdentifier));
            output("return 0;\n");
            break;
        }
        break;

    case ePERSTILength_InfiniteLength:
        /* infinite length case */

        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:

            /* encode an integer in fragmented format */
            if (info->NOctets != 0) {
                output("if (!ASN1PEREncBitVal(%s, %s * 8, %s))\n",
                    encref, lenref, valref);
                output("return 0;\n");
            } else {
                if (sinfo->Data == ePERSTIData_Integer) {
                    output("if (!ASN1PEREncFragmentedIntx(%s, %s))\n",
                        encref, Reference(valref));
                    output("return 0;\n");
                } else {
                    output("if (!ASN1PEREncFragmentedUIntx(%s, %s))\n",
                        encref, Reference(valref));
                    output("return 0;\n");
                }
            }
            break;

        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:

            /* encode bit string in fragmented format */
            output("if (!ASN1PEREncFragmented(%s, %s, %s, 1))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_OctetString:

            /* encode octet string in fragmented format */
            output("if (!ASN1PEREncFragmented(%s, %s, %s, 8))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_UTF8String:

            /* encode octet string in fragmented format */
            output("if (!ASN1PEREncUTF8String(%s, %s, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_Extension:

            /* encode extension bits in fragmented format */
            output("if (!ASN1PEREncFragmented(%s, %u, %s, 1))\n",
                encref, sinfo->NBits, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_SetOf:

            /* skip null set of */
            if (sinfo->SubType->Flags & eTypeFlags_Null)
                break;

            /* canonical PER? */
            if (g_eSubEncodingRule == eSubEncoding_Canonical) {

                /* encode the elements one by one and sort them */
                outputvar("ASN1uint32_t i;\n");
                outputvar("ASN1uint32_t j, n = 0x4000;\n");
                outputvar("ASN1encoding_t e, *p;\n");
                if (info->Rules &
                    (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList))
                    MyAbort(); /*XXX*/
                output("if (%s) {\n", lenref);
                output("e = p = (ASN1encoding_t)malloc(%s * sizeof(ASN1encoding_t));\n",
                    lenref);
                output("ZeroMemory(b, %s * sizeof(ASN1encoding_t));\n", lenref);
                output("for (i = 0; i < %s; i++, p++) {\n", lenref);
                sprintf(valbuf, "(%s)[i]", valref);
                GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, valbuf, eEncode, encref);
                output("}\n");
                output("qsort(e, %s, sizeof(ASN1encoding_t), ASN1PEREncCmpEncodings);\n",
                    lenref);
                output("}\n");

                /* then dump them */
                output("for (p = e, i = 0; i < %s; i += n) {\n", lenref);
                output("if (!ASN1PEREncFragmentedLength(&n, %s, %s - i))\n",
                    encref, lenref);
                output("return 0;\n");
                output("for (j = 0; j < n; p++, j++) {\n");
                output("if (!ASN1PEREncBits(%s, (p->pos - p->buf) * 8 + p->bit, p->buf))\n",
                    encref);
                output("return 0;\n");
                output("}\n");
                output("}\n");
                output("}\n");
                output("if (n >= 0x4000) {\n");
                output("if (!ASN1PEREncFragmentedLength(&n, %s, 0))\n",
                    encref);
                output("return 0;\n");
                output("}\n");
                break;
            }

            /* again in non-canonical PER: */
            /*FALLTHROUGH*/
        case ePERSTIData_SequenceOf:

            /* skip null sequence of */
            if (sinfo->SubType->Flags & eTypeFlags_Null)
                break;
            outputvar("ASN1uint32_t i;\n");
            outputvar("ASN1uint32_t j, n = 0x4000;\n");

            if (info->Rules &
                (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList)) {

                /* additional iterator needed */
                outputvar("P%s f;\n", info->Identifier);
                output("f = %s;\n", valref);
            }

            /* encode all elements */
            output("for (i = 0; i < %s;) {\n", lenref);

            /* encode fragmented length */
            output("if (!ASN1PEREncFragmentedLength(&n, %s, %s - i))\n",
                encref, lenref);
            output("return 0;\n");

            /* encode elements of the fragment */
            output("for (j = 0; j < n; i++, j++) {\n");
            if (info->Rules & eTypeRules_PointerArrayMask)
            {
                sprintf(valbuf, "(%s)[i]", valref);
            }
            else if (info->Rules & eTypeRules_LinkedListMask)
            {
                sprintf(valbuf, "f->%s", GetPrivateValueName(info->pPrivateDirectives, "value"));
            }
            else
            {
                MyAbort();
            }
            GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, valbuf,
                eEncode, encref);

            /* advance the iterator */
            if (info->Rules & eTypeRules_LinkedListMask)
            {
                output("f = f->next;\n");
            }

            /* end of inner loop */
            output("}\n");

            /* end of outer loop */
            output("}\n");

            /* add an zero-sized fragment if needed */
            output("if (n >= 0x4000) {\n");
            output("if (!ASN1PEREncFragmentedLength(&n, %s, 0))\n",
                encref);
            output("return 0;\n");
            output("}\n");
            break;

        case ePERSTIData_ObjectIdentifier:

            if (info->pPrivateDirectives->fOidArray || g_fOidArray)
            {
                /* encode object identifier value */
                output("if (!ASN1PEREncObjectIdentifier2(%s, %s))\n",
                    encref, Reference(valref));
            }
            else
            {
                /* encode object identifier value */
                output("if (!ASN1PEREncObjectIdentifier(%s, %s))\n",
                    encref, Reference(valref));
            }
            output("return 0;\n");
            break;

        case ePERSTIData_External:

            /* encode external value */
            output("if (!ASN1PEREncExternal(%s, %s))\n",
                encref, Reference(valref));
            output("return 0;\n");
            break;

        case ePERSTIData_EmbeddedPdv:

            /* encode embedded pdv value */
            if (sinfo->Identification) {
                output("if (!ASN1PEREncEmbeddedPdvOpt(%s, %s))\n",
                    encref, Reference(valref));
            } else {
                output("if (!ASN1PEREncEmbeddedPdv(%s, %s))\n",
                    encref, Reference(valref));
            }
            output("return 0;\n");
            break;

        case ePERSTIData_MultibyteString:

            /* encode multibyte string value */
            output("if (!ASN1PEREncMultibyteString(%s, %s))\n",
                encref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_UnrestrictedString:

            /* encode character string value */
            if (sinfo->Identification) {
                output("if (!ASN1PEREncCharacterStringOpt(%s, %s))\n",
                    encref, Reference(valref));
            } else {
                output("if (!ASN1PEREncCharacterString(%s, %s))\n",
                    encref, Reference(valref));
            }
            output("return 0;\n");
            break;

        case ePERSTIData_String:
        case ePERSTIData_ZeroString:

            /* encode string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            output("if (!ASN1PEREncFragmented%sString(%s, %s, %s, %u))\n",
                p, encref, lenref, valref, sinfo->NBits);
            output("return 0;\n");
            break;

        case ePERSTIData_TableString:
        case ePERSTIData_ZeroTableString:

            /* encode table string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            output("if (!ASN1PEREncFragmentedTable%sString(%s, %s, %s, %u, %s))\n",
                p, encref, lenref, valref, sinfo->NBits, Reference(sinfo->TableIdentifier));
            output("return 0;\n");
            break;

        case ePERSTIData_Open:

            /* encode open type value */
            output("if (!ASN1PEREncOpenType(%s, %s))\n",
                encref, Reference(valref));
            output("return 0;\n");
            break;
        }
        break;

    case ePERSTILength_SmallLength:
        /* small length */

        switch (sinfo->Data) {
        case ePERSTIData_Extension:
            /* encode extension bits with normally small length */
            output("if (!ASN1PEREncNormallySmallBits(%s, %u, %s))\n",
                encref, sinfo->NBits, valref);
            output("return 0;\n");
            break;
        }
    }

    switch (sinfo->Data) {
    case ePERSTIData_RZBBitString:

        /* encode additional zero bits for remove zero bits bit string */
        /* of short length */
        if (sinfo->LLowerVal) {
            output("if (%s < %u) {\n", lenref, sinfo->LLowerVal);
            output("if (!ASN1PEREncZero(%s, %u - %s))\n",
                encref, sinfo->LLowerVal, lenref);
            output("return 0;\n");
            output("}\n");
        }
    }

    /* free calculated intx_t value */
    switch (sinfo->Constraint) {
    case ePERSTIConstraint_Semiconstrained:
    case ePERSTIConstraint_Constrained:
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
        case ePERSTIData_NormallySmall:
            if (!info->NOctets) {
                if (intx_cmp(&sinfo->LowerVal, &intx_0) != 0) {
                    output("ASN1intx_free(&newval);\n");
                }
            }
            break;
        }
        break;
    }
}

/* generate decoding statements for a simple value */
void
GenPERDecSimpleType(AssignmentList_t ass, PERTypeInfo_t *info, char *valref, char *encref)
{
    uint32_t i;
    char *oldvalref;
    char valbuf[256], lenbuf[256];
    char *lenref;
    PERTypeInfo_t inf;

    inf = *info;

    /* examine type for special handling */
    switch (inf.Root.Data) {
    case ePERSTIData_BitString:
    case ePERSTIData_RZBBitString:

        if (inf.Root.cbFixedSizeBitString)
        {
            sprintf(lenbuf, "%u", inf.Root.LUpperVal);
            sprintf(valbuf, "%s", valref);
            lenref = lenbuf;
            valref = valbuf;
            break;
        }

        // lonchanc: intentionally fall through

    case ePERSTIData_OctetString:

        if (g_fCaseBasedOptimizer)
        {
            if (inf.Root.Data == ePERSTIData_OctetString && inf.Type == eExtension_Unextended)
            {
                switch (inf.Root.Length)
                {
                case ePERSTILength_NoLength:
                    if (inf.Root.LConstraint == ePERSTIConstraint_Constrained &&
                        inf.Root.LLowerVal == inf.Root.LUpperVal &&
                        inf.Root.LUpperVal < 64 * 1024)
                    {
                        // fixed size constraint, eg. OCTET STRING (SIZE (8))
                        if (inf.pPrivateDirectives->fLenPtr)
                        {
                            output("if (!ASN1PERDecOctetString_FixedSizeEx(%s, %s, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal);
                        }
                        else
                        {
                            output("if (!ASN1PERDecOctetString_FixedSize(%s, (ASN1octetstring2_t *) %s, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal);
                        }
                        output("return 0;\n");
                        return;
                    }
                    break;
                case ePERSTILength_Length:
                    break;
                case ePERSTILength_BitLength:
                    if (inf.Root.LConstraint == ePERSTIConstraint_Constrained &&
                        inf.Root.LLowerVal < inf.Root.LUpperVal &&
                        inf.Root.LUpperVal < 64 * 1024)
                    {
                        // variable size constraint, eg. OCTET STRING (SIZE (4..16))
                        if (inf.pPrivateDirectives->fLenPtr)
                        {
                            output("if (!ASN1PERDecOctetString_VarSizeEx(%s, %s, %u, %u, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal, inf.Root.LUpperVal, inf.Root.LNBits);
                        }
                        else
                        {
                            output("if (!ASN1PERDecOctetString_VarSize(%s, (ASN1octetstring2_t *) %s, %u, %u, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal, inf.Root.LUpperVal, inf.Root.LNBits);
                        }
                        output("return 0;\n");
                        return;
                    }
                    break;
                case ePERSTILength_SmallLength:
                    break;
                case ePERSTILength_InfiniteLength: // no size constraint
                    /* get octet string as fragmented */
                    if (valref)
                    {
                        output("if (!ASN1PERDecOctetString_NoSize(%s, %s))\n",
                            encref, Reference(valref));
                        output("return 0;\n");
                        return;
                    }
                    break;
               } // switch
           } // if
        }
    
        /* length and value of bit string/octet string/string value */
        sprintf(lenbuf, "(%s).length", valref);
        sprintf(valbuf, "(%s).value", valref);
        lenref = lenbuf;
        valref = valbuf;
        break;

    case ePERSTIData_UTF8String:

        /* length and value of bit string/octet string/string value */
        sprintf(lenbuf, "(%s).length", valref);
        sprintf(valbuf, "(%s).value", valref);
        lenref = lenbuf;
        valref = valbuf;
        break;

    case ePERSTIData_String:
    case ePERSTIData_TableString:

        /* length and value of bit string/octet string/string value */
        sprintf(lenbuf, "(%s).length", valref);
        sprintf(valbuf, "(%s).value", valref);
        lenref = lenbuf;
        valref = valbuf;
        break;

    case ePERSTIData_SequenceOf:
    case ePERSTIData_SetOf:

        if (inf.Rules & eTypeRules_PointerArrayMask)
        {
            /* length and value of sequence of/set of value with */
            /* length-pointer representation */
            if (inf.Rules & eTypeRules_PointerToElement)
            {
                sprintf(lenbuf, "(%s)->count", valref);
                sprintf(valbuf, "(%s)->%s", valref, GetPrivateValueName(inf.pPrivateDirectives, "value"));
            }
            else
            {
                sprintf(lenbuf, "(%s)->count", Reference(valref));
                sprintf(valbuf, "(%s)->%s", Reference(valref), GetPrivateValueName(inf.pPrivateDirectives, "value"));
            }
            lenref = lenbuf;
            valref = valbuf;
        }
        else
        if (inf.Rules & eTypeRules_LinkedListMask)
        {
            if (g_fCaseBasedOptimizer)
            {
                if (PerOptCase_IsTargetSeqOf(&inf))
                {
                    // generate the iterator
                    char szElmFn[128];
                    char szElmFnDecl[256];
                    sprintf(szElmFn, "ASN1Dec_%s_ElmFn", inf.Identifier);
                    sprintf(szElmFnDecl, "int ASN1CALL %s(ASN1decoding_t %s, P%s val)",
                        szElmFn, encref, inf.Identifier);

                    setoutfile(g_finc);
                    output("extern %s;\n", szElmFnDecl);
                    setoutfile(g_fout);

                    if ((inf.Root.LLowerVal == 0 && inf.Root.LUpperVal == 0) ||
                        (inf.Root.LUpperVal >= 64 * 1024)
                       )
                    {
                        output("return ASN1PERDecSeqOf_NoSize(%s, (ASN1iterator_t **) %s, (ASN1iterator_decfn) %s, sizeof(*%s));\n",
                            encref, Reference(valref), szElmFn, valref);
                    }
                    else
                    {
                        if (inf.Root.LLowerVal == inf.Root.LUpperVal)
                            MyAbort();
                        output("return ASN1PERDecSeqOf_VarSize(%s, (ASN1iterator_t **) %s, (ASN1iterator_decfn) %s, sizeof(*%s), %u, %u, %u);\n",
                            encref, Reference(valref), szElmFn, valref,
                            inf.Root.LLowerVal, inf.Root.LUpperVal, inf.Root.LNBits);
                    }
                    output("}\n\n"); // end of iterator body

                    // generate the element function
                    output("static %s\n", szElmFnDecl);
                    output("{\n");
                    sprintf(valbuf, "val->%s", GetPrivateValueName(inf.pPrivateDirectives, "value"));
                    GenPERFuncSimpleType(ass, &inf.Root.SubType->PERTypeInfo, valbuf,
                            eDecode, encref);
                    // end of element body
                    return;
                }
            }

            /* use a loop for sequence of/set of value with */
            /* list representation */
            outputvar("P%s *f;\n", inf.Identifier);
            lenref = NULL;

        } else {
            MyAbort();
        }
        break;

    case ePERSTIData_Extension:

        /* length of extension */
        if (inf.Root.Length == ePERSTILength_SmallLength)
            lenref = "e";
            else
            lenref = NULL;
        break;

    case ePERSTIData_Boolean:

        if (g_fCaseBasedOptimizer)
        {
            if (PerOptCase_IsBoolean(&inf.Root))
            {
                lenref = NULL;
                break;
            }
        }

        /* boolean value */
        inf.Root.Data = ePERSTIData_Unsigned;
        lenref = NULL;
        break;

    default:

        /* other values have no additional length */
        lenref = NULL;
        break;
    }

    /* check for extended values */
    if (inf.Type > eExtension_Unextended) {
        outputvar("ASN1uint32_t x;\n");
        if (g_fCaseBasedOptimizer)
        {
            output("if (!ASN1PERDecExtensionBit(%s, &x))\n", encref);
        }
        else
        {
            output("if (!ASN1PERDecBit(%s, &x))\n", encref);
        }
        output("return 0;\n");
        output("if (!x) {\n");
    }

    /* additional variable for enumeraton value mapping */
    oldvalref = valref;
    if (inf.EnumerationValues && valref) {
        outputvar("ASN1uint32_t u;\n");
        valref = "u";
        inf.NOctets = 4;
    }

    /* decode unextended value (of extension root) */
    GenPERDecGenericUnextended(ass, &inf, &inf.Root, valref, lenref, encref);

    /* map enumeration values if type is extendable */
    if (inf.EnumerationValues && oldvalref &&
        inf.Type == eExtension_Extendable) {
        output("switch (u) {\n");
        for (i = 0; inf.EnumerationValues[i]; i++) {
            output("case %u:\n", i);
            output("%s = %u;\n", oldvalref, intx2uint32(inf.EnumerationValues[i]));
            output("break;\n");
        }
        output("}\n");
    }

    /* type is extendable? */
    if (inf.Type > eExtension_Unextended) {
        output("} else {\n");
        if (inf.Type == eExtension_Extendable)
            valref = lenref = NULL;

        /* decode extended value (of extension addition) */
        GenPERDecGenericUnextended(ass, &inf, &inf.Additional, valref, lenref, encref);
        output("}\n");
    }

    /* map enumeration values if type is unextended/extended */
    if (inf.EnumerationValues && oldvalref &&
        inf.Type != eExtension_Extendable) {
        output("switch (u) {\n");
        for (i = 0; inf.EnumerationValues[i]; i++) {
            output("case %u:\n", i);
            output("%s = %u;\n", oldvalref, intx2uint32(inf.EnumerationValues[i]));
            output("break;\n");
        }
        output("}\n");
    }
}

/* generate decoding statements for a simple value (after some special */
/* handling has been done, esp. the evaluation of the extension) */
void GenPERDecGenericUnextended(
    AssignmentList_t ass,
    PERTypeInfo_t *info,
    PERSimpleTypeInfo_t *sinfo,
    char *valref,
    char *lenref,
    char *encref)
{
    char valbuf[256];
    char lenbuf[256];
    char lbbuf[256];
    char *p;
    char *oldvalref;
    intx_t ix;

    /* check for empty field */
    if (sinfo->NBits == 0) {
        switch (sinfo->Data) {
        case ePERSTIData_Null:
            return;
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
            if (valref && (sinfo->Constraint == ePERSTIConstraint_Semiconstrained || sinfo->Constraint == ePERSTIConstraint_Constrained)) {
                if (info->NOctets == 0) {
                    sprintf(lbbuf, "%s_lb", info->Identifier);
                    outputvarintx(lbbuf, &sinfo->LowerVal);
                    output("ASN1intx_dup(%s, %s);\n", Reference(valref), lbbuf);
                } else if (sinfo->Data == ePERSTIData_Integer) {
                    output("%s = %d;\n", valref, intx2int32(&sinfo->LowerVal));
                } else {
                    output("%s = %u;\n", valref, intx2uint32(&sinfo->LowerVal));
                }
            }
            return;
        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:
        case ePERSTIData_OctetString:
        case ePERSTIData_UTF8String:
        case ePERSTIData_SequenceOf:
        case ePERSTIData_SetOf:
        case ePERSTIData_String:
        case ePERSTIData_TableString:
        case ePERSTIData_ZeroString:
        case ePERSTIData_ZeroTableString:
            if (lenref)
                output("%s = 0;\n", lenref);
            return;
        case ePERSTIData_Extension:
            if (sinfo->Length == ePERSTILength_SmallLength)
                break;
            return;
        default:
            MyAbort();
        }
    }

    /* check for decoding of non-negative-binary-integer */
    switch (sinfo->Constraint) {
    case ePERSTIConstraint_Semiconstrained:
    case ePERSTIConstraint_Constrained:
        if (sinfo->Data == ePERSTIData_Integer)
            sinfo->Data = ePERSTIData_Unsigned;
        break;
    }

    /* use newval for dec of semiconstraint/constraint intx_t with lb != 0 */
    switch (sinfo->Constraint) {
    case ePERSTIConstraint_Semiconstrained:
    case ePERSTIConstraint_Constrained:
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
        case ePERSTIData_NormallySmall:
            if (valref) {
                if (intx_cmp(&sinfo->LowerVal, &intx_0) != 0) {
                    if (info->NOctets == 0) {
                        outputvar("ASN1intx_t newval;\n");
                        oldvalref = valref;
                        valref = "newval";
                    }
                }
            }
            break;
        }
        break;
    }

    /* general rules */
    if (sinfo->LAlignment == ePERSTIAlignment_OctetAligned && sinfo->Length == ePERSTILength_BitLength &&
        !(sinfo->LNBits & 7))
        sinfo->Alignment = ePERSTIAlignment_BitAligned;
                                /* octet alignment will be given my length */
    if (sinfo->Length == ePERSTILength_InfiniteLength &&
        (sinfo->Data == ePERSTIData_Integer && info->NOctets == 0 ||
        sinfo->Data == ePERSTIData_Unsigned && info->NOctets == 0 ||
        sinfo->Data == ePERSTIData_BitString ||
        sinfo->Data == ePERSTIData_RZBBitString ||
        sinfo->Data == ePERSTIData_Extension ||
        sinfo->Data == ePERSTIData_OctetString ||
        sinfo->Data == ePERSTIData_UTF8String ||
        sinfo->Data == ePERSTIData_SequenceOf ||
        sinfo->Data == ePERSTIData_SetOf ||
        sinfo->Data == ePERSTIData_String ||
        sinfo->Data == ePERSTIData_TableString ||
        sinfo->Data == ePERSTIData_ZeroString ||
        sinfo->Data == ePERSTIData_ZeroTableString) ||
        sinfo->Data == ePERSTIData_ObjectIdentifier ||
        sinfo->Data == ePERSTIData_Real ||
        sinfo->Data == ePERSTIData_GeneralizedTime ||
        sinfo->Data == ePERSTIData_UTCTime ||
        sinfo->Data == ePERSTIData_External ||
        sinfo->Data == ePERSTIData_EmbeddedPdv ||
        sinfo->Data == ePERSTIData_MultibyteString ||
        sinfo->Data == ePERSTIData_UnrestrictedString ||
        sinfo->Data == ePERSTIData_Open)
        sinfo->LAlignment = sinfo->Alignment = ePERSTIAlignment_BitAligned;
                                /* alignment will be done by encoding fn */
    if (sinfo->Length == ePERSTILength_NoLength ||
        sinfo->Length == ePERSTILength_SmallLength)
        sinfo->LAlignment = ePERSTIAlignment_BitAligned;
                                    /* no alignment of no length */

    if (g_fCaseBasedOptimizer)
    {
        // lonchanc: special handling for macro operations
        if (PerOptCase_IsSignedInteger(sinfo))
        {
            output("if (!ASN1PERDecInteger(%s, %s))\n", encref, Reference(valref));
            output("return 0;\n");
            goto FinalTouch;
        }
        if (PerOptCase_IsUnsignedInteger(sinfo))
        {
            output("if (!ASN1PERDecUnsignedInteger(%s, %s))\n", encref, Reference(valref));
            output("return 0;\n");
            goto FinalTouch;
        }
        if (PerOptCase_IsUnsignedShort(sinfo))
        {
            output("if (!ASN1PERDecUnsignedShort(%s, %s))\n", encref, Reference(valref));
            output("return 0;\n");
            goto FinalTouch;
        }
        if (PerOptCase_IsBoolean(sinfo))
        {
            output("if (!ASN1PERDecBoolean(%s, %s))\n", encref, Reference(valref));
            output("return 0;\n");
            return;
        }
    }

    /* initial settings for length enconding: */
    /* add lower bound of length to length */
    if (!lenref) {
        if (sinfo->Length == ePERSTILength_NoLength &&
            sinfo->Data != ePERSTIData_Extension) {
            sprintf(lenbuf, "%u", sinfo->LLowerVal);
            lenref = lenbuf;
        } else if (sinfo->Data != ePERSTIData_ObjectIdentifier &&
            sinfo->Data != ePERSTIData_External &&
            sinfo->Data != ePERSTIData_EmbeddedPdv &&
            sinfo->Data != ePERSTIData_MultibyteString &&
            sinfo->Data != ePERSTIData_UnrestrictedString &&
            sinfo->Data != ePERSTIData_Extension &&
            (sinfo->Length != ePERSTILength_InfiniteLength ||
            (sinfo->Data != ePERSTIData_SetOf &&
            sinfo->Data != ePERSTIData_SequenceOf) ||
            !IsStructuredType(GetType(ass, sinfo->SubType))) &&
            ((sinfo->Data != ePERSTIData_SetOf &&
            sinfo->Data != ePERSTIData_SequenceOf) || valref) &&
            (sinfo->Length != ePERSTILength_InfiniteLength ||
            info->NOctets != 0 ||
            (sinfo->Data != ePERSTIData_Integer &&
            sinfo->Data != ePERSTIData_Unsigned)) &&
            ((sinfo->Data != ePERSTIData_ZeroString &&
            sinfo->Data != ePERSTIData_ZeroTableString) ||
            sinfo->Length != ePERSTILength_InfiniteLength) &&
            (sinfo->Data != ePERSTIData_BitString &&
            sinfo->Data != ePERSTIData_UTF8String &&
            sinfo->Data != ePERSTIData_OctetString)) {
            outputvar("ASN1uint32_t l;\n");
            lenref = "l";
        }
    } else if (sinfo->Length == ePERSTILength_NoLength) {
        if ((sinfo->Data == ePERSTIData_BitString ||
             sinfo->Data == ePERSTIData_RZBBitString) &&
             sinfo->cbFixedSizeBitString)
        {
            // lonchanc: doing nothing here because lenref is a constant number
        }
        else
        {
            output("%s = %u;\n", lenref, sinfo->LLowerVal);
        }
    }

    /* length encoding */
    if (sinfo->LAlignment == ePERSTIAlignment_OctetAligned) {
        output("ASN1PERDecAlignment(%s);\n", encref);
    }
    switch (sinfo->Length) {
    case ePERSTILength_NoLength:
        break;

    case ePERSTILength_BitLength:

        /* get length */
        output("if (!ASN1PERDecU32Val(%s, %u, %s))\n",
            encref, sinfo->LNBits, Reference(lenref));
        output("return 0;\n");

        /* add lower bound of length */
        if (sinfo->LLowerVal)
            output("%s += %u;\n", lenref, sinfo->LLowerVal);

        /*
        if (sinfo->LConstraint == ePERSTIConstraint_Constrained) {
            output("if (%s > %u)\n", lenref, sinfo->LUpperVal);
            output("return ASN1DecError(%s, ASN1_ERR_CORRUPT);\n", encref);
        }
        */
        break;

    case ePERSTILength_InfiniteLength:

        /* infinite length case */
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:

            /* get length of integer value */
            if (info->NOctets != 0) {
                output("if (!ASN1PERDecFragmentedLength(%s, %s))\n",
                    encref, Reference(lenref));
                output("return 0;\n");
                if (sinfo->LLowerVal)
                    output("%s += %u;\n", lenref, sinfo->LLowerVal);
                /*
                if (sinfo->LConstraint == ePERSTIConstraint_Constrained) {
                    output("if (%s > %u)\n", lenref, sinfo->LUpperVal);
                    output("return ASN1DecError(%s, ASN1_ERR_CORRUPT);\n",
                        encref);
                }
                */
            }
            break;
        }
        break;
    }

    /* value decoding */
    switch (sinfo->Length) {
    case ePERSTILength_NoLength:

        /* decode alignment of the value */
        if (sinfo->Alignment == ePERSTIAlignment_OctetAligned) {
            output("ASN1PERDecAlignment(%s);\n", encref);
        }

        switch (sinfo->Data) {
        case ePERSTIData_Integer:

            /* decode the value as bit field */
            if (valref) {
                if (!info->NOctets) {
                    output("if (!ASN1PERDecSXVal(%s, %u, %s))\n",
                        info->NOctets * 8, encref, sinfo->NBits, Reference(valref));
                    output("return 0;\n");
                } else {
                    output("if (!ASN1PERDecS%dVal(%s, %u, %s))\n",
                        info->NOctets * 8, encref, sinfo->NBits, Reference(valref));
                    output("return 0;\n");
                }
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_Unsigned:

            /* decode the value as bit field */
            if (valref) {
                if (!info->NOctets) {
                    output("if (!ASN1PERDecUXVal(%s, %u, %s))\n",
                        info->NOctets * 8, encref, sinfo->NBits, Reference(valref));
                    output("return 0;\n");
                } else {
                    output("if (!ASN1PERDecU%dVal(%s, %u, %s))\n",
                        info->NOctets * 8, encref, sinfo->NBits, Reference(valref));
                    output("return 0;\n");
                }
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_NormallySmall:

            /* decode the value as normally small number */
            if (valref) {
                if (!info->NOctets) {
                    MyAbort();
                } else {
                    output("if (!ASN1PERDecN%dVal(%s, %s))\n",
                        info->NOctets * 8, encref, Reference(valref));
                    output("return 0;\n");
                }
            } else {
                output("if (!ASN1PERDecSkipNormallySmall(%s))\n",
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:

            /* decode bit string in a bit field */
            if (valref) {
                if (sinfo->cbFixedSizeBitString)
                {
                    output("if (!ASN1PERDecExtension(%s, %s, %s))\n",
                        encref, lenref, Reference(valref));
                }
                else
                {
                    output("if (!ASN1PERDecBits(%s, %s, %s))\n",
                        encref, lenref, Reference(valref));
                }
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s))\n",
                    encref, lenref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_OctetString:

            /* decode octet string in a bit field */
            if (valref) {
                if (sinfo->LConstraint == ePERSTIConstraint_Constrained &&
                    (! info->pPrivateDirectives->fLenPtr))
                {
                    output("if (!ASN1PERDecExtension(%s, %s * 8, %s))\n",
                        encref, lenref, valref);
                }
                else
                {
                    output("if (!ASN1PERDecBits(%s, %s * 8, %s))\n",
                        encref, lenref, Reference(valref));
                }
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * 8))\n",
                    encref, lenref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_UTF8String:

            /* decode octet string in a bit field */
            if (valref) {
                output("if (!ASN1PERDecUTF8String(%s, %s, %s))\n",
                    encref, lenref, Reference(valref));
                output("return 0;\n");
            } else {
                MyAbort();
            }
            break;

        case ePERSTIData_Extension:

            /* decode extension bits in a bit field */
            if (valref) {
                output("if (!ASN1PERDecExtension(%s, %u, %s))\n",
                    encref, sinfo->NBits, valref);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_SetOf:

            /* same as BitLength encoding */
            goto SetOfEncoding;

        case ePERSTIData_SequenceOf:

            /* same as BitLength encoding */
            goto SequenceOfEncoding;

        case ePERSTIData_String:

            /* same as BitLength encoding */
            goto StringEncoding;

        case ePERSTIData_ZeroString:

            /* same as BitLength encoding */
            goto ZeroStringEncoding;

        case ePERSTIData_TableString:

            /* same as BitLength encoding */
            goto TableStringEncoding;

        case ePERSTIData_ZeroTableString:

            /* same as BitLength encoding */
            goto ZeroTableStringEncoding;

        case ePERSTIData_Reference:

            /* call encoding function of referenced type */
            if (valref) {
                output("if (!ASN1Dec_%s(%s, %s))\n",
                    Identifier2C(sinfo->SubIdentifier),
                    encref, Reference(valref));
                output("return 0;\n");
            } else {
                output("if (!ASN1Dec_%s(%s, NULL))\n",
                    Identifier2C(sinfo->SubIdentifier),
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_Real:

            /* decode real value */
            if (valref) {
                if (info->NOctets)
                    output("if (!ASN1PERDecDouble(%s, %s))\n",
                        encref, Reference(valref));
                else
                    output("if (!ASN1PERDecReal(%s, %s))\n",
                        encref, Reference(valref));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, 8))\n",
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_GeneralizedTime:

            /* decode generalized time value */
            if (valref) {
                output("if (!ASN1PERDecGeneralizedTime(%s, %s, %d))\n",
                    encref, Reference(valref), sinfo->NBits);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, %d))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_UTCTime:

            /* decode utc time value */
            if (valref) {
                output("if (!ASN1PERDecUTCTime(%s, %s, %d))\n",
                    encref, Reference(valref), sinfo->NBits);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, %d))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;
        }
        break;

    case ePERSTILength_BitLength:

        /* decode alignment of the value */
        if (sinfo->Alignment == ePERSTIAlignment_OctetAligned) {
            output("ASN1PERDecAlignment(%s);\n", encref);
        }

        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:

            /* decode the value as bit field */
            if (valref) {
                if (info->NOctets == 0 && sinfo->Data == ePERSTIData_Integer) {
                    output("if (!ASN1PERDecSXVal(%s, %s * 8, %s))\n",
                        encref, lenref, Reference(valref));
                    output("return 0;\n");
                } else if (info->NOctets == 0 && sinfo->Data == ePERSTIData_Unsigned) {
                    output("if (!ASN1PERDecUXVal(%s, %s * 8, %s))\n",
                        encref, lenref, Reference(valref));
                    output("return 0;\n");
                } else if (sinfo->Data == ePERSTIData_Integer) {
                    output("if (!ASN1PERDecS%dVal(%s, %s * 8, %s))\n",
                        info->NOctets * 8, encref, lenref, Reference(valref));
                    output("return 0;\n");
                } else {
                    output("if (!ASN1PERDecU%dVal(%s, %s * 8, %s))\n",
                        info->NOctets * 8, encref, lenref, Reference(valref));
                    output("return 0;\n");
                }
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * 8))\n",
                    encref, lenref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:

            /* decode the value as bit field */
            if (valref) {
                output("if (!ASN1PERDecBits(%s, %s, %s))\n",
                    encref, lenref, Reference(valref));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s))\n",
                    encref, lenref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_OctetString:

            /* decode the value as bit field */
            if (valref) {
                if (sinfo->LConstraint == ePERSTIConstraint_Constrained &&
                    (! info->pPrivateDirectives->fLenPtr))
                {
                    output("if (!ASN1PERDecExtension(%s, %s * 8, %s))\n",
                        encref, lenref, valref);
                }
                else
                {
                    output("if (!ASN1PERDecBits(%s, %s * 8, %s))\n",
                        encref, lenref, Reference(valref));
                }
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * 8))\n",
                    encref, lenref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_UTF8String:

            /* decode the value as bit field */
            if (valref) {
                output("if (!ASN1PERDecUTF8String(%s, %s, %s))\n",
                    encref, lenref, Reference(valref));
                output("return 0;\n");
            } else {
                MyAbort();
            }
            break;

        case ePERSTIData_SetOf:
        SetOfEncoding:
            /*FALLTHROUGH*/
        case ePERSTIData_SequenceOf:
        SequenceOfEncoding:

            /* skip null sequence of/set of */
            if (sinfo->SubType->Flags & eTypeFlags_Null)
                break;

            outputvar("ASN1uint32_t i;\n");
            if (!valref || (info->Rules & eTypeRules_PointerArrayMask))
            {
                // lonchanc: no need to allocate memory for eTypeRules_FixedArray
                /* allocate memory for elements */
                if (valref && (info->Rules & eTypeRules_LengthPointer))
                {
                    output("if (!%s) {\n", lenref);
                    output("%s = NULL;\n", valref);
                    output("} else {\n");
                    output("if (!(%s = (%s *)ASN1DecAlloc(%s, %s * sizeof(%s))))\n",
                        valref, sinfo->SubIdentifier, encref,
                        lenref, Dereference(valref));
                    output("return 0;\n");
                }

                /* decode elements */
                output("for (i = 0; i < %s; i++) {\n", lenref);
                if (valref) {
                    sprintf(valbuf, "(%s)[i]", valref);
                    GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, valbuf, eDecode, encref);
                } else {
                    GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, NULL, eDecode, encref);
                }

                /* loop end */
                output("}\n");
                if (valref && (info->Rules & eTypeRules_LengthPointer))
                    output("}\n"); // closing bracket for else
            }
            else if (info->Rules & eTypeRules_SinglyLinkedList)
            {
                char szPrivateValueName[64];
                sprintf(&szPrivateValueName[0], "(*f)->%s", GetPrivateValueName(info->pPrivateDirectives, "value"));
                /* allocate and decode elements */
                outputvar("P%s *f;\n", info->Identifier);
                output("f = %s;\n", Reference(valref));
                output("for (i = 0; i < %s; i++) {\n", lenref);
                output("if (!(*f = (P%s)ASN1DecAlloc(%s, sizeof(**f))))\n",
                    info->Identifier, encref);
                output("return 0;\n");
                GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, &szPrivateValueName[0],
                    eDecode, encref);
                output("f = &(*f)->next;\n");
                output("}\n");
                output("*f = NULL;\n");
            }
            else
            if (info->Rules & eTypeRules_DoublyLinkedList)
            {
                char szPrivateValueName[64];
                sprintf(&szPrivateValueName[0], "(*f)->%s", GetPrivateValueName(info->pPrivateDirectives, "value"));
                /* allocate and decode elements */
                outputvar("P%s *f;\n", info->Identifier);
                outputvar("%s b;\n", info->Identifier);
                output("f = %s;\n", Reference(valref));
                output("b = NULL;\n");
                output("for (i = 0; i < %s; i++) {\n", lenref);
                output("if (!(*f = (P%s)ASN1DecAlloc(%s, sizeof(**f))))\n",
                    info->Identifier, encref);
                output("return 0;\n");
                GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, &szPrivateValueName[0],
                    eDecode, encref);
                output("f->prev = b;\n");
                output("b = *f;\n");
                output("f = &b->next;\n");
                output("}\n");
                output("*f = NULL;\n");
            }
            break;

        case ePERSTIData_String:
        StringEncoding:

            /* decode string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
#ifdef ENABLE_CHAR_STR_SIZE
                if (info->NOctets == 1 &&
                        info->Root.LConstraint == ePERSTIConstraint_Constrained)
                {
                    output("if (!ASN1PERDec%sStringNoAlloc(%s, %s, %s, %u))\n",
                        p, encref, lenref, valref, sinfo->NBits);
                }
                else
                {
                    output("if (!ASN1PERDec%sString(%s, %s, %s, %u))\n",
                        p, encref, lenref, Reference(valref), sinfo->NBits);
                }
#else
                output("if (!ASN1PERDec%sString(%s, %s, %s, %u))\n",
                    p, encref, lenref, Reference(valref), sinfo->NBits);
#endif
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * %u))\n",
                    encref, lenref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_ZeroString:
        ZeroStringEncoding:

            /* decode zero-terminated string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
#ifdef ENABLE_CHAR_STR_SIZE
                if (info->NOctets == 1 &&
                        info->Root.LConstraint == ePERSTIConstraint_Constrained)
                {
                    output("if (!ASN1PERDecZero%sStringNoAlloc(%s, %s, %s, %u))\n",
                        p, encref, lenref, valref, sinfo->NBits);
                }
                else
                {
                    output("if (!ASN1PERDecZero%sString(%s, %s, %s, %u))\n",
                        p, encref, lenref, Reference(valref), sinfo->NBits);
                }
#else
                output("if (!ASN1PERDecZero%sString(%s, %s, %s, %u))\n",
                    p, encref, lenref, Reference(valref), sinfo->NBits);
#endif
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * %u))\n",
                    encref, lenref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_TableString:
        TableStringEncoding:

            /* decode table string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
#ifdef ENABLE_CHAR_STR_SIZE
                if (info->NOctets == 1 &&
                        info->Root.LConstraint == ePERSTIConstraint_Constrained)
                {
                    output("if (!ASN1PERDecTable%sStringNoAlloc(%s, %s, %s, %u, %s))\n",
                        p, encref, lenref, valref, sinfo->NBits, Reference(sinfo->TableIdentifier));
                }
                else
                {
                    output("if (!ASN1PERDecTable%sString(%s, %s, %s, %u, %s))\n",
                        p, encref, lenref, Reference(valref), sinfo->NBits, Reference(sinfo->TableIdentifier));
                }
#else
                output("if (!ASN1PERDecTable%sString(%s, %s, %s, %u, %s))\n",
                    p, encref, lenref, Reference(valref), sinfo->NBits, Reference(sinfo->TableIdentifier));
#endif
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * %u, %s))\n",
                    encref, lenref, sinfo->NBits, Reference(sinfo->TableIdentifier));
                output("return 0;\n");
            }
            break;

        case ePERSTIData_ZeroTableString:
        ZeroTableStringEncoding:

                /* decode zero-terminated table string value */
                if (info->NOctets == 1) {
                p = "Char";
                } else if (info->NOctets == 2) {
                p = "Char16";
                } else if (info->NOctets == 4) {
                p = "Char32";
                } else
                MyAbort();
                if (valref) {
#ifdef ENABLE_CHAR_STR_SIZE
                if (info->NOctets == 1 &&
                        info->Root.LConstraint == ePERSTIConstraint_Constrained)
                {
                        output("if (!ASN1PERDecZeroTable%sStringNoAlloc(%s, %s, %s, %u, %s))\n",
                                p, encref, lenref, valref, sinfo->NBits, Reference(sinfo->TableIdentifier));
                }
                else
                {
                        output("if (!ASN1PERDecZeroTable%sString(%s, %s, %s, %u, %s))\n",
                                p, encref, lenref, Reference(valref), sinfo->NBits, Reference(sinfo->TableIdentifier));
                }
#else
                output("if (!ASN1PERDecZeroTable%sString(%s, %s, %s, %u, %s))\n",
                        p, encref, lenref, Reference(valref), sinfo->NBits, Reference(sinfo->TableIdentifier));
#endif
                output("return 0;\n");
                } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * %u, %s))\n",
                        encref, lenref, sinfo->NBits, Reference(sinfo->TableIdentifier));
                output("return 0;\n");
                }
            break;
        }
        break;

    case ePERSTILength_InfiniteLength:

        /* infinite length case */
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:

            /* get integer value as fragmented */
            if (valref) {
                if (info->NOctets == 0) {
                    if (sinfo->Data == ePERSTIData_Integer) {
                        output("if (!ASN1PERDecFragmentedIntx(%s, %s))\n",
                            encref, Reference(valref));
                    } else {
                        output("if (!ASN1PERDecFragmentedUIntx(%s, %s))\n",
                            encref, Reference(valref));
                    }
                    output("return 0;\n");
                } else if (sinfo->Data == ePERSTIData_Integer) {
                    output("if (!ASN1PERDecS%dVal(%s, %s * 8, %s))\n",
                        info->NOctets * 8, encref, lenref, Reference(valref));
                    output("return 0;\n");
                } else {
                    output("if (!ASN1PERDecU%dVal(%s, %s * 8, %s))\n",
                        info->NOctets * 8, encref, lenref, Reference(valref));
                    output("return 0;\n");
                }
            } else {
                if (info->NOctets != 0) {
                    output("if (!ASN1PERDecSkipBits(%s, %s * 8))\n",
                        encref, lenref);
                    output("return 0;\n");
                } else {
                    output("if (!ASN1PERDecSkipFragmented(%s, 8))\n",
                        encref);
                    output("return 0;\n");
                }
            }
            break;

        case ePERSTIData_Extension:

            /* get extension bits as fragmented */
            if (valref) {
                output("if (!ASN1PERDecFragmentedExtension(%s, %u, %s))\n",
                    encref, sinfo->NBits, valref);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, 1))\n",
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:

            /* get bit string as fragmented */
            if (valref) {
                output("if (!ASN1PERDecFragmented(%s, %s, %s, 1))\n",
                    encref, Reference(lenref), Reference(valref));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, 1))\n",
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_OctetString:

            /* get octet string as fragmented */
            if (valref) {
                output("if (!ASN1PERDecFragmented(%s, %s, %s, 8))\n",
                    encref, Reference(lenref), Reference(valref));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, 8))\n",
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_UTF8String:

            /* get octet string as fragmented */
            if (valref) {
                output("if (!ASN1PERDecUTF8StringEx(%s, %s, %s))\n",
                    encref, Reference(lenref), Reference(valref));
                output("return 0;\n");
            } else {
                MyAbort();
            }
            break;

        case ePERSTIData_SetOf:
        case ePERSTIData_SequenceOf:

            /* we need some counters and iterators */
            outputvar("ASN1uint32_t i;\n");
            outputvar("ASN1uint32_t n;\n");
            if (valref)
            {
                if (info->Rules & eTypeRules_LengthPointer)
                {
                    output("%s = 0;\n", lenref);
                    output("%s = NULL;\n", valref);
                }
                else
                if (info->Rules & eTypeRules_FixedArray)
                {
                    output("%s = 0;\n", lenref);
                }
                else
                if (info->Rules & eTypeRules_SinglyLinkedList)
                {
                    outputvar("P%s *f;\n", info->Identifier);
                    output("f = %s;\n", Reference(valref));
                }
                else
                if (info->Rules & eTypeRules_DoublyLinkedList)
                {
                    outputvar("P%s *f;\n", info->Identifier);
                    outputvar("%s b;\n", info->Identifier);
                    output("f = %s;\n", Reference(valref));
                    output("b = NULL;\n");
                }
            }

            /* get all elements of the sequence of/set of */
            output("do {\n");

            /* get length of a fragment */
            output("if (!ASN1PERDecFragmentedLength(%s, &n))\n",
                encref);
            output("return 0;\n");

            if (valref)
            {
                if (info->Rules & eTypeRules_LengthPointer)
                {
                    // lonchanc: no need to allocate memory for eTypeRules_FixedArray
                    /* resize memory for the element */
                    output("if (!(%s = (%s *)ASN1DecRealloc(%s, %s, (%s + n) * sizeof(%s))))\n",
                        valref, GetTypeName(ass, sinfo->SubType), encref,
                        valref, lenref, Dereference(valref));
                    output("return 0;\n");
                }
            }

            /* get the elements of the fragment */
            output("for (i = 0; i < n; i++) {\n");
            if (valref) {
                if (info->Rules & eTypeRules_PointerArrayMask)
                {
                    sprintf(valbuf, "(%s)[%s]", valref, lenref);
                }
                else
                if (info->Rules & eTypeRules_LinkedListMask)
                {
                    output("if (!(*f = (P%s)ASN1DecAlloc(%s, sizeof(**f))))\n",
                        info->Identifier, encref);
                    output("return 0;\n");
                    sprintf(valbuf, "(*f)->%s", GetPrivateValueName(info->pPrivateDirectives, "value"));
                }
                GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, valbuf, eDecode, encref);
                if (info->Rules & eTypeRules_SinglyLinkedList)
                {
                    output("f = &(*f)->next;\n");
                }
                else
                if (info->Rules & eTypeRules_DoublyLinkedList)
                {
                    output("(*f)->prev = b;\n");
                    output("b = *f;\n");
                    output("f = &b->next;\n");
                }
            } else {
                GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, NULL, eDecode, encref);
            }
            if ((info->Rules & (eTypeRules_LengthPointer | eTypeRules_FixedArray)) && lenref)
                output("(%s)++;\n", lenref);

            /* end of inner loop */
            output("}\n");

            /* end of outer loop */
            output("} while (n >= 0x4000);\n");

            /* terminate list */
            if (valref && (info->Rules & (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList)))
                output("*f = NULL;\n");
            break;

        case ePERSTIData_ObjectIdentifier:

            /* decode object identifier value */
            if (valref) {
                if (info->pPrivateDirectives->fOidArray || g_fOidArray)
                {
                    output("if (!ASN1PERDecObjectIdentifier2(%s, %s))\n",
                        encref, Reference(valref));
                }
                else
                {
                    output("if (!ASN1PERDecObjectIdentifier(%s, %s))\n",
                        encref, Reference(valref));
                }
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, 8))\n",
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_External:

            /* decode external value */
            output("if (!ASN1PERDecExternal(%s, %s))\n",
                encref, Reference(valref));
            output("return 0;\n");
            break;

        case ePERSTIData_EmbeddedPdv:

            /* decode embedded pdv value */
            if (sinfo->Identification) {
                if (!strcmp(sinfo->Identification->Identifier, "fixed")) {
                    output("if (!ASN1PERDecEmbeddedPdvOpt(%s, %s, NULL, NULL))\n",
                        encref, Reference(valref));
                } else {
                    output("if (!ASN1PERDecEmbeddedPdvOpt(%s, %s, &%s_identification_syntaxes_abstract, &%s_identification_syntaxes_transfer))\n",
                        encref, Reference(valref),
                        info->Identifier, info->Identifier);
                }
            } else {
                output("if (!ASN1PERDecEmbeddedPdv(%s, %s))\n",
                    encref, Reference(valref));
            }
            output("return 0;\n");
            break;

        case ePERSTIData_MultibyteString:

            /* decode multibyte string value */
            output("if (!ASN1PERDecMultibyteString(%s, %s))\n",
                encref, Reference(valref));
            output("return 0;\n");
            break;

        case ePERSTIData_UnrestrictedString:

            /* decode character string value */
            if (sinfo->Identification) {
                if (!strcmp(sinfo->Identification->Identifier, "fixed")) {
                    output("if (!ASN1PERDecCharacterStringOpt(%s, %s, NULL, NULL))\n",
                        encref, Reference(valref));
                } else {
                    output("if (!ASN1PERDecCharacterStringOpt(%s, %s, &%s_identification_syntaxes_abstract, &%s_identification_syntaxes_transfer))\n",
                        encref, Reference(valref),
                        info->Identifier, info->Identifier);
                }
            } else {
                output("if (!ASN1PERDecCharacterString(%s, %s))\n",
                    encref, Reference(valref));
            }
            output("return 0;\n");
            break;

        case ePERSTIData_String:

            /* decode string value as fragmented */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
                output("if (!ASN1PERDecFragmented%sString(%s, %s, %s, %u))\n",
                    p, encref, Reference(lenref), Reference(valref), sinfo->NBits);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_ZeroString:

            /* decode zero-terminated string value as fragmented */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
                output("if (!ASN1PERDecFragmentedZero%sString(%s, %s, %u))\n",
                    p, encref, Reference(valref), sinfo->NBits);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_TableString:

            /* decode table string value as fragmented */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
                output("if (!ASN1PERDecFragmentedTable%sString(%s, %s, %s, %u, %s))\n",
                    p, encref, Reference(lenref), Reference(valref), sinfo->NBits,
                    Reference(sinfo->TableIdentifier));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_ZeroTableString:

            /* decode zero-terminated table-string as fragmented */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
                output("if (!ASN1PERDecFragmentedZeroTable%sString(%s, %s, %u, %s))\n",
                    p, encref, Reference(valref), sinfo->NBits, Reference(sinfo->TableIdentifier));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_Open:

            /* decode open type value */
            if (valref) {
                output("if (!ASN1PERDecOpenType(%s, %s))\n",
                    encref, Reference(valref));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, 8))\n",
                    encref);
                output("return 0;\n");
            }
            break;
        }
        break;

    case ePERSTILength_SmallLength:

        switch (sinfo->Data) {
        case ePERSTIData_Extension:
            
            /* decode extension bits with normally small length */
            if (valref) {
                output("if (!ASN1PERDecNormallySmallExtension(%s, %s, %u, %s))\n",
                    encref, Reference(lenref), sinfo->NBits, valref);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipNormallySmallExtension(%s, %s))\n",
                    encref, Reference(lenref));
                output("return 0;\n");
            }
            break;
        }
    }

FinalTouch:

    /* additional calculations for value decoding: */
    /* add lower bound of constraint/semiconstraint value */
    switch (sinfo->Constraint) {
    case ePERSTIConstraint_Semiconstrained:
    case ePERSTIConstraint_Constrained:
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
        case ePERSTIData_NormallySmall:
            if (valref) {
                if (intx_cmp(&sinfo->LowerVal, &intx_0) != 0) {
                    if (info->NOctets != 0) {
                        if (intx_cmp(&sinfo->LowerVal, &intx_0) > 0) {
                            output("%s += %u;\n",
                                valref, intx2uint32(&sinfo->LowerVal));
                        } else {
                            intx_neg(&ix, &sinfo->LowerVal);
                            // LONCHANC: to workaround a compiler bug in vc++.
                            // output("%s += -%u;\n",
                            output("%s += 0 - %u;\n",
                                valref, intx2uint32(&ix));
                        }
                    } else {
                        sprintf(lbbuf, "%s_lb", info->Identifier);
                        outputvarintx(lbbuf, &sinfo->LowerVal);
                        output("ASN1intx_add(%s, %s, &%s);\n",
                            Reference(oldvalref), Reference(valref), lbbuf);
                        output("ASN1intx_free(%s);\n",
                            Reference(valref));
                    }
                }
            }
            break;
        }
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\hackdir.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "hackdir.h"

#ifdef MS_DIRECTIVE
int g_fPrivateDir_FieldNameToken = 0;
int g_fPrivateDir_TypeNameToken = 0;
int g_fPrivateDir_ValueNameToken = 0;
int g_fPrivateDir_SLinked = 0;
int g_fPrivateDir_DLinked = 0;
int g_fPrivateDir_Public = 0;
int g_fPrivateDir_Intx = 0;
int g_fPrivateDir_LenPtr = 0;
int g_fPrivateDir_Pointer = 0;
int g_fPrivateDir_Array = 0;
int g_fPrivateDir_NoCode = 0;
int g_fPrivateDir_NoMemCopy = 0;
int g_fPrivateDir_OidPacked = 0;
int g_fPrivateDir_OidArray = 0;
char g_szPrivateDirectedFieldName[64];
char g_szPrivateDirectedTypeName[64];
char g_szPrivateDirectedValueName[64];

int My_toupper ( int ch )
{
    if ('a' <= ch && ch <= 'z')
    {
        ch = (ch - 'a' + 'A');
    }
    return ch;
}

int PrivateDirectives_MatchSymbol ( int *p, char *psz )
{
    int c = *p;
    int fMatched = 1;

    while (*psz != '\0')
    {
        if (My_toupper(c) != *psz++)
        {
            fMatched = 0;
            break;
        }
        c = PrivateDirectives_Input();
    }
    *p = c;
    return fMatched;
}

void PrivateDirectives_SkipSpace ( int *p )
{
    int c = *p;
    while (isspace(c))
    {
        c = PrivateDirectives_Input();
    }
    *p = c;
}

void PrivateDirectives_GetSymbol ( int *p, char *psz )
{
    int c = *p;
    while (c == '_' || isalnum(c))
    {
        *psz++ = (char)c;
        c = PrivateDirectives_Input();
    }
    *psz = '\0';
    *p = c;
}

void PrivateDirectives_IgnoreSymbol ( int *p )
{
    int c = *p;
    while (c == '_' || isalnum(c))
    {
        c = PrivateDirectives_Input();
    }
    *p = c;
}

void GetMicrosoftDirective ( int *p )
{
    int c = *p;

    // loop through to get all directives
    while (c != g_chDirectiveEnd)
    {
        if (c == g_chDirectiveAND)
        {
            c = PrivateDirectives_Input();
            PrivateDirectives_SkipSpace(&c);
        }

        switch (My_toupper(c))
        {
        case 'A': // possible ARRAY
            if (PrivateDirectives_MatchSymbol(&c, "ARRAY"))
            {
                g_fPrivateDir_Array = 1;
            }
            break;

        case 'D': // possible DLINKED
            if (PrivateDirectives_MatchSymbol(&c, "DLINKED"))
            {
                g_fPrivateDir_DLinked = 1;
            }
            break;

        case 'F': // possible FNAME
            if (PrivateDirectives_MatchSymbol(&c, "FIELD"))
            {
                // c should be a space now
                PrivateDirectives_SkipSpace(&c);
                // c should be a double quote now
                if (c == '"')
                {
                    c = PrivateDirectives_Input();
                }
                // c should be the first char of name
                PrivateDirectives_GetSymbol(&c, &g_szPrivateDirectedFieldName[0]);
                g_fPrivateDir_FieldNameToken = 0;
            }
            break;

        case 'I': // possible INTX
            if (PrivateDirectives_MatchSymbol(&c, "INTX"))
            {
                g_fPrivateDir_Intx = 1;
            }
            break;

        case 'L': // possible LENPTR
            if (PrivateDirectives_MatchSymbol(&c, "LENPTR"))
            {
                g_fPrivateDir_LenPtr = 1;
            }
            break;

        case 'N': // possible NO MEMCPY (or NOMEMCPY) or NO CODE (or NOCODE)
            if (PrivateDirectives_MatchSymbol(&c, "NO"))
            {
                // skip over possible spaces
                PrivateDirectives_SkipSpace(&c);
                switch (My_toupper(c))
                {
                case 'C':
                    if (PrivateDirectives_MatchSymbol(&c, "CODE")) // CODE
                    {
                        g_fPrivateDir_NoCode = 1;
                    }
                    break;
                case 'M':
                    if (PrivateDirectives_MatchSymbol(&c, "MEMCPY")) // MEMCPY
                    {
                        g_fPrivateDir_NoMemCopy = 1;
                    }
                    break;
                }
            }
            break;

        case 'O': // possible OID ARRAY (or OIDARRAY) or OID PACKED (or OIDPACKED)
            if (PrivateDirectives_MatchSymbol(&c, "OID"))
            {
                // skip over possible spaces
                PrivateDirectives_SkipSpace(&c);
                switch (My_toupper(c))
                {
                case 'A':
                    if (PrivateDirectives_MatchSymbol(&c, "ARRAY")) // ARRAY
                    {
                        g_fPrivateDir_OidArray = 1;
                    }
                    break;
                case 'P':
                    if (PrivateDirectives_MatchSymbol(&c, "PACKED")) // PACKED
                    {
                        g_fPrivateDir_OidPacked = 1;
                    }
                    break;
                }
            }
            break;

        case 'P': // possible POINTER or PUBLIC
            c = PrivateDirectives_Input();
            switch (My_toupper(c))
            {
            case 'O':
                if (PrivateDirectives_MatchSymbol(&c, "OINTER")) // POINTER
                {
                    g_fPrivateDir_Pointer = 1;
                }
                break;
            case 'U':
                if (PrivateDirectives_MatchSymbol(&c, "UBLIC")) // PUBLIC
                {
                    g_fPrivateDir_Public = 1;
                }
                break;
            }
            break;

        case 'S': // possible SLINKED
            if (PrivateDirectives_MatchSymbol(&c, "SLINKED"))
            {
                g_fPrivateDir_SLinked = 1;
            }
            break;

        case 'T': // possible TNAME
            if (PrivateDirectives_MatchSymbol(&c, "TYPE"))
            {
                // c should be a space now
                PrivateDirectives_SkipSpace(&c);
                // c should be a double quote now
                if (c == '"')
                {
                    c = PrivateDirectives_Input();
                }
                // c should be the first char of name
                PrivateDirectives_GetSymbol(&c, &g_szPrivateDirectedTypeName[0]);
                g_fPrivateDir_TypeNameToken = 0;
            }
            break;

        case 'V': // possible VNAME
            if (PrivateDirectives_MatchSymbol(&c, "VALUE"))
            {
                // c should be a space now
                PrivateDirectives_SkipSpace(&c);
                // c should be a double quote now
                if (c == '"')
                {
                    c = PrivateDirectives_Input();
                }
                // c should be the first char of name
                PrivateDirectives_GetSymbol(&c, &g_szPrivateDirectedValueName[0]);
                g_fPrivateDir_ValueNameToken = 0;
            }
            break;

        default:
            goto MyExit;
        }

        // determine if we should stay in the loop
        // skip over the ending double quote
        if (c == '"')
        {
            c = PrivateDirectives_Input();
        }
        // skip over unknown directives
        PrivateDirectives_IgnoreSymbol(&c);
        // skip over possible spaces
        PrivateDirectives_SkipSpace(&c);
    }

    // now, c is >. we need to advance to --
    c = PrivateDirectives_Input();

    // now, c should be -

MyExit:

    // return the current character
    *p = c;
}


void GetPrivateDirective ( int *p )
{
    GetMicrosoftDirective(p);
}


typedef struct Verbatim_s
{
    struct Verbatim_s   *next;
    char                pszVerbatim[1];
}
    Verbatim_t;

Verbatim_t *g_VerbatimList = NULL;

void RememberVerbatim(char *pszVerbatim)
{
    int cb = strlen(pszVerbatim) + 1;
    Verbatim_t *p = (Verbatim_t *) malloc(sizeof(Verbatim_t) + cb);
    if (p)
    {
        memcpy(p->pszVerbatim, pszVerbatim, cb);
        p->next = NULL;
        if (g_VerbatimList)
        {
            Verbatim_t *q;
            for (q = g_VerbatimList; q->next; q = q->next)
                ;
            q->next = p;
        }
        else
        {
            g_VerbatimList = p;
        }
    }
}

void PrintVerbatim(void)
{
    Verbatim_t *p;
    for (p = g_VerbatimList; p; p = p->next)
    {
        output("/* %s */\n", p->pszVerbatim);
    }
    if (g_VerbatimList)
    {
        output("\n");
    }
}

int CompareDirective(char *pszDirective, char *pszInput)
{
    int rc;
    int len = strlen(pszDirective);
    char ch = pszInput[len];
    pszInput[len] = '\0';
    rc = strcmpi(pszDirective, pszInput);
    pszInput[len] = ch;
    return rc;
}

void SetDirective(char *pszInput)
{
    // verbatim strings
    const char szComment[] = "COMMENT";
    if (! CompareDirective((char *) &szComment[0], pszInput))
    {
        pszInput += sizeof(szComment) - 1;
        if (isspace(*pszInput))
        {
            pszInput++;
            if ('"' == *pszInput++)
            {
                char *pszEnd = strchr(pszInput, '"');
                if (pszEnd)
                {
                    *pszEnd = '\0';
                    RememberVerbatim(pszInput);
                    *pszEnd = '"';
                }
            }
        }
        return;
    }

    // object identifier
    if (! CompareDirective("OID ARRAY", pszInput))
    {
        g_fOidArray = 1;
        return;
    }

    // set of/sequence of w/o size constraint
    if (! CompareDirective("SS.basic SLINKED", pszInput))
    {
        g_eDefTypeRuleSS_NonSized = eTypeRules_SinglyLinkedList;
        return;
    }
    if (! CompareDirective("SS.basic DLINKED", pszInput))
    {
        g_eDefTypeRuleSS_NonSized = eTypeRules_DoublyLinkedList;
        return;
    }
    if (! CompareDirective("SS.basic LENPTR", pszInput))
    {
        g_eDefTypeRuleSS_NonSized = eTypeRules_LengthPointer;
        return;
    }
    if (! CompareDirective("SS.basic ARRAY", pszInput))
    {
        g_eDefTypeRuleSS_NonSized = eTypeRules_FixedArray;
        return;
    }

    // set of/sequence of w/ size constraint
    if (! CompareDirective("SS.sized SLINKED", pszInput))
    {
        g_eDefTypeRuleSS_Sized = eTypeRules_SinglyLinkedList;
        return;
    }
    if (! CompareDirective("SS.sized DLINKED", pszInput))
    {
        g_eDefTypeRuleSS_Sized = eTypeRules_DoublyLinkedList;
        return;
    }
    if (! CompareDirective("SS.sized LENPTR", pszInput))
    {
        g_eDefTypeRuleSS_Sized = eTypeRules_LengthPointer;
        return;
    }
    if (! CompareDirective("SS.sized ARRAY", pszInput))
    {
        g_eDefTypeRuleSS_Sized = eTypeRules_FixedArray;
        return;
    }

    // set extra pointer type for SS construct, its struct name will be postfixed with _s
    if (! CompareDirective("SS.struct EXTRA-PTR-TYPE", pszInput))
    {
        g_fExtraStructPtrTypeSS = 1;
        return;
    }
}

#endif // MS_DIRECTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\hackdir.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifdef MS_DIRECTIVE

extern int g_fPrivateDir_FieldNameToken;
extern int g_fPrivateDir_TypeNameToken;
extern int g_fPrivateDir_ValueNameToken;

extern int g_fPrivateDir_SLinked;
extern int g_fPrivateDir_DLinked;
extern int g_fPrivateDir_Public;
extern int g_fPrivateDir_Intx;
extern int g_fPrivateDir_LenPtr;
extern int g_fPrivateDir_Pointer;
extern int g_fPrivateDir_Array;
extern int g_fPrivateDir_NoMemCopy;
extern int g_fPrivateDir_NoCode;
extern int g_fPrivateDir_OidPacked;
extern int g_fPrivateDir_OidArray;

extern char g_szPrivateDirectedFieldName[64];
extern char g_szPrivateDirectedTypeName[64];
extern char g_szPrivateDirectedValueName[64];

extern int PrivateDirectives_Input ( void );
extern void GetPrivateDirective ( int *p );

#endif // MS_DIRECTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\ident.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

char ident1[] = "$Copyright: Microsoft ASN.1 Compiler V1.0 $";
char ident2[] = "$Copyright: Copyright (C) Microsoft Corporation, 1997. All rights reserved. $";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\libasn1.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __ASN1C_LIB_ASN1_H__
#define __ASN1C_LIB_ASN1_H__

#include <msasn1.h>

#ifdef __cplusplus
extern "C" {
#endif

// THE FOLLOWING IS FROM MS_CORE.H

/*
 * This file contains operating system specific defines:
 *
 * Dynamic link library support:
 * Define DllExport as declspec for exported functions and
 * DllImport as declspec for imported functions.
 *
 * Floating point encoding support:
 * For encoding floating point values either
 * - finite()+isinf()+copysign()+frexp() or
 * - finite()+fpclass()+FP_PINF+FP_NINF+frexp()
 * is needed. Define HAS_ISINF for the former case or HAS_FPCLASS for
 * the latter case.
 * Define HAS_IEEEFP_H for inclusion of <ieeefp.h> or HAS_FLOAT_H for
 * inclusion of <float.h> if required.
 *
 * Integer type support
 * [u]int{8,16,32}_t must specify an integral (unsigned iff u-prefixed)
 * type of the specified size (in bits).
 */

/* MS-Windows 95/MS-Windows NT */
#define THIRTYTWO_BITS  1
// #define HAS_SIXTYFOUR_BITS 1
#define HAS_FLOAT_H     1
#define HAS_FPCLASS     1
#define fpclass(_d)     _fpclass(_d)
#define finite(_d)      _finite(_d)
#define isnan(_d)       _isnan(_d)
#define FP_PINF         _FPCLASS_PINF
#define FP_NINF         _FPCLASS_NINF
// #define HAS_STRICMP     1
#define DBL_PINF        {0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x7f}
#define DBL_MINF        {0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0xff}


extern ASN1_PUBLIC ASN1intx_t ASN1intx_0, ASN1intx_1, ASN1intx_2, ASN1intx_16, ASN1intx_256, ASN1intx_64K, ASN1intx_1G;
// extern ASN1_PUBLIC ASN1stringtable_t ASN1NumericStringTable;
extern ASN1_PUBLIC void ASN1API ASN1intx_addoctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern ASN1_PUBLIC void ASN1API ASN1intx_suboctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern ASN1_PUBLIC void ASN1API ASN1intx_muloctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern ASN1_PUBLIC void ASN1API ASN1intx_inc(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_dec(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_neg(ASN1intx_t *, ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx_log2(ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx_log256(ASN1intx_t *);
extern ASN1_PUBLIC ASN1int32_t ASN1API ASN1intx_cmp(ASN1intx_t *, ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_dup(ASN1intx_t *, ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_setuint32(ASN1intx_t *, ASN1uint32_t);
extern ASN1_PUBLIC void ASN1API ASN1intx_setint32(ASN1intx_t *, ASN1int32_t);
extern ASN1_PUBLIC int ASN1API ASN1intxisuint64(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisint64(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisuint32(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisint32(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisuint16(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisint16(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisuint8(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisint8(ASN1intx_t *);
#ifdef HAS_SIXTYFOUR_BITS
extern ASN1_PUBLIC ASN1uint64_t ASN1API ASN1intx2uint64(ASN1intx_t *);
extern ASN1_PUBLIC ASN1int64_t ASN1API ASN1intx2int64(ASN1intx_t *);
#endif
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx2uint32(ASN1intx_t *);
extern ASN1_PUBLIC ASN1int32_t ASN1API ASN1intx2int32(ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint16_t ASN1API ASN1intx2uint16(ASN1intx_t *);
extern ASN1_PUBLIC ASN1int16_t ASN1API ASN1intx2int16(ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint8_t ASN1API ASN1intx2uint8(ASN1intx_t *);
extern ASN1_PUBLIC ASN1int8_t ASN1API ASN1intx2int8(ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx_octets(ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_log2(ASN1uint32_t);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_log256(ASN1uint32_t);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_octets(ASN1uint32_t);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_uoctets(ASN1uint32_t);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1int32_octets(ASN1int32_t);
extern ASN1_PUBLIC double ASN1API ASN1intx2double(ASN1intx_t *);
extern ASN1_PUBLIC double ASN1API ASN1real2double(ASN1real_t *);
extern ASN1_PUBLIC double ASN1API ASN1double_minf();
extern ASN1_PUBLIC double ASN1API ASN1double_pinf();
extern ASN1_PUBLIC int ASN1API ASN1double_isminf(double);
extern ASN1_PUBLIC int ASN1API ASN1double_ispinf(double);
extern ASN1_PUBLIC int ASN1API ASN1generalizedtime2string(char *, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1utctime2string(char *, ASN1utctime_t *);
extern ASN1_PUBLIC int ASN1API ASN1string2generalizedtime(ASN1generalizedtime_t *, char *);
extern ASN1_PUBLIC int ASN1API ASN1string2utctime(ASN1utctime_t *, char *);

/* ------ Memory Free APIs ------ */

extern ASN1_PUBLIC void ASN1API ASN1real_free(ASN1real_t *);
extern ASN1_PUBLIC void ASN1API ASN1bitstring_free(ASN1bitstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1octetstring_free(ASN1octetstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1objectidentifier_free(ASN1objectidentifier_t *);
extern ASN1_PUBLIC void ASN1API ASN1charstring_free(ASN1charstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1char16string_free(ASN1char16string_t *);
extern ASN1_PUBLIC void ASN1API ASN1char32string_free(ASN1char32string_t *);
extern ASN1_PUBLIC void ASN1API ASN1ztcharstring_free(ASN1ztcharstring_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar16string_free(ASN1ztchar16string_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar32string_free(ASN1ztchar32string_t);
extern ASN1_PUBLIC void ASN1API ASN1external_free(ASN1external_t *);
extern ASN1_PUBLIC void ASN1API ASN1embeddedpdv_free(ASN1embeddedpdv_t *);
extern ASN1_PUBLIC void ASN1API ASN1characterstring_free(ASN1characterstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1open_free(ASN1open_t *);

/* ------ Comparison APIs ------ */

extern ASN1_PUBLIC long ASN1API ASN1double_cmp(double, double);
extern ASN1_PUBLIC long ASN1API ASN1real_cmp(ASN1real_t *, ASN1real_t *);
extern ASN1_PUBLIC long ASN1API ASN1external_cmp(ASN1external_t *, ASN1external_t *);
extern ASN1_PUBLIC long ASN1API ASN1embeddedpdv_cmp(ASN1embeddedpdv_t *, ASN1embeddedpdv_t *);
extern ASN1_PUBLIC long ASN1API ASN1characterstring_cmp(ASN1characterstring_t *, ASN1characterstring_t *);
extern ASN1_PUBLIC long ASN1API ASN1sequenceoflengthpointer_cmp(ASN1uint32_t, void *, ASN1uint32_t, void *, ASN1uint32_t, int (*)(void *, void *));
extern ASN1_PUBLIC long ASN1API ASN1sequenceofsinglylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern ASN1_PUBLIC long ASN1API ASN1sequenceofdoublylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern ASN1_PUBLIC long ASN1API ASN1setoflengthpointer_cmp(ASN1uint32_t, void *, ASN1uint32_t, void *, ASN1uint32_t, int (*)(void *, void *));
extern ASN1_PUBLIC long ASN1API ASN1setofsinglylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern ASN1_PUBLIC long ASN1API ASN1setofdoublylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));



#define ASN1BITSET(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] |= 0x80 >> ((_bitnr) & 7))
#define ASN1BITCLR(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] &= ~(0x80 >> ((_bitnr) & 7)))
#define ASN1BITTEST(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] & (0x80 >> ((_bitnr) & 7)))
    



#ifdef __cplusplus
}
#endif

#endif // __ASN1C_LIB_ASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\list.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

/* get length of a singly linked list */
size_t SLlength(void *head, size_t offset)
{
    size_t nelem = 0;

    while (head) {
	/*LINTED*/
    	head = *(void **)((char *)head + offset);
	nelem++;
    }
    return nelem;
}

/* search for an element in a singly linked list */
int SLcontains(void *head, size_t offset, void *elem)
{
    while (head) {
	if (head == elem)
	    return 1;
	/*LINTED pointer cast may result in improper alignment*/
	head = *(void **)((char *)head + offset);
    }
    return 0;
}

/* copy elements of a singly linked list into an array */
void SLtoA(void *head, size_t offset, size_t elemsize, void **base, size_t *nelem)
{
    void *p;

    *nelem = SLlength(head, offset);
    if (!*nelem) {
    	*base = NULL;
	return;
    }
    p = *base = malloc(*nelem * elemsize);
    /*LINTED*/
    for (; head; head = *(void **)((char *)head + offset)) {
    	memcpy(p, head, elemsize);
	p = (void *)((char *)p + elemsize);
    }
}

/* copy pointers to elements of a singly linked list into an array */
void SLtoAP(void *head, size_t offset, void ***base, size_t *nelem)
{
    void **p;

    *nelem = SLlength(head, offset);
    if (!*nelem) {
    	*base = NULL;
	return;
    }
    p = *base = (void **)malloc(*nelem * sizeof(void *));
    /*LINTED*/
    for (; head; head = *(void **)((char *)head + offset)) {
    	*p++ = head;
    }
}

/* copy elements of an array into a singly linked list */
void AtoSL(void *base, size_t offset, size_t nelem, size_t elemsize, void **head)
{
    while (nelem--) {
    	*head = malloc(elemsize);
	memcpy(*head, base, elemsize);
	base = (void *)((char *)base + elemsize);
	/*LINTED*/
	head = (void **)((char *)*head + offset);
    }
    *head = NULL;
}

/* user defined compare function of qsortSL */
static int (*qsortSL_CmpFnCb)(const void *, const void *, void *);
static void *qsortSL_Context;

/* compare function of qsortSL */
static int __cdecl qsortSL_CmpFn(const void *p1, const void *p2)
{
    return qsortSL_CmpFnCb(*(void **)p1, *(void **)p2, qsortSL_Context);
}

/* sort a singly linked list */
void qsortSL(void **head, size_t offset, int (*cmpfn)(const void *, const void *, void *), void *context)
{
    void **base, **p;
    size_t nelem;

    SLtoAP(*head, offset, &base, &nelem);
    qsortSL_CmpFnCb = cmpfn;
    qsortSL_Context = context;
    qsort(base, nelem, sizeof(void *), qsortSL_CmpFn);
    p = base;
    while (nelem--) {
    	*head = *p++;
	/*LINTED*/
	head = (void **)((char *)*head + offset);
    }
    *head = NULL;
    free(base);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\genprg.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "optcase.h"

void GenFuncType(AssignmentList_t ass, char *module, Assignment_t *at, TypeFunc_e et);
void GenFuncComponents(AssignmentList_t ass, char *module, Type_t *type, char *ideref, uint32_t optindex, ComponentList_t components, char *valref1, char *valref2, TypeFunc_e et, int inextension, int inchoice);
void GenFuncSequenceSetType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref1, char *valref2, TypeFunc_e et);
void GenFuncChoiceType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref1, char *valref2, TypeFunc_e et);
void GenFuncSimpleType(AssignmentList_t ass, Type_t *type, char *ideref, char *valref1, char *valref2, TypeFunc_e et);
void GenFreeSimpleType(AssignmentList_t ass, Type_t *type, char *ideref, char *valref);
void GenCompareSimpleType(AssignmentList_t ass, Type_t *type, char *ideref, char *valref1, char *valref2);
void GenCompareExpression(AssignmentList_t ass, Type_t *type, char *ideref, char *valref1, char *valref2);
void GenFuncValue(AssignmentList_t ass, Assignment_t *at, ValueFunc_e cod);
void GenDeclGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t);
void GenDefhGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t);
void GenDefnGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t);
void GenInitGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t);
extern unsigned g_cPDUs;
extern char *g_pszOrigModuleNameLowerCase;
extern int g_fLongNameForImported;
extern int g_fNoAssert;
extern int g_fCaseBasedOptimizer;

extern uint32_t Tag2uint32(AssignmentList_t ass, Tag_t *tag);

int NotInFunTbl(Assignment_t *a)
{
    if (a->Type != eAssignment_Type)
    {
        return 1;
    }

    if (a->U.Type.Type->PrivateDirectives.fPublic)
    {
        return 0;
    }

    return ((a->U.Type.Type->Flags & eTypeFlags_Null) ||
            !(a->U.Type.Type->Flags & eTypeFlags_GenType) ||
            !(a->U.Type.Type->Flags & eTypeFlags_GenPdu) ||
            (a->U.Type.Type->Flags & eTypeFlags_MiddlePDU));
}

/* generate c file */
void
GenPrg(AssignmentList_t ass, FILE *fout, char *module, char *incfilename)
{
    Assignment_t *a;
    TypeFunc_e et;
    ValueFunc_e ev;
    Arguments_t args;
    unsigned i;
    char *pszFunParam;
    char *identifier;
    char funcbuf[256];

    setoutfile(fout);

    // print verbatim
    PrintVerbatim();

    /* file header */
    output("#include <windows.h>\n");
    output("#include \"%s\"\n", incfilename);
    switch (g_eEncodingRule) {
    case eEncoding_Packed:
        GenPERHeader();
        GetPERPrototype(&args);
        pszFunParam = "x,y";
        break;
    case eEncoding_Basic:
        GenBERHeader();
        GetBERPrototype(&args);
        pszFunParam = "x,y,z";
        break;
    default:
        MyAbort();
    }

    output("\n");

    output("ASN1module_t %s = NULL;\n", module);
    output("\n");

    /* write function prototypes */
    for (et = eStringTable; et <= eCopy; et++)
    {
        for (a = ass; a; a = a->Next)
        {
            if (a->Type != eAssignment_Type)
                continue;
            if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
                continue;
            if (a->U.Type.Type->PrivateDirectives.fPublic)
            {
                a->U.Type.Type->Flags |= eTypeFlags_GenEncode;
                a->U.Type.Type->Flags |= eTypeFlags_GenDecode;
                a->U.Type.Type->Flags |= eTypeFlags_GenFree;
                a->U.Type.Type->Flags |= eTypeFlags_GenCompare;
            }
            else
            {
                if ((GetType(ass, a->U.Type.Type)->Flags & eTypeFlags_Null) ||
                    !(a->U.Type.Type->Flags & eTypeFlags_GenType) ||
                    !(a->U.Type.Type->Flags & eTypeFlags_GenPdu))
                    continue;
            }
            switch (et)
            {
            case eStringTable:
                continue;
            case eEncode:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenEncode))
                    continue;
                identifier = GetName(a);
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pencfunc : args.encfunc, identifier);
                if (a->U.Type.Type->PrivateDirectives.fNoCode)
                {
                    output("#define ASN1Enc_%s(%s)      0\n", identifier, pszFunParam);
                }
                else
                {
                    output("static int ASN1CALL ASN1Enc_%s(%s);\n", identifier, funcbuf);
                }
                break;
            case eDecode:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenDecode))
                    continue;
                identifier = GetName(a);
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pdecfunc : args.decfunc, identifier);
                if (a->U.Type.Type->PrivateDirectives.fNoCode)
                {
                    output("#define ASN1Dec_%s(%s)      0\n", identifier, pszFunParam);
                }
                else
                {
                    output("static int ASN1CALL ASN1Dec_%s(%s);\n", identifier, funcbuf);
                }
                break;
            case eCheck:
                continue;
            case ePrint:
                continue;
            case eFree:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenFree) ||
                    (a->U.Type.Type->Flags & eTypeFlags_Simple))
                    continue;
                identifier = GetName(a);
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pfreefunc : args.freefunc, identifier);
                if (a->U.Type.Type->PrivateDirectives.fNoCode)
                {
                    output("#define ASN1Free_%s(x)     \n", identifier);
                }
                else
                {
                    output("static void ASN1CALL ASN1Free_%s(%s);\n", identifier, funcbuf);
                }
                break;
#ifdef ENABLE_COMPARE
            case eCompare:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenCompare))
                    continue;
                identifier = GetName(a);
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pcmpfun : args.cmpfunc, identifier, identifier);
                if (a->U.Type.Type->PrivateDirectives.fNoCode)
                {
                    output("#define ASN1Compare_%s(x,y)      0\n", identifier);
                }
                else
                {
                    output("static int ASN1CALL ASN1Compare_%s(%s);\n", identifier, funcbuf);
                }
                break;
#endif // ENABLE_COMPARE
            case eCopy:
                continue;
            }
        }
    }
    output("\n");

    /* write a table containing the encode function addresses */
    switch (g_eEncodingRule)
    {
    case eEncoding_Packed:
        output("typedef ASN1PerEncFun_t ASN1EncFun_t;\n");
        break;
    case eEncoding_Basic:
        output("typedef ASN1BerEncFun_t ASN1EncFun_t;\n");
        break;
    default:
        output("typedef int (ASN1CALL *ASN1EncFun_t)(%s);\n", args.enccast);
        break;
    }
    output("static const ASN1EncFun_t encfntab[%u] = {\n", g_cPDUs);
    for (a = ass; a; a = a->Next) {
        if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
           continue;
        if (NotInFunTbl(a))
            continue;
        if (!(a->U.Type.Type->Flags & eTypeFlags_GenEncode)) {
            ASSERT(0);
            output("(ASN1EncFun_t) NULL,\n");
            continue;
        }
        output("(ASN1EncFun_t) ASN1Enc_%s,\n", GetName(a));
    }
    output("};\n");

    /* write a table containing the decode function addresses */
    switch (g_eEncodingRule)
    {
    case eEncoding_Packed:
        output("typedef ASN1PerDecFun_t ASN1DecFun_t;\n");
        break;
    case eEncoding_Basic:
        output("typedef ASN1BerDecFun_t ASN1DecFun_t;\n");
        break;
    default:
        output("typedef int (ASN1CALL *ASN1DecFun_t)(%s);\n", args.deccast);
        break;
    }
    output("static const ASN1DecFun_t decfntab[%u] = {\n", g_cPDUs);
    for (a = ass; a; a = a->Next)
    {
        if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
           continue;
        if (NotInFunTbl(a))
            continue;
        if (!(a->U.Type.Type->Flags & eTypeFlags_GenDecode))
        {
            ASSERT(0);
            output("(ASN1DecFun_t) NULL,\n");
            continue;
        }
        output("(ASN1DecFun_t) ASN1Dec_%s,\n", GetName(a));
    }
    output("};\n");

    /* write a table containing the free function addresses */
    output("static const ASN1FreeFun_t freefntab[%u] = {\n", g_cPDUs);
    for (a = ass; a; a = a->Next)
    {
        if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
           continue;
        if (NotInFunTbl(a))
            continue;
        if (!(a->U.Type.Type->Flags & eTypeFlags_GenFree) ||
            (a->U.Type.Type->Flags & eTypeFlags_Simple))
        {
            output("(ASN1FreeFun_t) NULL,\n");
            continue;
        }
        output("(ASN1FreeFun_t) ASN1Free_%s,\n", GetName(a));
    }
    output("};\n");

#ifdef ENABLE_COMPARE
    /* write a table containing the compare function addresses */
    output("typedef int (ASN1CALL *ASN1CmpFun_t)(%s);\n", args.cmpcast);
    output("static const ASN1CmpFun_t cmpfntab[%u] = {\n", g_cPDUs);
    for (a = ass; a; a = a->Next)
    {
        if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
           continue;
        if (NotInFunTbl(a))
            continue;
        if (!(a->U.Type.Type->Flags & eTypeFlags_GenCompare))
        {
            ASSERT(0);
            output("(ASN1CmpFun_t) NULL,\n");
            continue;
        }
        output("(ASN1CmpFun_t) ASN1Compare_%s,\n", GetName(a));
    }
    output("};\n");
    output("\n");
#endif // ENABLE_COMPARE

    /* write a table containing the sizeof pdu structures */
    output("static const ULONG sizetab[%u] = {\n", g_cPDUs);
    for (i = 0; i < g_cPDUs; i++)
    {
        output("SIZE_%s_%s_%u,\n", module, g_pszApiPostfix, i);
    }
    output("};\n");
    output("\n");

    /* handle values in 4 steps: */
    /* 1. write forward declarations, */
    /* 2. write definitions of value components, */
    /* 3. write definitions of values, */
    /* 4. write assignments into the initialization function */
    for (ev = eDecl; ev <= eFinit; ev++)
    {
        switch (ev)
        {
        case eDecl:
            output("/* forward declarations of values: */\n");
            break;
        case eDefh:
            output("/* definitions of value components: */\n");
            break;
        case eDefn:
            output("/* definitions of values: */\n");
            break;
        case eInit:
            output("\nvoid ASN1CALL %s_Startup(void)\n", module);
            output("{\n");
            switch (g_eEncodingRule)
            {
            case eEncoding_Packed:
                GenPERInit(ass, module);
                break;
            case eEncoding_Basic:
                GenBERInit(ass, module);
                break;
            }
            break;
        case eFinit:
            output("\nvoid ASN1CALL %s_Cleanup(void)\n", module);
            output("{\n");
            output("ASN1_CloseModule(%s);\n", module);
            output("%s = NULL;\n", module);
            break;
        }
        for (a = ass; a; a = a->Next)
        {
            if (a->Type != eAssignment_Value)
                continue;
            if (GetValue(ass, a->U.Value.Value)->Type->Flags & eTypeFlags_Null)
                continue;
            switch (ev)
            {
            case eDecl:
            case eDefh:
            case eDefn:
            case eInit:
            case eFinit:
                if (!(a->U.Value.Value->Flags & eValueFlags_GenValue))
                    continue;
                break;
            }
            GenFuncValue(ass, a, ev);
        }
        if (ev == eInit || ev == eFinit) {
            output("}\n");
        }
    }
    output("\n");

    /* generate the type functions for all assignments as wanted */
    for (a = ass; a; a = a->Next)
    {
        if (a->Type != eAssignment_Type)
            continue;

        /* skip null types */
        if (a->U.Type.Type->Flags & eTypeFlags_Null)
            continue;

        if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
           continue;

        if (a->U.Type.Type->PrivateDirectives.fNoCode)
            continue;

        /* generate the functions */
        identifier = GetName(a);
        for (et = eStringTable; et <= eCopy; et++)
        {
            switch (et)
            {
            case eStringTable:
                if (!(a->U.Type.Type->Flags &
                    (eTypeFlags_GenEncode | eTypeFlags_GenDecode)))
                    continue;
                switch (g_eEncodingRule)
                {
                case eEncoding_Packed:
                    GenPERFuncType(ass, module, a, et);
                    break;
                case eEncoding_Basic:
                    GenBERFuncType(ass, module, a, et);
                    break;
                }
                break;
            case eEncode:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenEncode))
                    continue;
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pencfunc : args.encfunc, identifier);
                output("static int ASN1CALL ASN1Enc_%s(%s)\n",
                    identifier, funcbuf);
                output("{\n");
                switch (g_eEncodingRule)
                {
                case eEncoding_Packed:
                    GenPERFuncType(ass, module, a, et);
                    break;
                case eEncoding_Basic:
                    GenBERFuncType(ass, module, a, et);
                    break;
                }
                output("return 1;\n");
                output("}\n\n");
                break;
            case eDecode:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenDecode))
                    continue;
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pdecfunc : args.decfunc, identifier);
                output("static int ASN1CALL ASN1Dec_%s(%s)\n",
                    identifier, funcbuf);
                output("{\n");
                switch (g_eEncodingRule)
                {
                case eEncoding_Packed:
                    GenPERFuncType(ass, module, a, et);
                    break;
                case eEncoding_Basic:
                    GenBERFuncType(ass, module, a, et);
                    break;
                }
                output("return 1;\n");
                output("}\n\n");
                break;
            case eCheck:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenCheck))
                    continue;
                GenFuncType(ass, module, a, et);
                break;
            case ePrint:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenPrint))
                    continue;
                GenFuncType(ass, module, a, et);
                break;
            case eFree:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenFree) ||
                    (a->U.Type.Type->Flags & eTypeFlags_Simple))
                    continue;
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pfreefunc : args.freefunc, identifier);
                output("static void ASN1CALL ASN1Free_%s(%s)\n",
                    identifier, funcbuf);
                output("{\n");
                output("if (val) {\n");  // opening the null pointer check
                GenFuncType(ass, module, a, et);
                output("}\n"); // closing the null pointer check
                output("}\n\n");
                break;
#ifdef ENABLE_COMPARE
            case eCompare:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenCompare))
                    continue;
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pcmpfunc : args.cmpfunc, identifier);
                output("static int ASN1CALL ASN1Compare_%s(%s)\n",
                    identifier, funcbuf);
                output("{\n");
                outputvar("int ret;\n");
                GenFuncType(ass, module, a, et);
                output("return 0;\n");
                output("}\n\n");
                break;
#endif // ENABLE_COMPARE
            case eCopy:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenCopy))
                    continue;
                GenFuncType(ass, module, a, et);
                break;
            }
        }
    }
}

/* generate function encoding-independent type-specific functions */
void
GenFuncType(AssignmentList_t ass, char *module, Assignment_t *at, TypeFunc_e et)
{
    Type_t *type;
    char *ideref;
    char *valref1, *valref2;

    /* get some informations */
    type = at->U.Type.Type;
    ideref = GetName(at);
    switch (et) {
    case eCompare:
        valref1 = "val1";
        valref2 = "val2";
        break;
    default:
        valref1 = "val";
        valref2 = "";
        break;
    }

    /* function body */
    switch (type->Type) {
    case eType_Boolean:
    case eType_Integer:
    case eType_Enumerated:
    case eType_Real:
    case eType_BitString:
    case eType_OctetString:
    case eType_UTF8String:
    case eType_Null:
    case eType_EmbeddedPdv:
    case eType_External:
    case eType_ObjectIdentifier:
    case eType_BMPString:
    case eType_GeneralString:
    case eType_GraphicString:
    case eType_IA5String:
    case eType_ISO646String:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_UniversalString:
    case eType_VideotexString:
    case eType_VisibleString:
    case eType_CharacterString:
    case eType_GeneralizedTime:
    case eType_UTCTime:
    case eType_ObjectDescriptor:
    case eType_RestrictedString:
    case eType_Open:
    case eType_Reference:
        /* generate function for a simple type */
        GenFuncSimpleType(ass, type, ideref, Dereference(valref1), Dereference(valref2), et);
        break;

    case eType_SequenceOf:
    case eType_SetOf:
        /* generate function for seq-of and set-of */
        GenFuncSimpleType(ass, type, ideref, Dereference(valref1), Dereference(valref2), et);
        break;

    case eType_Sequence:
    case eType_Set:
    case eType_InstanceOf:
        /* generate function for a sequence/set/instanceof type */
        GenFuncSequenceSetType(ass, module, at, valref1, valref2, et);
        break;

    case eType_Choice:
        /* generate function for a choice type */
        GenFuncChoiceType(ass, module, at, valref1, valref2, et);
        break;

    case eType_Selection:
        MyAbort();
        /*NOTREACHED*/

    case eType_Undefined:
        MyAbort();
        /*NOTREACHED*/
    }
}

/* generate encoding-independent statements for components of a */
/* sequence/set/choice type */
void
GenFuncComponents(AssignmentList_t ass, char *module, Type_t *type, char *ideref, uint32_t optindex, ComponentList_t components, char *valref1, char *valref2, TypeFunc_e et, int inextension, int inchoice)
{
    Component_t *com;
    NamedType_t *namedType;
    char *ide, idebuf[256];
    char valbuf1[256], valbuf2[256], valbuf3[256];
    int skip;

    /* emit components of extension root */
    for (com = components; com; com = com->Next) {
        if (com->Type == eComponent_ExtensionMarker)
            break;

        /* get some information */
        namedType = com->U.NOD.NamedType;
        ide = Identifier2C(namedType->Identifier);
        sprintf(idebuf, "%s_%s", ideref, ide);

        /* skip unnecessary elements */
        switch (et) {
        case eFree:
            skip = (namedType->Type->Flags & eTypeFlags_Simple);
            break;
        default:
            skip = 0;
            break;
        }

        /* dereference pointer if pointer directive used */
        if (inchoice) {
            if (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer) {
                sprintf(valbuf1, "*(%s)->u.%s", valref1, ide);
                sprintf(valbuf2, "*(%s)->u.%s", valref2, ide);
            } else {
                sprintf(valbuf1, "(%s)->u.%s", valref1, ide);
                sprintf(valbuf2, "(%s)->u.%s", valref2, ide);
            }
        } else {
            if (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer) {
                sprintf(valbuf1, "*(%s)->%s", valref1, ide);
                sprintf(valbuf2, "*(%s)->%s", valref2, ide);
            } else {
                sprintf(valbuf1, "(%s)->%s", valref1, ide);
                sprintf(valbuf2, "(%s)->%s", valref2, ide);
            }
        }

        /* check if optional/default component is present */
        if (!skip) {
            if (inchoice) {
                switch (et) {
                case eFree:
                    output("case %d:\n", optindex);
                    GenFuncSimpleType(ass, namedType->Type, idebuf,
                        valbuf1, valbuf2, et);
                    if ((GetTypeRules(ass, namedType->Type) &
                        eTypeRules_Pointer) &&
                        !(GetType(ass, namedType->Type)->Flags &
                        eTypeFlags_Null))
                        output("ASN1Free(%s);\n", Reference(valbuf1));
                    output("break;\n");
                    break;
                default:
                    output("case %d:\n", optindex);
                    GenFuncSimpleType(ass, namedType->Type, idebuf,
                        valbuf1, valbuf2, et);
                    output("break;\n");
                    break;
                }
            } else {
                if (com->Type == eComponent_Optional ||
                    com->Type == eComponent_Default ||
                    inextension) {
                    switch (et) {
                    case eFree:
                        output("if ((%s)->o[%u] & 0x%x) {\n", valref1,
                            optindex / 8, 0x80 >> (optindex & 7));
                        GenFuncSimpleType(ass, namedType->Type, idebuf,
                            valbuf1, valbuf2, et);
                        if ((GetTypeRules(ass, namedType->Type) &
                            eTypeRules_Pointer) &&
                            !(GetType(ass, namedType->Type)->Flags &
                            eTypeFlags_Null))
                            output("ASN1Free(%s);\n", Reference(valbuf1));
                        output("}\n");
                        break;
                    case eCompare:
                        sprintf(valbuf3, "%s_default", idebuf);
                        output("if (((%s)->o[%u] & 0x%x)) {\n", valref1,
                            optindex / 8, 0x80 >> (optindex & 7));
                        output("if (((%s)->o[%u] & 0x%x)) {\n", valref2,
                            optindex / 8, 0x80 >> (optindex & 7));
                        GenFuncSimpleType(ass, namedType->Type, idebuf,
                            valbuf1, valbuf2, et);
                        output("} else {\n");
                        if (com->Type == eComponent_Default) {
                            GenFuncSimpleType(ass, namedType->Type, idebuf,
                                valbuf1, valbuf3, et);
                        } else {
                            output("return 1;\n");
                        }
                        output("}\n");
                        output("} else {\n");
                        output("if (((%s)->o[%u] & 0x%x)) {\n", valref2,
                            optindex / 8, 0x80 >> (optindex & 7));
                        if (com->Type == eComponent_Default) {
                            GenFuncSimpleType(ass, namedType->Type, idebuf,
                                valbuf3, valbuf2, et);
                        } else {
                            output("return 1;\n");
                        }
                        output("}\n");
                        output("}\n");
                        break;
                    default:
                        GenFuncSimpleType(ass, namedType->Type, idebuf,
                            valbuf1, valbuf2, et);
                        break;
                    }
                } else {
                    GenFuncSimpleType(ass, namedType->Type, idebuf,
                        valbuf1, valbuf2, et);
                }
            }
        }
        if (inchoice ||
            com->Type == eComponent_Optional ||
            com->Type == eComponent_Default ||
            inextension)
            optindex++;
    }
}

/* generate encoding-independent statements for sequence/set type */
void
GenFuncSequenceSetType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref1, char *valref2, TypeFunc_e et)
{
    uint32_t optionals, extensions;
    Component_t *components, *com;
    Type_t *type;
    char *ideref;

    type = at->U.Type.Type;
    ideref = GetName(at);
    optionals = type->U.SSC.Optionals;
    extensions = type->U.SSC.Extensions;
    components = type->U.SSC.Components;

    /* emit components of extension root */
    GenFuncComponents(ass, module, type, ideref, 0,
        components, valref1, valref2, et, 0, 0);

    /* handle extensions */
    if (type->Flags & eTypeFlags_ExtensionMarker) {
        if (extensions) {

            /* get start of extensions */
            for (com = components; com; com = com->Next) {
                if (com->Type == eComponent_ExtensionMarker) {
                    com = com->Next;
                    break;
                }
            }

            /* emit components of extension */
            GenFuncComponents(ass, module, type, ideref, (optionals + 7) & ~7,
                com, valref1, valref2, et, 1, 0);
        }
    }
}

/* generate encoding-independent statements for choice type */
void
GenFuncChoiceType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref1, char *valref2, TypeFunc_e et)
{
    Type_t *type;
    char *ideref;
    char valbuf1[256], valbuf2[256];
    uint32_t alternatives;
    Component_t *components, *com;

    /* get some informations */
    type = at->U.Type.Type;
    ideref = GetName(at);
    alternatives = type->U.SSC.Alternatives;
    components = type->U.SSC.Components;

    /* encode choice selector */
    sprintf(valbuf1, "(%s)->choice", valref1);
    sprintf(valbuf2, "(%s)->choice", valref2);
    GenFuncSimpleType(ass, type, ideref, valbuf1, valbuf2, et);

    /* finished if choice only contains NULL alternatives or if choice */
    /* contains no data to free */
    if ((type->Flags & eTypeFlags_NullChoice) ||
        (et == eFree && (type->Flags & eTypeFlags_Simple)))
        return;

    /* create switch statement */
    output("switch ((%s)->choice) {\n", valref1);

    /* generate components of extension root */
    GenFuncComponents(ass, module, type, ideref, ASN1_CHOICE_BASE,
        type->U.SSC.Components, valref1, valref2, et, 0, 1);

    /* get start of extensions */
    for (com = components; com; com = com->Next) {
        if (com->Type == eComponent_ExtensionMarker) {
            com = com->Next;
            break;
        }
    }

    /* generate components of extension */
    GenFuncComponents(ass, module, type, ideref, ASN1_CHOICE_BASE + alternatives,
        com, valref1, valref2, et, 1, 1);

    /* end of switch statement */
    output("}\n");
}

/* generate encoding-independent statements for a simple type */
void
GenFuncSimpleType(AssignmentList_t ass, Type_t *type, char *ideref, char *valref1, char *valref2, TypeFunc_e et)
{
    switch (et) {
    case eFree:
        GenFreeSimpleType(ass, type, ideref, valref1);
        break;
#ifdef ENABLE_COMPARE
    case eCompare:
        GenCompareSimpleType(ass, type, ideref, valref1, valref2);
        break;
#endif // ENABLE_COMPARE
    }
}

/* generate free statements for a simple type */
void
GenFreeSimpleType(AssignmentList_t ass, Type_t *type, char *ideref, char *valref)
{
    char idebuf[256];
    char valbuf[256];
    char valbuf2[256];
    char *itype;
    int32_t noctets;
    uint32_t zero;

    if (type->Flags & eTypeFlags_Simple)
        return;
    if (type->Type == eType_Reference && !IsStructuredType(GetType(ass, type)))
        type = GetType(ass, type);

    switch (type->Type) {
    case eType_Boolean:
    case eType_Integer:
    case eType_Enumerated:

        /* check if we have to free an intx_t value */
        itype = GetTypeName(ass, type);
        if (!strcmp(itype, "ASN1intx_t"))
            output("ASN1intx_free(%s);\n", Reference(valref));
        break;

    case eType_BitString:

        /* free bit string value */
        if (g_eEncodingRule == eEncoding_Packed)
        {
            if (type->PERTypeInfo.Root.cbFixedSizeBitString == 0)
            {
                output("ASN1bitstring_free(%s);\n", Reference(valref));
            }
        }
        else
        {
            // only support unbounded in BER
            if (! type->PrivateDirectives.fNoMemCopy)
            {
                output("ASN1bitstring_free(%s);\n", Reference(valref));
            }
        }
        break;

    case eType_OctetString:

        /* free octet string value */
        if (g_eEncodingRule == eEncoding_Packed)
        {
            if (type->PERTypeInfo.Root.LConstraint != ePERSTIConstraint_Constrained ||
                type->PrivateDirectives.fLenPtr)
            {
                output("ASN1octetstring_free(%s);\n", Reference(valref));
            }
        }
        else
        {
            // only support unbounded in BER
            if (! type->PrivateDirectives.fNoMemCopy)
            {
                output("ASN1octetstring_free(%s);\n", Reference(valref));
            }
        }
        break;

    case eType_UTF8String:

        /* free octet string value */
        output("ASN1utf8string_free(%s);\n", Reference(valref));
        break;

    case eType_ObjectIdentifier:

        /* free object identifier value */
        if (type->PrivateDirectives.fOidPacked)
        {
            output("ASN1BEREoid_free(%s);\n", Reference(valref));
        }
        else
        if (! (type->PrivateDirectives.fOidArray || g_fOidArray))
        {
            output("ASN1objectidentifier_free(%s);\n", Reference(valref));
        }
        break;

    case eType_External:

        /* free external value */
        output("ASN1external_free(%s);\n", Reference(valref));
        break;

    case eType_Real:

        /* free real value */
        output("ASN1real_free(%s);\n", Reference(valref));
        break;

    case eType_EmbeddedPdv:

        /* free embedded pdv value */
        output("ASN1embeddedpdv_free(%s);\n", Reference(valref));
        break;

    case eType_SetOf:

        /* create name of identifier */
        sprintf(idebuf, "%s_Set", ideref);
        goto FreeSequenceSetOf;

    case eType_SequenceOf:

        /* create name of identifier */
        sprintf(idebuf, "%s_Sequence", ideref);
    FreeSequenceSetOf:

        if (type->Rules & eTypeRules_FixedArray)
        {
            char *pszPrivateValueName = GetPrivateValueName(&type->PrivateDirectives, "value");
            /* free components of sequence of/set of */
            if (! (type->Rules & eTypeRules_PointerToElement))
                valref = Reference(valref);
            if (!(type->U.SS.Type->Flags & eTypeFlags_Simple)) {
                outputvar("ASN1uint32_t i;\n");
                output("for (i = 0; i < (%s)->count; i++) {\n", valref);
                sprintf(valbuf, "(%s)->%s[i]", valref, pszPrivateValueName);
                GenFuncSimpleType(ass, type->U.SS.Type, idebuf, valbuf, "", eFree);
                output("}\n");
            }
        }
        else
        if (type->Rules & eTypeRules_LengthPointer)
        {
            char *pszPrivateValueName = GetPrivateValueName(&type->PrivateDirectives, "value");
            /* free components of sequence of/set of */
            if (! (type->Rules & eTypeRules_PointerToElement))
                valref = Reference(valref);
            if (!(type->U.SS.Type->Flags & eTypeFlags_Simple)) {
                sprintf(valbuf2, "(%s)->%s[0]", valref, pszPrivateValueName);
                GenFuncSimpleType(ass, type->U.SS.Type, idebuf, valbuf2, "", eFree);
                outputvar("ASN1uint32_t i;\n");
                output("for (i = 1; i < (%s)->count; i++) {\n", valref);
                sprintf(valbuf2, "(%s)->%s[i]", valref, pszPrivateValueName);
                GenFuncSimpleType(ass, type->U.SS.Type, idebuf, valbuf2, "", eFree);
                output("}\n");
            }
            // lonchanc: no need to check length because we zero out decoded buffers.
            // output("if ((%s)->count)\n", valref);
            output("ASN1Free((%s)->%s);\n", valref, pszPrivateValueName);
        }
        else
        if (type->Rules & eTypeRules_LinkedListMask)
        {
            char szPrivateValueName[68];

            if (g_fCaseBasedOptimizer)
            {
                if (g_eEncodingRule == eEncoding_Packed &&
                    PerOptCase_IsTargetSeqOf(&type->PERTypeInfo))
                {
                    // generate the iterator
                    PERTypeInfo_t *info = &type->PERTypeInfo;
                    char szElmFn[128];
                    char szElmFnDecl[256];
                    sprintf(szElmFn, "ASN1Free_%s_ElmFn", info->Identifier);
                    sprintf(szElmFnDecl, "void ASN1CALL %s(P%s val)",
                        szElmFn, info->Identifier);

                    setoutfile(g_finc);
                    output("extern %s;\n", szElmFnDecl);
                    setoutfile(g_fout);

                    output("ASN1PERFreeSeqOf((ASN1iterator_t **) %s, (ASN1iterator_freefn) %s);\n",
                        Reference(valref), szElmFn);
                    output("}\n"); // closing the null pointer check
                    output("}\n\n"); // end of iterator body


                    // generate the element function
                    output("static %s\n", szElmFnDecl);
                    output("{\n");
                    output("if (val) {\n"); // opening the null pointer check
                    sprintf(&szPrivateValueName[0], "val->%s", GetPrivateValueName(info->pPrivateDirectives, "value"));
                    GenFuncSimpleType(ass, type->U.SS.Type, idebuf,
                        &szPrivateValueName[0], "", eFree);
                    // output("}\n"); // closing the null pointer check. lonchanc: closed by caller
                    // end of element body
                    return;
                }
            }

            /* free components of sequence of/set of */
            outputvar("P%s f, ff;\n", ideref);
            output("for (f = %s; f; f = ff) {\n", valref);
            sprintf(&szPrivateValueName[0], "f->%s", type->PrivateDirectives.pszValueName ? type->PrivateDirectives.pszValueName : "value");
            GenFuncSimpleType(ass, type->U.SS.Type, idebuf,
                &szPrivateValueName[0], "", eFree);
            output("ff = f->next;\n");

            /* free list entry of sequence of/set of */
            output("ASN1Free(f);\n");
            output("}\n");
        }
        break;

    case eType_ObjectDescriptor:

        /* free object descriptor value */
        output("ASN1ztcharstring_free(%s);\n", valref);
        break;

    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_VideotexString:
    case eType_IA5String:
    case eType_GraphicString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GeneralString:
    case eType_UniversalString:
#ifdef ENABLE_CHAR_STR_SIZE
                if (g_eEncodingRule == eEncoding_Packed &&
                    type->PERTypeInfo.NOctets == 1 &&
                        type->PERTypeInfo.Root.LConstraint == ePERSTIConstraint_Constrained)
                {
                    // it is an array, no need to free it.
                    break;
                }
#endif

    case eType_BMPString:
    case eType_RestrictedString:

        /* free string value */
        GetStringType(ass, type, &noctets, &zero);
        if (zero) {
            switch (noctets) {
            case 1:
                output("ASN1ztcharstring_free(%s);\n", valref);
                break;
            case 2:
                output("ASN1ztchar16string_free(%s);\n", valref);
                break;
            case 4:
                output("ASN1ztchar32string_free(%s);\n", valref);
                break;
            }
        } else {
            switch (noctets) {
            case 1:
                output("ASN1charstring_free(%s);\n", Reference(valref));
                break;
            case 2:
                output("ASN1char16string_free(%s);\n", Reference(valref));
                break;
            case 4:
                output("ASN1char32string_free(%s);\n", Reference(valref));
                break;
            }
        }
        break;

    case eType_CharacterString:

        /* free character string value */
        output("ASN1characterstring_free(%s);\n", Reference(valref));
        break;

    case eType_Reference:

        /* call free function of referenced type */
        output("ASN1Free_%s(%s);\n",
            GetTypeName(ass, type), Reference(valref));
        break;

    case eType_Open:

        /* free open type value */
        if (g_eEncodingRule == eEncoding_Packed || (! type->PrivateDirectives.fNoMemCopy))
        {
            output("ASN1open_free(%s);\n", Reference(valref));
        }
        break;
    }
}

/* generate compare statements for a simple type */
/*ARGSUSED*/
#ifdef ENABLE_COMPARE
void
GenCompareSimpleType(AssignmentList_t ass, Type_t *type, char *ideref, char *valref1, char *valref2)
{
    /* skip null type */
    if (type->Flags & eTypeFlags_Null)
        return;

    /* compare the values and return difference if different */
    output("if ((ret = (");
    GenCompareExpression(ass, type, ideref, valref1, valref2);
    output(")))\n");
    output("return ret;\n");
}
#endif // ENABLE_COMPARE

/* generate compare expression for two values of simple type */
/*ARGSUSED*/
#ifdef ENABLE_COMPARE
void
GenCompareExpression(AssignmentList_t ass, Type_t *type, char *ideref, char *valref1, char *valref2)
{
    PERSTIData_e dat;
    uint32_t noctets;
    char *itype;
    char *subide;
    char *pszPrivateValueName;

    /*XXX switch to PER-independent field */
    dat = type->PERTypeInfo.Root.Data;
    noctets = type->PERTypeInfo.NOctets;

    switch (dat) {
    case ePERSTIData_Null:

        /* null values equal */
        output("0");
        break;

    case ePERSTIData_Boolean:

        /* boolean values have to be converted to 0/1 values before */
        /* comparison */
        output("!!%s - !!%s", valref1, valref2);
        break;

    case ePERSTIData_Integer:
    case ePERSTIData_Unsigned:

        /* substract integer values */
        if (noctets) {
            if (noctets <= 4)
                output("%s - %s", valref1, valref2);
            else
                output("%s < %s ? -1 : %s > %s ? 1 : 0",
                    valref1, valref2, valref1, valref2);
        } else {
            output("ASN1intx_cmp(%s, %s)",
                Reference(valref1), Reference(valref2));
        }
        break;

    case ePERSTIData_Real:

        /* compare real values */
        itype = GetTypeName(ass, type);
        if (!strcmp(itype, "ASN1real_t"))
            output("ASN1real_cmp(%s, %s)",
                Reference(valref1), Reference(valref2));
        else
            output("ASN1double_cmp(%s, %s)",
                valref1, valref2);
        break;

    case ePERSTIData_BitString:

        /* compare bit string values */
        output("ASN1bitstring_cmp(%s, %s, 0)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_RZBBitString:

        /* compare remove-zero-bit bit string values */
        output("ASN1bitstring_cmp(%s, %s, 1)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_OctetString:

        /* compare octet string values */
        output("ASN1octetstring_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_UTF8String:

        /* compare octet string values */
        output("ASN1utf8string_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_ObjectIdentifier:

        /* compare object identifier values */
        output("ASN1objectidentifier_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_String:
    case ePERSTIData_TableString:

        /* compare string values */
        switch (noctets) {
        case 1:
            output("ASN1charstring_cmp(%s, %s)",
                Reference(valref1), Reference(valref2));
            break;
        case 2:
            output("ASN1char16string_cmp(%s, %s)",
                Reference(valref1), Reference(valref2));
            break;
        case 4:
            output("ASN1char32string_cmp(%s, %s)",
                Reference(valref1), Reference(valref2));
            break;
        }
        break;

    case ePERSTIData_ZeroString:
    case ePERSTIData_ZeroTableString:

        /* compare zero-terminated string values */
        switch (noctets) {
        case 1:
            output("ASN1ztcharstring_cmp(%s, %s)",
                valref1, valref2);
            break;
        case 2:
            output("ASN1ztchar16string_cmp(%s, %s)",
                valref1, valref2);
            break;
        case 4:
            output("ASN1ztchar32string_cmp(%s, %s)",
                valref1, valref2);
            break;
        }
        break;

    case ePERSTIData_SequenceOf:

        /* compare sequence of values by use of a comparison function */
        /* use element comparison function as argument */
        subide = GetTypeName(ass, type->U.SS.Type);
        pszPrivateValueName = GetPrivateValueName(&type->PrivateDirectives, "value");
        if (type->Rules & eTypeRules_PointerArrayMask)
        {
            output("ASN1sequenceoflengthpointer_cmp((%s)->count, (%s)->%s, (%s)->count, (%s)->%s, sizeof(%s), (int (*)(void *, void *))ASN1Compare_%s)",
                Reference(valref1), Reference(valref1), pszPrivateValueName,
                Reference(valref2), Reference(valref2), pszPrivateValueName, subide, subide);
        }
        else
        if (type->Rules & eTypeRules_SinglyLinkedList)
        {
            output("ASN1sequenceofsinglylinkedlist_cmp(%s, %s, offsetof(%s_Element, %s), (ASN1int32_t (*)(void *, void *))ASN1Compare_%s)",
                valref1, valref2, ideref, pszPrivateValueName, subide);
        }
        else
        if (type->Rules & eTypeRules_DoublyLinkedList)
        {
            output("ASN1sequenceofdoublylinkedlist_cmp(%s, %s, offsetof(%s_Element, %s), (ASN1int32_t (*)(void *, void *))ASN1Compare_%s)",
                valref1, valref2, ideref, pszPrivateValueName, subide);
        }
        else
        {
            MyAbort();
        }
        break;

    case ePERSTIData_SetOf:

        /* compare set of values by use of a comparison function */
        /* use element comparison function as argument */
        subide = GetTypeName(ass, type->U.SS.Type);
        pszPrivateValueName = GetPrivateValueName(&type->PrivateDirectives, "value");
        if (type->Rules & eTypeRules_PointerArrayMask)
        {
            output("ASN1setoflengthpointer_cmp((%s)->count, (%s)->%s, (%s)->count, (%s)->%s, sizeof(%s), (int (*)(void *, void *))ASN1Compare_%s)",
                Reference(valref1), Reference(valref1), pszPrivateValueName,
                Reference(valref2), Reference(valref2), pszPrivateValueName, subide, subide);
        }
        else
        if (type->Rules & eTypeRules_SinglyLinkedList)
        {
            output("ASN1setofsinglylinkedlist_cmp(%s, %s, offsetof(%s_Element, %s), (ASN1int32_t (*)(void *, void *))ASN1Compare_%s)",
                valref1, valref2, ideref, pszPrivateValueName, subide);
        }
        else
        if (type->Rules & eTypeRules_DoublyLinkedList)
        {
            output("ASN1setofdoublylinkedlist_cmp(%s, %s, offsetof(%s_Element, %s), (ASN1int32_t (*)(void *, void *))ASN1Compare_%s)",
                valref1, valref2, ideref, pszPrivateValueName, subide);
        }
        else
        {
            MyAbort();
        }
        break;

    case ePERSTIData_Reference:

        /* call compare function of referenced value */
        output("ASN1Compare_%s(%s, %s)",
            GetTypeName(ass, type), Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_External:

        /* compare external values */
        output("ASN1external_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_EmbeddedPdv:

        /* compare embedded pdv values */
        output("ASN1embeddedpdv_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_MultibyteString:

        /* compare multibyte string values */
        output("ASN1ztcharstring_cmp(%s, %s)",
            valref1, valref2);
        break;

    case ePERSTIData_UnrestrictedString:

        /* compare character string values */
        output("ASN1characterstring_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_GeneralizedTime:

        /* compare generalized time values */
        output("ASN1generalizedtime_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_UTCTime:

        /* compare utc time values */
        output("ASN1utctime_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_Open:

        /* compare open type values */
        output("ASN1open_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;
    }
}
#endif // ENABLE_COMPARE

/* generate encoding-independent statements for better optional flags of */
/* a sequence/set value */
void
GenFuncSequenceSetOptionals(AssignmentList_t ass, char *valref, ComponentList_t components, uint32_t optionals, uint32_t extensions, char *obuf, TypeFunc_e et)
{
    uint32_t optindex, inextension, oflg;
    Component_t *com;
    char *ide;
    char *itype;
    int flg;
    int32_t sign, noctets;
    uint32_t zero;

    sprintf(obuf, "(%s)->o", valref);
    oflg = 0;
    if (et == eEncode) {
        optindex = 0;
        inextension = 0;
        for (com = components; com; com = com->Next) {
            switch (com->Type) {
            case eComponent_Normal:

                /* non-optional fields in an extension will be mandatory, */
                /* so we can set the optional flag always. */
                if (inextension) {
                    if (!oflg) {
                        outputvar("ASN1octet_t o[%u];\n",
                            (optionals + 7) / 8 + (extensions + 7) / 8);
                        output("CopyMemory(o, (%s)->o, %u);\n", valref,
                            (optionals + 7) / 8 + (extensions + 7) / 8);
                        strcpy(obuf, "o");
                        oflg = 1;
                    }
                    output("%s[%u] |= 0x%x;\n", obuf, optindex / 8,
                        0x80 >> (optindex & 7));
                    optindex++;
                }
                break;

            case eComponent_Optional:

                /* optional pointers with value null are absent, so we */
                /* will clear the optional flag */
                ide = Identifier2C(com->U.Optional.NamedType->Identifier);
                switch (com->U.Optional.NamedType->Type->Type) {
                case eType_Reference:
                    if (GetTypeRules(ass, com->U.Optional.NamedType->Type) &
                        eTypeRules_Pointer) {
                        if (!oflg) {
                            outputvar("ASN1octet_t o[%u];\n",
                                (optionals + 7) / 8 + (extensions + 7) / 8);
                            output("CopyMemory(o, (%s)->o, %u);\n", valref,
                                (optionals + 7) / 8 + (extensions + 7) / 8);
                            strcpy(obuf, "o");
                            oflg = 1;
                        }
                        output("if (!(%s)->%s)\n", valref, ide);
                        output("o[%u] &= ~0x%x;\n", valref, optindex / 8,
                            0x80 >> (optindex & 7));
                    }
                    break;
                }
                optindex++;
                break;

            case eComponent_Default:

                /* default pointers with value null are absent, so we */
                /* will clear the optional flag */
                ide = Identifier2C(com->U.Default.NamedType->Identifier);
                switch (com->U.Default.NamedType->Type->Type) {
                case eType_Reference:
                    if (GetTypeRules(ass, com->U.Default.NamedType->Type) &
                        eTypeRules_Pointer) {
                        if (!oflg) {
                            outputvar("ASN1octet_t o[%u];\n",
                                (optionals + 7) / 8 + (extensions + 7) / 8);
                            output("CopyMemory(o, (%s)->o, %u);\n", valref,
                                (optionals + 7) / 8 + (extensions + 7) / 8);
                            strcpy(obuf, "o");
                            oflg = 1;
                        }
                        output("if (!(%s)->%s)\n", valref, ide);
                        output("o[%u] &= ~0x%x;\n", valref, optindex / 8,
                            0x80 >> (optindex & 7));
                    }
                    break;
                }

                /* if the given value is the default value, we can (BER) */
                /* or have to (CER) clear the corresponding optional flag */
                flg = 1;
                if (!oflg) {
                    switch (GetTypeType(ass, com->U.Default.NamedType->Type)) {
                    case eType_Choice:
                        if (!(GetType(ass, com->U.Default.NamedType->Type)->
                            Flags & eTypeFlags_NullChoice)) {
                            if (g_eSubEncodingRule == eSubEncoding_Canonical)
                                MyAbort(); /*XXX*/
                            flg = 0;
                        }
                        break;
                    case eType_Sequence:
                    case eType_Set:
                    case eType_InstanceOf:
                        if (g_eSubEncodingRule == eSubEncoding_Canonical)
                            MyAbort(); /*XXX*/
                        flg = 0;
                        break;
                    case eType_SequenceOf:
                    case eType_SetOf:
                        if (GetValue(ass, com->U.Default.Value)->U.SS.Values) {
                            if (g_eSubEncodingRule == eSubEncoding_Canonical)
                                MyAbort();
                            flg = 0;
                        }
                        break;
                    }
                    if (flg) {
                        outputvar("ASN1octet_t o[%u];\n",
                            (optionals + 7) / 8 + (extensions + 7) / 8);
                        output("CopyMemory(o, (%s)->o, %u);\n", valref,
                            (optionals + 7) / 8 + (extensions + 7) / 8);
                        strcpy(obuf, "o");
                        oflg = 1;
                    }
                }
                switch (GetTypeType(ass, com->U.Default.NamedType->Type)) {
                case eType_Boolean:
                    output("if (%s(%s)->%s)\n",
                        GetValue(ass,
                        com->U.Default.Value)->U.Boolean.Value ?  "" : "!",
                        valref, ide);
                    break;
                case eType_Integer:
                    itype = GetIntegerType(ass,
                        GetType(ass, com->U.Default.NamedType->Type),
                        &sign);
                    if (!strcmp(itype, "ASN1intx_t")) {
                        output("if (!ASN1intx_cmp(&(%s)->%s, &%s))\n",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value));
                    } else if (sign > 0) {
                        output("if ((%s)->%s == %u)\n", valref, ide,
                            intx2uint32(&GetValue(ass, com->U.Default.Value)
                            ->U.Integer.Value));
                    } else {
                        output("if ((%s)->%s == %d)\n", valref, ide,
                            intx2int32(&GetValue(ass, com->U.Default.Value)
                            ->U.Integer.Value));
                    }
                    break;
                case eType_BitString:
                    if (GetValue(ass, com->U.Default.Value)->
                        U.BitString.Value.length) {
                        output("if (!ASN1bitstring_cmp(&%s->%s, &%s, %d))\n",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value),
                            !!GetType(ass, com->U.Default.NamedType->Type)->
                            U.BitString.NamedNumbers);
                    } else {
                        output("if (!(%s)->%s.length)\n", valref, ide);
                    }
                    break;
                case eType_OctetString:
                    if (GetValue(ass, com->U.Default.Value)->U.OctetString.
                        Value.length) {
                        output("if (!ASN1octetstring_cmp(&%s->%s, &%s))\n",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value));
                    } else {
                        output("if (!(%s)->%s.length)\n", valref, ide);
                    }
                    break;
                case eType_UTF8String:
                    if (GetValue(ass, com->U.Default.Value)->U.UTF8String.
                        Value.length) {
                        output("if (!ASN1utf8string_cmp(&%s->%s, &%s))\n",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value));
                    } else {
                        output("if (!(%s)->%s.length)\n", valref, ide);
                    }
                    break;
                case eType_Null:
                    break;
                case eType_ObjectIdentifier:
                    if (GetValue(ass, com->U.Default.Value)->U.
                        ObjectIdentifier.Value.length) {
                        output("if (!ASN1objectidentifier%s_cmp(&%s->%s, &%s))\n",
                            com->U.Default.NamedType->Type->PrivateDirectives.fOidArray ? "2" : "",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value));
                    } else {
                        output("if (!(%s)->%s.length)\n", valref, ide);
                    }
                    break;
                case eType_ObjectDescriptor:
                    output("if (!strcmp((%s)->%s, %s))\n",
                        valref, ide,
                        GetValueName(ass, com->U.Default.Value));
                    break;
                case eType_External:
                    output("if (!ASN1external_cmp(&(%s)->%s, &%s))\n",
                        valref, ide,
                        GetValueName(ass, com->U.Default.Value));
                    break;
                case eType_Real:
                    itype = GetTypeName(ass, com->U.Default.NamedType->Type);
                    if (!strcmp(itype, "ASN1real_t")) {
                        output("if (!ASN1real_cmp(&(%s)->%s, &%s))\n",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value));
                    }
                    else
                    {
                        output("if ((%s)->%s == %g)\n",
                            valref, ide,
                            real2double(&GetValue(ass,
                            com->U.Default.Value)->U.Real.Value));
                    }
                    break;
                case eType_Enumerated:
                    output("if ((%s)->%s == %u)\n", valref, ide,
                        GetValue(ass, com->U.Default.Value)->
                        U.Enumerated.Value);
                    break;
                case eType_EmbeddedPdv:
                    output("if (!ASN1embeddedpdv_cmp(&(%s)->%s, &%s))\n",
                        valref, ide,
                        GetValueName(ass, com->U.Default.Value));
                    break;
                case eType_NumericString:
                case eType_PrintableString:
                case eType_TeletexString:
                case eType_T61String:
                case eType_VideotexString:
                case eType_IA5String:
                case eType_GraphicString:
                case eType_VisibleString:
                case eType_ISO646String:
                case eType_GeneralString:
                case eType_UniversalString:
                case eType_BMPString:
                case eType_RestrictedString:
                    GetStringType(ass, com->U.Default.NamedType->Type,
                        &noctets, &zero);
                    if (zero) {
                        switch (noctets) {
                        case 1:
                            output("if (!strcmp((%s)->%s, %s))\n",
                                valref, ide,
                                GetValueName(ass, com->U.Default.Value));
                            break;
                        case 2:
                            output("if (!ASN1str16cmp((%s)->%s, %s))\n",
                                valref, ide,
                                GetValueName(ass, com->U.Default.Value));
                            break;
                        case 4:
                            output("if (!ASN1str32cmp((%s)->%s, %s))\n",
                                valref, ide,
                                GetValueName(ass, com->U.Default.Value));
                            break;
                        default:
                            MyAbort();
                        }
                    } else {
                        switch (noctets) {
                        case 1:
                            output("if (!ASN1charstring_cmp(&(%s)->%s, &%s))\n",
                                valref, ide,
                                GetValueName(ass, com->U.Default.Value));
                            break;
                        case 2:
                            output("if (!ASN1char16string_cmp(&(%s)->%s, &%s))\n",
                                valref, ide,
                                GetValueName(ass, com->U.Default.Value));
                            break;
                        case 4:
                            output("if (!ASN1char32string_cmp(&(%s)->%s, &%s))\n",
                                valref, ide,
                                GetValueName(ass, com->U.Default.Value));
                            break;
                        default:
                            MyAbort();
                        }
                    }
                    break;
                case eType_CharacterString:
                    output("if (!ASN1characterstring_cmp(&(%s)->%s, &%s))\n",
                        valref, ide,
                        GetValueName(ass, com->U.Default.Value));
                    break;
                case eType_UTCTime:
                    output("if (!ASN1utctime_cmp(&(%s)->%s, &%s))\n",
                        valref, ide,
                        GetValueName(ass, com->U.Default.Value));
                    break;
                case eType_GeneralizedTime:
                    output("if (!ASN1generalizedtime_cmp(&(%s)->%s, &%s))\n",
                        valref, ide,
                        GetValueName(ass, com->U.Default.Value));
                    break;
                case eType_Choice:
                    if (GetType(ass, com->U.Default.NamedType->Type)->Flags
                        & eTypeFlags_NullChoice) {
                        output("if ((%s)->%s.o == %s.o)\n",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value));
                    } else {
                        if (g_eSubEncodingRule == eSubEncoding_Canonical)
                            MyAbort(); /*XXX*/
                        flg = 0;
                    }
                    break;
                case eType_Sequence:
                case eType_Set:
                case eType_InstanceOf:
                    if (g_eSubEncodingRule == eSubEncoding_Canonical)
                        MyAbort(); /*XXX*/
                    flg = 0;
                    break;
                case eType_SequenceOf:
                case eType_SetOf:
                    if (!GetValue(ass, com->U.Default.Value)->U.SS.Values) {
                        output("if (!(%s)->%s.count)\n", valref, ide);
                    } else {
                        if (g_eSubEncodingRule == eSubEncoding_Canonical)
                            MyAbort();
                        flg = 0;
                    }
                    break;
                default:
                    MyAbort();
                }
                if (flg)
                    output("%s[%u] &= ~0x%x;\n", obuf, optindex / 8,
                        0x80 >> (optindex & 7));
                optindex++;
                break;

            case eComponent_ExtensionMarker:

                /* update the optional index for extensions */
                optindex = (optindex + 7) & ~7;
                inextension = 1;
                break;
            }
        }
    }
}

/* generate encoding-independent statements for better optional values of */
/* a sequence/set value */
void
GenFuncSequenceSetDefaults(AssignmentList_t ass, char *valref, ComponentList_t components, char *obuf, TypeFunc_e et)
{
    uint32_t optindex, inextension;
    Component_t *com;
    char *ide;
    char *itype;
    int32_t sign;

    if (et == eDecode) {
        optindex = 0;
        inextension = 0;
        for (com = components; com; com = com->Next) {
            switch (com->Type) {
            case eComponent_Normal:

                /* all values in an extension are optional */
                if (!inextension)
                    break;
                /*FALLTHROUGH*/

            case eComponent_Optional:

                /* clear the pointer if the component is not present */
                ide = Identifier2C(com->U.Optional.NamedType->Identifier);
                switch (com->U.Optional.NamedType->Type->Type) {
                case eType_Reference:
                    if (GetTypeRules(ass, com->U.Optional.NamedType->Type) &
                        eTypeRules_Pointer) {
                        output("if (!(%s[%u] & 0x%x))\n", obuf,
                            optindex / 8, 0x80 >> (optindex & 7));
                        output("(%s)->%s = NULL;\n", valref, ide);
                    }
                    break;
                }
                optindex++;
                break;

            case eComponent_Default:

                /* clear the pointer if the component is not present */
                ide = Identifier2C(com->U.Default.NamedType->Identifier);
                switch (com->U.Optional.NamedType->Type->Type) {
                case eType_Reference:
                    if (GetTypeRules(ass, com->U.Optional.NamedType->Type) &
                        eTypeRules_Pointer) {
                        output("if (!(%s[%u] & 0x%x))\n", obuf,
                            optindex / 8, 0x80 >> (optindex & 7));
                        output("(%s)->%s = NULL;\n", valref, ide);
                    }
                    break;
                }

                /* set the element to the default value if it is simple */
                /* and not present */
                switch (GetTypeType(ass, com->U.Default.NamedType->Type)) {
                case eType_Boolean:
                    output("if (!(%s[%u] & 0x%x))\n", obuf, optindex / 8,
                        0x80 >> (optindex & 7));
                    output("(%s)->%s = %u;\n",
                        valref, ide, GetValue(ass, com->U.Default.Value)->
                        U.Boolean.Value);
                    break;
                case eType_Integer:
                    output("if (!(%s[%u] & 0x%x))\n", obuf, optindex / 8,
                        0x80 >> (optindex & 7));
                    itype = GetIntegerType(ass,
                        GetType(ass, com->U.Default.NamedType->Type),
                        &sign);
                    if (!strcmp(itype, "ASN1intx_t")) {
                        /*EMPTY*/
                    } else if (sign > 0) {
                        output("(%s)->%s = %u;\n", valref, ide,
                            intx2uint32(&GetValue(ass, com->U.Default.Value)
                            ->U.Integer.Value));
                    } else {
                        output("(%s)->%s = %d;\n", valref, ide,
                            intx2int32(&GetValue(ass, com->U.Default.Value)
                            ->U.Integer.Value));
                    }
                    break;
                case eType_Enumerated:
                    output("if (!(%s[%u] & 0x%x))\n", obuf, optindex / 8,
                        0x80 >> (optindex & 7));
                    output("(%s)->%s = %u;\n", valref, ide,
                        GetValue(ass, com->U.Default.Value)->
                        U.Enumerated.Value);
                    break;
                }
                optindex++;
                break;

            case eComponent_ExtensionMarker:

                /* update the optional index for extensions */
                optindex = (optindex + 7) & ~7;
                inextension = 1;
                break;
            }
        }
    }
}

/* generate values */
void
GenFuncValue(AssignmentList_t ass, Assignment_t *av, ValueFunc_e ev)
{
    char *ideref;
    char *typeref;
    Type_t *t;

    ideref = GetName(av);
    t = GetValue(ass, av->U.Value.Value)->Type;
    typeref = GetTypeName(ass, t);
    switch (ev) {
    case eDecl:
        GenDeclGeneric(ass, ideref, typeref, av->U.Value.Value, t);
        break;
    case eDefh:
        GenDefhGeneric(ass, ideref, typeref, av->U.Value.Value, t);
        break;
    case eDefn:
        GenDefnGeneric(ass, ideref, typeref, av->U.Value.Value, t);
        break;
    case eInit:
        GenInitGeneric(ass, ideref, typeref, av->U.Value.Value, t);
        break;
    case eFinit:
        break;
    }
}

/* generate forward declarations */
void
GenDeclGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t)
{
    value = GetValue(ass, value);
#if 0 // duplicate in the generated header file
    switch (t->Type)
    {
    case eType_ObjectIdentifier:
        if (t->PrivateDirectives.fOidArray || g_fOidArray)
        {
            output("extern ASN1objectidentifier2_t *%s;\n", ideref);
            break;
        }
        // intentionally fall through
    default:
        output("extern %s %s;\n", typeref, ideref);
        break;
    }
#endif // 0
    outputvalue0(ass, ideref, typeref, value);
}

/* generate definitions of value components */
void
GenDefhGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t)
{
    value = GetValue(ass, value);
    outputvalue1(ass, ideref, typeref, value);
}

/* generate definitions of values */
void
GenDefnGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t)
{
    value = GetValue(ass, value);
    switch (t->Type)
    {
    case eType_ObjectIdentifier:
        if (t->PrivateDirectives.fOidPacked ||
            t->PrivateDirectives.fOidArray || g_fOidArray)
        {
            // lonchanc: intentionally comment out the lines below
            // output("ASN1objectidentifier2_t *%s = ", ideref);
            // break;
            return;
        }
        // intentionally fall through
    default:
        output("%s %s = ", typeref, ideref);
        break;
    }
    outputvalue2(ass, ideref, value);
    output(";\n");
}

/* generate assignments into the initialization function */
/*ARGSUSED*/
void
GenInitGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t)
{
    outputvalue3(ass, ideref, ideref, value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\intx.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

// lonchanc: we seem to have a significant amount of memory leak
// while dealing with real number and unlimited integers.
// we definitely want to re-visit all the following routines carefully
// in the future.
// moreover, we need to make sure all the memory allocation and free
// are either using encoding and decoding memory manager or kernel one.
// need to make sure we do not mix them together.

#include "precomp.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* builtin intx values */
ASN1octet_t ASN1intx_0_[] = { 0 };
ASN1intx_t ASN1intx_0 = { 1, ASN1intx_0_ };
ASN1octet_t ASN1intx_1_[] = { 1 };
ASN1intx_t ASN1intx_1 = { 1, ASN1intx_1_ };
ASN1octet_t ASN1intx_2_[] = { 2 };
ASN1intx_t ASN1intx_2 = { 1, ASN1intx_2_ };
ASN1octet_t ASN1intx_16_[] = { 16 };
ASN1intx_t ASN1intx_16 = { 1, ASN1intx_16_ };
ASN1octet_t ASN1intx_256_[] = { 1, 0 };
ASN1intx_t ASN1intx_256 = { 2, ASN1intx_256_ };
ASN1octet_t ASN1intx_64K_[] = { 1, 0, 0 };
ASN1intx_t ASN1intx_64K = { 3, ASN1intx_64K_ };
ASN1octet_t ASN1intx_1G_[] = { 64, 0, 0, 0 };
ASN1intx_t ASN1intx_1G = { 4, ASN1intx_1G_ };

/* add two intx values */
void
ASN1intx_add(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1intx_t *arg2)
{
    ASN1octet_t *v;
    int l;
    int s1, s2;
    int o1, o2;
    int i;
    int c;
    int w;

    /* get signs */
    s1 = arg1->value[0] > 0x7f ? 0xff : 0x00;
    s2 = arg2->value[0] > 0x7f ? 0xff : 0x00;

    /* result length will be <= l */
    l = arg1->length > arg2->length ? arg1->length + 1 : arg2->length + 1;

    /* offset into values */
    o1 = l - arg1->length;
    o2 = l - arg2->length;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* clear carry bit */
    c = 0;

    /* add octet by octet */
    for (i = l - 1; i >= 0; i--) {
        w = (i >= o1 ? arg1->value[i - o1] : s1) + (i >= o2 ? arg2->value[i - o2] : s2) + c;
        v[i] = (ASN1octet_t)w;
        c = w > 0xff;
    }

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

    /* allocate and copy result */
    dst->length = l - i;
    dst->value = (ASN1octet_t *)malloc(l - i);
    memcpy(dst->value, v + i, l - i);
    free(v);
}

/* substract two intx values */
void
ASN1intx_sub(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1intx_t *arg2)
{
    ASN1octet_t *v;
    int l;
    int s1, s2;
    int o1, o2;
    int i;
    int c;
    int w;

    /* get signs */
    s1 = arg1->value[0] > 0x7f ? 0xff : 0x00;
    s2 = arg2->value[0] > 0x7f ? 0xff : 0x00;

    /* result length will be <= l */
    l = arg1->length > arg2->length ? arg1->length + 1 : arg2->length + 1;

    /* offset into values */
    o1 = l - arg1->length;
    o2 = l - arg2->length;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* clear borrow bit */
    c = 0;

    /* substract octet by octet */
    for (i = l - 1; i >= 0; i--) {
        w = (i >= o1 ? arg1->value[i - o1] : s1) - (i >= o2 ? arg2->value[i - o2] : s2) - c;
        v[i] = (ASN1octet_t)w;
        c = w < 0;
    }

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

// lonchanc: do we forget to free dst->value???
// in case that dst and arg1 are identical. for instance, 
// ASN1BEREncReal() calls ASN1intx_sub(&exponent, &exponent, &help);
    /* allocate and copy result */
    dst->length = l - i;
    dst->value = (ASN1octet_t *)malloc(l - i);
    memcpy(dst->value, v + i, l - i);
    free(v);
}

/* add one octet to an intx */
void
ASN1intx_addoctet(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1octet_t arg2)
{
    ASN1octet_t *v;
    int l;
    int i;
    int c;
    int w;

    /* result length will be <= l */
    l = arg1->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* add octet by octet */
    c = arg2;
    for (i = l - 2; i >= 0; i--) {
        w = arg1->value[i] + c;
        v[i + 1] = (ASN1octet_t)w;
        c = (w > 0xff);
    }
    v[0] = arg1->value[0] > 0x7f ? (ASN1octet_t)(0xff + c) : (ASN1octet_t)c;

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

    /* allocate and copy result */
    dst->length = l - i;
    dst->value = (ASN1octet_t *)malloc(l - i);
    memcpy(dst->value, v + i, l - i);
    free(v);
}

/* substract one octet to an intx */
void
ASN1intx_suboctet(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1octet_t arg2)
{
    ASN1octet_t *v;
    int l;
    int i;
    int c;
    int w;

    /* result length will be <= l */
    l = arg1->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* substract octet by octet */
    c = arg2;
    for (i = l - 2; i >= 0; i--) {
        w = arg1->value[i] - c;
        v[i + 1] = (ASN1octet_t)w;
        c = (w < 0);
    }
    v[0] = arg1->value[0] > 0x7f ? (ASN1octet_t)(0xff - c) : (ASN1octet_t)c;

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

    /* allocate and copy result */
    dst->length = l - i;
    dst->value = (ASN1octet_t *)malloc(l - i);
    memcpy(dst->value, v + i, l - i);
    free(v);
}

/* multiply intx by an octet */
void
ASN1intx_muloctet(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1octet_t arg2)
{
    ASN1octet_t *v;
    int l;
    int c;
    int i;
    int w;

    /* result length will be <= l */
    l = arg1->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* multiply octet by octet */
    c = 0;
    for (i = l - 2; i >= 0; i--) {
        w = arg1->value[i] * arg2 + c;
        v[i + 1] = (ASN1octet_t)w;
        c = w >> 8;
    }
    v[0] = (ASN1octet_t)(arg1->value[0] > 0x7f ? 0xff * arg2 + c : c);

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

    /* allocate and copy result */
    dst->length = l - i;
    dst->value = (ASN1octet_t *)malloc(l - i);
    memcpy(dst->value, v + i, l - i);
    free(v);
}

/* increment an intx */
void
ASN1intx_inc(ASN1intx_t *val)
{
    ASN1octet_t *v;
    int l;
    int i;
    int w;

    /* result length will be <= l */
    l = val->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* copy value */
    memcpy(v + 1, val->value, l - 1);
    free(val->value);
    v[0] = v[1] > 0x7f ? 0xff : 0x00;

    /* increment value */
    for (i = l - 1; i >= 0; i--) {
        if (++v[i])
            break;
    }

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

    /* allocate and copy result */
    val->length = l - i;
    val->value = (ASN1octet_t *)malloc(l - i);
    memcpy(val->value, v + i, l - i);
    free(v);
}

/* decrement an intx */
void
ASN1intx_dec(ASN1intx_t *val)
{
    ASN1octet_t *v;
    int l;
    int i;
    int w;

    /* result length will be <= l */
    l = val->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* copy value */
    memcpy(v + 1, val->value, l - 1);
    free(val->value);
    v[0] = v[1] > 0x7f ? 0xff : 0x00;

    /* decrement value */
    for (i = l - 1; i >= 0; i--) {
        if (v[i]--)
            break;
    }

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

    /* allocate and copy result */
    val->length = l - i;
    val->value = (ASN1octet_t *)malloc(l - i);
    memcpy(val->value, v + i, l - i);
    free(v);
}

/* negate an intx value */
void
ASN1intx_neg(ASN1intx_t *dst, ASN1intx_t *arg)
{
    ASN1uint32_t i;

    /* duplicate value */
    ASN1intx_dup(dst, arg);

    /* ones complement */
    for (i = 0; i < dst->length; i++)
        dst->value[i] = ~dst->value[i];
    
    /* and increment */
    ASN1intx_inc(dst);
}

/* returns floor(log2(arg - 1)) */
ASN1uint32_t
ASN1intx_log2(ASN1intx_t *arg)
{
    ASN1uint32_t i;
    ASN1intx_t v;
    ASN1uint32_t n;

    ASN1intx_dup(&v, arg);
    ASN1intx_dec(&v);
    if (v.value[0] > 0x7f) {
        ASN1intx_free(&v);
        return 0;
    }
    for (i = 0; i < v.length; i++) {
        if (v.value[i])
            break;
    }
    if (i >= v.length) {
        n = 0;
    } else if (v.value[i] > 0x7f) {
        n = 8 * (v.length - i - 1) + 8;
    } else if (v.value[i] > 0x3f) {
        n = 8 * (v.length - i - 1) + 7;
    } else if (v.value[i] > 0x1f) {
        n = 8 * (v.length - i - 1) + 6;
    } else if (v.value[i] > 0x0f) {
        n = 8 * (v.length - i - 1) + 5;
    } else if (v.value[i] > 0x07) {
        n = 8 * (v.length - i - 1) + 4;
    } else if (v.value[i] > 0x03) {
        n = 8 * (v.length - i - 1) + 3;
    } else if (v.value[i] > 0x01) {
        n = 8 * (v.length - i - 1) + 2;
    } else {
        n = 8 * (v.length - i - 1) + 1;
    }
    ASN1intx_free(&v);
    return n;
}

/* returns floor(log2(arg - 1)) */
ASN1uint32_t
ASN1uint32_log2(ASN1uint32_t arg)
{
    ASN1uint32_t i;

    arg--;
    for (i = 32; i != 0; i--) {
        if (arg & (1 << (i - 1)))
            break;
    }
    return i;
}

/* returns floor(log256(arg - 1)) */
ASN1uint32_t
ASN1intx_log256(ASN1intx_t *arg)
{
    ASN1uint32_t i;
    ASN1intx_t v;

    ASN1intx_dup(&v, arg);
    ASN1intx_dec(&v);
    if (v.value[0] > 0x7f) {
        ASN1intx_free(&v);
        return 0;
    }
    for (i = 0; i < v.length; i++) {
        if (v.value[i])
            break;
    }
    ASN1intx_free(&v);
    return v.length - i;
}

/* returns floor(log256(arg - 1)) */
ASN1uint32_t
ASN1uint32_log256(ASN1uint32_t arg)
{
    if (arg > 0x10000) {
        if (arg > 0x1000000)
            return 4;
        return 3;
    }
    if (arg > 0x100)
        return 2;
    if (arg > 1)
        return 1;
    return 0;
}

/* compare two intx values; return 0 iff equal */
ASN1int32_t
ASN1intx_cmp(ASN1intx_t *arg1, ASN1intx_t *arg2)
{
    int s1, s2;
    int o1, o2;
    int l;
    int i;
    int d;

    s1 = arg1->value[0] > 0x7f ? 0xff : 0x00;
    s2 = arg2->value[0] > 0x7f ? 0xff : 0x00;
    if (s1 != s2)
        return s1 == 0xff ? -1 : 1;
    l = arg1->length > arg2->length ? arg1->length : arg2->length;
    o1 = l - arg1->length;
    o2 = l - arg2->length;
    for (i = 0; i < l; i++) {
        d = (i >= o1 ? arg1->value[i - o1] : s1) - (i >= o2 ? arg2->value[i - o2] : s2);
        if (d)
            return d;
    }
    return 0;
}

/* create an intx value from an uint32 value */
void
ASN1intx_setuint32(ASN1intx_t *dst, ASN1uint32_t val)
{
    ASN1octet_t o[5], *v = o;
    int n = 5;
    v[0] = 0;
    v[1] = (ASN1octet_t)(val >> 24);
    v[2] = (ASN1octet_t)(val >> 16);
    v[3] = (ASN1octet_t)(val >> 8);
    v[4] = (ASN1octet_t)(val);
    while (n > 1 && !*v && v[1] <= 0x7f) {
        n--;
        v++;
    }
    dst->length = n;
    dst->value = (ASN1octet_t *)malloc(n);
    memcpy(dst->value, v, n);
}

/* create an intx value from an int32 value */
void
ASN1intx_setint32(ASN1intx_t *dst, ASN1int32_t val)
{
    ASN1octet_t o[5], *v = o;
    int n = 5;
    v[0] = (ASN1octet_t)(val < 0 ? 0xff : 0x00);
    v[1] = (ASN1octet_t)(val >> 24);
    v[2] = (ASN1octet_t)(val >> 16);
    v[3] = (ASN1octet_t)(val >> 8);
    v[4] = (ASN1octet_t)(val);
    while (n > 1 && ((!*v && v[1] <= 0x7f) || (*v == 0xff && v[1] > 0x7f))) {
        n--;
        v++;
    }
    dst->length = n;
    dst->value = (ASN1octet_t *)malloc(n);
    memcpy(dst->value, v, n);
}

/* copy constructor */
void
ASN1intx_dup(ASN1intx_t *dst, ASN1intx_t *val)
{
    dst->length = val->length;
    dst->value = (ASN1octet_t *)malloc(val->length);
    memcpy(dst->value, val->value, val->length);
}

/* free an intx value */
void
ASN1intx_free(ASN1intx_t *val)
{
    free(val->value);
}

#ifdef HAS_SIXTYFOUR_BITS
/* convert an intx value to a uint64 value */
ASN1uint64_t
ASN1intx2uint64(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1uint64_t)val->value[val->length - 1];
    case 2:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16));
    case 4:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    case 5:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32));
    case 6:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40));
    case 7:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48));
    default:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48) |
            ((ASN1uint64_t)val->value[val->length - 8] << 56));
    }
}
#endif

/* check if intx value is a uint64 value */
int
ASN1intxisuint64(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 8;
}

#ifdef HAS_SIXTYFOUR_BITS
/* convert an intx value to a int64 value */
ASN1int64_t
ASN1intx2int64(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1int64_t)(ASN1int8_t)val->value[val->length - 1];
    case 2:
        return (ASN1int64_t)(ASN1int16_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1int64_t)(ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 3] > 0x7f ?
            0xffffffffff000000LL : 0));
    case 4:
        return (ASN1int64_t)(ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    case 5:
        return (ASN1int64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 5] > 0x7f ?
            0xffffff0000000000LL : 0));
    case 6:
        return (ASN1int64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 6] > 0x7f ?
            0xffff000000000000LL : 0));
    case 7:
        return (ASN1int64_t)((ASN1uint64_t)val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48) |
            ((ASN1uint64_t)val->value[val->length - 7] > 0x7f ?
            0xff00000000000000LL : 0));
    default:
        return (ASN1int64_t)((ASN1uint64_t)val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48) |
            ((ASN1uint64_t)val->value[val->length - 8] << 56));
    }
}
#endif

/* check if intx value is an int64 value */
int
ASN1intxisint64(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 8;
}

/* convert intx value to uint32 value */
ASN1uint32_t
ASN1intx2uint32(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1uint32_t)val->value[val->length - 1];
    case 2:
        return (ASN1uint32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1uint32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16));
    default:
        return (ASN1uint32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    }
}

/* check if intx value is an uint32 value */
int
ASN1intxisuint32(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 4;
}

/* convert intx value to int32 value */
ASN1int32_t
ASN1intx2int32(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1int32_t)(ASN1int8_t)val->value[val->length - 1];
    case 2:
        return (ASN1int32_t)(ASN1int16_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 3] > 0x7f ?
            0xff000000 : 0));
    default:
        return (ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    }
}

/* check if intx value is an int32 value */
int
ASN1intxisint32(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 4;
}

/* convert intx value to uint16 value */
ASN1uint16_t
ASN1intx2uint16(ASN1intx_t *val)
{
    if (val->length == 1)
        return (ASN1uint16_t)val->value[val->length - 1];
    return (ASN1uint16_t)(val->value[val->length - 1] |
        ((ASN1uint32_t)val->value[val->length - 2] << 8));
}

/* check if intx value is an uint16 value */
int
ASN1intxisuint16(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 2;
}

/* convert intx value to int16 value */
ASN1int16_t
ASN1intx2int16(ASN1intx_t *val)
{
    if (val->length == 1)
        return (ASN1int16_t)(ASN1int8_t)val->value[val->length - 1];
    return (ASN1int16_t)(val->value[val->length - 1] |
        ((ASN1uint32_t)val->value[val->length - 2] << 8));
}

/* check if intx value is an int16 value */
int
ASN1intxisint16(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 2;
}

/* convert intx value to uint8 value */
ASN1uint8_t
ASN1intx2uint8(ASN1intx_t *val)
{
    return (ASN1uint8_t)val->value[val->length - 1];
}

/* check if intx value is an uint8 value */
int
ASN1intxisuint8(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 1;
}

/* convert intx value to int8 value */
ASN1int8_t
ASN1intx2int8(ASN1intx_t *val)
{
    return (ASN1int8_t)val->value[val->length - 1];
}

/* check if intx value is an int8 value */
int
ASN1intxisint8(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 1;
}

/* count octets for a signed encoding of an intx value */
ASN1uint32_t
ASN1intx_octets(ASN1intx_t *val)
{
    ASN1uint32_t i;
    ASN1uint32_t s;

    s = val->value[0] > 0x7f ? 0xff : 0x00;
    for (i = 0; i < val->length; i++) {
        if (val->value[i] != s)
            break;
    }
    if (i && ((val->value[i] ^ s) & 0x80))
        i--;
    return val->length - i;
}

/* count octets for unsigned encoding of an unsigned intx value */
ASN1uint32_t
ASN1intx_uoctets(ASN1intx_t *val)
{
    ASN1uint32_t i;

    for (i = 0; i < val->length; i++) {
        if (val->value[i])
            break;
    }
    return val->length - i;
}

/* count octets for signed encoding of an uint32 value */
ASN1uint32_t
ASN1uint32_octets(ASN1uint32_t val)
{
    if (val >= 0x8000) {
        if (val >= 0x800000) {
            if (val >= 0x80000000)
                return 5;
            return 4;
        }
        return 3;
    }
    if (val >= 0x80)
        return 2;
    return 1;
}

/* count octets for unsigned encoding of an uint32 value */
ASN1uint32_t
ASN1uint32_uoctets(ASN1uint32_t val)
{
    if (val >= 0x10000) {
        if (val >= 0x1000000)
            return 4;
        return 3;
    }
    if (val >= 0x100)
        return 2;
    return 1;
}

/* count octets for signed encoding of an int32 value */
ASN1uint32_t
ASN1int32_octets(ASN1int32_t val)
{
    if (val >= 0) {
        if (val >= 0x8000) {
            if (val >= 0x800000)
                return 4;
            return 3;
        }
        if (val >= 0x80)
            return 2;
        return 1;
    }
    if (val < -0x8000) {
        if (val < -0x800000)
            return 4;
        return 3;
    }
    if (val < -0x80)
        return 2;
    return 1;
}

/* convert an intx value into a double */
double
ASN1intx2double(ASN1intx_t *val)
{
    double ret;
    ASN1uint32_t i;

    if (val->value[0] > 0x7f)
        ret = (double)(val->value[0] - 0x100);
    else
        ret = (double)val->value[0];
    for (i = 1; i < val->length; i++) {
        ret = ret * 256.0 + (double)val->value[i];
    }
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\objid.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

/* --- NamedObjIdValue --- */

/* constructor of NamedObjIdValue_t */
NamedObjIdValue_t *NewNamedObjIdValue(NamedObjIdValue_e type)
{
    NamedObjIdValue_t *ret;

    ret = (NamedObjIdValue_t *)malloc(sizeof(NamedObjIdValue_t));
    ret->Type = type;
    ret->Next = NULL;
    ret->Name = NULL;
    ret->Number = 0xffffffff;
    return ret;
}

/* copy constructor of NamedObjIdValue_t */
NamedObjIdValue_t *DupNamedObjIdValue(NamedObjIdValue_t *src)
{
    NamedObjIdValue_t *ret;

    if (!src)
	return NULL;
    ret = (NamedObjIdValue_t *)malloc(sizeof(NamedObjIdValue_t));
    *ret = *src;
    return ret;
}

/* --- AssignedObjIds --- */

/* constructor of AssignedObjId_t */
AssignedObjId_t *NewAssignedObjId()
{
    AssignedObjId_t *ret;

    ret = (AssignedObjId_t *)malloc(sizeof(AssignedObjId_t));
    ret->Next = NULL;
    ret->Child = NULL;
    ret->Names = NULL;
    ret->Number = 0;
    return ret;
}

/* copy constructor of AssignedObjId_t */
AssignedObjId_t *DupAssignedObjId(AssignedObjId_t *src)
{
    AssignedObjId_t *ret;

    if (!src)
	return NULL;
    ret = (AssignedObjId_t *)malloc(sizeof(AssignedObjId_t));
    *ret = *src;
    return ret;
}

/* find an AssignedObjId_t by number in a list of AssignedObjId_t's */
static AssignedObjId_t *FindAssignedObjIdByNumber(AssignedObjId_t *aoi, objectnumber_t number)
{
    for (; aoi; aoi = aoi->Next) {
    	if (aoi->Number == number)
	    return aoi;
    }
    return NULL;
}

/* find an AssignedObjId_t by name in a list of AssignedObjId_t's */
static AssignedObjId_t *FindAssignedObjIdByName(AssignedObjId_t *aoi, char *name)
{
    String_t *names;

    for (; aoi; aoi = aoi->Next) {
	for (names = aoi->Names; names; names = names->Next) {
	    if (!strcmp(names->String, name))
		return aoi;
	}
    }
    return NULL;
}

/* convert a NamedObjIdValue into an object identifier value */
/* search for one NamedObjIdValue in AssignedObjIds; */
/* returns -1 for bad NamedObjIdValue (names defined to different values), */
/* returns 0 for unknown NamedObjIdValue (will probably be resolved in */
/* the next pass), */
/* returns 1 for success; */
/* on success: */
/* number contains the objectnumber, */
/* aoi contains a duplicate of the AssignedObjIds for the found */
/* NamedObjIdValue */
static int GetObjectIdentifierNumber(AssignedObjId_t **aoi, NamedObjIdValue_t *val, objectnumber_t *number)
{
    AssignedObjId_t *a, *a2;

    switch (val->Type) {
    case eNamedObjIdValue_NameForm:

	/* name form: search the assigned objid by name and return 0 if not */
	/* found */
	a2 = FindAssignedObjIdByName(*aoi, val->Name);
	if (!a2)
	    return 0;
	
	/* otherwise create a duplicate */
	a = DupAssignedObjId(a2);
	a->Next = *aoi;
	*aoi = a;
	break;

    case eNamedObjIdValue_NumberForm:

	/* number form: search the assigned objid by number and create */
	/* a new one/a duplicate */
	a2 = FindAssignedObjIdByNumber(*aoi, val->Number);
	if (!a2) {
	    a = NewAssignedObjId();
	    a->Number = val->Number;
	    a->Next = *aoi;
	    *aoi = a;
	} else {
	    a = DupAssignedObjId(a2);
	    a->Next = *aoi;
	    *aoi = a;
	}
	break;

    case eNamedObjIdValue_NameAndNumberForm:

	/* name and number form: search the assigned objid by name and by */
	/* number */
	a = FindAssignedObjIdByName(*aoi, val->Name);
	a2 = FindAssignedObjIdByNumber(*aoi, val->Number);

	/* successful but different results are errorneous */
	if (a && a != a2)
	    return -1;

	if (!a && !a2) {

	    /* found none, then create it */
	    a = NewAssignedObjId();
	    a->Number = val->Number;
	    a->Names = NewString();
	    a->Names->String = val->Name;
	    a->Next = *aoi;
	    *aoi = a;

	} else if (!a) {

	    /* found only by number, then duplicate it and add the name */
	    a = DupAssignedObjId(a2);
	    a->Names = NewString();
	    a->Names->String = val->Name;
	    a->Names->Next = a2->Names;
	    a->Next = *aoi;
	    *aoi = a;

	} else {

	    /* found only by name, then duplicate it */
	    a = DupAssignedObjId(a2);
	    a->Next = *aoi;
	    *aoi = a;
	}
	break;
    }
    *number = a->Number;
    return 1;
}

/*
 * create a value out of NamedObjIdValues
 * returns -1 for bad NamedObjIdValue (names defined to different values),
 * returns 0 for unknown NamedObjIdValue (will probably be resolved next pass),
 * returns 1 for success;
 */
int GetAssignedObjectIdentifier(AssignedObjId_t **aoi, Value_t *parent, NamedObjIdValueList_t named, Value_t **val)
{
    Value_t *v;
    int parentl;
    int l;
    NamedObjIdValue_t *n;
    objectnumber_t *on;

    /* get length of object identifier */
    parentl = (parent ? parent->U.ObjectIdentifier.Value.length : 0);
    for (l = parentl, n = named; n; n = n->Next)
    {
        Value_t *pValue;
        pValue = (n->Type == eNamedObjIdValue_NameForm) ?
                 GetDefinedOIDValue(n->Name) : NULL;
        if (pValue)
        {
            ASSERT(pValue->Type->Type == eType_ObjectIdentifier);
            l += pValue->U.ObjectIdentifier.Value.length;
        }
        else
        {
            l++;
        }
    }

    /* create the object identifier value */
    v = NewValue(NULL, Builtin_Type_ObjectIdentifier);
    v->U.ObjectIdentifier.Value.length = l;
    v->U.ObjectIdentifier.Value.value = on = 
	(objectnumber_t *)malloc(l * sizeof(objectnumber_t));

    /* get the numbers of the parent object identifier and walk in the object */
    /* identifier tree */
    n = NewNamedObjIdValue(eNamedObjIdValue_NumberForm);
    for (l = 0; l < parentl; l++) {
	n->Number = parent->U.ObjectIdentifier.Value.value[l];
	switch (GetObjectIdentifierNumber(aoi, n, on + l)) {
	case -1:
	    return -1;
	case 0:
	    return 0;
	default:
	    aoi = &(*aoi)->Child;
	    break;
	}
    }

    /* get the numers from the namedobjidvaluelist */
    for (n = named; n; n = n->Next)
    {
        Value_t *pValue;
        pValue = (n->Type == eNamedObjIdValue_NameForm) ?
                 GetDefinedOIDValue(n->Name) : NULL;
        if (pValue)
        {
            memcpy(on + l, pValue->U.ObjectIdentifier.Value.value,
                 pValue->U.ObjectIdentifier.Value.length * sizeof(objectnumber_t));
            l += pValue->U.ObjectIdentifier.Value.length;
        }
        else
        {
	        switch (GetObjectIdentifierNumber(aoi, n, on + l))
            {
	        case -1:
	            return -1;
	        case 0:
	            return 0;
	        default:
	            aoi = &(*aoi)->Child;
	            break;
	        }
            l++;
        }
    }

    *val = v;
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\optcase.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_OPT_CASE_H_
#define _ASN1C_OPT_CASE_H_

int PerOptCase_IsSignedInteger(PERSimpleTypeInfo_t *sinfo);
int PerOptCase_IsUnsignedInteger(PERSimpleTypeInfo_t *sinfo);
int PerOptCase_IsSignedShort(PERSimpleTypeInfo_t *sinfo);
int PerOptCase_IsUnsignedShort(PERSimpleTypeInfo_t *sinfo);
int PerOptCase_IsBoolean(PERSimpleTypeInfo_t *sinfo);
int PerOptCase_IsTargetSeqOf(PERTypeInfo_t *info);

int BerOptCase_IsBoolean(BERTypeInfo_t *info);

#endif // _ASN1C_OPT_CASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\parser.h ===
#ifndef _ASN1_PARSER_ 
#define _ASN1_PARSER_ 
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */

typedef char *XString;
typedef char32_t *XString32;
typedef intx_t XNumber;
typedef ASN1bool_t XBoolean;
typedef Type_t *XType;
typedef TagType_e XTagType;
typedef TagClass_e XTagClass;
typedef Tag_t *XTags;
typedef ExtensionType_e XExtensionType;
typedef NamedType_t *XNamedType;
typedef ComponentList_t XComponents;
typedef Constraint_t *XConstraints;
typedef ElementSetSpec_t *XElementSetSpec;
typedef SubtypeElement_t *XSubtypeElement;
typedef ObjectSetElement_t *XObjectSetElement;
typedef DirectiveList_t XDirectives;
typedef NamedConstraintList_t XNamedConstraints;
typedef Presence_e XPresence;
typedef NamedNumberList_t XNamedNumbers;
typedef Value_t *XValue;
typedef ValueSet_t *XValueSet;
typedef EndPoint_t XEndPoint;
typedef Tuple_t XTuple;
typedef Quadruple_t XQuadruple;
typedef NamedValueList_t XNamedValues;
typedef ModuleIdentifier_t *XModuleIdentifier;
typedef NamedObjIdValueList_t XNamedObjIdValue;
typedef ObjectClass_t *XObjectClass;
typedef ObjectSet_t *XObjectSet;
typedef Object_t *XObject;
typedef SyntaxSpecList_t XSyntaxSpecs;
typedef FieldSpecList_t XFieldSpecs;
typedef Optionality_t *XOptionality;
typedef SettingList_t XSettings;
typedef StringList_t XStrings;
typedef StringModuleList_t XStringModules;
typedef Macro_t *XMacro;
typedef MacroProduction_t *XMacroProduction;
typedef NamedMacroProductionList_t XMacroProductions;
typedef MacroLocalAssignmentList_t XMacroLocalAssignments;
typedef PrivateDirectives_t *XPrivateDirectives;
typedef struct LLPOS {
	int line;
	int column;
	char *file;
} LLPOS;
typedef struct LLSTATE {
	LLPOS pos;
	AssignmentList_t Assignments;
	AssignedObjIdList_t AssignedObjIds;
	UndefinedSymbolList_t Undefined;
	UndefinedSymbolList_t BadlyDefined;
	ModuleIdentifier_t *Module;
	ModuleIdentifier_t *MainModule;
	StringModuleList_t Imported;
	TagType_e TagDefault;
	ExtensionType_e ExtensionDefault;
} LLSTATE;
int ll_Main(LLSTATE *llin, LLSTATE *llout);
int ll_ModuleDefinition_ESeq(LLSTATE *llin, LLSTATE *llout);
int ll_ModuleDefinition(LLSTATE *llin, LLSTATE *llout);
int ll_ModuleIdentifier(XModuleIdentifier *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinitiveIdentifier(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinitiveObjIdComponentList(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinitiveObjIdComponent(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinitiveNumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinitiveNameAndNumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TagDefault(XTagType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExtensionDefault(XExtensionType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ModuleBody(LLSTATE *llin, LLSTATE *llout);
int ll_Exports(XStrings *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SymbolsExported(XStrings *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Imports(XStringModules *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SymbolsImported(XStringModules *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SymbolsFromModule_ESeq(XStringModules *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SymbolsFromModule(XStringModules *llret, LLSTATE *llin, LLSTATE *llout);
int ll_GlobalModuleReference(XModuleIdentifier *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AssignedIdentifier(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SymbolList(XStrings *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Symbol(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Reference(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AssignmentList(LLSTATE *llin, LLSTATE *llout);
int ll_Assignment_ESeq(LLSTATE *llin, LLSTATE *llout);
int ll_Assignment(LLSTATE *llin, LLSTATE *llout);
int ll_typereference(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Externaltypereference(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_valuereference(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Externalvaluereference(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_objectclassreference(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExternalObjectClassReference(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout);
int ll_objectreference(XObject *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExternalObjectReference(XObject *llret, LLSTATE *llin, LLSTATE *llout);
int ll_objectsetreference(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExternalObjectSetReference(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout);
int ll_macroreference(XMacro *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Externalmacroreference(XMacro *llret, LLSTATE *llin, LLSTATE *llout);
int ll_localtypereference(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_localvaluereference(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_productionreference(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_modulereference(XModuleIdentifier *llret, LLSTATE *llin, LLSTATE *llout);
int ll_typefieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_valuefieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_valuesetfieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_objectfieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_objectsetfieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_word(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_identifier(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ucsymbol(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ocsymbol(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_astring(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TypeAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_ValueSetTypeAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_ValueSet(XValueSet *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_Type(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_UndirectivedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_UntaggedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ConstrainableType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Constraint_ESeq(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_BuiltinType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ReferencedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NamedType(XNamedType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_BooleanType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_IntegerType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NamedNumberList(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NamedNumber(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_EnumeratedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Enumerations(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_EnumerationExtension(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Enumeration(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_EnumerationItem(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_RealType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_BitStringType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NamedBitList(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NamedBit(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_OctetStringType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_UTF8StringType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NullType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SequenceType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExtensionAndException(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExtendedComponentTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ComponentTypeListExtension(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AdditionalComponentTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ComponentTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ComponentType(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ComponentTypePostfix(XComponents *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SequenceOfType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SetType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SetOfType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ChoiceType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExtendedAlternativeTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AlternativeTypeListExtension(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AdditionalAlternativeTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AlternativeTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AnyType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SelectionType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TaggedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TagType(XTagType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Tag(XTags *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ClassNumber(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Class(XTagClass *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjectIdentifierType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_EmbeddedPDVType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExternalType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_CharacterStringType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_RestrictedCharacterStringType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_UnrestrictedCharacterStringType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_UsefulType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TypeWithConstraint(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ValueAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_Value(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_BuiltinValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ReferencedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NamedValue(XNamedValues *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_BooleanValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SignedNumber(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_IntegerValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_EnumeratedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_RealValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_NumericRealValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SpecialRealValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_BitStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_IdentifierList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_Identifier_EList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_IdentifierList_Elem(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_OctetStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_NullValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_GeneralizedTimeValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_UTCTimeValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ObjectDescriptorValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SequenceValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ComponentValueList(XNamedValues *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_ComponentValueCList(XNamedValues *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_SequenceOfValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ValueList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ValueCList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SetValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SetOfValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ChoiceValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ObjectIdentifierValue(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjIdComponentList(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjIdComponent_ESeq(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjIdComponent(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NameForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NameAndNumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_EmbeddedPDVValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ExternalValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_CharacterStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_RestrictedCharacterStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_UnrestrictedCharacterStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_CharacterStringList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_CharSyms(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_CharDefn(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_Quadruple(XQuadruple *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Tuple(XTuple *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AnyValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_Constraint(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_ConstraintSpec(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_SubtypeConstraint(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_ExceptionSpec(LLSTATE *llin, LLSTATE *llout);
int ll_ExceptionIdentification(LLSTATE *llin, LLSTATE *llout);
int ll_ElementSetSpecs(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_ElementSetSpecExtension(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_AdditionalElementSetSpec(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_ElementSetSpec(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_Unions(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_UnionList(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_Intersections(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_IntersectionList(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_IntersectionElements(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_Exclusions_Opt(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_Exclusions(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_UnionMark(LLSTATE *llin, LLSTATE *llout);
int ll_IntersectionMark(LLSTATE *llin, LLSTATE *llout);
int ll_Elements(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_SubtypeElements(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_SingleValue(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ContainedSubtype(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_Includes(XBoolean *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ValueRange(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_LowerEndpoint(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_UpperEndpoint(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_LowerEndValue(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_UpperEndValue(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SizeConstraint(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TypeConstraint(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PermittedAlphabet(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_InnerTypeConstraints(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SingleTypeConstraint(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_MultipleTypeConstraints(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_FullSpecification(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_PartialSpecification(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_TypeConstraints(XNamedConstraints *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_NamedConstraint(XNamedConstraints *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_ComponentConstraint(XNamedConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ValueConstraint(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_PresenceConstraint(XPresence *llret, LLSTATE *llin, LLSTATE *llout);
int ll_GeneralConstraint(LLSTATE *llin, LLSTATE *llout);
int ll_LocalTypeDirectiveSeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_LocalTypeDirectiveESeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_LocalTypeDirective(XDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_LocalSizeDirectiveSeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_LocalSizeDirectiveESeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_LocalSizeDirective(XDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Type(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Field(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Value(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Public(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Intx(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_LenPtr(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Pointer(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Array(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_NoCode(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_NoMemCopy(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_OidPacked(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_OidArray(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_SLinked(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_DLinked(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDirectives(XPrivateDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinedObjectClass(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinedObject(XObject *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinedObjectSet(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Usefulobjectclassreference(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjectClassAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_ObjectClass(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectClassDefn(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_FieldSpec_List(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_FieldSpec_EList(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_WithSyntaxSpec_opt(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_FieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_TypeFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_TypeOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout);
int ll_FixedTypeValueFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_UNIQUE_opt(XBoolean *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ValueOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_VariableTypeValueFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_FixedTypeValueSetFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ValueSetOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_VariableTypeValueSetFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectSetFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectSetOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_PrimitiveFieldName(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_FieldName(XStrings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_SyntaxList(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_TokenOrGroupSpec_Seq(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_TokenOrGroupSpec_ESeq(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_TokenOrGroupSpec(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_OptionalGroup(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_RequiredToken(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_Literal(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjectAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_Object(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectDefn(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_DefaultSyntax(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_FieldSetting_EList(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se);
int ll_FieldSetting_EListC(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se);
int ll_FieldSetting(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se);
int ll_DefinedSyntax(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_DefinedSyntaxToken_ESeq(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XSyntaxSpecs llarg_sy);
int ll_DefinedSyntaxToken(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XSyntaxSpecs llarg_sy);
int ll_DefinedSyntaxToken_Elem(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XSyntaxSpecs llarg_sy);
int ll_Setting(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XString llarg_f);
int ll_ObjectSetAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_ObjectSet(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectSetSpec(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectSetElements(XObjectSetElement *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectClassFieldType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjectClassFieldValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_OpenTypeFieldVal(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_FixedTypeFieldVal(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ValueFromObject(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ValueSetFromObjects(XValueSet *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TypeFromObject(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjectFromObject(XObject *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjectSetFromObjects(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ReferencedObjects(XObject *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ReferencedObjectSets(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout);
int ll_InstanceOfType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_InstanceOfValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_MacroDefinition(LLSTATE *llin, LLSTATE *llout);
int ll_MacroDefinedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_MacroDefinedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ParameterizedValueSetType(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedReference(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedType(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedValue(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedObjectClass(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedObject(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedObjectSet(LLSTATE *llin, LLSTATE *llout);
typedef union LLSTYPE{
	XNumber _XNumber;
	XString _XString;
	XString32 _XString32;
	XModuleIdentifier _XModuleIdentifier;
	XValue _XValue;
	XNamedObjIdValue _XNamedObjIdValue;
	XTagType _XTagType;
	XExtensionType _XExtensionType;
	XStrings _XStrings;
	XStringModules _XStringModules;
	XType _XType;
	XObjectClass _XObjectClass;
	XObject _XObject;
	XObjectSet _XObjectSet;
	XMacro _XMacro;
	XValueSet _XValueSet;
	XConstraints _XConstraints;
	XNamedType _XNamedType;
	XNamedNumbers _XNamedNumbers;
	XComponents _XComponents;
	XTags _XTags;
	XTagClass _XTagClass;
	XNamedValues _XNamedValues;
	XQuadruple _XQuadruple;
	XTuple _XTuple;
	XBoolean _XBoolean;
	XElementSetSpec _XElementSetSpec;
	XSubtypeElement _XSubtypeElement;
	XEndPoint _XEndPoint;
	XNamedConstraints _XNamedConstraints;
	XPresence _XPresence;
	XDirectives _XDirectives;
	int _int;
	XPrivateDirectives _XPrivateDirectives;
	XFieldSpecs _XFieldSpecs;
	XSyntaxSpecs _XSyntaxSpecs;
	XOptionality _XOptionality;
	XSettings _XSettings;
	XObjectSetElement _XObjectSetElement;
} LLSTYPE;
typedef struct LLTERM {
	int token;
	LLSTYPE lval;
	LLPOS pos;
} LLTERM;
void llscanner(LLTERM **tokens, unsigned *ntokens);
int llparser(LLTERM *tokens, unsigned ntokens, LLSTATE *llin, LLSTATE *llout);
void llprinterror(FILE *f);
void llverror(FILE *f, LLPOS *pos, char *fmt, va_list args);
void llerror(FILE *f, LLPOS *pos, char *fmt, ...);
int llgettoken(int *token, LLSTYPE *lval, LLPOS *pos);
#if LLDEBUG > 0
void lldebug_init();
#endif
#define T_DEF 257
#define T_DDOT 258
#define T_TDOT 259
#define T_TYPE_IDENTIFIER 260
#define T_ABSTRACT_SYNTAX 261
#define T_ZERO_TERMINATED 262
#define T_POINTER 263
#define T_NO_POINTER 264
#define T_FIXED_ARRAY 265
#define T_SINGLY_LINKED_LIST 266
#define T_DOUBLY_LINKED_LIST 267
#define T_LENGTH_POINTER 268
#define T_Number 269
#define T_number 270
#define T_bstring 271
#define T_hstring 272
#define T_cstring 273
#define T_only_uppercase_symbol 274
#define T_only_uppercase_digits_symbol 275
#define T_uppercase_symbol 276
#define T_lcsymbol 277
#define T_ampucsymbol 278
#define T_amplcsymbol 279
#define T_CON_XXX1 280
#define T_CON_XXX2 281
#define T_OBJ_XXX1 282
#define T_OBJ_XXX2 283
#define T_OBJ_XXX3 284
#define T_OBJ_XXX4 285
#define T_OBJ_XXX5 286
#define T_OBJ_XXX6 287
#define T_OBJ_XXX7 288
#define T_DUM_XXX1 289
#define T_DUM_XXX2 290
#define T_DUM_XXX3 291
#define T_DUM_XXX4 292
#define T_DUM_XXX5 293
#define T_DUM_XXX6 294
#define T_DUM_XXX7 295
#define T_DUM_XXX8 296
#define T_DUM_XXX9 297
#define T_DUM_XXX10 298
#define T_DUM_XXX11 299
#define T_DUM_XXX12 300
#define T_DUM_XXX13 301
#define T_DUM_XXX14 302
#define T_DUM_XXX15 303
#define T_DUM_XXX16 304
#define T_DUM_XXX17 305
#define T_DUM_XXX18 306
#define T_DUM_XXX19 307
#define T_DUM_XXX20 308
#define T_DEFINITIONS 309
#define T_BEGIN 310
#define T_END 311
#define T_EXPLICIT 312
#define T_TAGS 313
#define T_IMPLICIT 314
#define T_AUTOMATIC 315
#define T_EXTENSIBILITY 316
#define T_IMPLIED 317
#define T_EXPORTS 318
#define T_IMPORTS 319
#define T_FROM 320
#define T_ABSENT 321
#define T_ALL 322
#define T_ANY 323
#define T_APPLICATION 324
#define T_BMPString 325
#define T_BY 326
#define T_CLASS 327
#define T_COMPONENT 328
#define T_COMPONENTS 329
#define T_CONSTRAINED 330
#define T_DEFAULT 331
#define T_DEFINED 332
#define T_empty 333
#define T_EXCEPT 334
#define T_GeneralizedTime 335
#define T_GeneralString 336
#define T_GraphicString 337
#define T_IA5String 338
#define T_IDENTIFIER 339
#define T_identifier 340
#define T_INCLUDES 341
#define T_ISO646String 342
#define T_MACRO 343
#define T_MAX 344
#define T_MIN 345
#define T_NOTATION 346
#define T_NumericString 347
#define T_ObjectDescriptor 348
#define T_OF 349
#define T_OPTIONAL 350
#define T_PDV 351
#define T_PRESENT 352
#define T_PrintableString 353
#define T_PRIVATE 354
#define T_SIZE 355
#define T_STRING 356
#define T_string 357
#define T_SYNTAX 358
#define T_T61String 359
#define T_TeletexString 360
#define T_TYPE 361
#define T_type 362
#define T_UNIQUE 363
#define T_UNIVERSAL 364
#define T_UniversalString 365
#define T_UTCTime 366
#define T_UTF8String 367
#define T_VALUE 368
#define T_value 369
#define T_VideotexString 370
#define T_VisibleString 371
#define T_WITH 372
#define T_BOOLEAN 373
#define T_INTEGER 374
#define T_ENUMERATED 375
#define T_REAL 376
#define T_BIT 377
#define T_OCTET 378
#define T_NULL 379
#define T_SEQUENCE 380
#define T_SET 381
#define T_CHOICE 382
#define T_OBJECT 383
#define T_EMBEDDED 384
#define T_EXTERNAL 385
#define T_CHARACTER 386
#define T_TRUE 387
#define T_FALSE 388
#define T_PLUS_INFINITY 389
#define T_MINUS_INFINITY 390
#define T_UNION 391
#define T_INTERSECTION 392
#define T_PrivateDir_TypeName 393
#define T_PrivateDir_FieldName 394
#define T_PrivateDir_ValueName 395
#define T_PrivateDir_Public 396
#define T_PrivateDir_Intx 397
#define T_PrivateDir_LenPtr 398
#define T_PrivateDir_Pointer 399
#define T_PrivateDir_Array 400
#define T_PrivateDir_NoCode 401
#define T_PrivateDir_NoMemCopy 402
#define T_PrivateDir_OidPacked 403
#define T_PrivateDir_OidArray 404
#define T_PrivateDir_SLinked 405
#define T_PrivateDir_DLinked 406
#define T_INSTANCE 407
#endif // _ASN1_PARSER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\precomp.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stddef.h>
#include <ctype.h>
#include <memory.h>

#define ASN1C

#include <windows.h>

// resolve conflicts
#ifdef GetObject
#undef GetObject
#endif

#include "libasn1.h"

#ifdef ASSERT
#undef ASSERT
#endif

#ifdef _DEBUG
__inline void MyDebugBreak(void) { DebugBreak(); }
#define ASSERT(x)   if (!(x)) MyDebugBreak();
#else
#define ASSERT(x)   
#endif // _DEBUG


typedef ASN1uint8_t     uint8_t;
typedef ASN1uint16_t    uint16_t;
typedef ASN1uint32_t    uint32_t;
typedef ASN1int8_t      int8_t;
typedef ASN1int16_t     int16_t;
typedef ASN1int32_t     int32_t;
typedef ASN1octet_t octet_t;
typedef ASN1intx_t intx_t;
typedef ASN1real_e real_e;
typedef ASN1real_t real_t;
typedef ASN1octetstring_t octetstring_t;
typedef ASN1bitstring_t bitstring_t;
typedef ASN1char_t char_t;
typedef ASN1charstring_t charstring_t;
typedef ASN1ztcharstring_t ztcharstring_t;
typedef ASN1char16_t char16_t;
typedef ASN1char16string_t char16string_t;
typedef ASN1ztchar16string_t ztchar16string_t;
typedef ASN1char32_t char32_t;
typedef ASN1char32string_t char32string_t;
typedef ASN1ztchar32string_t ztchar32string_t;
typedef ASN1uint32_t objectnumber_t;
typedef ASN1objectidentifier_t objectidentifier_t;
typedef ASN1stringtableentry_t stringtableentry_t;
typedef ASN1stringtable_t stringtable_t;
typedef ASN1objectdescriptor_t objectdescriptor_t;
typedef ASN1generalizedtime_t generalizedtime_t;
typedef ASN1utctime_t utctime_t;
typedef ASN1external_t external_t;
#define intx_0 ASN1intx_0
#define intx_1 ASN1intx_1
#define intx_2 ASN1intx_2
#define intx_16 ASN1intx_16
#define intx_256 ASN1intx_256
#define intx_64K ASN1intx_64K
#define intx_1G ASN1intx_1G
#define NumericStringTable ASN1NumericStringTable;
#define intx_add ASN1intx_add
#define intx_addoctet ASN1intx_addoctet
#define intx_sub ASN1intx_sub
#define intx_suboctet ASN1intx_suboctet
#define intx_muloctet ASN1intx_muloctet
#define intx_inc ASN1intx_inc
#define intx_dec ASN1intx_dec
#define intx_neg ASN1intx_neg
#define intx_log2 ASN1intx_log2
#define intx_log256 ASN1intx_log256
#define intx_cmp ASN1intx_cmp
#define intx_dup ASN1intx_dup
#define intx_free ASN1intx_free
#define intx_setuint32 ASN1intx_setuint32
#define intx_setint32 ASN1intx_setint32
#define intx2uint64 ASN1intx2uint64
#define intx2int64 ASN1intx2int64
#define intx2uint32 ASN1intx2uint32
#define intx2int32 ASN1intx2int32
#define intx2uint16 ASN1intx2uint16
#define intx2int16 ASN1intx2int16
#define intx2uint8 ASN1intx2uint8
#define intx2int8 ASN1intx2int8
#define intxisuint64 ASN1intxisuint64
#define intxisint64 ASN1intxisint64
#define intxisuint32 ASN1intxisuint32
#define intxisint32 ASN1intxisint32
#define intxisuint16 ASN1intxisuint16
#define intxisint16 ASN1intxisint16
#define intxisuint8 ASN1intxisuint8
#define intxisint8 ASN1intxisint8
#define intx_octets ASN1intx_octets
#define intx_uoctets ASN1intx_uoctets
#define uint32_log2 ASN1uint32_log2
#define uint32_log256 ASN1uint32_log256
#define uint32_octets ASN1uint32_octets
#define uint32_uoctets ASN1uint32_uoctets
#define int32_octets ASN1int32_octets
#define intx2double ASN1intx2double
#define real2double ASN1real2double
#define intx2double ASN1intx2double
#define real2double ASN1real2double
#define double_minf ASN1double_minf
#define double_pinf ASN1double_pinf
#define double_isminf ASN1double_isminf
#define double_ispinf ASN1double_ispinf
#define generalizedtime2string ASN1generalizedtime2string
#define utctime2string ASN1utctime2string
#define string2generalizedtime ASN1string2generalizedtime
#define string2utctime ASN1string2utctime
#define real_free ASN1real_free
#define bitstring_free ASN1bitstring_free
#define octetstring_free ASN1octetstring_free
#define objectidentifier_free ASN1objectidentifier_free
#define charstring_free ASN1charstring_free
#define char16string_free ASN1char16string_free
#define char32string_free ASN1char32string_free
#define ztcharstring_free ASN1ztcharstring_free
#define ztchar16string_free ASN1ztchar16string_free
#define ztchar32string_free ASN1ztchar32string_free
#define external_free ASN1external_free
#define embeddedpdv_free ASN1embeddedpdv_free
#define characterstring_free ASN1characterstring_free
#define open_free ASN1open_free
#define bitstring_cmp ASN1bitstring_cmp
#define octetstring_cmp ASN1octetstring_cmp
#define objectidentifier_cmp ASN1objectidentifier_cmp
#define charstring_cmp ASN1charstring_cmp
#define char16string_cmp ASN1char16string_cmp
#define char32string_cmp ASN1char32string_cmp
#define ztcharstring_cmp ASN1ztcharstring_cmp
#define ztchar16string_cmp ASN1ztchar16string_cmp
#define ztchar32string_cmp ASN1ztchar32string_cmp
#define double_cmp double
#define real_cmp ASN1real_cmp
#define external_cmp ASN1external_cmp
#define embeddedpdv_cmp ASN1embeddedpdv_cmp
#define characterstring_cmp ASN1characterstring_cmp
#define open_cmp ASN1open_cmp
#define generalizedtime_cmp ASN1generalizedtime_cmp
#define utctime_cmp ASN1utctime_cmp
#define sequenceoflengthpointer_cmp
#define sequenceofsinglylinkedlist_cmp
#define sequenceofdoublylinkedlist_cmp
#define setoflengthpointer_cmp
#define setofsinglylinkedlist_cmp
#define setofdoublylinkedlist_cmp
#define is32space ASN1is32space
#define str32len ASN1str32len
#define is16space ASN1is16space
#define str16len ASN1str16len
#define bitcpy ASN1bitcpy
#define bitclr ASN1bitclr
#define bitset ASN1bitset
#define bitput ASN1bitput
#define octetput ASN1octetput


#include "defs.h"
#include "scanner.h"
#include "parser.h"
#include "builtin.h"
#include "write.h"
#include "error.h"
#include "util.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\per.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

void ExaminePERType(AssignmentList_t ass, Type_t *type, char *ideref);
static int __cdecl CmpIntxP(const void *v1, const void *v2);
void ExaminePERType_Boolean(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Integer(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Enumerated(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Real(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_BitString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_OctetString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_UTF8String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Null(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_EmbeddedPdv(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_External(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_ObjectIdentifier(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_BMPString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_GeneralString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_GraphicString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_IA5String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_ISO646String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_NumericString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_PrintableString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_TeletexString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_T61String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_UniversalString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_VideotexString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_VisibleString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_UnrestrictedString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_RestrictedString(AssignmentList_t ass, Type_t *type, intx_t *up, intx_t *nchars, char *tabref, uint32_t enbits, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_GeneralizedTime(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_UTCTime(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_ObjectDescriptor(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Open(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_SequenceSet(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_SequenceSetOf(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Choice(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Reference(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);

/* examine all types and extract informations needed for PER encoding */
void
ExaminePER(AssignmentList_t ass)
{
    Assignment_t *a;

    for (a = ass; a; a = a->Next) {
	switch (a->Type) {
	case eAssignment_Type:
	    ExaminePERType(ass, a->U.Type.Type, GetName(a));
	    break;
	default:
	    break;
	}
    }
}

/* extract some type informations needed for PER encoding */
void
ExaminePERType(AssignmentList_t ass, Type_t *type, char *ideref)
{
    PERConstraints_t *per;
    PERTypeInfo_t *info;
    uint32_t lrange, lrangelog2;

    per = &type->PERConstraints;
    info = &type->PERTypeInfo;
    info->pPrivateDirectives = &type->PrivateDirectives;

    /* get the type to be examined */
    if (type->Type == eType_Reference && !IsStructuredType(GetType(ass, type)))
	type = GetType(ass, type);

    /* initialize the PER informations */
    info->Type = eExtension_Unextended;
    info->Identifier = ideref;
    info->Rules = type->Rules;
    info->Flags = type->Flags;
    info->EnumerationValues = NULL;
    info->NOctets = 0;
    info->Root.TableIdentifier = NULL;
    info->Root.Table = NULL;
    info->Root.SubIdentifier = NULL;
    info->Root.SubType = NULL;
    info->Root.Data = ePERSTIData_Null;
    info->Root.Identification = NULL;
    info->Root.Constraint = ePERSTIConstraint_Unconstrained;
    intx_setuint32(&info->Root.LowerVal, 0);
    intx_setuint32(&info->Root.UpperVal, 0);
    info->Root.NBits = 1;
    info->Root.Alignment = ePERSTIAlignment_OctetAligned;
    info->Root.Length = ePERSTILength_NoLength;
    info->Root.LConstraint = ePERSTIConstraint_Semiconstrained;
    info->Root.LLowerVal = info->Root.LUpperVal = 0;
    info->Root.LNBits = 1;
    info->Root.LAlignment = ePERSTIAlignment_OctetAligned;
    info->Additional = info->Root;
    info->Additional.NBits = 8;
    info->Additional.Length = ePERSTILength_InfiniteLength;
    info->Additional.LNBits = 1;
    info->Additional.LAlignment = ePERSTIAlignment_OctetAligned;

    /* PER informations are type specific ... */
    switch (type->Type) {
    case eType_Boolean:
	ExaminePERType_Boolean(ass, type, per, info);
	break;
    case eType_Integer:
	ExaminePERType_Integer(ass, type, per, info);
	break;
    case eType_Enumerated:
	ExaminePERType_Enumerated(ass, type, per, info);
	break;
    case eType_Real:
	ExaminePERType_Real(ass, type, per, info);
	break;
    case eType_BitString:
	ExaminePERType_BitString(ass, type, per, info);
	break;
    case eType_OctetString:
	ExaminePERType_OctetString(ass, type, per, info);
	break;
    case eType_UTF8String:
	ExaminePERType_UTF8String(ass, type, per, info);
	break;
    case eType_Null:
	ExaminePERType_Null(ass, type, per, info);
	break;
    case eType_EmbeddedPdv:
	ExaminePERType_EmbeddedPdv(ass, type, per, info);
	break;
    case eType_External:
	ExaminePERType_External(ass, type, per, info);
	break;
    case eType_ObjectIdentifier:
	ExaminePERType_ObjectIdentifier(ass, type, per, info);
	break;
    case eType_BMPString:
	ExaminePERType_BMPString(ass, type, per, info);
	break;
    case eType_GeneralString:
	ExaminePERType_GeneralString(ass, type, per, info);
	break;
    case eType_GraphicString:
	ExaminePERType_GraphicString(ass, type, per, info);
	break;
    case eType_IA5String:
	ExaminePERType_IA5String(ass, type, per, info);
	break;
    case eType_ISO646String:
	ExaminePERType_ISO646String(ass, type, per, info);
	break;
    case eType_NumericString:
	ExaminePERType_NumericString(ass, type, per, info);
	break;
    case eType_PrintableString:
	ExaminePERType_PrintableString(ass, type, per, info);
	break;
    case eType_TeletexString:
	ExaminePERType_TeletexString(ass, type, per, info);
	break;
    case eType_T61String:
	ExaminePERType_T61String(ass, type, per, info);
	break;
    case eType_UniversalString:
	ExaminePERType_UniversalString(ass, type, per, info);
	break;
    case eType_VideotexString:
	ExaminePERType_VideotexString(ass, type, per, info);
	break;
    case eType_VisibleString:
	ExaminePERType_VisibleString(ass, type, per, info);
	break;
    case eType_CharacterString:
	ExaminePERType_UnrestrictedString(ass, type, per, info);
	break;
    case eType_GeneralizedTime:
	ExaminePERType_GeneralizedTime(ass, type, per, info);
	break;
    case eType_UTCTime:
	ExaminePERType_UTCTime(ass, type, per, info);
	break;
    case eType_ObjectDescriptor:
	ExaminePERType_ObjectDescriptor(ass, type, per, info);
	break;
    case eType_Open:
	ExaminePERType_Open(ass, type, per, info);
	break;
    case eType_Sequence:
    case eType_Set:
    case eType_InstanceOf:
	ExaminePERType_SequenceSet(ass, type, per, info);
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	ExaminePERType_SequenceSetOf(ass, type, per, info);
	break;
    case eType_Choice:
	ExaminePERType_Choice(ass, type, per, info);
	break;
    case eType_RestrictedString:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    case eType_Selection:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    case eType_Undefined:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    case eType_Reference:
	ExaminePERType_Reference(ass, type, per, info);
	break;
    }

    /* get real Length, LNBits and LAlignment */
    if (info->Root.Length == ePERSTILength_Length) {
	switch (info->Root.LConstraint) {
	case ePERSTIConstraint_Constrained:
	    lrange = info->Root.LUpperVal - info->Root.LLowerVal + 1;
	    lrangelog2 = uint32_log2(lrange);
	    if (info->Root.LUpperVal < 0x10000) {
		if (lrange < 0x100) {
		    info->Root.Length = ePERSTILength_BitLength;
		    info->Root.LAlignment = ePERSTIAlignment_BitAligned;
		    info->Root.LNBits = lrangelog2;
		} else if (lrange == 0x100) {
		    info->Root.Length = ePERSTILength_BitLength;
		    info->Root.LNBits = 8;
		} else if (lrange <= 0x10000) {
		    info->Root.Length = ePERSTILength_BitLength;
		    info->Root.LNBits = 16;
		} else {
		    info->Root.Length = ePERSTILength_InfiniteLength;
		    info->Root.LLowerVal = 0;
		}
	    } else {
		info->Root.Length = ePERSTILength_InfiniteLength;
		info->Root.LLowerVal = 0;
	    }
	    break;
	case ePERSTIConstraint_Semiconstrained:
	    info->Root.Length = ePERSTILength_InfiniteLength;
	    info->Root.LLowerVal = 0;
	    break;
	}
    } else if (info->Root.Length == ePERSTILength_NoLength) {
	info->Root.LAlignment = ePERSTIAlignment_BitAligned;
    }
}

/*
 * Description of the fields of PERTypeInfo_t:
 *   info.
 *	Identifier	complete name of the type
 *	Rules		encoding directive rules
 *	Flags		encoding flags
 *	EnumerationValues values of enumeration type
 *	NOctets		size of string characters/integer type
 *	Type		unextended/extendable/extended
 *	Root		information for the extension root
 *	Additional	information for the extensions
 *   info.{Root,Additional}.
 *	Data		data type of value
 *	TableIdentifier	name of stringtable to use
 *	Table		stringtable to use
 *	SubIdentifier	complete name of the subtype
 *	SubType		the subtype itself
 *	Identification	identification of EMBEDDED PDV/CHARACTER STRING
 *	NBits		number of bits to use
 *	Constraint	constraint of type values
 *	LowerVal	lower bound of values (if constrained)
 *	UpperVal	upper bound of values (if constrained)
 *	Alignment	alignment to be used for value encoding
 *	Length		type of length encoding
 *	LConstraint	constraint of length
 *	LLowerVal	lower bound of length
 *	LUpperVal	upper bound of length
 *	LAlignment	alignment to be used for length encoding
 *
 * NOTES:
 *	The encoding is mostly controlled by following arguments:
 *	- Data, the type: one of:
 *	  ePERSTIData_Null, ePERSTIData_Boolean,
 *	  ePERSTIData_Integer, ePERSTIData_Unsigned,
 *	  ePERSTIData_Real, ePERSTIData_BitString, ePERSTIData_RZBBitString,
 *	  ePERSTIData_OctetString, ePERSTIData_SequenceOf, ePERSTIData_SetOf,
 *	  ePERSTIData_ObjectIdentifier, ePERSTIData_NormallySmall,
 *	  ePERSTIData_String, ePERSTIData_TableString, ePERSTIData_ZeroString,
 *	  ePERSTIData_ZeroTableString, ePERSTIData_Reference,
 *	  ePERSTIData_Extension, ePERSTIData_External,
 *	  ePERSTIData_EmbeddedPdv, ePERSTIData_UnrestrictedString
 *	- NBits, the item size for encoding
 *	- Length, the length encoding: one of:
 *	  ePERSTILength_NoLength, ePERSTILength_SmallLength,
 *	  ePERSTILength_Length
 *	  (internally eLength will be replaced by one of:
 *	  ePERSTILength_BitLength, ePERSTILength_InfiniteLength,
 *	  depending on the constraints)
 *
 *	Additional arguments:
 *	- Alignment, the value alignment: one of:
 *	  ePERSTIAlignment_BitAligned, ePERSTIAlignment_OctetAligned
 *	- LAlignment, the length alignment: one of:
 *	  ePERSTIAlignment_BitAligned, ePERSTIAlignment_OctetAligned
 *	- Constraint, the value constraint: one of:
 *	  ePERSTIConstraint_Unconstrained, ePERSTIConstraint_Semiconstrained,
 *	  ePERSTIConstraint_Upperconstrained, ePERSTIConstraint_Constrained
 *	- LConstraint, the length constraint: one of:
 *	  ePERSTIConstraint_Semiconstrained, ePERSTIConstraint_Constrained
 *
 *	Following arguments contain variable/function names in the generated
 *	code:
 *	- Identifier, the name of the current type
 *	- SubIdentifier, the name of the subtype
 *	- TableIdentifier, the name of the stringtable
 *
 *	Following values require additional arguments:
 *	- Constraint == ePERSTIConstraint_Semiconstrained ||
 *	  Constraint == ePERSTIConstraint_Constrained:
 *	  -> LowerVal, the lower bound of the value
 *	- Constraint == ePERSTIConstraint_Upperconstrained ||
 *	  Constraint == ePERSTIConstraint_Constrained:
 *	  -> UpperVal, the upper bound of the value
 *	- Length == ePERSTILength_Length:
 *	  -> LLowerVal, the lower bound of the length
 *	- Length == ePERSTILength_Length &&
 *	  LConstraint == ePERSTIConstraint_Constrained:
 *	  -> LUpperVal, the upper bound of the length
 *	- Data == ePERSTIData_TableString ||
 *        Data == ePERSTIData_ZeroTableString:
 *	  -> TableIdentifier, the name of the string table
 *	  -> Table, the string table
 *	- Data == ePERSTIData_Reference:
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 *	- Data == ePERSTIData_*String:
 *	  -> NOctets, the size of the string characters
 *	- Data == ePERSTIData_Integer || Data == ePERSTIData_Unsigned ||
 *	  Data == ePERSTIData_Boolean:
 *	  -> NOctets, the size of the integer type
 *	- Data == ePERSTIData_SequenceOf || Data == ePERSTIData_SetOf:
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 *	  -> Rule, the encoding directive rules
 *	- Data == ePERSTIData_EmbeddedPdv ||
 *	  Data == ePERSTIData_UnrestrictedString
 *	  -> Identification, the identification of the type if the type
 *	     is constraint to fixed identification or syntaxes identification
 *	     with single value
 *
 *	Following values have optional arguments:
 *	- Data == ePERSTIData_Integer || dat == ePERSTIData_Unsigned:
 *	  -> EnumerationValues, the mapping for enumeration values
 *
 *	Following combinations are allowed:
 *	
 *	Data/NBits/Length		Description
 *	-----------------------------------------------------------------------
 *	Null/0/NoLength			NULL type
 *
 *	Boolean/1/NoLength		boolean value, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Integer/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Integer/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Integer/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 *	Unsigned/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Unsigned/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Unsigned/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 *	NormallySmall/1/NoLength	normally small non-negative
 *					whole number, stored in an
 *					uint{8,16,32}_t
 *					(noctets == 1/2/4)
 *
 *	Real/8/Length			REAL value
 *
 *	*BitString/0/NoLength		BIT STRING of fixed length 0
 *
 *	*BitString/1/NoLength		BIT STRING of fixed length < 64K
 *
 *	*BitString/1/Length		BIT STRING of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of bits
 *
 *					"RZB" in e*BitString means, bit
 *					strings with removed leading zero bits
 *
 *	OctetString/0/NoLength		OCTET STRING of fixed length 0
 *
 *	OctetString/8/NoLength		OCTET STRING of fixed length < 64K,
 *
 *	OctetString/8/Length		OCTET STRING of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of octets
 *
 *	Extension/n/NoLength		bit field representing presence or
 *					absence of <64K OPTIONAL/DEFAULT
 *					components in SEQUENCEs/SETs, encoded
 *					in n bits
 *
 *	Extension/n/Length		bit field representing presence or
 *					absence of >=64K OPTIONAL/DEFAULT
 *					components in SEQUENCEs/SETs, encoded
 *					in n bits
 *
 *	Extension/n/SmallLength		bit field representing presence or
 *					absence of components in the extension
 *					of SEQUENCEs/SETs, encoded in n bits
 *
 *	ObjectIdentifier/8/Length	OBJECT IDENTIFIER value
 *
 *	*String/0/NoLength		String of fixed length 0
 *
 *	*String/n/NoLength		String of fixed length < 64K,
 *					encoded in n bits
 *
 *	*String/n/Length		String of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of n bits
 *
 *					"Zero" in *String means
 *					zero-terminated strings,
 *					"Table" means renumbering of the
 *					characters.
 *
 *	MultibyteString/8/Length	not known-multiplier character strings
 *
 *	SequenceOf/0/NoLength		SEQUENCE OF subtype or SET OF subtype
 *	SetOf/0/NoLength		of zero length
 *
 *	SequenceOf/1/NoLength		SEQUENCE OF subtype or SET OF subtype
 *	SetOf/1/NoLength		of fixed length <64K
 *
 *	SequenceOf/1/Length		SEQUENCE OF subtype or SET OF subtype
 *	SetOf/1/Length			of var. length or length >= 64K or
 *					semiconstrained length
 *
 *	External/8/NoLength		EXTERNAL
 *
 *	EmbeddedPdv/8/Length		EMBEDDED PDV
 *
 *	UnrestrictedString/8/Length	CHARACTER STRING
 *
 *	GeneralizedTime/n/NoLength	GeneralizedTime, encoded in units of
 *					n bits
 *
 *	UTCTime/n/NoLength		UTCTime, encoded in units of n bits
 *
 *	Reference/1/NoLength		Reference to a structured subtype
 *
 *	Open/8/Length			Open type
 */

/* for sorting of intx_t's */
static int
__cdecl CmpIntxP(const void *v1, const void *v2)
{
    intx_t *n1 = *(intx_t **)v1;
    intx_t *n2 = *(intx_t **)v2;
    return intx_cmp(n1, n2);
}

/*
 * BOOLEAN:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Boolean/1/NoLength		boolean value, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_Integer || dat == ePERSTIData_Unsigned ||
 *	  Data == ePERSTIData_Boolean
 *	  -> NOctets, the size of the integer type
 */
void
ExaminePERType_Boolean(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_Boolean;
    info->NOctets = GetOctets(GetBooleanType());
    info->Root.Alignment = ePERSTIAlignment_BitAligned;
}

/*
 * INTEGER:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Integer/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Integer/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Integer/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 *	Unsigned/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Unsigned/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Unsigned/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_Integer || dat == ePERSTIData_Unsigned ||
 *	  Data == ePERSTIData_Boolean
 *	  -> NOctets, the size of the integer type
 */
void
ExaminePERType_Integer(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    EndPoint_t lower, upper;
    int32_t sign;
    intx_t range;
    uint32_t rangelog2;
    uint32_t rangelog256;

    /* calculate LowerVal, UpperVal and range of extension root */
    /* set Constraint according to presence of LowerVal/UpperVal */
    if (per->Value.Type == eExtension_Unconstrained) {
	lower.Flags = eEndPoint_Min;
	upper.Flags = eEndPoint_Max;
    } else {
	lower.Flags = eEndPoint_Max;
	upper.Flags = eEndPoint_Min;
	GetMinMax(ass, per->Value.Root, &lower, &upper);
	if (lower.Flags & eEndPoint_Max)
	    lower.Flags = eEndPoint_Min;
	if (upper.Flags & eEndPoint_Min)
	    upper.Flags = eEndPoint_Max;
    }
    if (!(lower.Flags & eEndPoint_Min)) {
	intx_dup(&info->Root.LowerVal,
	    &GetValue(ass, lower.Value)->U.Integer.Value);
	info->Root.Constraint = ePERSTIConstraint_Semiconstrained;
    }
    if (!(upper.Flags & eEndPoint_Max)) {
	intx_dup(&info->Root.UpperVal,
	    &GetValue(ass, upper.Value)->U.Integer.Value);
	info->Root.Constraint = ePERSTIConstraint_Upperconstrained;
    }
    if (!(lower.Flags & eEndPoint_Min) && !(upper.Flags & eEndPoint_Max)) {
	intx_sub(&range, &info->Root.UpperVal, &info->Root.LowerVal);
	intx_inc(&range);
	rangelog2 = intx_log2(&range);
	rangelog256 = intx_log256(&range);
	info->Root.Constraint = ePERSTIConstraint_Constrained;
    }

    /* calculate NOctets and Data depending on the used C-Type */
    info->NOctets = GetOctets(GetIntegerType(ass, type, &sign));
    info->Root.Data = sign > 0 ? ePERSTIData_Unsigned : ePERSTIData_Integer;

    /* calculate Length, NBits, Alignment, LConstraint, LLowerVal and */
    /* LUpperVal */
    switch (info->Root.Constraint) {
    case ePERSTIConstraint_Unconstrained:
    case ePERSTIConstraint_Semiconstrained:
    case ePERSTIConstraint_Upperconstrained:
	info->Root.Length = ePERSTILength_Length;
	info->Root.NBits = 8;
	info->Root.LLowerVal = 1;
	break;
    case ePERSTIConstraint_Constrained:
	if (intx_cmp(&range, &intx_1) == 0) {
	    info->Root.NBits = 0;
	} else if (intx_cmp(&range, &intx_256) < 0 || Alignment == eAlignment_Unaligned) {
	    info->Root.NBits = rangelog2;
	    info->Root.Alignment = ePERSTIAlignment_BitAligned;
	} else if (intx_cmp(&range, &intx_256) == 0) {
	    info->Root.NBits = 8;
	} else if (intx_cmp(&range, &intx_64K) <= 0) {
	    info->Root.NBits = 16;
	} else {
	    info->Root.NBits = 8;
	    info->Root.Length = ePERSTILength_Length;
	    info->Root.LConstraint = ePERSTIConstraint_Constrained;
	    info->Root.LLowerVal = 1;
	    info->Root.LUpperVal = rangelog256;
	}
    }

    /* check for extensions */
    info->Type = per->Value.Type;
    if (info->Type == eExtension_Unconstrained)
	info->Type = eExtension_Unextended;
    info->Additional.Data = info->Root.Data;
}

/*
 * ENUMERATED:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Integer/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Integer/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Integer/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 *	Unsigned/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Unsigned/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Unsigned/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 *	NormallySmall/1/NoLength	normally small non-negative
 *					whole number, stored in an
 *					uint{8,16,32}_t
 *					(noctets == 1/2/4)
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_Integer || dat == ePERSTIData_Unsigned ||
 *	  Data == ePERSTIData_Boolean
 *	  -> NOctets, the size of the integer type
 */
void
ExaminePERType_Enumerated(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    uint32_t nroot, nindex, i;
    NamedNumber_t *n;
    int32_t sign;
    uint32_t rangelog2;
    intx_t range;

    /* count number of enumeration values in extension root and extension */
    /* set extension type of extensions are present/possible */
    nroot = nindex = 0;
    for (n = type->U.Enumerated.NamedNumbers; n; n = n->Next) {
	switch (n->Type) {
	case eNamedNumber_Normal:
	    nindex++;
	    switch (info->Type) {
	    case eExtension_Unextended:
		nroot = nindex;
		break;
	    case eExtension_Extendable:
		info->Type = eExtension_Extended;
		break;
	    }
	    break;
	case eNamedNumber_ExtensionMarker:
	    info->Type = eExtension_Extendable;
	    break;
	}
    }

    /* allocate table for enumeration values and copy the values into */
    info->EnumerationValues =
	(intx_t **)malloc((nindex + 1) * sizeof(intx_t *));
    nindex = 0;
    for (n = type->U.Enumerated.NamedNumbers; n; n = n->Next) {
	switch (n->Type) {
	case eNamedNumber_Normal:
	    info->EnumerationValues[nindex++] =
		&GetValue(ass, n->U.Normal.Value)->U.Integer.Value;
	    break;
	case eNamedNumber_ExtensionMarker:
	    break;
	}
    }
    info->EnumerationValues[nindex] = 0;

    /* sort values of extension root according to their value */
    qsort(info->EnumerationValues, nroot,
	sizeof(*info->EnumerationValues), CmpIntxP);

    /* check the need for an index translation */
    for (i = 0; info->EnumerationValues[i]; i++) {
	if (intx2uint32(info->EnumerationValues[i]) != i)
	    break;
    }
    if (!info->EnumerationValues[i])
	info->EnumerationValues = NULL;

    /* calculate NOctets and Data depending on the used C-Type */
    info->NOctets = GetOctets(GetEnumeratedType(ass, type, &sign));
    info->Root.Data = sign > 0 ? ePERSTIData_Unsigned : ePERSTIData_Integer;

    /* enumeration is always constrained to value from 0 to nroot-1 */
    info->Root.Constraint = ePERSTIConstraint_Constrained;
    intx_setuint32(&info->Root.LowerVal, 0);
    intx_setuint32(&info->Root.UpperVal, nroot - 1);
    intx_setuint32(&range, nroot);
    rangelog2 = intx_log2(&range);

    /* calculate NBits and Alignment */
    if (nroot <= 1) {
	info->Root.NBits = 0;
    } else if (nroot < 256) {
	info->Root.Alignment = ePERSTIAlignment_BitAligned;
	info->Root.NBits = rangelog2;
    } else if (nroot == 256) {
	info->Root.NBits = 8;
    } else if (nroot < 65536) {
	info->Root.NBits = 16;
    } else {
	MyAbort();
    }

    /* values of extension will always be encoded as normally small numbers */
    /* with lowerbound = nroot */
    info->Additional.Data = ePERSTIData_NormallySmall;
    info->Additional.NBits = 1;
    info->Additional.Alignment = ePERSTIAlignment_BitAligned;
    info->Additional.Length = ePERSTILength_NoLength;
    info->Additional.Constraint = ePERSTIConstraint_Semiconstrained;
    intx_setuint32(&info->Additional.LowerVal, nroot);
}

/*
 * REAL:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Real/8/Length			REAL value
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_Real(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_Real;
    info->Root.NBits = 8;
    info->NOctets = GetOctets(GetRealType(type));
}

/*
 * BIT STRING:
 *
 * Data/NBits/Length used for encoding:
 *
 *	*BitString/0/NoLength		BIT STRING of fixed length 0
 *
 *	*BitString/1/NoLength		BIT STRING of fixed length < 64K,
 *					encoded in n bits
 *
 *	*BitString/1/Length		BIT STRING of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of bits
 *
 *					"RZB" in e*BitString means, bit
 *					strings with removed leading zero bits
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_BitString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    EndPoint_t lower, upper;

    /* calculate LConstraint, LLowerVal and LUpperVal */
    if (per->Size.Type != eExtension_Unconstrained) {
	lower.Flags = eEndPoint_Max;
	upper.Flags = eEndPoint_Min;
	GetMinMax(ass, per->Size.Root, &lower, &upper);
	if (upper.Flags & eEndPoint_Min)
	    upper.Flags = eEndPoint_Max;
	info->Root.LLowerVal =
	    intx2uint32(&GetValue(ass, lower.Value)->U.Integer.Value);
	info->Root.LConstraint = ePERSTIConstraint_Semiconstrained;
	if (!(upper.Flags & eEndPoint_Max)) {
	    info->Root.LUpperVal =
		intx2uint32(&GetValue(ass, upper.Value)->U.Integer.Value);
	    info->Root.LConstraint = ePERSTIConstraint_Constrained;
	}
    }

    /* calculate NBits, Alignment and Length */
    info->Root.cbFixedSizeBitString = 0; // clear it up first
    switch (info->Root.LConstraint) {
    case ePERSTIConstraint_Constrained:
	if (info->Root.LUpperVal == 0) {
	    info->Root.NBits = 0;
	} else {
	    info->Root.NBits = 1;
	    if (info->Root.LLowerVal == info->Root.LUpperVal) {
		if (info->Root.LUpperVal <= 32)
		{
		    info->Root.cbFixedSizeBitString = (info->Root.LUpperVal + 7) / 8;
        }
		if (info->Root.LUpperVal <= 16) {
		    info->Root.Alignment = ePERSTIAlignment_BitAligned;
		} else if (info->Root.LUpperVal >= 0x10000) {
		    info->Root.Length = ePERSTILength_Length;
		}
	    } else {
		info->Root.Length = ePERSTILength_Length;
	    }
	}
	break;
    case ePERSTIConstraint_Semiconstrained:
	info->Root.NBits = 1;
	info->Root.Length = ePERSTILength_Length;
	break;
    }

    /* get extension type */
    info->Type = per->Size.Type;
    if (info->Type == eExtension_Unconstrained)
	info->Type = eExtension_Unextended;

    /* set Data to RZBBitString/BitString */
    if (type->U.BitString.NamedNumbers)
	info->Root.Data = ePERSTIData_RZBBitString;
    else
	info->Root.Data = ePERSTIData_BitString;

    /* set extension informations */
    info->Additional.Data = info->Root.Data;
    info->Additional.NBits = 1;
}

/*
 * OCTET STRING:
 *
 * Data/NBits/Length used for encoding:
 *
 *	OctetString/0/NoLength		OCTET STRING of fixed length 0
 *
 *	OctetString/8/NoLength		OCTET STRING of fixed length < 64K,
 *
 *	OctetString/8/Length		OCTET STRING of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of octets
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_OctetString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    EndPoint_t lower, upper;

    /* calculate LConstraint, LLowerVal and LUpperVal */
    if (per->Size.Type != eExtension_Unconstrained) {
	lower.Flags = eEndPoint_Max;
	upper.Flags = eEndPoint_Min;
	GetMinMax(ass, per->Size.Root, &lower, &upper);
	if (upper.Flags & eEndPoint_Min)
	    upper.Flags = eEndPoint_Max;
	info->Root.LLowerVal =
	    intx2uint32(&GetValue(ass, lower.Value)->U.Integer.Value);
	info->Root.LConstraint = ePERSTIConstraint_Semiconstrained;
	if (!(upper.Flags & eEndPoint_Max)) {
	    info->Root.LUpperVal =
		intx2uint32(&GetValue(ass, upper.Value)->U.Integer.Value);
	    info->Root.LConstraint = ePERSTIConstraint_Constrained;
	}
    }

    /* calculate NBits, Alignment and Length */
    switch (info->Root.LConstraint) {
    case ePERSTIConstraint_Constrained:
	if (info->Root.LUpperVal == 0) {
	    info->Root.NBits = 0;
	} else {
	    info->Root.NBits = 8;
	    if (info->Root.LLowerVal == info->Root.LUpperVal) {
		if (info->Root.LUpperVal <= 2) {
		    info->Root.Alignment = ePERSTIAlignment_BitAligned;
		} else if (info->Root.LUpperVal >= 0x10000) {
		    info->Root.Length = ePERSTILength_Length;
		}
	    } else {
		info->Root.Length = ePERSTILength_Length;
	    }
	}
	break;
    case ePERSTIConstraint_Semiconstrained:
	info->Root.NBits = 8;
	info->Root.Length = ePERSTILength_Length;
	break;
    }

    /* get extension type */
    info->Type = per->Size.Type;
    if (info->Type == eExtension_Unconstrained)
	info->Type = eExtension_Unextended;

    /* set Data to OctetString */
    info->Root.Data = ePERSTIData_OctetString;

    /* set extension informations */
    info->Additional.Data = info->Root.Data;
}

void
ExaminePERType_UTF8String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    EndPoint_t lower, upper;

    /* calculate LConstraint, LLowerVal and LUpperVal */
    if (per->Size.Type != eExtension_Unconstrained) {
	lower.Flags = eEndPoint_Max;
	upper.Flags = eEndPoint_Min;
	GetMinMax(ass, per->Size.Root, &lower, &upper);
	if (upper.Flags & eEndPoint_Min)
	    upper.Flags = eEndPoint_Max;
	info->Root.LLowerVal =
	    intx2uint32(&GetValue(ass, lower.Value)->U.Integer.Value);
	info->Root.LConstraint = ePERSTIConstraint_Semiconstrained;
	if (!(upper.Flags & eEndPoint_Max)) {
	    info->Root.LUpperVal =
		intx2uint32(&GetValue(ass, upper.Value)->U.Integer.Value);
	    info->Root.LConstraint = ePERSTIConstraint_Constrained;
	}
    }

    /* calculate NBits, Alignment and Length */
    switch (info->Root.LConstraint) {
    case ePERSTIConstraint_Constrained:
	if (info->Root.LUpperVal == 0) {
	    info->Root.NBits = 0;
	} else {
	    info->Root.NBits = 8;
	    if (info->Root.LLowerVal == info->Root.LUpperVal) {
		if (info->Root.LUpperVal <= 2) {
		    info->Root.Alignment = ePERSTIAlignment_BitAligned;
		} else if (info->Root.LUpperVal >= 0x10000) {
		    info->Root.Length = ePERSTILength_Length;
		}
	    } else {
		info->Root.Length = ePERSTILength_Length;
	    }
	}
	break;
    case ePERSTIConstraint_Semiconstrained:
	info->Root.NBits = 8;
	info->Root.Length = ePERSTILength_Length;
	break;
    }

    /* get extension type */
    info->Type = per->Size.Type;
    if (info->Type == eExtension_Unconstrained)
	info->Type = eExtension_Unextended;

    /* set Data to OctetString */
    info->Root.Data = ePERSTIData_UTF8String;

    /* set extension informations */
    info->Additional.Data = info->Root.Data;
}

/*
 * NULL:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Null/0/NoLength			NULL type
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_Null(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.NBits = 0;
    info->Root.Data = ePERSTIData_Null;
}

/*
 * EMBEDDED PDV:
 *
 * Data/NBits/Length used for encoding:
 *
 *	EmbeddedPdv/8/Length		EMBEDDED PDV
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_EmbeddedPdv ||
 *	  Data == ePERSTIData_UnrestrictedString
 *	  -> Identification, the identification of the type if the type
 *	     is constraint to fixed identification or syntaxes identification
 *	     with single value
 */
void
ExaminePERType_EmbeddedPdv(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Identification = GetFixedIdentification(ass, type->Constraints);
    info->Root.Data = ePERSTIData_EmbeddedPdv;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
}

/*
 * EXTERNAL:
 *
 * Data/NBits/Length used for encoding:
 *
 *	External/8/Length		EXTERNAL
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_External(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_External;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
}

/*
 * OBJECT IDENTIFIER:
 *
 * Data/NBits/Length used for encoding:
 *
 *	ObjectIdentifier/8/Length	OBJECT IDENTIFIER value
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_ObjectIdentifier(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_ObjectIdentifier;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
}

/*
 * *String:
 *
 * Data/NBits/Length used for encoding:
 *
 *	*String/0/NoLength		String of fixed length 0
 *
 *	*String/n/NoLength		String of fixed length < 64K,
 *					encoded in n bits
 *
 *	*String/n/Length		String of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of n bits
 *
 *					"Zero" in *String means
 *					zero-terminated strings,
 *					"Table" means renumbering of the
 *					characters.
 *
 *	MultibyteString/8/Length	not known-multiplier character strings
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_TableString || dat == ePERSTIData_ZeroTableString:
 *	  -> TableIdentifier, the name of the string table
 *	  -> Table, the string table
 *	- Data == ePERSTIData_*String:
 *	  -> NOctets, the size of the string characters
 */

void
ExaminePERType_BMPString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0xffff);
    intx_setuint32(&nchars, 0x10000);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	NULL, 16, per, info);
}

void
ExaminePERType_GeneralString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Root.NBits = 8;
    info->Root.Data = zero ? ePERSTIData_ZeroString : ePERSTIData_String;
    info->Root.Length = ePERSTILength_Length;
}

void
ExaminePERType_GraphicString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Root.NBits = 8;
    info->Root.Data = zero ? ePERSTIData_ZeroString : ePERSTIData_String;
    info->Root.Length = ePERSTILength_Length;
}

void
ExaminePERType_IA5String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0x7f);
    intx_setuint32(&nchars, 0x80);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	NULL, Alignment == eAlignment_Aligned ? 8 : 7, per, info);
}

void
ExaminePERType_ISO646String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0x7e);
    intx_setuint32(&nchars, 0x5f);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	NULL, Alignment == eAlignment_Aligned ? 8 : 7, per, info);
}

void
ExaminePERType_NumericString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0x39);
    intx_setuint32(&nchars, 0xb);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	"ASN1NumericStringTable", 4, per, info);
}

void
ExaminePERType_PrintableString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0x7a);
    intx_setuint32(&nchars, 0x4a);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	NULL, Alignment == eAlignment_Aligned ? 8 : 7, per, info);
}

void
ExaminePERType_TeletexString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_MultibyteString;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
    info->NOctets = 1;
}

void
ExaminePERType_T61String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_MultibyteString;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
    info->NOctets = 1;
}

void
ExaminePERType_UniversalString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0xffffffff);
    intx_setuint32(&nchars, 0xffffffff);
    intx_inc(&nchars);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	NULL, 32, per, info);
}

void
ExaminePERType_VideotexString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_MultibyteString;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
    info->NOctets = 1;
}

void
ExaminePERType_VisibleString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0x7e);
    intx_setuint32(&nchars, 0x5f);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	NULL, Alignment == eAlignment_Aligned ? 8 : 7, per, info);
}

void
ExaminePERType_RestrictedString(AssignmentList_t ass, Type_t *type, intx_t *up, intx_t *nchars, char *tabref, uint32_t enbits, PERConstraints_t *per, PERTypeInfo_t *info)
{
    EndPoint_t lower, upper;
    uint32_t zero, rangelog2;
    intx_t ix, range;
    char tabbuf[256];

    /* calculate NOctets depending on the used C-Type */
    GetStringType(ass, type, &info->NOctets, &zero);

    /* calculate LConstraint, LLowerVal and LUpperVal if size constraint is */
    /* given */
    if (per->Size.Type != eExtension_Unconstrained) {
	lower.Flags = eEndPoint_Max;
	upper.Flags = eEndPoint_Min;
	GetMinMax(ass, per->Size.Root, &lower, &upper);
	if (upper.Flags & eEndPoint_Min)
	    upper.Flags = eEndPoint_Max;
	if (lower.Flags & eEndPoint_Max) {
	    lower.Flags = 0;
	    lower.Value = Builtin_Value_Integer_0;
	}
	info->Root.LLowerVal =
	    intx2uint32(&GetValue(ass, lower.Value)->U.Integer.Value);
	if (!(upper.Flags & eEndPoint_Max)) {
	    info->Root.LUpperVal =
		intx2uint32(&GetValue(ass, upper.Value)->U.Integer.Value);
	    info->Root.LConstraint = ePERSTIConstraint_Constrained;
	}
    }

    /* get extension type */
    info->Type = per->Size.Type;
    if (info->Type == eExtension_Unconstrained)
	info->Type = eExtension_Unextended;

    /* get string table if permitted alphabet constraint is present */
    /* update extension type if needed */
    if (per->PermittedAlphabet.Type != eExtension_Unconstrained) {
	info->Root.Table = per->PermittedAlphabet.Root;
	if (per->PermittedAlphabet.Type > info->Type)
	    info->Type = per->PermittedAlphabet.Type;
	if (CountValues(ass, info->Root.Table, &ix)) {
	    nchars = &ix;
	    sprintf(tabbuf, "%s_StringTable", info->Identifier);
	    tabref = tabbuf;
	} else {
	    MyAbort(); /*XXX*/
	}
    }

    /* get bits needed for one character */
    info->Root.NBits = intx_log2(nchars);
    if (Alignment == eAlignment_Aligned) {
	if (info->Root.NBits > 16)
	    info->Root.NBits = 32;
	else if (info->Root.NBits > 8)
	    info->Root.NBits = 16;
	else if (info->Root.NBits > 4)
	    info->Root.NBits = 8;
	else if (info->Root.NBits > 2)
	    info->Root.NBits = 4;
    }

    /* set data type */
    info->Root.Data = tabref ?
	(zero ? ePERSTIData_ZeroTableString : ePERSTIData_TableString) :
	(zero ? ePERSTIData_ZeroString : ePERSTIData_String);

    /* check if stringtable is really needed for encoding or extension check */
    intx_dup(&range, up);
    intx_inc(&range);
    rangelog2 = intx_log2(&range);
    if (rangelog2 <= info->Root.NBits) {
	info->Root.Data = zero ? ePERSTIData_ZeroString : ePERSTIData_String;
	if (per->PermittedAlphabet.Type < eExtension_Extended)
	    tabref = NULL;
    }
    info->Root.TableIdentifier = tabref ? strdup(tabref) : NULL;

    /* calculate Length and Alignment */
    switch (info->Root.LConstraint) {
    case ePERSTIConstraint_Constrained:
	if (info->Root.LUpperVal == 0) {
	    info->Root.NBits = 0;
	} else {
	    if (info->Root.LLowerVal == info->Root.LUpperVal) {
		if (info->Root.LUpperVal * info->Root.NBits <= 16) {
		    info->Root.Alignment = ePERSTIAlignment_BitAligned;
		} else if (info->Root.LUpperVal >= 0x10000) {
		    info->Root.Length = ePERSTILength_Length;
		}
	    } else {
		if (info->Root.LUpperVal * info->Root.NBits <= 16)
		    info->Root.Alignment = ePERSTIAlignment_BitAligned;
		info->Root.Length = ePERSTILength_Length;
	    }
	}
	break;
    case ePERSTIConstraint_Semiconstrained:
	info->Root.Length = ePERSTILength_Length;
	break;
    }

    /* set extension informations */
    info->Additional.Data = zero ? ePERSTIData_ZeroString : ePERSTIData_String;
    info->Additional.NBits = enbits;
}

/*
 * CHARACTER STRING:
 *
 * Data/NBits/Length used for encoding:
 *
 *	UnrestrictedString/8/Length	CHARACTER STRING
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_EmbeddedPdv ||
 *	  Data == ePERSTIData_UnrestrictedString
 *	  -> Identification, the identification of the type if the type
 *	     is constraint to fixed identification or syntaxes identification
 *	     with single value
 */
void
ExaminePERType_UnrestrictedString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Identification = GetFixedIdentification(ass, type->Constraints);
    info->Root.Data = ePERSTIData_UnrestrictedString;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
}

/*
 * GeneralizedTime:
 *
 * Data/NBits/Length used for encoding:
 *
 *	GeneralizedTime/n/NoLength	GeneralizedTime, encoded in units of
 *					n bits
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_GeneralizedTime(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.NBits = (Alignment == eAlignment_Aligned) ? 8 : 7;
    info->Root.Data = ePERSTIData_GeneralizedTime;
}

/*
 * UTCTime:
 *
 * Data/NBits/Length used for encoding:
 *
 *	UTCTime/n/NoLength		UTCTime, encoded in units of
 *					n bits
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_UTCTime(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.NBits = (Alignment == eAlignment_Aligned) ? 8 : 7;
    info->Root.Data = ePERSTIData_UTCTime;
}

/*
 * ObjectDescriptor:
 *
 * Data/NBits/Length used for encoding:
 *
 *	*String/n/Length		String of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of n bits
 *
 *					"Zero" in *String means
 *					zero-terminated strings
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_ObjectDescriptor(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->NOctets = 1;
    info->Root.NBits = 8;
    info->Root.Data = ePERSTIData_ZeroString;
    info->Root.Length = ePERSTILength_Length;
}

/*
 * OpenType:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Open/8/Length			Open type
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_Open(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->NOctets = 1;
    info->Root.NBits = 8;
    info->Root.Data = ePERSTIData_Open;
    info->Root.Length = ePERSTILength_Length;
}

/*
 * SEQUENCE/SET:
 *
 * Data/NBits/Length used for encoding:
 *
 *	none
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_SequenceSet(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    Component_t *comp;
    NamedType_t *namedType;
    char idebuf[256];

    /* examine types of components */
    for (comp = type->U.SSC.Components; comp; comp = comp->Next) {
	switch (comp->Type) {
	case eComponent_Normal:
	case eComponent_Optional:
	case eComponent_Default:
	    namedType = comp->U.NOD.NamedType;
	    sprintf(idebuf, "%s_%s", info->Identifier, namedType->Identifier);
	    ExaminePERType(ass, namedType->Type, strdup(idebuf));
	    break;
	}
    }
}

/*
 * SEQUENCE OF/SET OF:
 *
 * Data/NBits/Length used for encoding:
 *
 *	SequenceOf/0/NoLength		SEQUENCE OF subtype or SET OF subtype
 *	SetOf/0/NoLength		of zero length
 *
 *	SequenceOf/1/NoLength		SEQUENCE OF subtype or SET OF subtype
 *	SetOf/1/NoLength		of fixed length <64K
 *
 *	SequenceOf/1/Length		SEQUENCE OF subtype or SET OF subtype
 *	SetOf/1/Length			of var. length or length >= 64K or
 *					semiconstrained length
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_SequenceOf || dat == ePERSTIData_SetOf:
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 *	  -> Rule, the encoding directive rules
 */
void
ExaminePERType_SequenceSetOf(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    EndPoint_t lower, upper;
    char idebuf[256];

    /* calculate LConstraint, LLowerVal and LUpperVal */
    if (per->Size.Type != eExtension_Unconstrained) {
	lower.Flags = eEndPoint_Max;
	upper.Flags = eEndPoint_Min;
	GetMinMax(ass, per->Size.Root, &lower, &upper);
	if (upper.Flags & eEndPoint_Min)
	    upper.Flags = eEndPoint_Max;
	info->Root.LLowerVal = intx2uint32(&GetValue(ass, lower.Value)->
	    U.Integer.Value);
	if (!(upper.Flags & eEndPoint_Max)) {
	    info->Root.LUpperVal = intx2uint32(&GetValue(ass, upper.Value)->
		U.Integer.Value);
	    info->Root.LConstraint = ePERSTIConstraint_Constrained;
	}
    }

    /* calculate NBits, Length */
    switch (info->Root.LConstraint) {
    case ePERSTIConstraint_Constrained:
	if (info->Root.LUpperVal == 0) {
	    info->Root.NBits = 0;
	} else {
	    if (info->Root.LLowerVal != info->Root.LUpperVal)
		info->Root.Length = ePERSTILength_Length;
	}
	break;
    case ePERSTIConstraint_Semiconstrained:
	info->Root.Length = ePERSTILength_Length;
	break;
    }

    /* set data type and Alignment */
    info->Root.Data = (type->Type == eType_SequenceOf ?
	ePERSTIData_SequenceOf : ePERSTIData_SetOf);
    info->Root.Alignment = ePERSTIAlignment_BitAligned;

    /* set SubType, SubIdentifier */
    info->Root.SubType = type->U.SS.Type;
    info->Root.SubIdentifier = GetTypeName(ass, info->Root.SubType);

    /* get extension type */
    info->Type = per->Size.Type;
    if (info->Type == eExtension_Unconstrained)
	info->Type = eExtension_Unextended;

    /* set extension informations */
    info->Additional.Data = info->Root.Data;
    info->Additional.NBits = 1;
    info->Additional.SubType = info->Root.SubType;
    info->Additional.SubIdentifier = info->Root.SubIdentifier;

    /* examine subtype */
    sprintf(idebuf, "%s_%s", info->Identifier,
	type->Type == eType_SequenceOf ? "Sequence" : "Set");
    ExaminePERType(ass, type->U.SS.Type, strdup(idebuf));
}

/*
 * CHOICE:
 *
 * Data/NBits/Length used for encoding of the choice selector:
 *
 *	Unsigned/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Unsigned/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Unsigned/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 *	NormallySmall/1/NoLength	normally small non-negative
 *					whole number, stored in an
 *					uint{8,16,32}_t
 *					(noctets == 1/2/4)
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_Integer || dat == ePERSTIData_Unsigned ||
 *	  Data == ePERSTIData_Boolean
 *	  -> NOctets, the size of the integer type
 *
 */
void
ExaminePERType_Choice(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    uint32_t nroot, rangelog2;
    intx_t range;
    Component_t *comp;
    NamedType_t *namedType;
    char idebuf[256];

    if (type->Flags & eTypeFlags_ExtensionMarker) {
	info->Type = type->U.Choice.Extensions ?
	    eExtension_Extended : eExtension_Extendable;
    }
    nroot = type->U.Choice.Alternatives;
    info->NOctets = GetOctets(GetChoiceType(type));
    info->Root.Constraint = ePERSTIConstraint_Constrained;
    intx_setuint32(&info->Root.UpperVal, nroot - 1);
    intx_setuint32(&range, nroot);
    rangelog2 = intx_log2(&range);
    if (nroot <= 1) {
	info->Root.NBits = 0;
    } else if (nroot < 256) {
	info->Root.Alignment = ePERSTIAlignment_BitAligned;
	info->Root.NBits = rangelog2;
    } else if (nroot == 256) {
	info->Root.NBits = 8;
    } else if (nroot < 65536) {
	info->Root.NBits = 16;
    } else {
	MyAbort();
    }
    info->Root.Data = ePERSTIData_Unsigned;
    info->Additional.Data = ePERSTIData_NormallySmall;
    info->Additional.NBits = 1;
    info->Additional.Alignment = ePERSTIAlignment_BitAligned;
    info->Additional.Length = ePERSTILength_NoLength;
    info->Additional.Constraint = ePERSTIConstraint_Semiconstrained;
    intx_setuint32(&info->Additional.LowerVal, nroot);

    /* examine types of alternatives */
    for (comp = type->U.SSC.Components; comp; comp = comp->Next) {
	switch (comp->Type) {
	case eComponent_Normal:
	    namedType = comp->U.NOD.NamedType;
	    sprintf(idebuf, "%s_%s", info->Identifier, namedType->Identifier);
	    ExaminePERType(ass, namedType->Type, strdup(idebuf));
	    break;
	}
    }
}

/*
 * Reference:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Reference/1/NoLength		Reference to a structured subtype
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_Reference:
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 */
void
ExaminePERType_Reference(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_Reference;
    info->Root.Alignment = ePERSTIAlignment_BitAligned;
    info->Root.SubIdentifier = GetName(FindAssignment(ass, eAssignment_Type, type->U.Reference.Identifier, type->U.Reference.Module));
    info->Root.SubType = GetAssignment(ass, FindAssignment(ass, eAssignment_Type, type->U.Reference.Identifier, type->U.Reference.Module))->U.Type.Type;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\optcase.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

static int _IsNotBounded(PERSimpleTypeInfo_t *sinfo);
static int _IsUnsignedShortRange(PERSimpleTypeInfo_t *sinfo);
static int _IsExtendedShortRange(PERSimpleTypeInfo_t *sinfo);


int PerOptCase_IsSignedInteger(PERSimpleTypeInfo_t *sinfo)
{
    return (sinfo->Data       == ePERSTIData_Integer &&
            sinfo->Constraint == ePERSTIConstraint_Unconstrained &&
            sinfo->Length     == ePERSTILength_InfiniteLength &&
            sinfo->NBits      == 8 &&   // default
            sinfo->Alignment &&
            _IsNotBounded(sinfo) &&
            sinfo->LConstraint== ePERSTIConstraint_Semiconstrained &&
            sinfo->LLowerVal  == 0 &&
            sinfo->LUpperVal  == 0);
}

int PerOptCase_IsUnsignedInteger(PERSimpleTypeInfo_t *sinfo)
{
    return (sinfo->Data       == ePERSTIData_Unsigned &&
            sinfo->Constraint == ePERSTIConstraint_Semiconstrained &&
            sinfo->Length     == ePERSTILength_InfiniteLength &&
            sinfo->NBits      == 8 &&  // default
            sinfo->Alignment &&
            _IsNotBounded(sinfo) &&
            sinfo->LConstraint== ePERSTIConstraint_Semiconstrained &&
            sinfo->LLowerVal  == 0 &&
            sinfo->LUpperVal  == 0);
}

int PerOptCase_IsUnsignedShort(PERSimpleTypeInfo_t *sinfo)
{
    return (sinfo->Data       == ePERSTIData_Unsigned &&
            sinfo->Constraint == ePERSTIConstraint_Constrained &&
            sinfo->Length     == ePERSTILength_NoLength &&
            sinfo->NBits      == 16 &&
            sinfo->Alignment &&
            _IsUnsignedShortRange(sinfo) &&
            sinfo->LConstraint== ePERSTIConstraint_Semiconstrained &&
            sinfo->LLowerVal  == 0 &&
            sinfo->LUpperVal  == 0);
}

int PerOptCase_IsBoolean(PERSimpleTypeInfo_t *sinfo)
{
    return (sinfo->Data       == ePERSTIData_Boolean &&
            sinfo->Constraint == ePERSTIConstraint_Unconstrained &&
            sinfo->Length     == ePERSTILength_NoLength &&
            sinfo->NBits      == 1 &&
            ! sinfo->Alignment &&
            _IsNotBounded(sinfo) &&
            sinfo->LConstraint== ePERSTIConstraint_Semiconstrained &&
            sinfo->LLowerVal  == 0 &&
            sinfo->LUpperVal  == 0);
}

int PerOptCase_IsTargetSeqOf(PERTypeInfo_t *info)
{
    return (
            // we only deal with singly linked-list case
            (info->Rules & eTypeRules_SinglyLinkedList)
            &&
            // check for size of sequence of/set of
            ((info->Root.LLowerVal == 0 && info->Root.LUpperVal == 0) ||
             (info->Root.LLowerVal < info->Root.LUpperVal)
            )
            &&
            // we do not deal with null body case
            (! (info->Root.SubType->Flags & eTypeFlags_Null))
            &&
            // we do not deal with recursive sequence of/set of
            (info->Root.SubType->PERTypeInfo.Root.Data != ePERSTIData_SequenceOf)
            &&
            (info->Root.SubType->PERTypeInfo.Root.Data != ePERSTIData_SetOf)
            &&
            // we only deal with sequence of or non-canonical set of.
            ((info->Root.Data == ePERSTIData_SequenceOf) ||
             (info->Root.Data == ePERSTIData_SetOf && g_eSubEncodingRule != eSubEncoding_Canonical))
           );
}


// UTILITIES

static int _IsNotBounded(PERSimpleTypeInfo_t *sinfo)
{
    return (sinfo->LowerVal.length      == 1 &&
            sinfo->LowerVal.value[0]    == 0 &&
            sinfo->UpperVal.length      == 1 &&
            sinfo->UpperVal.value[0]    == 0);
}

static int _IsUnsignedShortRange(PERSimpleTypeInfo_t *sinfo)
{
    return ((sinfo->UpperVal.length < 3 ) ||
            (sinfo->UpperVal.length == 3 && sinfo->UpperVal.value[0] == 0 &&
             ! _IsExtendedShortRange(sinfo)));
}


static int _IsExtendedShortRange(PERSimpleTypeInfo_t *sinfo)
{
    // if the lower bound is negative and the upper bound greater than 0x7FFF
    // then it is an extended short.
    return ((sinfo->LowerVal.length >= 1) &&
            (sinfo->LowerVal.value[0] & 0x80) && // lower bound is negative
            (sinfo->UpperVal.length == 3) &&
            (sinfo->UpperVal.value[0] == 0) &&  // upper bound is positive
            (*((ASN1uint16_t *) &(sinfo->UpperVal.value[1])) > 0x7FFF)); // upper bound greater than 0x7FFF

}



int BerOptCase_IsBoolean(BERTypeInfo_t *info)
{
    return (eBERSTIData_Boolean == info->Data && 1 == info->NOctets);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\parser.c ===
#include "precomp.h" 
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "defs.h"
#include "builtin.h"
#include "hackdir.h"

extern int pass;


#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include "parser.h"

int llcpos;
int *llstk;
unsigned llstksize;
unsigned llcstp = 1;
LLTERM *lltokens;
int llntokens;
char llerrormsg[256];
LLPOS llerrorpos;
int llepos;
LLSTYPE lllval;

int llterm(int token, LLSTYPE *lval, LLSTATE *llin, LLSTATE *llout);
void llfailed(LLPOS *pos, char *fmt, ...);
void llresizestk();
#define LLCHECKSTK do{if (llcstp + 1 >= llstksize) llresizestk();}while(/*CONSTCOND*/0)
#define LLFAILED(_err) do{llfailed _err; goto failed;}while(/*CONSTCOND*/0)
#define LLCUTOFF do{unsigned i; for (i = llstp; i < llcstp; i++) if (llstk[i] > 0) llstk[i] = -llstk[i];}while(/*CONSTCOND*/0)
#define LLCUTTHIS do{if (llstk[llstp] > 0) llstk[llstp] = -llstk[llstp];}while(/*CONSTCOND*/0)
#define LLCUTALL do{unsigned i; for (i = 0; i < llcstp; i++) if (llstk[i] > 0) llstk[i] = -llstk[i];}while(/*CONSTCOND*/0)

#if LLDEBUG > 0
int lldebug;
int last_linenr;
char *last_file = "";
#define LLDEBUG_ENTER(_ident) lldebug_enter(_ident)
#define LLDEBUG_LEAVE(_ident,_succ) lldebug_leave(_ident,_succ)
#define LLDEBUG_ALTERNATIVE(_ident,_alt) lldebug_alternative(_ident,_alt)
#define LLDEBUG_ITERATION(_ident,_num) lldebug_iteration(_ident,_num)
#define LLDEBUG_TOKEN(_exp,_pos) lldebug_token(_exp,_pos)
#define LLDEBUG_ANYTOKEN(_pos) lldebug_anytoken(_pos)
#define LLDEBUG_BACKTRACKING(_ident) lldebug_backtracking(_ident)
void lldebug_init();
void lldebug_enter(char *ident);
void lldebug_leave(char *ident, int succ);
void lldebug_alternative(char *ident, int alt);
void lldebug_token(int expected, unsigned pos);
void lldebug_anytoken(unsigned pos);
void lldebug_backtracking(char *ident);
void llprinttoken(LLTERM *token, char *identifier, FILE *f);
#else
#define LLDEBUG_ENTER(_ident)
#define LLDEBUG_LEAVE(_ident,_succ)
#define LLDEBUG_ALTERNATIVE(_ident,_alt)
#define LLDEBUG_ITERATION(_ident,_num)
#define LLDEBUG_TOKEN(_exp,_pos)
#define LLDEBUG_ANYTOKEN(_pos)
#define LLDEBUG_BACKTRACKING(_ident)
#endif

int ll_Main(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Main");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!ll_ModuleDefinition(&llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!ll_ModuleDefinition_ESeq(&llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
}}
LLDEBUG_LEAVE("Main", 1);
return 1;
failed1: LLDEBUG_LEAVE("Main", 0);
return 0;
}

int ll_ModuleDefinition_ESeq(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ModuleDefinition_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ModuleDefinition_ESeq", 1);
{LLSTATE llstate_1;
if (!ll_ModuleDefinition(&llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_ModuleDefinition_ESeq(&llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ModuleDefinition_ESeq", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ModuleDefinition_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ModuleDefinition_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("ModuleDefinition_ESeq", 0);
return 0;
}

int ll_ModuleDefinition(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ModuleDefinition");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_ModuleIdentifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_DEFINITIONS, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XTagType llatt_3;
if (!ll_TagDefault(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XExtensionType llatt_4;
if (!ll_ExtensionDefault(&llatt_4, &llstate_3, &llstate_4)) goto failed1;
{LLSTATE llstate_5;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_4, &llstate_5)) goto failed1;
{if (!AssignModuleIdentifier(&llstate_5.Assignments, llatt_1))
		LLFAILED((&llstate_1.pos, "Module `%s' twice defined", llatt_1->Identifier));
	    llstate_5.MainModule = llatt_1;
	    llstate_5.Module = llatt_1;
	    llstate_5.TagDefault = llatt_3;
	    llstate_5.ExtensionDefault = llatt_4;
	    g_eDefTagType = llatt_3;
	
{LLSTATE llstate_6;
if (!llterm(T_BEGIN, (LLSTYPE *)0, &llstate_5, &llstate_6)) goto failed1;
{LLSTATE llstate_7;
if (!ll_ModuleBody(&llstate_6, &llstate_7)) goto failed1;
{LLSTATE llstate_8;
if (!llterm(T_END, (LLSTYPE *)0, &llstate_7, &llstate_8)) goto failed1;
*llout = llstate_8;
{LLCUTALL;
	
}}}}}}}}}}
LLDEBUG_LEAVE("ModuleDefinition", 1);
return 1;
failed1: LLDEBUG_LEAVE("ModuleDefinition", 0);
return 0;
}

int ll_ModuleIdentifier(XModuleIdentifier *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ModuleIdentifier");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_DefinitiveIdentifier(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = NewModuleIdentifier();
		(*llret)->Identifier = llatt_1->Identifier;
		(*llret)->ObjectIdentifier = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("ModuleIdentifier", 1);
return 1;
failed1: LLDEBUG_LEAVE("ModuleIdentifier", 0);
return 0;
}

int ll_DefinitiveIdentifier(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinitiveIdentifier");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinitiveIdentifier", 1);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XNamedObjIdValue llatt_2;
if (!ll_DefinitiveObjIdComponentList(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{switch (GetAssignedObjectIdentifier(
		&(*llout).AssignedObjIds, NULL, llatt_2, &(*llret))) {
	    case -1:
		LLFAILED((&llstate_2.pos, "Different numbers for equally named object identifier components"));
		/*NOTREACHED*/
	    case 0:
		(*llret) = NULL;
		break;
	    case 1:
		break;
	    }
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinitiveIdentifier", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinitiveIdentifier");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinitiveIdentifier", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinitiveIdentifier", 0);
return 0;
}

int ll_DefinitiveObjIdComponentList(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinitiveObjIdComponentList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinitiveObjIdComponentList", 1);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_DefinitiveObjIdComponent(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XNamedObjIdValue llatt_2;
if (!ll_DefinitiveObjIdComponentList(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = DupNamedObjIdValue(llatt_1);
	    (*llret)->Next = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinitiveObjIdComponentList", 2);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_DefinitiveObjIdComponent(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinitiveObjIdComponentList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinitiveObjIdComponentList", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinitiveObjIdComponentList", 0);
return 0;
}

int ll_DefinitiveObjIdComponent(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinitiveObjIdComponent");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinitiveObjIdComponent", 1);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_NameForm(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinitiveObjIdComponent", 2);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_DefinitiveNumberForm(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("DefinitiveObjIdComponent", 3);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_DefinitiveNameAndNumberForm(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinitiveObjIdComponent");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinitiveObjIdComponent", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinitiveObjIdComponent", 0);
return 0;
}

int ll_DefinitiveNumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinitiveNumberForm");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XNumber llatt_1;
if (!llterm(T_number, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XNumber;
*llout = llstate_1;
{(*llret) = NewNamedObjIdValue(eNamedObjIdValue_NumberForm);
	    (*llret)->Number = intx2uint32(&llatt_1);
	
}}
LLDEBUG_LEAVE("DefinitiveNumberForm", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinitiveNumberForm", 0);
return 0;
}

int ll_DefinitiveNameAndNumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinitiveNameAndNumberForm");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('(', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XNumber llatt_3;
if (!llterm(T_number, &lllval, &llstate_2, &llstate_3)) goto failed1;
llatt_3 = lllval._XNumber;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{(*llret) = NewNamedObjIdValue(eNamedObjIdValue_NameAndNumberForm);
	    (*llret)->Name = llatt_1;
	    (*llret)->Number = intx2uint32(&llatt_3);
	
}}}}}
LLDEBUG_LEAVE("DefinitiveNameAndNumberForm", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinitiveNameAndNumberForm", 0);
return 0;
}

int ll_TagDefault(XTagType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TagDefault");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TagDefault", 1);
{LLSTATE llstate_1;
if (!llterm(T_EXPLICIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_TAGS, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = eTagType_Explicit;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TagDefault", 2);
{LLSTATE llstate_1;
if (!llterm(T_IMPLICIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_TAGS, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = eTagType_Implicit;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("TagDefault", 3);
{LLSTATE llstate_1;
if (!llterm(T_AUTOMATIC, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_TAGS, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = eTagType_Automatic;
	
break;
}}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("TagDefault", 4);
*llout = llstate_0;
{(*llret) = eTagType_Explicit;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TagDefault");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TagDefault", 1);
return 1;
failed1: LLDEBUG_LEAVE("TagDefault", 0);
return 0;
}

int ll_ExtensionDefault(XExtensionType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExtensionDefault");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ExtensionDefault", 1);
{LLSTATE llstate_1;
if (!llterm(T_EXTENSIBILITY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_IMPLIED, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = eExtensionType_Automatic;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ExtensionDefault", 2);
*llout = llstate_0;
{(*llret) = eExtensionType_None;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ExtensionDefault");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ExtensionDefault", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExtensionDefault", 0);
return 0;
}

int ll_ModuleBody(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ModuleBody");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ModuleBody", 1);
{LLSTATE llstate_1;XStrings llatt_1;
if (!ll_Exports(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XStringModules llatt_2;
if (!ll_Imports(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{llstate_2.Imported = llatt_2;
	
{LLSTATE llstate_3;
if (!ll_AssignmentList(&llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{String_t *s;
	    StringModule_t *sm;
	    Assignment_t *a, **aa, *oldass;
	    UndefinedSymbol_t *u;
	    if (llatt_2 != IMPORT_ALL) {
		for (sm = llatt_2; sm; sm = sm->Next) {
		    if (!FindExportedAssignment((*llout).Assignments,
			eAssignment_Undefined, sm->String, sm->Module)) {
			if (FindAssignment((*llout).Assignments,
			    eAssignment_Undefined, sm->String,
			    sm->Module)) {
			    u = NewUndefinedSymbol(
				eUndefinedSymbol_SymbolNotExported,
				eAssignment_Undefined);
			} else {
			    u = NewUndefinedSymbol(
				eUndefinedSymbol_SymbolNotDefined,
				eAssignment_Undefined);
			}
			u->U.Symbol.Identifier = sm->String;
			u->U.Symbol.Module = sm->Module;
			u->Next = (*llout).Undefined;
			(*llout).Undefined = u;
			continue;
		    }
		    if (!FindAssignmentInCurrentPass((*llout).Assignments,
			sm->String, (*llout).Module)) {
			a = NewAssignment(eAssignment_Reference);
			a->Identifier = sm->String;
			a->Module = (*llout).Module;
			a->U.Reference.Identifier = sm->String;
			a->U.Reference.Module = sm->Module;
			a->Next = (*llout).Assignments;
			(*llout).Assignments = a;
		    }
		}
	    }
	    if (llatt_1 != EXPORT_ALL) {
		for (s = llatt_1; s; s = s->Next) {
		    if (!FindAssignment((*llout).Assignments, eAssignment_Undefined,
			s->String, (*llout).Module))
			LLFAILED((&llstate_1.pos, "Exported symbol `%s' is undefined",
			    s->String));
		}
	    }
	    oldass = (*llout).Assignments;
	    for (a = (*llout).Assignments, aa = &(*llout).Assignments; a;
		a = a->Next, aa = &(*aa)->Next) {
		if (a->Type == eAssignment_NextPass)
		    break;
		*aa = DupAssignment(a);
		if (!FindAssignmentInCurrentPass(a->Next, 
		    a->Identifier, a->Module) &&
		    FindAssignmentInCurrentPass(oldass,
		    a->Identifier, a->Module) == a &&
		    !CmpModuleIdentifier(oldass, a->Module, (*llout).Module) &&
		    (llatt_1 == EXPORT_ALL || FindString(llatt_1, a->Identifier)))
		    (*aa)->Flags |= eAssignmentFlags_Exported;
	    }
	    *aa = a;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ModuleBody", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ModuleBody");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ModuleBody", 1);
return 1;
failed1: LLDEBUG_LEAVE("ModuleBody", 0);
return 0;
}

int ll_Exports(XStrings *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Exports");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Exports", 1);
{LLSTATE llstate_1;
if (!llterm(T_EXPORTS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XStrings llatt_2;
if (!ll_SymbolsExported(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(';', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{String_t *s, *t;
	    for (s = llatt_2; s && s->Next; s = s->Next) {
		for (t = s->Next; t; t = t->Next) {
		    if (!strcmp(s->String, t->String))
			LLFAILED((&llstate_2.pos, "Symbol `%s' has been exported twice",
			    s->String));
		}
	    }
	    (*llret) = llatt_2;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Exports", 2);
*llout = llstate_0;
{(*llret) = EXPORT_ALL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Exports");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Exports", 1);
return 1;
failed1: LLDEBUG_LEAVE("Exports", 0);
return 0;
}

int ll_SymbolsExported(XStrings *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SymbolsExported");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SymbolsExported", 1);
{LLSTATE llstate_1;XStrings llatt_1;
if (!ll_SymbolList(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SymbolsExported", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SymbolsExported");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SymbolsExported", 1);
return 1;
failed1: LLDEBUG_LEAVE("SymbolsExported", 0);
return 0;
}

int ll_Imports(XStringModules *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Imports");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Imports", 1);
{LLSTATE llstate_1;
if (!llterm(T_IMPORTS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XStringModules llatt_2;
if (!ll_SymbolsImported(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(';', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_2;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Imports", 2);
*llout = llstate_0;
{(*llret) = IMPORT_ALL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Imports");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Imports", 1);
return 1;
failed1: LLDEBUG_LEAVE("Imports", 0);
return 0;
}

int ll_SymbolsImported(XStringModules *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SymbolsImported");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XStringModules llatt_1;
if (!ll_SymbolsFromModule_ESeq(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("SymbolsImported", 1);
return 1;
failed1: LLDEBUG_LEAVE("SymbolsImported", 0);
return 0;
}

int ll_SymbolsFromModule_ESeq(XStringModules *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SymbolsFromModule_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SymbolsFromModule_ESeq", 1);
{LLSTATE llstate_1;XStringModules llatt_1;
if (!ll_SymbolsFromModule(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XStringModules llatt_2;
if (!ll_SymbolsFromModule_ESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{StringModule_t *s, **ss;
	    for (s = llatt_1, ss = &(*llret); s; s = s->Next) {
		*ss = DupStringModule(s);
		ss = &(*ss)->Next;
	    }
	    *ss = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SymbolsFromModule_ESeq", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SymbolsFromModule_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SymbolsFromModule_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("SymbolsFromModule_ESeq", 0);
return 0;
}

int ll_SymbolsFromModule(XStringModules *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SymbolsFromModule");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XStrings llatt_1;
if (!ll_SymbolList(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_FROM, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XModuleIdentifier llatt_3;
if (!ll_GlobalModuleReference(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{String_t *s, *t;
	    StringModule_t **ss;
	    for (s = llatt_1; s && s->Next; s = s->Next) {
		for (t = s->Next; t; t = t->Next) {
		    if (!strcmp(s->String, t->String))
			LLFAILED((&llstate_2.pos, "Symbol `%s' has been imported twice",
			    s->String));
		}
	    }
	    for (s = llatt_1, ss = &(*llret); s; s = s->Next) {
		*ss = NewStringModule();
		(*ss)->String = s->String;
		(*ss)->Module = llatt_3;
		ss = &(*ss)->Next;
	    }
	    *ss = NULL;
	
}}}}
LLDEBUG_LEAVE("SymbolsFromModule", 1);
return 1;
failed1: LLDEBUG_LEAVE("SymbolsFromModule", 0);
return 0;
}

int ll_GlobalModuleReference(XModuleIdentifier *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("GlobalModuleReference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_AssignedIdentifier(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = NewModuleIdentifier();
	    (*llret)->Identifier = llatt_1->Identifier;
	    (*llret)->ObjectIdentifier = llatt_2;
	
}}}
LLDEBUG_LEAVE("GlobalModuleReference", 1);
return 1;
failed1: LLDEBUG_LEAVE("GlobalModuleReference", 0);
return 0;
}

int ll_AssignedIdentifier(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AssignedIdentifier");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("AssignedIdentifier", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ObjectIdentifierValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("AssignedIdentifier", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_DefinedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("AssignedIdentifier", 3);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("AssignedIdentifier");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("AssignedIdentifier", 1);
return 1;
failed1: LLDEBUG_LEAVE("AssignedIdentifier", 0);
return 0;
}

int ll_SymbolList(XStrings *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SymbolList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SymbolList", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_Symbol(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_SymbolList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = NewString();
	    (*llret)->String = llatt_1;
	    (*llret)->Next = llatt_3;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SymbolList", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_Symbol(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewString();
	    (*llret)->String = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SymbolList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SymbolList", 1);
return 1;
failed1: LLDEBUG_LEAVE("SymbolList", 0);
return 0;
}

int ll_Symbol(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Symbol");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Symbol", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_Reference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Symbol", 2);
{LLSTATE llstate_1;
if (!ll_ParameterizedReference(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Symbol");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Symbol", 1);
return 1;
failed1: LLDEBUG_LEAVE("Symbol", 0);
return 0;
}

int ll_Reference(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Reference");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Reference", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Reference", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_lcsymbol, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Reference");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Reference", 1);
return 1;
failed1: LLDEBUG_LEAVE("Reference", 0);
return 0;
}

int ll_AssignmentList(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AssignmentList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!ll_Assignment(&llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!ll_Assignment_ESeq(&llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
}}
LLDEBUG_LEAVE("AssignmentList", 1);
return 1;
failed1: LLDEBUG_LEAVE("AssignmentList", 0);
return 0;
}

int ll_Assignment_ESeq(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Assignment_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Assignment_ESeq", 1);
{LLSTATE llstate_1;
if (!ll_Assignment(&llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_Assignment_ESeq(&llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Assignment_ESeq", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Assignment_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Assignment_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("Assignment_ESeq", 0);
return 0;
}

int ll_Assignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Assignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Assignment", 1);
{LLSTATE llstate_1;
if (!ll_TypeAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Assignment", 2);
{LLSTATE llstate_1;
if (!ll_ValueAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("Assignment", 3);
{LLSTATE llstate_1;
if (!ll_ValueSetTypeAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("Assignment", 4);
{LLSTATE llstate_1;
if (!ll_ObjectClassAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("Assignment", 5);
{LLSTATE llstate_1;
if (!ll_ObjectAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("Assignment", 6);
{LLSTATE llstate_1;
if (!ll_ObjectSetAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("Assignment", 7);
{LLSTATE llstate_1;
if (!ll_ParameterizedAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 8: case -8:
LLDEBUG_ALTERNATIVE("Assignment", 8);
{LLSTATE llstate_1;
if (!ll_MacroDefinition(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Assignment");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Assignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("Assignment", 0);
return 0;
}

int ll_typereference(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("typereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    ref = FindAssignment((*llout).Assignments,
		eAssignment_Undefined, llatt_1, (*llout).Module);
	    if (!ref) {
		u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
		    eAssignment_Type);
		u->U.Symbol.Module = (*llout).Module;
		u->U.Symbol.Identifier = llatt_1;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Type)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not a typereference", llatt_1));
	    (*llret) = NewType(eType_Reference);
	    if (ref && ref->U.Type.Type)
	    {
	    	int fPublic = ref->U.Type.Type->PrivateDirectives.fPublic;
	    	ref->U.Type.Type->PrivateDirectives.fPublic = 0;
	    	PropagateReferenceTypePrivateDirectives((*llret), &(ref->U.Type.Type->PrivateDirectives));
	    	ref->U.Type.Type->PrivateDirectives.fPublic = fPublic;
	    }
	    (*llret)->U.Reference.Identifier = llatt_1;
	    (*llret)->U.Reference.Module = (*llout).Module;
	
}}
LLDEBUG_LEAVE("typereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("typereference", 0);
return 0;
}

int ll_Externaltypereference(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Externaltypereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XString llatt_3;
if (!ll_ucsymbol(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    if ((*llout).Imported != IMPORT_ALL &&
		!FindStringModule((*llout).Assignments, (*llout).Imported, llatt_3, llatt_1))
		LLFAILED((&llstate_1.pos, "Symbol `%s.%s' has not been imported",
		    llatt_1->Identifier, llatt_3));
	    ref = FindExportedAssignment((*llout).Assignments,
		eAssignment_Type, llatt_3, llatt_1);
	    if (!ref) {
		if (FindAssignment((*llout).Assignments,
		    eAssignment_Type, llatt_3, llatt_1)) {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotExported,
			eAssignment_Type);
		} else {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
			eAssignment_Type);
		}
		u->U.Symbol.Module = llatt_1;
		u->U.Symbol.Identifier = llatt_3;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Type)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not a typereference", llatt_1));
	    (*llret) = NewType(eType_Reference);
	    (*llret)->U.Reference.Identifier = llatt_3;
	    (*llret)->U.Reference.Module = llatt_1;
	
}}}}
LLDEBUG_LEAVE("Externaltypereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("Externaltypereference", 0);
return 0;
}

int ll_valuereference(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("valuereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_lcsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    ref = FindAssignment((*llout).Assignments,
		eAssignment_Undefined, llatt_1, (*llout).Module);
	    if (!ref) {
		u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
		    eAssignment_Value);
		u->U.Symbol.Module = (*llout).Module;
		u->U.Symbol.Identifier = llatt_1;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Value)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not a valuereference", llatt_1));
	    (*llret) = NewValue(NULL, NULL);
	    (*llret)->U.Reference.Identifier = llatt_1;
	    (*llret)->U.Reference.Module = (*llout).Module;
	
}}
LLDEBUG_LEAVE("valuereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("valuereference", 0);
return 0;
}

int ll_Externalvaluereference(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Externalvaluereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XString llatt_3;
if (!llterm(T_lcsymbol, &lllval, &llstate_2, &llstate_3)) goto failed1;
llatt_3 = lllval._XString;
*llout = llstate_3;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    if ((*llout).Imported != IMPORT_ALL &&
		!FindStringModule((*llout).Assignments, (*llout).Imported, llatt_3, llatt_1))
		LLFAILED((&llstate_1.pos, "Symbol `%s.%s' has not been imported",
		    llatt_1->Identifier, llatt_3));
	    ref = FindExportedAssignment((*llout).Assignments,
		eAssignment_Value, llatt_3, llatt_1);
	    if (!ref) {
		if (FindAssignment((*llout).Assignments,
		    eAssignment_Value, llatt_3, llatt_1)) {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotExported,
			eAssignment_Value);
		} else {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
			eAssignment_Value);
		}
		u->U.Symbol.Module = llatt_1;
		u->U.Symbol.Identifier = llatt_3;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Value)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not a valuereference", llatt_1));
	    (*llret) = NewValue(NULL, NULL);
	    (*llret)->U.Reference.Identifier = llatt_3;
	    (*llret)->U.Reference.Module = llatt_1;
	
}}}}
LLDEBUG_LEAVE("Externalvaluereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("Externalvaluereference", 0);
return 0;
}

int ll_objectclassreference(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("objectclassreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ocsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    ref = FindAssignment((*llout).Assignments,
		eAssignment_Undefined, llatt_1, (*llout).Module);
	    if (!ref) {
		u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
		    eAssignment_ObjectClass);
		u->U.Symbol.Module = (*llout).Module;
		u->U.Symbol.Identifier = llatt_1;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_ObjectClass)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an objectclassreference", llatt_1));
	    (*llret) = NewObjectClass(eObjectClass_Reference);
	    (*llret)->U.Reference.Identifier = llatt_1;
	    (*llret)->U.Reference.Module = (*llout).Module;
	
}}
LLDEBUG_LEAVE("objectclassreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("objectclassreference", 0);
return 0;
}

int ll_ExternalObjectClassReference(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExternalObjectClassReference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XString llatt_3;
if (!ll_ocsymbol(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    if ((*llout).Imported != IMPORT_ALL &&
		!FindStringModule((*llout).Assignments, (*llout).Imported, llatt_3, llatt_1))
		LLFAILED((&llstate_1.pos, "Symbol `%s.%s' has not been imported",
		    llatt_1->Identifier, llatt_3));
	    ref = FindExportedAssignment((*llout).Assignments,
		eAssignment_ObjectClass, llatt_3, llatt_1);
	    if (!ref) {
		if (FindAssignment((*llout).Assignments,
		    eAssignment_ObjectClass, llatt_3, llatt_1)) {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotExported,
			eAssignment_ObjectClass);
		} else {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
			eAssignment_ObjectClass);
		}
		u->U.Symbol.Module = llatt_1;
		u->U.Symbol.Identifier = llatt_3;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_ObjectClass)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an objectclassreference", llatt_1));
	    (*llret) = NewObjectClass(eObjectClass_Reference);
	    (*llret)->U.Reference.Identifier = llatt_3;
	    (*llret)->U.Reference.Module = llatt_1;
	
}}}}
LLDEBUG_LEAVE("ExternalObjectClassReference", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExternalObjectClassReference", 0);
return 0;
}

int ll_objectreference(XObject *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("objectreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_lcsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    ref = FindAssignment((*llout).Assignments,
		eAssignment_Undefined, llatt_1, (*llout).Module);
	    if (!ref) {
		u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
		    eAssignment_Object);
		u->U.Symbol.Module = (*llout).Module;
		u->U.Symbol.Identifier = llatt_1;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Object)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an objectreference", llatt_1));
	    (*llret) = NewObject(eObject_Reference);
	    (*llret)->U.Reference.Identifier = llatt_1;
	    (*llret)->U.Reference.Module = (*llout).Module;
	
}}
LLDEBUG_LEAVE("objectreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("objectreference", 0);
return 0;
}

int ll_ExternalObjectReference(XObject *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExternalObjectReference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XString llatt_3;
if (!llterm(T_lcsymbol, &lllval, &llstate_2, &llstate_3)) goto failed1;
llatt_3 = lllval._XString;
*llout = llstate_3;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    if ((*llout).Imported != IMPORT_ALL &&
		!FindStringModule((*llout).Assignments, (*llout).Imported, llatt_3, llatt_1))
		LLFAILED((&llstate_1.pos, "Symbol `%s.%s' has not been imported",
		    llatt_1->Identifier, llatt_3));
	    ref = FindExportedAssignment((*llout).Assignments,
		eAssignment_Object, llatt_3, llatt_1);
	    if (!ref) {
		if (FindAssignment((*llout).Assignments,
		    eAssignment_Object, llatt_3, llatt_1)) {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotExported,
			eAssignment_Object);
		} else {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
			eAssignment_Object);
		}
		u->U.Symbol.Module = llatt_1;
		u->U.Symbol.Identifier = llatt_3;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Object)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an objectreference", llatt_1));
	    (*llret) = NewObject(eObject_Reference);
	    (*llret)->U.Reference.Identifier = llatt_3;
	    (*llret)->U.Reference.Module = llatt_1;
	
}}}}
LLDEBUG_LEAVE("ExternalObjectReference", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExternalObjectReference", 0);
return 0;
}

int ll_objectsetreference(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("objectsetreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    ref = FindAssignment((*llout).Assignments,
		eAssignment_Undefined, llatt_1, (*llout).Module);
	    if (!ref) {
		u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
		    eAssignment_ObjectSet);
		u->U.Symbol.Module = (*llout).Module;
		u->U.Symbol.Identifier = llatt_1;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_ObjectSet)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an objectsetreference", llatt_1));
	    (*llret) = NewObjectSet(eObjectSet_Reference);
	    (*llret)->U.Reference.Identifier = llatt_1;
	    (*llret)->U.Reference.Module = (*llout).Module;
	
}}
LLDEBUG_LEAVE("objectsetreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("objectsetreference", 0);
return 0;
}

int ll_ExternalObjectSetReference(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExternalObjectSetReference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XString llatt_3;
if (!ll_ucsymbol(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    if ((*llout).Imported != IMPORT_ALL &&
		!FindStringModule((*llout).Assignments, (*llout).Imported, llatt_3, llatt_1))
		LLFAILED((&llstate_1.pos, "Symbol `%s.%s' has not been imported",
		    llatt_1->Identifier, llatt_3));
	    ref = FindExportedAssignment((*llout).Assignments,
		eAssignment_ObjectSet, llatt_3, llatt_1);
	    if (!ref) {
		if (FindAssignment((*llout).Assignments,
		    eAssignment_ObjectSet, llatt_3, llatt_1)) {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotExported,
			eAssignment_ObjectSet);
		} else {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
			eAssignment_ObjectSet);
		}
		u->U.Symbol.Module = llatt_1;
		u->U.Symbol.Identifier = llatt_3;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_ObjectSet)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an objectsetreference", llatt_1));
	    (*llret) = NewObjectSet(eObjectSet_Reference);
	    (*llret)->U.Reference.Identifier = llatt_3;
	    (*llret)->U.Reference.Module = llatt_1;
	
}}}}
LLDEBUG_LEAVE("ExternalObjectSetReference", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExternalObjectSetReference", 0);
return 0;
}

int ll_macroreference(XMacro *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("macroreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ocsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    ref = FindAssignment((*llout).Assignments,
		eAssignment_Undefined, llatt_1, (*llout).Module);
	    if (!ref) {
		u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
		    eAssignment_Macro);
		u->U.Symbol.Module = (*llout).Module;
		u->U.Symbol.Identifier = llatt_1;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Macro)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an macroreference", llatt_1));
	    (*llret) = NewMacro(eMacro_Reference);
	    (*llret)->U.Reference.Identifier = llatt_1;
	    (*llret)->U.Reference.Module = (*llout).Module;
	
}}
LLDEBUG_LEAVE("macroreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("macroreference", 0);
return 0;
}

int ll_Externalmacroreference(XMacro *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Externalmacroreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XString llatt_3;
if (!ll_ucsymbol(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    if ((*llout).Imported != IMPORT_ALL &&
		!FindStringModule((*llout).Assignments, (*llout).Imported, llatt_3, llatt_1))
		LLFAILED((&llstate_1.pos, "Symbol `%s.%s' has not been imported",
		    llatt_1->Identifier, llatt_3));
	    ref = FindExportedAssignment((*llout).Assignments,
		eAssignment_Macro, llatt_3, llatt_1);
	    if (!ref) {
		if (FindAssignment((*llout).Assignments,
		    eAssignment_Macro, llatt_3, llatt_1)) {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotExported,
			eAssignment_Macro);
		} else {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
			eAssignment_Macro);
		}
		u->U.Symbol.Module = llatt_1;
		u->U.Symbol.Identifier = llatt_3;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Macro)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an macroreference", llatt_1));
	    (*llret) = NewMacro(eMacro_Reference);
	    (*llret)->U.Reference.Identifier = llatt_3;
	    (*llret)->U.Reference.Module = llatt_1;
	
}}}}
LLDEBUG_LEAVE("Externalmacroreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("Externalmacroreference", 0);
return 0;
}

int ll_localtypereference(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("localtypereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("localtypereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("localtypereference", 0);
return 0;
}

int ll_localvaluereference(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("localvaluereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("localvaluereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("localvaluereference", 0);
return 0;
}

int ll_productionreference(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("productionreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("productionreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("productionreference", 0);
return 0;
}

int ll_modulereference(XModuleIdentifier *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("modulereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = NewModuleIdentifier();
	    (*llret)->Identifier = llatt_1;
	
}}
LLDEBUG_LEAVE("modulereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("modulereference", 0);
return 0;
}

int ll_typefieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("typefieldreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_ampucsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    ObjectClass_t *oc;
	    UndefinedSymbol_t *u;
	    oc = GetObjectClass((*llout).Assignments, llarg_oc);
	    fs = oc ? FindFieldSpec(oc->U.ObjectClass.FieldSpec, llatt_1) : NULL;
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe == eFieldSpec_Undefined) {
		if (llarg_oc) {
		    u = NewUndefinedField(eUndefinedSymbol_FieldNotDefined,
			llarg_oc, eSetting_Type);
		    u->U.Field.Module = (*llout).Module;
		    u->U.Field.Identifier = llatt_1;
		    u->Next = (*llout).Undefined;
		    (*llout).Undefined = u;
		}
	    } else if (fe != eFieldSpec_Type)
		LLFAILED((&llstate_1.pos, "%s is not a typefieldreference", llatt_1));
	    (*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("typefieldreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("typefieldreference", 0);
return 0;
}

int ll_valuefieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("valuefieldreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_amplcsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    ObjectClass_t *oc;
	    UndefinedSymbol_t *u;
	    oc = GetObjectClass((*llout).Assignments, llarg_oc);
	    fs = oc ? FindFieldSpec(oc->U.ObjectClass.FieldSpec, llatt_1) : NULL;
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe == eFieldSpec_Undefined) {
		if (llarg_oc) {
		    u = NewUndefinedField(eUndefinedSymbol_FieldNotDefined,
			llarg_oc, eSetting_Value);
		    u->U.Field.Module = (*llout).Module;
		    u->U.Field.Identifier = llatt_1;
		    u->Next = (*llout).Undefined;
		    (*llout).Undefined = u;
		}
	    } else if (fe != eFieldSpec_FixedTypeValue &&
		fe != eFieldSpec_VariableTypeValue)
		LLFAILED((&llstate_1.pos, "%s is not a valuefieldreference", llatt_1));
	    (*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("valuefieldreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("valuefieldreference", 0);
return 0;
}

int ll_valuesetfieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("valuesetfieldreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_ampucsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    ObjectClass_t *oc;
	    UndefinedSymbol_t *u;
	    oc = GetObjectClass((*llout).Assignments, llarg_oc);
	    fs = oc ? FindFieldSpec(oc->U.ObjectClass.FieldSpec, llatt_1) : NULL;
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe == eFieldSpec_Undefined) {
		if (llarg_oc) {
		    u = NewUndefinedField(eUndefinedSymbol_FieldNotDefined,
			llarg_oc, eSetting_ValueSet);
		    u->U.Field.Module = (*llout).Module;
		    u->U.Field.Identifier = llatt_1;
		    u->Next = (*llout).Undefined;
		    (*llout).Undefined = u;
		}
	    } else if (fe != eFieldSpec_FixedTypeValueSet &&
		fe != eFieldSpec_VariableTypeValueSet)
		LLFAILED((&llstate_1.pos, "%s is not a valuesetfieldreference", llatt_1));
	    (*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("valuesetfieldreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("valuesetfieldreference", 0);
return 0;
}

int ll_objectfieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("objectfieldreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_amplcsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    ObjectClass_t *oc;
	    UndefinedSymbol_t *u;
	    oc = GetObjectClass((*llout).Assignments, llarg_oc);
	    fs = oc ? FindFieldSpec(oc->U.ObjectClass.FieldSpec, llatt_1) : NULL;
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe == eFieldSpec_Undefined) {
		if (llarg_oc) {
		    u = NewUndefinedField(eUndefinedSymbol_FieldNotDefined,
			llarg_oc, eSetting_Object);
		    u->U.Field.Module = (*llout).Module;
		    u->U.Field.Identifier = llatt_1;
		    u->Next = (*llout).Undefined;
		    (*llout).Undefined = u;
		}
	    } else if (fe != eFieldSpec_Object)
		LLFAILED((&llstate_1.pos, "%s is not a objectfieldreference", llatt_1));
	    (*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("objectfieldreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("objectfieldreference", 0);
return 0;
}

int ll_objectsetfieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("objectsetfieldreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_ampucsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    ObjectClass_t *oc;
	    UndefinedSymbol_t *u;
	    oc = GetObjectClass((*llout).Assignments, llarg_oc);
	    fs = oc ? FindFieldSpec(oc->U.ObjectClass.FieldSpec, llatt_1) : NULL;
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe == eFieldSpec_Undefined) {
		if (llarg_oc) {
		    u = NewUndefinedField(eUndefinedSymbol_FieldNotDefined,
			llarg_oc, eSetting_ObjectSet);
		    u->U.Field.Module = (*llout).Module;
		    u->U.Field.Identifier = llatt_1;
		    u->Next = (*llout).Undefined;
		    (*llout).Undefined = u;
		}
	    } else if (fe != eFieldSpec_ObjectSet)
		LLFAILED((&llstate_1.pos, "%s is not a objectsetfieldreference", llatt_1));
	    (*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("objectsetfieldreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("objectsetfieldreference", 0);
return 0;
}

int ll_word(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("word");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("word", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("word", 2);
{LLSTATE llstate_1;
if (!llterm(T_ABSENT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "ABSENT";
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("word", 3);
{LLSTATE llstate_1;
if (!llterm(T_ABSTRACT_SYNTAX, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "ABSTRACT-SYNTAX";
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("word", 4);
{LLSTATE llstate_1;
if (!llterm(T_ALL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "ALL";
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("word", 5);
{LLSTATE llstate_1;
if (!llterm(T_ANY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "ANY";
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("word", 6);
{LLSTATE llstate_1;
if (!llterm(T_APPLICATION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "APPLICATION";
	
break;
}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("word", 7);
{LLSTATE llstate_1;
if (!llterm(T_AUTOMATIC, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "AUTOMATIC";
	
break;
}}
case 8: case -8:
LLDEBUG_ALTERNATIVE("word", 8);
{LLSTATE llstate_1;
if (!llterm(T_BEGIN, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "BEGIN";
	
break;
}}
case 9: case -9:
LLDEBUG_ALTERNATIVE("word", 9);
{LLSTATE llstate_1;
if (!llterm(T_BMPString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "BMPString";
	
break;
}}
case 10: case -10:
LLDEBUG_ALTERNATIVE("word", 10);
{LLSTATE llstate_1;
if (!llterm(T_BY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "BY";
	
break;
}}
case 11: case -11:
LLDEBUG_ALTERNATIVE("word", 11);
{LLSTATE llstate_1;
if (!llterm(T_CLASS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "CLASS";
	
break;
}}
case 12: case -12:
LLDEBUG_ALTERNATIVE("word", 12);
{LLSTATE llstate_1;
if (!llterm(T_COMPONENT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "COMPONENT";
	
break;
}}
case 13: case -13:
LLDEBUG_ALTERNATIVE("word", 13);
{LLSTATE llstate_1;
if (!llterm(T_COMPONENTS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "COMPONENTS";
	
break;
}}
case 14: case -14:
LLDEBUG_ALTERNATIVE("word", 14);
{LLSTATE llstate_1;
if (!llterm(T_CONSTRAINED, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "CONSTRAINED";
	
break;
}}
case 15: case -15:
LLDEBUG_ALTERNATIVE("word", 15);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "DEFAULT";
	
break;
}}
case 16: case -16:
LLDEBUG_ALTERNATIVE("word", 16);
{LLSTATE llstate_1;
if (!llterm(T_DEFINED, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "DEFINED";
	
break;
}}
case 17: case -17:
LLDEBUG_ALTERNATIVE("word", 17);
{LLSTATE llstate_1;
if (!llterm(T_DEFINITIONS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "DEFINITIONS";
	
break;
}}
case 18: case -18:
LLDEBUG_ALTERNATIVE("word", 18);
{LLSTATE llstate_1;
if (!llterm(T_empty, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "empty";
	
break;
}}
case 19: case -19:
LLDEBUG_ALTERNATIVE("word", 19);
{LLSTATE llstate_1;
if (!llterm(T_EXCEPT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "EXCEPT";
	
break;
}}
case 20: case -20:
LLDEBUG_ALTERNATIVE("word", 20);
{LLSTATE llstate_1;
if (!llterm(T_EXPLICIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "EXPLICIT";
	
break;
}}
case 21: case -21:
LLDEBUG_ALTERNATIVE("word", 21);
{LLSTATE llstate_1;
if (!llterm(T_EXPORTS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "EXPORTS";
	
break;
}}
case 22: case -22:
LLDEBUG_ALTERNATIVE("word", 22);
{LLSTATE llstate_1;
if (!llterm(T_EXTENSIBILITY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "EXTENSIBILITY";
	
break;
}}
case 23: case -23:
LLDEBUG_ALTERNATIVE("word", 23);
{LLSTATE llstate_1;
if (!llterm(T_FROM, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "FROM";
	
break;
}}
case 24: case -24:
LLDEBUG_ALTERNATIVE("word", 24);
{LLSTATE llstate_1;
if (!llterm(T_GeneralizedTime, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "GeneralizedTime";
	
break;
}}
case 25: case -25:
LLDEBUG_ALTERNATIVE("word", 25);
{LLSTATE llstate_1;
if (!llterm(T_GeneralString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "GeneralString";
	
break;
}}
case 26: case -26:
LLDEBUG_ALTERNATIVE("word", 26);
{LLSTATE llstate_1;
if (!llterm(T_GraphicString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "GraphicString";
	
break;
}}
case 27: case -27:
LLDEBUG_ALTERNATIVE("word", 27);
{LLSTATE llstate_1;
if (!llterm(T_IA5String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "IA5String";
	
break;
}}
case 28: case -28:
LLDEBUG_ALTERNATIVE("word", 28);
{LLSTATE llstate_1;
if (!llterm(T_IDENTIFIER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "IDENTIFIER";
	
break;
}}
case 29: case -29:
LLDEBUG_ALTERNATIVE("word", 29);
{LLSTATE llstate_1;
if (!llterm(T_identifier, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "identifier";
	
break;
}}
case 30: case -30:
LLDEBUG_ALTERNATIVE("word", 30);
{LLSTATE llstate_1;
if (!llterm(T_IMPLICIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "IMPLICIT";
	
break;
}}
case 31: case -31:
LLDEBUG_ALTERNATIVE("word", 31);
{LLSTATE llstate_1;
if (!llterm(T_IMPLIED, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "IMPLIED";
	
break;
}}
case 32: case -32:
LLDEBUG_ALTERNATIVE("word", 32);
{LLSTATE llstate_1;
if (!llterm(T_IMPORTS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "IMPORTS";
	
break;
}}
case 33: case -33:
LLDEBUG_ALTERNATIVE("word", 33);
{LLSTATE llstate_1;
if (!llterm(T_INCLUDES, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "INCLUDES";
	
break;
}}
case 34: case -34:
LLDEBUG_ALTERNATIVE("word", 34);
{LLSTATE llstate_1;
if (!llterm(T_ISO646String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "ISO646String";
	
break;
}}
case 35: case -35:
LLDEBUG_ALTERNATIVE("word", 35);
{LLSTATE llstate_1;
if (!llterm(T_MACRO, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "MACRO";
	
break;
}}
case 36: case -36:
LLDEBUG_ALTERNATIVE("word", 36);
{LLSTATE llstate_1;
if (!llterm(T_MAX, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "MAX";
	
break;
}}
case 37: case -37:
LLDEBUG_ALTERNATIVE("word", 37);
{LLSTATE llstate_1;
if (!llterm(T_MIN, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "MIN";
	
break;
}}
case 38: case -38:
LLDEBUG_ALTERNATIVE("word", 38);
{LLSTATE llstate_1;
if (!llterm(T_NOTATION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "NOTATION";
	
break;
}}
case 39: case -39:
LLDEBUG_ALTERNATIVE("word", 39);
{LLSTATE llstate_1;
if (!llterm(T_Number, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "number";
	
break;
}}
case 40: case -40:
LLDEBUG_ALTERNATIVE("word", 40);
{LLSTATE llstate_1;
if (!llterm(T_NumericString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "NumericString";
	
break;
}}
case 41: case -41:
LLDEBUG_ALTERNATIVE("word", 41);
{LLSTATE llstate_1;
if (!llterm(T_ObjectDescriptor, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "ObjectDescriptor";
	
break;
}}
case 42: case -42:
LLDEBUG_ALTERNATIVE("word", 42);
{LLSTATE llstate_1;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "OF";
	
break;
}}
case 43: case -43:
LLDEBUG_ALTERNATIVE("word", 43);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "OPTIONAL";
	
break;
}}
case 44: case -44:
LLDEBUG_ALTERNATIVE("word", 44);
{LLSTATE llstate_1;
if (!llterm(T_PDV, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "PDV";
	
break;
}}
case 45: case -45:
LLDEBUG_ALTERNATIVE("word", 45);
{LLSTATE llstate_1;
if (!llterm(T_PRESENT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "PRESENT";
	
break;
}}
case 46: case -46:
LLDEBUG_ALTERNATIVE("word", 46);
{LLSTATE llstate_1;
if (!llterm(T_PrintableString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "PrintableString";
	
break;
}}
case 47: case -47:
LLDEBUG_ALTERNATIVE("word", 47);
{LLSTATE llstate_1;
if (!llterm(T_PRIVATE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "PRIVATE";
	
break;
}}
case 48: case -48:
LLDEBUG_ALTERNATIVE("word", 48);
{LLSTATE llstate_1;
if (!llterm(T_SIZE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "SIZE";
	
break;
}}
case 49: case -49:
LLDEBUG_ALTERNATIVE("word", 49);
{LLSTATE llstate_1;
if (!llterm(T_STRING, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "STRING";
	
break;
}}
case 50: case -50:
LLDEBUG_ALTERNATIVE("word", 50);
{LLSTATE llstate_1;
if (!llterm(T_string, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "string";
	
break;
}}
case 51: case -51:
LLDEBUG_ALTERNATIVE("word", 51);
{LLSTATE llstate_1;
if (!llterm(T_SYNTAX, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "SYNTAX";
	
break;
}}
case 52: case -52:
LLDEBUG_ALTERNATIVE("word", 52);
{LLSTATE llstate_1;
if (!llterm(T_T61String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "T61String";
	
break;
}}
case 53: case -53:
LLDEBUG_ALTERNATIVE("word", 53);
{LLSTATE llstate_1;
if (!llterm(T_TAGS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "TAGS";
	
break;
}}
case 54: case -54:
LLDEBUG_ALTERNATIVE("word", 54);
{LLSTATE llstate_1;
if (!llterm(T_TeletexString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "TeletexString";
	
break;
}}
case 55: case -55:
LLDEBUG_ALTERNATIVE("word", 55);
{LLSTATE llstate_1;
if (!llterm(T_TYPE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "TYPE";
	
break;
}}
case 56: case -56:
LLDEBUG_ALTERNATIVE("word", 56);
{LLSTATE llstate_1;
if (!llterm(T_type, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "type";
	
break;
}}
case 57: case -57:
LLDEBUG_ALTERNATIVE("word", 57);
{LLSTATE llstate_1;
if (!llterm(T_TYPE_IDENTIFIER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "TYPE-IDENTIFIER";
	
break;
}}
case 58: case -58:
LLDEBUG_ALTERNATIVE("word", 58);
{LLSTATE llstate_1;
if (!llterm(T_UNIQUE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "UNIQUE";
	
break;
}}
case 59: case -59:
LLDEBUG_ALTERNATIVE("word", 59);
{LLSTATE llstate_1;
if (!llterm(T_UNIVERSAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "UNIVERSAL";
	
break;
}}
case 60: case -60:
LLDEBUG_ALTERNATIVE("word", 60);
{LLSTATE llstate_1;
if (!llterm(T_UniversalString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "UniversalString";
	
break;
}}
case 61: case -61:
LLDEBUG_ALTERNATIVE("word", 61);
{LLSTATE llstate_1;
if (!llterm(T_UTCTime, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "UTCTime";
	
break;
}}
case 62: case -62:
LLDEBUG_ALTERNATIVE("word", 62);
{LLSTATE llstate_1;
if (!llterm(T_UTF8String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "UTF8String";
	
break;
}}
case 63: case -63:
LLDEBUG_ALTERNATIVE("word", 63);
{LLSTATE llstate_1;
if (!llterm(T_VALUE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "VALUE";
	
break;
}}
case 64: case -64:
LLDEBUG_ALTERNATIVE("word", 64);
{LLSTATE llstate_1;
if (!llterm(T_value, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "value";
	
break;
}}
case 65: case -65:
LLDEBUG_ALTERNATIVE("word", 65);
{LLSTATE llstate_1;
if (!llterm(T_VideotexString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "VideotexString";
	
break;
}}
case 66: case -66:
LLDEBUG_ALTERNATIVE("word", 66);
{LLSTATE llstate_1;
if (!llterm(T_VisibleString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "VisibleString";
	
break;
}}
case 67: case -67:
LLDEBUG_ALTERNATIVE("word", 67);
{LLSTATE llstate_1;
if (!llterm(T_WITH, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "WITH";
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("word");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("word", 1);
return 1;
failed1: LLDEBUG_LEAVE("word", 0);
return 0;
}

int ll_identifier(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("identifier");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("identifier", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_lcsymbol, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("identifier", 2);
{LLSTATE llstate_1;
if (!llterm(T_empty, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "empty";
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("identifier", 3);
{LLSTATE llstate_1;
if (!llterm(T_identifier, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "identifier";
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("identifier", 4);
{LLSTATE llstate_1;
if (!llterm(T_Number, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "number";
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("identifier", 5);
{LLSTATE llstate_1;
if (!llterm(T_string, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "string";
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("identifier", 6);
{LLSTATE llstate_1;
if (!llterm(T_type, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "type";
	
break;
}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("identifier", 7);
{LLSTATE llstate_1;
if (!llterm(T_value, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "value";
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("identifier");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("identifier", 1);
return 1;
failed1: LLDEBUG_LEAVE("identifier", 0);
return 0;
}

int ll_ucsymbol(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ucsymbol");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ucsymbol", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ocsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ucsymbol", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_uppercase_symbol, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ucsymbol");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ucsymbol", 1);
return 1;
failed1: LLDEBUG_LEAVE("ucsymbol", 0);
return 0;
}

int ll_ocsymbol(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ocsymbol");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ocsymbol", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_only_uppercase_symbol, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ocsymbol", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_only_uppercase_digits_symbol, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ocsymbol", 3);
{LLSTATE llstate_1;
if (!llterm(T_MACRO, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "MACRO";
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("ocsymbol", 4);
{LLSTATE llstate_1;
if (!llterm(T_NOTATION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "NOTATION";
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("ocsymbol", 5);
{LLSTATE llstate_1;
if (!llterm(T_TYPE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "TYPE";
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("ocsymbol", 6);
{LLSTATE llstate_1;
if (!llterm(T_VALUE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "VALUE";
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ocsymbol");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ocsymbol", 1);
return 1;
failed1: LLDEBUG_LEAVE("ocsymbol", 0);
return 0;
}

int ll_astring(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("astring");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString32 llatt_1;
if (!llterm(T_cstring, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString32;
*llout = llstate_1;
{uint32_t i, len;
	    len = str32len(llatt_1);
	    (*llret) = (char *)malloc(len + 1);
	    for (i = 0; i <= len; i++)
		(*llret)[i] = (char)(llatt_1[i]);
	
}}
LLDEBUG_LEAVE("astring", 1);
return 1;
failed1: LLDEBUG_LEAVE("astring", 0);
return 0;
}

int ll_DefinedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_Externaltypereference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_typereference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("DefinedType", 3);
{LLSTATE llstate_1;
if (!ll_ParameterizedType(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("DefinedType", 4);
{LLSTATE llstate_1;
if (!ll_ParameterizedValueSetType(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedType", 0);
return 0;
}

int ll_TypeAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XType llatt_1;
if (!ll_typereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XType llatt_3;
if (!ll_Type(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XPrivateDirectives llatt_4;
if (!ll_PrivateDirectives(&llatt_4, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{PropagatePrivateDirectives(llatt_3, llatt_4);
	    if (!AssignType(&(*llout).Assignments, llatt_1, llatt_3))
		LLFAILED((&llstate_1.pos, "Type `%s' twice defined",
		    llatt_1->U.Reference.Identifier));
		((*llout).Assignments)->eDefTagType = g_eDefTagType;
	
}}}}}
LLDEBUG_LEAVE("TypeAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeAssignment", 0);
return 0;
}

int ll_ValueSetTypeAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueSetTypeAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XType llatt_1;
if (!ll_typereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XValueSet llatt_4;
if (!ll_ValueSet(&llatt_4, &llstate_3, &llstate_4, llatt_2)) goto failed1;
*llout = llstate_4;
{Type_t *type;
	    type = GetTypeOfValueSet((*llout).Assignments, llatt_4);
	    if (!AssignType(&(*llout).Assignments, llatt_1, type))
		LLFAILED((&llstate_1.pos, "Type `%s' twice defined",
		    llatt_1->U.Reference.Identifier));
	
}}}}}
LLDEBUG_LEAVE("ValueSetTypeAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueSetTypeAssignment", 0);
return 0;
}

int ll_ValueSet(XValueSet *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueSet");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_ElementSetSpec(&llatt_2, &llstate_1, &llstate_2, llarg_type, NULL, 0)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = NewValueSet();
	    (*llret)->Elements = llatt_2;
	    (*llret)->Type = llarg_type;
	
}}}}
LLDEBUG_LEAVE("ValueSet", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueSet", 0);
return 0;
}

int ll_Type(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Type");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XDirectives llatt_1;
if (!ll_LocalTypeDirectiveESeq(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_UndirectivedType(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XDirectives llatt_3;
if (!ll_LocalTypeDirectiveESeq(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Directive_t **dd, *d;
	    if (llatt_1 || llatt_3) {
		(*llret) = DupType(llatt_2);
		dd = &(*llret)->Directives;
		for (d = llatt_1; d; d = d->Next) {
		    *dd = DupDirective(d);
		    dd = &(*dd)->Next;
		}
		for (d = llatt_3; d; d = d->Next) {
		    *dd = DupDirective(d);
		    dd = &(*dd)->Next;
		}
		*dd = llatt_2->Directives;
	    } else {
		(*llret) = llatt_2;
	    }
	
}}}}
LLDEBUG_LEAVE("Type", 1);
return 1;
failed1: LLDEBUG_LEAVE("Type", 0);
return 0;
}

int ll_UndirectivedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UndirectivedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UndirectivedType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_UntaggedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UndirectivedType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_TaggedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UndirectivedType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UndirectivedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("UndirectivedType", 0);
return 0;
}

int ll_UntaggedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UntaggedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UntaggedType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_ConstrainableType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UntaggedType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_SequenceOfType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("UntaggedType", 3);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_SetOfType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("UntaggedType", 4);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_TypeWithConstraint(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UntaggedType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UntaggedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("UntaggedType", 0);
return 0;
}

int ll_ConstrainableType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ConstrainableType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ConstrainableType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_BuiltinType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalTypeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XConstraints llatt_4;
if (!ll_Constraint_ESeq(&llatt_4, &llstate_3, &llstate_4, llatt_1)) goto failed2;
{LLSTATE llstate_5;XDirectives llatt_5;
if (!ll_LocalTypeDirectiveESeq(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;XPrivateDirectives llatt_6;
if (!ll_PrivateDirectives(&llatt_6, &llstate_5, &llstate_6)) goto failed2;
*llout = llstate_6;
{Directive_t *d, **dd;
	    if (llatt_2 || llatt_4 || llatt_5) {
		(*llret) = DupType(llatt_1);
		IntersectConstraints(&(*llret)->Constraints,
		    llatt_1->Constraints, llatt_4);
		dd = &(*llret)->Directives;
		for (d = llatt_2; d; d = d->Next) {
		    *dd = DupDirective(d);
		    dd = &(*dd)->Next;
		}
		for (d = llatt_5; d; d = d->Next) {
		    *dd = DupDirective(d);
		    dd = &(*dd)->Next;
		}
		*dd = NULL;
	    } else {
		(*llret) = (llatt_3 || llatt_6) ? DupType(llatt_1) : llatt_1;
	    }
	    PropagatePrivateDirectives((*llret), llatt_3);
	    PropagatePrivateDirectives((*llret), llatt_6);
	
break;
}}}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ConstrainableType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_ReferencedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalTypeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XConstraints llatt_4;
if (!ll_Constraint_ESeq(&llatt_4, &llstate_3, &llstate_4, llatt_1)) goto failed2;
{LLSTATE llstate_5;XDirectives llatt_5;
if (!ll_LocalTypeDirectiveESeq(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;XPrivateDirectives llatt_6;
if (!ll_PrivateDirectives(&llatt_6, &llstate_5, &llstate_6)) goto failed2;
*llout = llstate_6;
{Directive_t *d, **dd;
	    if (llatt_2 || llatt_4 || llatt_5) {
		(*llret) = DupType(llatt_1);
		IntersectConstraints(&(*llret)->Constraints,
		    llatt_1->Constraints, llatt_4);
		dd = &(*llret)->Directives;
		for (d = llatt_2; d; d = d->Next) {
		    *dd = DupDirective(d);
		    dd = &(*dd)->Next;
		}
		for (d = llatt_5; d; d = d->Next) {
		    *dd = DupDirective(d);
		    dd = &(*dd)->Next;
		}
		*dd = NULL;
	    } else {
		(*llret) = (llatt_3 || llatt_6) ? DupType(llatt_1) : llatt_1;
	    }
	    PropagatePrivateDirectives((*llret), llatt_3);
	    PropagatePrivateDirectives((*llret), llatt_6);
	
break;
}}}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ConstrainableType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ConstrainableType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ConstrainableType", 0);
return 0;
}

int ll_Constraint_ESeq(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Constraint_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Constraint_ESeq", 1);
{LLSTATE llstate_1;XConstraints llatt_1;
if (!ll_Constraint(&llatt_1, &llstate_0, &llstate_1, llarg_type, 0)) goto failed2;
{LLSTATE llstate_2;XConstraints llatt_2;
if (!ll_Constraint_ESeq(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{if (llatt_2) {
		IntersectConstraints(&(*llret), llatt_1, llatt_2);
	    } else {
		(*llret) = llatt_1;
	    }
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Constraint_ESeq", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Constraint_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Constraint_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("Constraint_ESeq", 0);
return 0;
}

int ll_BuiltinType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("BuiltinType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("BuiltinType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_BitStringType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("BuiltinType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_BooleanType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("BuiltinType", 3);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_CharacterStringType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("BuiltinType", 4);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_ChoiceType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("BuiltinType", 5);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_EmbeddedPDVType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("BuiltinType", 6);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_EnumeratedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("BuiltinType", 7);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_ExternalType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 8: case -8:
LLDEBUG_ALTERNATIVE("BuiltinType", 8);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_InstanceOfType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 9: case -9:
LLDEBUG_ALTERNATIVE("BuiltinType", 9);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_IntegerType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 10: case -10:
LLDEBUG_ALTERNATIVE("BuiltinType", 10);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_NullType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 11: case -11:
LLDEBUG_ALTERNATIVE("BuiltinType", 11);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_ObjectClassFieldType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 12: case -12:
LLDEBUG_ALTERNATIVE("BuiltinType", 12);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_ObjectIdentifierType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 13: case -13:
LLDEBUG_ALTERNATIVE("BuiltinType", 13);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_OctetStringType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 14: case -14:
LLDEBUG_ALTERNATIVE("BuiltinType", 14);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_UTF8StringType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 15: case -15:
LLDEBUG_ALTERNATIVE("BuiltinType", 15);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_RealType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 16: case -16:
LLDEBUG_ALTERNATIVE("BuiltinType", 16);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_SequenceType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 17: case -17:
LLDEBUG_ALTERNATIVE("BuiltinType", 17);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_SetType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 18: case -18:
LLDEBUG_ALTERNATIVE("BuiltinType", 18);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_AnyType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 19: case -19:
LLDEBUG_ALTERNATIVE("BuiltinType", 19);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_MacroDefinedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("BuiltinType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("BuiltinType", 1);
return 1;
failed1: LLDEBUG_LEAVE("BuiltinType", 0);
return 0;
}

int ll_ReferencedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ReferencedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ReferencedType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_DefinedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ReferencedType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_UsefulType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ReferencedType", 3);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_SelectionType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("ReferencedType", 4);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_TypeFromObject(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("ReferencedType", 5);
{LLSTATE llstate_1;XValueSet llatt_1;
if (!ll_ValueSetFromObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = GetTypeOfValueSet((*llout).Assignments, llatt_1);
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ReferencedType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ReferencedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ReferencedType", 0);
return 0;
}

int ll_NamedType(XNamedType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NamedType", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewNamedType(llatt_2->PrivateDirectives.pszFieldName ? llatt_2->PrivateDirectives.pszFieldName : llatt_1, llatt_2);
	    llatt_2->PrivateDirectives.pszFieldName = NULL;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NamedType", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('<', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XType llatt_3;
if (!ll_Type(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{Type_t *type;
	    type = NewType(eType_Selection);
	    type->U.Selection.Type = llatt_3;
	    type->U.Selection.Identifier = llatt_1;
	    (*llret) = NewNamedType(llatt_3->PrivateDirectives.pszFieldName ? llatt_3->PrivateDirectives.pszFieldName : llatt_1, type);
	    llatt_3->PrivateDirectives.pszFieldName = NULL;
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NamedType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NamedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedType", 0);
return 0;
}

int ll_BooleanType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("BooleanType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_BOOLEAN, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = Builtin_Type_Boolean;
	
}}
LLDEBUG_LEAVE("BooleanType", 1);
return 1;
failed1: LLDEBUG_LEAVE("BooleanType", 0);
return 0;
}

int ll_IntegerType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IntegerType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("IntegerType", 1);
{LLSTATE llstate_1;
if (!llterm(T_INTEGER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNamedNumbers llatt_3;
if (!ll_NamedNumberList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{NamedNumber_t *n, *m;
	    for (n = llatt_3; n && n->Next; n = n->Next) {
		for (m = n->Next; m; m = m->Next) {
		    if (n->Type == eNamedNumber_Normal &&
			m->Type == eNamedNumber_Normal) {
			if (!strcmp(n->U.Normal.Identifier,
			    m->U.Normal.Identifier))
			    LLFAILED((&llstate_3.pos,
				"identifier `%s' has been assigned twice",
				n->U.Normal.Identifier));
			if (GetValue((*llout).Assignments, n->U.Normal.Value) &&
			    GetValue((*llout).Assignments, m->U.Normal.Value) &&
			    GetTypeType((*llout).Assignments,
			    GetValue((*llout).Assignments, n->U.Normal.Value)->Type)
			    == eType_Integer &&
			    GetTypeType((*llout).Assignments,
			    GetValue((*llout).Assignments, m->U.Normal.Value)->Type)
			    == eType_Integer &&
			    !intx_cmp(&GetValue((*llout).Assignments,
			    n->U.Normal.Value)->U.Integer.Value,
			    &GetValue((*llout).Assignments,
			    m->U.Normal.Value)->U.Integer.Value))
			    LLFAILED((&llstate_3.pos,
				"value `%d' has been assigned twice",
				intx2int32(&GetValue((*llout).Assignments,
				n->U.Normal.Value)->U.Integer.Value)));
		    }
		}
	    }
	    (*llret) = NewType(eType_Integer);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.Integer.NamedNumbers = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("IntegerType", 2);
{LLSTATE llstate_1;
if (!llterm(T_INTEGER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewType(eType_Integer);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("IntegerType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("IntegerType", 1);
return 1;
failed1: LLDEBUG_LEAVE("IntegerType", 0);
return 0;
}

int ll_NamedNumberList(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedNumberList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NamedNumberList", 1);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_NamedNumber(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNamedNumbers llatt_3;
if (!ll_NamedNumberList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = DupNamedNumber(llatt_1);
	    (*llret)->Next = llatt_3;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NamedNumberList", 2);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_NamedNumber(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NamedNumberList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NamedNumberList", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedNumberList", 0);
return 0;
}

int ll_NamedNumber(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedNumber");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NamedNumber", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('(', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_SignedNumber(&llatt_3, &llstate_2, &llstate_3, Builtin_Type_Integer)) goto failed2;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{(*llret) = NewNamedNumber(eNamedNumber_Normal);
	    (*llret)->U.Normal.Identifier = llatt_1;
	    (*llret)->U.Normal.Value = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NamedNumber", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('(', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_DefinedValue(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{Value_t *v;
	    v = GetValue((*llout).Assignments, llatt_3);
	    if (v) {
		if (GetTypeType((*llout).Assignments, v->Type) != eType_Undefined &&
		    GetTypeType((*llout).Assignments, v->Type) != eType_Integer)
		    LLFAILED((&llstate_3.pos, "Bad type of value"));
		if (GetTypeType((*llout).Assignments, v->Type) != eType_Integer &&
		    intx_cmp(&v->U.Integer.Value, &intx_0) < 0)
		    LLFAILED((&llstate_3.pos, "Bad value"));
	    }
	    (*llret) = NewNamedNumber(eNamedNumber_Normal);
	    (*llret)->U.Normal.Identifier = llatt_1;
	    (*llret)->U.Normal.Value = llatt_3;
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NamedNumber");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NamedNumber", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedNumber", 0);
return 0;
}

int ll_EnumeratedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("EnumeratedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_ENUMERATED, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XNamedNumbers llatt_3;
if (!ll_Enumerations(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{NamedNumber_t **nn, *n, *m;
	    intx_t *ix;
	    uint32_t num = 0;
	    (*llret) = NewType(eType_Enumerated);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    for (n = llatt_3; n; n = n->Next)
		if (n->Type == eNamedNumber_Normal)
		    KeepEnumNames(n->U.Normal.Identifier); // global conflict check
	    for (n = llatt_3; n && n->Next; n = n->Next) {
		if (n->Type != eNamedNumber_Normal)
		    continue;
		for (m = n->Next; m; m = m->Next) {
		    if (m->Type != eNamedNumber_Normal)
			continue;
		    if (!strcmp(n->U.Normal.Identifier,
			m->U.Normal.Identifier))
			LLFAILED((&llstate_3.pos,
			    "identifier `%s' has been assigned twice",
			    n->U.Normal.Identifier));
		    if (GetValue((*llout).Assignments, n->U.Normal.Value) &&
			GetValue((*llout).Assignments, m->U.Normal.Value) &&
			GetTypeType((*llout).Assignments,
			GetValue((*llout).Assignments, n->U.Normal.Value)->Type)
			== eType_Integer &&
			GetTypeType((*llout).Assignments,
			GetValue((*llout).Assignments, m->U.Normal.Value)->Type)
			== eType_Integer &&
			!intx_cmp(&GetValue((*llout).Assignments,
			n->U.Normal.Value)->U.Integer.Value,
			&GetValue((*llout).Assignments,
			m->U.Normal.Value)->U.Integer.Value))
			LLFAILED((&llstate_3.pos,
			    "value `%d' has been assigned twice",
			    intx2int32(&GetValue((*llout).Assignments,
			    n->U.Normal.Value)->U.Integer.Value)));
		}
	    }
	    nn = &(*llret)->U.Enumerated.NamedNumbers;
	    for (n = llatt_3; n; n = n->Next) {
		*nn = DupNamedNumber(n);
		switch (n->Type) {
		case eNamedNumber_Normal:
		    if (n->U.Normal.Value)
			break;
		    for (;; num++) {
			for (m = llatt_3; m; m = m->Next) {
			    switch (m->Type) {
			    case eNamedNumber_Normal:
				if (!m->U.Normal.Value)
				    continue;
				ix = &GetValue((*llout).Assignments,
				    m->U.Normal.Value)->U.Integer.Value;
				if (!intxisuint32(ix) ||
				    intx2uint32(ix) != num)
				    continue;
				break;
			    default:
				continue;
			    }
			    break;
			}
			if (!m)
			    break;
		    }
		    (*nn)->U.Normal.Value = NewValue(NULL,
			Builtin_Type_Integer);
		    intx_setuint32(
			&(*nn)->U.Normal.Value->U.Integer.Value,
		    	num++);
		    break;
		case eNamedNumber_ExtensionMarker:
		    break;
		}
		nn = &(*nn)->Next;
	    }
	    *nn = NULL;
	
}}}}}
LLDEBUG_LEAVE("EnumeratedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("EnumeratedType", 0);
return 0;
}

int ll_Enumerations(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Enumerations");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_Enumeration(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XNamedNumbers llatt_2;
if (!ll_EnumerationExtension(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{NamedNumber_t **nn, *n;
	    nn = &(*llret);
	    for (n = llatt_1; n; n = n->Next) {
		*nn = DupNamedNumber(n);
		nn = &(*nn)->Next;
	    }
	    *nn = llatt_2;
	
}}}
LLDEBUG_LEAVE("Enumerations", 1);
return 1;
failed1: LLDEBUG_LEAVE("Enumerations", 0);
return 0;
}

int ll_EnumerationExtension(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("EnumerationExtension");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("EnumerationExtension", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(',', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XNamedNumbers llatt_4;
if (!ll_Enumeration(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{(*llret) = NewNamedNumber(eNamedNumber_ExtensionMarker);
	    (*llret)->Next = llatt_4;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("EnumerationExtension", 2);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewNamedNumber(eNamedNumber_ExtensionMarker);
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("EnumerationExtension", 3);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("EnumerationExtension");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("EnumerationExtension", 1);
return 1;
failed1: LLDEBUG_LEAVE("EnumerationExtension", 0);
return 0;
}

int ll_Enumeration(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Enumeration");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Enumeration", 1);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_EnumerationItem(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNamedNumbers llatt_3;
if (!ll_Enumeration(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = DupNamedNumber(llatt_1);
	    (*llret)->Next = llatt_3;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Enumeration", 2);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_EnumerationItem(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Enumeration");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Enumeration", 1);
return 1;
failed1: LLDEBUG_LEAVE("Enumeration", 0);
return 0;
}

int ll_EnumerationItem(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("EnumerationItem");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("EnumerationItem", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewNamedNumber(eNamedNumber_Normal);
	    (*llret)->U.Normal.Identifier = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("EnumerationItem", 2);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_NamedNumber(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("EnumerationItem");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("EnumerationItem", 1);
return 1;
failed1: LLDEBUG_LEAVE("EnumerationItem", 0);
return 0;
}

int ll_RealType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("RealType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_REAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = Builtin_Type_Real;
	
}}
LLDEBUG_LEAVE("RealType", 1);
return 1;
failed1: LLDEBUG_LEAVE("RealType", 0);
return 0;
}

int ll_BitStringType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("BitStringType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("BitStringType", 1);
{LLSTATE llstate_1;
if (!llterm(T_BIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_STRING, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('{', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XNamedNumbers llatt_4;
if (!ll_NamedBitList(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
{LLSTATE llstate_5;
if (!llterm('}', (LLSTYPE *)0, &llstate_4, &llstate_5)) goto failed2;
*llout = llstate_5;
{NamedNumber_t *n, *m;
	    (*llret) = NewType(eType_BitString);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.BitString.NamedNumbers = llatt_4;
	    for (n = llatt_4; n; n = n->Next)
	        KeepEnumNames(n->U.Normal.Identifier); // global conflict check
	    for (n = llatt_4; n && n->Next; n = n->Next) {
		for (m = n->Next; m; m = m->Next) {
		    if (!strcmp(n->U.Normal.Identifier,
			m->U.Normal.Identifier))
			LLFAILED((&llstate_4.pos,
			    "identifier `%s' has been assigned twice",
			    n->U.Normal.Identifier));
		    if (GetValue((*llout).Assignments, n->U.Normal.Value) &&
			GetValue((*llout).Assignments, m->U.Normal.Value) &&
			GetTypeType((*llout).Assignments,
			GetValue((*llout).Assignments, n->U.Normal.Value)->Type)
			== eType_Integer &&
			GetTypeType((*llout).Assignments,
			GetValue((*llout).Assignments, m->U.Normal.Value)->Type)
			== eType_Integer &&
			!intx_cmp(&GetValue((*llout).Assignments,
			n->U.Normal.Value)->U.Integer.Value,
			&GetValue((*llout).Assignments,
			m->U.Normal.Value)->U.Integer.Value))
			LLFAILED((&llstate_4.pos,
			    "value `%u' has been assigned twice",
			    intx2uint32(&GetValue((*llout).Assignments,
			    n->U.Normal.Value)->U.Integer.Value)));
		}
	    }
	
break;
}}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("BitStringType", 2);
{LLSTATE llstate_1;
if (!llterm(T_BIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_STRING, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewType(eType_BitString);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("BitStringType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("BitStringType", 1);
return 1;
failed1: LLDEBUG_LEAVE("BitStringType", 0);
return 0;
}

int ll_NamedBitList(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedBitList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NamedBitList", 1);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_NamedBit(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNamedNumbers llatt_3;
if (!ll_NamedBitList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = DupNamedNumber(llatt_1);
	    (*llret)->Next = llatt_3;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NamedBitList", 2);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_NamedBit(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NamedBitList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NamedBitList", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedBitList", 0);
return 0;
}

int ll_NamedBit(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedBit");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NamedBit", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('(', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNumber llatt_3;
if (!llterm(T_number, &lllval, &llstate_2, &llstate_3)) goto failed2;
llatt_3 = lllval._XNumber;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{(*llret) = NewNamedNumber(eNamedNumber_Normal);
	    (*llret)->U.Normal.Identifier = llatt_1;
	    (*llret)->U.Normal.Value = NewValue(NULL, Builtin_Type_Integer);
	    (*llret)->U.Normal.Value->U.Integer.Value = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NamedBit", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('(', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_DefinedValue(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{Value_t *v;
	    v = GetValue((*llout).Assignments, llatt_3);
	    if (v) {
		if (GetTypeType((*llout).Assignments, v->Type) != eType_Undefined &&
		    GetTypeType((*llout).Assignments, v->Type) != eType_Integer)
		    LLFAILED((&llstate_3.pos, "Bad type of value"));
		if (GetTypeType((*llout).Assignments, v->Type) == eType_Integer &&
		    intx_cmp(&v->U.Integer.Value, &intx_0) < 0)
		    LLFAILED((&llstate_3.pos, "Bad value"));
	    }
	    (*llret) = NewNamedNumber(eNamedNumber_Normal);
	    (*llret)->U.Normal.Identifier = llatt_1;
	    (*llret)->U.Normal.Value = llatt_3;
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NamedBit");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NamedBit", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedBit", 0);
return 0;
}

int ll_OctetStringType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("OctetStringType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_OCTET, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_STRING, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = Builtin_Type_OctetString;
	
}}}
LLDEBUG_LEAVE("OctetStringType", 1);
return 1;
failed1: LLDEBUG_LEAVE("OctetStringType", 0);
return 0;
}

int ll_UTF8StringType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UTF8StringType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_UTF8String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = Builtin_Type_UTF8String;
	
}}
LLDEBUG_LEAVE("UTF8StringType", 1);
return 1;
failed1: LLDEBUG_LEAVE("UTF8StringType", 0);
return 0;
}

int ll_NullType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NullType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_NULL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = Builtin_Type_Null;
	
}}
LLDEBUG_LEAVE("NullType", 1);
return 1;
failed1: LLDEBUG_LEAVE("NullType", 0);
return 0;
}

int ll_SequenceType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SequenceType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SequenceType", 1);
{LLSTATE llstate_1;
if (!llterm(T_SEQUENCE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XComponents llatt_3;
if (!ll_ExtendedComponentTypeList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{Component_t *c, *d; int fExtended = 0;
	    for (c = llatt_3; c; c = c->Next)
		if (c->Type == eComponent_Optional || c->Type == eComponent_Default || fExtended)
		    KeepOptNames(c->U.NOD.NamedType->Identifier); // global conflict check
		else
		if (c->Type == eComponent_ExtensionMarker)
		    fExtended = 1;
	    for (c = llatt_3; c && c->Next; c = c->Next) {
		if (c->Type != eComponent_Normal &&
		    c->Type != eComponent_Optional &&
		    c->Type != eComponent_Default)
		    continue;
		for (d = c->Next; d; d = d->Next) {
		    if (d->Type != eComponent_Normal &&
			d->Type != eComponent_Optional &&
			d->Type != eComponent_Default)
			continue;
		    if (!strcmp(c->U.NOD.NamedType->Identifier,
			d->U.NOD.NamedType->Identifier))
			LLFAILED((&llstate_3.pos, "Component `%s' has been used twice",
			    c->U.NOD.NamedType->Identifier));
		}
	    }
	    (*llret) = NewType(eType_Sequence);
	    (*llret)->TagDefault = (*llout).TagDefault;
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.Sequence.Components = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SequenceType", 2);
{LLSTATE llstate_1;
if (!llterm(T_SEQUENCE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = NewType(eType_Sequence);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SequenceType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SequenceType", 1);
return 1;
failed1: LLDEBUG_LEAVE("SequenceType", 0);
return 0;
}

int ll_ExtensionAndException(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExtensionAndException");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ExtensionAndException", 1);
{LLSTATE llstate_1;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_ExceptionSpec(&llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewComponent(eComponent_ExtensionMarker);
	    /*(*llret)->U.ExtensionMarker.ExceptionSpec = llatt_2;*/
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ExtensionAndException", 2);
{LLSTATE llstate_1;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewComponent(eComponent_ExtensionMarker);
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ExtensionAndException");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ExtensionAndException", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExtensionAndException", 0);
return 0;
}

int ll_ExtendedComponentTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExtendedComponentTypeList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ExtendedComponentTypeList", 1);
{LLSTATE llstate_1;XComponents llatt_1;
if (!ll_ComponentTypeList(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_ComponentTypeListExtension(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{Component_t **cc, *c;
	    if (llatt_2) {
		cc = &(*llret);
		for (c = llatt_1; c; c = c->Next) {
		    *cc = DupComponent(c);
		    cc = &(*cc)->Next;
		}
		*cc = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ExtendedComponentTypeList", 2);
{LLSTATE llstate_1;XComponents llatt_1;
if (!ll_ExtensionAndException(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_AdditionalComponentTypeList(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{Component_t **cc, *c;
	    if (llatt_2) {
		cc = &(*llret);
		for (c = llatt_1; c; c = c->Next) {
		    *cc = DupComponent(c);
		    cc = &(*cc)->Next;
		}
		*cc = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ExtendedComponentTypeList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ExtendedComponentTypeList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExtendedComponentTypeList", 0);
return 0;
}

int ll_ComponentTypeListExtension(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentTypeListExtension");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ComponentTypeListExtension", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_ExtensionAndException(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XComponents llatt_3;
if (!ll_AdditionalComponentTypeList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{Component_t **cc, *c;
	    if (llatt_3) {
		cc = &(*llret);
		for (c = llatt_2; c; c = c->Next) {
		    *cc = DupComponent(c);
		    cc = &(*cc)->Next;
		}
		*cc = llatt_3;
	    } else {
		(*llret) = llatt_2;
	    }
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ComponentTypeListExtension", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ComponentTypeListExtension");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ComponentTypeListExtension", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentTypeListExtension", 0);
return 0;
}

int ll_AdditionalComponentTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AdditionalComponentTypeList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("AdditionalComponentTypeList", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_ComponentTypeList(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("AdditionalComponentTypeList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("AdditionalComponentTypeList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("AdditionalComponentTypeList", 1);
return 1;
failed1: LLDEBUG_LEAVE("AdditionalComponentTypeList", 0);
return 0;
}

int ll_ComponentTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentTypeList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XComponents llatt_1;
if (!ll_ComponentType(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_AdditionalComponentTypeList(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupComponent(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("ComponentTypeList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentTypeList", 0);
return 0;
}

int ll_ComponentType(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ComponentType", 1);
{LLSTATE llstate_1;XNamedType llatt_1;
if (!ll_NamedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_ComponentTypePostfix(&llatt_2, &llstate_1, &llstate_2, llatt_1->Type)) goto failed2;
*llout = llstate_2;
{(*llret) = DupComponent(llatt_2);
	    (*llret)->U.NOD.NamedType = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ComponentType", 2);
{LLSTATE llstate_1;
if (!llterm(T_COMPONENTS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XType llatt_3;
if (!ll_Type(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = NewComponent(eComponent_ComponentsOf);
	    (*llret)->U.ComponentsOf.Type = llatt_3;
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ComponentType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ComponentType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentType", 0);
return 0;
}

int ll_ComponentTypePostfix(XComponents *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentTypePostfix");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ComponentTypePostfix", 1);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewComponent(eComponent_Optional);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ComponentTypePostfix", 2);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_Value(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{(*llret) = NewComponent(eComponent_Default);
	    (*llret)->U.Default.Value = llatt_2;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ComponentTypePostfix", 3);
*llout = llstate_0;
{(*llret) = NewComponent(eComponent_Normal);
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ComponentTypePostfix");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ComponentTypePostfix", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentTypePostfix", 0);
return 0;
}

int ll_SequenceOfType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SequenceOfType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_SEQUENCE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
{LLSTATE llstate_5;XType llatt_5;
if (!ll_Type(&llatt_5, &llstate_4, &llstate_5)) goto failed1;
*llout = llstate_5;
{(*llret) = NewType(eType_SequenceOf);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.SequenceOf.Type = llatt_5;
	    (*llret)->U.SequenceOf.Directives = llatt_2;
	    if (llatt_3)
	    {
	        PropagatePrivateDirectives((*llret), llatt_3);
	    }
	    if ((*llret)->PrivateDirectives.pszTypeName &&
		strncmp("PSetOf", (*llret)->PrivateDirectives.pszTypeName, 6) == 0)
	    {
		(*llret)->PrivateDirectives.pszTypeName++;
	    }
	
}}}}}}
LLDEBUG_LEAVE("SequenceOfType", 1);
return 1;
failed1: LLDEBUG_LEAVE("SequenceOfType", 0);
return 0;
}

int ll_SetType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SetType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SetType", 1);
{LLSTATE llstate_1;
if (!llterm(T_SET, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XComponents llatt_3;
if (!ll_ExtendedComponentTypeList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{Component_t *c, *d;
	    for (c = llatt_3; c && c->Next; c = c->Next) {
		if (c->Type != eComponent_Normal &&
		    c->Type != eComponent_Optional &&
		    c->Type != eComponent_Default)
		    continue;
		for (d = c->Next; d; d = d->Next) {
		    if (d->Type != eComponent_Normal &&
			d->Type != eComponent_Optional &&
			d->Type != eComponent_Default)
			continue;
		    if (!strcmp(c->U.NOD.NamedType->Identifier,
			d->U.NOD.NamedType->Identifier))
			LLFAILED((&llstate_3.pos, "Component `%s' has been used twice",
			    c->U.NOD.NamedType->Identifier));
		}
	    }
	    (*llret) = NewType(eType_Set);
	    (*llret)->TagDefault = (*llout).TagDefault;
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.Set.Components = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SetType", 2);
{LLSTATE llstate_1;
if (!llterm(T_SET, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = NewType(eType_Set);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SetType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SetType", 1);
return 1;
failed1: LLDEBUG_LEAVE("SetType", 0);
return 0;
}

int ll_SetOfType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SetOfType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_SET, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
{LLSTATE llstate_5;XType llatt_5;
if (!ll_Type(&llatt_5, &llstate_4, &llstate_5)) goto failed1;
*llout = llstate_5;
{(*llret) = NewType(eType_SetOf);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.SetOf.Type = llatt_5;
	    (*llret)->U.SetOf.Directives = llatt_2;
	    if (llatt_3)
	    {
	    	PropagatePrivateDirectives((*llret), llatt_3);
	    }
	    if ((*llret)->PrivateDirectives.pszTypeName &&
		strncmp("PSetOf", (*llret)->PrivateDirectives.pszTypeName, 6) == 0)
	    {
		(*llret)->PrivateDirectives.pszTypeName++;
	    }
	
}}}}}}
LLDEBUG_LEAVE("SetOfType", 1);
return 1;
failed1: LLDEBUG_LEAVE("SetOfType", 0);
return 0;
}

int ll_ChoiceType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ChoiceType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_CHOICE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XComponents llatt_3;
if (!ll_ExtendedAlternativeTypeList(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{Component_t *c, *d;
	    for (c = llatt_3; c; c = c->Next)
		if (c->Type == eComponent_Normal ||
		    c->Type == eComponent_Optional ||
		    c->Type == eComponent_Default)
		    KeepChoiceNames(c->U.NOD.NamedType->Identifier); // global conflict check
	    for (c = llatt_3; c && c->Next; c = c->Next) {
		if (c->Type != eComponent_Normal &&
		    c->Type != eComponent_Optional &&
		    c->Type != eComponent_Default)
		    continue;
		for (d = c->Next; d; d = d->Next) {
		    if (d->Type != eComponent_Normal &&
			d->Type != eComponent_Optional &&
			d->Type != eComponent_Default)
			continue;
		    if (!strcmp(c->U.NOD.NamedType->Identifier,
			d->U.NOD.NamedType->Identifier))
			LLFAILED((&llstate_3.pos, "Component `%s' has been used twice",
			    c->U.NOD.NamedType->Identifier));
		}
	    }
	    (*llret) = NewType(eType_Choice);
	    (*llret)->TagDefault = (*llout).TagDefault;
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.Choice.Components = llatt_3;
	
}}}}}
LLDEBUG_LEAVE("ChoiceType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ChoiceType", 0);
return 0;
}

int ll_ExtendedAlternativeTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExtendedAlternativeTypeList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XComponents llatt_1;
if (!ll_AlternativeTypeList(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_AlternativeTypeListExtension(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{Component_t **cc, *c;
	    if (llatt_2) {
		cc = &(*llret);
		for (c = llatt_1; c; c = c->Next) {
		    *cc = DupComponent(c);
		    cc = &(*cc)->Next;
		}
		*cc = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("ExtendedAlternativeTypeList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExtendedAlternativeTypeList", 0);
return 0;
}

int ll_AlternativeTypeListExtension(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AlternativeTypeListExtension");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("AlternativeTypeListExtension", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_ExtensionAndException(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XComponents llatt_3;
if (!ll_AdditionalAlternativeTypeList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{Component_t **cc, *c;
	    if (llatt_3) {
		cc = &(*llret);
		for (c = llatt_2; c; c = c->Next) {
		    *cc = DupComponent(c);
		    cc = &(*cc)->Next;
		}
		*cc = llatt_3;
	    } else {
		(*llret) = llatt_2;
	    }
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("AlternativeTypeListExtension", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("AlternativeTypeListExtension");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("AlternativeTypeListExtension", 1);
return 1;
failed1: LLDEBUG_LEAVE("AlternativeTypeListExtension", 0);
return 0;
}

int ll_AdditionalAlternativeTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AdditionalAlternativeTypeList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("AdditionalAlternativeTypeList", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_AlternativeTypeList(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("AdditionalAlternativeTypeList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("AdditionalAlternativeTypeList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("AdditionalAlternativeTypeList", 1);
return 1;
failed1: LLDEBUG_LEAVE("AdditionalAlternativeTypeList", 0);
return 0;
}

int ll_AlternativeTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AlternativeTypeList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XNamedType llatt_1;
if (!ll_NamedType(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_AdditionalAlternativeTypeList(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = NewComponent(eComponent_Normal);
	    (*llret)->U.Normal.NamedType = llatt_1;
	    (*llret)->Next = llatt_2;
	
}}}
LLDEBUG_LEAVE("AlternativeTypeList", 1);
return 1;
failed1: LLDEBUG_LEAVE("AlternativeTypeList", 0);
return 0;
}

int ll_AnyType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AnyType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("AnyType", 1);
{LLSTATE llstate_1;
if (!llterm(T_ANY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_Open;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("AnyType", 2);
{LLSTATE llstate_1;
if (!llterm(T_ANY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_DEFINED, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(T_BY, (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XString llatt_4;
if (!ll_identifier(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{(*llret) = Builtin_Type_Open;
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("AnyType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("AnyType", 1);
return 1;
failed1: LLDEBUG_LEAVE("AnyType", 0);
return 0;
}

int ll_SelectionType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SelectionType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('<', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XType llatt_3;
if (!ll_Type(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = NewType(eType_Selection);
	    (*llret)->U.Selection.Identifier = llatt_1;
	    (*llret)->U.Selection.Type = llatt_3;
	
}}}}
LLDEBUG_LEAVE("SelectionType", 1);
return 1;
failed1: LLDEBUG_LEAVE("SelectionType", 0);
return 0;
}

int ll_TaggedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TaggedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XTags llatt_1;
if (!ll_Tag(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XTagType llatt_2;
if (!ll_TagType(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XType llatt_3;
if (!ll_Type(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Tag_t *t;
	    Type_e eType = GetTypeType((*llout).Assignments, llatt_3);
	    if (eType == eType_Choice || eType == eType_Open)
	    {
	    	if (llatt_2 == eTagType_Unknown &&
	    	    ((*llout).TagDefault == eTagType_Implicit || (*llout).TagDefault == eTagType_Automatic))
	    	{
	    	    llatt_2 = eTagType_Explicit;
	    	}
	    	else
	    	if (llatt_2 == eTagType_Implicit)
	    	{
		    for (t = llatt_3->Tags; t; t = t->Next) {
		        if (t->Type == eTagType_Explicit)
			    break;
		    }
		    if (!t)
		        LLFAILED((&llstate_3.pos, "Bad tag type for choice/open type"));
	        }
	    }
	    (*llret) = DupType(llatt_3);
	    (*llret)->Tags = DupTag(llatt_1);
	    (*llret)->Tags->Type = llatt_2;
	    (*llret)->Tags->Next = llatt_3->Tags;
	
}}}}
LLDEBUG_LEAVE("TaggedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("TaggedType", 0);
return 0;
}

int ll_TagType(XTagType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TagType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TagType", 1);
*llout = llstate_0;
{(*llret) = eTagType_Unknown;
	
break;
}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TagType", 2);
{LLSTATE llstate_1;
if (!llterm(T_IMPLICIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = eTagType_Implicit;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("TagType", 3);
{LLSTATE llstate_1;
if (!llterm(T_EXPLICIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = eTagType_Explicit;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TagType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TagType", 1);
return 1;
failed1: LLDEBUG_LEAVE("TagType", 0);
return 0;
}

int ll_Tag(XTags *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Tag");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('[', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XTagClass llatt_2;
if (!ll_Class(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_ClassNumber(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm(']', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{(*llret) = NewTag(eTagType_Unknown);
	    (*llret)->Class = llatt_2;
	    (*llret)->Tag = llatt_3;
	
}}}}}
LLDEBUG_LEAVE("Tag", 1);
return 1;
failed1: LLDEBUG_LEAVE("Tag", 0);
return 0;
}

int ll_ClassNumber(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ClassNumber");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ClassNumber", 1);
{LLSTATE llstate_1;XNumber llatt_1;
if (!llterm(T_number, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XNumber;
*llout = llstate_1;
{if (intx_cmp(&llatt_1, &intx_1G) >= 0)
		LLFAILED((&llstate_1.pos, "Bad tag value"));
	    (*llret) = NewValue(NULL, Builtin_Type_Integer);
	    (*llret)->U.Integer.Value = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ClassNumber", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_DefinedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{Value_t *v;
	    v = GetValue((*llout).Assignments, llatt_1);
	    if (v &&
		GetTypeType((*llout).Assignments, v->Type) != eType_Integer &&
		GetTypeType((*llout).Assignments, v->Type) != eType_Undefined)
		LLFAILED((&llstate_1.pos, "Bad type of tag value"));
	    if (v &&
		GetTypeType((*llout).Assignments, v->Type) == eType_Integer &&
		(intx_cmp(&v->U.Integer.Value, &intx_0) < 0 ||
		intx_cmp(&v->U.Integer.Value, &intx_1G) >= 0))
		LLFAILED((&llstate_1.pos, "Bad tag value"));
	    (*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ClassNumber");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ClassNumber", 1);
return 1;
failed1: LLDEBUG_LEAVE("ClassNumber", 0);
return 0;
}

int ll_Class(XTagClass *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Class");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Class", 1);
{LLSTATE llstate_1;
if (!llterm(T_UNIVERSAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = eTagClass_Universal;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Class", 2);
{LLSTATE llstate_1;
if (!llterm(T_APPLICATION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = eTagClass_Application;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("Class", 3);
{LLSTATE llstate_1;
if (!llterm(T_PRIVATE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = eTagClass_Private;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("Class", 4);
*llout = llstate_0;
{(*llret) = eTagClass_Unknown;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Class");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Class", 1);
return 1;
failed1: LLDEBUG_LEAVE("Class", 0);
return 0;
}

int ll_ObjectIdentifierType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectIdentifierType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_OBJECT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_IDENTIFIER, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = Builtin_Type_ObjectIdentifier;
	
}}}
LLDEBUG_LEAVE("ObjectIdentifierType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectIdentifierType", 0);
return 0;
}

int ll_EmbeddedPDVType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("EmbeddedPDVType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_EMBEDDED, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_PDV, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = Builtin_Type_EmbeddedPdv;
	
}}}
LLDEBUG_LEAVE("EmbeddedPDVType", 1);
return 1;
failed1: LLDEBUG_LEAVE("EmbeddedPDVType", 0);
return 0;
}

int ll_ExternalType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExternalType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_EXTERNAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = Builtin_Type_External;
	
}}
LLDEBUG_LEAVE("ExternalType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExternalType", 0);
return 0;
}

int ll_CharacterStringType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("CharacterStringType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("CharacterStringType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_RestrictedCharacterStringType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("CharacterStringType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_UnrestrictedCharacterStringType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("CharacterStringType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("CharacterStringType", 1);
return 1;
failed1: LLDEBUG_LEAVE("CharacterStringType", 0);
return 0;
}

int ll_RestrictedCharacterStringType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("RestrictedCharacterStringType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 1);
{LLSTATE llstate_1;
if (!llterm(T_BMPString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_BMPString;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 2);
{LLSTATE llstate_1;
if (!llterm(T_GeneralString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_GeneralString;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 3);
{LLSTATE llstate_1;
if (!llterm(T_GraphicString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_GraphicString;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 4);
{LLSTATE llstate_1;
if (!llterm(T_IA5String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_IA5String;
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 5);
{LLSTATE llstate_1;
if (!llterm(T_ISO646String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_ISO646String;
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 6);
{LLSTATE llstate_1;
if (!llterm(T_NumericString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_NumericString;
	
break;
}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 7);
{LLSTATE llstate_1;
if (!llterm(T_PrintableString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_PrintableString;
	
break;
}}
case 8: case -8:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 8);
{LLSTATE llstate_1;
if (!llterm(T_TeletexString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_TeletexString;
	
break;
}}
case 9: case -9:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 9);
{LLSTATE llstate_1;
if (!llterm(T_T61String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_T61String;
	
break;
}}
case 10: case -10:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 10);
{LLSTATE llstate_1;
if (!llterm(T_UniversalString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_UniversalString;
	
break;
}}
case 11: case -11:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 11);
{LLSTATE llstate_1;
if (!llterm(T_VideotexString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_VideotexString;
	
break;
}}
case 12: case -12:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 12);
{LLSTATE llstate_1;
if (!llterm(T_VisibleString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_VisibleString;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("RestrictedCharacterStringType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("RestrictedCharacterStringType", 1);
return 1;
failed1: LLDEBUG_LEAVE("RestrictedCharacterStringType", 0);
return 0;
}

int ll_UnrestrictedCharacterStringType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UnrestrictedCharacterStringType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_CHARACTER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_STRING, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = Builtin_Type_CharacterString;
	
}}}
LLDEBUG_LEAVE("UnrestrictedCharacterStringType", 1);
return 1;
failed1: LLDEBUG_LEAVE("UnrestrictedCharacterStringType", 0);
return 0;
}

int ll_UsefulType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UsefulType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UsefulType", 1);
{LLSTATE llstate_1;
if (!llterm(T_GeneralizedTime, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_GeneralizedTime;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UsefulType", 2);
{LLSTATE llstate_1;
if (!llterm(T_UTCTime, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_UTCTime;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("UsefulType", 3);
{LLSTATE llstate_1;
if (!llterm(T_ObjectDescriptor, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_ObjectDescriptor;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UsefulType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UsefulType", 1);
return 1;
failed1: LLDEBUG_LEAVE("UsefulType", 0);
return 0;
}

int ll_TypeWithConstraint(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeWithConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TypeWithConstraint", 1);
{LLSTATE llstate_1;
if (!llterm(T_SET, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XConstraints llatt_4;
if (!ll_Constraint(&llatt_4, &llstate_3, &llstate_4, NULL, 0)) goto failed2;
{LLSTATE llstate_5;XDirectives llatt_5;
if (!ll_LocalSizeDirectiveESeq(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_5, &llstate_6)) goto failed2;
{LLSTATE llstate_7;XType llatt_7;
if (!ll_Type(&llatt_7, &llstate_6, &llstate_7)) goto failed2;
*llout = llstate_7;
{Directive_t **dd, *d;
	    (*llret) = NewType(eType_SetOf);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->Constraints = llatt_4;
	    (*llret)->U.SetOf.Type = llatt_7;
	    if (llatt_3)
	    {
	    	PropagatePrivateDirectives((*llret), llatt_3);
	    }
	    dd = &(*llret)->U.SetOf.Directives;
	    for (d = llatt_2; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    for (d = llatt_5; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    *dd = NULL;
	    if ((*llret)->PrivateDirectives.pszTypeName &&
		strncmp("PSetOf", (*llret)->PrivateDirectives.pszTypeName, 6) == 0)
	    {
		(*llret)->PrivateDirectives.pszTypeName++;
	    }
	
break;
}}}}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TypeWithConstraint", 2);
{LLSTATE llstate_1;
if (!llterm(T_SET, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XSubtypeElement llatt_4;
if (!ll_SizeConstraint(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
{LLSTATE llstate_5;XDirectives llatt_5;
if (!ll_LocalSizeDirectiveESeq(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;XPrivateDirectives llatt_6;
if (!ll_PrivateDirectives(&llatt_6, &llstate_5, &llstate_6)) goto failed2;
{LLSTATE llstate_7;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_6, &llstate_7)) goto failed2;
{LLSTATE llstate_8;XType llatt_8;
if (!ll_Type(&llatt_8, &llstate_7, &llstate_8)) goto failed2;
*llout = llstate_8;
{Directive_t **dd, *d;
	    (*llret) = NewType(eType_SetOf);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->Constraints = NewConstraint();
	    (*llret)->Constraints->Type = eExtension_Unextended;
	    (*llret)->Constraints->Root = NewElementSetSpec(
		eElementSetSpec_SubtypeElement);
	    (*llret)->Constraints->Root->U.SubtypeElement.SubtypeElement = llatt_4;
	    (*llret)->U.SetOf.Type = llatt_8;
	    if (llatt_3)
	    {
	    	PropagatePrivateDirectives((*llret), llatt_3);
	    }
	    if (llatt_6)
	    {
	    	PropagatePrivateDirectives((*llret), llatt_6);
	    }
	    dd = &(*llret)->U.SetOf.Directives;
	    for (d = llatt_2; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    for (d = llatt_5; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    *dd = NULL;
	    if ((*llret)->PrivateDirectives.pszTypeName &&
		strncmp("PSetOf", (*llret)->PrivateDirectives.pszTypeName, 6) == 0)
	    {
		(*llret)->PrivateDirectives.pszTypeName++;
	    }
	
break;
}}}}}}}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("TypeWithConstraint", 3);
{LLSTATE llstate_1;
if (!llterm(T_SEQUENCE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XConstraints llatt_4;
if (!ll_Constraint(&llatt_4, &llstate_3, &llstate_4, NULL, 0)) goto failed2;
{LLSTATE llstate_5;XDirectives llatt_5;
if (!ll_LocalSizeDirectiveESeq(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_5, &llstate_6)) goto failed2;
{LLSTATE llstate_7;XType llatt_7;
if (!ll_Type(&llatt_7, &llstate_6, &llstate_7)) goto failed2;
*llout = llstate_7;
{Directive_t **dd, *d;
	    (*llret) = NewType(eType_SequenceOf);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->Constraints = llatt_4;
	    (*llret)->U.SequenceOf.Type = llatt_7;
	    if (llatt_3)
	    {
		PropagatePrivateDirectives((*llret), llatt_3);
	    }
	    dd = &(*llret)->U.SequenceOf.Directives;
	    for (d = llatt_2; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    for (d = llatt_5; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    *dd = NULL;
	    if ((*llret)->PrivateDirectives.pszTypeName &&
		strncmp("PSetOf", (*llret)->PrivateDirectives.pszTypeName, 6) == 0)
	    {
		(*llret)->PrivateDirectives.pszTypeName++;
	    }
	
break;
}}}}}}}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("TypeWithConstraint", 4);
{LLSTATE llstate_1;
if (!llterm(T_SEQUENCE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XSubtypeElement llatt_4;
if (!ll_SizeConstraint(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
{LLSTATE llstate_5;XDirectives llatt_5;
if (!ll_LocalSizeDirectiveESeq(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;XPrivateDirectives llatt_6;
if (!ll_PrivateDirectives(&llatt_6, &llstate_5, &llstate_6)) goto failed2;
{LLSTATE llstate_7;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_6, &llstate_7)) goto failed2;
{LLSTATE llstate_8;XType llatt_8;
if (!ll_Type(&llatt_8, &llstate_7, &llstate_8)) goto failed2;
*llout = llstate_8;
{Directive_t **dd, *d;
	    (*llret) = NewType(eType_SequenceOf);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->Constraints = NewConstraint();
	    (*llret)->Constraints->Type = eExtension_Unextended;
	    (*llret)->Constraints->Root = NewElementSetSpec(
		eElementSetSpec_SubtypeElement);
	    (*llret)->Constraints->Root->U.SubtypeElement.SubtypeElement = llatt_4;
	    (*llret)->U.SequenceOf.Type = llatt_8;
	    if (llatt_3)
	    {
	    	PropagatePrivateDirectives((*llret), llatt_3);
	    }
	    if (llatt_6)
	    {
	    	PropagatePrivateDirectives((*llret), llatt_6);
	    }
	    dd = &(*llret)->U.SequenceOf.Directives;
	    for (d = llatt_2; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    for (d = llatt_5; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    *dd = NULL;
	    if ((*llret)->PrivateDirectives.pszTypeName &&
		strncmp("PSetOf", (*llret)->PrivateDirectives.pszTypeName, 6) == 0)
	    {
		(*llret)->PrivateDirectives.pszTypeName++;
	    }
	
break;
}}}}}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TypeWithConstraint");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TypeWithConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeWithConstraint", 0);
return 0;
}

int ll_DefinedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_Externalvaluereference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedValue", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_valuereference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("DefinedValue", 3);
{LLSTATE llstate_1;
if (!ll_ParameterizedValue(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedValue", 0);
return 0;
}

int ll_ValueAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_valuereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XValue llatt_4;
if (!ll_Value(&llatt_4, &llstate_3, &llstate_4, llatt_2)) goto failed1;
*llout = llstate_4;
{if (!AssignValue(&(*llout).Assignments, llatt_1, llatt_4))
		LLFAILED((&llstate_1.pos, "Value `%s' twice defined",
		    llatt_1->U.Reference.Identifier));
	
}}}}}
LLDEBUG_LEAVE("ValueAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueAssignment", 0);
return 0;
}

int ll_Value(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Value");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Value", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_BuiltinValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Value", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ReferencedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("Value", 3);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ObjectClassFieldValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Value");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Value", 1);
return 1;
failed1: LLDEBUG_LEAVE("Value", 0);
return 0;
}

int ll_BuiltinValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("BuiltinValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("BuiltinValue", 1);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_BitString)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_BitStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("BuiltinValue", 2);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Boolean)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_BooleanValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("BuiltinValue", 3);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_CharacterStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("BuiltinValue", 4);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Choice)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ChoiceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("BuiltinValue", 5);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_EmbeddedPdv)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_EmbeddedPDVValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("BuiltinValue", 6);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Enumerated)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_EnumeratedValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("BuiltinValue", 7);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_External)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ExternalValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 8: case -8:
LLDEBUG_ALTERNATIVE("BuiltinValue", 8);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_InstanceOf)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_InstanceOfValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 9: case -9:
LLDEBUG_ALTERNATIVE("BuiltinValue", 9);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Integer)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_IntegerValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 10: case -10:
LLDEBUG_ALTERNATIVE("BuiltinValue", 10);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Null)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_NullValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 11: case -11:
LLDEBUG_ALTERNATIVE("BuiltinValue", 11);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_ObjectIdentifier)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ObjectIdentifierValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
		if (llatt_1->Type != NULL)
		{
			PropagatePrivateDirectives(llatt_1->Type, &(llarg_type->PrivateDirectives));
		}
	
break;
}}}
case 12: case -12:
LLDEBUG_ALTERNATIVE("BuiltinValue", 12);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_OctetString)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_OctetStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 13: case -13:
LLDEBUG_ALTERNATIVE("BuiltinValue", 13);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Real)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_RealValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 14: case -14:
LLDEBUG_ALTERNATIVE("BuiltinValue", 14);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) !=
		eType_GeneralizedTime)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_GeneralizedTimeValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 15: case -15:
LLDEBUG_ALTERNATIVE("BuiltinValue", 15);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_UTCTime)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_UTCTimeValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 16: case -16:
LLDEBUG_ALTERNATIVE("BuiltinValue", 16);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_ObjectDescriptor)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ObjectDescriptorValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 17: case -17:
LLDEBUG_ALTERNATIVE("BuiltinValue", 17);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Sequence)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 18: case -18:
LLDEBUG_ALTERNATIVE("BuiltinValue", 18);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_SequenceOf)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceOfValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 19: case -19:
LLDEBUG_ALTERNATIVE("BuiltinValue", 19);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Set)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SetValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 20: case -20:
LLDEBUG_ALTERNATIVE("BuiltinValue", 20);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_SetOf)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SetOfValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 21: case -21:
LLDEBUG_ALTERNATIVE("BuiltinValue", 21);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Open)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_AnyValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 22: case -22:
LLDEBUG_ALTERNATIVE("BuiltinValue", 22);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Macro)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_MacroDefinedValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("BuiltinValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("BuiltinValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("BuiltinValue", 0);
return 0;
}

int ll_ReferencedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ReferencedValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ReferencedValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_DefinedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ReferencedValue", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ValueFromObject(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ReferencedValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ReferencedValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ReferencedValue", 0);
return 0;
}

int ll_NamedValue(XNamedValues *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{Component_t *component;
	    Type_t *type;
	    component = FindComponent((*llin).Assignments, llarg_components, llatt_1);
	    if (component)
		type = component->U.NOD.NamedType->Type;
	    else
		type = NULL;
	
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_Value(&llatt_2, &llstate_1, &llstate_2, type)) goto failed1;
*llout = llstate_2;
{(*llret) = NewNamedValue(llatt_1, llatt_2);
	
}}}}
LLDEBUG_LEAVE("NamedValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedValue", 0);
return 0;
}

int ll_BooleanValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("BooleanValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("BooleanValue", 1);
{LLSTATE llstate_1;
if (!llterm(T_TRUE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.Boolean.Value = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("BooleanValue", 2);
{LLSTATE llstate_1;
if (!llterm(T_FALSE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.Boolean.Value = 0;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("BooleanValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("BooleanValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("BooleanValue", 0);
return 0;
}

int ll_SignedNumber(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SignedNumber");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SignedNumber", 1);
{LLSTATE llstate_1;XNumber llatt_1;
if (!llterm(T_number, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XNumber;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.Integer.Value = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SignedNumber", 2);
{LLSTATE llstate_1;
if (!llterm('-', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XNumber llatt_2;
if (!llterm(T_number, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._XNumber;
*llout = llstate_2;
{if (!intx_cmp(&llatt_2, &intx_0))
		LLFAILED((&llstate_2.pos, "Bad negative value"));
	    (*llret) = NewValue((*llout).Assignments, llarg_type);
	    intx_neg(&(*llret)->U.Integer.Value, &llatt_2);
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SignedNumber");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SignedNumber", 1);
return 1;
failed1: LLDEBUG_LEAVE("SignedNumber", 0);
return 0;
}

int ll_IntegerValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IntegerValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("IntegerValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SignedNumber(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("IntegerValue", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{NamedNumber_t *n;
	    Type_t *type;
	    type = GetType((*llout).Assignments, llarg_type);
	    if (type) {
		n = FindNamedNumber(type->U.Integer.NamedNumbers, llatt_1);
		if (!n)
		    LLFAILED((&llstate_1.pos, "Undefined integer value"));
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		intx_dup(&(*llret)->U.Integer.Value,
		    &n->U.Normal.Value->U.Integer.Value);
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("IntegerValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("IntegerValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("IntegerValue", 0);
return 0;
}

int ll_EnumeratedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("EnumeratedValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{NamedNumber_t *n;
	    Type_t *type;
	    type = GetType((*llout).Assignments, llarg_type);
	    if (type) {
		n = FindNamedNumber(type->U.Enumerated.NamedNumbers, llatt_1);
		if (!n)
		    LLFAILED((&llstate_1.pos, "Undefined enumeration value"));
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		(*llret)->U.Enumerated.Value =
		    intx2uint32(&n->U.Normal.Value->U.Integer.Value);
	    } else {
		(*llret) = NULL;
	    }
	
}}
LLDEBUG_LEAVE("EnumeratedValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("EnumeratedValue", 0);
return 0;
}

int ll_RealValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("RealValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("RealValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_NumericRealValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("RealValue", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SpecialRealValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("RealValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("RealValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("RealValue", 0);
return 0;
}

int ll_NumericRealValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NumericRealValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NumericRealValue", 1);
{LLSTATE llstate_1;XNumber llatt_1;
if (!llterm(T_number, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XNumber;
*llout = llstate_1;
{if (intx_cmp(&llatt_1, &intx_0))
		LLFAILED((&llstate_1.pos, "Bad real value"));
	    (*llret) = NewValue((*llout).Assignments, llarg_type);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NumericRealValue", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{NamedValue_t *mant, *expo, *base;
	    mant = FindNamedValue(llatt_1->U.Sequence.NamedValues, "mantissa");
	    expo = FindNamedValue(llatt_1->U.Sequence.NamedValues, "exponent");
	    base = FindNamedValue(llatt_1->U.Sequence.NamedValues, "base");
	    if (!mant || !expo || !base) {
		(*llret) = NULL;
	    } else {
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		intx_dup(&(*llret)->U.Real.Value.mantissa,
		    &mant->Value->U.Integer.Value);
		intx_dup(&(*llret)->U.Real.Value.exponent,
		    &expo->Value->U.Integer.Value);
		(*llret)->U.Real.Value.base =
		    intx2uint32(&base->Value->U.Integer.Value);
	    }
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NumericRealValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NumericRealValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("NumericRealValue", 0);
return 0;
}

int ll_SpecialRealValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SpecialRealValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SpecialRealValue", 1);
{LLSTATE llstate_1;
if (!llterm(T_PLUS_INFINITY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.Real.Value.type = eReal_PlusInfinity;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SpecialRealValue", 2);
{LLSTATE llstate_1;
if (!llterm(T_MINUS_INFINITY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.Real.Value.type = eReal_MinusInfinity;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SpecialRealValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SpecialRealValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("SpecialRealValue", 0);
return 0;
}

int ll_BitStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("BitStringValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("BitStringValue", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_bstring, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{int i, len;
	    if (GetTypeType((*llout).Assignments, llarg_type) == eType_BitString) {
		len = strlen(llatt_1);
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		(*llret)->U.BitString.Value.length = len;
		(*llret)->U.BitString.Value.value =
		    (octet_t *)malloc((len + 7) / 8);
		memset((*llret)->U.BitString.Value.value, 0, (len + 7) / 8);
		for (i = 0; i < len; i++) {
		    if (llatt_1[i] == '1')
			ASN1BITSET((*llret)->U.BitString.Value.value, i);
		}
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("BitStringValue", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_hstring, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{int i, len, c;
	    if (GetTypeType((*llout).Assignments, llarg_type) == eType_BitString) {
		len = strlen(llatt_1);
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		(*llret)->U.BitString.Value.length = len * 4;
		(*llret)->U.BitString.Value.value =
		    (octet_t *)malloc((len + 1) / 2);
		memset((*llret)->U.BitString.Value.value, 0, (len + 1) / 2);
		for (i = 0; i < len; i++) {
		    c = isdigit(llatt_1[i]) ? llatt_1[i] - '0' : llatt_1[i] - 'A' + 10;
		    (*llret)->U.BitString.Value.value[i / 2] |=
			(i & 1) ? c : (c << 4);
		}
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("BitStringValue", 3);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_IdentifierList(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_2;
	
break;
}}}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("BitStringValue", 4);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('}', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("BitStringValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("BitStringValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("BitStringValue", 0);
return 0;
}

int ll_IdentifierList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IdentifierList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_IdentifierList_Elem(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_Identifier_EList(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed1;
*llout = llstate_2;
{uint32_t bit, len;
	    bitstring_t *src, *dst;
	    if (llatt_1 && llatt_2) {
		bit = intx2uint32(&llatt_1->U.Integer.Value);
		src = &llatt_2->U.BitString.Value;
		len = bit + 1;
		if (len < src->length)
		    len = src->length;
		(*llret) = DupValue(llatt_2);
		dst = &(*llret)->U.BitString.Value;
		dst->length = len;
		dst->value = (octet_t *)malloc((len + 7) / 8);
		memcpy(dst->value, src->value, (src->length + 7) / 8);
		memset(dst->value + (src->length + 7) / 8, 0,
		    (len + 7) / 8 - (src->length + 7) / 8);
		ASN1BITSET(dst->value, bit);
	    } else if (llatt_1) {
		bit = intx2uint32(&llatt_1->U.Integer.Value);
		len = bit + 1;
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		dst = &(*llret)->U.BitString.Value;
		dst->length = len;
		dst->value = (octet_t *)malloc((len + 7) / 8);
		memset(dst->value, 0, (len + 7) / 8);
		ASN1BITSET(dst->value, bit);
	    } else {
		(*llret) = NULL;
	    }
	
}}}
LLDEBUG_LEAVE("IdentifierList", 1);
return 1;
failed1: LLDEBUG_LEAVE("IdentifierList", 0);
return 0;
}

int ll_Identifier_EList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Identifier_EList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Identifier_EList", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_IdentifierList_Elem(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_Identifier_EList(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{uint32_t bit, len;
	    bitstring_t *src, *dst;
	    if (llatt_1 && llatt_2) {
		bit = intx2uint32(&llatt_1->U.Integer.Value);
		src = &llatt_2->U.BitString.Value;
		len = bit + 1;
		if (len < src->length)
		    len = src->length;
		(*llret) = DupValue(llatt_2);
		dst = &(*llret)->U.BitString.Value;
		dst->length = len;
		dst->value = (octet_t *)malloc((len + 7) / 8);
		memcpy(dst->value, src->value, (src->length + 7) / 8);
		memset(dst->value + (src->length + 7) / 8, 0,
		    (len + 7) / 8 - (src->length + 7) / 8);
		ASN1BITSET(dst->value, bit);
	    } else if (llatt_1) {
		bit = intx2uint32(&llatt_1->U.Integer.Value);
		len = bit + 1;
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		dst = &(*llret)->U.BitString.Value;
		dst->length = len;
		dst->value = (octet_t *)malloc((len + 7) / 8);
		memset(dst->value, 0, (len + 7) / 8);
		ASN1BITSET(dst->value, bit);
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Identifier_EList", 2);
*llout = llstate_0;
{if (llarg_type) {
		(*llret) = NewValue((*llout).Assignments, llarg_type);
	    } else {
		(*llret) = NULL;
	    }
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Identifier_EList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Identifier_EList", 1);
return 1;
failed1: LLDEBUG_LEAVE("Identifier_EList", 0);
return 0;
}

int ll_IdentifierList_Elem(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IdentifierList_Elem");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{Value_t *v;
	    NamedNumber_t *n;
	    Type_t *type;
	    type = GetType((*llout).Assignments, llarg_type);
	    if (type) {
		n = FindNamedNumber(type->U.BitString.NamedNumbers, llatt_1);
		if (!n)
		    LLFAILED((&llstate_1.pos, "Bad bit string value"));
		v = GetValue((*llout).Assignments, n->U.Normal.Value);
		if (v) {
		    if (GetTypeType((*llout).Assignments, v->Type) != eType_Integer)
			MyAbort();
		    (*llret) = v;
		} else {
		    (*llret) = NULL;
		}
	    } else {
		(*llret) = NULL;
	    }
	
}}
LLDEBUG_LEAVE("IdentifierList_Elem", 1);
return 1;
failed1: LLDEBUG_LEAVE("IdentifierList_Elem", 0);
return 0;
}

int ll_OctetStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("OctetStringValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("OctetStringValue", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_bstring, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{int len, i;
	    if (GetTypeType((*llout).Assignments, llarg_type) == eType_OctetString) {
		len = strlen(llatt_1);
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		(*llret)->U.OctetString.Value.length = (len + 7) / 8;
		(*llret)->U.OctetString.Value.value =
		    (octet_t *)malloc((len + 7) / 8);
		memset((*llret)->U.OctetString.Value.value, 0, (len + 7) / 8);
		for (i = 0; i < len; i++) {
		    if (llatt_1[i] == '1')
			ASN1BITSET((*llret)->U.OctetString.Value.value, i);
		}
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("OctetStringValue", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_hstring, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{int i, len, c;
	    if (GetTypeType((*llout).Assignments, llarg_type) == eType_OctetString) {
		len = strlen(llatt_1);
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		(*llret)->U.OctetString.Value.length = (len + 1) / 2;
		(*llret)->U.OctetString.Value.value =
		    (octet_t *)malloc((len + 1) / 2);
		memset((*llret)->U.OctetString.Value.value, 0, (len + 1) / 2);
		for (i = 0; i < len; i++) {
		    c = isdigit(llatt_1[i]) ?  llatt_1[i] - '0' : llatt_1[i] - 'A' + 10;
		    (*llret)->U.OctetString.Value.value[i / 2] |=
			(i & 1) ? c : (c << 4);
		}
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("OctetStringValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("OctetStringValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("OctetStringValue", 0);
return 0;
}

int ll_NullValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NullValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_NULL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	
}}
LLDEBUG_LEAVE("NullValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("NullValue", 0);
return 0;
}

int ll_GeneralizedTimeValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("GeneralizedTimeValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_RestrictedCharacterStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    if (!String2GeneralizedTime(&(*llret)->U.GeneralizedTime.Value,
		&llatt_1->U.RestrictedString.Value))
		LLFAILED((&llstate_1.pos, "Bad time value"));
	
}}
LLDEBUG_LEAVE("GeneralizedTimeValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("GeneralizedTimeValue", 0);
return 0;
}

int ll_UTCTimeValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UTCTimeValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_RestrictedCharacterStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    if (!String2UTCTime(&(*llret)->U.UTCTime.Value,
		&llatt_1->U.RestrictedString.Value))
		LLFAILED((&llstate_1.pos, "Bad time value"));
	
}}
LLDEBUG_LEAVE("UTCTimeValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("UTCTimeValue", 0);
return 0;
}

int ll_ObjectDescriptorValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectDescriptorValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_RestrictedCharacterStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("ObjectDescriptorValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectDescriptorValue", 0);
return 0;
}

int ll_SequenceValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SequenceValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SequenceValue", 1);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{Component_t *components;
	    Type_t *type;
	    type = GetType(llstate_1.Assignments, llarg_type);
	    components = type ? type->U.SSC.Components : NULL;
	
{LLSTATE llstate_2;XNamedValues llatt_2;
if (!ll_ComponentValueList(&llatt_2, &llstate_1, &llstate_2, components)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{Component_t *c;
	    NamedValue_t *v;
	    if (type) {
		for (c = components, v = llatt_2; c; c = c->Next) {
		    switch (c->Type) {
		    case eComponent_Normal:
			if (!v)
			    LLFAILED((&llstate_2.pos,
				"Value for component `%s' is missing",
				c->U.NOD.NamedType->Identifier));
			if (strcmp(v->Identifier,
			    c->U.NOD.NamedType->Identifier))
			    LLFAILED((&llstate_2.pos, "Value for component `%s' expected",
				c->U.NOD.NamedType->Identifier));
			v = v->Next;
			break;
		    case eComponent_Optional:
		    case eComponent_Default:
			if (v && !strcmp(v->Identifier,
			    c->U.NOD.NamedType->Identifier))
			    v = v->Next;
			break;
		    }
		}
		if (v)
		    LLFAILED((&llstate_2.pos, "Component `%s' is unexpected",
			v->Identifier));
	    }
	    (*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.SSC.NamedValues = llatt_2;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SequenceValue", 2);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('}', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SequenceValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SequenceValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("SequenceValue", 0);
return 0;
}

int ll_ComponentValueList(XNamedValues *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentValueList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XNamedValues llatt_1;
if (!ll_NamedValue(&llatt_1, &llstate_0, &llstate_1, llarg_components)) goto failed1;
{LLSTATE llstate_2;XNamedValues llatt_2;
if (!ll_ComponentValueCList(&llatt_2, &llstate_1, &llstate_2, llarg_components)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupNamedValue(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("ComponentValueList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentValueList", 0);
return 0;
}

int ll_ComponentValueCList(XNamedValues *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentValueCList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ComponentValueCList", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XNamedValues llatt_2;
if (!ll_ComponentValueList(&llatt_2, &llstate_1, &llstate_2, llarg_components)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ComponentValueCList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ComponentValueCList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ComponentValueCList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentValueCList", 0);
return 0;
}

int ll_SequenceOfValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SequenceOfValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SequenceOfValue", 1);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{Type_t *type, *subtype;
	    type = GetType(llstate_1.Assignments, llarg_type);
	    subtype = (type ? type->U.SS.Type : NULL);
	
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_ValueList(&llatt_2, &llstate_1, &llstate_2, subtype)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.SequenceOf.Values = llatt_2;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SequenceOfValue", 2);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('}', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SequenceOfValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SequenceOfValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("SequenceOfValue", 0);
return 0;
}

int ll_ValueList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_Value(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_ValueCList(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed1;
*llout = llstate_2;
{(*llret) = DupValue(llatt_1);
	    (*llret)->Next = llatt_2;
	
}}}
LLDEBUG_LEAVE("ValueList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueList", 0);
return 0;
}

int ll_ValueCList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueCList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ValueCList", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_ValueList(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ValueCList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ValueCList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ValueCList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueCList", 0);
return 0;
}

int ll_SetValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SetValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SetValue", 1);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{Component_t *components;
	    Type_t *type;
	    type = GetType(llstate_1.Assignments, llarg_type);
	    components = type ? type->U.SSC.Components : NULL;
	
{LLSTATE llstate_2;XNamedValues llatt_2;
if (!ll_ComponentValueList(&llatt_2, &llstate_1, &llstate_2, components)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{Component_t *c;
	    NamedValue_t *v;
	    if (type) {
		for (c = components; c; c = c->Next) {
		    switch (c->Type) {
		    case eComponent_Normal:
			v = FindNamedValue(llatt_2, c->U.NOD.NamedType->Identifier);
			if (!v)
			    LLFAILED((&llstate_2.pos,
				"Value for component `%s' is missing",
				c->U.NOD.NamedType->Identifier));
			break;
		    }
		}
		for (v = llatt_2; v; v = v->Next) {
		    if (!FindComponent((*llout).Assignments, components,
			v->Identifier) ||
			FindNamedValue(v->Next, v->Identifier))
			LLFAILED((&llstate_2.pos, "Component `%s' is unexpected",
			    v->Identifier));
		}
	    }
	    (*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.Set.NamedValues = llatt_2;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SetValue", 2);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('}', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SetValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SetValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("SetValue", 0);
return 0;
}

int ll_SetOfValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SetOfValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SetOfValue", 1);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{Type_t *type, *subtype;
	    type = GetType(llstate_1.Assignments, llarg_type);
	    subtype = (type ? type->U.SS.Type : NULL);
	
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_ValueList(&llatt_2, &llstate_1, &llstate_2, subtype)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.SetOf.Values = llatt_2;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SetOfValue", 2);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('}', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SetOfValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SetOfValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("SetOfValue", 0);
return 0;
}

int ll_ChoiceValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ChoiceValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(':', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{Component_t *component;
	    Type_t *type, *subtype;
	    type = GetType(llstate_2.Assignments, llarg_type);
	    if (type) {
		component = FindComponent(llstate_2.Assignments,
		    type->U.Choice.Components, llatt_1);
		if (!component)
		    LLFAILED((&llstate_1.pos, "Bad alternative `%s'", llatt_1));
		subtype = component->U.NOD.NamedType->Type;
	    } else {
		subtype = NULL;
	    }
	
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_Value(&llatt_3, &llstate_2, &llstate_3, subtype)) goto failed1;
*llout = llstate_3;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.SSC.NamedValues = NewNamedValue(llatt_1, llatt_3);
	
}}}}}
LLDEBUG_LEAVE("ChoiceValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ChoiceValue", 0);
return 0;
}

int ll_ObjectIdentifierValue(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectIdentifierValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectIdentifierValue", 1);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XNamedObjIdValue llatt_2;
if (!ll_ObjIdComponentList(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{switch (GetAssignedObjectIdentifier(
		&(*llout).AssignedObjIds, NULL, llatt_2, &(*llret))) {
	    case -1:
		LLFAILED((&llstate_2.pos, "Different numbers for equally named object identifier components"));
		/*NOTREACHED*/
	    case 0:
		if (pass <= 2)
		    (*llret) = NULL;
		else
		    LLFAILED((&llstate_2.pos, "Unknown object identifier component"));
		break;
	    case 1:
		break;
	    }
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectIdentifierValue", 2);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_DefinedValue(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNamedObjIdValue llatt_3;
if (!ll_ObjIdComponentList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{Value_t *v;
	    v = GetValue((*llout).Assignments, llatt_2);
	    if (v) {
		if (GetTypeType((*llout).Assignments, v->Type) !=
		    eType_ObjectIdentifier &&
		    GetTypeType((*llout).Assignments, v->Type) !=
		    eType_Undefined)
		    LLFAILED((&llstate_2.pos, "Bad type of value in object identifier"));
		if (GetTypeType((*llout).Assignments, v->Type) ==
		    eType_ObjectIdentifier) {
		    switch (GetAssignedObjectIdentifier(
			&(*llout).AssignedObjIds, v, llatt_3, &(*llret))) {
		    case -1:
			LLFAILED((&llstate_3.pos, "Different numbers for equally named object identifier components"));
			/*NOTREACHED*/
		    case 0:
			if (pass <= 2)
			    (*llret) = NULL;
			else
			    LLFAILED((&llstate_2.pos, "Unknown object identifier component"));
			break;
		    case 1:
			break;
		    }
		}
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectIdentifierValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectIdentifierValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectIdentifierValue", 0);
return 0;
}

int ll_ObjIdComponentList(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjIdComponentList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_ObjIdComponent(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XNamedObjIdValue llatt_2;
if (!ll_ObjIdComponent_ESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{if (llatt_1) {
		(*llret) = DupNamedObjIdValue(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = NULL;
	    }
	
}}}
LLDEBUG_LEAVE("ObjIdComponentList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjIdComponentList", 0);
return 0;
}

int ll_ObjIdComponent_ESeq(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjIdComponent_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjIdComponent_ESeq", 1);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_ObjIdComponent(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XNamedObjIdValue llatt_2;
if (!ll_ObjIdComponent_ESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{if (llatt_1) {
		(*llret) = DupNamedObjIdValue(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjIdComponent_ESeq", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjIdComponent_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjIdComponent_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjIdComponent_ESeq", 0);
return 0;
}

int ll_ObjIdComponent(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjIdComponent");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjIdComponent", 1);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_NameForm(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjIdComponent", 2);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_NumberForm(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ObjIdComponent", 3);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_NameAndNumberForm(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjIdComponent");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjIdComponent", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjIdComponent", 0);
return 0;
}

int ll_NameForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NameForm");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = NewNamedObjIdValue(eNamedObjIdValue_NameForm);
	    (*llret)->Name = llatt_1;
	
}}
LLDEBUG_LEAVE("NameForm", 1);
return 1;
failed1: LLDEBUG_LEAVE("NameForm", 0);
return 0;
}

int ll_NumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NumberForm");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NumberForm", 1);
{LLSTATE llstate_1;XNumber llatt_1;
if (!llterm(T_number, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XNumber;
*llout = llstate_1;
{(*llret) = NewNamedObjIdValue(eNamedObjIdValue_NumberForm);
	    (*llret)->Number = intx2uint32(&llatt_1);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NumberForm", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_DefinedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{Value_t *v;
	    v = GetValue((*llout).Assignments, llatt_1);
	    if (v &&
		GetTypeType((*llout).Assignments, v->Type) != eType_Integer &&
		GetTypeType((*llout).Assignments, v->Type) != eType_Undefined)
		LLFAILED((&llstate_1.pos, "Bad type in object identifier"));
	    if (v &&
		GetTypeType((*llout).Assignments, v->Type) == eType_Integer &&
		intx_cmp(&v->U.Integer.Value, &intx_0) < 0)
		LLFAILED((&llstate_1.pos, "Bad value in object identifier"));
	    if (v &&
		GetTypeType((*llout).Assignments, v->Type) == eType_Integer) {
		(*llret) = NewNamedObjIdValue(eNamedObjIdValue_NumberForm);
		(*llret)->Number = intx2uint32(&v->U.Integer.Value);
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NumberForm");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NumberForm", 1);
return 1;
failed1: LLDEBUG_LEAVE("NumberForm", 0);
return 0;
}

int ll_NameAndNumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NameAndNumberForm");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('(', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XNamedObjIdValue llatt_3;
if (!ll_NumberForm(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{if (llatt_3) {
		(*llret) = NewNamedObjIdValue(eNamedObjIdValue_NameAndNumberForm);
		(*llret)->Name = llatt_1;
		(*llret)->Number = llatt_3->Number;
	    } else {
		(*llret) = NULL;
	    }
	
}}}}}
LLDEBUG_LEAVE("NameAndNumberForm", 1);
return 1;
failed1: LLDEBUG_LEAVE("NameAndNumberForm", 0);
return 0;
}

int ll_EmbeddedPDVValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("EmbeddedPDVValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("EmbeddedPDVValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("EmbeddedPDVValue", 0);
return 0;
}

int ll_ExternalValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExternalValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("ExternalValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExternalValue", 0);
return 0;
}

int ll_CharacterStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("CharacterStringValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("CharacterStringValue", 1);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type != eType_Undefined && !IsRestrictedString(type))
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_RestrictedCharacterStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("CharacterStringValue", 2);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_CharacterString)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_UnrestrictedCharacterStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("CharacterStringValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("CharacterStringValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("CharacterStringValue", 0);
return 0;
}

int ll_RestrictedCharacterStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("RestrictedCharacterStringValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringValue", 1);
{LLSTATE llstate_1;XString32 llatt_1;
if (!llterm(T_cstring, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString32;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.RestrictedString.Value.length = str32len(llatt_1);
	    (*llret)->U.RestrictedString.Value.value = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringValue", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_CharacterStringList(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringValue", 3);
{LLSTATE llstate_1;XQuadruple llatt_1;
if (!ll_Quadruple(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.RestrictedString.Value.length = 1;
	    (*llret)->U.RestrictedString.Value.value =
		(char32_t *)malloc(sizeof(char32_t));
	    (*llret)->U.RestrictedString.Value.value[0] =
		256 * (256 * (256 * llatt_1.Group + llatt_1.Plane) + llatt_1.Row) + llatt_1.Cell;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringValue", 4);
{LLSTATE llstate_1;XTuple llatt_1;
if (!ll_Tuple(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.RestrictedString.Value.length = 1;
	    (*llret)->U.RestrictedString.Value.value =
		(char32_t *)malloc(sizeof(char32_t));
	    *(*llret)->U.RestrictedString.Value.value =
		llatt_1.Column * 16 + llatt_1.Row;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("RestrictedCharacterStringValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("RestrictedCharacterStringValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("RestrictedCharacterStringValue", 0);
return 0;
}

int ll_UnrestrictedCharacterStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UnrestrictedCharacterStringValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("UnrestrictedCharacterStringValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("UnrestrictedCharacterStringValue", 0);
return 0;
}

int ll_CharacterStringList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("CharacterStringList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_CharSyms(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = llatt_2;
	
}}}}
LLDEBUG_LEAVE("CharacterStringList", 1);
return 1;
failed1: LLDEBUG_LEAVE("CharacterStringList", 0);
return 0;
}

int ll_CharSyms(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("CharSyms");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("CharSyms", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_CharDefn(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("CharSyms", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_CharDefn(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_CharSyms(&llatt_3, &llstate_2, &llstate_3, llarg_type)) goto failed2;
*llout = llstate_3;
{if (!llatt_1 || !llatt_3) {
		(*llret) = NULL;
	    } else {
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		(*llret)->U.RestrictedString.Value.length =
		    llatt_1->U.RestrictedString.Value.length +
		    llatt_3->U.RestrictedString.Value.length;
		(*llret)->U.RestrictedString.Value.value =
		    (char32_t *)malloc(
		    (*llret)->U.RestrictedString.Value.length *
		    sizeof(char32_t));
		memcpy((*llret)->U.RestrictedString.Value.value,
		    llatt_1->U.RestrictedString.Value.value,
		    llatt_1->U.RestrictedString.Value.length *
		    sizeof(char32_t));
		memcpy((*llret)->U.RestrictedString.Value.value +
		    llatt_1->U.RestrictedString.Value.length,
		    llatt_3->U.RestrictedString.Value.value,
		    llatt_3->U.RestrictedString.Value.length *
		    sizeof(char32_t));
	    }
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("CharSyms");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("CharSyms", 1);
return 1;
failed1: LLDEBUG_LEAVE("CharSyms", 0);
return 0;
}

int ll_CharDefn(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("CharDefn");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("CharDefn", 1);
{LLSTATE llstate_1;XString32 llatt_1;
if (!llterm(T_cstring, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString32;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.RestrictedString.Value.length = str32len(llatt_1);
	    (*llret)->U.RestrictedString.Value.value = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("CharDefn", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_DefinedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("CharDefn");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("CharDefn", 1);
return 1;
failed1: LLDEBUG_LEAVE("CharDefn", 0);
return 0;
}

int ll_Quadruple(XQuadruple *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Quadruple");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XNumber llatt_2;
if (!llterm(T_number, &lllval, &llstate_1, &llstate_2)) goto failed1;
llatt_2 = lllval._XNumber;
{LLSTATE llstate_3;
if (!llterm(',', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XNumber llatt_4;
if (!llterm(T_number, &lllval, &llstate_3, &llstate_4)) goto failed1;
llatt_4 = lllval._XNumber;
{LLSTATE llstate_5;
if (!llterm(',', (LLSTYPE *)0, &llstate_4, &llstate_5)) goto failed1;
{LLSTATE llstate_6;XNumber llatt_6;
if (!llterm(T_number, &lllval, &llstate_5, &llstate_6)) goto failed1;
llatt_6 = lllval._XNumber;
{LLSTATE llstate_7;
if (!llterm(',', (LLSTYPE *)0, &llstate_6, &llstate_7)) goto failed1;
{LLSTATE llstate_8;XNumber llatt_8;
if (!llterm(T_number, &lllval, &llstate_7, &llstate_8)) goto failed1;
llatt_8 = lllval._XNumber;
{LLSTATE llstate_9;
if (!llterm('}', (LLSTYPE *)0, &llstate_8, &llstate_9)) goto failed1;
*llout = llstate_9;
{(*llret).Group = intx2uint32(&llatt_2);
	    (*llret).Plane = intx2uint32(&llatt_4);
	    (*llret).Row = intx2uint32(&llatt_6);
	    (*llret).Cell = intx2uint32(&llatt_8);
	
}}}}}}}}}}
LLDEBUG_LEAVE("Quadruple", 1);
return 1;
failed1: LLDEBUG_LEAVE("Quadruple", 0);
return 0;
}

int ll_Tuple(XTuple *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Tuple");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XNumber llatt_2;
if (!llterm(T_number, &lllval, &llstate_1, &llstate_2)) goto failed1;
llatt_2 = lllval._XNumber;
{LLSTATE llstate_3;
if (!llterm(',', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XNumber llatt_4;
if (!llterm(T_number, &lllval, &llstate_3, &llstate_4)) goto failed1;
llatt_4 = lllval._XNumber;
{LLSTATE llstate_5;
if (!llterm('}', (LLSTYPE *)0, &llstate_4, &llstate_5)) goto failed1;
*llout = llstate_5;
{(*llret).Column = intx2uint32(&llatt_2);
	    (*llret).Row = intx2uint32(&llatt_4);
	
}}}}}}
LLDEBUG_LEAVE("Tuple", 1);
return 1;
failed1: LLDEBUG_LEAVE("Tuple", 0);
return 0;
}

int ll_AnyValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AnyValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XType llatt_1;
if (!ll_Type(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(':', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_Value(&llatt_3, &llstate_2, &llstate_3, llatt_1)) goto failed1;
*llout = llstate_3;
{(*llret) = llatt_3;
	
}}}}
LLDEBUG_LEAVE("AnyValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("AnyValue", 0);
return 0;
}

int ll_Constraint(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Constraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('(', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XConstraints llatt_2;
if (!ll_ConstraintSpec(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_permalpha)) goto failed1;
{LLSTATE llstate_3;
if (!ll_ExceptionSpec(&llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{(*llret) = llatt_2; /*XXX ExceptionSpec */
	
}}}}}
LLDEBUG_LEAVE("Constraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("Constraint", 0);
return 0;
}

int ll_ConstraintSpec(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ConstraintSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ConstraintSpec", 1);
{LLSTATE llstate_1;XConstraints llatt_1;
if (!ll_SubtypeConstraint(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_permalpha)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ConstraintSpec", 2);
{LLSTATE llstate_1;
if (!ll_GeneralConstraint(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NULL; /*XXX*/
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ConstraintSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ConstraintSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("ConstraintSpec", 0);
return 0;
}

int ll_SubtypeConstraint(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SubtypeConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XConstraints llatt_1;
if (!ll_ElementSetSpecs(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_permalpha)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("SubtypeConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("SubtypeConstraint", 0);
return 0;
}

int ll_ExceptionSpec(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExceptionSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ExceptionSpec", 1);
{LLSTATE llstate_1;
if (!llterm('!', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_ExceptionIdentification(&llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ExceptionSpec", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ExceptionSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ExceptionSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExceptionSpec", 0);
return 0;
}

int ll_ExceptionIdentification(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExceptionIdentification");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ExceptionIdentification", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SignedNumber(&llatt_1, &llstate_0, &llstate_1, Builtin_Type_Integer)) goto failed2;
*llout = llstate_1;
break;
}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ExceptionIdentification", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_DefinedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
break;
}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ExceptionIdentification", 3);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_Type(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(':', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_Value(&llatt_3, &llstate_2, &llstate_3, llatt_1)) goto failed2;
*llout = llstate_3;
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ExceptionIdentification");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ExceptionIdentification", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExceptionIdentification", 0);
return 0;
}

int ll_ElementSetSpecs(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ElementSetSpecs");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ElementSetSpecs", 1);
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_ElementSetSpec(&llatt_1, &llstate_0, &llstate_1, llarg_type, NULL, llarg_permalpha)) goto failed2;
{LLSTATE llstate_2;XConstraints llatt_2;
if (!ll_ElementSetSpecExtension(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_permalpha)) goto failed2;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupConstraint(llatt_2);
	    } else {
		(*llret) = NewConstraint();
	    }
	    (*llret)->Root = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ElementSetSpecs", 2);
{LLSTATE llstate_1;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_AdditionalElementSetSpec(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_permalpha)) goto failed2;
*llout = llstate_2;
{(*llret) = NewConstraint();
	    (*llret)->Type = llatt_2 ? eExtension_Extended : eExtension_Extendable;
	    (*llret)->Additional = llatt_2;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ElementSetSpecs");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ElementSetSpecs", 1);
return 1;
failed1: LLDEBUG_LEAVE("ElementSetSpecs", 0);
return 0;
}

int ll_ElementSetSpecExtension(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ElementSetSpecExtension");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ElementSetSpecExtension", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XElementSetSpec llatt_3;
if (!ll_AdditionalElementSetSpec(&llatt_3, &llstate_2, &llstate_3, llarg_type, llarg_permalpha)) goto failed2;
*llout = llstate_3;
{(*llret) = NewConstraint();
	    (*llret)->Type = llatt_3 ? eExtension_Extended : eExtension_Extendable;
	    (*llret)->Additional = llatt_3;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ElementSetSpecExtension", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ElementSetSpecExtension");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ElementSetSpecExtension", 1);
return 1;
failed1: LLDEBUG_LEAVE("ElementSetSpecExtension", 0);
return 0;
}

int ll_AdditionalElementSetSpec(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AdditionalElementSetSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("AdditionalElementSetSpec", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_ElementSetSpec(&llatt_2, &llstate_1, &llstate_2, llarg_type, NULL, llarg_permalpha)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("AdditionalElementSetSpec", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("AdditionalElementSetSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("AdditionalElementSetSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("AdditionalElementSetSpec", 0);
return 0;
}

int ll_ElementSetSpec(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ElementSetSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ElementSetSpec", 1);
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_Unions(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ElementSetSpec", 2);
{LLSTATE llstate_1;
if (!llterm(T_ALL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_Exclusions(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed2;
*llout = llstate_2;
{(*llret) = NewElementSetSpec(eElementSetSpec_AllExcept);
	    (*llret)->U.AllExcept.Elements = llatt_2;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ElementSetSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ElementSetSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("ElementSetSpec", 0);
return 0;
}

int ll_Unions(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Unions");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_Intersections(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_UnionList(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = NewElementSetSpec(eElementSetSpec_Union);
		(*llret)->U.Union.Elements1 = llatt_1;
		(*llret)->U.Union.Elements2 = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("Unions", 1);
return 1;
failed1: LLDEBUG_LEAVE("Unions", 0);
return 0;
}

int ll_UnionList(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UnionList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UnionList", 1);
{LLSTATE llstate_1;
if (!ll_UnionMark(&llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_Unions(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UnionList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UnionList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UnionList", 1);
return 1;
failed1: LLDEBUG_LEAVE("UnionList", 0);
return 0;
}

int ll_Intersections(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Intersections");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_IntersectionElements(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_IntersectionList(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = NewElementSetSpec(eElementSetSpec_Intersection);
		(*llret)->U.Intersection.Elements1 = llatt_1;
		(*llret)->U.Intersection.Elements2 = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("Intersections", 1);
return 1;
failed1: LLDEBUG_LEAVE("Intersections", 0);
return 0;
}

int ll_IntersectionList(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IntersectionList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("IntersectionList", 1);
{LLSTATE llstate_1;
if (!ll_IntersectionMark(&llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_Intersections(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("IntersectionList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("IntersectionList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("IntersectionList", 1);
return 1;
failed1: LLDEBUG_LEAVE("IntersectionList", 0);
return 0;
}

int ll_IntersectionElements(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IntersectionElements");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_Elements(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_Exclusions_Opt(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = NewElementSetSpec(eElementSetSpec_Exclusion);
		(*llret)->U.Exclusion.Elements1 = llatt_1;
		(*llret)->U.Exclusion.Elements2 = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("IntersectionElements", 1);
return 1;
failed1: LLDEBUG_LEAVE("IntersectionElements", 0);
return 0;
}

int ll_Exclusions_Opt(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Exclusions_Opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Exclusions_Opt", 1);
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_Exclusions(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Exclusions_Opt", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Exclusions_Opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Exclusions_Opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("Exclusions_Opt", 0);
return 0;
}

int ll_Exclusions(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Exclusions");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_EXCEPT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_Elements(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
*llout = llstate_2;
{(*llret) = llatt_2;
	
}}}
LLDEBUG_LEAVE("Exclusions", 1);
return 1;
failed1: LLDEBUG_LEAVE("Exclusions", 0);
return 0;
}

int ll_UnionMark(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UnionMark");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UnionMark", 1);
{LLSTATE llstate_1;
if (!llterm('|', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
break;
}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UnionMark", 2);
{LLSTATE llstate_1;
if (!llterm(T_UNION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UnionMark");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UnionMark", 1);
return 1;
failed1: LLDEBUG_LEAVE("UnionMark", 0);
return 0;
}

int ll_IntersectionMark(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IntersectionMark");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("IntersectionMark", 1);
{LLSTATE llstate_1;
if (!llterm('^', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
break;
}
case 2: case -2:
LLDEBUG_ALTERNATIVE("IntersectionMark", 2);
{LLSTATE llstate_1;
if (!llterm(T_INTERSECTION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("IntersectionMark");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("IntersectionMark", 1);
return 1;
failed1: LLDEBUG_LEAVE("IntersectionMark", 0);
return 0;
}

int ll_Elements(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Elements");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Elements", 1);
{if (llarg_objectclass)
		LLFAILED((&llstate_0.pos, "Bad object set"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_SubtypeElements(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_permalpha)) goto failed2;
*llout = llstate_1;
{(*llret) = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	    (*llret)->U.SubtypeElement.SubtypeElement = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Elements", 2);
{if (llarg_type)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XObjectSetElement llatt_1;
if (!ll_ObjectSetElements(&llatt_1, &llstate_0, &llstate_1, llarg_objectclass)) goto failed2;
*llout = llstate_1;
{(*llret) = NewElementSetSpec(eElementSetSpec_ObjectSetElement);
	    (*llret)->U.ObjectSetElement.ObjectSetElement = llatt_1;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("Elements", 3);
{LLSTATE llstate_1;
if (!llterm('(', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_ElementSetSpec(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(')', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_2;
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Elements");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Elements", 1);
return 1;
failed1: LLDEBUG_LEAVE("Elements", 0);
return 0;
}

int ll_SubtypeElements(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SubtypeElements");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SubtypeElements", 1);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type == eType_Open)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_SingleValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SubtypeElements", 2);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type == eType_EmbeddedPdv ||
		type == eType_External ||
		type == eType_Open ||
		type == eType_CharacterString)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_ContainedSubtype(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("SubtypeElements", 3);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (llarg_permalpha ?
		(type != eType_Undefined &&
		type != eType_BMPString &&
		type != eType_IA5String &&
		type != eType_NumericString &&
		type != eType_PrintableString &&
		type != eType_VisibleString &&
		type != eType_UniversalString) :
		(type != eType_Undefined &&
		type != eType_Integer &&
		type != eType_Real))
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_ValueRange(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("SubtypeElements", 4);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type != eType_Undefined &&
		!IsRestrictedString(type) ||
		llarg_permalpha)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_PermittedAlphabet(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("SubtypeElements", 5);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type != eType_Undefined &&
		type != eType_BitString &&
		type != eType_OctetString &&
		type != eType_UTF8String &&
		type != eType_SequenceOf &&
		type != eType_SetOf &&
		type != eType_CharacterString &&
		!IsRestrictedString(type) ||
		llarg_permalpha)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_SizeConstraint(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("SubtypeElements", 6);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type != eType_Undefined &&
		type != eType_Open ||
		llarg_permalpha)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_TypeConstraint(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("SubtypeElements", 7);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type != eType_Undefined &&
		type != eType_Choice &&
		type != eType_EmbeddedPdv &&
		type != eType_External &&
		type != eType_InstanceOf &&
		type != eType_Real &&
		type != eType_Sequence &&
		type != eType_SequenceOf &&
		type != eType_Set &&
		type != eType_SetOf &&
		type != eType_CharacterString ||
		llarg_permalpha)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_InnerTypeConstraints(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SubtypeElements");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SubtypeElements", 1);
return 1;
failed1: LLDEBUG_LEAVE("SubtypeElements", 0);
return 0;
}

int ll_SingleValue(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SingleValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_Value(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = NewSubtypeElement(eSubtypeElement_SingleValue);
	    (*llret)->U.SingleValue.Value = llatt_1;
	
}}
LLDEBUG_LEAVE("SingleValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("SingleValue", 0);
return 0;
}

int ll_ContainedSubtype(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ContainedSubtype");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XBoolean llatt_1;
if (!ll_Includes(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{if (GetTypeType((*llout).Assignments, llatt_2) == eType_Null && !llatt_1)
		LLFAILED((&llstate_1.pos, "Bad constraint"));
	    if (GetTypeType((*llout).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llout).Assignments, llatt_2) != eType_Undefined &&
		GetTypeType((*llout).Assignments, llarg_type) !=
		GetTypeType((*llout).Assignments, llatt_2) &&
		GetTypeType((*llout).Assignments, llarg_type) != eType_Open &&
		GetTypeType((*llout).Assignments, llatt_2) != eType_Open &&
		(!IsRestrictedString(GetTypeType((*llout).Assignments, llarg_type)) ||
		!IsRestrictedString(GetTypeType((*llout).Assignments, llatt_2))))
		LLFAILED((&llstate_2.pos, "Bad type of contained-subtype-constraint"));
	    (*llret) = NewSubtypeElement(eSubtypeElement_ContainedSubtype);
	    (*llret)->U.ContainedSubtype.Type = llatt_2;
	
}}}
LLDEBUG_LEAVE("ContainedSubtype", 1);
return 1;
failed1: LLDEBUG_LEAVE("ContainedSubtype", 0);
return 0;
}

int ll_Includes(XBoolean *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Includes");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Includes", 1);
{LLSTATE llstate_1;
if (!llterm(T_INCLUDES, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Includes", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Includes");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Includes", 1);
return 1;
failed1: LLDEBUG_LEAVE("Includes", 0);
return 0;
}

int ll_ValueRange(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueRange");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XEndPoint llatt_1;
if (!ll_LowerEndpoint(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_DDOT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XEndPoint llatt_3;
if (!ll_UpperEndpoint(&llatt_3, &llstate_2, &llstate_3, llarg_type)) goto failed1;
*llout = llstate_3;
{if (!llarg_type) {
		(*llret) = NULL;
	    } else {
		(*llret) = NewSubtypeElement(eSubtypeElement_ValueRange);
		(*llret)->U.ValueRange.Lower = llatt_1;
		(*llret)->U.ValueRange.Upper = llatt_3;
	    }
	
}}}}
LLDEBUG_LEAVE("ValueRange", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueRange", 0);
return 0;
}

int ll_LowerEndpoint(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LowerEndpoint");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("LowerEndpoint", 1);
{LLSTATE llstate_1;XEndPoint llatt_1;
if (!ll_LowerEndValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('<', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_1;
	    (*llret).Flags |= eEndPoint_Open;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("LowerEndpoint", 2);
{LLSTATE llstate_1;XEndPoint llatt_1;
if (!ll_LowerEndValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("LowerEndpoint");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("LowerEndpoint", 1);
return 1;
failed1: LLDEBUG_LEAVE("LowerEndpoint", 0);
return 0;
}

int ll_UpperEndpoint(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UpperEndpoint");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UpperEndpoint", 1);
{LLSTATE llstate_1;
if (!llterm('<', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XEndPoint llatt_2;
if (!ll_UpperEndValue(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	    (*llret).Flags |= eEndPoint_Open;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UpperEndpoint", 2);
{LLSTATE llstate_1;XEndPoint llatt_1;
if (!ll_UpperEndValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UpperEndpoint");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UpperEndpoint", 1);
return 1;
failed1: LLDEBUG_LEAVE("UpperEndpoint", 0);
return 0;
}

int ll_LowerEndValue(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LowerEndValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("LowerEndValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_Value(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret).Value = llatt_1;
	    (*llret).Flags = 0;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("LowerEndValue", 2);
{LLSTATE llstate_1;
if (!llterm(T_MIN, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret).Value = NULL;
	    (*llret).Flags = eEndPoint_Min;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("LowerEndValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("LowerEndValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("LowerEndValue", 0);
return 0;
}

int ll_UpperEndValue(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UpperEndValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UpperEndValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_Value(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret).Value = llatt_1;
	    (*llret).Flags = 0;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UpperEndValue", 2);
{LLSTATE llstate_1;
if (!llterm(T_MAX, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret).Value = NULL;
	    (*llret).Flags = eEndPoint_Max;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UpperEndValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UpperEndValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("UpperEndValue", 0);
return 0;
}

int ll_SizeConstraint(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SizeConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_SIZE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XConstraints llatt_2;
if (!ll_Constraint(&llatt_2, &llstate_1, &llstate_2, Builtin_Type_PositiveInteger, 0)) goto failed1;
*llout = llstate_2;
{(*llret) = NewSubtypeElement(eSubtypeElement_Size);
	    (*llret)->U.Size.Constraints = llatt_2;
	
}}}
LLDEBUG_LEAVE("SizeConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("SizeConstraint", 0);
return 0;
}

int ll_TypeConstraint(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XType llatt_1;
if (!ll_Type(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = NewSubtypeElement(eSubtypeElement_Type);
	    (*llret)->U.Type.Type = llatt_1;
	
}}
LLDEBUG_LEAVE("TypeConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeConstraint", 0);
return 0;
}

int ll_PermittedAlphabet(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PermittedAlphabet");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_FROM, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XConstraints llatt_2;
if (!ll_Constraint(&llatt_2, &llstate_1, &llstate_2, llarg_type, 1)) goto failed1;
*llout = llstate_2;
{(*llret) = NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
	    (*llret)->U.PermittedAlphabet.Constraints = llatt_2;
	
}}}
LLDEBUG_LEAVE("PermittedAlphabet", 1);
return 1;
failed1: LLDEBUG_LEAVE("PermittedAlphabet", 0);
return 0;
}

int ll_InnerTypeConstraints(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("InnerTypeConstraints");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("InnerTypeConstraints", 1);
{Type_t *subtype;
	    if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_SequenceOf &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_SetOf)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	    if (GetTypeType((*llin).Assignments, llarg_type) == eType_Undefined)
		subtype = NULL;
	    else
		subtype = GetType((*llin).Assignments, llarg_type)->U.SS.Type;
	
{LLSTATE llstate_1;
if (!llterm(T_WITH, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_COMPONENT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XSubtypeElement llatt_3;
if (!ll_SingleTypeConstraint(&llatt_3, &llstate_2, &llstate_3, subtype)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("InnerTypeConstraints", 2);
{Component_t *components;
	    if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Sequence &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Set &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Choice &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Real &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_External &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_EmbeddedPdv &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_CharacterString)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	    if (GetTypeType((*llin).Assignments, llarg_type) == eType_Undefined)
	    	components = NULL;
	    else
		components = GetType((*llin).Assignments, llarg_type)->U.SSC.Components;
	
{LLSTATE llstate_1;
if (!llterm(T_WITH, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_COMPONENTS, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XSubtypeElement llatt_3;
if (!ll_MultipleTypeConstraints(&llatt_3, &llstate_2, &llstate_3, components)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_3;
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("InnerTypeConstraints");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("InnerTypeConstraints", 1);
return 1;
failed1: LLDEBUG_LEAVE("InnerTypeConstraints", 0);
return 0;
}

int ll_SingleTypeConstraint(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SingleTypeConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XConstraints llatt_1;
if (!ll_Constraint(&llatt_1, &llstate_0, &llstate_1, llarg_type, 0)) goto failed1;
*llout = llstate_1;
{(*llret) = NewSubtypeElement(eSubtypeElement_SingleType);
	    (*llret)->U.SingleType.Constraints = llatt_1;
	
}}
LLDEBUG_LEAVE("SingleTypeConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("SingleTypeConstraint", 0);
return 0;
}

int ll_MultipleTypeConstraints(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("MultipleTypeConstraints");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("MultipleTypeConstraints", 1);
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_FullSpecification(&llatt_1, &llstate_0, &llstate_1, llarg_components)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("MultipleTypeConstraints", 2);
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_PartialSpecification(&llatt_1, &llstate_0, &llstate_1, llarg_components)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("MultipleTypeConstraints");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("MultipleTypeConstraints", 1);
return 1;
failed1: LLDEBUG_LEAVE("MultipleTypeConstraints", 0);
return 0;
}

int ll_FullSpecification(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FullSpecification");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XNamedConstraints llatt_2;
if (!ll_TypeConstraints(&llatt_2, &llstate_1, &llstate_2, llarg_components)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = NewSubtypeElement(eSubtypeElement_FullSpecification);
	    (*llret)->U.FullSpecification.NamedConstraints = llatt_2;
	
}}}}
LLDEBUG_LEAVE("FullSpecification", 1);
return 1;
failed1: LLDEBUG_LEAVE("FullSpecification", 0);
return 0;
}

int ll_PartialSpecification(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PartialSpecification");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(',', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XNamedConstraints llatt_4;
if (!ll_TypeConstraints(&llatt_4, &llstate_3, &llstate_4, llarg_components)) goto failed1;
{LLSTATE llstate_5;
if (!llterm('}', (LLSTYPE *)0, &llstate_4, &llstate_5)) goto failed1;
*llout = llstate_5;
{(*llret) = NewSubtypeElement(eSubtypeElement_PartialSpecification);
	    (*llret)->U.PartialSpecification.NamedConstraints = llatt_4;
	
}}}}}}
LLDEBUG_LEAVE("PartialSpecification", 1);
return 1;
failed1: LLDEBUG_LEAVE("PartialSpecification", 0);
return 0;
}

int ll_TypeConstraints(XNamedConstraints *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeConstraints");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TypeConstraints", 1);
{LLSTATE llstate_1;XNamedConstraints llatt_1;
if (!ll_NamedConstraint(&llatt_1, &llstate_0, &llstate_1, llarg_components)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TypeConstraints", 2);
{LLSTATE llstate_1;XNamedConstraints llatt_1;
if (!ll_NamedConstraint(&llatt_1, &llstate_0, &llstate_1, llarg_components)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNamedConstraints llatt_3;
if (!ll_TypeConstraints(&llatt_3, &llstate_2, &llstate_3, llarg_components)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_1;
	    (*llret)->Next = llatt_3;
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TypeConstraints");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TypeConstraints", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeConstraints", 0);
return 0;
}

int ll_NamedConstraint(XNamedConstraints *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{Component_t *component;
	    Type_t *type;
	    component = FindComponent(llstate_1.Assignments, llarg_components, llatt_1);
	    type = component ? component->U.NOD.NamedType->Type : NULL;
	
{LLSTATE llstate_2;XNamedConstraints llatt_2;
if (!ll_ComponentConstraint(&llatt_2, &llstate_1, &llstate_2, type)) goto failed1;
*llout = llstate_2;
{(*llret) = llatt_2;
	    (*llret)->Identifier = llatt_1;
	
}}}}
LLDEBUG_LEAVE("NamedConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedConstraint", 0);
return 0;
}

int ll_ComponentConstraint(XNamedConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XConstraints llatt_1;
if (!ll_ValueConstraint(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
{LLSTATE llstate_2;XPresence llatt_2;
if (!ll_PresenceConstraint(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = NewNamedConstraint();
	    (*llret)->Constraint = llatt_1;
	    (*llret)->Presence = llatt_2;
	
}}}
LLDEBUG_LEAVE("ComponentConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentConstraint", 0);
return 0;
}

int ll_ValueConstraint(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ValueConstraint", 1);
{LLSTATE llstate_1;XConstraints llatt_1;
if (!ll_Constraint(&llatt_1, &llstate_0, &llstate_1, llarg_type, 0)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ValueConstraint", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ValueConstraint");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ValueConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueConstraint", 0);
return 0;
}

int ll_PresenceConstraint(XPresence *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PresenceConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PresenceConstraint", 1);
{LLSTATE llstate_1;
if (!llterm(T_PRESENT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = ePresence_Present;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PresenceConstraint", 2);
{LLSTATE llstate_1;
if (!llterm(T_ABSENT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = ePresence_Absent;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("PresenceConstraint", 3);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = ePresence_Optional;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("PresenceConstraint", 4);
*llout = llstate_0;
{(*llret) = ePresence_Normal;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PresenceConstraint");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PresenceConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("PresenceConstraint", 0);
return 0;
}

int ll_GeneralConstraint(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("GeneralConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_CON_XXX1, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("GeneralConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("GeneralConstraint", 0);
return 0;
}

int ll_LocalTypeDirectiveSeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LocalTypeDirectiveSeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XDirectives llatt_1;
if (!ll_LocalTypeDirective(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalTypeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupDirective(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("LocalTypeDirectiveSeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("LocalTypeDirectiveSeq", 0);
return 0;
}

int ll_LocalTypeDirectiveESeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LocalTypeDirectiveESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("LocalTypeDirectiveESeq", 1);
{LLSTATE llstate_1;XDirectives llatt_1;
if (!ll_LocalTypeDirective(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalTypeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupDirective(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("LocalTypeDirectiveESeq", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("LocalTypeDirectiveESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("LocalTypeDirectiveESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("LocalTypeDirectiveESeq", 0);
return 0;
}

int ll_LocalTypeDirective(XDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LocalTypeDirective");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("LocalTypeDirective", 1);
{LLSTATE llstate_1;
if (!llterm(T_ZERO_TERMINATED, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_ZeroTerminated);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("LocalTypeDirective", 2);
{LLSTATE llstate_1;
if (!llterm(T_POINTER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_Pointer);
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("LocalTypeDirective", 3);
{LLSTATE llstate_1;
if (!llterm(T_NO_POINTER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_NoPointer);
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("LocalTypeDirective");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("LocalTypeDirective", 1);
return 1;
failed1: LLDEBUG_LEAVE("LocalTypeDirective", 0);
return 0;
}

int ll_LocalSizeDirectiveSeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LocalSizeDirectiveSeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XDirectives llatt_1;
if (!ll_LocalSizeDirective(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupDirective(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("LocalSizeDirectiveSeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("LocalSizeDirectiveSeq", 0);
return 0;
}

int ll_LocalSizeDirectiveESeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LocalSizeDirectiveESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("LocalSizeDirectiveESeq", 1);
{LLSTATE llstate_1;XDirectives llatt_1;
if (!ll_LocalSizeDirective(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupDirective(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("LocalSizeDirectiveESeq", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("LocalSizeDirectiveESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("LocalSizeDirectiveESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("LocalSizeDirectiveESeq", 0);
return 0;
}

int ll_LocalSizeDirective(XDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LocalSizeDirective");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("LocalSizeDirective", 1);
{LLSTATE llstate_1;
if (!llterm(T_FIXED_ARRAY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_FixedArray);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("LocalSizeDirective", 2);
{LLSTATE llstate_1;
if (!llterm(T_DOUBLY_LINKED_LIST, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_DoublyLinkedList);
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("LocalSizeDirective", 3);
{LLSTATE llstate_1;
if (!llterm(T_SINGLY_LINKED_LIST, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_SinglyLinkedList);
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("LocalSizeDirective", 4);
{LLSTATE llstate_1;
if (!llterm(T_LENGTH_POINTER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_LengthPointer);
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("LocalSizeDirective");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("LocalSizeDirective", 1);
return 1;
failed1: LLDEBUG_LEAVE("LocalSizeDirective", 0);
return 0;
}

int ll_PrivateDir_Type(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Type");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Type", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_TypeName, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XString llatt_2;
if (!llterm(T_lcsymbol, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._XString;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Type", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Type");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Type", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Type", 0);
return 0;
}

int ll_PrivateDir_Field(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Field");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Field", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_FieldName, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XString llatt_2;
if (!llterm(T_lcsymbol, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._XString;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Field", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Field");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Field", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Field", 0);
return 0;
}

int ll_PrivateDir_Value(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Value");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Value", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_ValueName, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XString llatt_2;
if (!llterm(T_lcsymbol, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._XString;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Value", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Value");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Value", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Value", 0);
return 0;
}

int ll_PrivateDir_Public(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Public");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Public", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_Public, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Public", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Public");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Public", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Public", 0);
return 0;
}

int ll_PrivateDir_Intx(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Intx");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Intx", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_Intx, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Intx", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Intx");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Intx", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Intx", 0);
return 0;
}

int ll_PrivateDir_LenPtr(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_LenPtr");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_LenPtr", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_LenPtr, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_LenPtr", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_LenPtr");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_LenPtr", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_LenPtr", 0);
return 0;
}

int ll_PrivateDir_Pointer(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Pointer");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Pointer", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_Pointer, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Pointer", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Pointer");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Pointer", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Pointer", 0);
return 0;
}

int ll_PrivateDir_Array(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Array");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Array", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_Array, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Array", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Array");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Array", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Array", 0);
return 0;
}

int ll_PrivateDir_NoCode(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_NoCode");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_NoCode", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_NoCode, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_NoCode", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_NoCode");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_NoCode", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_NoCode", 0);
return 0;
}

int ll_PrivateDir_NoMemCopy(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_NoMemCopy");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_NoMemCopy", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_NoMemCopy, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_NoMemCopy", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_NoMemCopy");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_NoMemCopy", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_NoMemCopy", 0);
return 0;
}

int ll_PrivateDir_OidPacked(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_OidPacked");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_OidPacked", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_OidPacked, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_OidPacked", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_OidPacked");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_OidPacked", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_OidPacked", 0);
return 0;
}

int ll_PrivateDir_OidArray(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_OidArray");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_OidArray", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_OidArray, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_OidArray", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_OidArray");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_OidArray", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_OidArray", 0);
return 0;
}

int ll_PrivateDir_SLinked(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_SLinked");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_SLinked", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_SLinked, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_SLinked", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_SLinked");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_SLinked", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_SLinked", 0);
return 0;
}

int ll_PrivateDir_DLinked(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_DLinked");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_DLinked", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_DLinked, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_DLinked", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_DLinked");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_DLinked", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_DLinked", 0);
return 0;
}

int ll_PrivateDirectives(XPrivateDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDirectives");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDirectives", 1);
{LLSTATE llstate_1;int llatt_1;
if (!ll_PrivateDir_Intx(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;int llatt_2;
if (!ll_PrivateDir_LenPtr(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;int llatt_3;
if (!ll_PrivateDir_Pointer(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;int llatt_4;
if (!ll_PrivateDir_Array(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
{LLSTATE llstate_5;int llatt_5;
if (!ll_PrivateDir_NoCode(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;int llatt_6;
if (!ll_PrivateDir_NoMemCopy(&llatt_6, &llstate_5, &llstate_6)) goto failed2;
{LLSTATE llstate_7;int llatt_7;
if (!ll_PrivateDir_Public(&llatt_7, &llstate_6, &llstate_7)) goto failed2;
{LLSTATE llstate_8;int llatt_8;
if (!ll_PrivateDir_OidPacked(&llatt_8, &llstate_7, &llstate_8)) goto failed2;
{LLSTATE llstate_9;int llatt_9;
if (!ll_PrivateDir_OidArray(&llatt_9, &llstate_8, &llstate_9)) goto failed2;
{LLSTATE llstate_10;XString llatt_10;
if (!ll_PrivateDir_Type(&llatt_10, &llstate_9, &llstate_10)) goto failed2;
{LLSTATE llstate_11;XString llatt_11;
if (!ll_PrivateDir_Field(&llatt_11, &llstate_10, &llstate_11)) goto failed2;
{LLSTATE llstate_12;XString llatt_12;
if (!ll_PrivateDir_Value(&llatt_12, &llstate_11, &llstate_12)) goto failed2;
{LLSTATE llstate_13;int llatt_13;
if (!ll_PrivateDir_SLinked(&llatt_13, &llstate_12, &llstate_13)) goto failed2;
{LLSTATE llstate_14;int llatt_14;
if (!ll_PrivateDir_DLinked(&llatt_14, &llstate_13, &llstate_14)) goto failed2;
*llout = llstate_14;
{(*llret) = (PrivateDirectives_t *) malloc(sizeof(PrivateDirectives_t));
	    if ((*llret))
	    {
	    	memset((*llret), 0, sizeof(PrivateDirectives_t));
		(*llret)->fIntx = llatt_1;
		(*llret)->fLenPtr = llatt_2;
		(*llret)->fPointer = llatt_3;
   		(*llret)->fArray = llatt_4;
		(*llret)->fNoCode = llatt_5;
		(*llret)->fNoMemCopy = llatt_6;
		(*llret)->fPublic = llatt_7;
		(*llret)->fOidPacked = llatt_8;
		(*llret)->fOidArray = llatt_9 | g_fOidArray;
   		(*llret)->pszTypeName = llatt_10;
   		(*llret)->pszFieldName = llatt_11;
   		(*llret)->pszValueName = llatt_12;
   		(*llret)->fSLinked = llatt_13;
   		(*llret)->fDLinked = llatt_14;
	    }
	
break;
}}}}}}}}}}}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDirectives", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDirectives");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDirectives", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDirectives", 0);
return 0;
}

int ll_DefinedObjectClass(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedObjectClass");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedObjectClass", 1);
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_ExternalObjectClassReference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedObjectClass", 2);
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_objectclassreference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("DefinedObjectClass", 3);
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_Usefulobjectclassreference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedObjectClass");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedObjectClass", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedObjectClass", 0);
return 0;
}

int ll_DefinedObject(XObject *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedObject");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedObject", 1);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ExternalObjectReference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedObject", 2);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_objectreference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedObject");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedObject", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedObject", 0);
return 0;
}

int ll_DefinedObjectSet(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedObjectSet");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedObjectSet", 1);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_ExternalObjectSetReference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedObjectSet", 2);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_objectsetreference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedObjectSet");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedObjectSet", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedObjectSet", 0);
return 0;
}

int ll_Usefulobjectclassreference(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Usefulobjectclassreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Usefulobjectclassreference", 1);
{LLSTATE llstate_1;
if (!llterm(T_TYPE_IDENTIFIER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_ObjectClass_TypeIdentifier;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Usefulobjectclassreference", 2);
{LLSTATE llstate_1;
if (!llterm(T_ABSTRACT_SYNTAX, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_ObjectClass_AbstractSyntax;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Usefulobjectclassreference");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Usefulobjectclassreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("Usefulobjectclassreference", 0);
return 0;
}

int ll_ObjectClassAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectClassAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_objectclassreference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XObjectClass llatt_3;
if (!ll_ObjectClass(&llatt_3, &llstate_2, &llstate_3, llatt_1)) goto failed1;
*llout = llstate_3;
{if (!AssignObjectClass(&(*llout).Assignments, llatt_1, llatt_3))
		LLFAILED((&llstate_1.pos, "Type `%s' twice defined",
		    llatt_1->U.Reference.Identifier));
	
}}}}
LLDEBUG_LEAVE("ObjectClassAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectClassAssignment", 0);
return 0;
}

int ll_ObjectClass(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectClass");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectClass", 1);
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_DefinedObjectClass(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectClass", 2);
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_ObjectClassDefn(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ObjectClass", 3);
{LLSTATE llstate_1;
if (!ll_ParameterizedObjectClass(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectClass");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectClass", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectClass", 0);
return 0;
}

int ll_ObjectClassDefn(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectClassDefn");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_CLASS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XFieldSpecs llatt_3;
if (!ll_FieldSpec_List(&llatt_3, &llstate_2, &llstate_3, llarg_oc)) goto failed1;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
{LLSTATE llstate_5;XSyntaxSpecs llatt_5;
if (!ll_WithSyntaxSpec_opt(&llatt_5, &llstate_4, &llstate_5, llarg_oc)) goto failed1;
*llout = llstate_5;
{ObjectClass_t *oc;
	    oc = NewObjectClass(eObjectClass_ObjectClass);
	    oc->U.ObjectClass.FieldSpec = llatt_3;
	    oc->U.ObjectClass.SyntaxSpec = llatt_5;
	    (*llret) = oc;
	
}}}}}}
LLDEBUG_LEAVE("ObjectClassDefn", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectClassDefn", 0);
return 0;
}

int ll_FieldSpec_List(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldSpec_List");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_FieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XFieldSpecs llatt_2;
if (!ll_FieldSpec_EList(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
*llout = llstate_2;
{if (llatt_1) {
		if (llatt_2) {
		    (*llret) = DupFieldSpec(llatt_1);
		    (*llret)->Next = llatt_2;
		} else {
		    (*llret) = llatt_1;
		}
	    } else {
		(*llret) = llatt_2;
	    }
	
}}}
LLDEBUG_LEAVE("FieldSpec_List", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldSpec_List", 0);
return 0;
}

int ll_FieldSpec_EList(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldSpec_EList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("FieldSpec_EList", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XFieldSpecs llatt_2;
if (!ll_FieldSpec(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed2;
{LLSTATE llstate_3;XFieldSpecs llatt_3;
if (!ll_FieldSpec_EList(&llatt_3, &llstate_2, &llstate_3, llarg_oc)) goto failed2;
*llout = llstate_3;
{if (llatt_2) {
		if (llatt_3) {
		    (*llret) = DupFieldSpec(llatt_2);
		    (*llret)->Next = llatt_3;
		} else {
		    (*llret) = llatt_2;
		}
	    } else {
		(*llret) = llatt_3;
	    }
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("FieldSpec_EList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("FieldSpec_EList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("FieldSpec_EList", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldSpec_EList", 0);
return 0;
}

int ll_WithSyntaxSpec_opt(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("WithSyntaxSpec_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("WithSyntaxSpec_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_WITH, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_SYNTAX, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XSyntaxSpecs llatt_3;
if (!ll_SyntaxList(&llatt_3, &llstate_2, &llstate_3, llarg_oc)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_3;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("WithSyntaxSpec_opt", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("WithSyntaxSpec_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("WithSyntaxSpec_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("WithSyntaxSpec_opt", 0);
return 0;
}

int ll_FieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("FieldSpec", 1);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_TypeFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("FieldSpec", 2);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_FixedTypeValueFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("FieldSpec", 3);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_VariableTypeValueFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("FieldSpec", 4);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_FixedTypeValueSetFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("FieldSpec", 5);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_VariableTypeValueSetFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("FieldSpec", 6);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_ObjectFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("FieldSpec", 7);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_ObjectSetFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("FieldSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("FieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldSpec", 0);
return 0;
}

int ll_TypeFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_typefieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XOptionality llatt_2;
if (!ll_TypeOptionalitySpec_opt(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = NewFieldSpec(eFieldSpec_Type);
	    (*llret)->Identifier = llatt_1;
	    (*llret)->U.Type.Optionality = llatt_2;
	
}}}
LLDEBUG_LEAVE("TypeFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeFieldSpec", 0);
return 0;
}

int ll_TypeOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeOptionalitySpec_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TypeOptionalitySpec_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewOptionality(eOptionality_Optional);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TypeOptionalitySpec_opt", 2);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewOptionality(eOptionality_Default_Type);
	    (*llret)->U.Type = llatt_2;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("TypeOptionalitySpec_opt", 3);
*llout = llstate_0;
{(*llret) = NewOptionality(eOptionality_Normal);
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TypeOptionalitySpec_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TypeOptionalitySpec_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeOptionalitySpec_opt", 0);
return 0;
}

int ll_FixedTypeValueFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FixedTypeValueFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_valuefieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XBoolean llatt_3;
if (!ll_UNIQUE_opt(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XOptionality llatt_4;
if (!ll_ValueOptionalitySpec_opt(&llatt_4, &llstate_3, &llstate_4, llatt_2)) goto failed1;
*llout = llstate_4;
{if (GetType((*llout).Assignments, llatt_2)) {
		(*llret) = NewFieldSpec(eFieldSpec_FixedTypeValue);
		(*llret)->Identifier = llatt_1;
		(*llret)->U.FixedTypeValue.Type = llatt_2;
		(*llret)->U.FixedTypeValue.Unique = llatt_3;
		(*llret)->U.FixedTypeValue.Optionality = llatt_4;
	    } else {
		(*llret) = NULL;
	    }
	
}}}}}
LLDEBUG_LEAVE("FixedTypeValueFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("FixedTypeValueFieldSpec", 0);
return 0;
}

int ll_UNIQUE_opt(XBoolean *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UNIQUE_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UNIQUE_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_UNIQUE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UNIQUE_opt", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UNIQUE_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UNIQUE_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("UNIQUE_opt", 0);
return 0;
}

int ll_ValueOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueOptionalitySpec_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ValueOptionalitySpec_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewOptionality(eOptionality_Optional);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ValueOptionalitySpec_opt", 2);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_Value(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{(*llret) = NewOptionality(eOptionality_Default_Value);
	    (*llret)->U.Value = llatt_2;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ValueOptionalitySpec_opt", 3);
*llout = llstate_0;
{(*llret) = NewOptionality(eOptionality_Normal);
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ValueOptionalitySpec_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ValueOptionalitySpec_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueOptionalitySpec_opt", 0);
return 0;
}

int ll_VariableTypeValueFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("VariableTypeValueFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_valuefieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XStrings llatt_2;
if (!ll_FieldName(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
{Type_t *deftype;
	    FieldSpec_t *fs, *deffs;
	    fs = GetFieldSpecFromObjectClass(llstate_2.Assignments, llarg_oc, llatt_2);
	    deffs = GetFieldSpec(llstate_2.Assignments, fs);
	    if (deffs &&
		deffs->Type == eFieldSpec_Type &&
		deffs->U.Type.Optionality->Type == eOptionality_Default_Type)
		deftype = deffs->U.Type.Optionality->U.Type;
	    else
		deftype = NULL;
	
{LLSTATE llstate_3;XOptionality llatt_3;
if (!ll_ValueOptionalitySpec_opt(&llatt_3, &llstate_2, &llstate_3, deftype)) goto failed1;
*llout = llstate_3;
{(*llret) = NewFieldSpec(eFieldSpec_VariableTypeValue);
	    (*llret)->Identifier = llatt_1;
	    (*llret)->U.VariableTypeValue.Fields = llatt_2;
	    (*llret)->U.VariableTypeValue.Optionality = llatt_3;
	
}}}}}
LLDEBUG_LEAVE("VariableTypeValueFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("VariableTypeValueFieldSpec", 0);
return 0;
}

int ll_FixedTypeValueSetFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FixedTypeValueSetFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_valuesetfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XOptionality llatt_3;
if (!ll_ValueSetOptionalitySpec_opt(&llatt_3, &llstate_2, &llstate_3, llatt_2)) goto failed1;
*llout = llstate_3;
{if (GetType((*llout).Assignments, llatt_2)) {
		(*llret) = NewFieldSpec(eFieldSpec_FixedTypeValueSet);
		(*llret)->Identifier = llatt_1;
		(*llret)->U.FixedTypeValueSet.Type = llatt_2;
		(*llret)->U.FixedTypeValueSet.Optionality = llatt_3;
	    } else {
		(*llret) = NULL;
	    }
	
}}}}
LLDEBUG_LEAVE("FixedTypeValueSetFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("FixedTypeValueSetFieldSpec", 0);
return 0;
}

int ll_ValueSetOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueSetOptionalitySpec_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ValueSetOptionalitySpec_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewOptionality(eOptionality_Optional);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ValueSetOptionalitySpec_opt", 2);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XValueSet llatt_2;
if (!ll_ValueSet(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{(*llret) = NewOptionality(eOptionality_Default_ValueSet);
	    (*llret)->U.ValueSet = llatt_2;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ValueSetOptionalitySpec_opt", 3);
*llout = llstate_0;
{(*llret) = NewOptionality(eOptionality_Normal);
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ValueSetOptionalitySpec_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ValueSetOptionalitySpec_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueSetOptionalitySpec_opt", 0);
return 0;
}

int ll_VariableTypeValueSetFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("VariableTypeValueSetFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_valuesetfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XStrings llatt_2;
if (!ll_FieldName(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
{Type_t *deftype;
	    FieldSpec_t *fs, *deffs;
	    fs = GetFieldSpecFromObjectClass(llstate_2.Assignments, llarg_oc, llatt_2);
	    deffs = GetFieldSpec(llstate_2.Assignments, fs);
	    if (deffs &&
		deffs->Type == eFieldSpec_Type &&
		deffs->U.Type.Optionality->Type == eOptionality_Default_Type)
		deftype = deffs->U.Type.Optionality->U.Type;
	    else
		deftype = NULL;
	
{LLSTATE llstate_3;XOptionality llatt_3;
if (!ll_ValueSetOptionalitySpec_opt(&llatt_3, &llstate_2, &llstate_3, deftype)) goto failed1;
*llout = llstate_3;
{(*llret) = NewFieldSpec(eFieldSpec_VariableTypeValueSet);
	    (*llret)->Identifier = llatt_1;
	    (*llret)->U.VariableTypeValueSet.Fields = llatt_2;
	    (*llret)->U.VariableTypeValueSet.Optionality = llatt_3;
	
}}}}}
LLDEBUG_LEAVE("VariableTypeValueSetFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("VariableTypeValueSetFieldSpec", 0);
return 0;
}

int ll_ObjectFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_objectfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XObjectClass llatt_2;
if (!ll_DefinedObjectClass(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XOptionality llatt_3;
if (!ll_ObjectOptionalitySpec_opt(&llatt_3, &llstate_2, &llstate_3, llatt_2)) goto failed1;
*llout = llstate_3;
{if (GetObjectClass((*llout).Assignments, llatt_2)) {
		(*llret) = NewFieldSpec(eFieldSpec_Object);
		(*llret)->Identifier = llatt_1;
		(*llret)->U.Object.ObjectClass = llatt_2;
		(*llret)->U.Object.Optionality = llatt_3;
	    } else {
		(*llret) = NULL;
	    }
	
}}}}
LLDEBUG_LEAVE("ObjectFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectFieldSpec", 0);
return 0;
}

int ll_ObjectOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectOptionalitySpec_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectOptionalitySpec_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewOptionality(eOptionality_Optional);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectOptionalitySpec_opt", 2);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XObject llatt_2;
if (!ll_Object(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed2;
*llout = llstate_2;
{(*llret) = NewOptionality(eOptionality_Default_Object);
	    (*llret)->U.Object = llatt_2;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ObjectOptionalitySpec_opt", 3);
*llout = llstate_0;
{(*llret) = NewOptionality(eOptionality_Normal);
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectOptionalitySpec_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectOptionalitySpec_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectOptionalitySpec_opt", 0);
return 0;
}

int ll_ObjectSetFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSetFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_objectsetfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XObjectClass llatt_2;
if (!ll_DefinedObjectClass(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XOptionality llatt_3;
if (!ll_ObjectSetOptionalitySpec_opt(&llatt_3, &llstate_2, &llstate_3, llatt_2)) goto failed1;
*llout = llstate_3;
{if (GetObjectClass((*llout).Assignments, llatt_2)) {
		(*llret) = NewFieldSpec(eFieldSpec_ObjectSet);
		(*llret)->Identifier = llatt_1;
		(*llret)->U.ObjectSet.ObjectClass = llatt_2;
		(*llret)->U.ObjectSet.Optionality = llatt_3;
	    } else {
		(*llret) = NULL;
	    }
	
}}}}
LLDEBUG_LEAVE("ObjectSetFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSetFieldSpec", 0);
return 0;
}

int ll_ObjectSetOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSetOptionalitySpec_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectSetOptionalitySpec_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewOptionality(eOptionality_Optional);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectSetOptionalitySpec_opt", 2);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XObjectSet llatt_2;
if (!ll_ObjectSet(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed2;
*llout = llstate_2;
{(*llret) = NewOptionality(eOptionality_Default_ObjectSet);
	    (*llret)->U.ObjectSet = llatt_2;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ObjectSetOptionalitySpec_opt", 3);
*llout = llstate_0;
{(*llret) = NewOptionality(eOptionality_Normal);
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectSetOptionalitySpec_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectSetOptionalitySpec_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSetOptionalitySpec_opt", 0);
return 0;
}

int ll_PrimitiveFieldName(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrimitiveFieldName");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrimitiveFieldName", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_typefieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrimitiveFieldName", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_valuefieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("PrimitiveFieldName", 3);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_valuesetfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("PrimitiveFieldName", 4);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_objectfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("PrimitiveFieldName", 5);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_objectsetfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrimitiveFieldName");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrimitiveFieldName", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrimitiveFieldName", 0);
return 0;
}

int ll_FieldName(XStrings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldName");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("FieldName", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_objectfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{FieldSpec_t *fs;
	    ObjectClass_t *oc;
	    fs = GetObjectClassField(llstate_2.Assignments, llarg_oc, llatt_1);
	    if (fs)
		oc = fs->U.Object.ObjectClass;
	    else
		oc = NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed2;
*llout = llstate_3;
{(*llret) = NewString();
	    (*llret)->String = llatt_1;
	    (*llret)->Next = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("FieldName", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_objectsetfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{FieldSpec_t *fs;
	    ObjectClass_t *oc;
	    fs = GetObjectClassField(llstate_2.Assignments, llarg_oc, llatt_1);
	    if (fs)
		oc = fs->U.ObjectSet.ObjectClass;
	    else
		oc = NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed2;
*llout = llstate_3;
{(*llret) = NewString();
	    (*llret)->String = llatt_1;
	    (*llret)->Next = llatt_3;
	
break;
}}}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("FieldName", 3);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_PrimitiveFieldName(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = NewString();
	    (*llret)->String = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("FieldName");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("FieldName", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldName", 0);
return 0;
}

int ll_SyntaxList(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SyntaxList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XSyntaxSpecs llatt_2;
if (!ll_TokenOrGroupSpec_Seq(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = llatt_2;
	
}}}}
LLDEBUG_LEAVE("SyntaxList", 1);
return 1;
failed1: LLDEBUG_LEAVE("SyntaxList", 0);
return 0;
}

int ll_TokenOrGroupSpec_Seq(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TokenOrGroupSpec_Seq");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XSyntaxSpecs llatt_1;
if (!ll_TokenOrGroupSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XSyntaxSpecs llatt_2;
if (!ll_TokenOrGroupSpec_ESeq(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
*llout = llstate_2;
{(*llret) = DupSyntaxSpec(llatt_1);
	    (*llret)->Next = llatt_2;
	
}}}
LLDEBUG_LEAVE("TokenOrGroupSpec_Seq", 1);
return 1;
failed1: LLDEBUG_LEAVE("TokenOrGroupSpec_Seq", 0);
return 0;
}

int ll_TokenOrGroupSpec_ESeq(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TokenOrGroupSpec_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TokenOrGroupSpec_ESeq", 1);
{LLSTATE llstate_1;XSyntaxSpecs llatt_1;
if (!ll_TokenOrGroupSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
{LLSTATE llstate_2;XSyntaxSpecs llatt_2;
if (!ll_TokenOrGroupSpec_ESeq(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed2;
*llout = llstate_2;
{(*llret) = DupSyntaxSpec(llatt_1);
	    (*llret)->Next = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TokenOrGroupSpec_ESeq", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TokenOrGroupSpec_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TokenOrGroupSpec_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("TokenOrGroupSpec_ESeq", 0);
return 0;
}

int ll_TokenOrGroupSpec(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TokenOrGroupSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TokenOrGroupSpec", 1);
{LLSTATE llstate_1;XSyntaxSpecs llatt_1;
if (!ll_RequiredToken(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TokenOrGroupSpec", 2);
{LLSTATE llstate_1;XSyntaxSpecs llatt_1;
if (!ll_OptionalGroup(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TokenOrGroupSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TokenOrGroupSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("TokenOrGroupSpec", 0);
return 0;
}

int ll_OptionalGroup(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("OptionalGroup");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('[', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XSyntaxSpecs llatt_2;
if (!ll_TokenOrGroupSpec_Seq(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(']', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = NewSyntaxSpec(eSyntaxSpec_Optional);
	    (*llret)->U.Optional.SyntaxSpec = llatt_2;
	
}}}}
LLDEBUG_LEAVE("OptionalGroup", 1);
return 1;
failed1: LLDEBUG_LEAVE("OptionalGroup", 0);
return 0;
}

int ll_RequiredToken(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("RequiredToken");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("RequiredToken", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_Literal(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewSyntaxSpec(eSyntaxSpec_Literal);
	    (*llret)->U.Literal.Literal = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("RequiredToken", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_PrimitiveFieldName(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = NewSyntaxSpec(eSyntaxSpec_Field);
	    (*llret)->U.Field.Field = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("RequiredToken");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("RequiredToken", 1);
return 1;
failed1: LLDEBUG_LEAVE("RequiredToken", 0);
return 0;
}

int ll_Literal(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Literal");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Literal", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_word(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Literal", 2);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = ",";
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Literal");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Literal", 1);
return 1;
failed1: LLDEBUG_LEAVE("Literal", 0);
return 0;
}

int ll_ObjectAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_objectreference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XObjectClass llatt_2;
if (!ll_DefinedObjectClass(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XObject llatt_4;
if (!ll_Object(&llatt_4, &llstate_3, &llstate_4, llatt_2)) goto failed1;
*llout = llstate_4;
{AssignObject(&(*llout).Assignments, llatt_1, llatt_4);
	
}}}}}
LLDEBUG_LEAVE("ObjectAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectAssignment", 0);
return 0;
}

int ll_Object(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Object");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Object", 1);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ObjectDefn(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Object", 2);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ObjectFromObject(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("Object", 3);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_DefinedObject(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("Object", 4);
{LLSTATE llstate_1;
if (!ll_ParameterizedObject(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Object");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Object", 1);
return 1;
failed1: LLDEBUG_LEAVE("Object", 0);
return 0;
}

int ll_ObjectDefn(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectDefn");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectDefn", 1);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_DefaultSyntax(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectDefn", 2);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_DefinedSyntax(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectDefn");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectDefn", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectDefn", 0);
return 0;
}

int ll_DefaultSyntax(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefaultSyntax");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XSettings llatt_2;
if (!ll_FieldSetting_EList(&llatt_2, &llstate_1, &llstate_2, llarg_oc, NULL)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = NewObject(eObject_Object);
	    (*llret)->U.Object.ObjectClass = llarg_oc;
	    (*llret)->U.Object.Settings = llatt_2;
	
}}}}
LLDEBUG_LEAVE("DefaultSyntax", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefaultSyntax", 0);
return 0;
}

int ll_FieldSetting_EList(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldSetting_EList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("FieldSetting_EList", 1);
{LLSTATE llstate_1;XSettings llatt_1;
if (!ll_FieldSetting(&llatt_1, &llstate_0, &llstate_1, llarg_oc, llarg_se)) goto failed2;
{Setting_t *s, **ss, *se;
	    for (s = llatt_1, ss = &se; s; s = s->Next, ss = &(*ss)->Next)
		*ss = DupSetting(s);
	    *ss = llarg_se;
	
{LLSTATE llstate_2;XSettings llatt_2;
if (!ll_FieldSetting_EListC(&llatt_2, &llstate_1, &llstate_2, llarg_oc, se)) goto failed2;
*llout = llstate_2;
{for (s = llatt_1, ss = &(*llret); s; s = s->Next, ss = &(*ss)->Next)
		*ss = DupSetting(s);
	    *ss = llatt_2;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("FieldSetting_EList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("FieldSetting_EList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("FieldSetting_EList", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldSetting_EList", 0);
return 0;
}

int ll_FieldSetting_EListC(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldSetting_EListC");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("FieldSetting_EListC", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XSettings llatt_2;
if (!ll_FieldSetting(&llatt_2, &llstate_1, &llstate_2, llarg_oc, llarg_se)) goto failed2;
{Setting_t *s, **ss, *se;
	    for (s = llatt_2, ss = &se; s; s = s->Next, ss = &(*ss)->Next)
		*ss = DupSetting(s);
	    *ss = llarg_se;
	
{LLSTATE llstate_3;XSettings llatt_3;
if (!ll_FieldSetting_EListC(&llatt_3, &llstate_2, &llstate_3, llarg_oc, se)) goto failed2;
*llout = llstate_3;
{for (s = llatt_2, ss = &(*llret); s; s = s->Next, ss = &(*ss)->Next)
		*ss = DupSetting(s);
	    *ss = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("FieldSetting_EListC", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("FieldSetting_EListC");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("FieldSetting_EListC", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldSetting_EListC", 0);
return 0;
}

int ll_FieldSetting(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldSetting");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_PrimitiveFieldName(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XSettings llatt_2;
if (!ll_Setting(&llatt_2, &llstate_1, &llstate_2, llarg_oc, llarg_se, llatt_1)) goto failed1;
*llout = llstate_2;
{(*llret) = llatt_2;
	
}}}
LLDEBUG_LEAVE("FieldSetting", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldSetting", 0);
return 0;
}

int ll_DefinedSyntax(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedSyntax");

llstate_0 = *llin;
#undef failed
#define failed failed1
{ObjectClass_t *oc;
	    SyntaxSpec_t *sy;
	    oc = GetObjectClass((*llin).Assignments, llarg_oc);
	    if (oc && !oc->U.ObjectClass.SyntaxSpec)
		LLFAILED((&llstate_0.pos, "Bad settings"));
	    sy = oc ? oc->U.ObjectClass.SyntaxSpec : UndefSyntaxSpecs;
	
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XSettings llatt_2;
if (!ll_DefinedSyntaxToken_ESeq(&llatt_2, &llstate_1, &llstate_2, llarg_oc, NULL, sy)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = NewObject(eObject_Object);
	    (*llret)->U.Object.ObjectClass = llarg_oc;
	    (*llret)->U.Object.Settings = llatt_2;
	
}}}}}
LLDEBUG_LEAVE("DefinedSyntax", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedSyntax", 0);
return 0;
}

int ll_DefinedSyntaxToken_ESeq(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XSyntaxSpecs llarg_sy)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedSyntaxToken_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken_ESeq", 1);
{if (!llarg_sy)
		LLFAILED((&llstate_0.pos, "Bad settings"));
	
{LLSTATE llstate_1;XSettings llatt_1;
if (!ll_DefinedSyntaxToken(&llatt_1, &llstate_0, &llstate_1, llarg_oc, llarg_se, llarg_sy)) goto failed2;
{Setting_t *s, **ss, *se;
	    for (s = llatt_1, ss = &se; s; s = s->Next, ss = &(*ss)->Next)
		*ss = DupSetting(s);
	    *ss = llarg_se;
	
{LLSTATE llstate_2;XSettings llatt_2;
if (!ll_DefinedSyntaxToken_ESeq(&llatt_2, &llstate_1, &llstate_2, llarg_oc, se, DEFINED(llarg_sy) ? llarg_sy->Next : llarg_sy)) goto failed2;
*llout = llstate_2;
{for (s = llatt_1, ss = &(*llret); s; s = s->Next, ss = &(*ss)->Next)
		*ss = DupSetting(s);
	    *ss = llatt_2;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken_ESeq", 2);
*llout = llstate_0;
{if (DEFINED(llarg_sy))
		LLFAILED((&llstate_0.pos, "Bad settings"));
	    (*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedSyntaxToken_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedSyntaxToken_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedSyntaxToken_ESeq", 0);
return 0;
}

int ll_DefinedSyntaxToken(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XSyntaxSpecs llarg_sy)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedSyntaxToken");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken", 1);
{if (!DEFINED(llarg_sy) || llarg_sy->Type != eSyntaxSpec_Optional)
		LLFAILED((&llstate_0.pos, "Bad settings"));
	
{LLSTATE llstate_1;XSettings llatt_1;
if (!ll_DefinedSyntaxToken_ESeq(&llatt_1, &llstate_0, &llstate_1, llarg_oc, llarg_se, llarg_sy->U.Optional.SyntaxSpec)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken", 2);
*llout = llstate_0;
{if (!DEFINED(llarg_sy) || llarg_sy->Type != eSyntaxSpec_Optional)
		LLFAILED((&llstate_0.pos, "Bad settings"));
	
{(*llret) = NULL;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken", 3);
{if (DEFINED(llarg_sy) && llarg_sy->Type == eSyntaxSpec_Optional)
		LLFAILED((&llstate_0.pos, "Bad settings"));
	
{LLSTATE llstate_1;XSettings llatt_1;
if (!ll_DefinedSyntaxToken_Elem(&llatt_1, &llstate_0, &llstate_1, llarg_oc, llarg_se, llarg_sy)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedSyntaxToken");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedSyntaxToken", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedSyntaxToken", 0);
return 0;
}

int ll_DefinedSyntaxToken_Elem(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XSyntaxSpecs llarg_sy)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedSyntaxToken_Elem");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken_Elem", 1);
{if (!llarg_sy || (DEFINED(llarg_sy) && llarg_sy->Type != eSyntaxSpec_Literal))
		LLFAILED((&llstate_0.pos, "Bad settings"));
	
{LLSTATE llstate_1;XString llatt_1;
if (!ll_Literal(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{if (DEFINED(llarg_sy) && strcmp(llarg_sy->U.Literal.Literal, llatt_1))
		LLFAILED((&llstate_0.pos, "Bad settings"));
	    (*llret) = NULL;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken_Elem", 2);
{if (!llarg_sy || (DEFINED(llarg_sy) && llarg_sy->Type != eSyntaxSpec_Field))
		LLFAILED((&llstate_0.pos, "Bad settings"));
	
{LLSTATE llstate_1;XSettings llatt_1;
if (!ll_Setting(&llatt_1, &llstate_0, &llstate_1, llarg_oc, llarg_se, DEFINED(llarg_sy) ? llarg_sy->U.Field.Field : NULL)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedSyntaxToken_Elem");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedSyntaxToken_Elem", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedSyntaxToken_Elem", 0);
return 0;
}

int ll_Setting(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XString llarg_f)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Setting");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Setting", 1);
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetObjectClassField((*llin).Assignments, llarg_oc, llarg_f);
	    fe = GetFieldSpecType((*llin).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_Type)
		LLFAILED((&llstate_0.pos, "Bad setting"));
	
{LLSTATE llstate_1;XType llatt_1;
if (!ll_Type(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewSetting(eSetting_Type);
	    (*llret)->Identifier = llarg_f;
	    (*llret)->U.Type.Type = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Setting", 2);
{Type_t *type;
	    FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    Setting_t *se;
	    fs = GetObjectClassField((*llin).Assignments, llarg_oc, llarg_f);
	    fe = GetFieldSpecType((*llin).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_FixedTypeValue &&
		fe != eFieldSpec_VariableTypeValue)
		LLFAILED((&llstate_0.pos, "Bad setting"));
	    if (fe == eFieldSpec_FixedTypeValue) {
		type = fs->U.FixedTypeValue.Type;
	    } else if (fe == eFieldSpec_VariableTypeValue) {
		se = GetSettingFromSettings((*llin).Assignments, llarg_se,
		    fs->U.VariableTypeValue.Fields);
		if (GetSettingType(se) != eSetting_Type &&
		    GetSettingType(se) != eSetting_Undefined)
		    MyAbort();
		if (GetSettingType(se) == eSetting_Type)
		    type = se->U.Type.Type;
		else
		    type = NULL;
	    } else {
		type = NULL;
	    }
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_Value(&llatt_1, &llstate_0, &llstate_1, type)) goto failed2;
*llout = llstate_1;
{if (type) {
		(*llret) = NewSetting(eSetting_Value);
		(*llret)->Identifier = llarg_f;
		(*llret)->U.Value.Value = llatt_1;
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("Setting", 3);
{Type_t *type;
	    FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    Setting_t *se;
	    fs = GetObjectClassField((*llin).Assignments, llarg_oc, llarg_f);
	    fe = GetFieldSpecType((*llin).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_FixedTypeValueSet &&
		fe != eFieldSpec_VariableTypeValueSet)
		LLFAILED((&llstate_0.pos, "Bad setting"));
	    if (fe == eFieldSpec_FixedTypeValueSet) {
		type = fs->U.FixedTypeValueSet.Type;
	    } else if (fe == eFieldSpec_VariableTypeValueSet) {
		se = GetSettingFromSettings((*llin).Assignments, llarg_se,
		    fs->U.VariableTypeValueSet.Fields);
		if (GetSettingType(se) != eSetting_Type &&
		    GetSettingType(se) != eSetting_Undefined)
		    MyAbort();
		if (GetSettingType(se) == eSetting_Type)
		    type = se->U.Type.Type;
		else
		    type = NULL;
	    } else {
		type = NULL;
	    }
	
{LLSTATE llstate_1;XValueSet llatt_1;
if (!ll_ValueSet(&llatt_1, &llstate_0, &llstate_1, type)) goto failed2;
*llout = llstate_1;
{if (type) {
		(*llret) = NewSetting(eSetting_ValueSet);
		(*llret)->Identifier = llarg_f;
		(*llret)->U.ValueSet.ValueSet = llatt_1;
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("Setting", 4);
{ObjectClass_t *oc;
	    FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetObjectClassField((*llin).Assignments, llarg_oc, llarg_f);
	    fe = GetFieldSpecType((*llin).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_Object)
		LLFAILED((&llstate_0.pos, "Bad setting"));
	    if (fe == eFieldSpec_Object)
		oc = fs->U.Object.ObjectClass;
	    else
		oc = NULL;
	
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_Object(&llatt_1, &llstate_0, &llstate_1, oc)) goto failed2;
*llout = llstate_1;
{(*llret) = NewSetting(eSetting_Object);
	    (*llret)->Identifier = llarg_f;
	    (*llret)->U.Object.Object = llatt_1;
	
break;
}}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("Setting", 5);
{ObjectClass_t *oc;
	    FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetObjectClassField((*llin).Assignments, llarg_oc, llarg_f);
	    fe = GetFieldSpecType((*llin).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_ObjectSet)
		LLFAILED((&llstate_0.pos, "Bad setting"));
	    if (fe == eFieldSpec_ObjectSet)
		oc = fs->U.ObjectSet.ObjectClass;
	    else
		oc = NULL;
	
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_ObjectSet(&llatt_1, &llstate_0, &llstate_1, oc)) goto failed2;
*llout = llstate_1;
{(*llret) = NewSetting(eSetting_ObjectSet);
	    (*llret)->Identifier = llarg_f;
	    (*llret)->U.ObjectSet.ObjectSet = llatt_1;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Setting");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Setting", 1);
return 1;
failed1: LLDEBUG_LEAVE("Setting", 0);
return 0;
}

int ll_ObjectSetAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSetAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_objectsetreference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XObjectClass llatt_2;
if (!ll_DefinedObjectClass(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XObjectSet llatt_4;
if (!ll_ObjectSet(&llatt_4, &llstate_3, &llstate_4, llatt_2)) goto failed1;
*llout = llstate_4;
{AssignObjectSet(&(*llout).Assignments, llatt_1, llatt_4);
	
}}}}}
LLDEBUG_LEAVE("ObjectSetAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSetAssignment", 0);
return 0;
}

int ll_ObjectSet(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSet");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XObjectSet llatt_2;
if (!ll_ObjectSetSpec(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = llatt_2;
	
}}}}
LLDEBUG_LEAVE("ObjectSet", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSet", 0);
return 0;
}

int ll_ObjectSetSpec(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSetSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectSetSpec", 1);
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_ElementSetSpec(&llatt_1, &llstate_0, &llstate_1, NULL, llarg_oc, 0)) goto failed2;
*llout = llstate_1;
{(*llret) = NewObjectSet(eObjectSet_ObjectSet);
	    (*llret)->U.ObjectSet.ObjectClass = llarg_oc;
	    (*llret)->U.ObjectSet.Elements = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectSetSpec", 2);
{LLSTATE llstate_1;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewObjectSet(eObjectSet_ExtensionMarker);
	    (*llret)->U.ExtensionMarker.ObjectClass = llarg_oc;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectSetSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectSetSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSetSpec", 0);
return 0;
}

int ll_ObjectSetElements(XObjectSetElement *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSetElements");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectSetElements", 1);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_ObjectSetFromObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewObjectSetElement(eObjectSetElement_ObjectSet);
	    (*llret)->U.ObjectSet.ObjectSet = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectSetElements", 2);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_Object(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = NewObjectSetElement(eObjectSetElement_Object);
	    (*llret)->U.Object.Object = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ObjectSetElements", 3);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_DefinedObjectSet(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewObjectSetElement(eObjectSetElement_ObjectSet);
	    (*llret)->U.ObjectSet.ObjectSet = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("ObjectSetElements", 4);
{LLSTATE llstate_1;
if (!ll_ParameterizedObjectSet(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectSetElements");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectSetElements", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSetElements", 0);
return 0;
}

int ll_ObjectClassFieldType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectClassFieldType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_DefinedObjectClass(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, llatt_1)) goto failed1;
*llout = llstate_3;
{FieldSpec_t *fs;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, llatt_1, llatt_3);
	    if (!fs) {
		(*llret) = NewType(eType_Undefined);
	    } else {
		switch (fs->Type) {
		case eFieldSpec_Type:
		case eFieldSpec_VariableTypeValue:
		case eFieldSpec_VariableTypeValueSet:
		    (*llret) = NewType(eType_Open);
		    break;
		case eFieldSpec_FixedTypeValue:
		    (*llret) = fs->U.FixedTypeValue.Type;
		    break;
		case eFieldSpec_FixedTypeValueSet:
		    (*llret) = fs->U.FixedTypeValueSet.Type;
		    break;
		case eFieldSpec_Object:
		    LLFAILED((&llstate_1.pos, "Object field not permitted"));
		    /*NOTREACHED*/
		case eFieldSpec_ObjectSet:
		    LLFAILED((&llstate_1.pos, "ObjectSet field not permitted"));
		    /*NOTREACHED*/
		default:
		    MyAbort();
		}
	    }
	
}}}}
LLDEBUG_LEAVE("ObjectClassFieldType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectClassFieldType", 0);
return 0;
}

int ll_ObjectClassFieldValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectClassFieldValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectClassFieldValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_OpenTypeFieldVal(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectClassFieldValue", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_FixedTypeFieldVal(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectClassFieldValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectClassFieldValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectClassFieldValue", 0);
return 0;
}

int ll_OpenTypeFieldVal(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("OpenTypeFieldVal");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XType llatt_1;
if (!ll_Type(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(':', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_Value(&llatt_3, &llstate_2, &llstate_3, llatt_1)) goto failed1;
*llout = llstate_3;
{(*llret) = llatt_3;
	
}}}}
LLDEBUG_LEAVE("OpenTypeFieldVal", 1);
return 1;
failed1: LLDEBUG_LEAVE("OpenTypeFieldVal", 0);
return 0;
}

int ll_FixedTypeFieldVal(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FixedTypeFieldVal");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("FixedTypeFieldVal", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_BuiltinValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("FixedTypeFieldVal", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ReferencedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("FixedTypeFieldVal");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("FixedTypeFieldVal", 1);
return 1;
failed1: LLDEBUG_LEAVE("FixedTypeFieldVal", 0);
return 0;
}

int ll_ValueFromObject(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueFromObject");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ReferencedObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{Object_t *o;
	    ObjectClass_t *oc;
	    o = GetObject(llstate_2.Assignments, llatt_1);
	    oc = o ? o->U.Object.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed1;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_FixedTypeValue &&
		fe != eFieldSpec_VariableTypeValue)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined) {
		(*llret) = GetValueFromObject((*llout).Assignments, llatt_1, llatt_3);
	    } else {
		(*llret) = NULL;
	    }
	
}}}}}
LLDEBUG_LEAVE("ValueFromObject", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueFromObject", 0);
return 0;
}

int ll_ValueSetFromObjects(XValueSet *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueSetFromObjects");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ValueSetFromObjects", 1);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ReferencedObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{Object_t *o;
	    ObjectClass_t *oc;
	    o = GetObject(llstate_2.Assignments, llatt_1);
	    oc = o ? o->U.Object.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed2;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_FixedTypeValueSet &&
		fe != eFieldSpec_VariableTypeValueSet)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined) {
		(*llret) = GetValueSetFromObject((*llout).Assignments, llatt_1, llatt_3);
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ValueSetFromObjects", 2);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_ReferencedObjectSets(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{ObjectSet_t *os;
	    ObjectClass_t *oc;
	    os = GetObjectSet(llstate_2.Assignments, llatt_1);
	    oc = os && os->Type == eObjectSet_ObjectSet ?
	    	os->U.ObjectSet.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed2;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_FixedTypeValue &&
		fe != eFieldSpec_FixedTypeValueSet)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined) {
		(*llret) = GetValueSetFromObjectSet((*llout).Assignments, llatt_1, llatt_3);
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ValueSetFromObjects");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ValueSetFromObjects", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueSetFromObjects", 0);
return 0;
}

int ll_TypeFromObject(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeFromObject");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ReferencedObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{Object_t *o;
	    ObjectClass_t *oc;
	    o = GetObject(llstate_2.Assignments, llatt_1);
	    oc = o ? o->U.Object.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed1;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_Type)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined)
		(*llret) = GetTypeFromObject((*llout).Assignments, llatt_1, llatt_3);
	    else
		(*llret) = NULL;
	
}}}}}
LLDEBUG_LEAVE("TypeFromObject", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeFromObject", 0);
return 0;
}

int ll_ObjectFromObject(XObject *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectFromObject");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ReferencedObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{Object_t *o;
	    ObjectClass_t *oc;
	    o = GetObject(llstate_2.Assignments, llatt_1);
	    oc = o ? o->U.Object.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed1;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_Object)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined)
		(*llret) = GetObjectFromObject((*llout).Assignments, llatt_1, llatt_3);
	    else
		(*llret) = NULL;
	
}}}}}
LLDEBUG_LEAVE("ObjectFromObject", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectFromObject", 0);
return 0;
}

int ll_ObjectSetFromObjects(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSetFromObjects");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectSetFromObjects", 1);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ReferencedObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{Object_t *o;
	    ObjectClass_t *oc;
	    o = GetObject(llstate_2.Assignments, llatt_1);
	    oc = o ? o->U.Object.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed2;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_ObjectSet)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined)
		(*llret) = GetObjectSetFromObject((*llout).Assignments, llatt_1, llatt_3);
	    else
		(*llret) = NULL;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectSetFromObjects", 2);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_ReferencedObjectSets(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{ObjectSet_t *os;
	    ObjectClass_t *oc;
	    os = GetObjectSet(llstate_2.Assignments, llatt_1);
	    oc = os ? os->U.OE.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed2;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_Object &&
		fe != eFieldSpec_ObjectSet)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined)
		(*llret) = GetObjectSetFromObjectSet((*llout).Assignments, llatt_1, llatt_3);
	    else
		(*llret) = NULL;
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectSetFromObjects");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectSetFromObjects", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSetFromObjects", 0);
return 0;
}

int ll_ReferencedObjects(XObject *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ReferencedObjects");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ReferencedObjects", 1);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_DefinedObject(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ReferencedObjects", 2);
{LLSTATE llstate_1;
if (!ll_ParameterizedObject(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ReferencedObjects");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ReferencedObjects", 1);
return 1;
failed1: LLDEBUG_LEAVE("ReferencedObjects", 0);
return 0;
}

int ll_ReferencedObjectSets(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ReferencedObjectSets");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ReferencedObjectSets", 1);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_DefinedObjectSet(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ReferencedObjectSets", 2);
{LLSTATE llstate_1;
if (!ll_ParameterizedObjectSet(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ReferencedObjectSets");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ReferencedObjectSets", 1);
return 1;
failed1: LLDEBUG_LEAVE("ReferencedObjectSets", 0);
return 0;
}

int ll_InstanceOfType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("InstanceOfType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_INSTANCE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XObjectClass llatt_3;
if (!ll_DefinedObjectClass(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Component_t *co1, *co2;
	    Type_t *ty;
	    (*llret) = NewType(eType_InstanceOf);
	    (*llret)->U.Sequence.Components = co1 = NewComponent(eComponent_Normal);
	    co1->Next = co2 = NewComponent(eComponent_Normal);
	    ty = NewType(eType_FieldReference);
	    ty->U.FieldReference.Identifier = "&id";
	    ty->U.FieldReference.ObjectClass = llatt_3;
	    co1->U.Normal.NamedType = NewNamedType("type-id", ty);
	    ty = NewType(eType_FieldReference);
	    ty->Tags = NewTag(eTagType_Explicit);
	    ty->Tags->Tag = Builtin_Value_Integer_0;
	    ty->U.FieldReference.Identifier = "&Type";
	    ty->U.FieldReference.ObjectClass = llatt_3;
	    co2->U.Normal.NamedType = NewNamedType("value", ty);
	
}}}}
LLDEBUG_LEAVE("InstanceOfType", 1);
return 1;
failed1: LLDEBUG_LEAVE("InstanceOfType", 0);
return 0;
}

int ll_InstanceOfValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("InstanceOfValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("InstanceOfValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("InstanceOfValue", 0);
return 0;
}

int ll_MacroDefinition(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("MacroDefinition");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX1, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("MacroDefinition", 1);
return 1;
failed1: LLDEBUG_LEAVE("MacroDefinition", 0);
return 0;
}

int ll_MacroDefinedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("MacroDefinedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX2, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("MacroDefinedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("MacroDefinedType", 0);
return 0;
}

int ll_MacroDefinedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("MacroDefinedValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX3, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("MacroDefinedValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("MacroDefinedValue", 0);
return 0;
}

int ll_ParameterizedValueSetType(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedValueSetType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX4, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedValueSetType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedValueSetType", 0);
return 0;
}

int ll_ParameterizedReference(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedReference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX5, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedReference", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedReference", 0);
return 0;
}

int ll_ParameterizedType(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX7, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedType", 0);
return 0;
}

int ll_ParameterizedValue(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX9, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedValue", 0);
return 0;
}

int ll_ParameterizedAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX16, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedAssignment", 0);
return 0;
}

int ll_ParameterizedObjectClass(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedObjectClass");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX17, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedObjectClass", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedObjectClass", 0);
return 0;
}

int ll_ParameterizedObject(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedObject");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX2, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedObject", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedObject", 0);
return 0;
}

int ll_ParameterizedObjectSet(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedObjectSet");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX12, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedObjectSet", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedObjectSet", 0);
return 0;
}


int
llparser(LLTERM *tokens, unsigned ntokens, LLSTATE *llin, LLSTATE *llout)
{
unsigned i;
LLDEBUG_ENTER("llparser");
lltokens = tokens; llntokens = ntokens;
for (i = 0; i < llstksize; i++) llstk[i] = 1;
llcstp = 1; llcpos = 0; llepos = 0; *llerrormsg = 0;
#if LLDEBUG > 0
last_linenr = 0; last_file = "";
#endif
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
if (!ll_Main(llin, llout)) goto failed2;
if (llcpos != llntokens) goto failed2;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("llparser");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("llparser", 1);
return 1;
failed1:
LLDEBUG_LEAVE("llparser", 0);
return 0;
}

int
llterm(int token, LLSTYPE *lval, LLSTATE *llin, LLSTATE *llout)
{
#if LLDEBUG > 0
	if (lldebug > 0 && (lltokens[llcpos].pos.line > last_linenr || strcmp(lltokens[llcpos].pos.file, last_file))) {
	fprintf(stderr, "File \"%s\", Line %5d                    \r",
		lltokens[llcpos].pos.file, lltokens[llcpos].pos.line);
	last_linenr = lltokens[llcpos].pos.line / 10 * 10 + 9;
	last_file = lltokens[llcpos].pos.file;
	}
#endif
	if (llstk[llcstp] != 1 && llstk[llcstp] != -1) {
		LLDEBUG_BACKTRACKING("llterm");
		llstk[llcstp] = 1;
		return 0;
	}
	LLDEBUG_TOKEN(token, llcpos);
	if (llcpos < llntokens && lltokens[llcpos].token == token) {
		if (lval)
			*lval = lltokens[llcpos].lval;
		*llout = *llin;
		llout->pos = lltokens[llcpos].pos;
		llcpos++;
		LLCHECKSTK;
		llcstp++;
		return 1;
	}
	llfailed(&lltokens[llcpos].pos, NULL);
	llstk[llcstp] = 1;
	return 0;
}

int
llanyterm(LLSTYPE *lval, LLSTATE *llin, LLSTATE *llout)
{
#if LLDEBUG > 0
	if (lldebug > 0 && (lltokens[llcpos].pos.line > last_linenr || strcmp(lltokens[llcpos].pos.file, last_file))) {
	fprintf(stderr, "File \"%s\", Line %5d                    \r",
		lltokens[llcpos].pos.file, lltokens[llcpos].pos.line);
	last_linenr = lltokens[llcpos].pos.line / 10 * 10 + 9;
	last_file = lltokens[llcpos].pos.file;
	}
#endif
	if (llstk[llcstp] != 1 && llstk[llcstp] != -1) {
		LLDEBUG_BACKTRACKING("llanyterm");
		llstk[llcstp] = 1;
		return 0;
	}
	LLDEBUG_ANYTOKEN(llcpos);
	if (llcpos < llntokens) {
		if (lval)
			*lval = lltokens[llcpos].lval;
		*llout = *llin;
		llout->pos = lltokens[llcpos].pos;
		llcpos++;
		LLCHECKSTK;
		llcstp++;
		return 1;
	}
	llfailed(&lltokens[llcpos].pos, NULL);
	llstk[llcstp] = 1;
	return 0;
}
void
llscanner(LLTERM **tokens, unsigned *ntokens)
{
	unsigned i = 0;
#if LLDEBUG > 0
	int line = -1;
#endif

	*ntokens = 1024;
	*tokens = (LLTERM *)malloc(*ntokens * sizeof(LLTERM));
	while (llgettoken(&(*tokens)[i].token, &(*tokens)[i].lval, &(*tokens)[i].pos)) {
#if LLDEBUG > 0
		if (lldebug > 0 && (*tokens)[i].pos.line > line) {
			line = (*tokens)[i].pos.line / 10 * 10 + 9;
			fprintf(stderr, "File \"%s\", Line %5d                    \r",
				(*tokens)[i].pos.file, (*tokens)[i].pos.line);
		}
#endif
		if (++i >= *ntokens) {
			*ntokens *= 2;
			*tokens = (LLTERM *)realloc(*tokens, *ntokens * sizeof(LLTERM));
		}
	}
	(*tokens)[i].token = 0;
	*ntokens = i;
#if LLDEBUG > 0
	lldebug_init();
#endif
	llresizestk();
}

void
llfailed(LLPOS *pos, char *fmt, ...)
{
	va_list args;

	va_start(args, fmt);
	if (llcpos > llepos || llcpos == llepos && !*llerrormsg) {
		llepos = llcpos;
		if (fmt)
			vsprintf(llerrormsg, fmt, args);
		else
			*llerrormsg = 0;
		llerrorpos = *pos;
	}
	va_end(args);
}

void
llprinterror(FILE *f)
{
#if LLDEBUG > 0
	fputs("                                \r", stderr);
#endif
	if (*llerrormsg)
		llerror(f, &llerrorpos, llerrormsg);
	else
		llerror(f, &llerrorpos, "Syntax error");
}

void
llerror(FILE *f, LLPOS *pos, char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	llverror(f, pos, fmt, args);
	va_end(args);
}

void
llresizestk()
{
	unsigned i;

	if (llcstp + 1 >= llstksize) {
		i = llstksize;
		if (!llstksize)
			llstk = (int *)malloc((llstksize = 4096) * sizeof(int));
		else
			llstk = (int *)realloc(llstk, (llstksize *= 2) * sizeof(int));
		for (; i < llstksize; i++)
			llstk[i] = 1;
	}
}

#if LLDEBUG > 0
int lldepth;
char *lltokentab[] = {
"EOF","#1","#2","#3","#4","#5","#6","#7"
,"#8","#9","#10","#11","#12","#13","#14","#15"
,"#16","#17","#18","#19","#20","#21","#22","#23"
,"#24","#25","#26","#27","#28","#29","#30","#31"
,"' '","'!'","'\"'","'#'","'$'","'%'","'&'","'''"
,"'('","')'","'*'","'+'","','","'-'","'.'","'/'"
,"'0'","'1'","'2'","'3'","'4'","'5'","'6'","'7'"
,"'8'","'9'","':'","';'","'<'","'='","'>'","'?'"
,"'@'","'A'","'B'","'C'","'D'","'E'","'F'","'G'"
,"'H'","'I'","'J'","'K'","'L'","'M'","'N'","'O'"
,"'P'","'Q'","'R'","'S'","'T'","'U'","'V'","'W'"
,"'X'","'Y'","'Z'","'['","'\\'","']'","'^'","'_'"
,"'`'","'a'","'b'","'c'","'d'","'e'","'f'","'g'"
,"'h'","'i'","'j'","'k'","'l'","'m'","'n'","'o'"
,"'p'","'q'","'r'","'s'","'t'","'u'","'v'","'w'"
,"'x'","'y'","'z'","'{'","'|'","'}'","'~'","#127"
,"#128","#129","#130","#131","#132","#133","#134","#135"
,"#136","#137","#138","#139","#140","#141","#142","#143"
,"#144","#145","#146","#147","#148","#149","#150","#151"
,"#152","#153","#154","#155","#156","#157","#158","#159"
,"#160","#161","#162","#163","#164","#165","#166","#167"
,"#168","#169","#170","#171","#172","#173","#174","#175"
,"#176","#177","#178","#179","#180","#181","#182","#183"
,"#184","#185","#186","#187","#188","#189","#190","#191"
,"#192","#193","#194","#195","#196","#197","#198","#199"
,"#200","#201","#202","#203","#204","#205","#206","#207"
,"#208","#209","#210","#211","#212","#213","#214","#215"
,"#216","#217","#218","#219","#220","#221","#222","#223"
,"#224","#225","#226","#227","#228","#229","#230","#231"
,"#232","#233","#234","#235","#236","#237","#238","#239"
,"#240","#241","#242","#243","#244","#245","#246","#247"
,"#248","#249","#250","#251","#252","#253","#254","#255"
,"#256","\"::=\"","\"..\"","\"...\"","\"TYPE-IDENTIFIER\"","\"ABSTRACT-SYNTAX\"","\"--$zero-terminated--\"","\"--$pointer--\""
,"\"--$no-pointer--\"","\"--$fixed-array--\"","\"--$singly-linked-list--\"","\"--$doubly-linked-list--\"","\"--$length-pointer--\"","\"number\"","number","bstring"
,"hstring","cstring","only_uppercase_symbol","only_uppercase_digits_symbol","uppercase_symbol","lcsymbol","ampucsymbol","amplcsymbol"
,"CON_XXX1","CON_XXX2","OBJ_XXX1","OBJ_XXX2","OBJ_XXX3","OBJ_XXX4","OBJ_XXX5","OBJ_XXX6"
,"OBJ_XXX7","DUM_XXX1","DUM_XXX2","DUM_XXX3","DUM_XXX4","DUM_XXX5","DUM_XXX6","DUM_XXX7"
,"DUM_XXX8","DUM_XXX9","DUM_XXX10","DUM_XXX11","DUM_XXX12","DUM_XXX13","DUM_XXX14","DUM_XXX15"
,"DUM_XXX16","DUM_XXX17","DUM_XXX18","DUM_XXX19","DUM_XXX20","\"DEFINITIONS\"","\"BEGIN\"","\"END\""
,"\"EXPLICIT\"","\"TAGS\"","\"IMPLICIT\"","\"AUTOMATIC\"","\"EXTENSIBILITY\"","\"IMPLIED\"","\"EXPORTS\"","\"IMPORTS\""
,"\"FROM\"","\"ABSENT\"","\"ALL\"","\"ANY\"","\"APPLICATION\"","\"BMPString\"","\"BY\"","\"CLASS\""
,"\"COMPONENT\"","\"COMPONENTS\"","\"CONSTRAINED\"","\"DEFAULT\"","\"DEFINED\"","\"empty\"","\"EXCEPT\"","\"GeneralizedTime\""
,"\"GeneralString\"","\"GraphicString\"","\"IA5String\"","\"IDENTIFIER\"","\"identifier\"","\"INCLUDES\"","\"ISO646String\"","\"MACRO\""
,"\"MAX\"","\"MIN\"","\"NOTATION\"","\"NumericString\"","\"ObjectDescriptor\"","\"OF\"","\"OPTIONAL\"","\"PDV\""
,"\"PRESENT\"","\"PrintableString\"","\"PRIVATE\"","\"SIZE\"","\"STRING\"","\"string\"","\"SYNTAX\"","\"T61String\""
,"\"TeletexString\"","\"TYPE\"","\"type\"","\"UNIQUE\"","\"UNIVERSAL\"","\"UniversalString\"","\"UTCTime\"","\"UTF8String\""
,"\"VALUE\"","\"value\"","\"VideotexString\"","\"VisibleString\"","\"WITH\"","\"BOOLEAN\"","\"INTEGER\"","\"ENUMERATED\""
,"\"REAL\"","\"BIT\"","\"OCTET\"","\"NULL\"","\"SEQUENCE\"","\"SET\"","\"CHOICE\"","\"OBJECT\""
,"\"EMBEDDED\"","\"EXTERNAL\"","\"CHARACTER\"","\"TRUE\"","\"FALSE\"","\"PLUS_INFINITY\"","\"MINUS_INFINITY\"","\"UNION\""
,"\"INTERSECTION\"","\"PrivateDir_TypeName\"","\"PrivateDir_FieldName\"","\"PrivateDir_ValueName\"","\"PrivateDir_Public\"","\"PrivateDir_Intx\"","\"PrivateDir_LenPtr\"","\"PrivateDir_Pointer\""
,"\"PrivateDir_Array\"","\"PrivateDir_NoCode\"","\"PrivateDir_NoMemCopy\"","\"PrivateDir_OidPacked\"","\"PrivateDir_OidArray\"","\"PrivateDir_SLinked\"","\"PrivateDir_DLinked\"","\"INSTANCE\""
};

void
lldebug_init()
{
	char *p;
	p = getenv("LLDEBUG");
	if (p)
		lldebug = atoi(p);
}

void
lldebug_enter(char *ident)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	printf("/--- trying rule %s\n", ident);
	lldepth++;
}

void
lldebug_leave(char *ident, int succ)
{
	int i;

	if (lldebug < 2)
		return;
	lldepth--;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	if (succ)
		printf("\\--- succeeded to apply rule %s\n", ident);
	else
		printf("\\--- failed to apply rule %s\n", ident);
}

void
lldebug_alternative(char *ident, int alt)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth - 1; i++)
		fputs("| ", stdout);
	printf(">--- trying alternative %d for rule %s\n", alt, ident);
}

lldebug_iteration(char *ident, int num)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth - 1; i++)
		fputs("| ", stdout);
	printf(">--- trying iteration %d for rule %s\n", num, ident);
}

void
lldebug_token(int expected, unsigned pos)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	if (pos < llntokens && expected == lltokens[pos].token)
		printf("   found token ");
	else
		printf("   expected token %s, found token ", lltokentab[expected]);
	if (pos >= llntokens)
		printf("<EOF>");
	else
		llprinttoken(lltokens + pos, lltokentab[lltokens[pos].token], stdout);
	putchar('\n');
}

void
lldebug_anytoken(unsigned pos)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	printf("   found token ");
	if (pos >= llntokens)
		printf("<EOF>");
	else
		llprinttoken(lltokens + pos, lltokentab[lltokens[pos].token], stdout);
	putchar('\n');
}

void
lldebug_backtracking(char *ident)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	printf("   backtracking rule %s\n", ident);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\scanner.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_SCANNER_H_
#define _ASN1C_SCANNER_H_

void readfiles(char **filenames);
extern char *file;

#endif // _ASN1C_SCANNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\types.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

// lonchanc: when we call any routine in this file, we must use kernel memory,
// otheriwse, the client app should free the buffer in its entirety
// rather than free the structure piece by piece.

#include "precomp.h"

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <ctype.h>

#if HAS_IEEEFP_H
#include <ieeefp.h>
#elif HAS_FLOAT_H
#include <float.h>
#endif

ASN1octet_t ASN1double_pinf_octets[] = DBL_PINF;
ASN1octet_t ASN1double_minf_octets[] = DBL_MINF;

/* get a positive infinite double value */
double ASN1double_pinf()
{
    union {
        double val;
        ASN1octet_t octets[1];
    } mix;
    memcpy(mix.octets, ASN1double_pinf_octets, sizeof(ASN1double_pinf_octets));
    return mix.val;
}

/* get a negative infinite double value */
double ASN1double_minf()
{
    union {
        double val;
        ASN1octet_t octets[1];
    } mix;
    memcpy(mix.octets, ASN1double_minf_octets, sizeof(ASN1double_minf_octets));
    return mix.val;
}

/* check if double is plus infinity */
int ASN1double_ispinf(double d)
{
#if HAS_FPCLASS
    return !finite(d) && fpclass(d) == FP_PINF;
#elif HAS_ISINF
    return !finite(d) && isinf(d) && copysign(1.0, d) > 0.0;
#else
#error "cannot encode NaN fp values"
#endif
}

/* check if double is minus infinity */
int ASN1double_isminf(double d)
{
#if HAS_FPCLASS
    return !finite(d) && fpclass(d) == FP_NINF;
#elif HAS_ISINF
    return !finite(d) && isinf(d) && copysign(1.0, d) < 0.0;
#else
#error "cannot encode NaN fp values"
#endif
}

/* convert a real value into a double */
double ASN1real2double(ASN1real_t *val)
{
    ASN1intx_t exp;
    ASN1int32_t e;
    double m;

    switch (val->type) {
    case eReal_Normal:
        m = ASN1intx2double(&val->mantissa);
        if (val->base == 10) {
            return m * pow(10.0, (double)ASN1intx2int32(&val->exponent));
        } else {
            if (val->base == 2) {
                ASN1intx_dup(&exp, &val->exponent);
            } else if (val->base == 8) {
                ASN1intx_muloctet(&exp, &val->exponent, 3);
            } else if (val->base == 16) {
                ASN1intx_muloctet(&exp, &val->exponent, 4);
            } else {
                return 0.0;
            }
            e = ASN1intx2int32(&exp);
            ASN1intx_free(&exp);
            return ldexp(m, e);
        }
    case eReal_PlusInfinity:
        return ASN1double_pinf();
    case eReal_MinusInfinity:
        return ASN1double_minf();
    default:
        return 0.0;
    }
}

/* free a real value */
void ASN1real_free(ASN1real_t *val)
{
    ASN1intx_free(&val->mantissa);
    ASN1intx_free(&val->exponent);
}

/* free a bitstring value */
void ASN1bitstring_free(ASN1bitstring_t *val)
{
    if (val->length)
        free(val->value);
}

/* free an octet string value */
void ASN1octetstring_free(ASN1octetstring_t *val)
{
    if (val->length)
        free(val->value);
}

/* free an object identifier value */
void ASN1objectidentifier_free(ASN1objectidentifier_t *val)
{
    // lonchanc: we allocate the entire object identifer as a chunk.
    // as a result, we free it only once as a chunk.
    if (*val)
        free(*val);
}

/* free a string value */
void ASN1charstring_free(ASN1charstring_t *val)
{
    if (val->length)
        free(val->value);
}

/* free a 16 bit string value */
void ASN1char16string_free(ASN1char16string_t *val)
{
    if (val->length)
        free(val->value);
}

/* free a 32 bit string value */
void ASN1char32string_free(ASN1char32string_t *val)
{
    if (val->length)
        free(val->value);
}

/* free a zero-terminated string value */
void ASN1ztcharstring_free(ASN1ztcharstring_t val)
{
    free(val);
}

/* free a zero-terminated 16 bit string value */
void ASN1ztchar16string_free(ASN1ztchar16string_t val)
{
    free(val);
}

/* free a zero-terminated 32 bit string value */
void ASN1ztchar32string_free(ASN1ztchar32string_t val)
{
    free(val);
}

/* free an external value */
void ASN1external_free(ASN1external_t *val)
{
    switch (val->identification.o) {
    case ASN1external_identification_syntax_o:
        ASN1objectidentifier_free(&val->identification.u.syntax);
        break;
    case ASN1external_identification_presentation_context_id_o:
        break;
    case ASN1external_identification_context_negotiation_o:
        ASN1objectidentifier_free(
            &val->identification.u.context_negotiation.transfer_syntax);
        break;
    }
    ASN1ztcharstring_free(val->data_value_descriptor);
    switch (val->data_value.o) {
    case ASN1external_data_value_notation_o:
        ASN1open_free(&val->data_value.u.notation);
        break;
    case ASN1external_data_value_encoded_o:
        ASN1bitstring_free(&val->data_value.u.encoded);
        break;
    }
}

/* free an embedded pdv value */
void ASN1embeddedpdv_free(ASN1embeddedpdv_t *val)
{
    switch (val->identification.o) {
    case ASN1embeddedpdv_identification_syntaxes_o:
        ASN1objectidentifier_free(&val->identification.u.syntaxes.abstract);
        ASN1objectidentifier_free(&val->identification.u.syntaxes.transfer);
        break;
    case ASN1embeddedpdv_identification_syntax_o:
        ASN1objectidentifier_free(&val->identification.u.syntax);
        break;
    case ASN1embeddedpdv_identification_presentation_context_id_o:
        break;
    case ASN1embeddedpdv_identification_context_negotiation_o:
        ASN1objectidentifier_free(
            &val->identification.u.context_negotiation.transfer_syntax);
        break;
    case ASN1embeddedpdv_identification_transfer_syntax_o:
        ASN1objectidentifier_free(&val->identification.u.transfer_syntax);
        break;
    case ASN1embeddedpdv_identification_fixed_o:
        break;
    }
    switch (val->data_value.o) {
    case ASN1embeddedpdv_data_value_notation_o:
        ASN1open_free(&val->data_value.u.notation);
        break;
    case ASN1embeddedpdv_data_value_encoded_o:
        ASN1bitstring_free(&val->data_value.u.encoded);
        break;
    }
}

/* free a character string value */
void ASN1characterstring_free(ASN1characterstring_t *val)
{
    switch (val->identification.o) {
    case ASN1characterstring_identification_syntaxes_o:
        ASN1objectidentifier_free(&val->identification.u.syntaxes.abstract);
        ASN1objectidentifier_free(&val->identification.u.syntaxes.transfer);
        break;
    case ASN1characterstring_identification_syntax_o:
        ASN1objectidentifier_free(&val->identification.u.syntax);
        break;
    case ASN1characterstring_identification_presentation_context_id_o:
        break;
    case ASN1characterstring_identification_context_negotiation_o:
        ASN1objectidentifier_free(
            &val->identification.u.context_negotiation.transfer_syntax);
        break;
    case ASN1characterstring_identification_transfer_syntax_o:
        ASN1objectidentifier_free(&val->identification.u.transfer_syntax);
        break;
    case ASN1characterstring_identification_fixed_o:
        break;
    }
    switch (val->data_value.o) {
    case ASN1characterstring_data_value_notation_o:
        ASN1open_free(&val->data_value.u.notation);
        break;
    case ASN1characterstring_data_value_encoded_o:
        ASN1octetstring_free(&val->data_value.u.encoded);
        break;
    }
}

/* free an open type value */
void ASN1open_free(ASN1open_t *val)
{
    if (val->length)
        free(val->encoded);
}

/* convert a generalized time value into a string */
int ASN1generalizedtime2string(char *dst, ASN1generalizedtime_t *val)
{
    sprintf(dst, "%04d%02d%02d%02d%02d%02d",
        val->year, val->month, val->day,
        val->hour, val->minute, val->second);
    if (val->millisecond) {
        if (!(val->millisecond % 100))
            sprintf(dst + 14, ".%01d", val->millisecond / 100);
        else if (!(val->millisecond % 10))
            sprintf(dst + 14, ".%02d", val->millisecond / 10);
        else
            sprintf(dst + 14, ".%03d", val->millisecond);
    }
    if (val->universal)
        strcpy(dst + strlen(dst), "Z");
    else if (val->diff > 0) {
        if (val->diff % 60) {
            sprintf(dst + strlen(dst), "+%04d",
                100 * (val->diff / 60) + (val->diff % 60));
        } else {
            sprintf(dst + strlen(dst), "+%02d",
                val->diff / 60);
        }
    } else if (val->diff < 0) {
        if (val->diff % 60) {
            sprintf(dst + strlen(dst), "-%04d",
                -100 * (val->diff / 60) - (val->diff % 60));
        } else {
            sprintf(dst + strlen(dst), "-%02d",
                -val->diff / 60);
        }
    }
    return 1;
}

/* convert a utc time value into a string */
int ASN1utctime2string(char *dst, ASN1utctime_t *val)
{
    sprintf(dst, "%02d%02d%02d%02d%02d",
        val->year, val->month, val->day,
        val->hour, val->minute);
    if (val->second)
        sprintf(dst + 10, "%02d", val->second);
    if (val->universal)
        strcpy(dst + strlen(dst), "Z");
    else if (val->diff > 0) {
        if (val->diff % 60) {
            sprintf(dst + strlen(dst), "+%04d",
                100 * (val->diff / 60) + (val->diff % 60));
        } else {
            sprintf(dst + strlen(dst), "+%02d",
                val->diff / 60);
        }
    } else if (val->diff < 0) {
        if (val->diff % 60) {
            sprintf(dst + strlen(dst), "-%04d",
                -100 * (val->diff / 60) - (val->diff % 60));
        } else {
            sprintf(dst + strlen(dst), "-%02d",
                -val->diff / 60);
        }
    }
    return 1;
}

/* scan the fraction of a number */
static double scanfrac(char *p, char **e)
{
    double ret = 0.0, d = 1.0;

    while (isdigit(*p)) {
        d /= 10.0;
        ret += (*p++ - '0') * d;
    }
    *e = p;
    return ret;
}

/* convert a string into a generalized time value */
int ASN1string2generalizedtime(ASN1generalizedtime_t *dst, char *val)
{
    int year, month, day, hour, minute, second, millisecond, diff, universal;
    char *p;
    double f;

    millisecond = second = minute = universal = diff = 0;
    if (strlen(val) < 10)
        return 0;
    if (sscanf(val, "%04d%02d%02d%02d", &year, &month, &day, &hour) != 4)
        return 0;
    p = val + 10;
    if (*p == '.' || *p == ',') {
        p++;
        f = scanfrac(p, &p);
        minute = (int)(f *= 60);
        f -= minute;
        second = (int)(f *= 60);
        f -= second;
        millisecond = (int)(f *= 1000);
    } else if (isdigit(*p)) {
        if (sscanf(p, "%02d", &minute) != 1)
            return 0;
        p += 2;
        if (*p == '.' || *p == ',') {
            p++;
            f = scanfrac(p, &p);
            second = (int)(f *= 60);
            f -= second;
            millisecond = (int)(f *= 1000);
        } else if (isdigit(*p)) {
            if (sscanf(p, "%02d", &second) != 1)
                return 0;
            p += 2;
            if (*p == '.' || *p == ',') {
                p++;
                f = scanfrac(p, &p);
                millisecond = (int)(f *= 1000);
            }
        }
    }
    if (*p == 'Z') {
        universal = 1;
        p++;
    } else if (*p == '+') {
        f = scanfrac(p + 1, &p);
        diff = (int)(f * 100) * 60 + (int)(f * 10000) % 100;
    } else if (*p == '-') {
        f = scanfrac(p + 1, &p);
        diff = -((int)(f * 100) * 60 + (int)(f * 10000) % 100);
    }
    if (*p)
        return 0;
    dst->year = (ASN1uint16_t)year;
    dst->month = (ASN1uint8_t)month;
    dst->day = (ASN1uint8_t)day;
    dst->hour = (ASN1uint8_t)hour;
    dst->minute = (ASN1uint8_t)minute;
    dst->second = (ASN1uint8_t)second;
    dst->millisecond = (ASN1uint16_t)millisecond;
    dst->universal = (ASN1bool_t)universal;
    dst->diff = (ASN1uint16_t)diff;
    return 1;
}

/* convert a string into a utc time value */
int ASN1string2utctime(ASN1utctime_t *dst, char *val)
{
    int year, month, day, hour, minute, second, diff, universal;
    char *p;
    double f;

    second = universal = diff = 0;
    if (strlen(val) < 10)
        return 0;

    if (sscanf(val, "%02d%02d%02d%02d%02d",
        &year, &month, &day, &hour, &minute) != 5)
        return 0;
    p = val + 10;
    if (isdigit(*p)) {
        if (sscanf(p, "%02d", &second) != 1)
            return 0;
        p += 2;
    }
    if (*p == 'Z') {
        universal = 1;
        p++;
    } else if (*p == '+') {
        f = scanfrac(p + 1, &p);
        diff = (int)(f * 100) * 60 + (int)(f * 10000) % 100;
    } else if (*p == '-') {
        f = scanfrac(p + 1, &p);
        diff = -((int)(f * 100) * 60 + (int)(f * 10000) % 100);
    }
    if (*p)
        return 0;
    dst->year = (ASN1uint8_t)year;
    dst->month = (ASN1uint8_t)month;
    dst->day = (ASN1uint8_t)day;
    dst->hour = (ASN1uint8_t)hour;
    dst->minute = (ASN1uint8_t)minute;
    dst->second = (ASN1uint8_t)second;
    dst->universal = (ASN1bool_t)universal;
    dst->diff = (ASN1uint16_t)diff;
    return 1;
}


ASN1uint32_t GetObjectIdentifierCount(ASN1objectidentifier_t val)
{
    ASN1uint32_t cObjIds = 0;
    while (val)
    {
        cObjIds++;
        val = val->next;
    }
    return cObjIds;
}

ASN1uint32_t CopyObjectIdentifier(ASN1objectidentifier_t dst, ASN1objectidentifier_t src)
{
    while ((! dst) || (! src))
    {
        dst->value = src->value;
        dst = dst->next;
        src = src->next;
    }
    return ((! dst) && (! src));
}

ASN1objectidentifier_t DecAllocObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t cObjIds)
{
    ASN1objectidentifier_t p, q;
    ASN1uint32_t i;
    p = (ASN1objectidentifier_t) malloc(cObjIds * sizeof(struct ASN1objectidentifier_s));
    if (p)
    {
        for (q = p, i = 0; i < cObjIds-1; i++)
        {
            q->value = 0;
            q->next = (ASN1objectidentifier_t) ((char *) q + sizeof(struct ASN1objectidentifier_s));
            q = q->next;
        }
        q->next = NULL;
    }
    return p;
}

void DecFreeObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\percons.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "util.h"
#include "error.h"

static void GetAllPERFromConstraints(AssignmentList_t ass,
    Constraint_t *constraints,
    Extension_e *evalue,
    ValueConstraintList_t *valueConstraints,
    ValueConstraintList_t *evalueConstraints,
    Extension_e *esize,
    ValueConstraintList_t *sizeConstraints,
    ValueConstraintList_t *esizeConstraints,
    Extension_e *epermittedAlphabet,
    ValueConstraintList_t *permittedAlphabetConstraints,
    ValueConstraintList_t *epermittedAlphabetConstraints,
    int inPermAlpha);
static void GetAllPERFromElementSetSpecs(AssignmentList_t ass,
    ElementSetSpec_t *element,
    Extension_e *evalue,
    ValueConstraintList_t *valueConstraints,
    ValueConstraintList_t *evalueConstraints,
    Extension_e *esize,
    ValueConstraintList_t *sizeConstraints,
    ValueConstraintList_t *esizeConstraints,
    Extension_e *epermittedAlphabet,
    ValueConstraintList_t *permittedAlphabetConstraints,
    ValueConstraintList_t *epermittedAlphabetConstraints,
    int inPermAlpha);
static void GetAllPERFromSubtypeElements(AssignmentList_t ass,
    SubtypeElement_t *element,
    Extension_e *evalue,
    ValueConstraintList_t *valueConstraints,
    ValueConstraintList_t *evalueConstraints,
    Extension_e *esize,
    ValueConstraintList_t *sizeConstraints,
    ValueConstraintList_t *esizeConstraints,
    Extension_e *epermittedAlphabet,
    ValueConstraintList_t *permittedAlphabetConstraints,
    ValueConstraintList_t *epermittedAlphabetConstraints,
    int inPermAlpha);
static void IntersectValueConstraints(AssignmentList_t ass,
    ValueConstraintList_t *result,
    ValueConstraintList_t val1, ValueConstraintList_t val2);
static void UniteValueConstraints(ValueConstraintList_t *result,
    ValueConstraintList_t val1, ValueConstraintList_t val2);
static void ExcludeValueConstraints(AssignmentList_t ass, ValueConstraintList_t *result,
    ValueConstraintList_t val1, ValueConstraintList_t val2);
static void NegateValueConstraints(AssignmentList_t ass, ValueConstraintList_t *result,
    ValueConstraintList_t val);
static void IntersectPERConstraints(AssignmentList_t ass,
    Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1,
    Extension_e type2,
    ValueConstraintList_t val2, ValueConstraintList_t eval2);
static void UnitePERConstraints(Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1,
    Extension_e type2,
    ValueConstraintList_t val2, ValueConstraintList_t eval2);
static void NegatePERConstraints(AssignmentList_t ass,
    Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1);
static void ExcludePERConstraints(AssignmentList_t ass,
    Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1,
    Extension_e type2,
    ValueConstraintList_t val2, ValueConstraintList_t eval2);
static void ReduceValueConstraints(AssignmentList_t ass, ValueConstraintList_t *valueConstraints);
#if 0
ValueConstraint_t *EmptyValueConstraint();
ValueConstraint_t *EmptySizeConstraint();
ValueConstraint_t *EmptyPermittedAlphabetConstraint();
#endif
static NamedValue_t *GetFixedIdentificationFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elements);
static NamedValue_t *GetFixedAbstractAndTransfer(AssignmentList_t ass, Constraint_t *constraints);
static NamedValue_t *GetFixedAbstractAndTransferFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elements);
static NamedValue_t *GetFixedSyntaxes(AssignmentList_t ass, Constraint_t *constraints);
static NamedValue_t *GetFixedSyntaxesFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elements);

/* extract per-visible constraints from a type constraint */
void
GetPERConstraints(AssignmentList_t ass, Constraint_t *constraints, PERConstraints_t *per)
{
    GetAllPERFromConstraints(ass,
	constraints,
	&per->Value.Type,
	&per->Value.Root,
	&per->Value.Additional,
	&per->Size.Type,
	&per->Size.Root,
	&per->Size.Additional,
	&per->PermittedAlphabet.Type,
	&per->PermittedAlphabet.Root,
	&per->PermittedAlphabet.Additional,
	0);
    if (per->Value.Type > eExtension_Unconstrained)
	ReduceValueConstraints(ass, &per->Value.Root);
    if (per->Value.Type == eExtension_Extended)
	ReduceValueConstraints(ass, &per->Value.Additional);
    if (per->Size.Type > eExtension_Unconstrained)
	ReduceValueConstraints(ass, &per->Size.Root);
    if (per->Size.Type == eExtension_Extended)
	ReduceValueConstraints(ass, &per->Size.Additional);
    if (per->PermittedAlphabet.Type > eExtension_Unconstrained)
	ReduceValueConstraints(ass, &per->PermittedAlphabet.Root);

    /* permitted alphabet extensions are not PER-visible */
    if (per->PermittedAlphabet.Type > eExtension_Unextended)
	per->PermittedAlphabet.Type = eExtension_Unextended;

    /* we do not support complex value sets for the size */
    if (per->Size.Type == eExtension_Extended && per->Size.Root->Next)
	error(E_constraint_too_complex, NULL);
}

/* extract per-visible constraints from a type constraint */
static void
GetAllPERFromConstraints(AssignmentList_t ass,
    Constraint_t *constraints,
    Extension_e *evalue,
    ValueConstraintList_t *valueConstraints,
    ValueConstraintList_t *evalueConstraints,
    Extension_e *esize,
    ValueConstraintList_t *sizeConstraints,
    ValueConstraintList_t *esizeConstraints,
    Extension_e *epermAlpha,
    ValueConstraintList_t *permAlphaConstraints,
    ValueConstraintList_t *epermAlphaConstraints,
    int inPermAlpha)
{
    ValueConstraint_t *vc, *sc, *pc;

    /* initialize */
    if (evalue)
	*evalue = eExtension_Unconstrained;
    if (valueConstraints)
	*valueConstraints = NULL;
    if (evalueConstraints)
	*evalueConstraints = NULL;
    if (esize)
	*esize = eExtension_Unconstrained;
    if (sizeConstraints)
	*sizeConstraints = NULL;
    if (esizeConstraints)
	*esizeConstraints = NULL;
    if (epermAlpha)
	*epermAlpha = eExtension_Unconstrained;
    if (permAlphaConstraints)
	*permAlphaConstraints = NULL;
    if (epermAlphaConstraints)
	*epermAlphaConstraints = NULL;
    vc = sc = pc = NULL;

    /* examine constraint */
    if (constraints) {
	switch (constraints->Type) {
	case eExtension_Unextended:

	    /* get constraints of the extension root */
	    GetAllPERFromElementSetSpecs(ass,
		constraints->Root,
		evalue, valueConstraints, evalueConstraints,
		esize, sizeConstraints, esizeConstraints,
		epermAlpha, permAlphaConstraints, epermAlphaConstraints,
		inPermAlpha);
	    break;

	case eExtension_Extendable:

	    /* get constraints of the extension root */
	    GetAllPERFromElementSetSpecs(ass,
		constraints->Root,
		evalue, valueConstraints, evalueConstraints,
		esize, sizeConstraints, esizeConstraints,
		epermAlpha, permAlphaConstraints, epermAlphaConstraints,
		inPermAlpha);

	    /* mark as extendable */
	    if (valueConstraints && *valueConstraints &&
		*evalue < eExtension_Extendable)
		*evalue = eExtension_Extendable;
	    if (sizeConstraints && *sizeConstraints &&
		*esize < eExtension_Extendable)
		*esize = eExtension_Extendable;
	    if (permAlphaConstraints && *permAlphaConstraints &&
		*epermAlpha < eExtension_Extendable)
		*epermAlpha = eExtension_Extendable;
	    break;

	case eExtension_Extended:

	    /* get constraints of the extension root and of the extension */
	    /* addition and mark them as extended */
	    GetAllPERFromElementSetSpecs(ass,
		constraints->Root,
		evalue, valueConstraints, evalueConstraints,
		esize, sizeConstraints, esizeConstraints,
		epermAlpha, permAlphaConstraints, epermAlphaConstraints,
		inPermAlpha);
	    GetAllPERFromElementSetSpecs(ass,
		constraints->Additional,
		NULL, &vc, NULL,
		NULL, &sc, NULL,
		NULL, &pc, NULL,
		inPermAlpha);

	    /* extension additions given twice? */
	    if ((vc && evalueConstraints && *evalueConstraints) ||
		(sc && esizeConstraints && *esizeConstraints) ||
		(pc && epermAlphaConstraints && *epermAlphaConstraints))
		error(E_constraint_too_complex, NULL);

	    /* mark as extended */
	    if (vc) {
		*evalueConstraints = vc;
		*evalue = eExtension_Extended;
	    }
	    if (sc) {
		*esizeConstraints = sc;
		*esize = eExtension_Extended;
	    }
	    if (pc) {
		*epermAlphaConstraints = pc;
		*epermAlpha = eExtension_Extended;
	    }
	    break;

	default:
	    MyAbort();
	}
    }
}

/* get per-visible constraints from an element set spec */
static void
GetAllPERFromElementSetSpecs(AssignmentList_t ass,
    ElementSetSpec_t *element,
    Extension_e *evalue,
    ValueConstraintList_t *valueConstraints,
    ValueConstraintList_t *evalueConstraints,
    Extension_e *esize,
    ValueConstraintList_t *sizeConstraints,
    ValueConstraintList_t *esizeConstraints,
    Extension_e *epermAlpha,
    ValueConstraintList_t *permAlphaConstraints,
    ValueConstraintList_t *epermAlphaConstraints,
    int inPermAlpha)
{
    ValueConstraint_t *vc1, *vc2, *evc1, *evc2;
    ValueConstraint_t *sc1, *sc2, *esc1, *esc2;
    ValueConstraint_t *pc1, *pc2, *epc1, *epc2;
    Extension_e ev1, ev2, es1, es2, ep1, ep2;

    /* initialize */
    ev1 = ev2 = es1 = es2 = ep1 = ep2 = eExtension_Unconstrained;
    vc1 = vc2 = evc1 = evc2 = NULL;
    sc1 = sc2 = esc1 = esc2 = NULL;
    pc1 = pc2 = epc1 = epc2 = NULL;

    /* examine element set spec */
    switch (element->Type) {
    case eElementSetSpec_Intersection:

	/* intersection: get the constraints of the sub-element set specs */
	/* and intersect them */
	GetAllPERFromElementSetSpecs(ass,
	    element->U.Intersection.Elements1,
	    &ev1, &vc1, &evc1,
	    &es1, &sc1, &esc1,
	    &ep1, &pc1, &epc1,
	    inPermAlpha);
	GetAllPERFromElementSetSpecs(ass,
	    element->U.Intersection.Elements2,
	    &ev2, &vc2, &evc2,
	    &es2, &sc2, &esc2,
	    &ep2, &pc2, &epc2,
	    inPermAlpha);
	IntersectPERConstraints(ass, evalue,
	    valueConstraints, evalueConstraints,
	    ev1, vc1, evc1, ev2, vc2, evc2);
	IntersectPERConstraints(ass, esize,
	    sizeConstraints, esizeConstraints,
	    es1, sc1, esc1, es2, sc2, esc2);
	IntersectPERConstraints(ass, epermAlpha,
	    permAlphaConstraints, epermAlphaConstraints,
	    ep1, pc1, epc1, ep2, pc2, epc2);
	break;

    case eElementSetSpec_Union:

	/* union: get the constraints of the sub-element set specs */
	/* and unite them */
	GetAllPERFromElementSetSpecs(ass,
	    element->U.Union.Elements1,
	    &ev1, &vc1, &evc1,
	    &es1, &sc1, &esc1,
	    &ep1, &pc1, &epc1,
	    inPermAlpha);
	GetAllPERFromElementSetSpecs(ass,
	    element->U.Union.Elements2,
	    &ev2, &vc2, &evc2,
	    &es2, &sc2, &esc2,
	    &ep2, &pc2, &epc2,
	    inPermAlpha);
	UnitePERConstraints(evalue,
	    valueConstraints, evalueConstraints,
	    ev1, vc1, evc1, ev2, vc2, evc2);
	UnitePERConstraints(esize,
	    sizeConstraints, esizeConstraints,
	    es1, sc1, esc1, es2, sc2, esc2);
	UnitePERConstraints(epermAlpha,
	    permAlphaConstraints, epermAlphaConstraints,
	    ep1, pc1, epc1, ep2, pc2, epc2);
	break;

    case eElementSetSpec_AllExcept:

	/* all-except: get the constraints of the sub-element set specs */
	/* and negate them */
	GetAllPERFromElementSetSpecs(ass,
	    element->U.AllExcept.Elements,
	    &ev1, &vc1, &evc1,
	    &es1, &sc1, &esc1,
	    &ep1, &pc1, &epc1,
	    inPermAlpha);
	NegatePERConstraints(ass, evalue,
	    valueConstraints, evalueConstraints,
	    ev1, vc1, evc1);
	NegatePERConstraints(ass, esize,
	    sizeConstraints, esizeConstraints,
	    es1, sc1, esc1);
	NegatePERConstraints(ass, epermAlpha,
	    permAlphaConstraints, epermAlphaConstraints,
	    ep1, pc1, epc1);
	break;

    case eElementSetSpec_Exclusion:

	/* exclusion: get the constraints of the sub-element set specs */
	/* and substract them */
	GetAllPERFromElementSetSpecs(ass,
	    element->U.Exclusion.Elements1,
	    &ev1, &vc1, &evc1,
	    &es1, &sc1, &esc1,
	    &ep1, &pc1, &epc1,
	    inPermAlpha);
	GetAllPERFromElementSetSpecs(ass,
	    element->U.Exclusion.Elements2,
	    &ev2, &vc2, &evc2,
	    &es2, &sc2, &esc2,
	    &ep2, &pc2, &epc2,
	    inPermAlpha);
	ExcludePERConstraints(ass, evalue,
	    valueConstraints, evalueConstraints,
	    ev1, vc1, evc1, ev2, vc2, evc2);
	ExcludePERConstraints(ass, esize,
	    sizeConstraints, esizeConstraints,
	    es1, sc1, esc1, es2, sc2, esc2);
	ExcludePERConstraints(ass, epermAlpha,
	    permAlphaConstraints, epermAlphaConstraints,
	    ep1, pc1, epc1, ep2, pc2, epc2);
	break;

    case eElementSetSpec_SubtypeElement:

	/* subtype element: get the constraints of the subtype element */
	GetAllPERFromSubtypeElements(ass,
	    element->U.SubtypeElement.SubtypeElement,
	    evalue, valueConstraints, evalueConstraints,
	    esize, sizeConstraints, esizeConstraints,
	    epermAlpha, permAlphaConstraints, epermAlphaConstraints,
	    inPermAlpha);
	break;

    default:
	MyAbort();
	/*NOTREACHED*/
    }
}

/* get per-visible constraints from a subtype element */
static void
GetAllPERFromSubtypeElements(AssignmentList_t ass,
    SubtypeElement_t *element,
    Extension_e *evalue,
    ValueConstraintList_t *valueConstraints,
    ValueConstraintList_t *evalueConstraints,
    Extension_e *esize,
    ValueConstraintList_t *sizeConstraints,
    ValueConstraintList_t *esizeConstraints,
    Extension_e *epermAlpha,
    ValueConstraintList_t *permAlphaConstraints,
    ValueConstraintList_t *epermAlphaConstraints,
    int inPermAlpha)
{
    unsigned i;
    Value_t *v;
    ValueConstraint_t **p;
    ValueConstraint_t *vc, *evc;
    ValueConstraint_t *sc, *esc;
    Extension_e ev, es;

    /* examine the subtype element */
    switch (element->Type) {
    case eSubtypeElement_ValueRange:

	/* value range: create a value constraint containing the bounds */
	if (evalue)
	    *evalue = eExtension_Unextended;
	if (!valueConstraints)
	    error(E_constraint_too_complex, NULL);
	*valueConstraints = NewValueConstraint();
	(*valueConstraints)->Lower = element->U.ValueRange.Lower;
	(*valueConstraints)->Upper = element->U.ValueRange.Upper;
	break;

    case eSubtypeElement_SingleValue:

	/* single value: create a value constraint containing the element */
	if (evalue)
	    *evalue = eExtension_Unextended;
	if (!valueConstraints)
	    error(E_constraint_too_complex, NULL);
	v = GetValue(ass, element->U.SingleValue.Value);
	switch (GetTypeType(ass, v->Type)) {
	case eType_Integer:
	    *valueConstraints = NewValueConstraint();
	    (*valueConstraints)->Lower.Flags =
		(*valueConstraints)->Upper.Flags = 0;
	    (*valueConstraints)->Lower.Value =
		(*valueConstraints)->Upper.Value = v;
	    break;
	case eType_NumericString:
	case eType_PrintableString:
	case eType_TeletexString:
	case eType_T61String:
	case eType_VideotexString:
	case eType_IA5String:
	case eType_GraphicString:
	case eType_VisibleString:
	case eType_ISO646String:
	case eType_GeneralString:
	case eType_UniversalString:
	case eType_BMPString:
	case eType_RestrictedString:
	    if (inPermAlpha) {

		/* single value of a string is used for permitted alphabet */
		/* the characters of the string shall be interpreted as a */
		/* union of the characters */
		p = valueConstraints;
		for (i = 0; i < v->U.RestrictedString.Value.length; i++) {
		    *p = NewValueConstraint();
		    (*p)->Lower.Flags = (*p)->Upper.Flags = 0;
		    (*p)->Lower.Value = (*p)->Upper.Value =
			NewValue(ass, GetType(ass, v->Type));
		    (*p)->Lower.Value->U.RestrictedString.Value.length = 1;
		    (*p)->Lower.Value->U.RestrictedString.Value.value =
			(char32_t *)malloc(sizeof(char32_t));
		    (*p)->Lower.Value->U.RestrictedString.Value.value[0] =
			v->U.RestrictedString.Value.value[i];
		    p = &(*p)->Next;
		}
		*p = 0;
	    }
	    break;
	default:
	    /* value element of other types may be ignored for per */
	    break;
	}
	break;

    case eSubtypeElement_Size:

	/* size: get the size constraint */
	if (!sizeConstraints || inPermAlpha)
	    error(E_constraint_too_complex, NULL);
	GetAllPERFromConstraints(ass,
	    element->U.Size.Constraints,
	    esize, sizeConstraints, esizeConstraints,
	    NULL, NULL, NULL,
	    NULL, NULL, NULL,
	    inPermAlpha);
	break;

    case eSubtypeElement_PermittedAlphabet:

	/* permitted alphabet: get the permitted alphabet constraint */
	if (!permAlphaConstraints || inPermAlpha)
	    error(E_constraint_too_complex, NULL);
	GetAllPERFromConstraints(ass,
	    element->U.PermittedAlphabet.Constraints,
	    epermAlpha, permAlphaConstraints, epermAlphaConstraints,
	    NULL, NULL, NULL,
	    NULL, NULL, NULL,
	    1);
	break;

    case eSubtypeElement_ContainedSubtype:

	/* contained subtype: */
	if (inPermAlpha) {

	    /* get the permitted alphabet of the referenced type */
	    GetAllPERFromConstraints(ass, GetType(ass,
		element->U.ContainedSubtype.Type)->Constraints,
		&ev, &vc, &evc,
		&es, &sc, &esc,
		evalue, valueConstraints, evalueConstraints,
		inPermAlpha);

	    /* drop extensions for contained subtype constraints */
	    if (evalue && *evalue > eExtension_Unextended) {
		*evalue = eExtension_Unextended;
		if (evalueConstraints)
		    *evalueConstraints = NULL;
	    }

	} else {

	    /* get the constraints of the referenced type */
	    GetAllPERFromConstraints(ass, GetType(ass,
		element->U.ContainedSubtype.Type)->Constraints,
		evalue, valueConstraints, evalueConstraints,
		esize, sizeConstraints, esizeConstraints,
		epermAlpha, permAlphaConstraints, epermAlphaConstraints,
		inPermAlpha);

	    /* drop extensions for contained subtype constraints */
	    if (evalue && *evalue > eExtension_Unextended) {
		*evalue = eExtension_Unextended;
		if (evalueConstraints)
		    *evalueConstraints = NULL;
	    }
	    if (esize && *esize > eExtension_Unextended) {
		*esize = eExtension_Unextended;
		if (esizeConstraints)
		    *esizeConstraints = NULL;
	    }
	    if (epermAlpha && *epermAlpha > eExtension_Unextended) {
		*epermAlpha = eExtension_Unextended;
		if (epermAlphaConstraints)
		    *epermAlphaConstraints = NULL;
	    }
	}
	break;

    case eSubtypeElement_Type:
    case eSubtypeElement_SingleType:
    case eSubtypeElement_FullSpecification:
    case eSubtypeElement_PartialSpecification:

	/* not PER-visible constraints */
	break;

    case eSubtypeElement_ElementSetSpec:

	/* get the constraints of the element set spec */
	GetAllPERFromElementSetSpecs(ass,
	    element->U.ElementSetSpec.ElementSetSpec,
	    evalue, valueConstraints, evalueConstraints,
	    esize, sizeConstraints, esizeConstraints,
	    epermAlpha, permAlphaConstraints, epermAlphaConstraints,
	    inPermAlpha);
	break;

    default:
	MyAbort();
    }
}

/* intersect two value constraints */
static void
IntersectValueConstraints(AssignmentList_t ass,
    ValueConstraintList_t *result,
    ValueConstraintList_t val1, ValueConstraintList_t val2)
{
    ValueConstraint_t *v1, *v2;
    EndPoint_t lo, up;

    /*XXX may be optimized for better results */

    /* unite intersection of each pair of value ranges */
    for (v1 = val1; v1; v1 = v1->Next) {
	for (v2 = val2; v2; v2 = v2->Next) {

	    /* get bigger lower bound */
	    if (CmpLowerEndPoint(ass, &v1->Lower, &v2->Lower) >= 0)
		lo = v1->Lower;
	    else
		lo = v2->Lower;

	    /* get smaller upper bound */
	    if (CmpUpperEndPoint(ass, &v1->Upper, &v2->Upper) <= 0)
		up = v1->Upper;
	    else
		up = v2->Upper;

	    /* add intersection if it is not empty */
	    if ((lo.Flags & eEndPoint_Min) ||
		(up.Flags & eEndPoint_Max) ||
		CmpLowerUpperEndPoint(ass, &lo, &up) <= 0) {
		*result = NewValueConstraint();
		(*result)->Lower = lo;
		(*result)->Upper = up;
		result = &(*result)->Next;
	    }
	}
    }
    *result = NULL;
}

/* unite two value constraints */
static void
UniteValueConstraints(ValueConstraintList_t *result,
    ValueConstraintList_t val1, ValueConstraintList_t val2)
{
    /*XXX may be optimized for better results */
    for (; val1; val1 = val1->Next) {
	*result = NewValueConstraint();
	(*result)->Lower = val1->Lower;
	(*result)->Upper = val1->Upper;
	result = &(*result)->Next;
    }
    for (; val2; val2 = val2->Next) {
	*result = NewValueConstraint();
	(*result)->Lower = val2->Lower;
	(*result)->Upper = val2->Upper;
	result = &(*result)->Next;
    }
    *result = NULL;
}

/* negate a value constraint */
static void
NegateValueConstraints(AssignmentList_t ass, ValueConstraintList_t *result,
    ValueConstraintList_t val)
{
    ValueConstraint_t *vc, *lvc, *uvc;
    EndPoint_t *lower, *upper;

    *result = NewValueConstraint();
    (*result)->Lower.Flags = eEndPoint_Min;
    (*result)->Upper.Flags = eEndPoint_Max;
    for (; val; val = val->Next) {
	lower = &val->Lower;
	upper = &val->Upper;
	if (!(upper->Flags & eEndPoint_Max)) {
	    uvc = NewValueConstraint();
	    uvc->Lower.Flags = (upper->Flags & eEndPoint_Open) ^ eEndPoint_Open;
	    uvc->Lower.Value = upper->Value;
	    uvc->Upper.Flags = eEndPoint_Max;
	} else {
	    uvc = NULL;
	}
	if (!(lower->Flags & eEndPoint_Min)) {
	    lvc = NewValueConstraint();
	    lvc->Lower.Flags = eEndPoint_Min;
	    lvc->Upper.Flags = (lower->Flags & eEndPoint_Open) ^ eEndPoint_Open;
	    lvc->Upper.Value = lower->Value;
	} else {
	    lvc = NULL;
	}
	if (!lvc && !uvc) {
	    *result = NULL;
	    return;
	}
	if (lvc) {
	    vc = lvc;
	    if (uvc)
		vc->Next = uvc;
	} else {
	    vc = uvc;
	}
	IntersectValueConstraints(ass, result, *result, vc);
    }
}

/* substract two value constraints */
static void
ExcludeValueConstraints(AssignmentList_t ass, ValueConstraintList_t *result,
    ValueConstraintList_t val1, ValueConstraintList_t val2)
{
    ValueConstraint_t *notval2;

    NegateValueConstraints(ass, &notval2, val2);
    IntersectValueConstraints(ass, result, val1, notval2);
}

/* intersect two constraints */
static void
IntersectPERConstraints(AssignmentList_t ass,
    Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1,
    Extension_e type2,
    ValueConstraintList_t val2, ValueConstraintList_t eval2)
{
    if (type1 == eExtension_Unconstrained) {
	if (rtype)
	    *rtype = type2;
	if (result)
	    *result = val2;
	if (eresult)
	    *eresult = eval2;
    } else if (type2 == eExtension_Unconstrained) {
	if (rtype)
	    *rtype = type1;
	if (result)
	    *result = val1;
	if (eresult)
	    *eresult = eval1;
    } else {
	if (rtype)
	    *rtype = type1 < type2 ? type1 : type2;
	if (result)
	    IntersectValueConstraints(ass, result, val1, val2);
	if (rtype && *rtype == eExtension_Extended && eresult)
	    IntersectValueConstraints(ass, eresult, eval1, eval2);
    }
}

/* unite two constraints */
static void
UnitePERConstraints(Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1,
    Extension_e type2,
    ValueConstraintList_t val2, ValueConstraintList_t eval2)
{
    if (type1 == eExtension_Unconstrained) {
	if (rtype)
	    *rtype = type2;
	if (result)
	    *result = val2;
	if (eresult)
	    *eresult = eval2;
    } else if (type2 == eExtension_Unconstrained) {
	if (rtype)
	    *rtype = type1;
	if (result)
	    *result = val1;
	if (eresult)
	    *eresult = eval1;
    } else {
	if (rtype)
	    *rtype = type1 > type2 ? type1 : type2;
	if (result)
	    UniteValueConstraints(result, val1, val2);
	if (rtype && *rtype == eExtension_Extended && eresult)
	    UniteValueConstraints(eresult,
		eval1 ? eval1 : val1, eval2 ? eval2 : val2);
    }
}

/* negate a constraint */
static void
NegatePERConstraints(AssignmentList_t ass,
    Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1)
{
    if (rtype)
	*rtype = type1;
    if (result)
	NegateValueConstraints(ass, result, val1);
    if (rtype && *rtype == eExtension_Extended && eresult)
	NegateValueConstraints(ass, eresult, eval1);
}

/* substract two constraints */
static void
ExcludePERConstraints(AssignmentList_t ass,
    Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1,
    Extension_e type2,
    ValueConstraintList_t val2, ValueConstraintList_t eval2)
{
    if (type1 == eExtension_Unconstrained) {
	if (rtype)
	    *rtype = type2;
	if (result)
	    *result = val2;
	if (eresult)
	    *eresult = eval2;
    } else if (type2 == eExtension_Unconstrained) {
	if (rtype)
	    *rtype = type1;
	if (result)
	    *result = val1;
	if (eresult)
	    *eresult = eval1;
    } else {
	if (rtype)
	    *rtype = type1 < type2 ? type1 : type2;
	if (result)
	    ExcludeValueConstraints(ass, result, val1, val2);
	if (rtype && *rtype == eExtension_Extended && eresult)
	    ExcludeValueConstraints(ass, eresult, eval1, eval2);
    }
}

/* compare two value constraints */
static int
CmpValueConstraints(const void *v1, const void *v2, void *ctx)
{
    ValueConstraint_t *vc1 = (ValueConstraint_t *)v1;
    ValueConstraint_t *vc2 = (ValueConstraint_t *)v2;
    Assignment_t *ass = (Assignment_t *)ctx;
    int r;

    r = CmpLowerEndPoint(ass, &vc1->Lower, &vc2->Lower);
    if (r)
	return r;
    return CmpUpperEndPoint(ass, &vc1->Upper, &vc2->Upper);
}

/* reduce a value constraint by concatenation of value ranges (if possible) */
void
ReduceValueConstraints(AssignmentList_t ass, ValueConstraintList_t *valueConstraints)
{
    ValueConstraint_t *p;
    EndPoint_t lower, upper, lower2, upper2;
    int flg;

    if (!*valueConstraints)
	return;
    qsortSL((void **)valueConstraints, offsetof(ValueConstraint_t, Next),
    	CmpValueConstraints, ass);
    flg = 0;
    for (p = *valueConstraints; p; p = p->Next) {
    	if (flg) {
	    lower2 = p->Lower;
	    upper2 = p->Upper;
	    if (CheckEndPointsJoin(ass, &upper, &lower2)) {
		upper = upper2;
		continue;
	    }
	    *valueConstraints = NewValueConstraint();
	    /*LINTED*/
	    (*valueConstraints)->Lower = lower;
	    (*valueConstraints)->Upper = upper;
	    valueConstraints = &(*valueConstraints)->Next;
	}
	lower = p->Lower;
	upper = p->Upper;
	flg = 1;
    }
    *valueConstraints = NewValueConstraint();
    (*valueConstraints)->Lower = lower;
    (*valueConstraints)->Upper = upper;
    (*valueConstraints)->Next = NULL;
}

/* count the values of a value constraint */
int
CountValues(AssignmentList_t ass, ValueConstraintList_t v, intx_t *n) {
    intx_t ix;

    intx_setuint32(n, 0);
    for (; v; v = v->Next) {
	if ((v->Lower.Flags & eEndPoint_Min) ||
	    (v->Upper.Flags & eEndPoint_Max))
	    return 0;
	if (!SubstractValues(ass, &ix, v->Lower.Value, v->Upper.Value))
	    return 0;
	intx_add(n, n, &ix);
	intx_inc(n);
    }
    return 1;
}


/* check if the value constraint of a value is empty */
int
HasNoValueConstraint(ValueConstraintList_t v)
{
    EndPoint_t *p1, *p2;

    if (!v)
	return 1;
    if (!v->Next) {
	p1 = &v->Lower;
	p2 = &v->Upper;
	if ((p1->Flags & eEndPoint_Min) &&
	    (p2->Flags & eEndPoint_Max)) {
	    return 1;
	}
    }
    return 0;
}

/* check if the value constraint of a size is empty */
int
HasNoSizeConstraint(AssignmentList_t ass, ValueConstraintList_t v)
{
    EndPoint_t *p1, *p2;

    if (!v)
	return 1;
    if (!v->Next) {
	p1 = &v->Lower;
	p2 = &v->Upper;
	if (!(p1->Flags & eEndPoint_Min) &&
	    !intx_cmp(&GetValue(ass, p1->Value)->U.Integer.Value,
	    &intx_0) && (p2->Flags & eEndPoint_Max)) {
	    return 1;
	}
    }
    return 0;
}

/* check if the value constraint of a permitted alphabet is empty */
int
HasNoPermittedAlphabetConstraint(AssignmentList_t ass, ValueConstraintList_t v)
{
    EndPoint_t *p1, *p2;

    if (!v)
	return 1;
    if (!v->Next) {
	p1 = &v->Lower;
	p2 = &v->Upper;
	if (!(p1->Flags & eEndPoint_Min) &&
	    GetValue(ass, p1->Value)->U.RestrictedString.Value.length == 1 &&
	    GetValue(ass, p1->Value)->U.RestrictedString.Value.value[0] == 0 &&
	    !(p2->Flags & eEndPoint_Max) &&
	    GetValue(ass, p2->Value)->U.RestrictedString.Value.length == 1 &&
	    GetValue(ass, p2->Value)->U.RestrictedString.Value.value[0]
	    == 0xffffffff) {
	    return 1;
	}
    }
    return 0;
}

/* get the fixed identification */
/* this is needed for embedded pdv/character string types who are encoded */
/* in an "optimized" manner if the identification is fixed */
NamedValue_t *
GetFixedIdentification(AssignmentList_t ass, Constraint_t *constraints)
{
    if (!constraints)
	return NULL;
    return GetFixedIdentificationFromElementSetSpec(ass, constraints->Root);
}

/* get the fixed identification from an element set spec */
static NamedValue_t *
GetFixedIdentificationFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elements)
{
    NamedConstraint_t *named;
    NamedValue_t *nv1, *nv2;
    SubtypeElement_t *se;

    if (!elements)
	return NULL;
    switch (elements->Type) {
    case eElementSetSpec_AllExcept:
	return NULL;
    case eElementSetSpec_Union:
	nv1 = GetFixedIdentificationFromElementSetSpec(ass,
	    elements->U.Union.Elements1);
	nv2 = GetFixedIdentificationFromElementSetSpec(ass,
	    elements->U.Union.Elements2);
	return nv1 && nv2 ? nv1 : NULL; /*XXX conflicts ignored */
    case eElementSetSpec_Intersection:
	nv1 = GetFixedIdentificationFromElementSetSpec(ass,
	    elements->U.Union.Elements1);
	nv2 = GetFixedIdentificationFromElementSetSpec(ass,
	    elements->U.Union.Elements2);
	return nv1 ? nv1 : nv2; /*XXX conflicts ignored */
    case eElementSetSpec_Exclusion:
	nv1 = GetFixedIdentificationFromElementSetSpec(ass,
	    elements->U.Exclusion.Elements1);
	nv2 = GetFixedIdentificationFromElementSetSpec(ass,
	    elements->U.Exclusion.Elements2);
	return nv1 && !nv2 ? nv1 : NULL; /*XXX conflicts ignored */
    case eElementSetSpec_SubtypeElement:
	se = elements->U.SubtypeElement.SubtypeElement;
	switch (se->Type) {
	case eSubtypeElement_FullSpecification:
	case eSubtypeElement_PartialSpecification:
	    for (named = se->U.FP.NamedConstraints; named;
		named = named->Next) {
		if (!strcmp(named->Identifier, "identification"))
		    return GetFixedSyntaxes(ass, named->Constraint);
	    }
	    break;
	}
	return NULL;
    default:
	MyAbort();
	/*NOTREACHED*/
    }
    return NULL;
}

/* get the fixed syntaxes from a constraint */
static NamedValue_t *
GetFixedSyntaxes(AssignmentList_t ass, Constraint_t *constraints)
{
    if (!constraints)
	return NULL;
    return GetFixedSyntaxesFromElementSetSpec(ass, constraints->Root);
}

/* get the fixed syntaxes from an element set spec */
static NamedValue_t *
GetFixedSyntaxesFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elements)
{
    int present, absent, bit;
    Constraint_t *presentconstraints[6];
    NamedConstraint_t *named;
    NamedValue_t *nv1, *nv2;
    SubtypeElement_t *se;

    if (!elements)
	return NULL;
    switch (elements->Type) {
    case eElementSetSpec_AllExcept:
	return NULL;
    case eElementSetSpec_Union:
	nv1 = GetFixedSyntaxesFromElementSetSpec(ass,
	    elements->U.Union.Elements1);
	nv2 = GetFixedSyntaxesFromElementSetSpec(ass,
	    elements->U.Union.Elements2);
	return nv1 && nv2 ? nv1 : NULL; /*XXX conflicts ignored */
    case eElementSetSpec_Intersection:
	nv1 = GetFixedSyntaxesFromElementSetSpec(ass,
	    elements->U.Intersection.Elements1);
	nv2 = GetFixedSyntaxesFromElementSetSpec(ass,
	    elements->U.Intersection.Elements2);
	return nv1 ? nv1 : nv2; /*XXX conflicts ignored */
    case eElementSetSpec_Exclusion:
	nv1 = GetFixedSyntaxesFromElementSetSpec(ass,
	    elements->U.Exclusion.Elements1);
	nv2 = GetFixedSyntaxesFromElementSetSpec(ass,
	    elements->U.Exclusion.Elements2);
	return nv1 && !nv2 ? nv1 : NULL; /*XXX conflicts ignored */
    case eElementSetSpec_SubtypeElement:
	se = elements->U.SubtypeElement.SubtypeElement;
	switch (se->Type) {
	case eSubtypeElement_FullSpecification:
	case eSubtypeElement_PartialSpecification:
	    present = absent = 0;
	    for (named = se->U.FP.NamedConstraints; named;
		named = named->Next) {
		if (!strcmp(named->Identifier, "syntaxes")) {
		    bit = 0;
		} else if (!strcmp(named->Identifier, "syntax")) {
		    bit = 1;
		} else if (!strcmp(named->Identifier,
		    "presentation-context-id")) {
		    bit = 2;
		} else if (!strcmp(named->Identifier, "context-negotiation")) {
		    bit = 3;
		} else if (!strcmp(named->Identifier, "transfer-syntax")) {
		    bit = 4;
		} else if (!strcmp(named->Identifier, "fixed")) {
		    bit = 5;
		}
		switch (named->Presence) {
		case ePresence_Normal:
		    if (se->Type == eSubtypeElement_PartialSpecification)
			break;
		    /*FALLTHROUGH*/
		case ePresence_Present:
		    present |= (1 << bit);
		    presentconstraints[bit] = named->Constraint;
		    break;
		case ePresence_Absent:
		    absent |= (1 << bit);
		    break;
		case ePresence_Optional:
		    break;
		}
	    }
	    if (se->Type == eSubtypeElement_FullSpecification)
		absent |= (0x3f & ~present);
	    if (present == 0x20 && absent == 0x1f)
		return NewNamedValue("fixed", Builtin_Value_Null);
	    if (present == 0x01 && absent == 0x3e)
		return GetFixedAbstractAndTransfer(ass, presentconstraints[0]);
	    return NULL;
	}
	return NULL;
    default:
	MyAbort();
	/*NOTREACHED*/
    }
    return NULL;
}

/* get the fixed abstract and transfer from a constraint */
static NamedValue_t *
GetFixedAbstractAndTransfer(AssignmentList_t ass, Constraint_t *constraints)
{
    if (!constraints)
	return NULL;
    return GetFixedAbstractAndTransferFromElementSetSpec(ass,
	constraints->Root);
}

/* get the fixed abstract and transfer from an element set spec */
static NamedValue_t *
GetFixedAbstractAndTransferFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elements)
{
    NamedValue_t *nv1, *nv2;
    SubtypeElement_t *se;

    if (!elements)
	return NULL;
    switch (elements->Type) {
    case eElementSetSpec_AllExcept:
	return NULL;
    case eElementSetSpec_Union:
	nv1 = GetFixedAbstractAndTransferFromElementSetSpec(ass,
	    elements->U.Union.Elements1);
	nv2 = GetFixedAbstractAndTransferFromElementSetSpec(ass,
	    elements->U.Union.Elements2);
	return nv1 && nv2 ? nv1 : NULL; /*XXX conflicts ignored */
    case eElementSetSpec_Intersection:
	nv1 = GetFixedAbstractAndTransferFromElementSetSpec(ass,
	    elements->U.Intersection.Elements1);
	nv2 = GetFixedAbstractAndTransferFromElementSetSpec(ass,
	    elements->U.Intersection.Elements2);
	return nv1 ? nv1 : nv2; /*XXX conflicts ignored */
    case eElementSetSpec_Exclusion:
	nv1 = GetFixedAbstractAndTransferFromElementSetSpec(ass,
	    elements->U.Exclusion.Elements1);
	nv2 = GetFixedAbstractAndTransferFromElementSetSpec(ass,
	    elements->U.Exclusion.Elements2);
	return nv1 && !nv2 ? nv1 : NULL; /*XXX conflicts ignored */
    case eElementSetSpec_SubtypeElement:
	se = elements->U.SubtypeElement.SubtypeElement;
	switch (se->Type) {
	case eSubtypeElement_SingleValue:
	    return NewNamedValue("syntaxes", se->U.SingleValue.Value);
	}
	return NULL;
    default:
	MyAbort();
	/*NOTREACHED*/
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\undefine.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

/* print all undefined/unexported symbols and terminate */
void
UndefinedError(AssignmentList_t ass, UndefinedSymbolList_t undef, UndefinedSymbol_t *bad)
{
    UndefinedSymbol_t *u;
    char *type;
    int undefined = 0, unexported = 0;
    char *identifier;

    /* count undefined and unexported symbols */
    for (u = undef; u; u = u->Next) {
	switch (u->Type) {
	case eUndefinedSymbol_SymbolNotDefined:
	case eUndefinedSymbol_SymbolNotExported:
	    if (FindUndefinedSymbol(ass, bad, u->U.Symbol.ReferenceType,
		u->U.Symbol.Identifier, u->U.Symbol.Module))
		continue;
	    break;
	case eUndefinedSymbol_FieldNotDefined:
	case eUndefinedSymbol_FieldNotExported:
	    if (FindUndefinedField(ass, bad, u->U.Field.ReferenceFieldType,
		u->U.Field.ObjectClass, u->U.Field.Identifier,
		u->U.Field.Module))
		continue;
	    break;
	}
	switch (u->Type) {
	case eUndefinedSymbol_SymbolNotDefined:
	case eUndefinedSymbol_FieldNotDefined:
	    undefined = 1;
	    break;
	case eUndefinedSymbol_SymbolNotExported:
	case eUndefinedSymbol_FieldNotExported:
	    unexported = 1;
	    break;
	}
    }

    /* print the undefined symbols */
    if (undefined) {
	fprintf(stderr, "Following symbols are undefined:\n");
	for (u = undef; u; u = u->Next) {
	    if (u->Type == eUndefinedSymbol_SymbolNotExported ||
	        u->Type == eUndefinedSymbol_FieldNotExported)
		continue;
	    if (u->Type == eUndefinedSymbol_SymbolNotDefined &&
		FindUndefinedSymbol(ass, bad, u->U.Symbol.ReferenceType,
		u->U.Symbol.Identifier, u->U.Symbol.Module))
		continue;
	    if (u->Type == eUndefinedSymbol_FieldNotDefined &&
		FindUndefinedField(ass, bad, u->U.Field.ReferenceFieldType,
		u->U.Field.ObjectClass, u->U.Field.Identifier,
		u->U.Field.Module))
		continue;
	    if (u->Type == eUndefinedSymbol_SymbolNotDefined) {
		switch (u->U.Symbol.ReferenceType) {
		case eAssignment_Type:
		    type = "type";
		    break;
		case eAssignment_Value:
		    type = "value";
		    break;
		case eAssignment_ObjectClass:
		    type = "object class";
		    break;
		case eAssignment_Object:
		    type = "object";
		    break;
		case eAssignment_ObjectSet:
		    type = "object set";
		    break;
		case eAssignment_Macro:
		    type = "macro";
		    break;
		case eAssignment_Undefined:
		    if (isupper(*u->U.Symbol.Identifier))
			type = "type?";
		    else if (islower(*u->U.Symbol.Identifier))
			type = "value?";
		    else
			type = "?";
		    break;
		default:
		    MyAbort();
		    /*NOTREACHED*/
		}
		identifier = u->U.Symbol.Identifier ?
		    u->U.Symbol.Identifier : "<unnamed>";
		if (u->U.Symbol.Module) {
		    fprintf(stderr, "%s.%s (%s)\n",
			u->U.Symbol.Module->Identifier, identifier, type);
		} else {
		    fprintf(stderr, "%s (%s)\n", identifier, type);
		}
	    } else {
		switch (u->U.Field.ReferenceFieldType) {
		case eSetting_Type:
		    type = "type field";
		    break;
		case eSetting_Value:
		    type = "value field";
		    break;
		case eSetting_ValueSet:
		    type = "value set field";
		    break;
		case eSetting_Object:
		    type = "object field";
		    break;
		case eSetting_ObjectSet:
		    type = "object set field";
		    break;
		case eAssignment_Macro:
		    type = "macro";
		    break;
		default:
		    MyAbort();
		    /*NOTREACHED*/
		}
		identifier = u->U.Field.Identifier ?
		    u->U.Field.Identifier : "<unnamed>";
		if (u->U.Field.Module) {
		    fprintf(stderr, "%s.%s.%s (%s)\n",
			u->U.Field.Module->Identifier,
			u->U.Field.ObjectClass->U.Reference.Identifier,
			identifier, type);
		} else {
		    fprintf(stderr, "%s.%s (%s)\n",
			u->U.Field.ObjectClass->U.Reference.Identifier,
			identifier, type);
		}
	    }
	}
    }

    /* print the unexported symbols */
    if (unexported) {
	fprintf(stderr, "Following symbols have not been exported:\n");
	for (u = undef; u; u = u->Next) {
	    if (u->Type == eUndefinedSymbol_SymbolNotDefined ||
	        u->Type == eUndefinedSymbol_FieldNotDefined)
		continue;
	    if (u->Type == eUndefinedSymbol_SymbolNotExported &&
		FindUndefinedSymbol(ass, bad, u->U.Symbol.ReferenceType,
		u->U.Symbol.Identifier, u->U.Symbol.Module))
		continue;
	    if (u->Type == eUndefinedSymbol_FieldNotExported &&
		FindUndefinedField(ass, bad, u->U.Field.ReferenceFieldType,
		u->U.Field.ObjectClass, u->U.Field.Identifier,
		u->U.Field.Module))
		continue;
	    if (u->Type == eUndefinedSymbol_SymbolNotExported) {
		switch (u->U.Symbol.ReferenceType) {
		case eAssignment_Type:
		    type = "type";
		    break;
		case eAssignment_Value:
		    type = "value";
		    break;
		case eAssignment_ObjectClass:
		    type = "object class";
		    break;
		case eAssignment_Object:
		    type = "object";
		    break;
		case eAssignment_ObjectSet:
		    type = "object set";
		    break;
		case eAssignment_Macro:
		    type = "macro";
		    break;
		case eAssignment_Undefined:
		    if (isupper(*u->U.Symbol.Identifier))
			type = "type?";
		    else if (islower(*u->U.Symbol.Identifier))
			type = "value?";
		    else
			type = "?";
		    break;
		default:
		    MyAbort();
		    /*NOTREACHED*/
		}
		identifier = u->U.Symbol.Identifier ?
		    u->U.Symbol.Identifier : "<unnamed>";
		if (u->U.Symbol.Module) {
		    fprintf(stderr, "%s.%s (%s)\n",
			u->U.Symbol.Module->Identifier, identifier, type);
		} else {
		    fprintf(stderr, "%s (%s)\n", identifier, type);
		}
	    } else {
		switch (u->U.Field.ReferenceFieldType) {
		case eSetting_Type:
		    type = "type field";
		    break;
		case eSetting_Value:
		    type = "value field";
		    break;
		case eSetting_ValueSet:
		    type = "value set field";
		    break;
		case eSetting_Object:
		    type = "object field";
		    break;
		case eSetting_ObjectSet:
		    type = "object set field";
		    break;
		case eAssignment_Macro:
		    type = "macro";
		    break;
		default:
		    MyAbort();
		    /*NOTREACHED*/
		}
		identifier = u->U.Field.Identifier ?
		    u->U.Field.Identifier : "<unnamed>";
		if (u->U.Field.Module) {
		    fprintf(stderr, "%s.%s.%s (%s)\n",
			u->U.Field.Module->Identifier,
			u->U.Field.ObjectClass->U.Reference.Identifier,
			identifier, type);
		} else {
		    fprintf(stderr, "%s.%s (%s)\n",
			u->U.Field.ObjectClass->U.Reference.Identifier,
			identifier, type);
		}
	    }
	}
    }
    MyExit(1);
}

/* compare two undefined symbol entries */
/* return 0 if equal */
int CmpUndefinedSymbol(AssignmentList_t ass, UndefinedSymbol_t *u1, UndefinedSymbol_t *u2) {
    if (u1->Type != u2->Type)
	return 1;
    switch (u1->Type) {
    case eUndefinedSymbol_SymbolNotExported:
    case eUndefinedSymbol_SymbolNotDefined:
        return strcmp(u1->U.Symbol.Identifier, u2->U.Symbol.Identifier) ||
	    u1->U.Symbol.Module && !u2->U.Symbol.Module ||
	    !u1->U.Symbol.Module && u2->U.Symbol.Module ||
	    u1->U.Symbol.Module && u2->U.Symbol.Module &&
	    CmpModuleIdentifier(ass, u1->U.Symbol.Module, u2->U.Symbol.Module);
    case eUndefinedSymbol_FieldNotExported:
    case eUndefinedSymbol_FieldNotDefined:
        return strcmp(u1->U.Field.Identifier, u2->U.Field.Identifier) ||
	    strcmp(u1->U.Field.ObjectClass->U.Reference.Identifier,
	    u2->U.Field.ObjectClass->U.Reference.Identifier) ||
	    CmpModuleIdentifier(ass,
	    u1->U.Field.ObjectClass->U.Reference.Module,
	    u2->U.Field.ObjectClass->U.Reference.Module) ||
	    u1->U.Field.Module && !u2->U.Field.Module ||
	    !u1->U.Field.Module && u2->U.Field.Module ||
	    u1->U.Field.Module && u2->U.Field.Module &&
	    CmpModuleIdentifier(ass, u1->U.Field.Module, u2->U.Field.Module);
    default:
	MyAbort();
	/*NOTREACHED*/
    }
    return 1; // not equal
}

/* compare two lists of undefined symbols */
int CmpUndefinedSymbolList(AssignmentList_t ass, UndefinedSymbolList_t u1, UndefinedSymbolList_t u2) {
    for (; u1 && u2; u1 = u1->Next, u2 = u2->Next) {
	if (CmpUndefinedSymbol(ass, u1, u2))
	    return 1;
    }
    return u1 || u2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\util.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_UTIL_H_
#define _ASN1C_UTIL_H_

size_t SLlength(void *head, size_t offset);
int SLcontains(void *head, size_t offset, void *elem);
void SLtoA(void *head, size_t offset, size_t elemsize, void **base, size_t *nelem);
void SLtoAP(void *head, size_t offset, void ***base, size_t *nelem);
void AtoSL(void *base, size_t offset, size_t nelem, size_t elemsize, void **head);
void qsortSL(void **head, size_t offset, int (*cmpfn)(const void *, const void *, void *), void *context);

void MyAbort(void);
void MyExit(int val);

#endif /* _ASN1C_UTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\scanner.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
 */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5

#include <stdio.h>


/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif


#ifdef __cplusplus

#include <stdlib.h>
#include <unistd.h>

/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else	/* ! __cplusplus */

#if __STDC__

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif	/* __STDC__ */
#endif	/* ! __cplusplus */

#ifdef __TURBOC__
 #pragma warn -rch
 #pragma warn -use
#include <io.h>
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#endif

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif


#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

#include "hackdir.h"

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 16384

typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;
extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 * 	if ( condition_holds )
 *		yyless( 5 );
 *	else
 *		do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		*yy_cp = yy_hold_char; \
		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int yy_size_t;


struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_size_t yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2
	};

static YY_BUFFER_STATE yy_current_buffer = 0;

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer


/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;

static int yy_n_chars;		/* number of characters read into yy_ch_buf */


int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 1;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart YY_PROTO(( FILE *input_file ));

void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
void yy_load_buffer_state YY_PROTO(( void ));
YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )

YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));

static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
static void yy_flex_free YY_PROTO(( void * ));

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! yy_current_buffer ) \
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	yy_current_buffer->yy_is_interactive = is_interactive; \
	}

#define yy_set_bol(at_bol) \
	{ \
	if ( ! yy_current_buffer ) \
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	yy_current_buffer->yy_at_bol = at_bol; \
	}

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)

typedef unsigned char YY_CHAR;
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
typedef int yy_state_type;
extern char *yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state YY_PROTO(( void ));
static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
static int yy_get_next_buffer YY_PROTO(( void ));
static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	yytext_ptr = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
	yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
	yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 126
#define YY_END_OF_BUFFER 127
static yyconst short int yy_accept[722] =
    {   0,
        0,    0,    0,    0,  127,  125,  123,  123,  124,   89,
       96,  125,  125,   89,   89,   93,   93,   89,   97,   97,
       97,   97,   97,   97,   97,   97,   97,   97,   97,   97,
       97,   97,   97,   97,   97,   97,   97,  100,  100,  100,
      100,  100,  100,  100,  121,  120,  105,  126,  121,  121,
      121,  121,  117,  121,  121,  123,  102,  101,    0,    0,
        0,  122,   92,   93,    0,    0,   98,   97,   97,   97,
       97,   97,   97,   99,   97,   97,   97,   97,   11,   97,
       97,   97,   97,   97,   97,   97,   97,   97,   99,   99,
       97,   97,   97,   97,   97,   97,   97,   97,   97,   99,

       97,   97,   58,   97,   99,   97,   97,   97,   99,   97,
       97,   97,   97,   97,   98,   97,   97,   97,   99,   97,
       97,   99,   97,   99,   97,    0,  100,  100,  100,  100,
      100,  100,  100,  121,  120,  104,  121,  121,  107,  121,
      121,  113,  121,  119,  121,  121,  121,  121,  115,    0,
      102,    0,  101,   94,   95,    0,  103,   91,   90,    0,
       97,    3,    4,   97,   97,    0,   97,    8,   97,   97,
       97,   97,   97,   97,   97,   97,   97,   23,   97,   97,
       97,   97,   97,   97,   99,   99,   98,   97,   97,   97,
       97,   97,   97,   97,   48,   49,   97,   97,   99,   97,

       97,   97,   99,   60,   97,   97,   97,   99,   97,   97,
       67,   97,   97,   97,   98,   97,   97,   97,   99,   97,
       97,   97,   99,   97,   99,   99,   97,  100,  100,  100,
      100,  100,  100,  111,  121,  121,  121,    0,  121,  121,
      109,  121,   97,   97,   97,   97,   97,   97,   97,   97,
       97,   97,   97,   97,   97,   97,   97,   97,   97,   97,
       97,   97,   97,   31,   99,   99,   98,   97,   97,   97,
       97,   97,   97,   98,   97,   97,   97,   52,   99,   97,
       97,   97,   99,   97,   97,   97,   99,   65,   97,   68,
       97,   97,   98,   73,   75,   76,   99,   97,   97,   97,

       97,   98,   99,   97,   99,   99,   88,  100,  100,  100,
      100,   77,  100,  121,  121,  121,    0,  121,  121,  121,
       97,   97,   97,   97,    7,   99,   97,   97,   97,   14,
       97,   97,   97,   97,   97,   97,   97,   97,   97,   97,
       97,   30,   99,   99,   99,   97,   97,   97,   97,   97,
       97,   97,   98,   47,   97,   97,   99,   97,   57,   97,
       99,    0,   97,   97,   99,   97,   97,   97,   99,    0,
       99,   78,   97,   97,   99,   98,   99,   84,   99,   99,
       22,  100,  100,  100,   85,  121,  121,  121,    0,  121,
      121,    0,    1,   97,   97,   97,   99,   97,   97,   13,

       97,   97,   97,   97,   97,   97,   97,   25,   97,   97,
       97,   97,   99,   99,   99,   97,   97,   97,   97,   97,
       97,   97,   97,   98,    0,   97,   99,   55,   97,   99,
       97,   97,   97,   99,   97,   69,   71,   99,   97,   99,
       79,   97,   99,   99,   99,   99,   99,  100,   53,   70,
      121,    0,  121,    0,  121,  121,    0,   97,   97,   97,
       99,   10,   97,   97,   97,   18,   19,   97,   97,   97,
       97,   27,   97,   97,   99,   99,   99,   97,   97,   40,
       41,   97,   97,   44,   97,   98,   97,   97,   99,   97,
       99,   97,   62,   64,   99,   97,   99,   97,   99,   97,

       82,   99,   99,   99,   99,  100,    0,    0,    0,    0,
      116,    0,    0,   97,   97,   97,   99,   97,   97,   97,
       97,   21,   97,   26,   97,   29,   99,   99,   99,   99,
       97,   39,   42,   43,   97,   99,   97,   51,   99,   59,
       99,   97,   99,   66,   99,   97,   99,   97,   99,   99,
       99,   99,  100,    0,    0,    0,    0,    0,    0,    0,
       97,    6,    9,   12,   15,   97,   97,   97,   97,   99,
       99,   99,   35,   97,   97,   99,   97,   99,   99,   97,
       99,   72,   97,   99,   80,   99,   99,   99,   99,  100,
        0,    0,    0,    0,    0,    0,   97,   97,   16,   97,

       97,   24,   97,   99,   99,   99,   37,   97,   99,   97,
       99,   99,   97,   99,   97,   99,   83,   99,   99,   99,
       38,    0,    0,    0,  118,    0,    0,   97,    5,   17,
       20,   97,   99,   99,   99,   97,   99,   97,   99,   99,
       97,   99,   97,   99,   99,   99,   99,    0,  106,    0,
        0,    0,   97,   97,   99,   99,   99,   45,   46,   97,
       99,   99,   97,   99,   97,   99,   99,   99,   99,    0,
        0,    0,    0,   97,   28,   33,   99,   34,   97,   54,
       99,   61,   99,   97,   74,   99,   99,   87,    0,    0,
        0,    0,   97,   99,   50,   99,   99,   97,   99,   86,

        0,  112,    0,    0,    2,   32,   99,   63,   36,   81,
        0,    0,  114,   56,    0,    0,    0,    0,  110,  108,
        0
    } ;

static yyconst int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        2,    2,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    4,    1,    1,    1,    1,
        1,    2,    5,    6,    1,    7,    1,    8,    9,   10,
       11,    1,    1,   12,   13,   14,    1,   15,   16,   17,
       17,   18,   19,   20,   17,   21,   17,   22,   23,   24,
       25,   26,    1,   27,   28,   29,   30,   31,   32,   33,
       34,   35,   36,   37,   38,   39,   40,   41,   42,   43,
       44,   45,   46,   47,   48,   49,   50,   51,   52,   53,
       54,    1,   55,   56,    1,    1,   57,   58,   59,   60,

       61,   62,   63,   64,   65,   66,   67,   68,   69,   70,
       71,   72,   73,   74,   75,   76,   77,   78,   73,   79,
       80,   81,   82,   83,   84,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst int yy_meta[85] =
    {   0,
        1,    2,    2,    1,    1,    1,    1,    1,    2,    1,
        1,    1,    3,    1,    4,    4,    4,    4,    4,    4,
        4,    1,    1,    1,    1,    1,    1,    4,    4,    4,
        4,    4,    4,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    1,    1,    1,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    1,    1,    1
    } ;

static yyconst short int yy_base[729] =
    {   0,
        0,    0,   83,   97, 1486, 3743,   85,   87, 3743, 3743,
     3743,  151,   89, 1471, 1469, 3743,   96, 1449,  220,   89,
      273,  281,  294,  310,  311,  113,  334,  328,  349,  365,
      371,  386,  392,  418,  421,  444,  445, 1457,   80,   84,
       89,   94,   88,   81,    0,  121,    0, 1456,   35,   62,
       63,   68, 1397,   82,   87,  171, 1454, 1451,  302,   91,
     1445, 1446, 1437,  479, 1424,  472,  508,  475,  483,  533,
      534,  549,  555, 1434,  566,  572,  583,  594,  600,  616,
      622,  633,  646,  649,  662,  670,  673,  686,  164,  149,
      701,  704,  712,  727,  738,  753,  759,  770,  781,  234,

      794,  797,  810,  818,  109,  821,  834,  842,   95,  858,
      864,  875,  881,  892, 1429,  898,  909,  915,  262,  926,
      942,  261,  939,  306,  950, 1431, 1430,  133,  318,  263,
      232,  296,  315,    0,  334, 3743, 1372, 1362,    0, 1353,
     1360,    0, 1415,    0, 1357, 1351, 1347, 1339,    0, 1398,
     1396, 1392, 1391, 3743, 3743, 1363, 3743, 3743, 3743,    0,
      963,  974,  980,  991, 1002, 1383, 1013, 1019, 1030, 1036,
     1051, 1052, 1068, 1069, 1084, 1090, 1105, 1106, 1121, 1127,
     1138, 1144, 1155, 1166,  328,  312, 1348, 1179, 1182, 1190,
     1203, 1216, 1227, 1224, 1242, 1245, 1248, 1263,  335, 1266,

     1281, 1287,  348, 1298, 1304, 1315, 1326,  331, 1337, 1343,
     1354, 1360, 1371, 1377, 1344, 1388, 1394, 1409,  380, 1417,
     1433, 1434,  229, 1449,  390,  334, 1450,  373,  347,  374,
      357,  392,  330,    0, 1330, 1326, 1318, 1307, 1307, 1310,
        0, 1300, 1465, 1466, 1481, 1487, 1502, 1503, 1520, 1519,
     1535, 1541, 1552, 1563, 1574, 1580, 1595, 1598, 1606, 1619,
     1627, 1635, 1650, 1656,  429,  407, 1294, 1667, 1680, 1688,
     1691, 1709, 1706, 1350, 1717, 1732, 1738, 1753,  443, 1754,
     1769, 1780,  417, 1786, 1801, 1807,  430, 1818, 1824, 1835,
     1841, 1857, 1288, 1858, 1873, 1879,  452, 1890, 1896, 1911,

     1912, 1316,  441, 1932,  439,  424, 1933,  163,  454,  464,
      435, 1347,  506, 1291, 1297, 1277, 1280, 1273, 1280, 1329,
     1949, 1965, 1971, 1987, 1988,  494, 2004, 2010, 2025, 2026,
     2041, 2042, 2057, 2063, 2078, 2079, 2094, 2109, 2115, 2126,
     2132, 2147,  398,  462,  495, 2148, 2168, 2165, 2186, 2185,
     2203, 2202, 1320, 2218, 2224, 2235,  467, 2241, 2252, 2258,
      551, 2269, 2275, 2286,  476, 2297, 2303, 2314,  558, 2320,
      522, 2331, 2337, 2348,  465, 1262,  566, 2359,  552,  553,
     1323,  591,  572,  567, 1321, 1252, 1318, 1261, 1256, 1258,
     1238, 1241, 2365, 2380, 2383, 2386,  595, 2401, 2407, 2418,

     2424, 2440, 2446, 2461, 2467, 2484, 2483, 2499, 2500, 2515,
     2516, 2537,  557,  593,  603, 2538, 2553, 2559, 2570, 2576,
     2591, 2597, 2612, 1269, 2618, 2629,  621, 2635, 2651,  586,
     2652, 2667, 2680,  580, 2688, 2691, 2704,  641, 2715,  574,
     2712, 2728,  605,  597,  656,  634,  671,  636, 1299, 1295,
     1290, 1244, 1287, 1229, 1223, 1281, 1221, 2736, 2739, 2752,
      654, 2760, 2773, 2781, 2789, 2797, 2805, 2813, 2826, 2829,
     2842, 2853, 2859, 2870,  673,  691,  669, 2876, 2887, 2898,
     2904, 2915, 2921, 2936, 2937, 1204, 2952, 2953,  713, 2968,
      710, 2969, 2984, 2985,  694, 3002,  695, 3008,  741, 3024,

     1266,  670,  733,  735,  745,  750, 1210, 1199, 1190, 1185,
        0, 1192, 1184, 3025, 3040, 3041,  709, 3056, 3064, 3067,
     3080, 3088, 3101, 3109, 3117, 3125,  751,  765,  756,  771,
     3138, 3146, 3149, 3162, 3170,  780, 3173, 3186,  772, 3194,
      737, 3202,  782, 3210,  792, 3218,  776, 3226,  806,  748,
      784,  808,  795, 1189, 1178, 1178, 1182, 1176, 1171, 3234,
     3242, 3250, 1226, 3258, 3266, 3279, 3287, 3290, 3303,  793,
      828,  875, 1224, 3311, 3319,  763, 3332,  879,  866, 3335,
      867, 1223, 3343,  885, 3356,  882,  896,  923,  887,  902,
     1165, 1177, 1163, 1152, 1147, 1151, 3359, 3367, 3380, 3383,

     3391, 3404, 3412,  878,  812,  921, 3415, 3428,  881, 3436,
      947,  934, 3444,  951, 3452,  953, 1202,  957,  964,  960,
     1200, 1145, 1130, 1134, 3743, 1135, 1130, 3460, 3468, 3476,
     3484, 3492,  981,  855,  983, 3505,  992, 3513,  987,  971,
     3516,  994, 3529, 1013, 1011,  975, 1016, 1132, 3743, 1115,
     1128, 1131, 3537, 3540, 1001, 1022, 1003, 3557, 1169, 3560,
     1057, 1033, 3573, 1024, 3581, 1059, 1050, 1034, 1061, 1114,
     1111, 1098, 1079, 3598, 3599, 1139, 1088, 1130, 3614, 1129,
     1089, 3615, 1069, 3632,  988, 1093, 1108,  917,  906,  843,
      883,  742, 3631, 1090, 3647, 1128, 1115, 3648, 1127,  683,

      609, 3743,  523,  529, 3663,  477, 1123,  445, 3669,  423,
      262,  181, 3743,  231,  132,   96,   60,   58, 3743, 3743,
     3743, 3717, 3721, 3723, 3728, 3731, 3734, 3737
    } ;

static yyconst short int yy_def[729] =
    {   0,
      721,    1,  722,  722,  721,  721,  721,  721,  721,  721,
      721,  721,  723,  721,  721,  721,  721,  721,  721,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,  724,  724,  724,
      724,  724,  724,  724,  725,  725,  725,  721,  725,  725,
      725,  725,  725,  725,  725,  721,  726,  727,  723,  721,
      723,  721,  721,  721,  721,   19,   19,   19,   19,   19,
       19,   19,   19,  728,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,  728,  728,
       19,   19,   19,   19,   19,   19,   19,   19,   19,  728,

       19,   19,   19,   19,  728,   19,   19,   19,  728,   19,
       19,   19,   19,   19,   67,   19,   19,   19,  728,   19,
       19,  728,   19,  728,   19,  724,  724,  724,  724,  724,
      724,  724,  724,  725,  725,  721,  725,  725,  725,  725,
      725,  725,  725,  725,  725,  725,  725,  725,  725,  726,
      726,  727,  727,  721,  721,  721,  721,  721,  721,   67,
       19,   19,   19,   19,   19,  728,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,  728,  728,   67,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,  728,   19,

       19,   19,  728,   19,   19,   19,   19,  728,   19,   19,
       19,   19,   19,   19,   67,   19,   19,   19,  728,   19,
       19,   19,  728,   19,  728,  728,   19,  724,  724,  724,
      724,  724,  724,  725,  725,  725,  725,  721,  725,  725,
      725,  725,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,  728,  728,   67,   19,   19,   19,
       19,   19,   19,   67,   19,   19,   19,   19,  728,   19,
       19,   19,  728,   19,   19,   19,  728,   19,   19,   19,
       19,   19,   67,   19,   19,   19,  728,   19,   19,   19,

       19,   67,  728,   19,  728,  728,   19,  724,  724,  724,
      724,  724,  724,  725,  725,  725,  721,  725,  725,  725,
       19,   19,   19,   19,   19,  728,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,  728,  728,  728,   19,   19,   19,   19,   19,
       19,   19,   67,   19,   19,   19,  728,   19,   19,   19,
      728,   19,   19,   19,  728,   19,   19,   19,  728,   19,
      728,   19,   19,   19,  728,   67,  728,   19,  728,  728,
      724,  724,  724,  724,  724,  725,  725,  725,  721,  725,
      725,  721,   19,   19,   19,   19,  728,   19,   19,   19,

       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,  728,  728,  728,   19,   19,   19,   19,   19,
       19,   19,   19,   67,   19,   19,  728,   19,   19,  728,
       19,   19,   19,  728,   19,   19,   19,  728,   19,  728,
       19,   19,  728,  728,  728,  728,  728,  724,  724,  724,
      725,  721,  725,  721,  725,  725,  721,   19,   19,   19,
      728,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,  728,  728,  728,   19,   19,   19,
       19,   19,   19,   19,   19,   67,   19,   19,  728,   19,
      728,   19,   19,   19,  728,   19,  728,   19,  728,   19,

      728,  728,  728,  728,  728,  724,  721,  721,  721,  721,
      725,  721,  721,   19,   19,   19,  728,   19,   19,   19,
       19,   19,   19,   19,   19,   19,  728,  728,  728,  728,
       19,   19,   19,   19,   19,  728,   19,   19,  728,   19,
      728,   19,  728,   19,  728,   19,  728,   19,  728,  728,
      728,  728,  724,  721,  721,  721,  721,  721,  721,   19,
       19,   19,  728,   19,   19,   19,   19,   19,   19,  728,
      728,  728,  728,   19,   19,  728,   19,  728,  728,   19,
      728,  728,   19,  728,   19,  728,  728,  728,  728,  724,
      721,  721,  721,  721,  721,  721,   19,   19,   19,   19,

       19,   19,   19,  728,  728,  728,   19,   19,  728,   19,
      728,  728,   19,  728,   19,  728,  728,  728,  728,  728,
      724,  721,  721,  721,  721,  721,  721,   19,   19,   19,
       19,   19,  728,  728,  728,   19,  728,   19,  728,  728,
       19,  728,   19,  728,  728,  728,  728,  721,  721,  721,
      721,  721,   19,   19,  728,  728,  728,   19,  728,   19,
      728,  728,   19,  728,   19,  728,  728,  728,  728,  721,
      721,  721,  721,   19,   19,  728,  728,  728,   19,  728,
      728,   19,  728,   19,  728,  728,  728,  728,  721,  721,
      721,  721,   19,  728,   19,  728,  728,   19,  728,  728,

      721,  721,  721,  721,   19,  728,  728,  728,   19,  728,
      721,  721,  721,  728,  721,  721,  721,  721,  721,  721,
        0,  721,  721,  721,  721,  721,  721,  721
    } ;

static yyconst short int yy_nxt[3828] =
    {   0,
        6,    7,    8,    9,   10,   11,    6,   12,   13,   10,
       10,   10,   14,   15,   16,   17,   17,   17,   17,   17,
       17,   18,   10,   10,    6,   10,   10,   19,   20,   21,
       22,   23,   24,   25,   26,   27,   26,   26,   26,   28,
       29,   30,   31,   26,   32,   33,   34,   35,   36,   37,
       26,   26,   26,   10,   10,   10,   38,   38,   38,   38,
       39,   38,   38,   38,   40,   38,   38,   38,   38,   41,
       38,   38,   38,   38,   42,   43,   38,   44,   38,   38,
       38,   10,   10,   10,   46,   47,   56,   56,   56,   56,
       59,   59,  126,  126,   46,   48,  126,   60,   46,   47,

      126,  126,  137,   59,   59,  138,  126,  166,   46,   48,
       64,   64,   64,   64,   64,   64,   64,   68,  139,  154,
       75,  166,  135,  141,   76,  155,  140,   68,   77,   68,
       78,   68,  135,  720,  142,  719,   68,  133,  143,  144,
       79,   68,   49,  129,   50,  126,  146,  148,  128,  147,
       51,   68,   52,   68,   53,   68,   49,   54,   50,  208,
       68,  166,  149,   55,   51,  130,   52,  132,   53,  131,
      718,   54,   56,   56,  203,  126,  166,   55,   57,   57,
       57,   57,   57,   57,   57,   57,   57,   57,   57,   57,
       57,   57,   57,   57,   57,   57,   57,   57,   57,   57,

       57,   57,   57,   57,  228,  186,  717,   58,   58,   58,
       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
       58,   58,   66,  185,   67,   67,   67,   67,   67,   67,
       67,  166,  381,  166,  126,  716,  166,   68,   69,   68,
       68,   68,   68,   68,   68,   68,   68,   68,   70,   68,
       71,   68,   72,   68,   68,   68,   68,   73,   68,   68,
       68,   68,   68,  166,  166,  126,   74,   74,   74,   74,
       74,   74,   74,   74,   74,   74,   74,   74,   74,   74,
       74,   74,   74,   74,   74,   74,   74,   74,   74,   74,

       74,   68,  199,   59,   59,  231,  303,   80,  126,   68,
       60,   81,   83,   68,   82,   68,   59,   59,  166,   68,
       68,   68,   68,   68,  166,  223,  715,  126,   68,  219,
      126,  230,   68,   84,   85,  135,   68,   87,   68,   68,
      166,   68,  126,  166,   86,  135,  166,  166,   68,   68,
       68,   68,   68,   68,   88,   96,   68,   68,   68,  126,
      166,   91,   68,   97,   92,  225,   68,  232,   68,  126,
       68,   89,   68,   93,   94,   68,   68,   68,  229,   95,
      226,   68,  233,  266,   90,  126,  126,   68,  265,   68,
       98,   68,  166,  101,  102,  279,   99,  103,  306,   68,

      287,  106,  166,   68,  126,   68,  313,  104,  283,  107,
      166,   68,   68,   68,   68,  108,  309,  110,   68,  166,
       68,  311,  105,  111,   68,  100,   68,  112,   68,  166,
       68,  310,   68,   68,   68,  166,  166,  115,  113,   68,
      297,  166,  166,  114,  109,  116,   68,  126,  308,   68,
      305,  166,  312,  166,  413,  166,   68,  166,   68,   68,
       68,  120,  117,   68,  166,   68,  126,  121,   68,  118,
      344,  123,   68,   68,  166,  361,  126,  166,  119,  166,
      125,  380,   68,   68,   68,   68,   68,   68,  166,  166,
      122,   68,   68,   64,   64,   64,   64,   64,   64,   64,

       68,  377,  343,   68,  384,  365,  166,  166,  124,  379,
       68,   68,   68,   68,   68,   68,  357,   68,  126,   68,
      160,   68,   68,   68,  383,   68,  414,  371,  161,  382,
       68,  427,  434,  443,  166,   67,   67,   67,   67,   67,
       67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
       67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
       67,   68,   68,  166,  166,  166,  385,  397,  415,  166,
      166,  162,   68,   68,   68,   68,   68,   68,  166,  126,
       68,   68,  440,   68,  126,  163,  166,   68,  713,   68,
      712,  164,  166,   68,   68,   68,   68,   68,  166,  167,

       68,  165,   68,  126,   68,  166,   68,  166,   68,  166,
       68,   68,   68,   68,   68,  166,  491,  166,  168,   68,
      447,   68,   68,   68,  475,  169,  430,  446,   68,  450,
       68,  438,   68,  166,   68,  170,   68,  495,   68,  445,
       68,   68,   68,  171,   68,  449,  166,   68,  126,  173,
       68,  476,  499,  166,   68,  448,   68,  172,   68,  461,
       68,   68,   68,   68,   68,  501,  166,  477,  166,   68,
      502,   68,  174,  175,   68,   68,  711,  177,  176,  489,
       68,  166,  166,  166,   68,  166,   68,   68,   68,   68,
       68,   68,  178,   68,  504,  166,   68,  506,   68,  180,

       68,   68,   68,  166,   68,  497,  166,  166,   68,  179,
       68,  183,  181,   68,   68,   68,  182,   68,  527,  187,
       68,  166,  166,  517,   68,  166,   68,  184,   68,   68,
      503,  505,   68,   68,  549,  188,  529,  528,  530,   68,
       68,   68,   68,   68,   68,  166,   68,  166,   68,  166,
       68,   68,   68,  166,  189,   68,  190,  166,  539,   68,
      166,  543,  126,  166,  545,   68,   68,   68,  166,   68,
      541,  563,  191,  192,   68,  166,   68,  166,   68,  193,
       68,   68,  194,  166,  166,   68,  547,   68,  166,  550,
      552,   68,  166,   68,  166,   68,  166,   68,   68,  196,

       68,   68,  704,  195,  166,  166,   68,  126,   68,   68,
       68,  579,   68,  551,  553,  587,  197,   68,  166,  198,
      166,   68,   68,   68,  166,   68,  570,  609,   68,  588,
      200,  572,   68,  573,   68,   68,   68,   68,   68,   68,
      166,   68,  581,  201,   68,  571,   68,  578,   68,   68,
       68,  584,   68,  576,  582,  590,   68,   68,   68,   68,
       68,   68,   68,   68,  202,   68,  604,  166,   68,  204,
       68,  634,   68,  206,   68,  586,   68,  207,  166,  166,
       68,  205,   68,  589,   68,  209,   68,  166,  605,   68,
      166,  166,   68,  166,  166,  703,   68,  166,   68,  166,

       68,  656,   68,   68,   68,   68,   68,  210,  166,   68,
      211,   68,  614,   68,  126,   68,  702,   68,  701,   68,
       68,   68,   68,   68,  612,  213,   68,  212,   68,  166,
       68,  216,  214,  166,   68,  166,   68,   68,   68,   68,
       68,  618,  633,   68,  617,   68,  166,   68,  606,   68,
      637,   68,  611,   68,   68,   68,  217,  218,  616,  166,
      620,  220,   68,  166,   68,  166,   68,   68,   68,  166,
       68,  221,  166,   68,  222,  621,  166,  224,   68,   68,
       68,   68,   68,  166,   68,  635,   68,  166,   68,   68,
       68,   68,   68,  166,  243,  166,  227,   68,  619,  166,

      166,   68,   68,   68,  166,   68,  166,  640,   68,  244,
       68,  639,   68,  166,   68,  166,   68,  644,   68,   68,
       68,   68,   68,  166,  647,  166,  642,   68,  166,  245,
       68,   68,  645,   68,  166,  662,  166,  646,   68,  668,
       68,   68,   68,  246,   68,  166,  166,   68,  247,   68,
      655,   68,  657,   68,  659,   68,  661,   68,   68,   68,
       68,   68,  166,  676,   68,  678,   68,  664,   68,  166,
       68,  166,   68,  166,  249,  248,   68,   68,   68,   68,
       68,  166,  666,   68,  667,  669,  677,  251,  683,   68,
       68,   68,   68,   68,   68,  250,   68,   68,   68,   68,

      166,  166,  166,  687,  681,  166,   68,   68,   68,   68,
       68,  253,   68,  252,  686,   68,   68,  255,   68,  680,
      166,  685,   68,  688,   68,  256,   68,  166,   68,  254,
       68,   68,   68,   68,   68,  166,  257,   68,  697,  166,
      166,  166,  166,   68,   68,   68,   68,   68,   68,   68,
      706,  166,   68,   68,  692,   68,  694,  691,  259,   68,
      258,   68,  699,   68,  696,   68,   68,   68,   68,   68,
      700,  690,   68,  689,   68,  262,  260,  708,   68,  261,
       68,  166,   68,   68,   68,   68,   68,  673,  672,  710,
      671,   68,  670,   68,   68,   68,  714,   68,  707,  652,

      263,  651,   68,  650,   68,  264,   68,   68,   68,  649,
       68,  648,  126,   68,  166,  627,  626,   68,   68,  268,
      269,   68,   68,  270,   68,  625,   68,  624,  271,   68,
       68,   68,   68,  623,  622,  166,  166,   68,  166,  596,
      595,   68,  594,   68,   68,   68,  274,  273,  593,  272,
       68,  592,   68,  591,   68,   68,   68,  559,   68,  558,
      557,  556,   68,   68,   68,   68,   68,   68,  275,   68,
       68,   68,  555,   68,   68,  277,   68,  554,  166,  536,
       68,  513,   68,   68,   68,   68,   68,   68,   68,   68,
       68,   68,  276,  512,   68,   68,  511,  280,  510,  509,

      508,  278,  507,   68,   68,   68,   68,  126,   68,   68,
       68,  126,  281,   68,  486,   68,  457,  456,  455,   68,
      454,   68,  282,   68,  453,   68,   68,   68,   68,   68,
      452,  451,   68,  126,   68,  126,   68,  444,   68,  424,
       68,  392,   68,   68,   68,   68,   68,  391,  390,  284,
      389,   68,  388,   68,   68,   68,  387,   68,  386,  126,
      285,  376,   68,  369,   68,   68,   68,  353,   68,  345,
      320,   68,  319,   68,  286,  288,  318,   68,  317,   68,
      316,   68,   68,   68,   68,   68,  315,  314,   68,  293,
      289,  290,   68,  267,   68,  166,   68,  155,   68,   68,

       68,   68,   68,  152,  152,   68,  291,   68,  150,   68,
      150,   68,  242,   68,  241,   68,   68,   68,   68,   68,
      240,  239,   68,  292,   68,  295,   68,  238,   68,  237,
       68,  236,   68,  294,   68,   68,   68,   68,  235,  234,
      296,   68,  126,  126,  215,   68,  166,   68,  159,   68,
      158,   68,  157,  156,  302,   68,   68,   68,  298,   68,
      299,   68,   68,  152,   68,  300,  150,  145,  136,  126,
       65,   68,   68,   68,   68,   68,   68,   68,   68,  301,
       68,   68,   63,   62,  307,  721,  721,   68,   68,   68,
       68,   68,   68,   68,   68,  721,  304,   68,  721,  721,

      721,  721,  721,   68,   68,  321,   68,   68,   68,   68,
      322,  721,   68,   68,  721,   68,  323,  721,  721,   68,
      721,   68,  721,   68,  721,   68,  324,   68,   68,   68,
       68,   68,  721,  721,   68,  721,  721,  721,  721,  721,
       68,   68,  325,   68,   68,   68,  328,   68,   68,   68,
       68,  327,  721,  721,  721,  721,  721,   68,   68,   68,
       68,   68,   68,   68,  329,  721,   68,   68,  721,   68,
      721,  721,  721,   68,  721,   68,  721,   68,  326,   68,
       68,   68,   68,   68,  721,  721,  330,  721,   68,  721,
       68,   68,   68,  331,   68,  721,  721,  721,  721,   68,

      721,   68,   68,   68,  721,   68,  721,  721,   68,  332,
       68,  721,   68,  721,   68,  721,   68,  721,   68,  721,
      334,  333,   68,   68,  721,  335,   68,   68,  721,  336,
      721,  721,  721,   68,   68,   68,   68,   68,   68,  721,
       68,  721,   68,  721,   68,   68,   68,   68,  337,  721,
      721,  721,  721,   68,  338,   68,  721,   68,  721,   68,
      721,   68,  721,   68,  721,   68,   68,   68,  721,   68,
      721,  339,  721,   68,   68,  340,  721,   68,   68,  341,
      721,  342,   68,  721,   68,  721,  721,  721,   68,  721,
       68,  721,   68,  721,   68,   68,   68,   68,   68,  721,

      721,  721,  721,   68,  721,   68,  721,   68,   68,   68,
      721,  721,  721,  346,   68,  347,   68,  721,   68,   68,
       68,  721,   68,  721,  721,  721,   68,   68,   68,   68,
       68,   68,  348,   68,   68,   68,  350,   68,  349,  351,
      721,  721,  721,  721,   68,   68,   68,   68,   68,   68,
      352,   68,  721,   68,  721,   68,   68,   68,  354,   68,
       68,  721,  721,  721,   68,  721,   68,  721,  721,  721,
       68,  721,   68,  721,   68,  721,   68,  355,   68,   68,
       68,   68,   68,  358,  356,   68,  721,  721,  721,  721,
      721,   68,   68,   68,   68,   68,   68,   68,  362,  721,

       68,   68,  721,  721,  721,  721,  721,   68,   68,   68,
      721,   68,  721,  721,   68,  359,   68,  721,   68,  721,
       68,  360,   68,  721,   68,  721,   68,   68,   68,   68,
      721,  721,  363,   68,  364,   68,  721,  721,  721,   68,
      721,   68,  721,   68,  721,   68,   68,   68,   68,   68,
      721,  721,   68,  721,   68,  366,   68,  721,   68,  721,
       68,  721,   68,   68,   68,   68,   68,  721,  721,   68,
      721,   68,  721,   68,  721,   68,  721,   68,  721,   68,
      721,  367,   68,   68,  368,   68,   68,  721,   68,  721,
      721,  370,  721,  721,  721,   68,   68,   68,   68,   68,

       68,   68,  721,  721,   68,   68,  721,   68,  721,  721,
      721,   68,  721,   68,  721,   68,  721,   68,   68,   68,
       68,   68,  721,  721,   68,  721,   68,  721,   68,  721,
      372,  721,   68,  721,   68,  721,   68,   68,   68,   68,
       68,  721,  374,  373,  721,  721,  721,  721,  721,   68,
       68,   68,   68,   68,   68,  721,  721,  721,   68,   68,
       68,   68,  721,  378,  721,  721,  721,  721,  721,  721,
       68,   68,   68,   68,   68,   68,  375,   68,  721,   68,
       68,  721,  721,  721,  721,  721,  721,   68,  721,   68,
      721,   68,  394,   68,  721,  393,   68,  721,  721,   68,

      395,  721,  721,   68,  721,   68,  721,   68,  721,   68,
      721,   68,   68,   68,  396,   68,   68,  721,   68,  721,
      721,  721,  721,  721,  721,   68,   68,   68,   68,   68,
       68,  398,   68,  721,   68,   68,  721,  721,   68,  399,
      721,  721,   68,  721,   68,  721,   68,  721,   68,  721,
       68,   68,   68,   68,   68,  721,  400,   68,  721,  721,
      721,  721,  721,   68,   68,   68,   68,   68,   68,   68,
       68,  721,   68,   68,  721,  721,  721,  721,  721,   68,
       68,  401,   68,   68,   68,   68,  402,  721,   68,   68,
      721,   68,  721,  721,  404,  403,  721,   68,  405,   68,

      721,   68,  721,   68,   68,   68,   68,   68,  406,  721,
       68,  721,  721,  721,  721,  721,   68,   68,   68,   68,
       68,   68,   68,  407,  721,   68,   68,  721,  721,  721,
      721,  721,   68,  721,   68,  721,   68,   68,  409,  721,
      408,   68,  721,   68,  721,  721,  721,   68,  721,   68,
      721,   68,  721,   68,   68,   68,   68,   68,  721,  721,
       68,  410,   68,  721,   68,  721,   68,  721,   68,  721,
       68,  411,  412,   68,   68,   68,   68,  721,  721,   68,
      721,  721,  721,  416,  721,   68,   68,   68,   68,   68,
       68,  721,  721,   68,   68,   68,   68,  417,  721,  418,

      721,  721,  721,   68,  721,   68,   68,   68,   68,  721,
       68,  419,   68,   68,   68,   68,  420,  721,  721,  721,
      721,  721,  721,   68,   68,  421,   68,   68,   68,  721,
       68,   68,   68,   68,  422,  721,  425,  721,  721,  721,
       68,   68,   68,   68,   68,   68,   68,  423,  721,   68,
       68,  721,   68,  721,  721,  721,   68,  721,   68,  721,
       68,  721,   68,   68,   68,   68,   68,  721,  721,   68,
      426,   68,  721,   68,  721,   68,  721,   68,  721,   68,
       68,   68,   68,   68,  721,  721,   68,  428,   68,  721,
       68,  721,   68,  721,   68,  721,   68,   68,  429,   68,

       68,  721,  721,   68,  431,   68,  721,   68,  721,   68,
      721,   68,  721,   68,   68,  432,   68,   68,  721,  721,
      721,  721,   68,  721,   68,   68,   68,  721,   68,  721,
      721,   68,  433,   68,  721,   68,  436,  435,  721,   68,
      721,   68,   68,   68,   68,   68,  721,  721,   68,  721,
       68,  721,   68,  721,   68,  439,   68,  721,   68,   68,
       68,   68,   68,  721,  437,   68,  721,   68,  441,   68,
      721,   68,  721,   68,  721,   68,   68,   68,   68,   68,
      721,  721,  721,  721,   68,  721,   68,   68,   68,  721,
       68,  721,  442,   68,  721,   68,  721,   68,  721,   68,

      721,   68,  721,   68,  721,   68,   68,   68,   68,  458,
      459,   68,   68,  721,   68,  721,  721,  721,   68,  721,
       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
       68,  721,  460,   68,  721,   68,  721,  721,  721,   68,
      721,  462,  721,   68,  721,   68,   68,   68,   68,   68,
      721,  721,   68,  463,   68,  464,   68,  721,   68,  721,
       68,  721,   68,  721,   68,   68,   68,  465,   68,  721,
      721,   68,  721,  721,   68,  721,  721,  721,   68,  721,
       68,  721,   68,  721,   68,  721,   68,   68,   68,   68,
      721,  467,  466,   68,  721,   68,  721,  721,  721,   68,

      721,   68,  721,   68,  721,   68,  721,   68,   68,   68,
      470,   68,   68,  468,   68,  469,  721,  721,  721,  721,
      721,   68,   68,   68,   68,   68,   68,   68,   68,  721,
       68,   68,  721,  721,  721,  471,  721,   68,   68,   68,
       68,   68,   68,   68,   68,  721,   68,   68,  721,  721,
      721,  473,  721,   68,   68,   68,   68,   68,   68,  721,
      472,  721,   68,   68,  474,   68,   68,  721,  721,  721,
      478,  721,  721,  721,  721,   68,   68,   68,   68,   68,
       68,   68,  721,  721,   68,   68,  721,   68,  479,  480,
      721,   68,  721,   68,  721,   68,  721,   68,   68,   68,

       68,   68,  721,  721,   68,  721,   68,  482,   68,  721,
       68,  721,   68,  721,   68,  481,   68,   68,   68,   68,
      483,  721,  721,   68,  721,   68,  721,  721,  721,   68,
      721,   68,  721,   68,  721,   68,  721,   68,   68,   68,
       68,  484,  721,  485,   68,  721,   68,  721,  721,  721,
       68,  721,   68,  487,   68,  721,   68,   68,   68,   68,
       68,  721,  721,   68,  721,   68,  721,   68,  721,   68,
      488,   68,  721,   68,  721,   68,   68,   68,  490,   68,
       68,  721,   68,  721,  721,  721,  721,  721,  721,   68,
       68,   68,  492,   68,   68,   68,  721,  721,   68,   68,

      721,  721,  721,  721,  721,   68,  721,   68,   68,   68,
      721,  494,  721,  493,   68,  721,   68,  496,   68,   68,
       68,  721,   68,  721,  721,  721,   68,   68,   68,   68,
       68,   68,   68,   68,  721,   68,  721,  721,   68,  721,
       68,  721,   68,   68,   68,  498,   68,  721,  721,  721,
       68,   68,   68,   68,   68,   68,   68,   68,  721,   68,
      721,  721,   68,  721,   68,  721,   68,   68,   68,  721,
       68,  721,  721,  500,   68,   68,   68,   68,   68,   68,
       68,   68,  514,   68,  721,  515,   68,  516,   68,  721,
       68,  721,   68,  721,   68,  721,  721,  721,   68,   68,

       68,   68,   68,  721,  518,  721,  721,   68,  721,   68,
      721,   68,  721,   68,  721,   68,  721,   68,  721,   68,
       68,  519,  721,   68,  520,   68,  721,   68,   68,   68,
      721,   68,  721,   68,  721,   68,   68,   68,  721,   68,
      721,   68,  721,   68,   68,   68,  721,   68,  521,  721,
      721,   68,   68,   68,   68,   68,  522,   68,  721,  721,
       68,  721,  721,  721,   68,  721,   68,   68,   68,   68,
       68,   68,  721,   68,  721,  523,   68,  721,  721,  721,
       68,   68,   68,  721,   68,  721,  721,  525,  524,   68,
      721,   68,  721,   68,  721,   68,  721,   68,   68,   68,

       68,   68,  721,  721,   68,  721,   68,  721,  526,  721,
       68,  531,   68,  721,   68,   68,   68,   68,   68,  721,
      721,  721,  721,   68,  721,   68,   68,   68,  721,   68,
      721,  721,   68,  532,   68,  721,   68,  721,   68,  721,
       68,  721,   68,   68,   68,   68,   68,  721,  721,   68,
      721,   68,  534,   68,  721,   68,  721,   68,  721,   68,
      533,   68,   68,   68,   68,   68,  535,  721,   68,  721,
      721,  721,  721,  721,   68,   68,   68,   68,   68,   68,
       68,   68,  721,   68,   68,  721,  721,  721,  721,  721,
       68,   68,  537,  538,   68,   68,   68,   68,  721,   68,

       68,  542,  721,  721,  721,  721,  540,   68,   68,   68,
       68,   68,   68,   68,  721,   68,   68,  721,  721,  721,
      721,  721,   68,   68,   68,   68,   68,   68,  721,  721,
       68,   68,   68,  544,  721,  721,   68,  560,  721,  546,
       68,  721,   68,  721,   68,  721,   68,  721,   68,   68,
       68,  548,   68,   68,  721,   68,  721,  721,  721,  721,
      721,  721,   68,   68,   68,   68,   68,   68,   68,   68,
      562,   68,   68,  721,  721,  561,  721,  721,   68,   68,
       68,   68,   68,   68,   68,  721,  721,   68,   68,  721,
      721,  721,   68,  721,   68,   68,   68,  721,   68,  721,

      564,  721,   68,   68,   68,   68,   68,  566,   68,   68,
      565,   68,  721,  721,   68,  721,   68,  721,   68,  721,
       68,  567,   68,  721,  721,  721,   68,   68,   68,   68,
       68,  721,  568,  721,  721,   68,  721,   68,  721,   68,
      721,   68,  721,   68,  721,   68,  721,   68,   68,   68,
      721,   68,  569,   68,  721,   68,   68,   68,  721,   68,
      721,  721,  721,   68,   68,   68,   68,   68,  721,  574,
      721,  721,   68,  721,   68,  721,   68,   68,   68,  721,
       68,  721,  721,  721,   68,   68,   68,   68,   68,   68,
       68,   68,  721,   68,  721,  721,   68,  721,   68,  721,

       68,   68,   68,  721,   68,  577,  721,  721,   68,   68,
       68,   68,   68,   68,   68,   68,  575,   68,  721,  721,
       68,  721,   68,  721,   68,  721,   68,  721,   68,  721,
       68,  721,   68,   68,   68,  721,   68,  580,   68,  721,
       68,   68,   68,  721,   68,  721,   68,  721,   68,   68,
       68,  721,   68,  721,   68,  721,   68,   68,  583,  721,
       68,  721,   68,  721,  585,   68,   68,  721,   68,  721,
       68,  721,   68,   68,   68,  721,   68,  721,   68,  597,
       68,   68,   68,  598,   68,  721,   68,  721,   68,   68,
       68,  721,   68,  721,   68,  721,   68,   68,   68,  721,

       68,  721,  721,  721,   68,   68,   68,   68,   68,  721,
      600,  599,  721,   68,  721,   68,  721,   68,   68,   68,
      602,   68,  721,  721,  721,   68,   68,  601,   68,   68,
       68,   68,   68,  721,   68,  721,  721,   68,  721,   68,
      721,  603,  721,   68,  721,   68,  721,   68,  721,   68,
       68,   68,  721,   68,  608,  607,  721,   68,   68,   68,
       68,   68,  721,   68,  721,  721,   68,  610,  721,  721,
       68,   68,   68,   68,   68,  613,  721,   68,  721,   68,
      721,   68,   68,   68,   68,   68,  721,   68,  721,  615,
       68,  721,  721,  721,   68,   68,   68,   68,   68,   68,

      721,   68,  721,   68,  721,   68,   68,  629,   68,   68,
      628,   68,  721,  630,   68,  721,  721,  721,   68,   68,
       68,   68,   68,   68,  721,   68,  721,   68,  721,   68,
       68,   68,   68,   68,  721,  721,  631,  721,   68,  721,
       68,  721,   68,   68,   68,  721,   68,  632,  721,  721,
       68,   68,   68,   68,   68,   68,   68,   68,  721,   68,
      721,  721,   68,  721,   68,  721,   68,  721,   68,  636,
       68,  721,   68,  721,   68,   68,  638,  721,   68,  641,
       68,  721,   68,   68,   68,  721,   68,  643,   68,  721,
       68,   68,   68,  721,   68,  721,   68,  721,   68,   68,

      653,  721,   68,  721,   68,  721,   68,   68,   68,  721,
       68,  721,   68,  721,   68,   68,   68,  721,   68,  721,
       68,  721,   68,   68,   68,  721,   68,  721,  721,  721,
       68,   68,   68,   68,   68,  721,  721,  721,  654,   68,
      721,   68,  721,   68,   68,  658,  721,   68,  660,  721,
      721,   68,   68,   68,   68,   68,   68,   68,   68,  721,
       68,  665,  663,   68,  721,   68,  721,   68,   68,   68,
      721,   68,  721,  721,  721,   68,   68,   68,   68,   68,
       68,  721,   68,  674,   68,   68,  721,   68,   68,  721,
      721,  675,  721,  721,  721,   68,  721,   68,   68,   68,

       68,   68,   68,  721,   68,  721,  679,   68,  721,   68,
      721,   68,  721,   68,  721,   68,  684,  721,  721,   68,
       68,   68,  721,   68,  682,  693,   68,   68,   68,  721,
      721,  721,  721,  721,  721,  721,   68,   68,   68,   68,
       68,   68,   68,   68,  721,   68,   68,  721,  721,  721,
      721,  721,   68,   68,   68,   68,   68,   68,  721,   68,
       68,   68,   68,  698,  721,  695,  721,  721,  721,   68,
       68,   68,   68,   68,   68,   68,   68,  721,   68,   68,
      721,  705,  721,  721,  721,   68,   68,   68,   68,   68,
       68,   68,  709,  721,   68,   68,  721,   68,  721,  721,

      721,   68,  721,   68,  721,   68,  721,   68,  721,   68,
       68,   68,  721,  721,  721,  721,   68,   45,   45,   45,
       45,   45,   61,  721,   61,  127,  127,  127,  134,  134,
      721,  134,  134,  151,  151,  151,  153,  153,  153,   74,
       74,   74,    5,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,

      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721
    } ;

static yyconst short int yy_chk[3828] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    3,    3,    7,    7,    8,    8,
       13,   13,   39,   44,    3,    3,   40,   13,    4,    4,

       43,   41,   49,   13,   13,   49,   42,  109,    4,    4,
       17,   17,   17,   17,   17,   17,   17,   20,   50,   60,
       20,  105,   46,   51,   20,   60,   50,   20,   20,   20,
       20,   20,   46,  718,   51,  717,   20,   44,   52,   52,
       20,   26,    3,   40,    3,  128,   54,   55,   39,   54,
        3,   26,    3,   26,    3,   26,    4,    3,    4,  109,
       26,   90,   55,    3,    4,   41,    4,   43,    4,   42,
      716,    4,   56,   56,  105,  308,   89,    4,   12,   12,
       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,

       12,   12,   12,   12,  128,   90,  715,   12,   12,   12,
       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
       12,   12,   19,   89,   19,   19,   19,   19,   19,   19,
       19,  223,  308,  714,  131,  712,  100,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,  122,  119,  130,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,

       19,   21,  100,   59,   59,  131,  223,   21,  132,   22,
       59,   21,   22,   21,   21,   21,   59,   59,  124,   22,
       21,   22,   23,   22,  186,  122,  711,  133,   22,  119,
      129,  130,   23,   23,   23,  135,   23,   24,   24,   25,
      185,   23,  233,  208,   23,  135,  226,  199,   24,   25,
       24,   25,   24,   25,   24,   28,   28,   24,   25,  229,
      203,   27,   27,   28,   27,  124,   28,  132,   28,  231,
       28,   25,   27,   27,   27,   28,   27,   29,  129,   27,
      124,   27,  133,  186,   25,  228,  230,   29,  185,   29,
       29,   29,  219,   30,   30,  199,   29,   30,  226,   31,

      208,   31,  225,   30,  232,   30,  233,   30,  203,   31,
      343,   31,   30,   31,   32,   31,  229,   32,   31,  266,
       33,  231,   30,   33,   32,   29,   32,   33,   32,  283,
       33,  230,   33,   32,   33,  710,  306,   34,   33,   33,
      219,  265,  287,   33,   31,   34,   34,  311,  228,   35,
      225,  305,  232,  303,  343,  279,   34,  708,   34,   35,
       34,   35,   34,   35,  297,   34,  309,   35,   35,   34,
      266,   36,   36,   37,  344,  283,  310,  375,   34,  357,
       37,  306,   36,   37,   36,   37,   36,   37,  365,  706,
       35,   36,   37,   64,   64,   64,   64,   64,   64,   64,

       66,  303,  265,   68,  311,  287,  326,  345,   36,  305,
       66,   69,   66,   68,   66,   68,  279,   68,  313,   66,
       67,   69,   68,   69,  310,   69,  344,  297,   69,  309,
       69,  357,  365,  375,  371,   67,   67,   67,   67,   67,
       67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
       67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
       67,   70,   71,  361,  379,  380,  313,  326,  345,  413,
      369,   70,   71,   70,   71,   70,   71,   72,  377,  384,
       70,   71,  371,   73,  383,   71,  440,   72,  704,   72,
      703,   72,  434,   73,   75,   73,   72,   73,  430,   75,

       76,   73,   73,  382,   75,  414,   75,  397,   75,  444,
       76,   77,   76,   75,   76,  415,  430,  443,   76,   76,
      380,   77,   78,   77,  413,   77,  361,  379,   79,  384,
       77,  369,   78,  427,   78,   78,   78,  434,   79,  377,
       79,   78,   79,   80,   80,  383,  446,   79,  448,   81,
       81,  414,  440,  438,   80,  382,   80,   80,   80,  397,
       81,   82,   81,   80,   81,  443,  461,  415,  445,   81,
      444,   82,   82,   82,   83,   82,  701,   84,   83,  427,
       82,  477,  502,  447,   83,  475,   83,   84,   83,   84,
       85,   84,   85,   83,  446,  700,   84,  448,   86,   86,

       85,   87,   85,  476,   85,  438,  495,  497,   86,   85,
       86,   87,   86,   87,   88,   87,   86,   86,  475,   91,
       87,  517,  491,  461,   88,  489,   88,   88,   88,   91,
      445,  447,   92,   88,  502,   92,  476,  475,  477,   91,
       93,   91,   92,   91,   92,  503,   92,  504,   91,  541,
       93,   92,   93,  499,   93,   94,   94,  505,  489,   93,
      550,  495,  506,  527,  497,   94,   95,   94,  529,   94,
      491,  517,   94,   94,   94,  576,   95,  528,   95,   95,
       95,   96,   96,  530,  539,   95,  499,   97,  547,  503,
      505,   96,  536,   96,  543,   96,  551,   97,   98,   97,

       96,   97,  692,   96,  545,  570,   97,  553,   98,   99,
       98,  541,   98,  504,  506,  550,   98,   98,  549,   99,
      552,   99,  101,   99,  605,  102,  527,  576,   99,  551,
      101,  529,  101,  530,  101,  102,  101,  102,  103,  102,
      571,  101,  543,  102,  102,  528,  104,  539,  103,  106,
      103,  547,  103,  536,  545,  553,  104,  103,  104,  106,
      104,  106,  107,  106,  104,  104,  570,  634,  106,  106,
      108,  605,  107,  108,  107,  549,  107,  108,  579,  581,
      108,  107,  108,  552,  108,  110,  110,  572,  571,  108,
      604,  578,  111,  609,  586,  691,  110,  584,  110,  589,

      110,  634,  111,  112,  111,  110,  111,  111,  587,  113,
      111,  111,  581,  112,  590,  112,  690,  112,  689,  113,
      114,  113,  112,  113,  579,  113,  116,  112,  113,  688,
      114,  116,  114,  606,  114,  588,  116,  117,  116,  114,
      116,  587,  604,  118,  586,  116,  612,  117,  572,  117,
      609,  117,  578,  118,  120,  118,  117,  118,  584,  611,
      589,  120,  118,  614,  120,  616,  120,  123,  120,  618,
      121,  121,  620,  120,  121,  590,  619,  123,  125,  123,
      121,  123,  121,  640,  121,  606,  123,  646,  125,  121,
      125,  161,  125,  633,  161,  635,  125,  125,  588,  639,

      685,  161,  162,  161,  637,  161,  642,  612,  163,  161,
      161,  611,  162,  655,  162,  657,  162,  616,  163,  164,
      163,  162,  163,  645,  620,  644,  614,  163,  647,  164,
      165,  164,  618,  164,  656,  640,  664,  619,  164,  646,
      165,  167,  165,  165,  165,  662,  668,  168,  167,  165,
      633,  167,  635,  167,  637,  167,  639,  168,  169,  168,
      167,  168,  667,  655,  170,  657,  168,  642,  169,  661,
      169,  666,  169,  669,  170,  169,  170,  169,  170,  171,
      172,  683,  644,  170,  645,  647,  656,  172,  664,  171,
      172,  171,  172,  171,  172,  171,  173,  174,  171,  172,

      677,  681,  694,  668,  662,  686,  173,  174,  173,  174,
      173,  174,  175,  173,  667,  173,  174,  176,  176,  661,
      687,  666,  175,  669,  175,  176,  175,  697,  176,  175,
      176,  175,  176,  177,  178,  707,  177,  176,  683,  699,
      696,  680,  678,  177,  178,  177,  178,  177,  178,  179,
      694,  676,  177,  178,  673,  180,  677,  672,  180,  179,
      179,  179,  686,  179,  681,  180,  181,  180,  179,  180,
      687,  671,  182,  670,  180,  182,  181,  697,  181,  181,
      181,  659,  182,  183,  182,  181,  182,  652,  651,  699,
      650,  182,  648,  183,  184,  183,  707,  183,  696,  627,

      183,  626,  183,  624,  184,  184,  184,  188,  184,  623,
      189,  622,  621,  184,  617,  596,  595,  188,  190,  188,
      189,  188,  189,  189,  189,  594,  188,  593,  190,  189,
      190,  191,  190,  592,  591,  582,  573,  190,  563,  559,
      558,  191,  557,  191,  192,  191,  193,  192,  556,  191,
      191,  555,  194,  554,  192,  193,  192,  513,  192,  512,
      510,  509,  194,  192,  194,  193,  194,  193,  194,  193,
      195,  194,  508,  196,  193,  197,  197,  507,  501,  486,
      195,  457,  195,  196,  195,  196,  197,  196,  197,  195,
      197,  198,  196,  456,  200,  197,  455,  200,  454,  453,

      452,  198,  451,  198,  200,  198,  200,  450,  200,  201,
      198,  449,  201,  200,  424,  202,  392,  391,  390,  201,
      389,  201,  202,  201,  388,  202,  204,  202,  201,  202,
      387,  386,  205,  385,  202,  381,  204,  376,  204,  353,
      204,  320,  205,  206,  205,  204,  205,  319,  318,  205,
      317,  205,  316,  206,  207,  206,  315,  206,  314,  312,
      206,  302,  206,  293,  207,  209,  207,  274,  207,  267,
      242,  210,  240,  207,  207,  209,  239,  209,  238,  209,
      237,  210,  211,  210,  209,  210,  236,  235,  212,  215,
      210,  212,  211,  187,  211,  166,  211,  156,  212,  213,

      212,  211,  212,  153,  152,  214,  213,  212,  151,  213,
      150,  213,  148,  213,  147,  214,  216,  214,  213,  214,
      146,  145,  217,  214,  214,  217,  216,  143,  216,  141,
      216,  140,  217,  216,  217,  216,  217,  218,  138,  137,
      218,  217,  127,  126,  115,  220,   74,  218,   65,  218,
       63,  218,   62,   61,  222,  220,  218,  220,  220,  220,
      220,  221,  222,   58,  220,  220,   57,   53,   48,   38,
       18,  221,  222,  221,  222,  221,  222,  224,  227,  221,
      221,  222,   15,   14,  227,    5,    0,  224,  227,  224,
      227,  224,  227,  243,  244,    0,  224,  227,    0,    0,

        0,    0,    0,  243,  244,  243,  244,  243,  244,  245,
      244,    0,  243,  244,    0,  246,  245,    0,    0,  245,
        0,  245,    0,  245,    0,  246,  246,  246,  245,  246,
      247,  248,    0,    0,  246,    0,    0,    0,    0,    0,
      247,  248,  247,  248,  247,  248,  250,  250,  249,  247,
      248,  249,    0,    0,    0,    0,    0,  250,  249,  250,
      249,  250,  249,  251,  251,    0,  250,  249,    0,  252,
        0,    0,    0,  251,    0,  251,    0,  251,  248,  252,
      253,  252,  251,  252,    0,    0,  252,    0,  252,    0,
      253,  254,  253,  253,  253,    0,    0,    0,    0,  253,

        0,  254,  255,  254,    0,  254,    0,    0,  256,  254,
      254,    0,  255,    0,  255,    0,  255,    0,  256,    0,
      256,  255,  256,  257,    0,  257,  258,  256,    0,  258,
        0,    0,    0,  257,  259,  257,  258,  257,  258,    0,
      258,    0,  257,    0,  259,  258,  259,  260,  259,    0,
        0,    0,    0,  259,  260,  261,    0,  260,    0,  260,
        0,  260,    0,  262,    0,  261,  260,  261,    0,  261,
        0,  261,    0,  262,  261,  262,    0,  262,  263,  262,
        0,  263,  262,    0,  264,    0,    0,    0,  263,    0,
      263,    0,  263,    0,  264,  268,  264,  263,  264,    0,

        0,    0,    0,  264,    0,  268,    0,  268,  269,  268,
        0,    0,    0,  268,  268,  269,  270,    0,  269,  271,
      269,    0,  269,    0,    0,    0,  270,  269,  270,  271,
      270,  271,  270,  271,  273,  270,  272,  272,  271,  273,
        0,    0,    0,    0,  273,  275,  273,  272,  273,  272,
      273,  272,    0,  273,    0,  275,  272,  275,  275,  275,
      276,    0,    0,    0,  275,    0,  277,    0,    0,    0,
      276,    0,  276,    0,  276,    0,  277,  276,  277,  276,
      277,  278,  280,  280,  277,  277,    0,    0,    0,    0,
        0,  278,  280,  278,  280,  278,  280,  281,  284,    0,

      278,  280,    0,    0,    0,    0,    0,  281,  282,  281,
        0,  281,    0,    0,  284,  281,  281,    0,  282,    0,
      282,  282,  282,    0,  284,    0,  284,  282,  284,  285,
        0,    0,  285,  284,  286,  286,    0,    0,    0,  285,
        0,  285,    0,  285,    0,  286,  288,  286,  285,  286,
        0,    0,  289,    0,  286,  289,  288,    0,  288,    0,
      288,    0,  289,  290,  289,  288,  289,    0,    0,  291,
        0,  289,    0,  290,    0,  290,    0,  290,    0,  291,
        0,  291,  290,  291,  292,  292,  294,    0,  291,    0,
        0,  296,    0,    0,    0,  292,  294,  292,  294,  292,

      294,  295,    0,    0,  292,  294,    0,  296,    0,    0,
        0,  295,    0,  295,    0,  295,    0,  296,  298,  296,
      295,  296,    0,    0,  299,    0,  296,    0,  298,    0,
      298,    0,  298,    0,  299,    0,  299,  298,  299,  300,
      301,    0,  300,  299,    0,    0,    0,    0,    0,  300,
      301,  300,  301,  300,  301,    0,    0,    0,  300,  301,
      304,  307,    0,  304,    0,    0,    0,    0,    0,    0,
      304,  307,  304,  307,  304,  307,  301,  321,    0,  304,
      307,    0,    0,    0,    0,    0,    0,  321,    0,  321,
        0,  321,  322,  322,    0,  321,  321,    0,    0,  323,

      323,    0,    0,  322,    0,  322,    0,  322,    0,  323,
        0,  323,  322,  323,  324,  324,  325,    0,  323,    0,
        0,    0,    0,    0,    0,  324,  325,  324,  325,  324,
      325,  327,  327,    0,  324,  325,    0,    0,  328,  328,
        0,    0,  327,    0,  327,    0,  327,    0,  328,    0,
      328,  327,  328,  329,  330,    0,  329,  328,    0,    0,
        0,    0,    0,  329,  330,  329,  330,  329,  330,  331,
      332,    0,  329,  330,    0,    0,    0,    0,    0,  331,
      332,  331,  332,  331,  332,  333,  332,    0,  331,  332,
        0,  334,    0,    0,  334,  333,    0,  333,  334,  333,

        0,  334,    0,  334,  333,  334,  335,  336,  335,    0,
      334,    0,    0,    0,    0,    0,  335,  336,  335,  336,
      335,  336,  337,  336,    0,  335,  336,    0,    0,    0,
        0,    0,  337,    0,  337,    0,  337,  338,  338,    0,
      337,  337,    0,  339,    0,    0,    0,  338,    0,  338,
        0,  338,    0,  339,  340,  339,  338,  339,    0,    0,
      341,  339,  339,    0,  340,    0,  340,    0,  340,    0,
      341,  340,  341,  340,  341,  342,  346,    0,    0,  341,
        0,    0,    0,  346,    0,  342,  346,  342,  346,  342,
      346,    0,    0,  348,  342,  346,  347,  347,    0,  347,

        0,    0,    0,  348,    0,  348,  347,  348,  347,    0,
      347,  348,  348,  350,  349,  347,  349,    0,    0,    0,
        0,    0,    0,  350,  349,  350,  349,  350,  349,    0,
      352,  351,  350,  349,  351,    0,  355,    0,    0,    0,
      352,  351,  352,  351,  352,  351,  354,  352,    0,  352,
      351,    0,  355,    0,    0,    0,  354,    0,  354,    0,
      354,    0,  355,  356,  355,  354,  355,    0,    0,  358,
      356,  355,    0,  356,    0,  356,    0,  356,    0,  358,
      359,  358,  356,  358,    0,    0,  360,  358,  358,    0,
      359,    0,  359,    0,  359,    0,  360,  362,  360,  359,

      360,    0,    0,  363,  362,  360,    0,  362,    0,  362,
        0,  362,    0,  363,  364,  363,  362,  363,    0,    0,
        0,    0,  363,    0,  364,  366,  364,    0,  364,    0,
        0,  367,  364,  364,    0,  366,  367,  366,    0,  366,
        0,  367,  368,  367,  366,  367,    0,    0,  370,    0,
      367,    0,  368,    0,  368,  370,  368,    0,  370,  372,
      370,  368,  370,    0,  368,  373,    0,  370,  373,  372,
        0,  372,    0,  372,    0,  373,  374,  373,  372,  373,
        0,    0,    0,    0,  373,    0,  374,  378,  374,    0,
      374,    0,  374,  393,    0,  374,    0,  378,    0,  378,

        0,  378,    0,  393,    0,  393,  378,  393,  394,  394,
      395,  395,  393,    0,  396,    0,    0,    0,  394,    0,
      394,  395,  394,  395,  396,  395,  396,  394,  396,  398,
      395,    0,  396,  396,    0,  399,    0,    0,    0,  398,
        0,  398,    0,  398,    0,  399,  400,  399,  398,  399,
        0,    0,  401,  399,  399,  401,  400,    0,  400,    0,
      400,    0,  401,    0,  401,  400,  401,  402,  402,    0,
        0,  401,    0,    0,  403,    0,    0,    0,  402,    0,
      402,    0,  402,    0,  403,    0,  403,  402,  403,  404,
        0,  404,  403,  403,    0,  405,    0,    0,    0,  404,

        0,  404,    0,  404,    0,  405,    0,  405,  404,  405,
      407,  407,  406,  405,  405,  406,    0,    0,    0,    0,
        0,  407,  406,  407,  406,  407,  406,  408,  409,    0,
      407,  406,    0,    0,    0,  409,    0,  408,  409,  408,
      409,  408,  409,  410,  411,    0,  408,  409,    0,    0,
        0,  411,    0,  410,  411,  410,  411,  410,  411,    0,
      410,    0,  410,  411,  412,  412,  416,    0,    0,    0,
      416,    0,    0,    0,    0,  412,  416,  412,  416,  412,
      416,  417,    0,    0,  412,  416,    0,  418,  417,  418,
        0,  417,    0,  417,    0,  417,    0,  418,  419,  418,

      417,  418,    0,    0,  420,    0,  418,  420,  419,    0,
      419,    0,  419,    0,  420,  419,  420,  419,  420,  421,
      421,    0,    0,  420,    0,  422,    0,    0,    0,  421,
        0,  421,    0,  421,    0,  422,    0,  422,  421,  422,
      423,  422,    0,  423,  422,    0,  425,    0,    0,    0,
      423,    0,  423,  425,  423,    0,  425,  426,  425,  423,
      425,    0,    0,  428,    0,  425,    0,  426,    0,  426,
      426,  426,    0,  428,    0,  428,  426,  428,  429,  429,
      431,    0,  428,    0,    0,    0,    0,    0,    0,  429,
      431,  429,  431,  429,  431,  432,    0,    0,  429,  431,

        0,    0,    0,    0,    0,  432,    0,  432,  433,  432,
        0,  433,    0,  432,  432,    0,  435,  435,  433,  436,
      433,    0,  433,    0,    0,    0,  435,  433,  435,  436,
      435,  436,  437,  436,    0,  435,    0,    0,  436,    0,
      441,    0,  437,  439,  437,  439,  437,    0,    0,    0,
      441,  437,  441,  439,  441,  439,  442,  439,    0,  441,
        0,    0,  439,    0,  458,    0,  442,  459,  442,    0,
      442,    0,    0,  442,  458,  442,  458,  459,  458,  459,
      460,  459,  458,  458,    0,  459,  459,  460,  462,    0,
      460,    0,  460,    0,  460,    0,    0,    0,  462,  460,

      462,  463,  462,    0,  463,    0,    0,  462,    0,  464,
        0,  463,    0,  463,    0,  463,    0,  465,    0,  464,
      463,  464,    0,  464,  465,  466,    0,  465,  464,  465,
        0,  465,    0,  467,    0,  466,  465,  466,    0,  466,
        0,  468,    0,  467,  466,  467,    0,  467,  468,    0,
        0,  468,  467,  468,  469,  468,  469,  470,    0,    0,
      468,    0,    0,    0,  469,    0,  469,  470,  469,  470,
      471,  470,    0,  469,    0,  470,  470,    0,    0,    0,
      471,  472,  471,    0,  471,    0,    0,  473,  471,  471,
        0,  472,    0,  472,    0,  472,    0,  473,  474,  473,

      472,  473,    0,    0,  478,    0,  473,    0,  474,    0,
      474,  478,  474,    0,  478,  479,  478,  474,  478,    0,
        0,    0,    0,  478,    0,  479,  480,  479,    0,  479,
        0,    0,  481,  479,  479,    0,  480,    0,  480,    0,
      480,    0,  481,  482,  481,  480,  481,    0,    0,  483,
        0,  481,  483,  482,    0,  482,    0,  482,    0,  483,
      482,  483,  482,  483,  484,  485,  485,    0,  483,    0,
        0,    0,    0,    0,  484,  485,  484,  485,  484,  485,
      487,  488,    0,  484,  485,    0,    0,    0,    0,    0,
      487,  488,  487,  488,  487,  488,  490,  492,    0,  487,

      488,  492,    0,    0,    0,    0,  490,  492,  490,  492,
      490,  492,  493,  494,    0,  490,  492,    0,    0,    0,
        0,    0,  493,  494,  493,  494,  493,  494,    0,    0,
      496,  493,  494,  496,    0,    0,  498,  514,    0,  498,
      496,    0,  496,    0,  496,    0,  498,    0,  498,  496,
      498,  500,  500,  514,    0,  498,    0,    0,    0,    0,
        0,    0,  500,  514,  500,  514,  500,  514,  515,  516,
      516,  500,  514,    0,    0,  515,    0,    0,  515,  516,
      515,  516,  515,  516,  518,    0,    0,  515,  516,    0,
        0,    0,  519,    0,  518,  520,  518,    0,  518,    0,

      518,    0,  519,  518,  519,  520,  519,  520,  521,  520,
      519,  519,    0,    0,  520,    0,  522,    0,  521,    0,
      521,  521,  521,    0,    0,    0,  522,  521,  522,  523,
      522,    0,  523,    0,    0,  522,    0,  524,    0,  523,
        0,  523,    0,  523,    0,  525,    0,  524,  523,  524,
        0,  524,  525,  526,    0,  525,  524,  525,    0,  525,
        0,    0,    0,  526,  525,  526,  531,  526,    0,  531,
        0,    0,  526,    0,  532,    0,  531,  533,  531,    0,
      531,    0,    0,    0,  532,  531,  532,  533,  532,  533,
      534,  533,    0,  532,    0,    0,  533,    0,  535,    0,

      534,  537,  534,    0,  534,  537,    0,    0,  535,  534,
      535,  537,  535,  537,  538,  537,  535,  535,    0,    0,
      537,    0,  540,    0,  538,    0,  538,    0,  538,    0,
      542,    0,  540,  538,  540,    0,  540,  542,  544,    0,
      542,  540,  542,    0,  542,    0,  546,    0,  544,  542,
      544,    0,  544,    0,  548,    0,  546,  544,  546,    0,
      546,    0,  560,    0,  548,  546,  548,    0,  548,    0,
      561,    0,  560,  548,  560,    0,  560,    0,  562,  560,
      561,  560,  561,  561,  561,    0,  564,    0,  562,  561,
      562,    0,  562,    0,  565,    0,  564,  562,  564,    0,

      564,    0,    0,    0,  565,  564,  565,  566,  565,    0,
      566,  565,    0,  565,    0,  567,    0,  566,  568,  566,
      568,  566,    0,    0,    0,  567,  566,  567,  568,  567,
      568,  569,  568,    0,  567,    0,    0,  568,    0,  574,
        0,  569,    0,  569,    0,  569,    0,  575,    0,  574,
      569,  574,    0,  574,  575,  574,    0,  575,  574,  575,
      577,  575,    0,  580,    0,    0,  575,  577,    0,    0,
      577,  583,  577,  580,  577,  580,    0,  580,    0,  577,
        0,  583,  580,  583,  585,  583,    0,  597,    0,  583,
      583,    0,    0,    0,  585,  598,  585,  597,  585,  597,

        0,  597,    0,  585,    0,  598,  597,  598,  599,  598,
      597,  600,    0,  600,  598,    0,    0,    0,  599,  601,
      599,  600,  599,  600,    0,  600,    0,  599,    0,  601,
      600,  601,  602,  601,    0,    0,  601,    0,  601,    0,
      603,    0,  602,  607,  602,    0,  602,  603,    0,    0,
      603,  602,  603,  607,  603,  607,  608,  607,    0,  603,
        0,    0,  607,    0,  610,    0,  608,    0,  608,  608,
      608,    0,  613,    0,  610,  608,  610,    0,  610,  613,
      615,    0,  613,  610,  613,    0,  613,  615,  628,    0,
      615,  613,  615,    0,  615,    0,  629,    0,  628,  615,

      628,    0,  628,    0,  630,    0,  629,  628,  629,    0,
      629,    0,  631,    0,  630,  629,  630,    0,  630,    0,
      632,    0,  631,  630,  631,    0,  631,    0,    0,    0,
      632,  631,  632,  636,  632,    0,    0,    0,  632,  632,
        0,  638,    0,  636,  641,  636,    0,  636,  638,    0,
        0,  638,  636,  638,  641,  638,  641,  643,  641,    0,
      638,  643,  641,  641,    0,  653,    0,  643,  654,  643,
        0,  643,    0,    0,    0,  653,  643,  653,  654,  653,
      654,    0,  654,  653,  653,  658,    0,  654,  660,    0,
        0,  654,    0,    0,    0,  658,    0,  658,  660,  658,

      660,  663,  660,    0,  658,    0,  660,  660,    0,  665,
        0,  663,    0,  663,    0,  663,  665,    0,    0,  665,
      663,  665,    0,  665,  663,  674,  674,  675,  665,    0,
        0,    0,    0,    0,    0,    0,  674,  675,  674,  675,
      674,  675,  679,  682,    0,  674,  675,    0,    0,    0,
        0,    0,  679,  682,  679,  682,  679,  682,    0,  693,
      684,  679,  682,  684,    0,  679,    0,    0,    0,  693,
      684,  693,  684,  693,  684,  695,  698,    0,  693,  684,
        0,  693,    0,    0,    0,  695,  698,  695,  698,  695,
      698,  705,  698,    0,  695,  698,    0,  709,    0,    0,

        0,  705,    0,  705,    0,  705,    0,  709,    0,  709,
      705,  709,    0,    0,    0,    0,  709,  722,  722,  722,
      722,  722,  723,    0,  723,  724,  724,  724,  725,  725,
        0,  725,  725,  726,  726,  726,  727,  727,  727,  728,
      728,  728,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,

      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721
    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
char *yytext;
#define INITIAL 0
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "defs.h"
#include "parser.h"
#include "error.h"

#define T_NOTOKEN		9999

static LLPOS current_pos;
static LLPOS last_pos;

#undef YY_INPUT
#define YY_INPUT(buf,result,max_size) {\
if (!filelen) { result = YY_NULL;\
} else { while (currentfilepos >= allfilestarts[currentfile+1]) currentfile++;\
buf[0] = *currentfilepos++; filelen--;\
last_pos = current_pos;\
if (buf[0] == '\n') { current_pos.line++; current_pos.column = 1; }\
else { current_pos.column++; }\
current_pos.file = allfilenames[currentfile];\
result = 1;\
}}

LLSTYPE yylval;
char *file = NULL;
int filelen = 0;
char *currentfilepos = NULL;
char **allfilenames;
char **allfilestarts;
int currentfile;
#define DIRECTIVE 1


/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap YY_PROTO(( void ));
#else
extern int yywrap YY_PROTO(( void ));
#endif
#endif

#ifndef YY_NO_UNPUT
static void yyunput YY_PROTO(( int c, char *buf_ptr ));
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput YY_PROTO(( void ));
#else
static int input YY_PROTO(( void ));
#endif
#endif

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state YY_PROTO(( int new_state ));
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state YY_PROTO(( void ));
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO(( void ));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( yy_current_buffer->yy_is_interactive ) \
		{ \
		int c = '*', n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
		  && ferror( yyin ) ) \
		YY_FATAL_ERROR( "input in flex scanner failed" );
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL int yylex YY_PROTO(( void ))
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

YY_DECL
	{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;


	if ( yy_init )
		{
		yy_init = 0;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yy_start )
			yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! yy_current_buffer )
			yy_current_buffer =
				yy_create_buffer( yyin, YY_BUF_SIZE );

		yy_load_buffer_state();
		}

	while ( 1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yy_start;
yy_match:
		do
			{
			register YY_CHAR yy_c = (YY_CHAR) yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				yy_last_accepting_state = yy_current_state;
				yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 722 )
					yy_c = (YY_CHAR) yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 3743 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;


do_action:	/* This label is used only to access EOF actions. */


		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yy_hold_char;
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
return T_ABSENT;
	YY_BREAK
case 2:
YY_RULE_SETUP
return T_ABSTRACT_SYNTAX;
	YY_BREAK
case 3:
YY_RULE_SETUP
return T_ALL;
	YY_BREAK
case 4:
YY_RULE_SETUP
return T_ANY;
	YY_BREAK
case 5:
YY_RULE_SETUP
return T_APPLICATION;
	YY_BREAK
case 6:
YY_RULE_SETUP
return T_AUTOMATIC;
	YY_BREAK
case 7:
YY_RULE_SETUP
return T_BEGIN;
	YY_BREAK
case 8:
YY_RULE_SETUP
return T_BIT;
	YY_BREAK
case 9:
YY_RULE_SETUP
return T_BMPString;
	YY_BREAK
case 10:
YY_RULE_SETUP
return T_BOOLEAN;
	YY_BREAK
case 11:
YY_RULE_SETUP
return T_BY;
	YY_BREAK
case 12:
YY_RULE_SETUP
return T_CHARACTER;
	YY_BREAK
case 13:
YY_RULE_SETUP
return T_CHOICE;
	YY_BREAK
case 14:
YY_RULE_SETUP
return T_CLASS;
	YY_BREAK
case 15:
YY_RULE_SETUP
return T_COMPONENT;
	YY_BREAK
case 16:
YY_RULE_SETUP
return T_COMPONENTS;
	YY_BREAK
case 17:
YY_RULE_SETUP
return T_CONSTRAINED;
	YY_BREAK
case 18:
YY_RULE_SETUP
return T_DEFAULT;
	YY_BREAK
case 19:
YY_RULE_SETUP
return T_DEFINED;
	YY_BREAK
case 20:
YY_RULE_SETUP
return T_DEFINITIONS;
	YY_BREAK
case 21:
YY_RULE_SETUP
return T_EMBEDDED;
	YY_BREAK
case 22:
YY_RULE_SETUP
return T_empty;
	YY_BREAK
case 23:
YY_RULE_SETUP
return T_END;
	YY_BREAK
case 24:
YY_RULE_SETUP
return T_ENUMERATED;
	YY_BREAK
case 25:
YY_RULE_SETUP
return T_EXCEPT;
	YY_BREAK
case 26:
YY_RULE_SETUP
return T_EXPLICIT;
	YY_BREAK
case 27:
YY_RULE_SETUP
return T_EXPORTS;
	YY_BREAK
case 28:
YY_RULE_SETUP
return T_EXTENSIBILITY;
	YY_BREAK
case 29:
YY_RULE_SETUP
return T_EXTERNAL;
	YY_BREAK
case 30:
YY_RULE_SETUP
return T_FALSE;
	YY_BREAK
case 31:
YY_RULE_SETUP
return T_FROM;
	YY_BREAK
case 32:
YY_RULE_SETUP
return T_GeneralizedTime;
	YY_BREAK
case 33:
YY_RULE_SETUP
return T_GeneralString;
	YY_BREAK
case 34:
YY_RULE_SETUP
return T_GraphicString;
	YY_BREAK
case 35:
YY_RULE_SETUP
return T_IA5String;
	YY_BREAK
case 36:
YY_RULE_SETUP
return T_TYPE_IDENTIFIER;
	YY_BREAK
case 37:
YY_RULE_SETUP
return T_IDENTIFIER;
	YY_BREAK
case 38:
YY_RULE_SETUP
return T_identifier;
	YY_BREAK
case 39:
YY_RULE_SETUP
return T_IMPLICIT;
	YY_BREAK
case 40:
YY_RULE_SETUP
return T_IMPLIED;
	YY_BREAK
case 41:
YY_RULE_SETUP
return T_IMPORTS;
	YY_BREAK
case 42:
YY_RULE_SETUP
return T_INCLUDES;
	YY_BREAK
case 43:
YY_RULE_SETUP
return T_INSTANCE;
	YY_BREAK
case 44:
YY_RULE_SETUP
return T_INTEGER;
	YY_BREAK
case 45:
YY_RULE_SETUP
return T_INTERSECTION;
	YY_BREAK
case 46:
YY_RULE_SETUP
return T_ISO646String;
	YY_BREAK
case 47:
YY_RULE_SETUP
return T_MACRO;
	YY_BREAK
case 48:
YY_RULE_SETUP
return T_MAX;
	YY_BREAK
case 49:
YY_RULE_SETUP
return T_MIN;
	YY_BREAK
case 50:
YY_RULE_SETUP
return T_MINUS_INFINITY;
	YY_BREAK
case 51:
YY_RULE_SETUP
return T_NOTATION;
	YY_BREAK
case 52:
YY_RULE_SETUP
return T_NULL;
	YY_BREAK
case 53:
YY_RULE_SETUP
return T_Number;
	YY_BREAK
case 54:
YY_RULE_SETUP
return T_NumericString;
	YY_BREAK
case 55:
YY_RULE_SETUP
return T_OBJECT;
	YY_BREAK
case 56:
YY_RULE_SETUP
return T_ObjectDescriptor;
	YY_BREAK
case 57:
YY_RULE_SETUP
return T_OCTET;
	YY_BREAK
case 58:
YY_RULE_SETUP
return T_OF;
	YY_BREAK
case 59:
YY_RULE_SETUP
return T_OPTIONAL;
	YY_BREAK
case 60:
YY_RULE_SETUP
return T_PDV;
	YY_BREAK
case 61:
YY_RULE_SETUP
return T_PLUS_INFINITY;
	YY_BREAK
case 62:
YY_RULE_SETUP
return T_PRESENT;
	YY_BREAK
case 63:
YY_RULE_SETUP
return T_PrintableString;
	YY_BREAK
case 64:
YY_RULE_SETUP
return T_PRIVATE;
	YY_BREAK
case 65:
YY_RULE_SETUP
return T_REAL;
	YY_BREAK
case 66:
YY_RULE_SETUP
return T_SEQUENCE;
	YY_BREAK
case 67:
YY_RULE_SETUP
return T_SET;
	YY_BREAK
case 68:
YY_RULE_SETUP
return T_SIZE;
	YY_BREAK
case 69:
YY_RULE_SETUP
return T_STRING;
	YY_BREAK
case 70:
YY_RULE_SETUP
return T_string;
	YY_BREAK
case 71:
YY_RULE_SETUP
return T_SYNTAX;
	YY_BREAK
case 72:
YY_RULE_SETUP
return T_T61String;
	YY_BREAK
case 73:
YY_RULE_SETUP
return T_TAGS;
	YY_BREAK
case 74:
YY_RULE_SETUP
return T_TeletexString;
	YY_BREAK
case 75:
YY_RULE_SETUP
return T_TRUE;
	YY_BREAK
case 76:
YY_RULE_SETUP
return T_TYPE;
	YY_BREAK
case 77:
YY_RULE_SETUP
return T_type;
	YY_BREAK
case 78:
YY_RULE_SETUP
return T_UNION;
	YY_BREAK
case 79:
YY_RULE_SETUP
return T_UNIQUE;
	YY_BREAK
case 80:
YY_RULE_SETUP
return T_UNIVERSAL;
	YY_BREAK
case 81:
YY_RULE_SETUP
return T_UniversalString;
	YY_BREAK
case 82:
YY_RULE_SETUP
return T_UTCTime;
	YY_BREAK
case 83:
YY_RULE_SETUP
return T_UTF8String;
	YY_BREAK
case 84:
YY_RULE_SETUP
return T_VALUE;
	YY_BREAK
case 85:
YY_RULE_SETUP
return T_value;
	YY_BREAK
case 86:
YY_RULE_SETUP
return T_VideotexString;
	YY_BREAK
case 87:
YY_RULE_SETUP
return T_VisibleString;
	YY_BREAK
case 88:
YY_RULE_SETUP
return T_WITH;
	YY_BREAK
case 89:
YY_RULE_SETUP
return *yytext;
	YY_BREAK
case 90:
YY_RULE_SETUP
return T_DEF;
	YY_BREAK
case 91:
YY_RULE_SETUP
return T_TDOT;
	YY_BREAK
case 92:
YY_RULE_SETUP
return T_DDOT;
	YY_BREAK
case 93:
YY_RULE_SETUP
{	int i;
					intx_t h;
					intx_setuint32(&yylval._XNumber, 0);
					for (i = 0; i < yyleng; i++) {
					    intx_muloctet(&h, &yylval._XNumber,
						10);
					    intx_addoctet(&yylval._XNumber, &h,
						(octet_t)(yytext[i] - '0'));
					}
					return T_number;
				}
	YY_BREAK
case 94:
YY_RULE_SETUP
{	char *p, *q;
					q = yylval._XString =
					    (char *)malloc(yyleng - 2);
					for (p = yytext + 1; *p != '\''; p++)
						if (*p == '0' || *p == '1')
							*q++ = *p;
					*q = 0;
					return T_bstring;
				}
	YY_BREAK
case 95:
YY_RULE_SETUP
{	char *p, *q;
					q = yylval._XString =
					    (char *)malloc(yyleng - 2);
					for (p = yytext + 1; *p != '\''; p++)
						if (isxdigit(*p))
							*q++ = *p;
					*q = 0;
					return T_hstring;
				}
	YY_BREAK
case 96:
YY_RULE_SETUP
{	int s, l = 0, c;
					LLPOS start_pos;
					yylval._XString32 =
					    (char32_t *)malloc(
					    (s = 32) * sizeof(char32_t));
					start_pos = last_pos;
					for (;;) {
					    c = input();
					    if (!c || c == EOF) {
						error(E_unterminated_string,
						    &start_pos);
						/*NOTREACHED*/
					    }
					    if (c == '\n') {
						while (l > 0 && is32space(
						    yylval._XString32[l - 1]))
						    l--;
						while (c = input()) {
						    if (!isspace(c))
							break;
						}
					    }
					    if (c == '\"') {
						c = input();
						if (c != '\"') {
						    unput(c);
						    yylval._XString32[l] = 0;
						    return T_cstring;
						}
					    }
					    if (l + 1 >= s) {
						yylval._XString32 = (char32_t *)
						    realloc(yylval._XString32,
						    (s *= 2) *
						    sizeof(char32_t));
					    }
					    yylval._XString32[l++] = c;
					}
				}
	YY_BREAK
case 97:
YY_RULE_SETUP
{
					yylval._XString =
						(char *)malloc(yyleng + 1);
					strcpy(yylval._XString, yytext);
					return T_only_uppercase_symbol;
				}
	YY_BREAK
case 98:
YY_RULE_SETUP
{
					yylval._XString =
						(char *)malloc(yyleng + 1);
					strcpy(yylval._XString, yytext);
					return T_only_uppercase_digits_symbol;
				}
	YY_BREAK
case 99:
YY_RULE_SETUP
{
					yylval._XString =
						(char *)malloc(yyleng + 1);
					strcpy(yylval._XString, yytext);
					return T_uppercase_symbol;
				}
	YY_BREAK
case 100:
YY_RULE_SETUP
{
					yylval._XString =
						(char *)malloc(yyleng + 1);
					strcpy(yylval._XString, yytext);
					return T_lcsymbol;
				}
	YY_BREAK
case 101:
YY_RULE_SETUP
{
					yylval._XString =
						(char *)malloc(yyleng + 1);
					strcpy(yylval._XString, yytext);
					return T_amplcsymbol;
				}
	YY_BREAK
case 102:
YY_RULE_SETUP
{
					yylval._XString =
						(char *)malloc(yyleng + 1);
					strcpy(yylval._XString, yytext);
					return T_ampucsymbol;
				}
	YY_BREAK
case 103:
YY_RULE_SETUP
{	BEGIN DIRECTIVE;
				}
	YY_BREAK
case 104:
YY_RULE_SETUP
{	BEGIN INITIAL;
				}
	YY_BREAK
case 105:
YY_RULE_SETUP
{	BEGIN INITIAL;
				}
	YY_BREAK
case 106:
case 107:
YY_RULE_SETUP
{	return T_FIXED_ARRAY;
				}
	YY_BREAK
case 108:
case 109:
YY_RULE_SETUP
{	return T_SINGLY_LINKED_LIST;
				}
	YY_BREAK
case 110:
case 111:
YY_RULE_SETUP
{	return T_DOUBLY_LINKED_LIST;
				}
	YY_BREAK
case 112:
case 113:
YY_RULE_SETUP
{	return T_LENGTH_POINTER;
				}
	YY_BREAK
case 114:
case 115:
YY_RULE_SETUP
{	return T_ZERO_TERMINATED;
				}
	YY_BREAK
case 116:
case 117:
YY_RULE_SETUP
{	return T_POINTER;
				}
	YY_BREAK
case 118:
case 119:
YY_RULE_SETUP
{	return T_NO_POINTER;
				}
	YY_BREAK
case 120:
YY_RULE_SETUP
{	/* ignore */
				}
	YY_BREAK
case 121:
YY_RULE_SETUP
{	fprintf(stderr,
						"Bad directive %s (ignored)\n",
						yytext);
				}
	YY_BREAK
case 122:
YY_RULE_SETUP
{	int c;
					for (;;) {
						c = input();
						if (c == 0 || c == EOF)
							break;
						if (c == '\n')
							break;
#ifdef MS_DIRECTIVE
					    if (c == g_chDirectiveBegin)
					    {
				            c = input();
					        GetPrivateDirective(&c);
					    }
#endif // MS_DIRECTIVE
						if (c != '-')
							continue;
						c = input();
						if (c == 0 || c == EOF)
							break;
						if (c == '\n')
							break;
						if (c != '-')
							continue;
						break;
					}
					return T_NOTOKEN;
				}
	YY_BREAK
case 123:
YY_RULE_SETUP
return T_NOTOKEN;
	YY_BREAK
case 124:
YY_RULE_SETUP
return EOF;
	YY_BREAK
case 125:
YY_RULE_SETUP
{	error(E_bad_character, &last_pos);
				}
	YY_BREAK
case 126:
YY_RULE_SETUP
ECHO;
	YY_BREAK
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(DIRECTIVE):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yy_hold_char;

		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between yy_current_buffer and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yy_n_chars = yy_current_buffer->yy_n_chars;
			yy_current_buffer->yy_input_file = yyin;
			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state();

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer() )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yy_did_buffer_switch_on_eof = 0;

				if ( yywrap() )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yy_c_buf_p =
					yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yy_c_buf_p =
				&yy_current_buffer->yy_ch_buf[yy_n_chars];

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of yylex */


/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer()
	{
	register char *dest = yy_current_buffer->yy_ch_buf;
	register char *source = yytext_ptr;
	register int number_to_move, i;
	int ret_val;

	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( yy_current_buffer->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		yy_n_chars = 0;

	else
		{
		int num_to_read =
			yy_current_buffer->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
			YY_FATAL_ERROR(
"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
#else

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = yy_current_buffer;

			int yy_c_buf_p_offset =
				(int) (yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yy_flex_realloc( (void *) b->yy_ch_buf,
							 b->yy_buf_size + 2 );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = 0;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = yy_current_buffer->yy_buf_size -
						number_to_move - 1;
#endif
			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
			yy_n_chars, num_to_read );
		}

	if ( yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			yy_current_buffer->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	yy_n_chars += number_to_move;
	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

	return ret_val;
	}


/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state()
	{
	register yy_state_type yy_current_state;
	register char *yy_cp;

	yy_current_state = yy_start;

	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
		{
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yy_last_accepting_state = yy_current_state;
			yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 722 )
				yy_c = (YY_CHAR) yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		}

	return yy_current_state;
	}


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */

#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
#else
static yy_state_type yy_try_NUL_trans( yy_current_state )
yy_state_type yy_current_state;
#endif
	{
	register int yy_is_jam;
	register char *yy_cp = yy_c_buf_p;

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 722 )
			yy_c = (YY_CHAR) yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 721);

	return yy_is_jam ? 0 : yy_current_state;
	}


#ifndef YY_NO_UNPUT
#ifdef YY_USE_PROTOS
static void yyunput( int c, register char *yy_bp )
#else
static void yyunput( c, yy_bp )
int c;
register char *yy_bp;
#endif
	{
	register char *yy_cp = yy_c_buf_p;

	/* undo effects of setting up yytext */
	*yy_cp = yy_hold_char;

	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		register int number_to_move = yy_n_chars + 2;
		register char *dest = &yy_current_buffer->yy_ch_buf[
					yy_current_buffer->yy_buf_size + 2];
		register char *source =
				&yy_current_buffer->yy_ch_buf[number_to_move];

		while ( source > yy_current_buffer->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		yy_n_chars = yy_current_buffer->yy_buf_size;

		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;


	yytext_ptr = yy_bp;
	yy_hold_char = *yy_cp;
	yy_c_buf_p = yy_cp;
	}
#endif	/* ifndef YY_NO_UNPUT */


#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif
	{
	int c;

	*yy_c_buf_p = yy_hold_char;

	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			/* This was really a NUL. */
			*yy_c_buf_p = '\0';

		else
			{ /* need more input */
			yytext_ptr = yy_c_buf_p;
			++yy_c_buf_p;

			switch ( yy_get_next_buffer() )
				{
				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap() )
						{
						yy_c_buf_p =
						yytext_ptr + YY_MORE_ADJ;
						return EOF;
						}

					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
					break;

				case EOB_ACT_LAST_MATCH:
#ifdef __cplusplus
					YY_FATAL_ERROR(
					"unexpected last match in yyinput()" );
#else
					YY_FATAL_ERROR(
					"unexpected last match in input()" );
#endif
				}
			}
		}

	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
	*yy_c_buf_p = '\0';	/* preserve yytext */
	yy_hold_char = *++yy_c_buf_p;


	return c;
	}


#ifdef YY_USE_PROTOS
void yyrestart( FILE *input_file )
#else
void yyrestart( input_file )
FILE *input_file;
#endif
	{
	if ( ! yy_current_buffer )
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );

	yy_init_buffer( yy_current_buffer, input_file );
	yy_load_buffer_state();
	}


#ifdef YY_USE_PROTOS
void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
#else
void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
#endif
	{
	if ( yy_current_buffer == new_buffer )
		return;

	if ( yy_current_buffer )
		{
		/* Flush out information for old buffer. */
		*yy_c_buf_p = yy_hold_char;
		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
		yy_current_buffer->yy_n_chars = yy_n_chars;
		}

	yy_current_buffer = new_buffer;
	yy_load_buffer_state();

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	yy_did_buffer_switch_on_eof = 1;
	}


#ifdef YY_USE_PROTOS
void yy_load_buffer_state( void )
#else
void yy_load_buffer_state()
#endif
	{
	yy_n_chars = yy_current_buffer->yy_n_chars;
	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
	yyin = yy_current_buffer->yy_input_file;
	yy_hold_char = *yy_c_buf_p;
	}


#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
#else
YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
#endif
	{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
	}


#ifdef YY_USE_PROTOS
void yy_delete_buffer( YY_BUFFER_STATE b )
#else
void yy_delete_buffer( b )
YY_BUFFER_STATE b;
#endif
	{
	if ( ! b )
		return;

	if ( b == yy_current_buffer )
		yy_current_buffer = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yy_flex_free( (void *) b->yy_ch_buf );

	yy_flex_free( (void *) b );
	}


#ifndef YY_ALWAYS_INTERACTIVE
#ifndef YY_NEVER_INTERACTIVE
extern int __cdecl isatty YY_PROTO(( int ));
#endif
#endif

#ifdef YY_USE_PROTOS
void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
#else
void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;
#endif


	{
	yy_flush_buffer( b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

#if YY_ALWAYS_INTERACTIVE
	b->yy_is_interactive = 1;
#else
#if YY_NEVER_INTERACTIVE
	b->yy_is_interactive = 0;
#else
	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
#endif
#endif
	}


#ifdef YY_USE_PROTOS
void yy_flush_buffer( YY_BUFFER_STATE b )
#else
void yy_flush_buffer( b )
YY_BUFFER_STATE b;
#endif

	{
	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == yy_current_buffer )
		yy_load_buffer_state();
	}


#ifndef YY_NO_SCAN_BUFFER
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
#else
YY_BUFFER_STATE yy_scan_buffer( base, size )
char *base;
yy_size_t size;
#endif
	{
	YY_BUFFER_STATE b;

	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return 0;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = 0;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer( b );

	return b;
	}
#endif


#ifndef YY_NO_SCAN_STRING
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
#else
YY_BUFFER_STATE yy_scan_string( yy_str )
yyconst char *yy_str;
#endif
	{
	int len;
	for ( len = 0; yy_str[len]; ++len )
		;

	return yy_scan_bytes( yy_str, len );
	}
#endif


#ifndef YY_NO_SCAN_BYTES
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
#else
YY_BUFFER_STATE yy_scan_bytes( bytes, len )
yyconst char *bytes;
int len;
#endif
	{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = len + 2;
	buf = (char *) yy_flex_alloc( n );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < len; ++i )
		buf[i] = bytes[i];

	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer( buf, n );
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
	}
#endif


#ifndef YY_NO_PUSH_STATE
#ifdef YY_USE_PROTOS
static void yy_push_state( int new_state )
#else
static void yy_push_state( new_state )
int new_state;
#endif
	{
	if ( yy_start_stack_ptr >= yy_start_stack_depth )
		{
		yy_size_t new_size;

		yy_start_stack_depth += YY_START_STACK_INCR;
		new_size = yy_start_stack_depth * sizeof( int );

		if ( ! yy_start_stack )
			yy_start_stack = (int *) yy_flex_alloc( new_size );

		else
			yy_start_stack = (int *) yy_flex_realloc(
					(void *) yy_start_stack, new_size );

		if ( ! yy_start_stack )
			YY_FATAL_ERROR(
			"out of memory expanding start-condition stack" );
		}

	yy_start_stack[yy_start_stack_ptr++] = YY_START;

	BEGIN(new_state);
	}
#endif


#ifndef YY_NO_POP_STATE
static void yy_pop_state()
	{
	if ( --yy_start_stack_ptr < 0 )
		YY_FATAL_ERROR( "start-condition stack underflow" );

	BEGIN(yy_start_stack[yy_start_stack_ptr]);
	}
#endif


#ifndef YY_NO_TOP_STATE
static int yy_top_state()
	{
	return yy_start_stack[yy_start_stack_ptr - 1];
	}
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

#ifdef YY_USE_PROTOS
static void yy_fatal_error( yyconst char msg[] )
#else
static void yy_fatal_error( msg )
char msg[];
#endif
	{
	(void) fprintf( stderr, "%s\n", msg );
	MyExit( YY_EXIT_FAILURE );
	}



/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		yytext[yyleng] = yy_hold_char; \
		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \
		yy_hold_char = *yy_c_buf_p; \
		*yy_c_buf_p = '\0'; \
		yyleng = n; \
		} \
	while ( 0 )


/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
#else
static void yy_flex_strncpy( s1, s2, n )
char *s1;
yyconst char *s2;
int n;
#endif
	{
	register int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
	}
#endif

#ifdef YY_USE_PROTOS
static void *yy_flex_alloc( yy_size_t size )
#else
static void *yy_flex_alloc( size )
yy_size_t size;
#endif
	{
	return (void *) malloc( size );
	}

#ifdef YY_USE_PROTOS
static void *yy_flex_realloc( void *ptr, yy_size_t size )
#else
static void *yy_flex_realloc( ptr, size )
void *ptr;
yy_size_t size;
#endif
	{
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return (void *) realloc( (char *) ptr, size );
	}

#ifdef YY_USE_PROTOS
static void yy_flex_free( void *ptr )
#else
static void yy_flex_free( ptr )
void *ptr;
#endif
	{
	free( ptr );
	}

#if YY_MAIN
int main()
	{
	yylex();
	return 0;
	}
#endif


int llgettoken(int *token, LLSTYPE *lval, LLPOS *pos)
{
    for (;;) {
#ifdef MS_DIRECTIVE
// Ordering of hack directives
//      PrivateDir_Huge PrivateDir_Unbounded PrivateDir_Array PrivateDir_NoCopy PrivateDir_PDU
//      PrivateDir_ObjectIdEncoded PrivateDir_ObjectIdFixedSize
//      PrivateDir_Type PrivateDir_Field PrivateDir_Value PrivateDir_Linked

    if (g_fPrivateDir_Intx)
    {
        g_fPrivateDir_Intx = 0;
        yylval._XString = "PrivateDir_Intx";
        *lval = yylval;
        *token = T_PrivateDir_Intx;
        return 1;
    }
    if (g_fPrivateDir_LenPtr)
    {
        g_fPrivateDir_LenPtr = 0;
        yylval._XString = "PrivateDir_LenPtr";
        *lval = yylval;
        *token = T_PrivateDir_LenPtr;
        return 1;
    }
    if (g_fPrivateDir_Pointer)
    {
        g_fPrivateDir_Pointer = 0;
        yylval._XString = "PrivateDir_Pointer";
        *lval = yylval;
        *token = T_PrivateDir_Pointer;
        return 1;
    }
    if (g_fPrivateDir_Array)
    {
        g_fPrivateDir_Array = 0;
        yylval._XString = "PrivateDir_Array";
        *lval = yylval;
        *token = T_PrivateDir_Array;
        return 1;
    }
    if (g_fPrivateDir_NoCode)
    {
        g_fPrivateDir_NoCode = 0;
        yylval._XString = "PrivateDir_NoCode";
        *lval = yylval;
        *token = T_PrivateDir_NoCode;
        return 1;
    }
    if (g_fPrivateDir_NoMemCopy)
    {
        g_fPrivateDir_NoMemCopy = 0;
        yylval._XString = "PrivateDir_NoMemCopy";
        *lval = yylval;
        *token = T_PrivateDir_NoMemCopy;
        return 1;
    }
    if (g_fPrivateDir_Public)
    {
        g_fPrivateDir_Public = 0;
        yylval._XString = "PrivateDir_Public";
        *lval = yylval;
        *token = T_PrivateDir_Public;
        return 1;
    }
    if (g_fPrivateDir_OidPacked)
    {
        g_fPrivateDir_OidPacked = 0;
        yylval._XString = "PrivateDir_OidPacked";
        *lval = yylval;
        *token = T_PrivateDir_OidPacked;
        return 1;
    }
    if (g_fPrivateDir_OidArray)
    {
        g_fPrivateDir_OidArray = 0;
        yylval._XString = "PrivateDir_OidArray";
        *lval = yylval;
        *token = T_PrivateDir_OidArray;
        return 1;
    }
    if (g_szPrivateDirectedTypeName[0])
    {
        if (g_fPrivateDir_TypeNameToken)
        {
            yylval._XString = strdup(&g_szPrivateDirectedTypeName[0]);
            g_szPrivateDirectedTypeName[0] = '\0';
            *lval = yylval;
            *token = T_lcsymbol;
        }
        else
        {
            g_fPrivateDir_TypeNameToken = 1;
            yylval._XString = "PrivateDir_TypeName";
            *lval = yylval;
            *token = T_PrivateDir_TypeName;
        }
        return 1;
    }
    if (g_szPrivateDirectedFieldName[0])
    {
        if (g_fPrivateDir_FieldNameToken)
        {
            yylval._XString = strdup(&g_szPrivateDirectedFieldName[0]);
            g_szPrivateDirectedFieldName[0] = '\0';
            *lval = yylval;
            *token = T_lcsymbol;
        }
        else
        {
            g_fPrivateDir_FieldNameToken = 1;
            yylval._XString = "PrivateDir_FieldName";
            *lval = yylval;
            *token = T_PrivateDir_FieldName;
        }
        return 1;
    }
    if (g_szPrivateDirectedValueName[0])
    {
        if (g_fPrivateDir_ValueNameToken)
        {
            yylval._XString = strdup(&g_szPrivateDirectedValueName[0]);
            g_szPrivateDirectedValueName[0] = '\0';
            *lval = yylval;
            *token = T_lcsymbol;
        }
        else
        {
            g_fPrivateDir_ValueNameToken = 1;
            yylval._XString = "PrivateDir_ValueName";
            *lval = yylval;
            *token = T_PrivateDir_ValueName;
        }
        return 1;
    }
    if (g_fPrivateDir_SLinked)
    {
        g_fPrivateDir_SLinked = 0;
        yylval._XString = "PrivateDir_SLinked";
        *lval = yylval;
        *token = T_PrivateDir_SLinked;
        return 1;
    }
    if (g_fPrivateDir_DLinked)
    {
        g_fPrivateDir_DLinked = 0;
        yylval._XString = "PrivateDir_DLinked";
        *lval = yylval;
        *token = T_PrivateDir_DLinked;
        return 1;
    }
#endif // MS_DIRECTIVE
	if (yy_hold_char == YY_END_OF_BUFFER_CHAR) {
	    *pos = current_pos;
	} else {
	    *pos = last_pos;
	}
	*token = yylex();
	if (*token == 0 || *token == EOF)
	    return 0;
	if (*token == T_NOTOKEN)
	    continue;
	*lval = yylval;
	return 1;
    }
}

void readfiles(char **filenames)
{
    FILE *fin;
    long len;
    int i, nfiles, j;

    for (nfiles = 0; filenames[nfiles]; nfiles++) {}
    allfilenames = filenames;
    allfilestarts = (char **)malloc((nfiles + 1) * sizeof(char *));
    filelen = 0;
    for (i = 0; i < nfiles; i++) {
	fin = fopen(filenames[i], "r");
	if (!fin) {
	    perror(filenames[i]);
	    MyExit(1);
	}
	fseek(fin, 0, SEEK_END);
	filelen += ftell(fin);
	fclose(fin);
    }
    currentfilepos = file = (char *)malloc(filelen);
    for (i = 0; i < nfiles; i++) {
	fin = fopen(filenames[i], "r");
	if (!fin) {
	    perror(filenames[i]);
	    MyExit(1);
	}
	fseek(fin, 0, SEEK_END);
	len = ftell(fin);
	fseek(fin, 0, SEEK_SET);
	allfilestarts[i] = currentfilepos;
	len = fread(currentfilepos, 1, len, fin);
	currentfilepos += len;
	fclose(fin);
    }
    filelen = currentfilepos - file;
    allfilestarts[i] = currentfilepos;

    // set up the first file's info
    currentfilepos = file;
    current_pos.line = 1;
    current_pos.column = 1;
    current_pos.file = filenames[0];
    last_pos = current_pos;

    // mask out all the directives prior to the body
    for (i = 0; i < nfiles; i++)
    {
        char *psz = allfilestarts[i];
        while (isspace(*psz))
            psz++;
        while ('-' == *psz && '-' == *(psz+1))
        {
            psz += 2;
            // mask out directives if needed
            if (g_chDirectiveBegin == *psz)
                *psz++ = ' ';
            SetDirective(psz);
            // locate the closing '--'
            while ('\n' != *psz)
            {
                if ('-' == *psz && '-' == *(psz+1))
                {
                    psz++;
                    break;
                }
                psz++;
            }
            psz++; // skip over '\n' or the second '-'
            // skip over white spaces
            while (isspace(*psz))
                psz++;
        }

        // associate ghost files with ghost modules
        for (j = 0; j < g_cGhostFiles; j++)
        {
            if (! strcmp(g_aGhostFiles[j].pszFileName, filenames[i]))
            {
                int ch_idx;
                char szModuleName[128];
                // get the module identifier
                while (! isalpha(*psz))
                    psz++;
                for (ch_idx = 0; isalnum(*psz) || *psz == '-'; )
                {
                    szModuleName[ch_idx++] = *psz++;
                }
                szModuleName[ch_idx] = '\0'; // null terminator
                ASSERT(! g_aGhostFiles[j].pszModuleName);
                g_aGhostFiles[j].pszModuleName = strdup(szModuleName);
            }
        }
    }
}

void
llprinttoken(LLTERM *term, char *identifier, FILE *f)
{
    char32_t *p;

    switch (term->token) {
    case T_number:
	fprintf(f, "%s(%u)", identifier, intx2uint32(&term->lval._XNumber));
	break;
    case T_bstring:
    case T_hstring:
    case T_only_uppercase_symbol:
    case T_only_uppercase_digits_symbol:
    case T_uppercase_symbol:
    case T_lcsymbol:
    case T_ampucsymbol:
    case T_amplcsymbol:
	fprintf(f, "%s(%s)", identifier, term->lval._XString);
	break;
    case T_cstring:
	fprintf(f, "%s(", identifier);
	for (p = term->lval._XString32; *p; p++)
	    putc(*p, f);
	putc(')', f);
	break;
    default:
	fprintf(f, "%s", identifier);
    }
}


#ifdef MS_DIRECTIVE
int PrivateDirectives_Input ( void )
{
    return input();
}
#endif // MS_DIRECTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\util.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

extern int g_fLongNameForImported;

/* get the type by resolving references */
Type_t *
GetType(AssignmentList_t ass, Type_t *type)
{
    if (!type)
        return NULL;
    if (IsReferenceType(type))
        return GetType(ass, GetReferencedType(ass, type));
    return type;
}

/* get the type's type by resolving references */
Type_e
GetTypeType(AssignmentList_t ass, Type_t *type)
{
    type = GetType(ass, type);
    return type ? type->Type : eType_Undefined;
}

/* get the type rules */
TypeRules_e
GetTypeRules(AssignmentList_t ass, Type_t *type)
{
    if (!IsReferenceType(type))
        return type->Rules;
    return type->Rules | GetTypeRules(ass, GetReferencedType(ass, type));
}

/* get the value by resolving references */
Value_t *
GetValue(AssignmentList_t ass, Value_t *value)
{
    Assignment_t *a;

    if (!value)
        return NULL;
    if (!value->Type) {
        a = GetAssignment(ass, FindAssignment(ass, eAssignment_Value,
            value->U.Reference.Identifier, value->U.Reference.Module));
        if (!a)
            return NULL;
        return GetValue(ass, a->U.Value.Value);
    }
    return value;
}

/* get the object class by resolving references */
ObjectClass_t *
GetObjectClass(AssignmentList_t ass, ObjectClass_t *oc)
{
    Assignment_t *a;
    FieldSpec_t *fs;
    ObjectClass_t *oc2;

    if (!oc)
        return NULL;
    switch (oc->Type) {
    case eObjectClass_Reference:
        a = GetAssignment(ass, FindAssignment(ass, eAssignment_ObjectClass,
            oc->U.Reference.Identifier, oc->U.Reference.Module));
        if (!a)
            return NULL;
        return GetObjectClass(ass, a->U.ObjectClass.ObjectClass);
    case eObjectClass_FieldReference:
        oc2 = GetObjectClass(ass, oc->U.FieldReference.ObjectClass);
        if (!oc2)
            return NULL;
        fs = GetFieldSpec(ass, FindFieldSpec(oc2->U.ObjectClass.FieldSpec,
            oc->U.FieldReference.Identifier));
        if (!fs)
            return NULL;
        if (fs->Type == eFieldSpec_Object)
            return GetObjectClass(ass, fs->U.Object.ObjectClass);
        else if (fs->Type == eFieldSpec_ObjectSet)
            return GetObjectClass(ass, fs->U.ObjectSet.ObjectClass);
        else
            return NULL;
    }
    return oc;
}

/* get the object by resolving references */
Object_t *
GetObject(AssignmentList_t ass, Object_t *o)
{
    Assignment_t *a;

    if (!o)
        return NULL;
    if (o->Type == eObject_Reference) {
        a = GetAssignment(ass, FindAssignment(ass, eAssignment_Object,
            o->U.Reference.Identifier, o->U.Reference.Module));
        if (!a)
            return NULL;
        return GetObject(ass, a->U.Object.Object);
    }
    return o;
}

/* get the object set by resolving references */
ObjectSet_t *
GetObjectSet(AssignmentList_t ass, ObjectSet_t *os)
{
    Assignment_t *a;

    if (!os)
        return NULL;
    if (os->Type == eObjectSet_Reference) {
        a = GetAssignment(ass, FindAssignment(ass, eAssignment_ObjectSet,
            os->U.Reference.Identifier, os->U.Reference.Module));
        if (!a)
            return NULL;
        return GetObjectSet(ass, a->U.ObjectSet.ObjectSet);
    }
    return os;
}

/* get the field spec */
FieldSpec_t *
GetFieldSpec(AssignmentList_t ass, FieldSpec_t *fs)
{
    return fs;
}

/* get the field spec type */
FieldSpecs_e
GetFieldSpecType(AssignmentList_t ass, FieldSpec_t *fs)
{
    return fs ? fs->Type : eFieldSpec_Undefined;
}

/* convert an identifier into C syntax */
char *
Identifier2C(char *identifier)
{
    char buffer[256];
    char *p = buffer;

    while (*identifier) {
        if (isalnum(*identifier))
            *p++ = *identifier;
        else
            *p++ = '_';
        identifier++;
    }
    *p = 0;
    return strdup(buffer);
}

/* convert an identifier into C syntax */
char *
PIdentifier2C(char *identifier)
{
    char buffer[256];
    char *p = buffer;

    *p++ = 'P';
    while (*identifier) {
        if (isalnum(*identifier))
            *p++ = *identifier;
        else
            *p++ = '_';
        identifier++;
    }
    *p = 0;
    return strdup(buffer);
}

/* get the integer type and the sign of an integer with the given bounds */
static char *
GetIType(intx_t *lb, intx_t *ub, int32_t *sign)
{
    enum {
        eint8 = 1,
        euint8 = 2,
        eint16 = 4,
        euint16 = 8,
        eint32 = 16,
        euint32 = 32,
        eint64 = 64,
        euint64 = 128,
        eintx = 256,
        euintx = 512
    } type;
    
    type = (eint8 | euint8 | eint16 | euint16 | eint32 | euint32 | eintx | euintx);
    if (Has64Bits)
        type |= eint64 | euint64;
    if (!intxisuint8(lb) || !intxisuint8(ub))
        type &= ~euint8;
    if (!intxisuint16(lb) || !intxisuint16(ub))
        type &= ~euint16;
    if (!intxisuint32(lb) || !intxisuint32(ub))
        type &= ~euint32;
    if (!intxisuint64(lb) || !intxisuint64(ub))
        type &= ~euint64;
    if (!intxisint8(lb) || !intxisint8(ub))
        type &= ~eint8;
    if (!intxisint16(lb) || !intxisint16(ub))
        type &= ~eint16;
    if (!intxisint32(lb) || !intxisint32(ub))
        type &= ~eint32;
    if (!intxisint64(lb) || !intxisint64(ub))
        type &= ~eint64;
    if (lb->value[0] >= 0x7f || ub->value[0] >= 0x7f)
        type &= ~euintx;
    if (type & euint8) {
        *sign = 1;
        return "ASN1uint16_t"; // lonchanc: for av; original is "ASN1uint8_t";
    }
    if (type & eint8) {
        *sign = -1;
        return "ASN1int8_t";
    }
    if (type & euint16) {
        *sign = 1;
        return "ASN1uint16_t";
    }
    if (type & eint16) {
        *sign = -1;
        return "ASN1int16_t";
    }
    if (type & euint32) {
        *sign = 1;
        return "ASN1uint32_t";
    }
    if (type & eint32) {
        *sign = -1;
        return "ASN1int32_t";
    }
    if (type & euint64) {
        *sign = 1;
        return "ASN1uint64_t";
    }
    if (type & eint64) {
        *sign = -1;
        return "ASN1int64_t";
    }
    if (type & euintx) {
        *sign = 1;
        return "ASN1intx_t";
    }
    if (type & eintx) {
        *sign = -1;
        return "ASN1intx_t";
    }
    MyAbort();
    /*NOTREACHED*/
    return NULL;
}

/* adjust the lower and upper bound according to the value constraints in */
/* the constraints list */
void GetMinMax(AssignmentList_t ass, ValueConstraintList_t constraints,
    EndPoint_t *lower, EndPoint_t *upper)
{
    ValueConstraint_t *vc;
    EndPoint_t lo, up;

    for (vc = constraints; vc; vc = vc->Next) {
        lo = vc->Lower;
        up = vc->Upper;
        if (CmpLowerEndPoint(ass, lower, &lo) > 0)
            *lower = lo;
        if (CmpUpperEndPoint(ass, upper, &up) < 0)
            *upper = up;
    }
}

/* get the integer type and the sign of an integer with the given bounds */
char *GetIntType(AssignmentList_t ass, EndPoint_t *lower, EndPoint_t *upper, int32_t *sign)
{
    char *inttype;

    if (!(lower->Flags & eEndPoint_Min) &&
        !(upper->Flags & eEndPoint_Max)) {
        inttype = GetIType(&GetValue(ass, lower->Value)->U.Integer.Value,
            &GetValue(ass, upper->Value)->U.Integer.Value, sign);
    } else {
        if (!(lower->Flags & eEndPoint_Min) &&
            intx_cmp(&GetValue(ass, lower->Value)->U.Integer.Value, &intx_0) >= 0) {
            inttype = UIntegerRestriction;
            *sign = 1;
        } else {
            inttype = IntegerRestriction;
            *sign = -1;
        }
        if (!strncmp(inttype, "ASN1uint", 8))
            *sign = 1;
        else if (!strncmp(inttype, "ASN1int", 7))
            *sign = -1;
    }
    return inttype;
}

/* get the integer type and the sign of an integer type */
char *GetIntegerType(AssignmentList_t ass, Type_t *type, int32_t *sign)
{
    EndPoint_t lower, upper;

    if (type->PrivateDirectives.fIntx)
    {
        return "ASN1intx_t";
    }

    lower.Flags = eEndPoint_Max;
    upper.Flags = eEndPoint_Min;
    GetMinMax(ass, type->PERConstraints.Value.Root, &lower, &upper);
    if (type->PERConstraints.Value.Type == eExtension_Extended)
        GetMinMax(ass, type->PERConstraints.Value.Additional,
            &lower, &upper);
    if (lower.Flags & eEndPoint_Max)
        lower.Flags = eEndPoint_Min;
    if (upper.Flags & eEndPoint_Min)
        upper.Flags = eEndPoint_Max;
    return GetIntType(ass, &lower, &upper, sign);
}

/* get the real type */
/*ARGSUSED*/
char *GetRealType(Type_t *type)
{
    return RealRestriction;
}

/* get the boolean type */
char *GetBooleanType()
{
    return "ASN1bool_t";
}

/* get the enumerated type */
char *GetEnumeratedType(AssignmentList_t ass, Type_t *type, int32_t *sign)
{
#if 1 // added by Microsoft
    return "ASN1enum_t";
#else
    EndPoint_t lower, upper, ep;
    NamedNumber_t *namedNumbers;

    lower.Flags = eEndPoint_Max;
    upper.Flags = eEndPoint_Min;
    ep.Flags = 0;
    for (namedNumbers = type->U.Enumerated.NamedNumbers; namedNumbers;
        namedNumbers = namedNumbers->Next) {
        switch (namedNumbers->Type) {
        case eNamedNumber_Normal:
            ep.Value = namedNumbers->U.Normal.Value;
            if (CmpLowerEndPoint(ass, &lower, &ep) > 0)
                lower = ep;
            if (CmpUpperEndPoint(ass, &upper, &ep) < 0)
                upper = ep;
            break;
        case eNamedNumber_ExtensionMarker:
            break;
        }
    }
    if (lower.Flags & eEndPoint_Max)
        lower.Flags = eEndPoint_Min;
    if (upper.Flags & eEndPoint_Min)
        upper.Flags = eEndPoint_Max;
    return GetIntType(ass, &lower, &upper, sign);
#endif
}

/* get the type of an choice selector */
char *GetChoiceType(Type_t *type)
{
#if 1 // added by Microsoft
    return "ASN1choice_t";
#else
    uint32_t nchoice;
    Component_t *components;

    nchoice = 0;
    for (components = type->U.Choice.Components; components;
        components = components->Next) {
        switch (components->Type) {
        case eComponent_Normal:
            nchoice++;
            break;
        case eComponent_ExtensionMarker:
            nchoice++; /* one reserved value for unknown extensions */
            break;
        default:
            MyAbort();
        }
    }
    if (nchoice < 0x100)
        return "ASN1uint8_t";
    if (nchoice < 0x10000)
        return "ASN1uint16_t";
    return "ASN1uint32_t";
#endif
}

/* get the type of a string */
char *GetStringType(AssignmentList_t ass, Type_t *type, int32_t *noctets, uint32_t *zero)
{
    EndPoint_t lower, upper;
    uint32_t up;

    type = GetType(ass, type);
    *zero = type->PrivateDirectives.fLenPtr ? 0 : 1; // null terminator

    /* get the upper bound and zero flag of the type */
    switch (type->Type) {
    case eType_NumericString:
        up = 0x39;
        break;
    case eType_PrintableString:
        up = 0x7a;
        break;
    case eType_ISO646String:
    case eType_VisibleString:
        up = 0x7e;
        break;
    case eType_IA5String:
        up = 0x7f;
        // *zero = 0;
        break;
    case eType_UTF8String:
        up = 0xffff;
        break;
    case eType_BMPString:
        up = 0xffff;
        *zero = 0; // must be unbounded
        break;
    case eType_UniversalString:
        up = 0xffffffff;
        *zero = 0; // must be unbounded
        break;
    case eType_GeneralString:
    case eType_GraphicString:
        up = 0xff;
        break;
    case eType_TeletexString:
        up = 0xff;
        break;
    case eType_T61String:
        up = 0xff;
        break;
    case eType_VideotexString:
        up = 0xff;
        break;
    default:
        MyAbort();
        /*NOTREACHED*/
    }
    lower.Flags = eEndPoint_Max;
    upper.Flags = 0;
    upper.Value = NewValue(NULL, NewType(eType_RestrictedString));
    upper.Value->U.RestrictedString.Value.length = 1;
    upper.Value->U.RestrictedString.Value.value = &up;

    /* apply permitted alphabet constraints */
    if (type->PERConstraints.PermittedAlphabet.Type !=
        eExtension_Unconstrained) {
        GetMinMax(ass, type->PERConstraints.PermittedAlphabet.Root,
            &lower, &upper);
        if (type->PERConstraints.PermittedAlphabet.Type == eExtension_Extended)
            GetMinMax(ass, type->PERConstraints.PermittedAlphabet.Additional,
                &lower, &upper);
    }

    /* set zero flag if the resulting type rejects the 0-character */
    if (!(lower.Flags & eEndPoint_Max) &&
        *GetValue(ass, lower.Value)->U.RestrictedString.Value.value > 0)
        *zero = 1;

    /* get the number of octets needed for a character */
    *noctets = uint32_uoctets(
        *GetValue(ass, upper.Value)->U.RestrictedString.Value.value);

    /* if the type is marked as zero-terminated or length/value, use the */
    /* appropriate type */
    if (GetTypeRules(ass, type) & eTypeRules_ZeroTerminated)
        *zero = 1;
    else if (GetTypeRules(ass, type) & (eTypeRules_LengthPointer|eTypeRules_FixedArray))
        *zero = 0;

    /* return the correct type */
    if (*zero) {
        if (*noctets == 1)
        {
#ifdef ENABLE_CHAR_STR_SIZE
        if (g_eEncodingRule == eEncoding_Packed &&
            type->PERTypeInfo.Root.LConstraint == ePERSTIConstraint_Constrained)
        {
            return "ASN1char_t";
        }
        else
        {
                return "ASN1ztcharstring_t";
        }
#else
            return "ASN1ztcharstring_t";
#endif
        }
        if (*noctets == 2)
            return "ASN1ztchar16string_t";
        *noctets = 4;
        return "ASN1ztchar32string_t";
    } else {
        if (*noctets == 1)
            return "ASN1charstring_t";
        if (*noctets == 2)
            return "ASN1char16string_t";
        *noctets = 4;
        return "ASN1char32string_t";
    }
}

/* check if a type is a restricted string type */
int IsRestrictedString(Type_e type)
{
    return
        type == eType_NumericString ||
        type == eType_PrintableString ||
        type == eType_TeletexString ||
        type == eType_T61String ||
        type == eType_VideotexString ||
        type == eType_IA5String ||
        type == eType_GraphicString ||
        type == eType_VisibleString ||
        type == eType_ISO646String ||
        type == eType_GeneralString ||
        type == eType_UniversalString ||
        type == eType_BMPString ||
        type == eType_RestrictedString;
}

/* create a reference to a value */
char *Reference(char *p)
{
    char *q;

    if (*p == '*')
        return p + 1;
    q = (char *)malloc(strlen(p) + 2);
    *q = '&';
    strcpy(q + 1, p);
    return q;
}

/* create a dereference to a value */
char *Dereference(char *p)
{
    char *q;

    if (*p == '&')
        return p + 1;
    q = (char *)malloc(strlen(p) + 2);
    *q = '*';
    strcpy(q + 1, p);
    return q;
}

/* get the name of a type */
char *GetTypeName(AssignmentList_t ass, Type_t *t)
{
    Assignment_t *a;
    int32_t noctets;
    uint32_t zero;
    int32_t sign;
    char buf[256];
    char *p;

    switch (t->Type) {
    case eType_Boolean:
        return GetBooleanType();
    case eType_Integer:
        return GetIntegerType(ass, t, &sign);
    case eType_BitString:
        return "ASN1bitstring_t";
    case eType_OctetString:
        return "ASN1octetstring_t";
    case eType_UTF8String:
        return "ASN1wstring_t";
    case eType_Null:
        MyAbort();
        /*NOTREACHED*/
    case eType_ObjectIdentifier:
        if (t->PrivateDirectives.fOidPacked)
        {
            return "ASN1encodedOID_t";
        }
        return t->PrivateDirectives.fOidArray ? "ASN1objectidentifier2_t" : "ASN1objectidentifier_t";
    case eType_Real:
        return GetRealType(t);
    case eType_Enumerated:
        return GetEnumeratedType(ass, t, &sign);
    case eType_EmbeddedPdv:
        return "ASN1embeddedpdv_t";
    case eType_Sequence:
    case eType_SequenceOf:
    case eType_Set:
    case eType_SetOf:
    case eType_Choice:
    case eType_InstanceOf:
        MyAbort();
        /*NOTREACHED*/
    case eType_NumericString:
    case eType_PrintableString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GraphicString:
    case eType_GeneralString:
    case eType_IA5String:
    case eType_UniversalString:
    case eType_BMPString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_VideotexString:
        return GetStringType(ass, t, &noctets, &zero);
    case eType_UTCTime:
        return "ASN1utctime_t";
    case eType_GeneralizedTime:
        return "ASN1generalizedtime_t";
    case eType_ObjectDescriptor:
        return "ASN1objectdescriptor_t";
    case eType_External:
        return "ASN1external_t";
    case eType_CharacterString:
        return "ASN1characterstring_t";
        /*NOTREACHED*/
    case eType_Selection:
        MyAbort();
        /*NOTREACHED*/
    case eType_Reference:
        a = FindAssignment(ass, eAssignment_Type,
            t->U.Reference.Identifier, t->U.Reference.Module);
        return GetName(a);
    case eType_FieldReference:
        p = GetObjectClassName(ass, t->U.FieldReference.ObjectClass);
        sprintf(buf, "%s_%s", p, t->U.FieldReference.Identifier);
        return Identifier2C(buf);
    case eType_RestrictedString:
        MyAbort();
        /*NOTREACHED*/
    case eType_Open:
        return "ASN1open_t";
    case eType_Undefined:
        MyAbort();
        /*NOTREACHED*/
    }
	/*NOTREACHED*/
	return NULL;
}

/* get the name of a type */
char *PGetTypeName(AssignmentList_t ass, Type_t *t)
{
    Assignment_t *a;

    if (t->Type == eType_Reference)
    {
        a = FindAssignment(ass, eAssignment_Type,
                t->U.Reference.Identifier, t->U.Reference.Module);
        return IsPSetOfType(ass, a) ? PGetName(ass, a) : GetName(a);
    }
    return GetTypeName(ass, t);
}

/* get the name of a value */
char *GetValueName(AssignmentList_t ass, Value_t *value)
{
    Assignment_t *a;

    if (value->Type)
        MyAbort();
    a = FindAssignment(ass, eAssignment_Value,
        value->U.Reference.Identifier, value->U.Reference.Module);
    return GetName(a);
}

/* get the name of an object class */
char *GetObjectClassName(AssignmentList_t ass, ObjectClass_t *oc)
{
    Assignment_t *a;

    switch (oc->Type) {
    case eObjectClass_Reference:
        a = FindAssignment(ass, eAssignment_ObjectClass,
            oc->U.Reference.Identifier, oc->U.Reference.Module);
        return GetName(a);
    default:
        MyAbort();
        /*NOTREACHED*/
    }
    return NULL;
}

/* check if a type is of structured type */
int IsStructuredType(Type_t *type)
{
    switch (type->Type) {
    case eType_Sequence:
    case eType_SequenceOf:
    case eType_Set:
    case eType_SetOf:
    case eType_Choice:
    case eType_InstanceOf:
        return 1;
    default:
        return 0;
    }
}

/* check if a type is of sequence type */
int IsSequenceType(Type_t *type)
{
    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_Real:
    case eType_External:
    case eType_EmbeddedPdv:
    case eType_CharacterString:
    case eType_InstanceOf:
        return 1;
    default:
        return 0;
    }
}

/* check if a type is a reference type */
int IsReferenceType(Type_t *type)
{
    switch (type->Type) {
    case eType_Reference:
    case eType_FieldReference:
        return 1;
    default:
        return 0;
    }
}

/* get the tag of a type */
Tag_t *GetTag(AssignmentList_t ass, Type_t *type)
{
    Type_t *type2;
    for (;;) {
        if (type->Tags || !IsReferenceType(type))
            return type->Tags;
        type2 = GetReferencedType(ass, type);
        /*XXX self-referencing types will idle forever */
        if (type == type2)
        {
            ASSERT(0);
            return NULL;
        }
        type = type2;
    }
    /*NOTREACHED*/
}

/* get the number of octets of a C type */
int32_t GetOctets(char *inttype)
{
    if (!strcmp(inttype, "ASN1uint8_t"))
        return sizeof(ASN1uint8_t);
    if (!strcmp(inttype, "ASN1uint16_t"))
        return sizeof(ASN1uint16_t);
    if (!strcmp(inttype, "ASN1uint32_t"))
        return sizeof(ASN1uint32_t);
    if (!strcmp(inttype, "ASN1uint64_t"))
        return 8;
    if (!strcmp(inttype, "ASN1int8_t"))
        return sizeof(ASN1int8_t);
    if (!strcmp(inttype, "ASN1int16_t"))
        return sizeof(ASN1int16_t);
    if (!strcmp(inttype, "ASN1int32_t"))
        return sizeof(ASN1int32_t);
    if (!strcmp(inttype, "ASN1int64_t"))
        return 8;
    if (!strcmp(inttype, "ASN1intx_t"))
        return 0;
    if (!strcmp(inttype, "ASN1bool_t"))
        return sizeof(ASN1bool_t);
    if (!strcmp(inttype, "ASN1char_t"))
        return sizeof(ASN1char_t);
    if (!strcmp(inttype, "ASN1char16_t"))
        return sizeof(ASN1char16_t);
    if (!strcmp(inttype, "ASN1char32_t"))
        return sizeof(ASN1char32_t);
    if (!strcmp(inttype, "double"))
        return 8;
    if (!strcmp(inttype, "ASN1real_t"))
        return 0;
    // added by Microsoft
    if (!strcmp(inttype, "ASN1enum_t"))
        return sizeof(ASN1enum_t);
    if (!strcmp(inttype, "ASN1choice_t"))
        return sizeof(ASN1choice_t);
    MyAbort();
    /*NOTREACHED*/
    return 0;
}

/* compare two values; return 0 if equal */
int CmpValue(AssignmentList_t ass, Value_t *v1, Value_t *v2)
{
    uint32_t i;
    int32_t d;
    Type_e t1, t2;

    v1 = GetValue(ass, v1);
    v2 = GetValue(ass, v2);
    t1 = GetTypeType(ass, v1->Type);
    t2 = GetTypeType(ass, v2->Type);
    if (t1 == eType_Integer && t2 == eType_Integer) {
        return intx_cmp(&v1->U.Integer.Value, &v2->U.Integer.Value);
    }
    if (t1 == eType_ObjectIdentifier && t2 == eType_ObjectIdentifier) {
        d = v1->U.ObjectIdentifier.Value.length -
            v2->U.ObjectIdentifier.Value.length;
        if (d)
            return d;
        for (i = 0; i < v1->U.ObjectIdentifier.Value.length; i++) {
            d = v1->U.ObjectIdentifier.Value.value[i] -
                v2->U.ObjectIdentifier.Value.value[i];
            if (d)
                return d;
        }
        return 0;
    }
    if (IsRestrictedString(t1) && IsRestrictedString(t2)) {
        if (v1->U.RestrictedString.Value.length != 1 ||
            v2->U.RestrictedString.Value.length != 1)
            MyAbort();
        if (*v1->U.RestrictedString.Value.value <
            *v2->U.RestrictedString.Value.value)
            return -1;
        if (*v1->U.RestrictedString.Value.value >
            *v2->U.RestrictedString.Value.value)
            return 1;
        return 0;
    }
    MyAbort();
    /*NOTREACHED*/
    return 1; // not equal
}

/* substract two values (integer/character) */
int SubstractValues(AssignmentList_t ass, intx_t *diff, Value_t *v1, Value_t *v2)
{
    v1 = GetValue(ass, v1);
    v2 = GetValue(ass, v2);
    switch (GetTypeType(ass, v1->Type)) {
    case eType_Integer:
            intx_sub(diff, &v1->U.Integer.Value, &v2->U.Integer.Value);
        return 1;
    default:
            if (IsRestrictedString(GetTypeType(ass, v1->Type))) {
            if (v1->U.RestrictedString.Value.length != 1 ||
                v2->U.RestrictedString.Value.length != 1)
                return 0;
            intx_setuint32(diff, v2->U.RestrictedString.Value.value[0] -
                v1->U.RestrictedString.Value.value[0]);
            return 1;
        }
        break;
    }
    MyAbort();
    /*NOTREACHED*/
    return 0;
}

/* get the lower endpoint; adjust endpoint if the endpoint is "open" */
/* (means "not including the value") */
EndPoint_t *GetLowerEndPoint(AssignmentList_t ass, EndPoint_t *e)
{
    EndPoint_t *newe;
    Type_t *type;

    if ((e->Flags & eEndPoint_Min) || !(e->Flags & eEndPoint_Open))
        return e;
    type = GetType(ass, GetValue(ass, e->Value)->Type);
    switch (type->Type) {
    case eType_Integer:
        newe = NewEndPoint();
        newe->Value = NewValue(ass, type);
        intx_add(&newe->Value->U.Integer.Value, &e->Value->U.Integer.Value,
            &intx_1);
        return newe;
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_VideotexString:
    case eType_IA5String:
    case eType_GraphicString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GeneralString:
    case eType_UniversalString:
    case eType_BMPString:
    case eType_RestrictedString:
        newe = NewEndPoint();
        newe->Value = NewValue(ass, type);
        newe->Value->U.RestrictedString.Value.length = 1;
        newe->Value->U.RestrictedString.Value.value =
            (char32_t *)malloc(sizeof(char32_t));
        *newe->Value->U.RestrictedString.Value.value =
            *e->Value->U.RestrictedString.Value.value + 1;
        return newe;
    default:
        return e;
    }
}

/* get the upper endpoint; adjust endpoint if the endpoint is "open" */
/* (means "not including the value") */
EndPoint_t *GetUpperEndPoint(AssignmentList_t ass, EndPoint_t *e)
{
    EndPoint_t *newe;
    Type_t *type;

    if ((e->Flags & eEndPoint_Max) || !(e->Flags & eEndPoint_Open))
        return e;
    type = GetType(ass, GetValue(ass, e->Value)->Type);
    switch (type->Type) {
    case eType_Integer:
        newe = NewEndPoint();
        newe->Value = NewValue(ass, type);
        intx_sub(&newe->Value->U.Integer.Value, &e->Value->U.Integer.Value,
            &intx_1);
        return newe;
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_VideotexString:
    case eType_IA5String:
    case eType_GraphicString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GeneralString:
    case eType_UniversalString:
    case eType_BMPString:
    case eType_RestrictedString:
        newe = NewEndPoint();
        newe->Value = NewValue(ass, type);
        newe->Value->U.RestrictedString.Value.length = 1;
        newe->Value->U.RestrictedString.Value.value =
            (char32_t *)malloc(sizeof(char32_t));
        *newe->Value->U.RestrictedString.Value.value =
            *e->Value->U.RestrictedString.Value.value - 1;
        return newe;
    default:
        return e;
    }
}

/* compare two lower endpoints */
int CmpLowerEndPoint(AssignmentList_t ass, EndPoint_t *e1, EndPoint_t *e2)
{
    int ret;

    e1 = GetLowerEndPoint(ass, e1);
    e2 = GetLowerEndPoint(ass, e2);
    if (e1->Flags & eEndPoint_Min) {
            if (e2->Flags & eEndPoint_Min)
            return 0;
        return -1;
    } else if (e2->Flags & eEndPoint_Min) {
            return 1;
    } else if (e1->Flags & eEndPoint_Max) {
            if (e2->Flags & eEndPoint_Max)
            return 0;
        return 1;
    } else if (e2->Flags & eEndPoint_Max) {
            return -1;
    } else {
        ret = CmpValue(ass, e1->Value, e2->Value);
        if (ret != 0)
            return ret;
        if (e1->Flags & eEndPoint_Open) {
            if (e2->Flags & eEndPoint_Open)
                return 0;
            else
                return 1;
        } else {
            if (e2->Flags & eEndPoint_Open)
                return -1;
            else
                return 0;
        }
    }
}

/* compare two upper endpoints */
int CmpUpperEndPoint(AssignmentList_t ass, EndPoint_t *e1, EndPoint_t *e2)
{
    int ret;

    e1 = GetUpperEndPoint(ass, e1);
    e2 = GetUpperEndPoint(ass, e2);
    if (e1->Flags & eEndPoint_Min) {
            if (e2->Flags & eEndPoint_Min)
            return 0;
        return -1;
    } else if (e2->Flags & eEndPoint_Min) {
            return 1;
    } else if (e1->Flags & eEndPoint_Max) {
            if (e2->Flags & eEndPoint_Max)
            return 0;
        return 1;
    } else if (e2->Flags & eEndPoint_Max) {
            return -1;
    } else {
        ret = CmpValue(ass, e1->Value, e2->Value);
        if (ret != 0)
            return ret;
        if (e1->Flags & eEndPoint_Open) {
            if (e2->Flags & eEndPoint_Open)
                return 0;
            else
                return -1;
        } else {
            if (e2->Flags & eEndPoint_Open)
                return 1;
            else
                return 0;
        }
    }
}

/* compare a lower and an upper endpoints */
int CmpLowerUpperEndPoint(AssignmentList_t ass, EndPoint_t *e1, EndPoint_t *e2)
{
    int ret;

    e1 = GetLowerEndPoint(ass, e1);
    e2 = GetUpperEndPoint(ass, e2);
    if (e1->Flags & eEndPoint_Min) {
            if (e2->Flags & eEndPoint_Min)
            return 0;
        return -1;
    } else if (e2->Flags & eEndPoint_Min) {
            return 1;
    } else if (e1->Flags & eEndPoint_Max) {
            if (e2->Flags & eEndPoint_Max)
            return 0;
        return 1;
    } else if (e2->Flags & eEndPoint_Max) {
            return -1;
    } else {
        ret = CmpValue(ass, e1->Value, e2->Value);
        if (ret != 0)
            return ret;
        if ((e1->Flags & eEndPoint_Open) || (e2->Flags & eEndPoint_Open))
            return 1;
        else
            return 0;
    }
}

/* check whether two EndPoint_t's join together */
int CheckEndPointsJoin(AssignmentList_t ass, EndPoint_t *e1, EndPoint_t *e2)
{
    intx_t ix;
    Value_t *v1, *v2;

    /* check if endpoints overlap */
    if (CmpLowerUpperEndPoint(ass, e2, e1) <= 0)
        return 1;

    e1 = GetUpperEndPoint(ass, e1);
    e2 = GetLowerEndPoint(ass, e2);
    v1 = GetValue(ass, e1->Value);
    v2 = GetValue(ass, e2->Value);
    switch (GetTypeType(ass, v1->Type)) {
    case eType_Integer:
        /* check for subsequent integers */
            intx_dup(&ix, &v1->U.Integer.Value);
        intx_inc(&ix);
        return intx_cmp(&ix, &v2->U.Integer.Value) >= 0;
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_VideotexString:
    case eType_IA5String:
    case eType_GraphicString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GeneralString:
    case eType_UniversalString:
    case eType_BMPString:
    case eType_RestrictedString:
        /* reject multiple characters */
            if (v1->U.RestrictedString.Value.length != 1 ||
                v2->U.RestrictedString.Value.length != 1)
            MyAbort();

        /* beware of wrap around */
        if (v1->U.RestrictedString.Value.value[0] == 0xffffffff &&
            v2->U.RestrictedString.Value.value[0] == 0)
            return 0;

        /* check for subsequent characters */
        return v2->U.RestrictedString.Value.value[0] -
            v1->U.RestrictedString.Value.value[0] == 1;
    }
    MyAbort();
    /*NOTREACHED*/
    return 0;
}

/* compare two module identifiers; return 0 if equal */
int CmpModuleIdentifier(AssignmentList_t ass, ModuleIdentifier_t *mod1, ModuleIdentifier_t *mod2)
{
    if (mod1->ObjectIdentifier && mod2->ObjectIdentifier)
        return CmpValue(ass, mod1->ObjectIdentifier, mod2->ObjectIdentifier);
    if (mod1->Identifier && mod2->Identifier)
        return strcmp(mod1->Identifier, mod2->Identifier);
    return 0;
}

/* get the name of an assignment */
char *GetNameEx(AssignmentList_t ass, AssignmentList_t a, int fPSetOf)
{
    char *p;
    char *ide;
    char *mod;

    if (a->Type == eAssignment_Type &&
        a->U.Type.Type && a->U.Type.Type->PrivateDirectives.pszTypeName)
    {
        if (fPSetOf && IsPSetOfType(ass, a))
        {
            ide = PIdentifier2C(a->U.Type.Type->PrivateDirectives.pszTypeName);
        }
        else
        {
            ide = Identifier2C(a->U.Type.Type->PrivateDirectives.pszTypeName);
        }
    }
    else
    {
        if (fPSetOf && IsPSetOfType(ass, a))
        {
            ide = PIdentifier2C(a->Identifier);
        }
        else
        {
            ide = Identifier2C(a->Identifier);
        }
    }

// LONCHANC: disable the following code per MikeV.
    if (g_fLongNameForImported)
    {
        if (!(a->Flags & eAssignmentFlags_LongName))
            return ide;
        mod = Identifier2C(a->Module->Identifier);
        p = (char *)malloc(strlen(mod) + strlen(ide) + 2);
        sprintf(p, "%s_%s", mod, ide);
        return p;
    }
    else
    {
        return ide;
    }
}

/* get the name of an assignment */
char *GetName(AssignmentList_t a)
{
    return GetNameEx(NULL, a, 0);
}
char *PGetName(AssignmentList_t ass, AssignmentList_t a)
{
    return GetNameEx(ass, a, 1);
}

/* convert a 32 bit string into a generalized time */
int String2GeneralizedTime(generalizedtime_t *time, char32string_t *string)
{
    char str[64];
    unsigned i;

    if (string->length > 63 || string->length < 10)
        return 0;
    for (i = 0; i < string->length; i++)
        str[i] = (char)string->value[i];
    str[i] = 0;
    return string2generalizedtime(time, str);
}

/* convert a 32 bit string into an utc time */
int String2UTCTime(utctime_t *time, char32string_t *string)
{
    char str[64];
    unsigned i;

    if (string->length > 63 || string->length < 10)
        return 0;
    for (i = 0; i < string->length; i++)
        str[i] = (char)string->value[i];
    str[i] = 0;
    return string2utctime(time, str);
}

/* build an intersection of two constraints */
void IntersectConstraints(Constraint_t **ret, Constraint_t *c1, Constraint_t *c2)
{
    ElementSetSpec_t *e;

    if (!c2) {
        *ret = c1;
        return;
    }
    if (!c1) {
        *ret = c2;
        return;
    }
    *ret = NewConstraint();
    if (!c1->Root) {
        (*ret)->Root = c2->Root;
    } else if (!c2->Root) {
        (*ret)->Root = c1->Root;
    } else {
        (*ret)->Root = e = NewElementSetSpec(eElementSetSpec_Intersection);
        e->U.Intersection.Elements1 = c1->Root;
        e->U.Intersection.Elements2 = c2->Root;
    }
    if (c1->Type > c2->Type)
        (*ret)->Type = c1->Type;
    else
        (*ret)->Type = c2->Type;
    if ((*ret)->Type == eExtension_Extended) {
        if (c1->Type != eExtension_Extended || !c1->Additional) {
            (*ret)->Additional = c2->Additional;
        } else if (c2->Type != eExtension_Extended || !c2->Additional) {
            (*ret)->Additional = c1->Additional;
        } else {
            (*ret)->Additional = e =
                NewElementSetSpec(eElementSetSpec_Intersection);
            e->U.Intersection.Elements1 = c1->Additional;
            e->U.Intersection.Elements2 = c2->Additional;
        }
    }
}

/* find a field spec by name of an object class */
FieldSpec_t *GetObjectClassField(AssignmentList_t ass, ObjectClass_t *oc, char *field)
{
    oc = GetObjectClass(ass, oc);
    if (!oc)
        return NULL;
    return GetFieldSpec(ass, FindFieldSpec(oc->U.ObjectClass.FieldSpec, field));
}

/* find a field spec by name list of an object class */
FieldSpec_t *GetFieldSpecFromObjectClass(AssignmentList_t ass, ObjectClass_t *oc, StringList_t sl)
{
    FieldSpec_t *fs;

    for (; sl; sl = sl->Next) {
        fs = GetObjectClassField(ass, oc, sl->String);
        if (!fs)
            return NULL;
        if (!sl->Next)
            return fs;
        if (fs->Type == eFieldSpec_Object)
            oc = fs->U.Object.ObjectClass;
        else if (fs->Type == eFieldSpec_ObjectSet)
            oc = fs->U.ObjectSet.ObjectClass;
        else
            return NULL;
    }
    return NULL;
}

/* get the default setting of a field spec */
static Setting_t *GetDefaultSetting(FieldSpec_t *fs)
{
    Setting_t *ret = NULL;
    Optionality_t *op;

    switch (fs->Type) {
    case eFieldSpec_Type:
        op = fs->U.Type.Optionality;
        if (op && op->Type == eOptionality_Default_Type) {
            ret = NewSetting(eSetting_Type);
            ret->Identifier = fs->Identifier;
            ret->U.Type.Type = op->U.Type;
        }
        break;
    case eFieldSpec_FixedTypeValue:
        op = fs->U.FixedTypeValue.Optionality;
        if (op && op->Type == eOptionality_Default_Value) {
            ret = NewSetting(eSetting_Value);
            ret->Identifier = fs->Identifier;
            ret->U.Value.Value = op->U.Value;
        }
        break;
    case eFieldSpec_VariableTypeValue:
        op = fs->U.VariableTypeValue.Optionality;
        if (op && op->Type == eOptionality_Default_Value) {
            ret = NewSetting(eSetting_Value);
            ret->Identifier = fs->Identifier;
            ret->U.Value.Value = op->U.Value;
        }
        break;
    case eFieldSpec_FixedTypeValueSet:
        op = fs->U.FixedTypeValueSet.Optionality;
        if (op && op->Type == eOptionality_Default_ValueSet) {
            ret = NewSetting(eSetting_ValueSet);
            ret->Identifier = fs->Identifier;
            ret->U.ValueSet.ValueSet = op->U.ValueSet;
        }
        break;
    case eFieldSpec_VariableTypeValueSet:
        op = fs->U.VariableTypeValueSet.Optionality;
        if (op && op->Type == eOptionality_Default_ValueSet) {
            ret = NewSetting(eSetting_ValueSet);
            ret->Identifier = fs->Identifier;
            ret->U.ValueSet.ValueSet = op->U.ValueSet;
        }
        break;
    case eFieldSpec_Object:
        op = fs->U.Object.Optionality;
        if (op && op->Type == eOptionality_Default_Object) {
            ret = NewSetting(eSetting_Object);
            ret->Identifier = fs->Identifier;
            ret->U.Object.Object = op->U.Object;
        }
        break;
    case eFieldSpec_ObjectSet:
        op = fs->U.Object.Optionality;
        if (op && op->Type == eOptionality_Default_ObjectSet) {
            ret = NewSetting(eSetting_ObjectSet);
            ret->Identifier = fs->Identifier;
            ret->U.ObjectSet.ObjectSet = op->U.ObjectSet;
        }
        break;
    default:
        return NULL;
    }
    return ret;
}

Setting_t *GetSettingFromSettings(AssignmentList_t ass, SettingList_t se, StringList_t sl)
{
    Object_t *o;

    for (; sl; sl = sl->Next) {
        for (; se; se = se->Next) {
            if (!strcmp(se->Identifier, sl->String))
                break;
        }
        if (!se)
            return NULL;
        if (!sl->Next)
            return se;
        if (se->Type != eSetting_Object)
            return NULL;
        o = GetObject(ass, se->U.Object.Object);
        if (!o)
            return NULL;
        se = o->U.Object.Settings;
    }
    return NULL;
}

Setting_t *GetSettingFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    FieldSpec_t *fs;
    Setting_t *se;
    ObjectClass_t *oc;

    for (; sl; sl = sl->Next) {
        o = GetObject(ass, o);
        if (!o)
            return NULL;
        oc = GetObjectClass(ass, o->U.Object.ObjectClass);
        if (!oc)
            return NULL;
        fs = GetFieldSpec(ass,
            FindFieldSpec(oc->U.ObjectClass.FieldSpec, sl->String));
        if (!fs)
            return NULL;
        se = FindSetting(o->U.Object.Settings, sl->String);
        if (!se) {
            se = GetDefaultSetting(fs);
            if (!se)
                return NULL;
        }
        if (!sl->Next)
            return se;
        if (fs->Type == eFieldSpec_Object && se->Type == eSetting_Object) {
            o = se->U.Object.Object;
        } else {
            return NULL;
        }
    }
    return NULL;
}

ObjectClass_t *GetObjectClassFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elems)
{
    ObjectSetElement_t *ose;
    Object_t *o;
    ObjectSet_t *os;

    switch (elems->Type) {
    case eElementSetSpec_AllExcept:
        return GetObjectClassFromElementSetSpec(ass,
            elems->U.AllExcept.Elements);
    case eElementSetSpec_Union:
    case eElementSetSpec_Intersection:
    case eElementSetSpec_Exclusion:
        return GetObjectClassFromElementSetSpec(ass,
            elems->U.UIE.Elements1);
    case eElementSetSpec_SubtypeElement:
        MyAbort();
        /*NOTREACHED*/
    case eElementSetSpec_ObjectSetElement:
        ose = elems->U.ObjectSetElement.ObjectSetElement;
        switch (ose->Type) {
        case eObjectSetElement_Object:
            o = ose->U.Object.Object;
            o = GetObject(ass, o);
            if (!o)
                return NULL;
            return o->U.Object.ObjectClass;
        case eObjectSetElement_ObjectSet:
            os = ose->U.ObjectSet.ObjectSet;
            os = GetObjectSet(ass, os);
            if (!os)
                return NULL;
            return os->U.ObjectSet.ObjectClass;
        case eObjectSetElement_ElementSetSpec:
            return GetObjectClassFromElementSetSpec(ass,
                ose->U.ElementSetSpec.ElementSetSpec);
        } 
        /*NOTREACHED*/
    }
    /*NOTREACHED*/
	return NULL;
}

#if 0
Type_t *GetTypeFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elems)
{
    Type_t *ret;
    SubtypeElement_t *sub;
    Value_t *value;

    switch (elems->Type) {
    case eElementSetSpec_AllExcept:
        return GetTypeFromElementSetSpec(ass,
            elems->U.AllExcept.Elements);
    case eElementSetSpec_Union:
    case eElementSetSpec_Intersection:
    case eElementSetSpec_Exclusion:
        ret = GetTypeFromElementSetSpec(ass, elems->U.UIE.Elements1);
        if (ret)
            return ret;
        return GetTypeFromElementSetSpec(ass, elems->U.UIE.Elements2);
    case eElementSetSpec_SubtypeElement:
        sub = elems->U.SubtypeElement.SubtypeElement;
        switch (sub->Type) {
        case eSubtypeElement_Size:
        case eSubtypeElement_PermittedAlphabet:
        case eSubtypeElement_SingleType:
        case eSubtypeElement_FullSpecification:
        case eSubtypeElement_PartialSpecification:
            return NULL;
        case eSubtypeElement_Type:
            return Builtin_Type_Open;
        case eSubtypeElement_ContainedSubtype:
            return sub->U.ContainedSubtype.Type;
        case eSubtypeElement_SingleValue:
            value = GetValue(ass, sub->U.SingleValue.Value);
            return value->Type;
        case eSubtypeElement_ValueRange:
            if (!(sub->U.ValueRange.Lower.Flags & eEndPoint_Min)) {
                value = GetValue(ass, sub->U.ValueRange.Lower.Value);
                return value->Type;
            }
            if (!(sub->U.ValueRange.Upper.Flags & eEndPoint_Max)) {
                value = GetValue(ass, sub->U.ValueRange.Upper.Value);
                return value->Type;
            }
            return NULL;
        case eSubtypeElement_ElementSetSpec:
            return GetTypeFromElementSetSpec(ass,
                sub->U.ElementSetSpec.ElementSetSpec);
        } 
        /*NOTREACHED*/
    case eElementSetSpec_ObjectSetElement:
        MyAbort();
        /*NOTREACHED*/
    }
    /*NOTREACHED*/
}
#endif

Type_t *GetTypeOfValueSet(AssignmentList_t ass, ValueSet_t *vs)
{
    Type_t *ret;
    Constraint_t *c;

    if (!vs)
        return NULL;
    ret = DupType(vs->Type);
    c = NewConstraint();
    c->Type = eExtension_Unextended;
    c->Root = vs->Elements;
    IntersectConstraints(&ret->Constraints, vs->Type->Constraints, c);
    return ret;
}

Value_t *GetValueFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    Setting_t *se;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type != eSetting_Value)
        return NULL; /* error */
    return se->U.Value.Value;
}

ValueSet_t *GetValueSetFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    Setting_t *se;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type != eSetting_ValueSet)
        return NULL; /* error */
    return se->U.ValueSet.ValueSet;
}

Type_t *GetTypeFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    Setting_t *se;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type != eSetting_Type)
        return NULL; /* error */
    return se->U.Type.Type;
}

Object_t *GetObjectFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    Setting_t *se;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type != eSetting_Object)
        return NULL; /* error */
    return se->U.Object.Object;
}

ObjectSet_t *GetObjectSetFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    Setting_t *se;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type != eSetting_ObjectSet)
        return NULL; /* error */
    return se->U.ObjectSet.ObjectSet;
}

ElementSetSpec_t *ConvertElementSetSpecToElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elems, StringList_t sl, ElementSetSpec_t *(*fn)(AssignmentList_t ass, Object_t *o, StringList_t sl))
{
    ElementSetSpec_t *ret, *e1, *e2;
    ObjectSetElement_t *ose;

    ret = NULL;
    switch (elems->Type) {
    case eElementSetSpec_AllExcept:
        e1 = ConvertElementSetSpecToElementSetSpec(
            ass, elems->U.AllExcept.Elements, sl, fn);
        if (e1) {
            ret = NewElementSetSpec(elems->Type);
            ret->U.AllExcept.Elements = e1;
        }
        break;
    case eElementSetSpec_Union:
    case eElementSetSpec_Intersection:
    case eElementSetSpec_Exclusion:
        e1 = ConvertElementSetSpecToElementSetSpec(
            ass, elems->U.UIE.Elements1, sl, fn);
        e2 = ConvertElementSetSpecToElementSetSpec(
            ass, elems->U.UIE.Elements2, sl, fn);
        if (e1 && e2) {
            ret = NewElementSetSpec(elems->Type);
            ret->U.UIE.Elements1 = ConvertElementSetSpecToElementSetSpec(
                ass, elems->U.UIE.Elements1, sl, fn);
            ret->U.UIE.Elements2 = ConvertElementSetSpecToElementSetSpec(
                ass, elems->U.UIE.Elements2, sl, fn);
        } else if (e1) {
            ret = e1;
        } else if (e2) {
            if (elems->Type == eElementSetSpec_Exclusion) {
                ret = NewElementSetSpec(eElementSetSpec_AllExcept);
                ret->U.AllExcept.Elements = e2;
            } else {
                ret = e2;
            }
        }
        break;
    case eElementSetSpec_ObjectSetElement:
        ose = elems->U.ObjectSetElement.ObjectSetElement;
        switch (ose->Type) {
        case eObjectSetElement_Object:
            ret = fn(ass, ose->U.Object.Object, sl);
            break;
        case eObjectSetElement_ObjectSet:
            ret = ConvertObjectSetToElementSetSpec(ass,
                ose->U.ObjectSet.ObjectSet, sl, fn);
            break;
        case eObjectSetElement_ElementSetSpec:
            ret = ConvertElementSetSpecToElementSetSpec(ass,
                ose->U.ElementSetSpec.ElementSetSpec, sl, fn);
            break;
        }
        break;
    case eElementSetSpec_SubtypeElement:
        MyAbort();
        /*NOTREACHED*/
    }
    return ret;
}

ElementSetSpec_t *ConvertObjectSetToElementSetSpec(AssignmentList_t ass, ObjectSet_t *os, StringList_t sl, ElementSetSpec_t *(*fn)(AssignmentList_t ass, Object_t *o, StringList_t sl))
{
    os = GetObjectSet(ass, os);
    if (!os)
        return NULL;
    return ConvertElementSetSpecToElementSetSpec(ass,
        os->U.ObjectSet.Elements, sl, fn);
}

static ElementSetSpec_t *CbGetValueSetFromObjectSet(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    ElementSetSpec_t *ret;
    Setting_t *se;
    SubtypeElement_t *sub;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type == eSetting_Value) {
        sub = NewSubtypeElement(eSubtypeElement_SingleValue);
        sub->U.SingleValue.Value = se->U.Value.Value;
        ret = NewElementSetSpec(eElementSetSpec_SubtypeElement);
        ret->U.SubtypeElement.SubtypeElement = sub;
        return ret;
    } else if (se->Type == eSetting_ValueSet) {
        return se->U.ValueSet.ValueSet->Elements;
    } else {
        return NULL; /* error */
    }
}

ValueSet_t *GetValueSetFromObjectSet(AssignmentList_t ass, ObjectSet_t *os, StringList_t sl)
{
    ElementSetSpec_t *elems;
    ValueSet_t *ret;
    ObjectClass_t *oc;
    FieldSpec_t *fs;
    Type_t *type;

    os = GetObjectSet(ass, os);
    if (!os)
        return NULL;
    oc = os->U.ObjectSet.ObjectClass;
    fs = GetFieldSpecFromObjectClass(ass, oc, sl);
    if (!fs)
        return NULL;
    if (fs->Type == eFieldSpec_FixedTypeValue)
        type = fs->U.FixedTypeValue.Type;
    else if (fs->Type == eFieldSpec_FixedTypeValueSet)
        type = fs->U.FixedTypeValueSet.Type;
    else
        return NULL;
    elems = ConvertObjectSetToElementSetSpec(ass, os, sl,
        CbGetValueSetFromObjectSet);
    if (!elems)
        return NULL;
    ret = NewValueSet();
    ret->Elements = elems;
    ret->Type = type;
    return ret;
}

static ElementSetSpec_t *CbGetObjectSetFromObjectSet(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    ElementSetSpec_t *ret;
    Setting_t *se;
    ObjectSetElement_t *sub;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type == eSetting_Object) {
        sub = NewObjectSetElement(eObjectSetElement_Object);
        sub->U.Object.Object = se->U.Object.Object;
        ret = NewElementSetSpec(eElementSetSpec_ObjectSetElement);
        ret->U.ObjectSetElement.ObjectSetElement = sub;
        return ret;
    } else if (se->Type == eSetting_ObjectSet) {
        return se->U.ObjectSet.ObjectSet->U.ObjectSet.Elements;
    } else {
        return NULL; /* error */
    }
}

ObjectSet_t *GetObjectSetFromObjectSet(AssignmentList_t ass, ObjectSet_t *os, StringList_t sl)
{
    ElementSetSpec_t *elems;
    ObjectSet_t *ret;

    elems = ConvertObjectSetToElementSetSpec(ass, os, sl,
        CbGetObjectSetFromObjectSet);
    if (!elems)
        return NULL;
    ret = NewObjectSet(eObjectSet_ObjectSet);
    ret->U.ObjectSet.Elements = elems;
    ret->U.ObjectSet.ObjectClass = GetObjectClassFromElementSetSpec(ass, elems);
    return ret;
}

// The following is added by Microsoft

int IsPSetOfType(AssignmentList_t ass, Assignment_t *a)
{
    Type_t *t2 = a->U.Type.Type;
#if 0
    if (t2->Type == eType_Reference)
    {
        t2 = GetType(ass, t2);
    }
#endif
    return ((eType_SequenceOf == t2->Type || eType_SetOf == t2->Type)
            &&
            (t2->Rules & (eTypeRules_LinkedListMask | eTypeRules_PointerToElement))
            // (t2->PrivateDirectives.fSLinked)
           );
}


void MyAbort(void)
{
    ASSERT(0);
    abort();
}

void MyExit(int val)
{
    ASSERT(0);
    exit(val);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\yywrap.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

int yywrap()
{
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\write.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_WRITE_H_
#define _ASN1C_WRITE_H_

void setoutfile(FILE *);
/*PRINTFLIKE1*/
void output(const char *fmt, ...);
/*PRINTFLIKE1*/
void outputni(const char *fmt, ...);
void outputreal(const char *fmt, real_t *real);
void outputoctets(const char *name, uint32_t length, octet_t *val);
void outputuint32s(const char *name, uint32_t length, uint32_t *val);
void outputvalue0(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value);
void outputvalue1(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value);
void outputvalue2(AssignmentList_t ass, char *ideref, Value_t *value);
void outputvalue3(AssignmentList_t ass, char *ideref, char *valref, Value_t *value);
/*PRINTFLIKE1*/
void outputvar(const char *fmt, ...);
void outputvarintx(const char *fmt, intx_t *intx);
void outputvarreal(const char *fmt, real_t *real);
void outputvaroctets(const char *name, uint32_t length, octet_t *val);

#endif // _ASN1C_WRITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\authz.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    authz.c

Abstract:

   This module implements the user mode authorization APIs exported to the
   external world.

Author:

    Kedar Dubhashi - March 2000

Environment:

    User mode only.

Revision History:

    Created - March 2000

--*/

#include "pch.h"

#pragma hdrstop

#include <authzp.h>
#include <authzi.h>

BOOL
AuthzAccessCheck(
    IN     DWORD                              Flags,
    IN     AUTHZ_CLIENT_CONTEXT_HANDLE        hAuthzClientContext,
    IN     PAUTHZ_ACCESS_REQUEST              pRequest,
    IN     AUTHZ_AUDIT_EVENT_HANDLE           hAuditEvent OPTIONAL,
    IN     PSECURITY_DESCRIPTOR               pSecurityDescriptor,
    IN     PSECURITY_DESCRIPTOR               *OptionalSecurityDescriptorArray OPTIONAL,
    IN     DWORD                              OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY                pReply,
    OUT    PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE phAccessCheckResults             OPTIONAL
    )

/*++

Routine Description:

    This API decides what access bits may be granted to a client for a given set
    of security security descriptors. The pReply structure is used to return an
    array of granted access masks and error statuses. There is an option to
    cache the access masks that will always be granted. A handle to cached
    values is returned if the caller asks for caching.

Arguments:

    Flags - AUTHZ_ACCESS_CHECK_NO_DEEP_COPY_SD - do not deep copy the SD information into the caching
                                    handle.  Default behaviour is to perform a deep copy.

    hAuthzClientContext - Authz context representing the client.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    hAuditEvent - Object specific audit event will be passed in this handle.
        Non-null parameter is an automatic request for audit. 
        
    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primay security descriptor.

    pReply - Supplies a pointer to a reply structure used to return the results
        of access check as an array of (GrantedAccessMask, ErrorValue) pairs.
        The number of results to be returned in supplied by the caller in
        pResult->ResultListLength.

        Expected error values are:

          ERROR_SUCCESS - If all the access bits (not including MAXIMUM_ALLOWED)
            are granted and GrantedAccessMask is not zero.

          ERROR_PRIVILEGE_NOT_HELD - if the DesiredAccess includes
          ACCESS_SYSTEM_SECURITY and the client does not have SeSecurityPrivilege.

          ERROR_ACCESS_DENIED in each of the following cases -
            1. any of the bits asked for is not granted.
            2. MaximumAllowed bit it on and granted access is zero.
            3. DesiredAccess is 0.

    phAccessCheckResults - Supplies a pointer to return a handle to the cached results
        of access check. Non-null phAccessCheckResults is an implicit request to cache
        results of this access check call and will result in a MAXIMUM_ALLOWED
        check.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    BOOL                   b                    = TRUE;
    DWORD                  LocalTypeListLength  = 0;
    PIOBJECT_TYPE_LIST     LocalTypeList        = NULL;
    PIOBJECT_TYPE_LIST     LocalCachingTypeList = NULL;
    PAUTHZI_CLIENT_CONTEXT pCC                  = (PAUTHZI_CLIENT_CONTEXT) hAuthzClientContext;
    PAUTHZI_AUDIT_EVENT    pAuditEvent          = (PAUTHZI_AUDIT_EVENT) hAuditEvent;
    IOBJECT_TYPE_LIST      FixedTypeList        = {0};
    IOBJECT_TYPE_LIST      FixedCachingTypeList = {0};

    UNREFERENCED_PARAMETER(Flags);

#ifdef AUTHZ_PARAM_CHECK
    //
    // Verify that the arguments passed are valid.
    // Also, initialize the output parameters to default.
    //

    b = AuthzpVerifyAccessCheckArguments(
            pCC,
            pRequest,
            pSecurityDescriptor,
            OptionalSecurityDescriptorArray,
            OptionalSecurityDescriptorCount,
            pReply,
            phAccessCheckResults
            );

    if (!b)
    {
        return FALSE;
    }
#endif

    //
    // No client should be able to open an object by asking for zero access.
    // If desired access is 0 then return an error.
    //
    // Note: No audit is generated in this case.
    //

    if (0 == pRequest->DesiredAccess)
    {
        AuthzpFillReplyStructure(
            pReply,
            ERROR_ACCESS_DENIED,
            0
            );

        return TRUE;
    }

    //
    // Generic bits should be mapped to specific ones by the resource manager.
    //

    if (FLAG_ON(pRequest->DesiredAccess, (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL)))
    {
        SetLastError(ERROR_GENERIC_NOT_MAPPED);
        return FALSE;
    }

    //
    // In the simple case, there is no object type list. Fake one of length = 1
    // to represent the entire object.
    //

    if (0 == pRequest->ObjectTypeListLength)
    {
        LocalTypeList = &FixedTypeList;
        FixedTypeList.ParentIndex = -1;
        LocalTypeListLength = 1;

        //
        // If the caller has asked for caching, fake an object type list that'd
        // be used for computing static "always granted" access.
        //

        if (ARGUMENT_PRESENT(phAccessCheckResults))
        {
            RtlCopyMemory(
                &FixedCachingTypeList,
                &FixedTypeList,
                sizeof(IOBJECT_TYPE_LIST)
                );

            LocalCachingTypeList = &FixedCachingTypeList;
        }
    }
    else
    {
        //
        // Capture the object type list into an internal structure.
        //

        b = AuthzpCaptureObjectTypeList(
                pRequest->ObjectTypeList,
                pRequest->ObjectTypeListLength,
                &LocalTypeList,
                ARGUMENT_PRESENT(phAccessCheckResults) ? &LocalCachingTypeList : NULL
                );

        if (!b)
        {
            return FALSE;
        }

        LocalTypeListLength = pRequest->ObjectTypeListLength;
    }

    //
    // There are three cases when we have to perform a MaximumAllowed access
    // check and traverse the whole acl:
    //     1. RM has requested for caching.
    //     2. DesiredAccessMask has MAXIMUM_ALLOWED turned on.
    //     3. ObjectTypeList is present and pReply->ResultList has a length > 1
    //

    if (ARGUMENT_PRESENT(phAccessCheckResults)            ||
        FLAG_ON(pRequest->DesiredAccess, MAXIMUM_ALLOWED) ||
        (pReply->ResultListLength > 1))
    {
        b = AuthzpAccessCheckWithCaching(
                Flags,
                pCC,
                pRequest,
                pSecurityDescriptor,
                OptionalSecurityDescriptorArray,
                OptionalSecurityDescriptorCount,
                pReply,
                phAccessCheckResults,
                LocalTypeList,
                LocalCachingTypeList,
                LocalTypeListLength
                );
    }
    else
    {
        //
        // Perform a normal access check in the default case. Acl traversal may
        // be abandoned if any of the desired access bits are denied before they
        // are granted.
        //

        b = AuthzpNormalAccessCheckWithoutCaching(
                pCC,
                pRequest,
                pSecurityDescriptor,
                OptionalSecurityDescriptorArray,
                OptionalSecurityDescriptorCount,
                pReply,
                LocalTypeList,
                LocalTypeListLength
                );
    }

    if (!b) 
    {
        goto Cleanup;
    }

    //
    // Check if an audit needs to be generated if the RM has requested audit
    // generation by passing a non-null AuditEvent structure.
    //

    if (ARGUMENT_PRESENT(pAuditEvent))
    {
        b = AuthzpGenerateAudit(
                pCC,
                pRequest,
                pAuditEvent,
                pSecurityDescriptor,
                OptionalSecurityDescriptorArray,
                OptionalSecurityDescriptorCount,
                pReply,
                LocalTypeList
                );

        if (!b) 
        {
            goto Cleanup;
        }
    }

Cleanup:

    //
    // Clean up allocated memory.
    //

    if ((&FixedTypeList != LocalTypeList) && (AUTHZ_NON_NULL_PTR(LocalTypeList)))
    {
        AuthzpFree(LocalTypeList);
        AuthzpFreeNonNull(LocalCachingTypeList);
    }

    return b;
}


BOOL
AuthzCachedAccessCheck(
    IN DWORD                             Flags,
    IN AUTHZ_ACCESS_CHECK_RESULTS_HANDLE hAccessCheckResults,
    IN PAUTHZ_ACCESS_REQUEST             pRequest,
    IN AUTHZ_AUDIT_EVENT_HANDLE          hAuditEvent          OPTIONAL,
    IN OUT PAUTHZ_ACCESS_REPLY           pReply
    )

/*++

Routine Description:

    This API performs a fast access check based on a cached handle which holds
    the static granted bits evaluated at the time of a previously made
    AuthzAccessCheck call. The pReply structure is used to return an array of
    granted access masks and error statuses.

Assumptions:
    The client context pointer is stored in the hAccessCheckResults. The structure of
    the client context must be exactly the same as it was at the time the
    hAccessCheckResults was created. This restriction is for the following fields:
    Sids, RestrictedSids, Privileges.
    Pointers to the primary security descriptor and the optional security
    descriptor array are stored in the hAccessCheckResults at the time of handle
    creation. These must still be valid.

Arguments:

    Flags - TBD.
    
    hAccessCheckResults - Handle to the cached access check results.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    AuditEvent - Object specific audit info will be passed in this structure.
        Non-null parameter is an automatic request for audit. 

    pReply - Supplies a pointer to a reply structure used to return the results
        of access check as an array of (GrantedAccessMask, ErrorValue) pairs.
        The number of results to be returned in supplied by the caller in
        pResult->ResultListLength.

        Expected error values are:

          ERROR_SUCCESS - If all the access bits (not including MAXIMUM_ALLOWED)
            are granted and GrantedAccessMask is not zero.

          ERROR_PRIVILEGE_NOT_HELD - if the DesiredAccess includes
          ACCESS_SYSTEM_SECURITY and the client does not have SeSecurityPrivilege.

          ERROR_ACCESS_DENIED in each of the following cases -
            1. any of the bits asked for is not granted.
            2. MaximumAllowed bit it on and granted access is zero.
            3. DesiredAccess is 0.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD               i                   = 0;
    DWORD               LocalTypeListLength = 0;
    PIOBJECT_TYPE_LIST  LocalTypeList       = NULL;
    PAUTHZI_HANDLE      pAH                 = (PAUTHZI_HANDLE) hAccessCheckResults;
    BOOL                b                   = TRUE;
    PAUTHZI_AUDIT_EVENT pAuditEvent         = (PAUTHZI_AUDIT_EVENT) hAuditEvent;
    IOBJECT_TYPE_LIST   FixedTypeList       = {0};

    UNREFERENCED_PARAMETER(Flags);

#ifdef AUTHZ_PARAM_CHECK
    b = AuthzpVerifyCachedAccessCheckArguments(
            pAH,
            pRequest,
            pReply
            );

    if (!b)
    {
        return FALSE;
    }
#endif

    //
    // No client should be able to open an object by asking for zero access.
    // If desired access is 0 then return an error.
    //
    // Note: No audit is generated in this case.
    //

    if (0 == pRequest->DesiredAccess)
    {
        AuthzpFillReplyStructure(
            pReply,
            ERROR_ACCESS_DENIED,
            0
            );

        return TRUE;
    }

    //
    // Generic bits should be mapped to specific ones by the resource manager.
    //

    if (FLAG_ON(pRequest->DesiredAccess, (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL)))
    {
        SetLastError(ERROR_GENERIC_NOT_MAPPED);
        return FALSE;
    }

    //
    // Capture the object type list if one has been passed in or fake one with
    // just one element.
    //

    if (0 == pRequest->ObjectTypeListLength)
    {
        LocalTypeList = &FixedTypeList;
        LocalTypeListLength = 1;
        FixedTypeList.ParentIndex = -1;
    }
    else
    {
        b = AuthzpCaptureObjectTypeList(
                pRequest->ObjectTypeList,
                pRequest->ObjectTypeListLength,
                &LocalTypeList,
                NULL
                );

        if (!b)
        {
            return FALSE;
        }

        LocalTypeListLength = pRequest->ObjectTypeListLength;
    }

    //
    // If all the bits have already been granted then just copy the results and
    // skip access check.
    //

    if (!FLAG_ON(pRequest->DesiredAccess, ~pAH->GrantedAccessMask[i]))
    {
        AuthzpFillReplyStructure(
            pReply,
            ERROR_SUCCESS,
            pRequest->DesiredAccess
            );

        goto GenerateAudit;
    }

    //
    // The assumption is privileges can not be changed. Thus, if the client did
    // not have SecurityPrivilege previously then he does not have it now.
    //

    if (FLAG_ON(pRequest->DesiredAccess, ACCESS_SYSTEM_SECURITY))
    {
        AuthzpFillReplyStructure(
            pReply,
            ERROR_PRIVILEGE_NOT_HELD,
            0
            );

        goto GenerateAudit;
    }

    //
    // If all aces are simple aces then there's nothing to do. All access bits
    // are static.
    //

    if ((!FLAG_ON(pAH->Flags, AUTHZ_DYNAMIC_EVALUATION_PRESENT)) &&
        (!FLAG_ON(pRequest->DesiredAccess, MAXIMUM_ALLOWED)))
    {
        AuthzpFillReplyStructureFromCachedGrantedAccessMask(
            pReply,
            pRequest->DesiredAccess,
            pAH->GrantedAccessMask
            );

        goto GenerateAudit;
    }

    //
    // Get the access bits from the last static access check.
    //

    for (i = 0; i < LocalTypeListLength; i++)
    {
        LocalTypeList[i].CurrentGranted = pAH->GrantedAccessMask[i];
        LocalTypeList[i].Remaining = pRequest->DesiredAccess & ~pAH->GrantedAccessMask[i];
    }

    //
    // If there are no deny aces, then perform a quick access check evaluating
    // only the allow aces that are dynamic or have principal self sid in them.
    //

    if (!FLAG_ON(pAH->Flags, (AUTHZ_DENY_ACE_PRESENT | AUTHZ_DYNAMIC_DENY_ACE_PRESENT)))
    {
        if (FLAG_ON(pRequest->DesiredAccess, MAXIMUM_ALLOWED) ||
            (pReply->ResultListLength > 1))
        {
            b = AuthzpQuickMaximumAllowedAccessCheck(
                    pAH->pAuthzClientContext,
                    pAH,
                    pRequest,
                    pReply,
                    LocalTypeList,
                    LocalTypeListLength
                    );
        }
        else
        {
            b = AuthzpQuickNormalAccessCheck(
                    pAH->pAuthzClientContext,
                    pAH,
                    pRequest,
                    pReply,
                    LocalTypeList,
                    LocalTypeListLength
                    );
        }
    }
    else if (0 != pRequest->ObjectTypeListLength)
    {
        //
        // Now we have to evaluate the entire acl since there are deny aces
        // and the caller has asked for a result list.
        //

        b = AuthzpAccessCheckWithCaching(
                Flags,
                pAH->pAuthzClientContext,
                pRequest,
                pAH->pSecurityDescriptor,
                pAH->OptionalSecurityDescriptorArray,
                pAH->OptionalSecurityDescriptorCount,
                pReply,
                NULL,
                LocalTypeList,
                NULL,
                LocalTypeListLength
                );
    }
    else
    {
        //
        // There are deny aces in the acl but the caller has not asked for
        // entire resultlist. Preform a normal access check.
        //

        b = AuthzpNormalAccessCheckWithoutCaching(
                pAH->pAuthzClientContext,
                pRequest,
                pAH->pSecurityDescriptor,
                pAH->OptionalSecurityDescriptorArray,
                pAH->OptionalSecurityDescriptorCount,
                pReply,
                LocalTypeList,
                LocalTypeListLength
                );
    }

    if (!b) goto Cleanup;

    AuthzpFillReplyFromParameters(
        pRequest,
        pReply,
        LocalTypeList
        );

GenerateAudit:

    if (ARGUMENT_PRESENT(pAuditEvent))
    {
        b = AuthzpGenerateAudit(
                pAH->pAuthzClientContext,
                pRequest,
                pAuditEvent,
                pAH->pSecurityDescriptor,
                pAH->OptionalSecurityDescriptorArray,
                pAH->OptionalSecurityDescriptorCount,
                pReply,
                LocalTypeList
                );

        if (!b) goto Cleanup;
    }

Cleanup:

    if ((&FixedTypeList != LocalTypeList) && (AUTHZ_NON_NULL_PTR(LocalTypeList)))
    {
        AuthzpFree(LocalTypeList);
    }

    return b;
}


BOOL
AuthzOpenObjectAudit(
    IN DWORD                       Flags,
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext,
    IN PAUTHZ_ACCESS_REQUEST       pRequest,
    IN AUTHZ_AUDIT_EVENT_HANDLE    hAuditEvent,
    IN PSECURITY_DESCRIPTOR        pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR        *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD                       OptionalSecurityDescriptorCount,
    IN PAUTHZ_ACCESS_REPLY         pReply
    )

/*++

Routine Description

    This API examines the SACL in the passed security descriptor(s) and generates 
    any appropriate audits.  

Arguments

    Flags - TBD.
    
    hAuthzClientContext - Client context to perform the SACL evaluation against.
    
    pRequest - pointer to request structure.
    
    hAuditEvent - Handle to the audit that may be generated.
    
    pSecurityDescriptor - Pointer to a security descriptor.
    
    OptionalSecurityDescriptorArray - Optional array of security descriptors.
    
    OptionalSecurityDescriptorCount - Size of optional security descriptor array.
    
    pReply - Pointer to the reply structure.

Return Value

    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().
--*/

{
    BOOL                   b                   = TRUE;
    DWORD                  LocalTypeListLength = 0;
    PIOBJECT_TYPE_LIST     LocalTypeList       = NULL;
    PAUTHZI_CLIENT_CONTEXT pCC                 = (PAUTHZI_CLIENT_CONTEXT) hAuthzClientContext;
    PAUTHZI_AUDIT_EVENT    pAuditEvent         = (PAUTHZI_AUDIT_EVENT) hAuditEvent;
    IOBJECT_TYPE_LIST      FixedTypeList       = {0};

    UNREFERENCED_PARAMETER(Flags);

    //
    // Verify that the arguments passed are valid.
    //
    
    b = AuthzpVerifyOpenObjectArguments(
            pCC,
            pSecurityDescriptor,
            OptionalSecurityDescriptorArray,
            OptionalSecurityDescriptorCount,
            pAuditEvent
            );

    if (!b)
    {
        return FALSE;
    }

    //
    // In the simple case, there is no object type list. Fake one of length = 1
    // to represent the entire object.
    //
    
    if (0 == pRequest->ObjectTypeListLength)
    {
        LocalTypeList = &FixedTypeList;
        FixedTypeList.ParentIndex = -1;
        LocalTypeListLength = 1;
    }
    else
    {
        //
        // Capture the object type list into an internal structure.
        //

        b = AuthzpCaptureObjectTypeList(
                pRequest->ObjectTypeList,
                pRequest->ObjectTypeListLength,
                &LocalTypeList,
                NULL
                );

        if (!b)
        {
            goto Cleanup;
        }

        LocalTypeListLength = pRequest->ObjectTypeListLength;
    }

    b = AuthzpGenerateAudit(
            pCC,
            pRequest,
            pAuditEvent,
            pSecurityDescriptor,
            OptionalSecurityDescriptorArray,
            OptionalSecurityDescriptorCount,
            pReply,
            LocalTypeList
            );

    if (!b)
    {
        goto Cleanup;
    }

Cleanup:

    //
    // Clean up allocated memory.
    //

    if (&FixedTypeList != LocalTypeList)
    {
        AuthzpFreeNonNull(LocalTypeList);
    }

    return b;
}


BOOL
AuthzFreeHandle(
    IN OUT AUTHZ_ACCESS_CHECK_RESULTS_HANDLE hAccessCheckResults
    )

/*++

Routine Description:

    This API finds and deletes the input handle from the handle list.

Arguments:

    hAcc - Handle to be freed.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PAUTHZI_HANDLE pAH      = (PAUTHZI_HANDLE) hAccessCheckResults;
    PAUTHZI_HANDLE pCurrent = NULL;
    PAUTHZI_HANDLE pPrev    = NULL;
    BOOL           b        = TRUE;
    
    //
    // Validate parameters.
    //

    if (!ARGUMENT_PRESENT(pAH) ||
        !AUTHZ_NON_NULL_PTR(pAH->pAuthzClientContext) ||
        !AUTHZ_NON_NULL_PTR(pAH->pAuthzClientContext->AuthzHandleHead))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    AuthzpAcquireClientCacheWriteLock(pAH->pAuthzClientContext);

    pCurrent = pAH->pAuthzClientContext->AuthzHandleHead;

    //
    // Check if the handle is at the beginning of the list.
    //

    if (pCurrent == pAH)
    {
        pAH->pAuthzClientContext->AuthzHandleHead = pAH->pAuthzClientContext->AuthzHandleHead->next;
    }
    else
    {
        //
        // The handle is not the head of the list. Loop thru the list to find
        // it.
        //

        pPrev = pCurrent;
        pCurrent = pCurrent->next;

        for (; AUTHZ_NON_NULL_PTR(pCurrent); pPrev = pCurrent, pCurrent = pCurrent->next)
        {
            if (pCurrent == pAH)
            {
                pPrev->next = pCurrent->next;
                break;
            }
        }

        //
        // The caller has sent us an invalid handle.
        //

        if (!AUTHZ_NON_NULL_PTR(pCurrent))
        {
            b = FALSE;
            SetLastError(ERROR_INVALID_PARAMETER);
        }
    }

    AuthzpReleaseClientCacheLock(pCC);

    //
    // Free the handle node.
    //

    if (b)
    {    
        AuthzpFree(pAH);
    }

    return b;
}


BOOL
AuthzInitializeResourceManager(
    IN  DWORD                            Flags,
    IN  PFN_AUTHZ_DYNAMIC_ACCESS_CHECK   pfnDynamicAccessCheck   OPTIONAL,
    IN  PFN_AUTHZ_COMPUTE_DYNAMIC_GROUPS pfnComputeDynamicGroups OPTIONAL,
    IN  PFN_AUTHZ_FREE_DYNAMIC_GROUPS    pfnFreeDynamicGroups    OPTIONAL,
    IN  PCWSTR                           szResourceManagerName,
    OUT PAUTHZ_RESOURCE_MANAGER_HANDLE   phAuthzResourceManager
    )

/*++

Routine Description:

    This API allocates and initializes a resource manager structure.

Arguments:
    
    Flags - AUTHZ_RM_FLAG_NO_AUDIT - use if the RM will never generate an audit to
        save some cycles.
    
    pfnAccessCheck - Pointer to the RM supplied access check function to be
    called when a callback ace is encountered by the access check algorithm.

    pfnComputeDynamicGroups - Pointer to the RM supplied function to compute
    groups to be added to the client context at the time of its creation.

    pfnFreeDynamicGroups - Pointer to the function to free the memory allocated
    by the pfnComputeDynamicGroups function.

    szResourceManagerName - the name of the resource manager.
    
    pAuthzResourceManager - To return the resource manager handle. The returned
    handle must be freed using AuthzFreeResourceManager.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PAUTHZI_RESOURCE_MANAGER pRM    = NULL;
    BOOL                     b      = TRUE;
    ULONG                    len    = 0;

    if (!ARGUMENT_PRESENT(phAuthzResourceManager) ||
        (Flags & ~AUTHZ_VALID_RM_INIT_FLAGS))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *phAuthzResourceManager = NULL;

    if (AUTHZ_NON_NULL_PTR(szResourceManagerName))
    {
        len = (ULONG) wcslen(szResourceManagerName) + 1;
    }
   
    pRM = (PAUTHZI_RESOURCE_MANAGER)
              AuthzpAlloc(sizeof(AUTHZI_RESOURCE_MANAGER) + sizeof(WCHAR) * len);

    if (AUTHZ_ALLOCATION_FAILED(pRM))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    //
    // Use the default pessimistic function if none has been specified.
    //

    if (AUTHZ_NON_NULL_PTR(pfnDynamicAccessCheck))
    {
        pRM->pfnDynamicAccessCheck = pfnDynamicAccessCheck;
    }
    else
    {
        pRM->pfnDynamicAccessCheck = &AuthzpDefaultAccessCheck;
    }

    if (!FLAG_ON(Flags, AUTHZ_RM_FLAG_NO_AUDIT))
    {
        
        //
        // Initialize the generic audit queue and generic audit events.
        //

        b = AuthziInitializeAuditQueue(
                AUTHZ_MONITOR_AUDIT_QUEUE_SIZE,
                1000,
                100,
                NULL,
                &pRM->hAuditQueue
                );

        if (!b)
        {
            goto Cleanup;
        }

        //
        // Initialize the generic audit event.
        //

        b = AuthziInitializeAuditEventType(
                AUTHZP_DEFAULT_RM_EVENTS | AUTHZP_INIT_GENERIC_AUDIT_EVENT,
                0,
                0,
                0,
                &pRM->hAET
                );

        if (!b)
        {
            goto Cleanup;
        }

        b = AuthziInitializeAuditEventType(
                AUTHZP_DEFAULT_RM_EVENTS,
                SE_CATEGID_DS_ACCESS,
                SE_AUDITID_OBJECT_OPERATION,
                9,
                &pRM->hAETDS
                );

        if (!b)
        {
            goto Cleanup;
        }
    }

    pRM->pfnComputeDynamicGroups        = pfnComputeDynamicGroups;
    pRM->pfnFreeDynamicGroups           = pfnFreeDynamicGroups;
    pRM->Flags                          = Flags;
    pRM->pUserSID                       = NULL;
    pRM->szResourceManagerName          = (PWSTR)((PUCHAR)pRM + sizeof(AUTHZI_RESOURCE_MANAGER));
    
    b = AuthzpGetProcessTokenInfo(
            &pRM->pUserSID,
            &pRM->AuthID
            );

    if (!b)
    {
        goto Cleanup;
    }

    if (0 != len)
    {    
        RtlCopyMemory(
            pRM->szResourceManagerName,
            szResourceManagerName,
            sizeof(WCHAR) * len
            );
    }
    else 
    {
        pRM->szResourceManagerName = NULL;
    }

    *phAuthzResourceManager = (AUTHZ_RESOURCE_MANAGER_HANDLE) pRM;

Cleanup:

    if (!b)
    {
        //
        // Copy LastError value, since the calls to AuthziFreeAuditEventType can succeed and 
        // overwrite it with 0x103 (STATUS_PENDING).
        //

        DWORD dwError = GetLastError();

        if (NULL != pRM)
        {
            if (!FLAG_ON(Flags, AUTHZ_RM_FLAG_NO_AUDIT))
            {
                AuthziFreeAuditQueue(pRM->hAuditQueue);
                AuthziFreeAuditEventType(pRM->hAET);
                AuthziFreeAuditEventType(pRM->hAETDS);
            }
            AuthzpFreeNonNull(pRM->pUserSID);
            AuthzpFree(pRM);
        }
        
        SetLastError(dwError);
    }

    return b;
}


BOOL
AuthzFreeResourceManager(
    IN OUT AUTHZ_RESOURCE_MANAGER_HANDLE hAuthzResourceManager
    )

/*++

Routine Description:

    This API frees up a resource manager.  If the default queue is in use, this call will wait for that
    queue to empty.
    
Arguments:

    hAuthzResourceManager - Handle to the resource manager object to be freed.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PAUTHZI_RESOURCE_MANAGER pRM = (PAUTHZI_RESOURCE_MANAGER) hAuthzResourceManager;
    BOOL                     b   = TRUE;
    
    if (!ARGUMENT_PRESENT(pRM))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!FLAG_ON(pRM->Flags, AUTHZ_RM_FLAG_NO_AUDIT))
    {
        (VOID) AuthziFreeAuditQueue(pRM->hAuditQueue);

        b = AuthziFreeAuditEventType(pRM->hAET);
        ASSERT(b == TRUE && L"Freeing pAEI didn't work.\n");

        b = AuthziFreeAuditEventType(pRM->hAETDS);
        ASSERT(b == TRUE && L"Freeing pAEIDS didn't work.\n");
    }

    AuthzpFreeNonNull(pRM->pUserSID);
    AuthzpFree(pRM);
    return TRUE;
}


BOOL
AuthzInitializeContextFromToken(
    IN  DWORD                         Flags,
    IN  HANDLE                        TokenHandle,
    IN  AUTHZ_RESOURCE_MANAGER_HANDLE hAuthzResourceManager,
    IN  PLARGE_INTEGER                pExpirationTime        OPTIONAL,
    IN  LUID                          Identifier,
    IN  PVOID                         DynamicGroupArgs,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE  phAuthzClientContext
    )

/*++

Routine Description:

    Initialize the authz context from the handle to the kernel token. The token
    must have been opened for TOKEN_QUERY.

Arguments:

    Flags - None

    TokenHandle - Handle to the client token from which the authz context will
    be initialized. The token must have been opened with TOKEN_QUERY access.

    AuthzResourceManager - The resource manager handle creating this client
    context. This will be stored in the client context structure.

    pExpirationTime - To set for how long the returned context structure is
    valid. If no value is passed then the token never expires.
    Expiration time is not currently enforced in the system.

    Identifier - Resource manager manager specific identifier. This is never
    interpreted by Authz.

    DynamicGroupArgs - To be passed to the callback function that computes
    dynamic groups

    pAuthzClientContext - To return a handle to the AuthzClientContext

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    UCHAR Buffer[AUTHZ_MAX_STACK_BUFFER_SIZE];

    NTSTATUS                     Status               = STATUS_SUCCESS;
    PUCHAR                       pBuffer              = (PVOID) Buffer;
    BOOL                         b                    = TRUE;
    BOOL                         bAllocatedSids       = FALSE;
    BOOL                         bLockHeld            = FALSE;
    PTOKEN_GROUPS_AND_PRIVILEGES pTokenInfo           = NULL;
    PAUTHZI_RESOURCE_MANAGER     pRM                  = NULL;
    PAUTHZI_CLIENT_CONTEXT       pCC                  = NULL;
    DWORD                        Length               = 0;
    LARGE_INTEGER                ExpirationTime       = {0, 0};

    UNREFERENCED_PARAMETER(Flags);

    if (!ARGUMENT_PRESENT(TokenHandle)           ||
        !ARGUMENT_PRESENT(hAuthzResourceManager) ||
        !ARGUMENT_PRESENT(phAuthzClientContext))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *phAuthzClientContext = NULL;

    //
    // Query the token information into user mode buffer. A local stack buffer
    // is used in the first call hoping that it would be sufficient to hold
    // the return values.
    //

    Status = NtQueryInformationToken(
                 TokenHandle,
                 TokenGroupsAndPrivileges,
                 pBuffer,
                 AUTHZ_MAX_STACK_BUFFER_SIZE,
                 &Length
                 );

    if (STATUS_BUFFER_TOO_SMALL == Status)
    {
        pBuffer = (PVOID) AuthzpAlloc(Length);

        if (AUTHZ_ALLOCATION_FAILED(pBuffer))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        Status = NtQueryInformationToken(
                     TokenHandle,
                     TokenGroupsAndPrivileges,
                     pBuffer,
                     Length,
                     &Length
                     );
    }

    if (!NT_SUCCESS(Status))
    {

#ifdef AUTHZ_DEBUG
        wprintf(L"\nNtQueryInformationToken failed with %d\n", Status);
#endif

        SetLastError(RtlNtStatusToDosError(Status));
        b = FALSE;
        goto Cleanup;
    }

    pTokenInfo = (PTOKEN_GROUPS_AND_PRIVILEGES) pBuffer;

    pRM = (PAUTHZI_RESOURCE_MANAGER) hAuthzResourceManager;

    if (ARGUMENT_PRESENT(pExpirationTime))
    {
        ExpirationTime = *pExpirationTime;
    }

    //
    // Initialize the client context. The callee allocates memory for the client
    // context structure.
    //

    b = AuthzpAllocateAndInitializeClientContext(
            &pCC,
            NULL,
            AUTHZ_CURRENT_CONTEXT_REVISION,
            Identifier,
            ExpirationTime,
            0,
            pTokenInfo->SidCount,
            pTokenInfo->SidLength,
            pTokenInfo->Sids,
            pTokenInfo->RestrictedSidCount,
            pTokenInfo->RestrictedSidLength,
            pTokenInfo->RestrictedSids,
            pTokenInfo->PrivilegeCount,
            pTokenInfo->PrivilegeLength,
            pTokenInfo->Privileges,
            pTokenInfo->AuthenticationId,
            NULL,
            pRM
            );

    if (!b)
    {
        goto Cleanup;
    }

    AuthzpAcquireClientContextReadLock(pCC);

    bLockHeld = TRUE;

    //
    // Add dynamic sids to the token.
    //

    b = AuthzpAddDynamicSidsToToken(
            pCC,
            pRM,
            DynamicGroupArgs,
            pTokenInfo->Sids,
            pTokenInfo->SidLength,
            pTokenInfo->SidCount,
            pTokenInfo->RestrictedSids,
            pTokenInfo->RestrictedSidLength,
            pTokenInfo->RestrictedSidCount,
            pTokenInfo->Privileges,
            pTokenInfo->PrivilegeLength,
            pTokenInfo->PrivilegeCount,
            FALSE
            );

    if (!b) 
    {
        goto Cleanup;
    }

    bAllocatedSids = TRUE;
    *phAuthzClientContext = (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC;

    AuthzPrintContext(pCC);
    
    //
    // initialize the sid hash for regular sids
    //

    AuthzpInitSidHash(
        pCC->Sids,
        pCC->SidCount,
        pCC->SidHash
        );

    //
    // initialize the sid hash for restricted sids
    //

    AuthzpInitSidHash(
        pCC->RestrictedSids,
        pCC->RestrictedSidCount,
        pCC->RestrictedSidHash
        );

Cleanup:

    if ((PVOID) Buffer != pBuffer)
    {
        AuthzpFreeNonNull(pBuffer);
    }

    if (!b)
    {
        DWORD dwSavedError = GetLastError();
        
        if (AUTHZ_NON_NULL_PTR(pCC))
        {
            if (bAllocatedSids)
            {
                AuthzFreeContext((AUTHZ_CLIENT_CONTEXT_HANDLE)pCC);
                SetLastError(dwSavedError);
            }
            else
            {
                AuthzpFree(pCC);
            }
        }
    }

    if (bLockHeld)
    {
        AuthzpReleaseClientContextLock(pCC);
    }

    return b;
}



BOOL
AuthzInitializeContextFromSid(
    IN  DWORD                         Flags,
    IN  PSID                          UserSid,
    IN  AUTHZ_RESOURCE_MANAGER_HANDLE hAuthzResourceManager,
    IN  PLARGE_INTEGER                pExpirationTime        OPTIONAL,
    IN  LUID                          Identifier,
    IN  PVOID                         DynamicGroupArgs,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE  phAuthzClientContext
    )

/*++

Routine Description:

    This API takes a user sid and creates a user mode client context from it.
    It fetches the TokenGroups attributes from the AD in case of domain sids.
    The machine local groups are computed on the ServerName specified. The
    resource manager may dynamic groups using callback mechanism.

Arguments:

    Flags -
      AUTHZ_SKIP_TOKEN_GROUPS -  Do not token groups if this is on.

    UserSid - The sid of the user for whom a client context will be created.

    ServerName - The machine on which local groups should be computed. A NULL
    server name defaults to the local machine.

    AuthzResourceManager - The resource manager handle creating this client
    context. This will be stored in the client context structure.

    pExpirationTime - To set for how long the returned context structure is
    valid. If no value is passed then the token never expires.
    Expiration time is not currently enforced in the system.

    Identifier - Resource manager manager specific identifier. This is never
    interpreted by Authz.

    DynamicGroupArgs - To be passed to the callback function that computes
    dynamic groups

    pAuthzClientContext - To return a handle to the AuthzClientContext
    structure. The returned handle must be freed using AuthzFreeContext.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PSID_AND_ATTRIBUTES      pSidAttr         = NULL;
    PAUTHZI_CLIENT_CONTEXT   pCC              = NULL;
    BOOL                     b                = FALSE;
    DWORD                    SidCount         = 0;
    DWORD                    SidLength        = 0;
    LARGE_INTEGER            ExpirationTime   = {0, 0};
    LUID                     NullLuid         = {0, 0};
    PAUTHZI_RESOURCE_MANAGER pRM              = (PAUTHZI_RESOURCE_MANAGER) hAuthzResourceManager;

    if (!ARGUMENT_PRESENT(UserSid)               ||
        !ARGUMENT_PRESENT(hAuthzResourceManager) ||
        !ARGUMENT_PRESENT(phAuthzClientContext))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *phAuthzClientContext = NULL;

    //
    // Compute the token groups and the machine local groups. These will be
    // returned in memory allocated by the callee.
    //

    b = AuthzpGetAllGroupsBySid(
            UserSid,
            Flags,
            &pSidAttr,
            &SidCount,
            &SidLength
            );

    if (!b) 
    {
        goto Cleanup;
    }

    if (ARGUMENT_PRESENT(pExpirationTime))
    {
        ExpirationTime = *pExpirationTime;
    }

    //
    // Initialize the client context. The callee allocates memory for the client
    // context structure.
    //

    b = AuthzpAllocateAndInitializeClientContext(
            &pCC,
            NULL,
            AUTHZ_CURRENT_CONTEXT_REVISION,
            Identifier,
            ExpirationTime,
            0,
            SidCount,
            SidLength,
            pSidAttr,
            0,
            0,
            NULL,
            0,
            0,
            NULL,
            NullLuid,
            NULL,
            pRM
            );

    if (!b) goto Cleanup;

    //
    // Add dynamic sids to the token.
    //

    b = AuthzpAddDynamicSidsToToken(
            pCC,
            pRM,
            DynamicGroupArgs,
            pSidAttr,
            SidLength,
            SidCount,
            NULL,
            0,
            0,
            NULL,
            0,
            0,
            TRUE
            );

    if (!b) goto Cleanup;

    *phAuthzClientContext = (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC;

    AuthzPrintContext(pCC);
    
    //
    // initialize the sid hash for regular sids
    //

    AuthzpInitSidHash(
        pCC->Sids,
        pCC->SidCount,
        pCC->SidHash
        );

    //
    // initialize the sid hash for restricted sids
    //

    AuthzpInitSidHash(
        pCC->RestrictedSids,
        pCC->RestrictedSidCount,
        pCC->RestrictedSidHash
        );

Cleanup:

    if (!b)
    {
        AuthzpFreeNonNull(pSidAttr);
        if (AUTHZ_NON_NULL_PTR(pCC))
        {
            if (pSidAttr != pCC->Sids)
            {
                AuthzpFreeNonNull(pCC->Sids);
            }

            AuthzpFreeNonNull(pCC->RestrictedSids);
            AuthzpFree(pCC);
        }
    }
    else
    {
        if (pSidAttr != pCC->Sids)
        {
            AuthzpFree(pSidAttr);
        }
    }

    return b;
}


BOOL
AuthzInitializeContextFromAuthzContext(
    IN  DWORD                        Flags,
    IN  AUTHZ_CLIENT_CONTEXT_HANDLE  hAuthzClientContext,
    IN  PLARGE_INTEGER               pExpirationTime         OPTIONAL,
    IN  LUID                         Identifier,
    IN  PVOID                        DynamicGroupArgs,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE phNewAuthzClientContext
    )

/*++

Routine Description:

    This API creates an AUTHZ_CLIENT_CONTEXT based on another AUTHZ_CLIENT_CONTEXT.

Arguments:

    Flags - TBD

    hAuthzClientContext - Client context to duplicate

    pExpirationTime - To set for how long the returned context structure is
    valid. If no value is passed then the token never expires.
    Expiration time is not currently enforced in the system.

    Identifier - Resource manager manager specific identifier.

    DynamicGroupArgs - To be passed to the callback function that computes
    dynamic groups.  If NULL then callback not called.

    phNewAuthzClientContext - Duplicate of context.  Must be freed using AuthzFreeContext.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PAUTHZI_CLIENT_CONTEXT pCC                = (PAUTHZI_CLIENT_CONTEXT) hAuthzClientContext;
    PAUTHZI_CLIENT_CONTEXT pNewCC             = NULL;
    PAUTHZI_CLIENT_CONTEXT pServer            = NULL;
    BOOL                   b                  = FALSE;
    BOOL                   bAllocatedSids     = FALSE;
    LARGE_INTEGER          ExpirationTime     = {0, 0};


    if (!ARGUMENT_PRESENT(phNewAuthzClientContext) ||
        !ARGUMENT_PRESENT(hAuthzClientContext))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    *phNewAuthzClientContext = NULL;

    //
    // Determine the ExpirationTime of the new context.
    //

    if (ARGUMENT_PRESENT(pExpirationTime))
    {
        ExpirationTime = *pExpirationTime;
    }
    
    AuthzpAcquireClientContextReadLock(pCC);

    if (AUTHZ_NON_NULL_PTR(pCC->Server))
    {
       b = AuthzInitializeContextFromAuthzContext(
               0,
               (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC->Server,
               NULL,
               pCC->Server->Identifier,
               NULL,
               (PAUTHZ_CLIENT_CONTEXT_HANDLE) &pServer
               );

       if (!b)
       {
           goto Cleanup;
       }
    }

    //
    // Now initialize the new context.
    //

    b = AuthzpAllocateAndInitializeClientContext(
            &pNewCC,
            pServer,
            pCC->Revision,
            Identifier,
            ExpirationTime,
            Flags,
            pCC->SidCount,
            pCC->SidLength,
            pCC->Sids,
            pCC->RestrictedSidCount,
            pCC->RestrictedSidLength,
            pCC->RestrictedSids,
            pCC->PrivilegeCount,
            pCC->PrivilegeLength,
            pCC->Privileges,
            pCC->AuthenticationId,
            NULL,
            pCC->pResourceManager
            );

    if (!b)
    {
        goto Cleanup;
    }

    b = AuthzpAddDynamicSidsToToken(
            pNewCC,
            pNewCC->pResourceManager,
            DynamicGroupArgs,
            pNewCC->Sids,
            pNewCC->SidLength,
            pNewCC->SidCount,
            pNewCC->RestrictedSids,
            pNewCC->RestrictedSidLength,
            pNewCC->RestrictedSidCount,
            pNewCC->Privileges,
            pNewCC->PrivilegeLength,
            pNewCC->PrivilegeCount,
            FALSE
            );

    if (!b)
    {
        goto Cleanup;
    }

    bAllocatedSids = TRUE;
    *phNewAuthzClientContext = (AUTHZ_CLIENT_CONTEXT_HANDLE) pNewCC;

#ifdef AUTHZ_DEBUG
    wprintf(L"ContextFromAuthzContext: Original Context:\n");
    AuthzPrintContext(pCC);
    wprintf(L"ContextFromAuthzContext: New Context:\n");
    AuthzPrintContext(pNewCC);
#endif

    //
    // initialize the sid hash for regular sids
    //

    AuthzpInitSidHash(
        pNewCC->Sids,
        pNewCC->SidCount,
        pNewCC->SidHash
        );

    //
    // initialize the sid hash for restricted sids
    //

    AuthzpInitSidHash(
        pNewCC->RestrictedSids,
        pNewCC->RestrictedSidCount,
        pNewCC->RestrictedSidHash
        );

Cleanup:

    if (!b)
    {
        DWORD dwSavedError = GetLastError();

        if (AUTHZ_NON_NULL_PTR(pNewCC))
        {
            if (bAllocatedSids)
            {
                AuthzFreeContext((AUTHZ_CLIENT_CONTEXT_HANDLE)pNewCC);
            }
            else
            {
                AuthzpFree(pNewCC);
            }
        }
        else
        {
            if (AUTHZ_NON_NULL_PTR(pServer))
            {
                AuthzFreeContext((AUTHZ_CLIENT_CONTEXT_HANDLE)pServer);
            }
        }
        SetLastError(dwSavedError);
    }

    AuthzpReleaseClientContextLock(pCC);

    return b;
}


BOOL
AuthzAddSidsToContext(
    IN  AUTHZ_CLIENT_CONTEXT_HANDLE  hAuthzClientContext,
    IN  PSID_AND_ATTRIBUTES          Sids                    OPTIONAL,
    IN  DWORD                        SidCount,
    IN  PSID_AND_ATTRIBUTES          RestrictedSids          OPTIONAL,
    IN  DWORD                        RestrictedSidCount,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE phNewAuthzClientContext
    )

/*++

Routine Description:

    This API creates a new context given a set of sids as well as restricted sids
    and an already existing context.  The original is unchanged.

Arguments:

    hAuthzClientContext - Client context to which the given sids will be added

    Sids - Sids and attributes to be added to the normal part of the client
    context

    SidCount - Number of sids to be added

    RestrictedSids - Sids and attributes to be added to the restricted part of
    the client context

    RestrictedSidCount - Number of restricted sids to be added

    phNewAuthzClientContext - The new context with the additional sids.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD                  i                   = 0;
    DWORD                  SidLength           = 0;
    DWORD                  RestrictedSidLength = 0;
    PSID_AND_ATTRIBUTES    pSidAttr            = NULL;
    PSID_AND_ATTRIBUTES    pRestrictedSidAttr  = NULL;
    BOOL                   b                   = TRUE;
    PAUTHZI_CLIENT_CONTEXT pCC                 = (PAUTHZI_CLIENT_CONTEXT) hAuthzClientContext;
    PAUTHZI_CLIENT_CONTEXT pNewCC              = NULL;
    PAUTHZI_CLIENT_CONTEXT pServer             = NULL;
    PLUID_AND_ATTRIBUTES   pPrivileges         = NULL;

    if ((!ARGUMENT_PRESENT(phNewAuthzClientContext)) ||
        (!ARGUMENT_PRESENT(hAuthzClientContext))     ||
        (0 != SidCount && !ARGUMENT_PRESENT(Sids))   ||
        (0 != RestrictedSidCount && !ARGUMENT_PRESENT(RestrictedSids)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *phNewAuthzClientContext = NULL;

    AuthzpAcquireClientContextReadLock(pCC);

    //
    // Recursively duplicate the server
    //

    if (AUTHZ_NON_NULL_PTR(pCC->Server))
    {

        b = AuthzInitializeContextFromAuthzContext(
                0,
                (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC->Server,
                NULL,
                pCC->Server->Identifier,
                NULL,
                (PAUTHZ_CLIENT_CONTEXT_HANDLE) &pServer
                );

       if (!b)
       {
           goto Cleanup;
       }
    }

    //
    // Duplicate the context, and do all further work on the duplicate.
    //

    b = AuthzpAllocateAndInitializeClientContext(
            &pNewCC,
            pServer,
            pCC->Revision,
            pCC->Identifier,
            pCC->ExpirationTime,
            pCC->Flags,
            0,
            0,
            NULL,
            0,
            0,
            NULL,
            0,
            0,
            NULL,
            pCC->AuthenticationId,
            NULL,
            pCC->pResourceManager
            );

    if (!b)
    {
        goto Cleanup;
    }

    SidLength = sizeof(SID_AND_ATTRIBUTES) * SidCount;

    //
    // Compute the length required to hold the new sids.
    //

    for (i = 0; i < SidCount; i++)
    {
#ifdef AUTHZ_PARAM_CHECK
        if (FLAG_ON(Sids[i].Attributes, ~AUTHZ_VALID_SID_ATTRIBUTES) ||
            !FLAG_ON(Sids[i].Attributes, AUTHZ_VALID_SID_ATTRIBUTES))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            b = FALSE;
            goto Cleanup;
        }

        if (!RtlValidSid(Sids[i].Sid))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            b = FALSE;
            goto Cleanup;
        }
#endif
        SidLength += RtlLengthSid(Sids[i].Sid);
    }

    RestrictedSidLength = sizeof(SID_AND_ATTRIBUTES) * RestrictedSidCount;

    //
    // Compute the length required to hold the new restricted sids.
    //

    for (i = 0; i < RestrictedSidCount; i++)
    {
#ifdef AUTHZ_PARAM_CHECK
        if (FLAG_ON(RestrictedSids[i].Attributes, ~AUTHZ_VALID_SID_ATTRIBUTES) ||
            !FLAG_ON(RestrictedSids[i].Attributes, AUTHZ_VALID_SID_ATTRIBUTES))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            b = FALSE;
            goto Cleanup;
        }

        if (!RtlValidSid(RestrictedSids[i].Sid))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            b = FALSE;
            goto Cleanup;
        }
#endif
        RestrictedSidLength += RtlLengthSid(RestrictedSids[i].Sid);
    }

    //
    // Copy the existing sids and the new ones into the allocated memory.
    //

    SidLength += pCC->SidLength;

    if (0 != SidLength)
    {

        pSidAttr = (PSID_AND_ATTRIBUTES) AuthzpAlloc(SidLength);

        if (AUTHZ_ALLOCATION_FAILED(pSidAttr))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            b = FALSE;
            goto Cleanup;
        }

        b = AuthzpCopySidsAndAttributes(
                pSidAttr,
                pCC->Sids,
                pCC->SidCount,
                Sids,
                SidCount
                );

        if (!b)
        {
            goto Cleanup;
        }

    }

    //
    // Copy the existing restricted sids and the new ones into the allocated
    // memory.
    //

    RestrictedSidLength += pCC->RestrictedSidLength;

    if (0 != RestrictedSidLength)
    {

        pRestrictedSidAttr = (PSID_AND_ATTRIBUTES) AuthzpAlloc(RestrictedSidLength);

        if (AUTHZ_ALLOCATION_FAILED(pRestrictedSidAttr))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            b = FALSE;
            goto Cleanup;
        }

        b = AuthzpCopySidsAndAttributes(
                pRestrictedSidAttr,
                pCC->RestrictedSids,
                pCC->RestrictedSidCount,
                RestrictedSids,
                RestrictedSidCount
                );

        if (!b)
        {
            goto Cleanup;
        }
    }

    //
    // Copy the existing privileges into the allocated memory.
    //

    pPrivileges = (PLUID_AND_ATTRIBUTES) AuthzpAlloc(pCC->PrivilegeLength);

    if (AUTHZ_ALLOCATION_FAILED(pPrivileges))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        b = FALSE;
        goto Cleanup;
    }

    AuthzpCopyLuidAndAttributes(
        pNewCC,
        pCC->Privileges,
        pCC->PrivilegeCount,
        pPrivileges
        );

    //
    // Update fields in the client context.
    //

    pNewCC->Sids = pSidAttr;
    pNewCC->SidLength = SidLength;
    pNewCC->SidCount = SidCount + pCC->SidCount;
    pSidAttr = NULL;

    pNewCC->RestrictedSids = pRestrictedSidAttr;
    pNewCC->RestrictedSidLength = RestrictedSidLength;
    pNewCC->RestrictedSidCount = RestrictedSidCount + pCC->RestrictedSidCount;
    pRestrictedSidAttr = NULL;

    pNewCC->Privileges = pPrivileges;
    pNewCC->PrivilegeCount = pCC->PrivilegeCount;
    pNewCC->PrivilegeLength = pCC->PrivilegeLength;
    pPrivileges = NULL;

    *phNewAuthzClientContext = (AUTHZ_CLIENT_CONTEXT_HANDLE) pNewCC;

#ifdef AUTHZ_DEBUG
    wprintf(L"AddSids: Original Context:\n");
    AuthzPrintContext(pCC);
    wprintf(L"AddSids: New Context:\n");
    AuthzPrintContext(pNewCC);
#endif

    //
    // initialize the sid hash for regular sids
    //

    AuthzpInitSidHash(
        pNewCC->Sids,
        pNewCC->SidCount,
        pNewCC->SidHash
        );

    //
    // initialize the sid hash for restricted sids
    //

    AuthzpInitSidHash(
        pNewCC->RestrictedSids,
        pNewCC->RestrictedSidCount,
        pNewCC->RestrictedSidHash
        );

Cleanup:

    AuthzpReleaseClientContextLock(pCC);

    //
    // These statements are relevant in the failure case.
    // In the success case, the pointers are set to NULL.
    //

    if (!b)
    {
        DWORD dwSavedError = GetLastError();
        
        AuthzpFreeNonNull(pSidAttr);
        AuthzpFreeNonNull(pRestrictedSidAttr);
        AuthzpFreeNonNull(pPrivileges);
        if (AUTHZ_NON_NULL_PTR(pNewCC))
        {
            AuthzFreeContext((AUTHZ_CLIENT_CONTEXT_HANDLE)pNewCC);
        }
        SetLastError(dwSavedError);
    }
    return b;
}


BOOL
AuthzGetInformationFromContext(
    IN  AUTHZ_CLIENT_CONTEXT_HANDLE     hAuthzClientContext,
    IN  AUTHZ_CONTEXT_INFORMATION_CLASS InfoClass,
    IN  DWORD                           BufferSize,
    OUT PDWORD                          pSizeRequired,
    OUT PVOID                           Buffer
    )

/*++

Routine Description:

    This API returns information about the client context in a buffer supplied
    by the caller. It also returns the size of the buffer required to hold the
    requested information.

Arguments:

    AuthzClientContext - Authz client context from which requested information
    will be read.

    InfoClass - Type of information to be returned. The caller can ask for
            a. privileges
                   TOKEN_PRIVILEGES
            b. sids and their attributes
                   TOKEN_GROUPS
            c. restricted sids and their attributes
                   TOKEN_GROUPS
            d. authz context persistent structure which can be saved to and
               read from the disk.
                   PVOID
            e. User sid
                   TOKEN_USER
            f. Server Context one level higher
                   PAUTHZ_CLIENT_CONTEXT
            g. Expiration time
                   LARGE_INTEGER
            h. Identifier
                   LUID

     BufferSize - Size of the supplied buffer.

     pSizeRequired - To return the size of the structure needed to hold the results.

     Buffer - To hold the information requested. The structure returned will
     depend on the information class requested.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD                  LocalSize = 0;
    PAUTHZI_CLIENT_CONTEXT pCC       = (PAUTHZI_CLIENT_CONTEXT) hAuthzClientContext;

    if (!ARGUMENT_PRESENT(hAuthzClientContext)         ||
        (!ARGUMENT_PRESENT(Buffer) && BufferSize != 0) ||
        !ARGUMENT_PRESENT(pSizeRequired))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *pSizeRequired = 0;

    switch(InfoClass)
    {
    case AuthzContextInfoUserSid:

        LocalSize = RtlLengthSid(pCC->Sids[0].Sid) + sizeof(TOKEN_USER);

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        //
        // xor SE_GROUP_ENABLED from the User attributes.  Authz sets this because it simplifies
        // access check logic.
        //

        ((PTOKEN_USER)Buffer)->User.Attributes = pCC->Sids[0].Attributes ^ SE_GROUP_ENABLED;
        ((PTOKEN_USER)Buffer)->User.Sid        = ((PUCHAR) Buffer) + sizeof(TOKEN_USER);

        RtlCopyMemory(
            ((PTOKEN_USER)Buffer)->User.Sid,
            pCC->Sids[0].Sid,
            RtlLengthSid(pCC->Sids[0].Sid)
            );

        return TRUE;

    case AuthzContextInfoGroupsSids:

        LocalSize = pCC->SidLength +
                    sizeof(TOKEN_GROUPS) -
                    RtlLengthSid(pCC->Sids[0].Sid) -
                    2 * sizeof(SID_AND_ATTRIBUTES);

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        ((PTOKEN_GROUPS) Buffer)->GroupCount = pCC->SidCount - 1;

        return AuthzpCopySidsAndAttributes(
                   ((PTOKEN_GROUPS) Buffer)->Groups,
                   pCC->Sids + 1,
                   pCC->SidCount - 1,
                   NULL,
                   0
                   );

    case AuthzContextInfoRestrictedSids:

        LocalSize = pCC->RestrictedSidLength + 
                    sizeof(TOKEN_GROUPS) -
                    sizeof(SID_AND_ATTRIBUTES);

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        ((PTOKEN_GROUPS) Buffer)->GroupCount = pCC->RestrictedSidCount;

        return AuthzpCopySidsAndAttributes(
                   ((PTOKEN_GROUPS) Buffer)->Groups,
                   pCC->RestrictedSids,
                   pCC->RestrictedSidCount,
                   NULL,
                   0
                   );

    case AuthzContextInfoPrivileges:

        LocalSize = pCC->PrivilegeLength + 
                    sizeof(TOKEN_PRIVILEGES) - 
                    sizeof(LUID_AND_ATTRIBUTES);

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        ((PTOKEN_PRIVILEGES) Buffer)->PrivilegeCount = pCC->PrivilegeCount;

        memcpy(
            ((PTOKEN_PRIVILEGES) Buffer)->Privileges,
            pCC->Privileges,
            pCC->PrivilegeLength
            );

        return TRUE;

    case AuthzContextInfoExpirationTime:

        LocalSize = sizeof(LARGE_INTEGER);

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        *((PLARGE_INTEGER) Buffer) = pCC->ExpirationTime;

        return TRUE;

    case AuthzContextInfoIdentifier:

        LocalSize = sizeof(LUID);

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        *((PLUID) Buffer) = pCC->Identifier;

        return TRUE;

    case AuthzContextInfoServerContext:

        LocalSize = sizeof(AUTHZ_CLIENT_CONTEXT_HANDLE);

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        *((PAUTHZ_CLIENT_CONTEXT_HANDLE) Buffer) = (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC->Server;

        return TRUE;

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
}


BOOL
AuthzFreeContext(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext
    )

/*++

Routine Description:

    This API frees up all the structures/memory accociated with the client
    context. Note that the list of handles for this client will be freed in
    this call.

Arguments:

    AuthzClientContext - Context to be freed.

Return Value:

    A value of TRUE is returned if the API is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PAUTHZI_CLIENT_CONTEXT pCC      = (PAUTHZI_CLIENT_CONTEXT) hAuthzClientContext;
    BOOL                   b        = TRUE;
    PAUTHZI_HANDLE         pCurrent = NULL;
    PAUTHZI_HANDLE         pPrev    = NULL;

    if (!ARGUMENT_PRESENT(pCC))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    AuthzpAcquireClientContextWriteLock(pCC);

    AuthzpFreeNonNull(pCC->Privileges);
    AuthzpFreeNonNull(pCC->Sids);
    AuthzpFreeNonNull(pCC->RestrictedSids);

    pCurrent = pCC->AuthzHandleHead;

    //
    // Loop thru all the handles and free them up.
    //

    while (AUTHZ_NON_NULL_PTR(pCurrent))
    {
        pPrev = pCurrent;
        pCurrent = pCurrent->next;
        AuthzpFree(pPrev);
    }

    //
    // Free up the server context. The context is a recursive structure.
    //

    if (AUTHZ_NON_NULL_PTR(pCC->Server))
    {
        b = AuthzFreeContext((AUTHZ_CLIENT_CONTEXT_HANDLE) pCC->Server);
    }

    AuthzpFree(pCC);

    return b;
}

AUTHZAPI
BOOL
WINAPI
AuthzInitializeObjectAccessAuditEvent(
    IN  DWORD                         Flags,
    IN  AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType,
    IN  PWSTR                         szOperationType,
    IN  PWSTR                         szObjectType,
    IN  PWSTR                         szObjectName,
    IN  PWSTR                         szAdditionalInfo,
    OUT PAUTHZ_AUDIT_EVENT_HANDLE     phAuditEvent,
    IN  DWORD                         dwAdditionalParameterCount,
    ...
    )

/*++

Routine Description:

    Allocates and initializes an AUTHZ_AUDIT_EVENT_HANDLE for use with AuthzAccessCheck.  
    The handle is used for storing information for audit generation.  
    
Arguments:

    Flags - Audit flags.  Currently defined bits are:
        AUTHZ_NO_SUCCESS_AUDIT - disables generation of success audits
        AUTHZ_NO_FAILURE_AUDIT - disables generation of failure audits
        AUTHZ_NO_ALLOC_STRINGS - storage space is not allocated for the 4 wide character strings.  Rather,
            the handle will only hold pointers to resource manager memory.
    
    hAuditEventType - for future use.  Should be NULL.
    
    szOperationType - Resource manager defined string that indicates the operation being
        performed that is to be audited.

    szObjectType - Resource manager defined string that indicates the type of object being
        accessed.

    szObjectName - the name of the specific object being accessed.
    
    szAdditionalInfo - Resource Manager defined string for additional audit information.

    phAuditEvent - pointer to AUTHZ_AUDIT_EVENT_HANDLE.  Space for this is allocated in the function.
    
    dwAdditionalParameterCount - Must be zero.
    
Return Value:

    Returns TRUE if successful, FALSE if unsuccessful.  
    Extended information available with GetLastError().    
    
--*/

{
    PAUTHZI_AUDIT_EVENT pAuditEvent            = NULL;
    BOOL                b                      = TRUE;
    DWORD               dwStringSize           = 0;
    DWORD               dwObjectTypeLength     = 0;
    DWORD               dwObjectNameLength     = 0;
    DWORD               dwOperationTypeLength  = 0;
    DWORD               dwAdditionalInfoLength = 0;

    if ((!ARGUMENT_PRESENT(phAuditEvent))     ||
        (NULL != hAuditEventType)             ||
        (0 != dwAdditionalParameterCount)     ||
        (!ARGUMENT_PRESENT(szOperationType))  ||
        (!ARGUMENT_PRESENT(szObjectType))     ||
        (!ARGUMENT_PRESENT(szObjectName))     ||
        (!ARGUMENT_PRESENT(szAdditionalInfo)) ||
        (Flags & (~(AUTHZ_VALID_OBJECT_ACCESS_AUDIT_FLAGS | AUTHZ_DS_CATEGORY_FLAG))))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *phAuditEvent = NULL;
    
    //
    // Allocate and initialize a new AUTHZI_AUDIT_EVENT.  Include for the string in the contiguous memory, if
    // needed.
    //

    if (FLAG_ON(Flags, AUTHZ_NO_ALLOC_STRINGS))
    {
        dwStringSize = 0;
    } 
    else
    {
        dwOperationTypeLength  = (DWORD) wcslen(szOperationType) + 1;
        dwObjectTypeLength     = (DWORD) wcslen(szObjectType) + 1;
        dwObjectNameLength     = (DWORD) wcslen(szObjectName) + 1;
        dwAdditionalInfoLength = (DWORD) wcslen(szAdditionalInfo) + 1;

        dwStringSize = sizeof(WCHAR) * (dwOperationTypeLength + dwObjectTypeLength + dwObjectNameLength + dwAdditionalInfoLength);
    }

    pAuditEvent = (PAUTHZI_AUDIT_EVENT) AuthzpAlloc(sizeof(AUTHZI_AUDIT_EVENT) + dwStringSize);

    if (AUTHZ_ALLOCATION_FAILED(pAuditEvent))
    {
        b = FALSE;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Cleanup;
    }

    if (FLAG_ON(Flags, AUTHZ_NO_ALLOC_STRINGS))
    {
        pAuditEvent->szOperationType  = szOperationType;
        pAuditEvent->szObjectType     = szObjectType;
        pAuditEvent->szObjectName     = szObjectName;
        pAuditEvent->szAdditionalInfo = szAdditionalInfo;
    }
    else
    {
        //
        // Set the string pointers into the contiguous memory.
        //

        pAuditEvent->szOperationType = (PWSTR)((PUCHAR)pAuditEvent + sizeof(AUTHZI_AUDIT_EVENT));
        
        RtlCopyMemory(
            pAuditEvent->szOperationType,
            szOperationType,
            sizeof(WCHAR) * dwOperationTypeLength
            );

    
        pAuditEvent->szObjectType = (PWSTR)((PUCHAR)pAuditEvent->szOperationType + (sizeof(WCHAR) * dwOperationTypeLength));

        RtlCopyMemory(
            pAuditEvent->szObjectType,
            szObjectType,
            sizeof(WCHAR) * dwObjectTypeLength
            );

        pAuditEvent->szObjectName = (PWSTR)((PUCHAR)pAuditEvent->szObjectType + (sizeof(WCHAR) * dwObjectTypeLength));

        RtlCopyMemory(
            pAuditEvent->szObjectName,
            szObjectName,
            sizeof(WCHAR) * dwObjectNameLength
            );

        pAuditEvent->szAdditionalInfo = (PWSTR)((PUCHAR)pAuditEvent->szObjectName + (sizeof(WCHAR) * dwObjectNameLength));

        RtlCopyMemory(
            pAuditEvent->szAdditionalInfo,
            szAdditionalInfo,
            sizeof(WCHAR) * dwAdditionalInfoLength
            );
    }

    //
    // AEI and Queue will be filled in from RM in AuthzpCreateAndLogAudit
    //

    pAuditEvent->hAET            = NULL;
    pAuditEvent->hAuditQueue     = NULL;
    pAuditEvent->pAuditParams    = NULL;
    pAuditEvent->Flags           = Flags;
    pAuditEvent->dwTimeOut       = INFINITE;
    pAuditEvent->dwSize          = sizeof(AUTHZI_AUDIT_EVENT) + dwStringSize;

Cleanup:

    if (!b)
    {
        AuthzpFreeNonNull(pAuditEvent);
    }
    else
    {
        *phAuditEvent = (AUTHZ_AUDIT_EVENT_HANDLE) pAuditEvent;
    }
    return b;
}



BOOL
AuthzGetInformationFromAuditEvent(
    IN  AUTHZ_AUDIT_EVENT_HANDLE            hAuditEvent,
    IN  AUTHZ_AUDIT_EVENT_INFORMATION_CLASS InfoClass,
    IN  DWORD                               BufferSize,
    OUT PDWORD                              pSizeRequired,
    OUT PVOID                               Buffer
    )

/*++

Routine Description

    Queries information in the AUTHZ_AUDIT_EVENT_HANDLE.
    
Arguments

    hAuditEvent - the AUTHZ_AUDIT_EVENT_HANDLE to query.
    
    InfoClass - The class of information to query.  Valid values are:
        
        a. AuthzAuditEventInfoFlags - returns the flags set for the handle.  Type is DWORD.
        e. AuthzAuditEventInfoOperationType - returns the operation type.  Type is PCWSTR.
        e. AuthzAuditEventInfoObjectType - returns the object type.  Type is PCWSTR.
        f. AuthzAuditEventInfoObjectName - returns the object name.  Type is PCWSTR.
        g. AuthzAuditEventInfoAdditionalInfo - returns the additional info field.  Type is PCWSTR.
    
    BufferSize - Size of the supplied buffer.

    pSizeRequired - To return the size of the structure needed to hold the results.

    Buffer - To hold the information requested. The structure returned will
        depend on the information class requested.

Return Value

    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().

--*/

{

    DWORD               LocalSize  = 0;
    PAUTHZI_AUDIT_EVENT pAuditEvent = (PAUTHZI_AUDIT_EVENT) hAuditEvent;

    if ((!ARGUMENT_PRESENT(hAuditEvent))             ||
        (!ARGUMENT_PRESENT(pSizeRequired))           ||
        (!ARGUMENT_PRESENT(Buffer) && BufferSize > 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *pSizeRequired = 0;

    switch(InfoClass)
    {
    case AuthzAuditEventInfoFlags:
        
        LocalSize = sizeof(DWORD);
        
        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }
        
        *((PDWORD)Buffer) = pAuditEvent->Flags;

        return TRUE;

    case AuthzAuditEventInfoOperationType:
    
        LocalSize = (DWORD)(sizeof(WCHAR) * (wcslen(pAuditEvent->szOperationType) + 1));

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        RtlCopyMemory(
            Buffer,
            pAuditEvent->szOperationType,
            LocalSize
            );

        return TRUE;

    case AuthzAuditEventInfoObjectType:
    
        LocalSize = (DWORD)(sizeof(WCHAR) * (wcslen(pAuditEvent->szObjectType) + 1));

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        RtlCopyMemory(
            Buffer,
            pAuditEvent->szObjectType,
            LocalSize
            );

        return TRUE;

    case AuthzAuditEventInfoObjectName:
    
        LocalSize = (DWORD)(sizeof(WCHAR) * (wcslen(pAuditEvent->szObjectName) + 1));

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        RtlCopyMemory(
            Buffer,
            pAuditEvent->szObjectName,
            LocalSize
            );

        return TRUE;

    case AuthzAuditEventInfoAdditionalInfo:

        if (NULL == pAuditEvent->szAdditionalInfo)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        LocalSize = (DWORD)(sizeof(WCHAR) * (wcslen(pAuditEvent->szAdditionalInfo) + 1));

        *pSizeRequired = LocalSize;

        if (LocalSize > BufferSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        RtlCopyMemory(
            Buffer,
            pAuditEvent->szAdditionalInfo,
            LocalSize
            );

        return TRUE;

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
}


BOOL
AuthzFreeAuditEvent(
    IN AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent
    )

/*++

Routine Description:

    Frees hAuditEvent and notifies the appropriate queue to unregister the audit context in LSA.
    
Arguments:

    hAuditEvent - AUTHZ_AUDIT_EVENT_HANDLE.  Must have initially been created 
        with AuthzRMInitializeObjectAccessAuditEvent or AuthzInitializeAuditEvent().
        
Return Value:

    Boolean: TRUE if successful; FALSE if failure.  
    Extended information available with GetLastError().
    
--*/

{
    PAUTHZI_AUDIT_EVENT pAuditEvent = (PAUTHZI_AUDIT_EVENT) hAuditEvent;

    if (!ARGUMENT_PRESENT(hAuditEvent))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // If the RM specified the AuditEvent, then we should deref the context.  If the AuditEvent
    // has not been used, or was a default event type, then this field will be NULL.
    //

    if (AUTHZ_NON_NULL_PTR(pAuditEvent->hAET))
    {
        AuthzpDereferenceAuditEventType(pAuditEvent->hAET);
    }

    AuthzpFree(pAuditEvent);
    return TRUE;
}


//
// Routines for internal callers.
//


BOOL
AuthziInitializeAuditEventType(
    IN DWORD Flags,
    IN USHORT CategoryID,
    IN USHORT AuditID,
    IN USHORT ParameterCount,
    OUT PAUTHZ_AUDIT_EVENT_TYPE_HANDLE phAuditEventType
    )

/*++

Routine Description

    Initializes an AUTHZ_AUDIT_EVENT_TYPE_HANDLE for use in AuthzInitializeAuditEvent().
    
Arguments

    phAuditEventType - pointer to pointer to receive memory allocated for AUTHZ_AUDIT_EVENT_TYPE_HANDLE.
    
    dwFlags - Flags that control behavior of function.
        AUTHZ_INIT_GENERIC_AUDIT_EVENT - initialize the AUTHZ_AUDIT_EVENT_TYPE for generic object 
        access audits.  When this flag is specified, none of the optional parameters need to 
        be passed.  This is equivalent to calling:
           
           AuthzInitializeAuditEvent(
               &hAEI,
               0,
               SE_CATEGID_OBJECT_ACCESS,
               SE_AUDITID_OBJECT_OPERATION,
               9
               );

    CategoryID - The category id of the audit.
    
    AuditID - The ID of the audit in msaudite.
    
    ParameterCount - The number of fields in the audit.        
        
Return Value

    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().

--*/

{
    PAUTHZ_AUDIT_EVENT_TYPE_OLD pAET   = NULL;
    BOOL                        b      = TRUE;
    AUDIT_HANDLE                hAudit = NULL;

    if (!ARGUMENT_PRESENT(phAuditEventType))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *phAuditEventType = NULL;

    pAET = AuthzpAlloc(sizeof(AUTHZ_AUDIT_EVENT_TYPE_OLD));

    if (AUTHZ_ALLOCATION_FAILED(pAET))
    {
        b = FALSE;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Cleanup;
    }

    if (FLAG_ON(Flags, AUTHZP_INIT_GENERIC_AUDIT_EVENT))
    {
        pAET->Version                 = AUDIT_TYPE_LEGACY;
        pAET->u.Legacy.CategoryId     = SE_CATEGID_OBJECT_ACCESS;
        pAET->u.Legacy.AuditId        = SE_AUDITID_OBJECT_OPERATION;
        pAET->u.Legacy.ParameterCount = 11;
    }
    else
    {
        pAET->Version                 = AUDIT_TYPE_LEGACY;
        pAET->u.Legacy.CategoryId     = CategoryID;
        pAET->u.Legacy.AuditId        = AuditID;
        
        // 
        // ParameterCount gets increased by 2 because the LSA expects the first two
        // parameters to be the user sid and subsystem name.
        //

        pAET->u.Legacy.ParameterCount = ParameterCount + 2;
    }

    b = AuthzpRegisterAuditEvent( 
            pAET, 
            &hAudit 
            ); 

    if (!b)
    {
        goto Cleanup;
    }

    pAET->hAudit     = (ULONG_PTR) hAudit;
    pAET->dwFlags    = Flags & ~AUTHZP_INIT_GENERIC_AUDIT_EVENT;

Cleanup:

    if (!b)
    {
        AuthzpFreeNonNull(pAET);
    }
    else
    {
        AuthzpReferenceAuditEventType((AUTHZ_AUDIT_EVENT_TYPE_HANDLE)pAET);
        *phAuditEventType = (AUTHZ_AUDIT_EVENT_TYPE_HANDLE)pAET;
    }
    return b;
}


BOOL
AuthziModifyAuditEventType(
    IN DWORD Flags,
    IN USHORT CategoryID,
    IN USHORT AuditID,
    IN USHORT ParameterCount,
    IN OUT AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType
    )

/*++

Routine Description

    Modifies an existing AuditEventType.
    
Arguments

    Flags - AUTHZ_AUDIT_EVENT_TYPE_AUDITID
    
Return Value

--*/
{
    PAUTHZ_AUDIT_EVENT_TYPE_OLD pAAETO = (PAUTHZ_AUDIT_EVENT_TYPE_OLD) hAuditEventType;
    BOOL                        b      = TRUE;

    if (!ARGUMENT_PRESENT(hAuditEventType))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    UNREFERENCED_PARAMETER(CategoryID);
    UNREFERENCED_PARAMETER(ParameterCount);

    if (FLAG_ON(Flags, AUTHZ_AUDIT_EVENT_TYPE_AUDITID))
    {
        pAAETO->u.Legacy.AuditId = AuditID;
    }
    
    if (FLAG_ON(Flags, AUTHZ_AUDIT_EVENT_TYPE_CATEGID))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        b = FALSE;
        goto Cleanup;
    }

    if (FLAG_ON(Flags, AUTHZ_AUDIT_EVENT_TYPE_PARAM))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        b = FALSE;
        goto Cleanup;
    }

Cleanup:

    return b;
}


BOOL
AuthziFreeAuditEventType(
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType
    )

/*++

Routine Description

    Frees the PAUDIT_EVENT_TYPE allocated by AuthzInitializeAuditEventType().
    
Arguments

    pAuditEventType - pointer to memory to free.
    
Return Value
    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().
    
--*/

{
    BOOL b = TRUE;

    if (!ARGUMENT_PRESENT(hAuditEventType))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    b = AuthzpDereferenceAuditEventType(
            hAuditEventType
            );
    
    return b;
}


AUTHZAPI
BOOL
WINAPI
AuthziInitializeAuditQueue(
    IN DWORD Flags,
    IN DWORD dwAuditQueueHigh,
    IN DWORD dwAuditQueueLow,
    IN PVOID Reserved,
    OUT PAUTHZ_AUDIT_QUEUE_HANDLE phAuditQueue
    )

/*++

Routine Description

    Creates an audit queue.
    
Arguments

    phAuditQueue - pointer to handle for the audit queue.
    
    Flags -
        
        AUTHZ_MONITOR_AUDIT_QUEUE_SIZE - notifies Authz that it should not let the size of the 
        audit queue grow unchecked.  
        
    dwAuditQueueHigh - high water mark for the audit queue.
    
    dwAuditQueueLow - low water mark for the audit queue.
        
    Reserved - for future expansion.                  

Return Value

    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().
--*/

{
    PAUTHZI_AUDIT_QUEUE pQueue = NULL;
    BOOL                b      = TRUE;
    NTSTATUS            Status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(Reserved);

    if (!ARGUMENT_PRESENT(phAuditQueue))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *phAuditQueue = NULL;

    pQueue = AuthzpAlloc(sizeof(AUTHZI_AUDIT_QUEUE));

    if (AUTHZ_ALLOCATION_FAILED(pQueue))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        b = FALSE;
        goto Cleanup;
    }

    pQueue->dwAuditQueueHigh = dwAuditQueueHigh;
    pQueue->dwAuditQueueLow  = dwAuditQueueLow;
    pQueue->bWorker          = TRUE;
    pQueue->Flags            = Flags;


    //
    // This event is set whenever an audit is queued with AuthziLogAuditEvent().  It
    // notifies the dequeueing thread that there is work to do.  
    //

    pQueue->hAuthzAuditAddedEvent = CreateEvent(
                                        NULL,
                                        TRUE,  
                                        FALSE, // Initially not signaled, since no audit has been added yet.
                                        NULL
                                        );

    if (NULL == pQueue->hAuthzAuditAddedEvent)
    {
        b = FALSE;
        goto Cleanup;
    }

    //
    // This event is set when the audit queue is empty.
    //

    pQueue->hAuthzAuditQueueEmptyEvent = CreateEvent(
                                             NULL,
                                             TRUE, 
                                             TRUE, // Initially signaled.
                                             NULL
                                             );

    if (NULL == pQueue->hAuthzAuditQueueEmptyEvent)
    {
        b = FALSE;
        goto Cleanup;
    }

    //
    // This event is set when the audit queue is below the low water mark.
    //

    pQueue->hAuthzAuditQueueLowEvent = CreateEvent(
                                           NULL,
                                           FALSE,// The system only schedules one thread waiting on this event (auto reset event).
                                           TRUE, // Initially set.
                                           NULL
                                           );

    if (NULL == pQueue->hAuthzAuditQueueLowEvent)
    {
        b = FALSE;
        goto Cleanup;
    }
    
    //
    // This boolean is true only when the high water mark has been reached
    //

    pQueue->bAuthzAuditQueueHighEvent = FALSE;

    //
    // This lock is taken whenever audits are being added or removed from the queue, or events / boolean being set.
    //

    Status = RtlInitializeCriticalSection(&pQueue->AuthzAuditQueueLock);
    if (!NT_SUCCESS(Status))
    {
        SetLastError(RtlNtStatusToDosError(Status));
        b = FALSE;
        goto Cleanup;
    }
    
    //
    // Initialize the list
    //

    InitializeListHead(&pQueue->AuthzAuditQueue);
    
    //
    // Create the worker thread that sends audits to LSA.
    //

    pQueue->hAuthzAuditThread = CreateThread(
                                    NULL,
                                    0,
                                    AuthzpDeQueueThreadWorker,
                                    pQueue,
                                    0,
                                    NULL
                                    );

    if (NULL == pQueue->hAuthzAuditThread)
    {
        b = FALSE;
        goto Cleanup;
    }
    


Cleanup:
    
    if (!b)
    {
        if (AUTHZ_NON_NULL_PTR(pQueue))
        {
            AuthzpCloseHandleNonNull(pQueue->hAuthzAuditQueueLowEvent);
            AuthzpCloseHandleNonNull(pQueue->hAuthzAuditAddedEvent);
            AuthzpCloseHandleNonNull(pQueue->hAuthzAuditQueueEmptyEvent);
            AuthzpCloseHandleNonNull(pQueue->hAuthzAuditThread);
            AuthzpFree(pQueue);
        }
    }
    else
    {
        *phAuditQueue = (AUTHZ_AUDIT_QUEUE_HANDLE)pQueue;
    }
    return b;
}
    

AUTHZAPI
BOOL
WINAPI
AuthziModifyAuditQueue(
    IN OUT AUTHZ_AUDIT_QUEUE_HANDLE hQueue OPTIONAL,
    IN DWORD Flags,
    IN DWORD dwQueueFlags OPTIONAL,
    IN DWORD dwAuditQueueSizeHigh OPTIONAL,
    IN DWORD dwAuditQueueSizeLow OPTIONAL,
    IN DWORD dwThreadPriority OPTIONAL
    )

/*++

Routine Description

    Allows the Resource Manager to modify audit queue information.

Arguments

    Flags - Flags specifying which fields are to be reinitialized.  Valid flags are:
        
        AUTHZ_AUDIT_QUEUE_HIGH            
        AUTHZ_AUDIT_QUEUE_LOW             
        AUTHZ_AUDIT_QUEUE_THREAD_PRIORITY 
        AUTHZ_AUDIT_QUEUE_FLAGS           

        Specifying one of the above flags in the Flags field causes the appropriate field of 
        the resource manager to be modified to the correct value below:
        
    dwQueueFlags - set the flags for the audit queue.
                                                                                          
    dwAuditQueueSizeHigh - High water mark for the audit queue.
    
    dwAuditQueueSizeLow - Low water mark for the audit queue.
    
    dwThreadPriority - Changes the priority of the audit dequeue thread.  Valid values are described
        in the SetThreadPriority API.  A RM may wish to change the priority of the thread if, for example,
         the high water mark is being reached too frequently and the RM does not want to allow the queue to
         grow beyond its current size.

Return Value

    Boolean: TRUE on success; FALSE on failure.  
    Extended information available with GetLastError().

--*/

{
    BOOL                b      = TRUE;
    PAUTHZI_AUDIT_QUEUE pQueue = NULL;

    if (!ARGUMENT_PRESENT(hQueue))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pQueue = (PAUTHZI_AUDIT_QUEUE)hQueue;

    //
    // Set the fields that the caller has asked us to initialize.
    //

    if (FLAG_ON(Flags, AUTHZ_AUDIT_QUEUE_FLAGS))
    {
        pQueue->Flags = dwQueueFlags;
    }
    
    if (FLAG_ON(Flags, AUTHZ_AUDIT_QUEUE_HIGH))
    {
        pQueue->dwAuditQueueHigh = dwAuditQueueSizeHigh;
    }
    
    if (FLAG_ON(Flags, AUTHZ_AUDIT_QUEUE_LOW))
    {
        pQueue->dwAuditQueueLow = dwAuditQueueSizeLow;
    }
    
    if (FLAG_ON(Flags, AUTHZ_AUDIT_QUEUE_THREAD_PRIORITY))
    {
        b = SetThreadPriority(pQueue->hAuthzAuditThread, dwThreadPriority);
        if (!b)
        {
            goto Cleanup;
        }
    }

Cleanup:    
    
    return b;
}


AUTHZAPI
BOOL
WINAPI
AuthziFreeAuditQueue(
    IN AUTHZ_AUDIT_QUEUE_HANDLE hQueue OPTIONAL
    )

/*++

Routine Description

    This API flushes and frees a queue.  The actual freeing of queue memory occurs in the dequeueing thread,
    after all audits have been flushed.
        
Arguments

    hQueue - handle to the queue object to free.
    
Return Value

    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().
    
--*/

{
    PAUTHZI_AUDIT_QUEUE pQueue  = (PAUTHZI_AUDIT_QUEUE) hQueue;
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                b       = TRUE;

    if (!ARGUMENT_PRESENT(hQueue))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    dwError = WaitForSingleObject(
                  pQueue->hAuthzAuditQueueEmptyEvent, 
                  INFINITE
                  );

    if (WAIT_OBJECT_0 != dwError)
    {
        ASSERT(L"WaitForSingleObject on hAuthzAuditQueueEmptyEvent failed." && FALSE);
        SetLastError(dwError);
        b = FALSE;
        goto Cleanup;
    }

    //
    // Set this BOOL to FALSE so that the dequeueing thread knows it can terminate.  Set the 
    // AddedEvent so that the thread can be scheduled.
    //

    pQueue->bWorker = FALSE;        

    b = SetEvent(
            pQueue->hAuthzAuditAddedEvent
            );

    if (!b)
    {
        goto Cleanup;
    }

    //
    // Wait for the thread to terminate.
    //

    dwError = WaitForSingleObject(
                  pQueue->hAuthzAuditThread, 
                  INFINITE
                  );

    //
    // The wait should succeed since we have told the thread to finish working.
    //

    if (WAIT_OBJECT_0 != dwError)
    {
        ASSERT(L"WaitForSingleObject on hAuthzAuditThread failed." && FALSE);
        SetLastError(dwError);
        b = FALSE;
        goto Cleanup;
    }
    
    RtlDeleteCriticalSection(&pQueue->AuthzAuditQueueLock);
    AuthzpCloseHandle(pQueue->hAuthzAuditAddedEvent);
    AuthzpCloseHandle(pQueue->hAuthzAuditQueueLowEvent);
    AuthzpCloseHandle(pQueue->hAuthzAuditQueueEmptyEvent);
    AuthzpCloseHandle(pQueue->hAuthzAuditThread);
    AuthzpFree(pQueue);

Cleanup:

    return b;
}
    

BOOL
AuthziLogAuditEvent(
    IN DWORD Flags,
    IN AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent,
    IN PVOID pReserved
    )

/*++

Routine Description:

    This API manages the logging of Audit Records.  The function constructs an 
    Audit Record from the information provided and appends it to the Audit 
    Record Queue, a doubly-linked list of Audit Records awaiting output to the 
    Audit Log.  A dedicated thread reads this queue, sending the Audit Records 
    to the LSA and removing them from the Audit Queue.  
        
    This call is not guaranteed to return without latency.  If the queue is at 
    or above the high water mark for size, then the calling thread will be 
    suspended until such time that the queue reaches the low water mark.  Be 
    aware of this latency when fashioning your calls to AuthziLogAuditEvent.  
    If such latency is not allowable for the audit that is being generated, 
    then specify the correct flag when initializing the 
    AUTHZ_AUDIT_EVENT_HANDLE (in AuthzInitAuditEventHandle()).  Flags are listed 
    in that routines description.  
        
Arguments:

    hAuditEvent   - handle previously obtained by calling AuthzInitAuditEventHandle

    Flags       - TBD

    pReserved     - reserved for future enhancements

Return Value:

    Boolean: TRUE on success, FALSE on failure.  
    Extended information available with GetLastError().
                    
--*/
                    
{
    NTSTATUS                 Status                  = STATUS_SUCCESS;
    BOOL                     b                       = TRUE;
    BOOL                     bRef                    = FALSE;
    PAUTHZI_AUDIT_QUEUE      pQueue                  = NULL;
    PAUDIT_PARAMS            pMarshalledAuditParams  = NULL;
    PAUTHZ_AUDIT_QUEUE_ENTRY pAuthzAuditEntry        = NULL;
    PAUTHZI_AUDIT_EVENT      pAuditEvent             = (PAUTHZI_AUDIT_EVENT)hAuditEvent;
    
    //
    // Verify what the caller has passed in.
    //

    if (!ARGUMENT_PRESENT(hAuditEvent))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    //
    // Make a self relative copy of the pAuditEvent->pAuditParams.
    //

    b = AuthzpMarshallAuditParams(
            &pMarshalledAuditParams, 
            pAuditEvent->pAuditParams
            );

    if (!b)
    {
        goto Cleanup;
    }

    pQueue = (PAUTHZI_AUDIT_QUEUE)pAuditEvent->hAuditQueue;

    if (NULL == pQueue)
    {
        
        b = AuthzpSendAuditToLsa(
                (AUDIT_HANDLE)((PAUTHZ_AUDIT_EVENT_TYPE_OLD)pAuditEvent->hAET)->hAudit,
                0,
                pMarshalledAuditParams,
                NULL
                );
        
        goto Cleanup;
    }
    else
    {

        //
        // Create the audit queue entry.
        //

        pAuthzAuditEntry = AuthzpAlloc(sizeof(AUTHZ_AUDIT_QUEUE_ENTRY));

        if (AUTHZ_ALLOCATION_FAILED(pAuthzAuditEntry))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            b = FALSE;
            goto Cleanup;
        }

        pAuthzAuditEntry->pAAETO        = (PAUTHZ_AUDIT_EVENT_TYPE_OLD)pAuditEvent->hAET;
        pAuthzAuditEntry->Flags         = Flags;
        pAuthzAuditEntry->pReserved     = pReserved;
        pAuthzAuditEntry->pAuditParams  = pMarshalledAuditParams;
    
        AuthzpReferenceAuditEventType(pAuditEvent->hAET);
        bRef = TRUE;

        if (FLAG_ON(pQueue->Flags, AUTHZ_MONITOR_AUDIT_QUEUE_SIZE))
        {
            
            //
            // Monitor queue size if specified by the Resource Manager.
            //

            //
            // If we are closing in on the high water mark then wait for the queue 
            // to be below the low water mark.
            //

#define AUTHZ_QUEUE_WAIT_HEURISTIC .75


            if (pQueue->AuthzAuditQueueLength > pQueue->dwAuditQueueHigh * AUTHZ_QUEUE_WAIT_HEURISTIC)
            {
                Status = WaitForSingleObject(
                             pQueue->hAuthzAuditQueueLowEvent, 
                             pAuditEvent->dwTimeOut
                             );

                if (WAIT_FAILED == Status)
                {
                    ASSERT(L"WaitForSingleObject on hAuthzAuditQueueLowEvent failed." && FALSE);
                }

                if (WAIT_TIMEOUT == Status)
                {
                    b = FALSE;
                    SetLastError(RtlNtStatusToDosError(Status));
                    goto Cleanup;
                }
            }

            //
            // Queue the event and modify appropriate events.
            //

            b = AuthzpEnQueueAuditEventMonitor(
                    pQueue,
                    pAuthzAuditEntry
                    );
            
            goto Cleanup;
        }
        else
        {

            //
            // If we are not to monitor the audit queue then simply queue the entry.
            //

            b = AuthzpEnQueueAuditEvent(
                    pQueue,
                    pAuthzAuditEntry
                    );

            goto Cleanup;
        }
    }

Cleanup:

    if (pQueue)
    {
        if (FALSE == b)
        {
            if (bRef)
            {
                AuthzpDereferenceAuditEventType(pAuditEvent->hAET);
            }
            AuthzpFreeNonNull(pAuthzAuditEntry);
            AuthzpFreeNonNull(pMarshalledAuditParams);
        }

        //
        // hAuthzAuditQueueLowEvent is an auto reset event.  Only one waiting thread is released when it is signalled, and then
        // event is automatically switched to a nonsignalled state.  This is appropriate here because it keeps many threads from
        // running and overflowing the high water mark.  However, I must always resignal the event myself if the conditions
        // for signaling are true.
        //

        RtlEnterCriticalSection(&pQueue->AuthzAuditQueueLock);
        if (!pQueue->bAuthzAuditQueueHighEvent)
        {
            if (pQueue->AuthzAuditQueueLength <= pQueue->dwAuditQueueHigh)
            {
                BOOL bSet;
                bSet = SetEvent(pQueue->hAuthzAuditQueueLowEvent);
                if (!bSet)
                {
                    ASSERT(L"SetEvent on hAuthzAuditQueueLowEvent failed" && FALSE);
                }

            }
        }
        RtlLeaveCriticalSection(&pQueue->AuthzAuditQueueLock);
    }
    else
    {
        AuthzpFreeNonNull(pMarshalledAuditParams);
    }
    return b;
}



BOOL
AuthziAllocateAuditParams(
    OUT PAUDIT_PARAMS * ppParams,
    IN USHORT NumParams
    )
/*++

Routine Description:

    Allocate the AUDIT_PARAMS structure for the correct number of parameters.
     
Arguments:

    ppParams       - pointer to PAUDIT_PARAMS structure to be initialized.

    NumParams     - number of parameters passed in the var-arg section.
                    This must be SE_MAX_AUDIT_PARAMETERS or less.
Return Value:
    
     Boolean: TRUE on success, FALSE on failure.  Extended information available with GetLastError().

--*/
{
    BOOL                     b               = TRUE;
    PAUDIT_PARAMS            pAuditParams    = NULL;
    
    if (!ARGUMENT_PRESENT(ppParams))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    *ppParams = NULL;

    //
    // the first two params are always fixed. thus the total number
    // is 2 + the passed number.
    //

    if ((NumParams + 2) > SE_MAX_AUDIT_PARAMETERS)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        b = FALSE;
        goto Cleanup;
    }

    pAuditParams = AuthzpAlloc(sizeof(AUDIT_PARAMS) + (sizeof(AUDIT_PARAM) * (NumParams + 2)));
    
    if (AUTHZ_ALLOCATION_FAILED(pAuditParams))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        b = FALSE;
        goto Cleanup;
    }

    pAuditParams->Parameters = (PAUDIT_PARAM)((PUCHAR)pAuditParams + sizeof(AUDIT_PARAMS));

Cleanup:

    if (!b)
    {
        AuthzpFreeNonNull(pAuditParams);
    }
    else
    {
        *ppParams = pAuditParams;
    }
    return b;
}


BOOL
AuthziInitializeAuditParamsWithRM(
    IN DWORD Flags,
    IN AUTHZ_RESOURCE_MANAGER_HANDLE hResourceManager,
    IN USHORT NumParams,
    OUT PAUDIT_PARAMS pParams,
    ...
    )
/*++

Routine Description:

    Initialize the AUDIT_PARAMS structure based on the passed
    data. This is the recommended way to init AUDIT_PARAMS.  It is
    faster than AuthzInitializeAuditParams and works with an 
    impersonating caller.

    The caller passes in type ~ value pairs in the vararg section.
    This function will initialize the corresponding array elements
    based on each such pair. In case of certain types, there may
    be more than one value argument required. This requirement
    is documented next to each param-type.

Arguments:

    pParams       - pointer to AUDIT_PARAMS structure to be initialized
                    the size of pParams->Parameters member must be big enough
                    to hold NumParams elements. The caller must allocate
                    memory for this structure and its members.

    hResourceManager - Handle to the Resource manager that is creating the audit.
    
    Flags       - control flags. one or more of the following:
                    APF_AuditSuccess

    NumParams     - number of parameters passed in the var-arg section.
                    This must be SE_MAX_AUDIT_PARAMETERS or less.

    ...           - The format of the variable arg portion is as follows:
                    
                    <one of APT_ * flags> <zero or more values>

                    APT_String  <pointer to null terminated string>

                                Flags:
                                AP_Filespec  : treats the string as a filename
                    
                    APT_Ulong   <ulong value> [<object-type-index>]
                    
                                Flags:
                                AP_FormatHex : number appears in hex
                                               in eventlog
                                AP_AccessMask: number is treated as
                                               an access-mask
                                               Index to object type must follow

                    APT_Pointer <pointer/handle>
                                32 bit on 32 bit systems and
                                64 bit on 64 bit systems

                    APT_Sid     <pointer to sid>

                    APT_LogonId [<logon-id>]
                    
                                Flags:
                                AP_PrimaryLogonId : logon-id is captured
                                                    from the process token.
                                                    No need to specify one.

                                AP_ClientLogonId  : logon-id is captured
                                                    from the thread token.
                                                    No need to specify one.
                                                    
                                no flags          : need to supply a logon-id

                    APT_ObjectTypeList <ptr to obj type list> <obj-type-index>
                                Index to object type must be specified

Return Value:
    TRUE  on success
    FALSE otherwise

    call GetLastError() to retrieve the errorcode,
    which will be one of the following:

    ERROR_INVALID_PARAMETER if one of the params is incorrect
    

Notes:

--*/
{
    PAUTHZI_RESOURCE_MANAGER pRM             = (PAUTHZI_RESOURCE_MANAGER) hResourceManager;
    DWORD                    dwError         = NO_ERROR;
    BOOL                     b               = TRUE;
    BOOL                     bImpersonating  = TRUE;
    USHORT                   i;
    AUDIT_PARAM_TYPE         ParamType       = APT_None;
    PAUDIT_PARAM             pParam          = NULL;
    LUID                     Luid            = { 0 };
    LUID                     AuthIdThread    = { 0 };
    PSID                     pThreadSID      = NULL;
    ULONG                    TypeFlags;
    ULONG                    ParamFlags;
    ULONG                    ObjectTypeIndex;

    va_list(arglist);
    
    //
    // the first two params are always fixed. thus the total number
    // is 2 + the passed number.
    //


    if (!ARGUMENT_PRESENT(hResourceManager)       ||
        !ARGUMENT_PRESENT(pParams)                ||
        (NumParams + 2) > SE_MAX_AUDIT_PARAMETERS)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    b = AuthzpGetThreadTokenInfo( 
            &pThreadSID, 
            &AuthIdThread 
            );

    if (!b)
    {
        dwError = GetLastError();

        if (dwError == ERROR_NO_TOKEN)
        {
            bImpersonating = FALSE;
            dwError = NO_ERROR;
            b = TRUE;
        }
        else
        {
            goto Cleanup;
        }
    }

    va_start (arglist, pParams);

    pParams->Length = 0;
    pParams->Flags  = Flags;
    pParams->Count  = NumParams+2;

    pParam          = pParams->Parameters;

    //
    // the first param is always the sid of the user in thread token
    // if thread is not impersonating, sid in the primary token is used.
    //

    pParam->Type = APT_Sid;
    if (bImpersonating)
    {
        pParam->Data0 = (ULONG_PTR) pThreadSID;

    }
    else
    {
        pParam->Data0 = (ULONG_PTR) pRM->pUserSID;
    }

    pParam++;

    //
    // the second param is always the sub-system name
    //

    pParam->Type    = APT_String;
    pParam->Data0   = (ULONG_PTR) pRM->szResourceManagerName;

    pParam++;
    
    //
    // now initialize the rest using the var-arg portion
    //

    for (i = 0; i < NumParams; i++, pParam++)
    {
        TypeFlags = va_arg(arglist, ULONG);

        ParamType  = ApExtractType(TypeFlags);
        ParamFlags = ApExtractFlags(TypeFlags);
        
        pParam->Type = ParamType;

        switch(ParamType)
        {
        default:
            dwError = ERROR_INVALID_PARAMETER;
            break;
                
        case APT_Pointer:
        case APT_String:
        case APT_Sid:
            pParam->Data0 = (ULONG_PTR) va_arg(arglist, PVOID);
            break;
            
        case APT_Ulong:
            pParam->Data0 = va_arg(arglist, ULONG);

            //
            // in case of an access-mask, store the object-type index
            // This is because, the meaning of the access-mask bits
            // cannot be determined without knowing the object type.
            //

            if (ParamFlags & AP_AccessMask)
            {
                ObjectTypeIndex = va_arg(arglist, ULONG);
                //
                // The object-type-index:
                // - must have been specified earlier
                // - must be specified as a string.
                //

                if ( ( ObjectTypeIndex >= i ) ||
                     ( pParams->Parameters[ObjectTypeIndex].Type !=
                       APT_String ) )
                {
                    dwError = ERROR_INVALID_PARAMETER;
                }
                else
                {
                    pParam->Data1 = ObjectTypeIndex;
                }
            }
            pParam->Flags   = ParamFlags;
            break;
            
        case APT_LogonId:
            if (ParamFlags & AP_PrimaryLogonId)
            {
                //
                // use the captured process token info
                //

                pParam->Data0 = pRM->AuthID.LowPart;
                pParam->Data1 = pRM->AuthID.HighPart;
            }
            else if (ParamFlags & AP_ClientLogonId)
            {
                //ASSERT( bImpersonating && L"AuthziInitializeAuditParamsWithRM: AP_ClientLogonId specified while not impersonating" );
                //
                // use the captured thread token info
                //

                pParam->Data0 = AuthIdThread.LowPart;
                pParam->Data1 = AuthIdThread.HighPart;
            }
            else
            {
                //
                // no flag is specified, use the supplied logon-id
                //

                Luid = va_arg(arglist, LUID);
                pParam->Data0 = Luid.LowPart;
                pParam->Data1 = Luid.HighPart;
            }
            break;

        case APT_ObjectTypeList:
            pParam->Data0 = (ULONG_PTR) va_arg(
                                            arglist,
                                            PAUDIT_OBJECT_TYPES
                                            );
            pParam->Data1 = va_arg(arglist, ULONG);
            break;
        }

        if (dwError != NO_ERROR)
        {
            break;
        }
    }

Cleanup:    
    if ( dwError != NO_ERROR )
    {
        SetLastError( dwError );
        b = FALSE;
        
        if ( pThreadSID != NULL )
        {
            LocalFree( pThreadSID );
        }
    }

    va_end (arglist);
    return b;
}


BOOL
AuthziInitializeAuditParamsFromArray(
    IN DWORD Flags,
    IN AUTHZ_RESOURCE_MANAGER_HANDLE hResourceManager,
    IN USHORT NumParams,
    IN PAUDIT_PARAM pParamArray,
    OUT PAUDIT_PARAMS pParams
    )
/*++

Routine Description:

    Initialize the AUDIT_PARAMS structure based on the passed
    data. 

Arguments:

    pParams       - pointer to AUDIT_PARAMS structure to be initialized
                    the size of pParams->Parameters member must be big enough
                    to hold NumParams elements. The caller must allocate
                    memory for this structure and its members.

    hResourceManager - Handle to the Resource manager that is creating the audit.
    
    Flags       - control flags. one or more of the following:
                    APF_AuditSuccess

    pParamArray - an array of type AUDIT_PARAM

Return Value:
    TRUE  on success
    FALSE otherwise

    call GetLastError() to retrieve the errorcode,
    which will be one of the following:

    ERROR_INVALID_PARAMETER if one of the params is incorrect
    

Notes:

--*/
{
    PAUTHZI_RESOURCE_MANAGER pRM             = (PAUTHZI_RESOURCE_MANAGER) hResourceManager;
    DWORD                    dwError         = NO_ERROR;
    BOOL                     b               = TRUE;
    BOOL                     bImpersonating  = TRUE;
    PAUDIT_PARAM             pParam          = NULL;
    LUID                     AuthIdThread;
    PSID                     pThreadSID      = NULL;

    //
    // the first two params are always fixed. thus the total number
    // is 2 + the passed number.
    //

    if (!ARGUMENT_PRESENT(hResourceManager)       ||
        !ARGUMENT_PRESENT(pParams)                ||
        !ARGUMENT_PRESENT(pParamArray)            ||
        (NumParams + 2) > SE_MAX_AUDIT_PARAMETERS)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    b = AuthzpGetThreadTokenInfo( 
            &pThreadSID, 
            &AuthIdThread 
            );

    if (!b)
    {
        dwError = GetLastError();

        if (dwError == ERROR_NO_TOKEN)
        {
            bImpersonating = FALSE;
            dwError = NO_ERROR;
            b = TRUE;
        }
        else
        {
            goto Cleanup;
        }
    }

    pParams->Length = 0;
    pParams->Flags  = Flags;
    pParams->Count  = NumParams+2;

    pParam          = pParams->Parameters;

    //
    // the first param is always the sid of the user in thread token
    // if thread is not impersonating, sid in the primary token is used.
    //

    pParam->Type = APT_Sid;
    if (bImpersonating)
    {
        pParam->Data0 = (ULONG_PTR) pThreadSID;

    }
    else
    {
        pParam->Data0 = (ULONG_PTR) pRM->pUserSID;
    }

    pParam++;

    //
    // the second param is always the sub-system name
    //

    pParam->Type    = APT_String;
    pParam->Data0   = (ULONG_PTR) pRM->szResourceManagerName;

    pParam++;
    
    //
    // now initialize the rest using the array.
    //

    RtlCopyMemory(
        pParam,
        pParamArray,
        sizeof(AUDIT_PARAM) * NumParams
        );

Cleanup:    
    if ( dwError != NO_ERROR )
    {
        SetLastError( dwError );
        b = FALSE;
        
        if ( pThreadSID != NULL )
        {
            LocalFree( pThreadSID );
        }
    }

    return b;
}


BOOL
AuthziInitializeAuditParams(
    IN  DWORD         dwFlags,
    OUT PAUDIT_PARAMS pParams,
    OUT PSID*         ppUserSid,
    IN  PCWSTR        SubsystemName,
    IN  USHORT        NumParams,
    ...
    )
/*++

Routine Description:

    Initialize the AUDIT_PARAMS structure based on the passed
    data.

    The caller passes in type ~ value pairs in the vararg section.
    This function will initialize the corresponding array elements
    based on each such pair. In case of certain types, there may
    be more than one value argument required. This requirement
    is documented next to each param-type.

Arguments:

    pParams       - pointer to AUDIT_PARAMS structure to be initialized
                    the size of pParams->Parameters member must be big enough
                    to hold NumParams elements. The caller must allocate
                    memory for this structure and its members.

    ppUserSid     - pointer to user sid allocated. This sid is referenced
                    by the first parameter (index 0) in AUDIT_PARAMS structure.
                    The caller should free this by calling LocalFree
                    *after* freeing the AUDIT_PARAMS structure.

    SubsystemName - name of Subsystem that is generating audit

    dwFlags       - control flags. one or more of the following:
                    APF_AuditSuccess

    NumParams     - number of parameters passed in the var-arg section.
                    This must be SE_MAX_AUDIT_PARAMETERS or less.

    ...           - The format of the variable arg portion is as follows:
                    
                    <one of APT_ * flags> <zero or more values>

                    APT_String  <pointer to null terminated string>

                                Flags:
                                AP_Filespec  : treats the string as a filename
                    
                    APT_Ulong   <ulong value> [<object-type-index>]
                    
                                Flags:
                                AP_FormatHex : number appears in hex
                                               in eventlog
                                AP_AccessMask: number is treated as
                                               an access-mask
                                               Index to object type must follow

                    APT_Pointer <pointer/handle>
                                32 bit on 32 bit systems and
                                64 bit on 64 bit systems

                    APT_Sid     <pointer to sid>

                    APT_LogonId [<logon-id>]
                    
                                Flags:
                                AP_PrimaryLogonId : logon-id is captured
                                                    from the process token.
                                                    No need to specify one.

                                AP_ClientLogonId  : logon-id is captured
                                                    from the thread token.
                                                    No need to specify one.
                                                    
                                no flags          : need to supply a logon-id

                    APT_ObjectTypeList <ptr to obj type list> <obj-type-index>
                                Index to object type must be specified

Return Value:
    TRUE  on success
    FALSE otherwise

    call GetLastError() to retrieve the errorcode,
    which will be one of the following:

    ERROR_INVALID_PARAMETER if one of the params is incorrect
    

Notes:

--*/

{
    DWORD dwError = NO_ERROR;
    BOOL fResult = TRUE;
    USHORT i;
    AUDIT_PARAM_TYPE ParamType;
    AUDIT_PARAM* pParam;
    LUID Luid;
    LUID AuthIdThread, AuthIdProcess;
    BOOL fImpersonating=TRUE;
    ULONG TypeFlags;
    ULONG ParamFlags;
    ULONG ObjectTypeIndex;

    va_list(arglist);
    
    *ppUserSid = NULL;
    
    //
    // the first two params are always fixed. thus the total number
    // is 2 + the passed number.
    //

    if (( (NumParams+2) > SE_MAX_AUDIT_PARAMETERS ) ||
        ( pParams == NULL )                         ||
        ( ppUserSid == NULL )                       ||
        ( SubsystemName == NULL )                   ||
        ( dwFlags & ~APF_ValidFlags )
        )
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (!AuthzpGetThreadTokenInfo( ppUserSid, &AuthIdThread ))
    {
        dwError = GetLastError();

        if (dwError == ERROR_NO_TOKEN)
        {
            fImpersonating = FALSE;
            dwError = NO_ERROR;
        }
        else
        {
            goto Cleanup;
        }
    }

    if (!AuthzpGetProcessTokenInfo( fImpersonating ? NULL : ppUserSid,
                                    &AuthIdProcess ))
    {
        dwError = GetLastError();
        goto Cleanup;
    }
        
    va_start (arglist, NumParams);

    pParams->Length = 0;
    pParams->Flags  = dwFlags;
    pParams->Count  = NumParams+2;

    pParam = pParams->Parameters;

    //
    // the first param is always the sid of the user in thread token
    // if thread is not impersonating, sid in the primary token is used.
    //

    pParam->Type    = APT_Sid;
    pParam->Data0   = (ULONG_PTR) *ppUserSid;

    pParam++;

    //
    // the second param is always the sub-system name
    //

    pParam->Type    = APT_String;
    pParam->Data0   = (ULONG_PTR) SubsystemName;

    pParam++;
    
    //
    // now initialize the rest using the var-arg portion
    //

    for ( i=0; i<NumParams; i++, pParam++ )
    {
        TypeFlags = va_arg(arglist, ULONG);

        ParamType  = ApExtractType(TypeFlags);
        ParamFlags = ApExtractFlags(TypeFlags);
        
        pParam->Type = ParamType;

        switch( ParamType )
        {
            default:
                dwError = ERROR_INVALID_PARAMETER;
                break;
                
            case APT_Pointer:
            case APT_String:
            case APT_Sid:
                pParam->Data0 = (ULONG_PTR) va_arg(arglist, PVOID);
                break;
                
            case APT_Ulong:
                pParam->Data0 = va_arg(arglist, ULONG);

                //
                // in case of an access-mask, store the object-type index
                // This is because, the meaning of the access-mask bits
                // cannot be determined without knowing the object type.
                //

                if (ParamFlags & AP_AccessMask)
                {
                    ObjectTypeIndex = va_arg(arglist, ULONG);
                    //
                    // The object-type-index:
                    // - must have been specified earlier
                    // - must be specified as a string.
                    //

                    if ( ( ObjectTypeIndex >= i ) ||
                         ( pParams->Parameters[ObjectTypeIndex].Type !=
                           APT_String ) )
                    {
                        dwError = ERROR_INVALID_PARAMETER;
                    }
                    else
                    {
                        pParam->Data1 = ObjectTypeIndex;
                    }
                }
                pParam->Flags   = ParamFlags;
                break;
                
            case APT_LogonId:
                if (ParamFlags & AP_PrimaryLogonId)
                {
                    //
                    // use the captured process token info
                    //

                    pParam->Data0 = AuthIdProcess.LowPart;
                    pParam->Data1 = AuthIdProcess.HighPart;
                }
                else if (ParamFlags & AP_ClientLogonId)
                {
                    //
                    // use the captured thread token info
                    //

                    pParam->Data0 = AuthIdThread.LowPart;
                    pParam->Data1 = AuthIdThread.HighPart;
                }
                else
                {
                    //
                    // no flag is specified, use the supplied logon-id
                    //

                    Luid = va_arg(arglist, LUID);
                    pParam->Data0 = Luid.LowPart;
                    pParam->Data1 = Luid.HighPart;
                }
                break;

            case APT_ObjectTypeList:
                pParam->Data0 = (ULONG_PTR) va_arg(arglist,
                                                   AUDIT_OBJECT_TYPES*);
                pParam->Data1 = va_arg(arglist, ULONG);
                break;
        }

        if (dwError != NO_ERROR)
        {
            break;
        }
    }

Cleanup:    
    if ( dwError != NO_ERROR )
    {
        SetLastError( dwError );
        fResult = FALSE;
        
        if ( *ppUserSid != NULL )
        {
            LocalFree( *ppUserSid );
            *ppUserSid = NULL;
        }
    }

    va_end (arglist);
    return fResult;
}


BOOL
AuthziFreeAuditParams(
    PAUDIT_PARAMS pParams
    )

/*++

Routine Description

    Frees the AUDIT_PARAMS created by AuthzAllocateInitializeAuditParamsWithRM.

Arguments

    pParams - pointer to AUDIT_PARAMS.

Return Value

    Boolean: TRUE on success, FALSE on failure.

--*/

{
    if (!ARGUMENT_PRESENT(pParams))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    AuthzpFree(pParams);
    return TRUE;
}



BOOL
AuthziInitializeAuditEvent(
    IN  DWORD                         Flags,
    IN  AUTHZ_RESOURCE_MANAGER_HANDLE hRM,
    IN  AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET OPTIONAL,
    IN  PAUDIT_PARAMS                 pAuditParams OPTIONAL,
    IN  AUTHZ_AUDIT_QUEUE_HANDLE      hAuditQueue OPTIONAL,
    IN  DWORD                         dwTimeOut,
    IN  PWSTR                         szOperationType,
    IN  PWSTR                         szObjectType,
    IN  PWSTR                         szObjectName,
    IN  PWSTR                         szAdditionalInfo OPTIONAL,
    OUT PAUTHZ_AUDIT_EVENT_HANDLE     phAuditEvent
    )

/*++

Routine Description:

    Allocates and initializes an AUTHZ_AUDIT_EVENT_HANDLE.  The handle is used for storing information 
    for audit generation per AuthzAccessCheck().  
    
Arguments:

    phAuditEvent - pointer to AUTHZ_AUDIT_EVENT_HANDLE.  Space for this is allocated in the function.

    Flags - Audit flags.  Currently defined bits are:
        AUTHZ_NO_SUCCESS_AUDIT - disables generation of success audits
        AUTHZ_NO_FAILURE_AUDIT - disables generation of failure audits
        AUTHZ_DS_CATEGORY_FLAG - swithces the default audit category from OBJECT_ACCESS to DS_ACCESS.
        AUTHZ_NO_ALLOC_STRINGS - storage space is not allocated for the 4 wide character strings.  Rather,
            the handle will only hold pointers to resource manager memory.
            
    hRM - handle to a Resource Manager.            
    
    hAET - pointer to an AUTHZ_AUDIT_EVENT_TYPE structure.  This is needed if the resource manager
        is creating its own audit types.  This is not needed for generic object operation audits.  
        
    pAuditParams - If this is specified, then pAuditParams will be used to 
        create the audit.  If NULL is passed, then a generic AUDIT_PARAMS will
        be constructed that is suitable for the generic object access audit.  

    hAuditQueue - queue object created with AuthzInitializeAuditQueue.  If none is specified, the 
        default RM queue will be used.
        
    dwTimeOut - milliseconds that a thread attempting to generate an audit with this 
        AUTHZ_AUDIT_EVENT_HANDLE should wait for access to the queue.  Use INFINITE to 
        specify an unlimited timeout.
                     
    szOperationType - Resource manager defined string that indicates the operation being
        performed that is to be audited.

    szObjectType - Resource manager defined string that indicates the type of object being
        accessed.

    szObjectName - the name of the specific object being accessed.
    
    szAdditionalInfo - Resource Manager defined string for additional audit information.

Return Value:

    Returns TRUE if successful, FALSE if unsuccessful.  
    Extended information available with GetLastError().    
    
--*/

{
    PAUTHZI_AUDIT_EVENT      pAuditEvent            = NULL;
    BOOL                     b                      = TRUE;
    BOOL                     bRef                   = FALSE;
    DWORD                    dwStringSize           = 0;
    DWORD                    dwObjectTypeLength     = 0;
    DWORD                    dwObjectNameLength     = 0;
    DWORD                    dwOperationTypeLength  = 0;
    DWORD                    dwAdditionalInfoLength = 0;
    PAUTHZI_RESOURCE_MANAGER pRM                    = (PAUTHZI_RESOURCE_MANAGER) hRM;

    if (!ARGUMENT_PRESENT(phAuditEvent)                                ||
        (!ARGUMENT_PRESENT(hAET) && !ARGUMENT_PRESENT(hRM))            ||
        !ARGUMENT_PRESENT(szOperationType)                             ||
        !ARGUMENT_PRESENT(szObjectType)                                ||
        !ARGUMENT_PRESENT(szObjectName)                                ||
        !ARGUMENT_PRESENT(szAdditionalInfo))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *phAuditEvent = NULL;
    
    //
    // Allocate and initialize a new AUTHZI_AUDIT_EVENT.
    //

    if (FLAG_ON(Flags, AUTHZ_NO_ALLOC_STRINGS))
    {
        dwStringSize = 0;
    } 
    else
    {
        dwOperationTypeLength  = (DWORD) wcslen(szOperationType) + 1;
        dwObjectTypeLength     = (DWORD) wcslen(szObjectType) + 1;
        dwObjectNameLength     = (DWORD) wcslen(szObjectName) + 1;
        dwAdditionalInfoLength = (DWORD) wcslen(szAdditionalInfo) + 1;

        dwStringSize = sizeof(WCHAR) * (dwOperationTypeLength + dwObjectTypeLength + dwObjectNameLength + dwAdditionalInfoLength);
    }

    pAuditEvent = (PAUTHZI_AUDIT_EVENT) AuthzpAlloc(sizeof(AUTHZI_AUDIT_EVENT) + dwStringSize);

    if (AUTHZ_ALLOCATION_FAILED(pAuditEvent))
    {
        b = FALSE;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Cleanup;
    }

    RtlZeroMemory(
        pAuditEvent, 
        sizeof(AUTHZI_AUDIT_EVENT) + dwStringSize
        );
    

    if (FLAG_ON(Flags, AUTHZ_NO_ALLOC_STRINGS))
    {
        pAuditEvent->szOperationType  = szOperationType;
        pAuditEvent->szObjectType     = szObjectType;
        pAuditEvent->szObjectName     = szObjectName;
        pAuditEvent->szAdditionalInfo = szAdditionalInfo;
    }
    else
    {
        //
        // Set the string pointers into the contiguous memory.
        //

        pAuditEvent->szOperationType  = (PWSTR)((PUCHAR)pAuditEvent + sizeof(AUTHZI_AUDIT_EVENT));
    
        pAuditEvent->szObjectType     = (PWSTR)((PUCHAR)pAuditEvent + sizeof(AUTHZI_AUDIT_EVENT) 
                                               + (sizeof(WCHAR) * dwOperationTypeLength));

        pAuditEvent->szObjectName     = (PWSTR)((PUCHAR)pAuditEvent + sizeof(AUTHZI_AUDIT_EVENT) 
                                               + (sizeof(WCHAR) * (dwOperationTypeLength + dwObjectTypeLength)));

        pAuditEvent->szAdditionalInfo = (PWSTR)((PUCHAR)pAuditEvent + sizeof(AUTHZI_AUDIT_EVENT) 
                                               + (sizeof(WCHAR) * (dwOperationTypeLength + dwObjectTypeLength + dwObjectNameLength)));

        RtlCopyMemory(
            pAuditEvent->szOperationType,
            szOperationType,
            sizeof(WCHAR) * dwOperationTypeLength
            );

        RtlCopyMemory(
            pAuditEvent->szObjectType,
            szObjectType,
            sizeof(WCHAR) * dwObjectTypeLength
            );

        RtlCopyMemory(
            pAuditEvent->szObjectName,
            szObjectName,
            sizeof(WCHAR) * dwObjectNameLength
            );

        RtlCopyMemory(
            pAuditEvent->szAdditionalInfo,
            szAdditionalInfo,
            sizeof(WCHAR) * dwAdditionalInfoLength
            );
    }

    //
    // Use the passed audit event type if present, otherwise use the RM's generic Audit Event.
    //

    if (ARGUMENT_PRESENT(hAET))
    {
        pAuditEvent->hAET = hAET;
    }
    else
    {
        if (FLAG_ON(Flags, AUTHZ_DS_CATEGORY_FLAG))
        {
            pAuditEvent->hAET = pRM->hAETDS;
        }
        else
        {
            pAuditEvent->hAET = pRM->hAET;
        }
    }

    AuthzpReferenceAuditEventType(pAuditEvent->hAET);
    bRef = TRUE;

    //
    // Use the specified queue, if it exists.  Else use the RM queue.
    //

    if (ARGUMENT_PRESENT(hAuditQueue))
    {
        pAuditEvent->hAuditQueue = hAuditQueue;
    }
    else if (ARGUMENT_PRESENT(hRM))
    {
        pAuditEvent->hAuditQueue = pRM->hAuditQueue;
    } 

    pAuditEvent->pAuditParams = pAuditParams;
    pAuditEvent->Flags        = Flags;
    pAuditEvent->dwTimeOut    = dwTimeOut;
    pAuditEvent->dwSize       = sizeof(AUTHZI_AUDIT_EVENT) + dwStringSize;

Cleanup:

    if (!b)
    {
        if (bRef)
        {
            AuthzpDereferenceAuditEventType(pAuditEvent->hAET);
        }
        AuthzpFreeNonNull(pAuditEvent);
    }
    else
    {
        *phAuditEvent = (AUTHZ_AUDIT_EVENT_HANDLE) pAuditEvent;
    }
    return b;
}



BOOL
AuthziModifyAuditEvent(
    IN DWORD                    Flags,
    IN AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent,
    IN DWORD                    NewFlags,
    IN PWSTR                    szOperationType,
    IN PWSTR                    szObjectType,
    IN PWSTR                    szObjectName,
    IN PWSTR                    szAdditionalInfo
    )

/*++

Routine Description

Arguments

    Flags - flags to specify which field of the hAuditEvent to modify.  Valid flags are:
        
        AUTHZ_AUDIT_EVENT_FLAGS           
        AUTHZ_AUDIT_EVENT_OPERATION_TYPE  
        AUTHZ_AUDIT_EVENT_OBJECT_TYPE     
        AUTHZ_AUDIT_EVENT_OBJECT_NAME     
        AUTHZ_AUDIT_EVENT_ADDITIONAL_INFO 
        
    hAuditEvent - handle to modify.  Must be created with AUTHZ_NO_ALLOC_STRINGS flag.

    NewFlags - replacement flags for hAuditEvent.
    
    szOperationType - replacement string for hAuditEvent.
    
    szObjectType - replacement string for hAuditEvent.
    
    szObjectName - replacement string for hAuditEvent.
    
    szAdditionalInfo - replacement string for hAuditEvent.
    
Return Value
    
    Boolean: TRUE on success; FALSE on failure.  Extended information available with GetLastError().
    
--*/

{
    PAUTHZI_AUDIT_EVENT pAuditEvent = (PAUTHZI_AUDIT_EVENT) hAuditEvent;

    if ((!ARGUMENT_PRESENT(hAuditEvent))                       ||
        (Flags & ~AUTHZ_VALID_MODIFY_AUDIT_EVENT_FLAGS)        ||
        (!FLAG_ON(pAuditEvent->Flags, AUTHZ_NO_ALLOC_STRINGS)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (FLAG_ON(Flags, AUTHZ_AUDIT_EVENT_FLAGS))
    {
       pAuditEvent->Flags = NewFlags;
    }

    if (FLAG_ON(Flags, AUTHZ_AUDIT_EVENT_OPERATION_TYPE))
    {
       pAuditEvent->szOperationType = szOperationType;
    }

    if (FLAG_ON(Flags, AUTHZ_AUDIT_EVENT_OBJECT_TYPE))
    {
       pAuditEvent->szObjectType = szObjectType;
    }
    
    if (FLAG_ON(Flags, AUTHZ_AUDIT_EVENT_OBJECT_NAME))
    {
        pAuditEvent->szOperationType = szObjectName;
    }
    
    if (FLAG_ON(Flags, AUTHZ_AUDIT_EVENT_ADDITIONAL_INFO))
    {
        pAuditEvent->szAdditionalInfo = szAdditionalInfo;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\adtgen.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T G E N . C
//
// Contents:    definitions of types/functions required for 
//              generating generic audits.
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "authz.h"

//------------------------------------------------------------------------
//
// internal routines
//
NTSTATUS
LsapApiReturnResult(
    ULONG ExceptionCode
    );


//------------------------------------------------------------------------


BOOL
AuthzpRegisterAuditEvent(
    IN  PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType,
    OUT AUDIT_HANDLE*     phAuditContext
    )
/*++

Routine Description:
    Register the specified event with LSA. This causes LSA to
    generate and return an audit context. This context handle
    is required to publish event of the specified type.

Arguments:
    pAuditEventType - pointer to audit event info structure
                      that defines which event to register.

    phAuditContext  - pointer to audit context handle returned

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:
    Note that this function does NOT register the schema of an event. It is
    assumed that the schema has been registered *before* calling
    this function.

    The schema of legacy audit events is stored in a .mc file.

--*/
{
    DWORD dwStatus;
    
    //
    // since we use the same var to store NTSTATUS and win32 error
    // make sure that this is not a problem
    //
    ASSERT( sizeof(NTSTATUS) == sizeof(DWORD) );

    //
    // we generate a unique ID and store it in the audit handle
    // the server will copy this into the corresponding structure
    // on the server side. This ID allows us to track which server side
    // audit-context corresponds to which client side event handle.
    // This is very useful in debugging.
    //
    NtAllocateLocallyUniqueId( &pAuditEventType->LinkId );
    
    RpcTryExcept
    {
        dwStatus = LsarRegisterAuditEvent( pAuditEventType, phAuditContext );
    }
    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
    {
        dwStatus = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;
    

    if (!NT_SUCCESS(dwStatus))
    {
        dwStatus = RtlNtStatusToDosError( dwStatus );
        SetLastError( dwStatus );
        
        return FALSE;
    }
    
    return TRUE;
}


BOOL
AuthzpSendAuditToLsa(
    IN AUDIT_HANDLE  hAuditContext,
    IN DWORD         dwFlags,
    IN AUDIT_PARAMS* pAuditParams,
    IN PVOID         pReserved
    )
/*++

Routine Description:
    Send an event to LSA for publishing. 
    

Arguments:

    hAuditContext - handle of audit-context previously obtained
                    by calling LsaRegisterAuditEvent

    dwFlags       - TBD

    pAuditParams  - pointer to audit event parameters

    pReserved     - reserved for future enhancements

Return Value:

    STATUS_SUCCESS         -- if all is well
    NTSTATUS error code otherwise.

Notes:

--*/
{
    DWORD dwStatus;
    
    UNREFERENCED_PARAMETER(pReserved);

    //
    // since we use the same var to store NTSTATUS and win32 error
    // make sure that this is not a problem
    //
    ASSERT( sizeof(NTSTATUS) == sizeof(DWORD) );
    
    RpcTryExcept
    {
        dwStatus = LsarGenAuditEvent( hAuditContext, dwFlags, pAuditParams );
    }
    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
    {
        dwStatus = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;

    if (!NT_SUCCESS(dwStatus))
    {
        dwStatus = RtlNtStatusToDosError( dwStatus );
        SetLastError( dwStatus );
        
        return FALSE;
    }
    
    return TRUE;
}


BOOL
AuthzpUnregisterAuditEvent(
    IN OUT AUDIT_HANDLE* phAuditContext
    )
/*++

Routine Description:
    Unregister the specified event. This causes LSA to
    free resources associated with the context.
    

Arguments:

    hAuditContext -  handle to the audit context to unregister

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:


--*/
{
    DWORD dwStatus;
    
    //
    // since we use the same var to store NTSTATUS and win32 error
    // make sure that this is not a problem
    //
    ASSERT( sizeof(NTSTATUS) == sizeof(DWORD) );
    
    RpcTryExcept
    {
        dwStatus = LsarUnregisterAuditEvent( phAuditContext );
    }
    RpcExcept( EXCEPTION_EXECUTE_HANDLER )
    {
        dwStatus = LsapApiReturnResult(I_RpcMapWin32Status(RpcExceptionCode()));

    } RpcEndExcept;
    
    if (!NT_SUCCESS(dwStatus))
    {
        dwStatus = RtlNtStatusToDosError( dwStatus );
        SetLastError( dwStatus );
        
        return FALSE;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\asn1\asn1c\write.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

#define IDCHRSET "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"

#define INDENT 4
#define TABSIZE 8

static FILE *fout;
static int xcurrindent = 0;
static int xindentflag = 0;
static char *xbuf = 0;
static int xbufsize = 0;
static int xbuflen = 0;
static int ycurrindent = 1;
static char *ybuf = 0;
static int ybufsize = 0;
static int ybuflen = 0;

void xputc(char c);
void xputs(char *s);
void xflush();
void yputc(char c);
void yputs(char *s);
void yflush();

/* set the output file */
void
setoutfile(FILE *f)
{
    xflush();
    fout = f;
}

/* print indentation up to current indentation level */
static void
findent()
{
    int indent;

    indent = xcurrindent * INDENT;
    while (indent >= TABSIZE) {
	xputc('\t');
	indent -= TABSIZE;
    }
    while (indent-- > 0)
	xputc(' ');
}

/* print indentation up to current indentation level */
/* but expect one character to be printed already */
static void
findent1()
{
    int indent;

    indent = xcurrindent * INDENT;
    if (indent > 0 && indent < TABSIZE)
	indent--;
    while (indent >= TABSIZE) {
	xputc('\t');
	indent -= TABSIZE;
    }
    while (indent-- > 0)
	xputc(' ');
}

/* output function doing indentation automatically */
void
outputv(const char *format, va_list args)
{
    static char buf[4098];
    static int pos = 0;
    char *p, *q;
    int l;
    
    /* get the string to write */
    vsprintf(buf + pos, format, args);

    /* print it line by line */
    for (p = buf; *p; p = q) {
	q = strchr(p, '\n');
	if (!q) {
	    for (q = buf; *p;)
		*q++ = *p++;
	    *q = 0;
	    pos = q - buf;
	    return;
	}
	*q++ = 0;

	/* examine the first character for correct indentation */
	if (strchr(IDCHRSET, *p)) {
	    l = strspn(p, IDCHRSET);
	} else if (*p == '{' || *p == '}' || *p == '*' || *p == '&' ||
	    *p == '(' || *p == ')' || *p == '#') {
	    l = 1;
	} else {
	    l = 0;
	}

	if (!l) {

	    /* no indentation at all */
	    xputs(p);
	    xputc('\n');
	    continue;
	}

	if (p[0] == '#') {

	    /* preprocessor directive: indent after # */
	    xputc('#');
	    findent1();
	    xputs(p + 1);
	    xputc('\n');
	    continue;
	}

	/* closing brace? then unindent */
	if (p[0] == '}')
	    xcurrindent--;

	/* print the indentation, but labels will be less indented */
	if (p[strlen(p) - 1] == ':') {
	    xcurrindent--;
	    findent();
	    xcurrindent++;
	} else {
	    findent();
	}

	/* output the line */
	xputs(p);
	xputc('\n');

	/* back at indentation level 0? then we can flush our buffers */
	/* first the variables then the other lines */
	if (!xcurrindent) {
	    yflush();
	    xflush();
	}

	/* undo indentation of non-braced if/else/switch/for/while/do stmt */
	if (xindentflag) {
	    xcurrindent--;
	    xindentflag = 0;
	}

	/* indent after opening brace */
	if (p[strlen(p) - 1] == '{') {
	    xcurrindent++;
	    xindentflag = 0;

	/* indent one line after if/else/switch/for/while/do stmt */
	} else if (l == 2 && !memcmp(p, "if", l) ||
	    l == 4 && !memcmp(p, "else", l) ||
	    l == 6 && !memcmp(p, "switch", l) ||
	    l == 3 && !memcmp(p, "for", l) ||
	    l == 5 && !memcmp(p, "while", l) ||
	    l == 2 && !memcmp(p, "do", l)) {
	    xcurrindent++;
	    xindentflag = 1;
	}
    }

    /* empty buffer after printing */
    pos = 0;
}

/* output function doing indentation automatically */
/*PRINTFLIKE1*/
void
output(const char *format, ...)
{
    va_list args;

    va_start(args, format);
    outputv(format, args);
    va_end(args);
}

/* output function without indentation */
void
outputniv(const char *format, va_list args)
{
    static char buf[512];

    vsprintf(buf, format, args);
    xputs(buf);
}

/* output function without indentation */
/*PRINTFLIKE1*/
void
outputni(const char *format, ...)
{
    va_list args;

    va_start(args, format);
    outputniv(format, args);
    va_end(args);
}

/* output an intx value definition */
void
outputintx(const char *name, intx_t *val)
{
    outputoctets(name, val->length, val->value);
    output("static ASN1intx_t %s = { %d, %s_octets };\n",
	name, val->length, name);
}

/* output an real value definition */
void
outputreal(const char *name, real_t *val)
{
    char buf[256];
    switch (val->type) {
    case eReal_Normal:
	sprintf(buf, "%s_mantissa", name);
	outputoctets(buf, val->mantissa.length, val->mantissa.value);
	sprintf(buf, "%s_exponent", name);
	outputoctets(buf, val->exponent.length, val->exponent.value);
	output("ASN1real_t %s = { eReal_Normal, { %u, %s_mantissa_octets }, %u, { %u, %s_exponent_octets } };\n",
	    name, val->mantissa.length, name,
	    val->base, val->exponent.length, name);
	break;
    case eReal_PlusInfinity:
	output("ASN1real_t %s = { eReal_PlusInfinity };\n", name);
	break;
    case eReal_MinusInfinity:
	output("ASN1real_t %s = { eReal_MinusInfinity };\n", name);
	break;
    }
}

/* output an octet array definition */
void
outputoctets(const char *name, uint32_t length, octet_t *val)
{
    uint32_t i;
    char buf[1024];
    char *p;

    p = buf;
    for (i = 0; i < length; i++) {
	sprintf(p, "0x%02x", val[i]);
	p += 4;
	if (i < length - 1) {
	    sprintf(p, ", ");
	    p += 2;
	}
    }
    *p = 0;
    output("static ASN1octet_t %s_octets[%u] = { %s };\n",
	name, length, buf);
}

/* output an uint32 array definition */
void
outputuint32s(const char *name, uint32_t length, uint32_t *val)
{
    uint32_t i;
    char buf[256];
    char *p;

    p = buf;
    for (i = 0; i < length; i++) {
	sprintf(p, "%u", val[i]);
	p += strlen(p);
	if (i < length - 1) {
	    sprintf(p, ", ");
	    p += 2;
	}
    }
    *p = 0;
    output("static ASN1uint32_t %s_elems[%u] = { %s };\n",
	name, length, buf);
}

/* output forward declaration for a value */
void
outputvalue0(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value)
{
    Type_t *type;
    char buf[256];
    char *itype;
    int32_t noctets;
    uint32_t zero;
    uint32_t i;
    Value_t *values;
    Component_t *components;
    NamedValue_t *namedvalue;
    int32_t sign;
    char *pszStatic = "extern";

    value = GetValue(ass, value);
    type = GetType(ass, value->Type);
    value = GetValue(ass, value);
    switch (type->Type) {
    case eType_Integer:
	itype = GetIntegerType(ass, type, &sign);
	if (!strcmp(itype, "ASN1intx_t")) {
	    output("%s ASN1octet_t %s_octets[%u];\n", pszStatic,
		ideref, value->U.Integer.Value.length);
	}
	break;
    case eType_Real:
	itype = GetRealType(type);
	if (!strcmp(itype, "ASN1real_t"))
	{
	    switch (value->U.Real.Value.type) {
	    case eReal_Normal:
		output("%s ASN1octet_t %s_mantissa_octets[%u];\n", pszStatic,
		    ideref, value->U.Real.Value.mantissa.length);
		output("%s ASN1octet_t %s_exponent_octets[%u];\n", pszStatic,
		    ideref, value->U.Real.Value.exponent.length);
		break;
	    }
	}
	break;
    case eType_BitString:
	output("%s ASN1octet_t %s_octets[%u];\n", pszStatic,
	    ideref, (value->U.BitString.Value.length + 7) / 8);
	break;
    case eType_OctetString:
	output("%s ASN1octet_t %s_octets[%u];\n", pszStatic,
	    ideref, value->U.OctetString.Value.length);
	break;
    case eType_UTF8String:
	output("%s ASN1wchar_t %s_wchars[%u];\n", pszStatic,
	    ideref, value->U.UTF8String.Value.length);
	break;
    case eType_ObjectIdentifier:
        if (type->PrivateDirectives.fOidPacked ||
            type->PrivateDirectives.fOidArray || g_fOidArray)
        {
            // doing nothing
        }
        else
        {
            output("%s ASN1uint32_t %s_elems[%u];\n", pszStatic,
                ideref, value->U.ObjectIdentifier.Value.length);
        }
        break;
    case eType_BMPString:
    case eType_GeneralString:
    case eType_GraphicString:
    case eType_IA5String:
    case eType_ISO646String:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_UniversalString:
    case eType_VideotexString:
    case eType_VisibleString:
    case eType_RestrictedString:
	itype = GetStringType(ass, type, &noctets, &zero);
	switch (noctets) {
	case 1:
	    output("%s ASN1char_t %s_chars[%u];\n", pszStatic,
		ideref, value->U.RestrictedString.Value.length + zero);
	    break;
	case 2:
	    output("%s ASN1char16_t %s_chars[%u];\n", pszStatic,
		ideref, value->U.RestrictedString.Value.length + zero);
	    break;
	case 4:
	    output("%s ASN1char32_t %s_chars[%u];\n", pszStatic,
		ideref, value->U.RestrictedString.Value.length + zero);
	    break;
	}
	break;
    case eType_ObjectDescriptor:
	output("%s ASN1char_t %s_chars[%u];\n", pszStatic,
	    ideref, value->U.ObjectDescriptor.Value.length + 1);
	break;
    case eType_SequenceOf:
    case eType_SetOf:
        if (type->Rules & (eTypeRules_LengthPointer | eTypeRules_FixedArray))
        {
            for (i = 0, values = value->U.SS.Values; values;
            i++, values = values->Next) {}
            if (value->U.SS.Values) {
            for (i = 0, values = value->U.SS.Values; values;
                i++, values = values->Next) {
                sprintf(buf, "%s_value%d", ideref, i);
                outputvalue0(ass, buf,
                GetTypeName(ass, type->U.SS.Type), values);
            }
            output("%s %s %s_values[%u];\n", pszStatic,
                GetTypeName(ass, type->U.SS.Type),
                ideref, i);
            }
        }
        else
        if (type->Rules & (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList))
        {
            for (i = 0, values = value->U.SS.Values; values;
            i++, values = values->Next) {
            sprintf(buf, "%s_element%d", ideref, i);
            outputvalue0(ass, buf, GetTypeName(ass, type->U.SS.Type),
                values);
            output("%s %s_Element %s_value%d;\n", pszStatic,
                typeref, ideref, i);
            }
        }
        else
        {
            MyAbort();
        }
        break;
    case eType_Sequence:
    case eType_Set:
    case eType_External:
    case eType_EmbeddedPdv:
    case eType_CharacterString:
    case eType_InstanceOf:
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		namedvalue = FindNamedValue(value->U.SSC.NamedValues,
		    components->U.NOD.NamedType->Identifier);
		if (!namedvalue)
		    break;
		sprintf(buf, "%s_%s", ideref,
		    Identifier2C(components->U.NOD.NamedType->Identifier));
		outputvalue0(ass, buf,
		    GetTypeName(ass, components->U.NOD.NamedType->Type),
		    namedvalue->Value);
		break;
	    }
	}
	break;
    }
}

/* output definitions of value components */
void
outputvalue1(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value)
{
    static uint32_t nOidPackedCount = 0;
    Type_t *type;
    char buf[256];
    char *itype;
    int32_t noctets;
    uint32_t zero;
    uint32_t i;
    Value_t *values;
    Component_t *components;
    NamedValue_t *namedvalue;
    int32_t sign;

    value = GetValue(ass, value);
    type = GetType(ass, value->Type);
    value = GetValue(ass, value);
    switch (type->Type) {
    case eType_Integer:
	itype = GetIntegerType(ass, type, &sign);
	if (!strcmp(itype, "ASN1intx_t")) {
	    outputoctets(ideref, value->U.Integer.Value.length,
		value->U.Integer.Value.value);
	}
	break;
    case eType_Real:
	itype = GetRealType(type);
	if (!strcmp(itype, "ASN1real_t")) {
	    switch (value->U.Real.Value.type) {
	    case eReal_Normal:
		sprintf(buf, "%s_mantissa", ideref);
		outputoctets(buf, value->U.Real.Value.mantissa.length,
		    value->U.Real.Value.mantissa.value);
		sprintf(buf, "%s_exponent", ideref);
		outputoctets(buf, value->U.Real.Value.exponent.length,
		    value->U.Real.Value.exponent.value);
		break;
	    }
	}
	break;
    case eType_BitString:
	outputoctets(ideref, (value->U.BitString.Value.length + 7) / 8,
	    value->U.BitString.Value.value);
	break;
    case eType_OctetString:
	outputoctets(ideref, value->U.OctetString.Value.length,
	    value->U.OctetString.Value.value);
	break;
    case eType_UTF8String:
        itype = GetStringType(ass, type, &noctets, &zero);
        output("static ASN1wchar_t %s_wchars[%u] = { ",
        ideref, value->U.UTF8String.Value.length + zero);
        for (i = 0; i < value->U.UTF8String.Value.length; i++) {
            output("0x%x", value->U.UTF8String.Value.value[i]);
            if (i < value->U.UTF8String.Value.length - 1)
                output(", ");
        }
        if (zero) {
            if (value->U.UTF8String.Value.length)
                output(", 0x0");
            else
                output("0x0");
        }
        output(" };\n");
        break;
    case eType_ObjectIdentifier:
        if (type->PrivateDirectives.fOidPacked)
        {
            uint32_t length = value->U.ObjectIdentifier.Value.length;
            uint32_t *val = value->U.ObjectIdentifier.Value.value;
            uint32_t i, j, cb;
            uint32_t count = 0;
            uint32_t node;
            unsigned char aLittleEndian[16];
            char buf[1024];
            char *p = buf;
            sprintf(p, "{");
            p += strlen(p);
            for (i = 0; i < length; i++)
            {
                // get node value
                node = val[i];

                // special case for the first node
                if (0 == i && length > 1)
                {
                    i++;
                    node = node * 40 + val[1];
                }

                // encode this node
                ZeroMemory(aLittleEndian, sizeof(aLittleEndian));
                for (j = 0; node != 0; j++)
                {
                    aLittleEndian[j] = (unsigned char) (node & 0x7f);
                    if (j != 0)
                    {
                        aLittleEndian[j] |= (unsigned char) 0x80;
                    }
                    node >>= 7;
                }
                cb = j ? j : 1; // at least one byte for zero value

                // print out the values
                for (j = 0; j < cb; j ++)
                {
                    count++;
                    sprintf(p, " %u,", (unsigned char) aLittleEndian[cb - j - 1]);
                    p += strlen(p);
                }
            }
            --p; // remove the last ','
            strcpy(p, " }");
            output("static ASN1octet_t s_oid%u[] = %s;\n", nOidPackedCount, buf);
            output("ASN1encodedOID_t %s = { %u, s_oid%u };\n", ideref, count, nOidPackedCount);
            nOidPackedCount++;
        }
        else
        if (type->PrivateDirectives.fOidArray || g_fOidArray)
        {
            uint32_t length = value->U.ObjectIdentifier.Value.length;
            uint32_t *val = value->U.ObjectIdentifier.Value.value;
            uint32_t i;
            char buf[1024];
            char *p = buf;
            sprintf(p, "{ ");
            p += strlen(p);
            for (i = 0; i < length; i++)
            {
                if (i == length - 1)
                {
                    sprintf(p, "%u }", val[i]);
                }
                else
                {
                    sprintf(p, "%u, ", val[i]);
                }
                p += strlen(p);
            }
            *p = 0;
            output("ASN1objectidentifier2_t %s = {\n%u, %s\n};\n", ideref, length, buf);
        }
        else
        {
            uint32_t length = value->U.ObjectIdentifier.Value.length;
            uint32_t *val = value->U.ObjectIdentifier.Value.value;
            uint32_t i;
            char buf[1024];
            char *p = buf;
            for (i = 0; i < length; i++)
            {
                if (i == length - 1)
                {
                    sprintf(p, "{ NULL, %u }", val[i]);
                }
                else
                {
                    sprintf(p, "{ (ASN1objectidentifier_t) &(%s_list[%u]), %u },\n", ideref, i+1, val[i]);
                }
                p += strlen(p);
            }
            *p = 0;
            output("static const struct ASN1objectidentifier_s %s_list[%u] = {\n%s\n};\n",
            ideref, length, buf);
        }
        break;
    case eType_BMPString:
    case eType_GeneralString:
    case eType_GraphicString:
    case eType_IA5String:
    case eType_ISO646String:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_UniversalString:
    case eType_VideotexString:
    case eType_VisibleString:
    case eType_RestrictedString:
	itype = GetStringType(ass, type, &noctets, &zero);
	switch (noctets) {
	case 1:
	    output("static ASN1char_t %s_chars[%u] = { ",
		ideref, value->U.RestrictedString.Value.length + zero);
	    break;
	case 2:
	    output("static ASN1char16_t %s_chars[%u] = { ",
		ideref, value->U.RestrictedString.Value.length + zero);
	    break;
	case 4:
	    output("static ASN1char32_t %s_chars[%u] = { ",
		ideref, value->U.RestrictedString.Value.length + zero);
	    break;
	}
	for (i = 0; i < value->U.RestrictedString.Value.length; i++) {
	    output("0x%x", value->U.RestrictedString.Value.value[i]);
	    if (i < value->U.RestrictedString.Value.length - 1)
		output(", ");
	}
	if (zero) {
	    if (value->U.RestrictedString.Value.length)
		output(", 0x0");
	    else
		output("0x0");
	}
	output(" };\n");
	break;
    case eType_ObjectDescriptor:
	output("static ASN1char_t %s_chars[%u] = { ",
	    ideref, value->U.ObjectDescriptor.Value.length + 1);
	for (i = 0; i < value->U.ObjectDescriptor.Value.length; i++) {
	    output("0x%x, ", value->U.ObjectDescriptor.Value.value[i]);
	}
	output("0x0 };\n");
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	if (type->Rules & 
	    (eTypeRules_LengthPointer | eTypeRules_FixedArray)) {
	    if (value->U.SS.Values) {
		for (i = 0, values = value->U.SS.Values; values;
		    i++, values = values->Next) {
		    sprintf(buf, "%s_value%d", ideref, i);
		    outputvalue1(ass, buf,
			GetTypeName(ass, type->U.SS.Type),
			values);
		}
		output("static %s %s_values[%u] = { ",
		    GetTypeName(ass, type->U.SS.Type),
		    ideref, i);
		for (i = 0, values = value->U.SS.Values; values;
		    i++, values = values->Next) {
		    if (i)
			output(", ");
		    sprintf(buf, "%s_value%d", ideref, i);
		    outputvalue2(ass, buf, values);
		}
		output(" };\n");
	    }
	} else if (type->Rules &
	    (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList)) {
	    for (i = 0, values = value->U.SS.Values; values;
		i++, values = values->Next) {
		sprintf(buf, "%s_element%d", ideref, i);
		outputvalue1(ass, buf, GetTypeName(ass, type->U.SS.Type),
		    values);
	    }
	    for (i = 0, values = value->U.SS.Values; values;
		i++, values = values->Next) {
		output("static %s_Element %s_value%d = { ",
		    typeref, ideref, i);
		if (values->Next)
		    output("&%s_value%d, ", ideref, i + 1);
		else
		    output("0, ");
		if (type->Rules & eTypeRules_DoublyLinkedList) {
		    if (i)
			output("&%s_value%d, ", ideref, i - 1);
		    else
			output("0, ");
		}
		sprintf(buf, "%s_element%d", ideref, i);
		outputvalue2(ass, buf, values);
		output(" };\n");
	    }
	} else {
	    MyAbort();
	}
	break;
    case eType_Sequence:
    case eType_Set:
    case eType_External:
    case eType_EmbeddedPdv:
    case eType_CharacterString:
    case eType_InstanceOf:
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		namedvalue = FindNamedValue(value->U.SSC.NamedValues,
		    components->U.NOD.NamedType->Identifier);
		if (!namedvalue)
		    break;
		sprintf(buf, "%s_%s", ideref,
		    Identifier2C(components->U.NOD.NamedType->Identifier));
		outputvalue1(ass, buf,
		    GetTypeName(ass, components->U.NOD.NamedType->Type),
		    namedvalue->Value);
		break;
	    }
	}
	break;
    case eType_Choice:
	namedvalue = value->U.Choice.NamedValues;
	components = FindComponent(ass, type->U.Choice.Components,
	    namedvalue->Identifier);
	sprintf(buf, "%s_%s", ideref,
	    Identifier2C(components->U.NOD.NamedType->Identifier));
	outputvalue1(ass, buf, GetTypeName(ass,
	    components->U.NOD.NamedType->Type),
	    namedvalue->Value);
	output("static %s %s = ",
	    GetTypeName(ass, components->U.NOD.NamedType->Type), buf);
	outputvalue2(ass, buf, namedvalue->Value);
	output(";\n");
	break;
    }
}

/* output definition of value */
void
outputvalue2(AssignmentList_t ass, char *ideref, Value_t *value)
{
    Type_t *type;
    char buf[256];
    char *itype;
    int32_t noctets;
    uint32_t zero;
    uint32_t i;
    Value_t *values;
    Component_t *components;
    NamedValue_t *namedvalue;
    char *comma;
    uint32_t ext;
    uint32_t opt;
    int32_t sign;

    value = GetValue(ass, value);
    type = GetType(ass, value->Type);
    value = GetValue(ass, value);
    switch (type->Type) {
    case eType_Boolean:
	output("%d", value->U.Boolean.Value);
	break;
    case eType_Integer:
	itype = GetIntegerType(ass, type, &sign);
	if (!strcmp(itype, "ASN1intx_t")) {
	    output("{ %d, %s_octets }", value->U.Integer.Value.length, ideref);
	} else if (sign > 0) {
	    output("%u", intx2uint32(&value->U.Integer.Value));
	} else {
	    output("%d", intx2int32(&value->U.Integer.Value));
	}
	break;
    case eType_Enumerated:
	output("%u", value->U.Enumerated.Value);
	break;
    case eType_Real:
	itype = GetRealType(type);
	if (!strcmp(itype, "ASN1real_t")) {
	    switch (value->U.Real.Value.type) {
	    case eReal_Normal:
		output("{ eReal_Normal, { %u, %s_mantissa_octets }, %u, { %u, %s_exponent_octets } }",
		    value->U.Real.Value.mantissa.length, ideref,
		    value->U.Real.Value.base,
		    value->U.Real.Value.exponent.length, ideref);
		break;
	    case eReal_PlusInfinity:
		output("{ eReal_PlusInfinity }");
		break;
	    case eReal_MinusInfinity:
		output("{ eReal_MinusInfinity }");
		break;
	    }
	}
	else
	{
	    switch (value->U.Real.Value.type) {
	    case eReal_Normal:
		output("%g", real2double(&value->U.Real.Value));
		break;
	    case eReal_PlusInfinity:
	    case eReal_MinusInfinity:
		output("0.0");
		break;
	    }
	}
	break;
    case eType_BitString:
	output("{ %u, %s_octets }",
	    value->U.BitString.Value.length, ideref);
	break;
    case eType_OctetString:
	output("{ %u, %s_octets }",
	    value->U.OctetString.Value.length, ideref);
	break;
    case eType_UTF8String:
        output("{ %u, %s_utf8chars }",
            value->U.UTF8String.Value.length, ideref);
        break;
    case eType_ObjectIdentifier:
        if (type->PrivateDirectives.fOidPacked)
        {
            // doing nothing
        }
        else
        if (type->PrivateDirectives.fOidArray || g_fOidArray)
        {
            output("(ASN1objectidentifier2_t *) &%s_list", ideref);
        }
        else
        {
            output("(ASN1objectidentifier_t) %s_list", ideref);
        }
        break;
    case eType_BMPString:
    case eType_GeneralString:
    case eType_GraphicString:
    case eType_IA5String:
    case eType_ISO646String:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_UniversalString:
    case eType_VideotexString:
    case eType_VisibleString:
    case eType_RestrictedString:
	itype = GetStringType(ass, type, &noctets, &zero);
	if (zero) {
	    output("%s_chars", ideref);
	} else {
	    output("{ %u, %s_chars }",
		value->U.RestrictedString.Value.length, ideref);
	}
	break;
    case eType_ObjectDescriptor:
	output("%s_chars", ideref);
	break;
    case eType_GeneralizedTime:
	output("{ %d, %d, %d, %d, %d, %d, %d, %d, %d }",
	    value->U.GeneralizedTime.Value.year,
	    value->U.GeneralizedTime.Value.month,
	    value->U.GeneralizedTime.Value.day,
	    value->U.GeneralizedTime.Value.hour,
	    value->U.GeneralizedTime.Value.minute,
	    value->U.GeneralizedTime.Value.second,
	    value->U.GeneralizedTime.Value.millisecond,
	    value->U.GeneralizedTime.Value.universal,
	    value->U.GeneralizedTime.Value.diff);
	break;
    case eType_UTCTime:
	output("{ %d, %d, %d, %d, %d, %d, %d, %d }",
	    value->U.UTCTime.Value.year,
	    value->U.UTCTime.Value.month,
	    value->U.UTCTime.Value.day,
	    value->U.UTCTime.Value.hour,
	    value->U.UTCTime.Value.minute,
	    value->U.UTCTime.Value.second,
	    value->U.UTCTime.Value.universal,
	    value->U.UTCTime.Value.diff);
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	if (type->Rules &
	    (eTypeRules_LengthPointer | eTypeRules_FixedArray)) {
	    if (value->U.SS.Values) {
		for (i = 0, values = value->U.SS.Values; values;
		    i++, values = values->Next) {}
		output("{ %d, %s_values }", i, ideref);
	    } else {
		output("{ 0, NULL }");
	    }
	} else if (type->Rules &
	    (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList)) {
	    output("&%s_value0", ideref);
	} else {
	    MyAbort();
	}
	break;
    case eType_Sequence:
    case eType_Set:
    case eType_External:
    case eType_EmbeddedPdv:
    case eType_CharacterString:
    case eType_InstanceOf:
	comma = "";
	output("{ ");
	if (type->U.SSC.Optionals || type->U.SSC.Extensions) {
	    output("{ ");
	    ext = 0;
	    opt = 0;
	    i = 0;
	    comma = "";
	    for (components = type->U.SSC.Components; components;
		components = components->Next) {
		switch (components->Type) {
		case eComponent_Normal:
		    if (!ext)
			break;
		    /*FALLTHROUGH*/
		case eComponent_Optional:
		case eComponent_Default:
		    namedvalue = FindNamedValue(value->U.SSC.NamedValues,
			components->U.NOD.NamedType->Identifier);
		    if (namedvalue)
			opt |= (0x80 >> i);
		    if (++i > 7) {
			output("%s0x%02x", comma, opt);
			opt = 0;
			i = 0;
			comma = ", ";
		    }
		    break;
		case eComponent_ExtensionMarker:
		    if (i) {
			output("%s0x%02x", comma, opt);
			opt = 0;
			i = 0;
			comma = ", ";
		    }
		    ext = 1;
		    break;
		}
	    }
	    if (i)
		output("%s0x%02x", comma, opt);
	    output(" }");
	    comma = ", ";
	}
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		namedvalue = FindNamedValue(value->U.SSC.NamedValues,
		    components->U.NOD.NamedType->Identifier);
		if (!namedvalue) {
		    output("%s0", comma);
		} else {
		    output("%s", comma);
		    sprintf(buf, "%s_%s", ideref,
			Identifier2C(components->U.NOD.NamedType->Identifier));
		    outputvalue2(ass, buf, namedvalue->Value);
		}
		comma = ", ";
		break;
	    }
	}
	output(" }");
	break;
    case eType_Choice:
	i = ASN1_CHOICE_BASE;
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
		if (!strcmp(value->U.SSC.NamedValues->Identifier,
		    components->U.NOD.NamedType->Identifier))
		    break;
		i++;
		continue;
	    case eComponent_ExtensionMarker:
		continue;
	    default:
		MyAbort();
	    }
	    break;
	}
	output("{ %d }", i);
    }
}

/* output assignments needed in initialization function */
void
outputvalue3(AssignmentList_t ass, char *ideref, char *valref, Value_t *value)
{
    Type_t *type;
    NamedValue_t *named;
    Value_t *values;
    int i;
    char idebuf[256];
    char valbuf[256];
    char *itype;

    value = GetValue(ass, value);
    type = GetType(ass, value->Type);
    switch (type->Type) {
    case eType_SequenceOf:
    case eType_SetOf:
	for (values = value->U.SS.Values, i = 0; values;
	    values = values->Next, i++) {
	    if (type->Rules &
	        (eTypeRules_LengthPointer | eTypeRules_FixedArray)) {
		sprintf(idebuf, "%s.value[%d]", ideref, i);
	    } else if (type->Rules &
		(eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList)) {
		sprintf(idebuf, "%s_value%d", ideref, i);
	    } else {
		MyAbort();
	    }
	    sprintf(valbuf, "%s_value%d", valref, i);
	    outputvalue3(ass, idebuf, valbuf, values);
	}
	break;
    case eType_Choice:
	output("%s.u.%s = %s_%s;\n",
	    ideref, Identifier2C(value->U.SSC.NamedValues->Identifier),
	    valref, Identifier2C(value->U.SSC.NamedValues->Identifier));
	/*FALLTHROUGH*/
    case eType_Sequence:
    case eType_Set:
    case eType_External:
    case eType_EmbeddedPdv:
    case eType_CharacterString:
    case eType_InstanceOf:
	for (named = value->U.SSC.NamedValues; named; named = named->Next) {
	    sprintf(idebuf, "%s.%s", ideref,
		Identifier2C(named->Identifier));
	    sprintf(valbuf, "%s_%s", valref,
		Identifier2C(named->Identifier));
	    outputvalue3(ass, idebuf, valbuf, named->Value);
	}
	break;
    case eType_Real:
	itype = GetRealType(type);
	if (strcmp(itype, "ASN1real_t"))
	{
	    switch (value->U.Real.Value.type) {
	    case eReal_Normal:
		break;
	    case eReal_PlusInfinity:
		output("%s = ASN1double_pinf();\n", ideref);
		break;
	    case eReal_MinusInfinity:
		output("%s = ASN1double_minf();\n", ideref);
		break;
	    }
	}
    }
}

/* print indentation up to current indentation level for variables */
static void
findentvar()
{
    int indent;

    indent = ycurrindent * INDENT;
    while (indent >= TABSIZE) {
	yputc('\t');
	indent -= TABSIZE;
    }
    while (indent--)
	yputc(' ');
}

/* print indentation up to current indentation level for variables */
void
outputvarv(const char *format, va_list args)
{
    static char buf[512];
    static int pos = 0;
    char *p, *q;
    int l;
    
    /* get the string to write */
    vsprintf(buf + pos, format, args);

    /* print it line by line */
    for (p = buf; *p; p = q) {
	q = strchr(p, '\n');
	if (!q) {
	    for (q = buf; *p;)
		*q++ = *p++;
	    *q = 0;
	    pos = q - buf;
	    return;
	}
	*q++ = 0;

	/* output every variable only once */
	if (ycurrindent == 1) {
	    l = 0;
	    while (l < ybuflen) {
		if (!memcmp(ybuf + l + INDENT / TABSIZE + INDENT % TABSIZE,
		    p, strlen(p)))
		    break;
		l += (strchr(ybuf + l, '\n') - (ybuf + l)) + 1;
	    }
	    if (l < ybuflen)
		continue;
	}

	/* examine the first character for correct indentation */
	if (strchr(IDCHRSET, *p)) {
	    l = strspn(p, IDCHRSET);
	} else if (*p == '{' || *p == '}') {
	    l = 1;
	} else {
	    l = 0;
	}

	if (!l) {

	    /* no indentation at all */
	    yputs(p);
	    yputc('\n');
	    continue;
	}

	/* closing brace? then unindent */
	if (p[0] == '}')
	    ycurrindent--;

	/* print indentation */
	findentvar();

	/* output the line */
	yputs(p);
	yputc('\n');

	/* indent after opening brace */
	if (p[strlen(p) - 1] == '{') {
	    ycurrindent++;
	}
    }
    pos = 0;
}

/* print indentation up to current indentation level for variables */
/*PRINTFLIKE1*/
void
outputvar(const char *format, ...)
{
    va_list args;

    va_start(args, format);
    outputvarv(format, args);
    va_end(args);
}

/* output an octet array definition for variables */
void
outputvaroctets(const char *name, uint32_t length, octet_t *val)
{
    uint32_t i;
    char buf[256];
    char *p;

    p = buf;
    for (i = 0; i < length; i++) {
	sprintf(p, "0x%02x", val[i]);
	p += 4;
	if (i < length - 1) {
	    sprintf(p, ", ");
	    p += 2;
	}
    }
    outputvar("static ASN1octet_t %s_octets[%u] = { %s };\n",
	name, length, buf);
}

/* output an intx value definition for variables */
void outputvarintx(const char *name, intx_t *val)
{
    outputvaroctets(name, val->length, val->value);
    outputvar("static ASN1intx_t %s = { %d, %s_octets };\n",
	name, val->length, name);
}

/* output an real value definition for variables */
void outputvarreal(const char *name, real_t *val)
{
    char buf[256];
    switch (val->type) {
    case eReal_Normal:
	sprintf(buf, "%s_mantissa", name);
	outputvaroctets(buf, val->mantissa.length, val->mantissa.value);
	sprintf(buf, "%s_exponent", name);
	outputvaroctets(buf, val->exponent.length, val->exponent.value);
	outputvar("ASN1real_t %s = { eReal_Normal, { %u, %s_mantissa_octets }, %u, { %u, %s_exponent_octets } };\n",
	    name, val->mantissa.length, name,
	    val->base, val->exponent.length, name);
	break;
    case eReal_PlusInfinity:
	outputvar("ASN1real_t %s = { eReal_PlusInfinity };\n", name);
	break;
    case eReal_MinusInfinity:
	outputvar("ASN1real_t %s = { eReal_MinusInfinity };\n", name);
	break;
    }
}

/* output a character of the function body */
void xputc(char c)
{
    if (xbuflen + 1 > xbufsize) {
    	xbufsize += 1024;
	if (!xbuf)
	    xbuf = (char *)malloc(xbufsize);
	else
	    xbuf = (char *)realloc(xbuf, xbufsize);
    }
    xbuf[xbuflen++] = c;
}

/* output a string of the function body */
void xputs(char *s)
{
    int sl;

    sl = strlen(s);
    if (xbuflen + sl > xbufsize) {
	while (xbuflen + sl > xbufsize)
	    xbufsize += 1024;
	if (!xbuf)
	    xbuf = (char *)malloc(xbufsize);
	else
	    xbuf = (char *)realloc(xbuf, xbufsize);
    }
    memcpy(xbuf + xbuflen, s, sl);
    xbuflen += sl;
}

/* flush the function body into the output file */
void xflush()
{
    if (xbuflen) {
	fwrite(xbuf, xbuflen, 1, fout);
#if 0
	fflush(fout);
#endif
	xbuflen = 0;
    }
}

/* output a character of the function variables */
void yputc(char c)
{
    if (ybuflen + 1 > ybufsize) {
    	ybufsize += 1024;
	if (!ybuf)
	    ybuf = (char *)malloc(ybufsize);
	else
	    ybuf = (char *)realloc(ybuf, ybufsize);
    }
    ybuf[ybuflen++] = c;
}

/* output a string of the function variables */
void yputs(char *s)
{
    int sl;

    sl = strlen(s);
    if (ybuflen + sl > ybufsize) {
	while (ybuflen + sl > ybufsize)
	    ybufsize += 1024;
	if (!ybuf)
	    ybuf = (char *)malloc(ybufsize);
	else
	    ybuf = (char *)realloc(ybuf, ybufsize);
    }
    memcpy(ybuf + ybuflen, s, sl);
    ybuflen += sl;
}

/* flush the function variables into the output file */
void yflush()
{
    if (ybuflen) {
	fwrite(ybuf, ybuflen, 1, fout);
#if 0
	fflush(fout);
#endif
	ybuflen = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\adtqueue.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adtqueue.c

Abstract:

   This module implements the routines for the Authz audit queue.

Author:

    Jeff Hamblin - May 2000

Environment:

    User mode only.

Revision History:

    Created - May 2000

--*/

/*++

The Authz Audit Queue Algorithm

    The following are used in the queueing algorithm:

    hAuthzAuditQueueLowEvent - event that is signalled when threads are free 
    to place audits on the queue (queue is below high water mark).  Note that 
    this is an auto reset event: when the event is signalled, exactly one 
    waiting thread is scheduled to run and the event then returns to a 
    nonsignalled state.  

    bAuthzAuditQueueHighEvent - boolean indicating that audits may not be 
    added (queue is over high water mark).  

    hAuthzAuditAddedEvent - event that is signalled when the queue is empty and an 
    audit get placed on the queue.  The dequeueing thread runs when this is signalled.  

    hAuthzAuditQueueEmptyEvent - signals when the queue is empty.  
    
    AuthzAuditQueue - doubly linked list.  This is the audit queue.  

    AuthzAuditQueueLength - The current number of audits in the queue.  

    hAuthzAuditThread - the dequeueing thread.  
        
    AuthzAuditQueueLock - critical section locking the queue and related 
    variables.  

    Assume that the Resource Manager wishes to monitor the queue length and 
    has specified High and Low water marks to control the growth of the queue.  
    If the queue length reaches the High water mark, then all queueing threads 
    will be blocked until the dequeueing thread has reduced the queue length 
    to the Low water mark.  

    Here is the flow of code for a thread attempting to log an audit (via 
    AuthziLogAuditEvent()) when the Resource Manager is monitoring the queue 
    length: 

      if QueueLength > .75 * HighWater          # this is heuristic to save unnecessary         
         wait until the LowEvent is signalled  # kernel transitions
      enter queue critical section
      {
          insert audit on queue
          QueueLength ++
          signal AuditAddedEvent               # notifying the dequeue thread
          if (QueueLength >= HighWater)
          {
            bHigh = TRUE
          }
      } 
      leave critical section    
      
      ...[code overhead, execute cleanup code in AuthziLogAuditEvent ...]
      
      enter queue critical section
      {
          if (!bHigh)
          {   
              if (QueueLength <= HighWater)
              {    
                   signal LowEvent                  #allow other threads to run
              }
          }
                ASSERT(FALSE);
      }                   
      leave critical section
             
Here is the algorithm for the dequeueing thread:

      while (TRUE)
      {
          wait for AuditAdded event
          while (QueueLength > 0)
          {    
              enter queue critical section
              {    
                  remove audit from head of list
                  QueueLength--
                  if (bHigh)
                  {
                      if (QueueLength <= LowWater)
                      {
                          bHigh = FALSE
                          signal LowEvent                 # tell threads it is okay to queue
                      }
                  }
              }
              release critical section
              
              Send to LSA
          }
          
          enter critical section
          {
              if (QueueLength == 0)
              {
                  reset AuditAdded event                 # make myself wait 
              }
          }
          release critical section            
      }

--*/

#include "pch.h"

#pragma hdrstop

#include <authzp.h>
#include <authzi.h>

#ifdef AUTHZ_AUDIT_COUNTER
LONG AuthzpAuditsEnqueued = 0;
LONG AuthzpAuditsDequeued = 0;
#endif


BOOL
AuthzpEnQueueAuditEvent(
    PAUTHZI_AUDIT_QUEUE pQueue,
    PAUTHZ_AUDIT_QUEUE_ENTRY pAudit
    )

/*++

Routine Description

    This enqueues an audit without regard to any queue size limits.  It does minimal event management.
    
Arguments

    pQueue - Pointer to the queue to place the audit on.
    pAudit - Pointer to the audit to enqueue.
    
Return Value

    Boolean, TRUE on success, FALSE on failure.
    Extended information available with GetLastError().
    
--*/

{
    BOOL b = TRUE;

    RtlEnterCriticalSection(&pQueue->AuthzAuditQueueLock);
    InsertTailList(&pQueue->AuthzAuditQueue, &pAudit->list);
    pQueue->AuthzAuditQueueLength++;
    
#ifdef AUTHZ_AUDIT_COUNTER
    InterlockedIncrement(&AuthzpAuditsEnqueued);
#endif

    //
    // Only set the AuditAdded event if the length goes from 0 to 1.  This 
    // saves us redundant kernel transitions.
    //

    if (pQueue->AuthzAuditQueueLength == 1)
    {
        b = SetEvent(pQueue->hAuthzAuditAddedEvent);
        if (!b)
        {
            ASSERT(L"AUTHZ: SetEvent on hAuthzAuditAddedEvent handle failed." && FALSE);
            goto Cleanup;
        }
        
        b = ResetEvent(pQueue->hAuthzAuditQueueEmptyEvent);
        if (!b)
        {
            ASSERT(L"AUTHZ: ResetEvent on hAuthzAuditQueueEmptyEvent handle failed." && FALSE);
            goto Cleanup;
        }
    }

Cleanup:

    RtlLeaveCriticalSection(&pQueue->AuthzAuditQueueLock);
    return b;
}


BOOL
AuthzpEnQueueAuditEventMonitor(
    PAUTHZI_AUDIT_QUEUE pQueue,
    PAUTHZ_AUDIT_QUEUE_ENTRY pAudit
    )

/*++

Routine Description

    This enqueues an audit and sets appropriate events for queue size monitoring.
    
Arguments

    pQueue - pointer to the queue to place audit on.
    pAudit - pointer to the audit to queue.
    
Return Value

    Boolean, TRUE on success, FALSE on failure.
    Extended information available with GetLastError().
    
--*/

{
    BOOL b = TRUE;

    RtlEnterCriticalSection(&pQueue->AuthzAuditQueueLock);
    InsertTailList(&pQueue->AuthzAuditQueue, &pAudit->list);
    pQueue->AuthzAuditQueueLength++;
    
#ifdef AUTHZ_AUDIT_COUNTER
    InterlockedIncrement(&AuthzpAuditsEnqueued);
#endif

    //
    // Only set the AuditAdded event if the length goes from 0 to 1.  This 
    // saves us redundant kernel transitions.
    //

    if (pQueue->AuthzAuditQueueLength == 1)
    {
        b = SetEvent(pQueue->hAuthzAuditAddedEvent);
        if (!b)
        {
            ASSERT(L"AUTHZ: SetEvent on hAuthzAuditAddedEvent handle failed." && FALSE);
            goto Cleanup;
        }

        b = ResetEvent(pQueue->hAuthzAuditQueueEmptyEvent);
        if (!b)
        {
            ASSERT(L"AUTHZ: ResetEvent on hAuthzAuditQueueEmptyEvent handle failed." && FALSE);
            goto Cleanup;
        }
    }

    if (pQueue->AuthzAuditQueueLength >= pQueue->dwAuditQueueHigh)
    {
#ifdef AUTHZ_DEBUG_QUEUE
        wprintf(L"___Setting HIGH water mark ON\n");
        fflush(stdout);
#endif
        pQueue->bAuthzAuditQueueHighEvent = TRUE;
    }

Cleanup:

    RtlLeaveCriticalSection(&pQueue->AuthzAuditQueueLock);
    return b;
}


ULONG
AuthzpDeQueueThreadWorker(
    LPVOID lpParameter
    )

/*++

Routine Description

    This is the function run by the dequeueing thread.  It pulls audits from the queue 
    and sends them to LSA.
    
Arguments

    lpParameter - generic thread parameter.  The actual parameter passed in is of 
        type PAUTHZI_AUDIT_QUEUE.
    
Return Value

    None.
    
--*/

{
    BOOL                     b;
    PAUTHZ_AUDIT_QUEUE_ENTRY pAuditEntry  = NULL; 
    PAUTHZI_AUDIT_QUEUE      pQueue       = (PAUTHZI_AUDIT_QUEUE) lpParameter;
    DWORD                    dwError;

    while (pQueue->bWorker)
    {

        //
        // The thread waits until there are audits in the queue.
        //

        dwError = WaitForSingleObject(
                     pQueue->hAuthzAuditAddedEvent,
                     INFINITE
                     );

        //
        // If the wait does not succeed either something is very wrong or the hAuthzAuditAddedEvent 
        // was closed, indicating that the RM is freeing its hRMAuditInfo.  The thread should exit.
        //

        if (WAIT_OBJECT_0 != dwError)
        {
            ASSERT(L"WaitForSingleObject on hAuthzAuditAddedEvent failed." && FALSE);
        }

        //
        // The thread remains active while there are audits in the queue.
        //

        while (pQueue->AuthzAuditQueueLength > 0)
        {
            RtlEnterCriticalSection(&pQueue->AuthzAuditQueueLock);
            pAuditEntry = (PAUTHZ_AUDIT_QUEUE_ENTRY) (pQueue->AuthzAuditQueue).Flink;
            RemoveEntryList(&pAuditEntry->list);
            pQueue->AuthzAuditQueueLength--;

#ifdef AUTHZ_AUDIT_COUNTER
            InterlockedIncrement(&AuthzpAuditsDequeued);
#endif
            
            if (FLAG_ON(pQueue->Flags, AUTHZ_MONITOR_AUDIT_QUEUE_SIZE))
            {
                if (TRUE == pQueue->bAuthzAuditQueueHighEvent)
                {
                    if (pQueue->AuthzAuditQueueLength <= pQueue->dwAuditQueueLow)
                    {
                        
                        //
                        // If the High flag is on and the length is now reduced to the low water mark, then
                        // set appropriate events.
                        //
                        
                        pQueue->bAuthzAuditQueueHighEvent = FALSE;
                        b = SetEvent(pQueue->hAuthzAuditQueueLowEvent);
                        if (!b)
                        {
                            ASSERT(L"SetEvent on hAuthzAuditQueueLowEvent failed." && FALSE);
                        }
#ifdef AUTHZ_DEBUG_QUEUE
        wprintf(L"** _____ TURNING HIGH WATER OFF _____\n");
        fflush(stdout);
#endif
                    }
                }
            }
            
            RtlLeaveCriticalSection(&pQueue->AuthzAuditQueueLock);

            b = AuthzpSendAuditToLsa(
                    (AUDIT_HANDLE)(pAuditEntry->pAAETO->hAudit),
                    pAuditEntry->Flags,
                    pAuditEntry->pAuditParams,
                    pAuditEntry->pReserved
                    );

#ifdef AUTHZ_DEBUG_QUEUE
            if (!b)
            {
                DbgPrint("Error in AuthzpSendAuditToLsa() :: Error = %d = 0x%x\n", GetLastError(), GetLastError());
                DbgPrint("Context = 0x%x\n", pAuditEntry->pAAETO->hAudit);
                DbgPrint("Flags   = 0x%x\n", pAuditEntry->Flags);
                DbgPrint("Params  = 0x%x\n", pAuditEntry->pAuditParams);
                ASSERT(FALSE);
            }
#endif
            b = AuthzpDereferenceAuditEventType((AUTHZ_AUDIT_EVENT_TYPE_HANDLE)pAuditEntry->pAAETO);
            if (!b)
            {
                ASSERT(FALSE && L"Deref AuditEventType failed.");
            }
            AuthzpFree(pAuditEntry->pAuditParams);
            AuthzpFree(pAuditEntry);
        }

        RtlEnterCriticalSection(&pQueue->AuthzAuditQueueLock);
        if (0 == pQueue->AuthzAuditQueueLength)
        {
            b = ResetEvent(pQueue->hAuthzAuditAddedEvent);
            if (!b)
            {
                ASSERT(L"ResetEvent on hAuthzAuditAddedEvent failed." && FALSE);
            }
            b = SetEvent(pQueue->hAuthzAuditQueueEmptyEvent);
            if (!b)
            {
                ASSERT(L"SetEvent on hAuthzAuditQueueEmptyEvent failed." && FALSE);
            }
        }
        RtlLeaveCriticalSection(&pQueue->AuthzAuditQueueLock);
    }
    
    return STATUS_SUCCESS;
}


BOOL
AuthzpCreateAndLogAudit(
    IN DWORD AuditTypeFlag,
    IN PAUTHZI_CLIENT_CONTEXT pAuthzClientContext,
    IN PAUTHZI_AUDIT_EVENT pAuditEvent,
    IN PAUTHZI_RESOURCE_MANAGER pRM,
    IN PIOBJECT_TYPE_LIST LocalTypeList,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PAUTHZ_ACCESS_REPLY pReply
    )

/*++

Routine Description

    This is called from AuthzpGenerateAudit as a wrapper around LSA and
    AuthziLogAuditEvent functionality.  It places the appropriate audit
    information on a queue for sending to LSA.

Arguments

    AuditTypeFlag - mask to specify success | failure audit generation.  Only
    one bit at a time.

    pAuthzClientContext - pointer to Authz context representing the client.

    pAuditEvent - Object specific audit info will be passed in this structure.

    pRM - Resource manager that generates the audit.

    LocalTypeList - Internal object type list structure.

    pRequest - specifies the desired access mask, principal self sid, the
    object type list structure (if any).

    pReply - The reply structure to return the results.

Return Value

    TRUE if successful, FALSE if not.
    Extended information available with GetLastError().

--*/

{

#define AUTHZ_BUFFER_CAPTURE_MAX 200

    BOOL                b;
    AUDIT_PARAMS        AuditParams                          = {0};
    AUDIT_PARAM         ParamArray[SE_MAX_AUDIT_PARAMETERS]  = {0};
    PAUTHZI_AUDIT_EVENT pCapturedAuditEvent                  = NULL;
    UCHAR               pBuffer[AUTHZ_BUFFER_CAPTURE_MAX]    = {0};
    AUDIT_OBJECT_TYPE   FixedObjectTypeToAudit               = {0};
    AUDIT_OBJECT_TYPES  ObjectTypeListAudit                  = {0};
    PAUDIT_OBJECT_TYPE  ObjectTypesToAudit                   = NULL;
    USHORT              ObjectTypeAuditCount                 = 0;
    LONG                i                                    = 0;
    LONG                j                                    = 0;
    DWORD               APF_AuditTypeFlag                    = 0;
    ACCESS_MASK         MaskToAudit                          = 0;
    
    //
    // Capture pAuditEvent, as we may change the pAuditParams member and would like to
    // avoid the inevitable race that would follow.
    //

    if (AUTHZ_BUFFER_CAPTURE_MAX >= pAuditEvent->dwSize)
    {
        pCapturedAuditEvent = (PAUTHZI_AUDIT_EVENT) pBuffer;
        RtlCopyMemory(
            pCapturedAuditEvent,
            pAuditEvent,
            pAuditEvent->dwSize
            );
    }
    else
    {
        pCapturedAuditEvent = AuthzpAlloc(pAuditEvent->dwSize);
        
        if (AUTHZ_ALLOCATION_FAILED(pCapturedAuditEvent))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            b = FALSE;
            goto Cleanup;
        }

        RtlCopyMemory(
            pCapturedAuditEvent,
            pAuditEvent,
            pAuditEvent->dwSize
            );

    }

    //
    // Make sure only one valid bit is on in the AuditTypeFlag.  If a RM needs to generate
    // both success and failure audits, then two separate calls should be made.
    //

    ASSERT(!(
              FLAG_ON(AuditTypeFlag, AUTHZ_OBJECT_SUCCESS_AUDIT) &&
              FLAG_ON(AuditTypeFlag, AUTHZ_OBJECT_FAILURE_AUDIT)
             ));

    //
    // Set the APF_AuditTypeFlag.  LSA has its own flags for audit success
    // and audit failure.  Authz must map the Authz flag to the LSA APF equivalent.
    //

    if (FLAG_ON(AuditTypeFlag, AUTHZ_OBJECT_SUCCESS_AUDIT))
    {
        APF_AuditTypeFlag = APF_AuditSuccess;
        
        //
        // Test if the RM specifically disabled success audits
        //

        if (FLAG_ON(pCapturedAuditEvent->Flags, AUTHZ_NO_SUCCESS_AUDIT))
        {
            b = TRUE;
            goto Cleanup;
        }
    }
    else if (FLAG_ON(AuditTypeFlag, AUTHZ_OBJECT_FAILURE_AUDIT))
    {
        APF_AuditTypeFlag = APF_AuditFailure;
        
        //
        // Test if the RM specifically disabled failure audits
        //

        if (FLAG_ON(pCapturedAuditEvent->Flags, AUTHZ_NO_FAILURE_AUDIT))
        {
            b = TRUE;
            goto Cleanup;
        }
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        b = FALSE;
        goto Cleanup;
    }

    //
    // Set the AUTHZ_AUDIT_QUEUE_HANDLE and AUTHZ_AUDIT_EVENT_TYPE_HANDLE of the AuditEvent if they are not yet set.
    // 

    if (NULL == pCapturedAuditEvent->hAET)
    {
        if (FLAG_ON(pCapturedAuditEvent->Flags, AUTHZ_DS_CATEGORY_FLAG))
        {
            pCapturedAuditEvent->hAET = pRM->hAETDS;
        }
        else
        {
            pCapturedAuditEvent->hAET = pRM->hAET;
        }
    }

    if (NULL == pAuditEvent->hAuditQueue)
    {
        pCapturedAuditEvent->hAuditQueue = pRM->hAuditQueue;
        InterlockedCompareExchangePointer(
            &pAuditEvent->hAuditQueue,
            pRM->hAuditQueue,
            NULL
            );
    }
    
    //
    // Decide what access bits we should audit
    //

    MaskToAudit = (APF_AuditTypeFlag == APF_AuditSuccess) ? pReply->GrantedAccessMask[0] : pRequest->DesiredAccess;

    //
    // If the RM gives us an AUDIT_PARAMS structure to marshall, then we don't
    // need to generate our own.
    //

    if (AUTHZ_NON_NULL_PTR(pCapturedAuditEvent->pAuditParams))
    {
        
        // 
        // Capture the AuditParams so that we can change the User SID without racing.
        //

        RtlCopyMemory(
            &AuditParams, 
            pCapturedAuditEvent->pAuditParams, 
            sizeof(AUDIT_PARAMS)
            );

        ASSERT(pCapturedAuditEvent->pAuditParams->Count <= SE_MAX_AUDIT_PARAMETERS);

        RtlCopyMemory(
            &ParamArray, 
            pCapturedAuditEvent->pAuditParams->Parameters, 
            sizeof(AUDIT_PARAM) * pCapturedAuditEvent->pAuditParams->Count
            );

        AuditParams.Parameters = ParamArray;

        //
        // Replace the SID in the AUDIT_PARAMS with the SID of the current Client Context.
        //

        if (AUTHZ_NON_NULL_PTR(pAuthzClientContext->Sids[0].Sid))
        {
            AuditParams.Parameters[0].Data0 = (ULONG_PTR) pAuthzClientContext->Sids[0].Sid;
        }

        AuditParams.Flags = APF_AuditTypeFlag;

        pCapturedAuditEvent->pAuditParams = &AuditParams;

        b = AuthziLogAuditEvent(
                0,
                (AUTHZ_AUDIT_EVENT_HANDLE)pCapturedAuditEvent,
                0
                );

        goto Cleanup;
    }

    //
    // The caller has not given us an audit to generate.  We will create one, provided that
    // the AuditID specifies the generic object access (SE_AUDITID_OBJECT_OPERATION)
    //

    if ((NULL != pCapturedAuditEvent->hAET) && 
        (((PAUTHZ_AUDIT_EVENT_TYPE_OLD)pCapturedAuditEvent->hAET)->u.Legacy.AuditId != SE_AUDITID_OBJECT_OPERATION))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        b = FALSE;
        goto Cleanup;
    }

    //
    // Create the generic object access audit.  There are two codepaths
    // that initialize the AuditParams structure.  The first path is taken if
    // there is no ObjectTypeList.  The second path is taken if there is an
    // ObjectTypeList.
    //

    AuditParams.Parameters           = ParamArray;
    pCapturedAuditEvent->pAuditParams = &AuditParams;

    //
    // Check if there is an ObjectTypeList.
    //

    if (AUTHZ_NON_NULL_PTR(pRequest->ObjectTypeList))
    {

        //
        // If the length of the structure is 1 then the caller only wants access
        // at the root of the tree.
        //

        if (1 == pReply->ResultListLength)
        {

            //
            // Caller only wants access at ObjectTypeList root, so only one ObjectType to
            // audit.  For efficiency simply use the stack variable.
            //

            ObjectTypesToAudit                = &FixedObjectTypeToAudit;
            ObjectTypeAuditCount              = 1;
            FixedObjectTypeToAudit.AccessMask = pReply->GrantedAccessMask[0];

            RtlCopyMemory(
                &FixedObjectTypeToAudit.ObjectType,
                &LocalTypeList[0].ObjectType,
                sizeof(GUID)
                );
        }
        else
        {

            //
            // The caller wants more than access at ObjectTypeList root.  He wants the
            // whole thing.
            //

            //
            // Determine how many GUIDs the client has access to which should be audited
            //

            for (ObjectTypeAuditCount = 0, i = 0; i < (LONG) pReply->ResultListLength; i++)
            {
                if (FLAG_ON(LocalTypeList[i].Flags, AuditTypeFlag))
                {
                    ObjectTypeAuditCount++;
                }
            }

            //
            // Allocate appropriate storage space for GUID list
            //

            ObjectTypesToAudit = AuthzpAlloc(sizeof(AUDIT_OBJECT_TYPE) * ObjectTypeAuditCount);

            if (AUTHZ_ALLOCATION_FAILED(ObjectTypesToAudit))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                b = FALSE;
                goto Cleanup;
            }

            RtlZeroMemory(
                ObjectTypesToAudit,
                sizeof(AUDIT_OBJECT_TYPE) * ObjectTypeAuditCount
                );

            for (i = 0, j = -1; i < ObjectTypeAuditCount; i++)
            {

                //
                // One counter tracks position in the alloc'ed array of ObjectTypesToAudit.
                // The other counter picks out the indices in the pReply and LocalTypeList
                // structures that need to be audited for success.
                //

                //
                // find the next GUID to audit in pReply that client was granted access to.
                //

                do
                {
                    j++;
                }
                while (!FLAG_ON(LocalTypeList[j].Flags, AuditTypeFlag));

                //
                // In the success audit, the AccessMask records the actual
                // granted bits.
                //

                ObjectTypesToAudit[i].AccessMask = pReply->GrantedAccessMask[j];
                ObjectTypesToAudit[i].Level      = LocalTypeList[j].Level;
                ObjectTypesToAudit[i].Flags      = 0;

                RtlCopyMemory(
                    &ObjectTypesToAudit[i].ObjectType,
                    &LocalTypeList[j].ObjectType,
                    sizeof(GUID)
                    );
            }

        }

        ObjectTypeListAudit.Count        = ObjectTypeAuditCount;
        ObjectTypeListAudit.pObjectTypes = ObjectTypesToAudit;
        ObjectTypeListAudit.Flags        = 0;

        b = AuthziInitializeAuditParamsWithRM(
                APF_AuditTypeFlag,
                (AUTHZ_RESOURCE_MANAGER_HANDLE)pRM,
                9,
                &AuditParams,
                APT_String,         pCapturedAuditEvent->szOperationType,
                APT_String,         pCapturedAuditEvent->szObjectType,
                APT_String,         pCapturedAuditEvent->szObjectName,
                APT_String,         L"-",
                APT_LogonId | AP_PrimaryLogonId,
                APT_LogonId,  pAuthzClientContext->AuthenticationId,
                APT_Ulong   | AP_AccessMask, MaskToAudit, 1,
                APT_ObjectTypeList, &ObjectTypeListAudit, 1,
                APT_String,         pCapturedAuditEvent->szAdditionalInfo
                );

        if (!b)
        {
#ifdef AUTHZ_DEBUG_QUEUE
            DbgPrint("AuthzInitializeAuditParams failed %d\n", GetLastError());
#endif
            goto Cleanup;
        }
    } // matches "if (AUTHZ_NON_NULL_PTR(pRequest->ObjectTypeList))"
    else
    {
        b = AuthziInitializeAuditParamsWithRM(
                APF_AuditTypeFlag,
                (AUTHZ_RESOURCE_MANAGER_HANDLE)pRM,
                9,
                &AuditParams,
                APT_String,         pCapturedAuditEvent->szOperationType,
                APT_String,         pCapturedAuditEvent->szObjectType,
                APT_String,         pCapturedAuditEvent->szObjectName,
                APT_String,         L"-",
                APT_LogonId | AP_PrimaryLogonId,
                APT_LogonId,  pAuthzClientContext->AuthenticationId,
                APT_Ulong   | AP_AccessMask, MaskToAudit, 1,
                APT_String, L"-",
                APT_String,         pCapturedAuditEvent->szAdditionalInfo
                );

        if (!b)
        {
#ifdef AUTHZ_DEBUG_QUEUE
            DbgPrint("AuthzInitializeAuditParams failed %d\n", GetLastError());
#endif
            goto Cleanup;
        }
    }

    //
    // Replace the SID in the AUDIT_PARAMS with the SID of the current Client Context.
    //

    if (AUTHZ_NON_NULL_PTR(pAuthzClientContext->Sids[0].Sid))
    {
        pCapturedAuditEvent->pAuditParams->Parameters[0].Data0 = (ULONG_PTR) pAuthzClientContext->Sids[0].Sid;
    }

    //
    // At this point, AuditParams is initialized for an audit.  Send to the LSA.
    //

    b = AuthziLogAuditEvent(
            0,
            (AUTHZ_AUDIT_EVENT_HANDLE)pCapturedAuditEvent,
            0
            );

    if (!b)
    {
        goto Cleanup;
    }

Cleanup:

    if (ObjectTypesToAudit != &FixedObjectTypeToAudit)
    {
        AuthzpFreeNonNull(ObjectTypesToAudit);
    }

    if (pCapturedAuditEvent != (PAUTHZI_AUDIT_EVENT)pBuffer)
    {
        AuthzpFreeNonNull(pCapturedAuditEvent);
    }

    return b;
}


BOOL
AuthzpMarshallAuditParams(
    OUT PAUDIT_PARAMS * ppMarshalledAuditParams,
    IN  PAUDIT_PARAMS   pAuditParams
    )

/*++

Routine Description:

    This routine will take an AUDIT_PARAMS structure and create a new 
    structure that is suitable for sending to LSA.  It will be allocated 
    as a single chunk of memory.  

Arguments:

    ppMarshalledAuditParams - pointer to pointer that will receive the 
        marshalled audit parameters.  This memory is allocated within the routine.  
        The dequeue thread frees this memory.  

    pAuditParams - Original, unmarshalled version of the AUDIT_PARAMS.  

Return Value:

    Boolean: TRUE if success, FALSE if failure.  
    Extended information available with GetLastError().

--*/

{
    DWORD           i                        = 0;
    DWORD           AuditParamsSize          = 0;
    PAUDIT_PARAMS   pMarshalledAuditParams   = NULL;
    BOOL            b                        = TRUE;
    PUCHAR          Base                     = NULL;
    PUCHAR          inData0                  = NULL;
    
    *ppMarshalledAuditParams = NULL;

    //
    // Begin calculating the total size required for the marshalled version
    // of pAuditParams.
    //

    AuditParamsSize = sizeof(AUDIT_PARAMS) + sizeof(AUDIT_PARAM) * pAuditParams->Count;
    AuditParamsSize = PtrAlignSize( AuditParamsSize );

    //
    // Determine how much memory each parameter requires.
    //

    for (i = 0; i < pAuditParams->Count; i++) 
    {   
        inData0 = (PUCHAR) pAuditParams->Parameters[i].Data0;

        switch (pAuditParams->Parameters[i].Type)
        {
        case APT_String:
            {

                //
                // wcslen returns the number of characters, excluding the terminating NULL.  Must check for NULL 
                // because the AdditionalInfo string is OPTIONAL.
                //

                if (AUTHZ_NON_NULL_PTR(inData0))
                {
                    AuditParamsSize += (DWORD)(sizeof(WCHAR) * wcslen((PWSTR) inData0) + sizeof(WCHAR));
                    AuditParamsSize = PtrAlignSize( AuditParamsSize );
                }
                break;
            }
        case APT_Pointer:
        case APT_Ulong:
        case APT_LogonId:
            {
                break;
            }
        case APT_Sid:
            {
                AuditParamsSize += RtlLengthSid((PSID) inData0);
                AuditParamsSize = PtrAlignSize( AuditParamsSize );
                break;
            }
        case APT_ObjectTypeList:
            {
                AUDIT_OBJECT_TYPES * aot = (AUDIT_OBJECT_TYPES *) inData0;

                //
                // Need space for AUDIT_OBJECT_TYPES structure, and the AUDIT_OBJECT_TYPE 
                // array that it contains.
                //

                AuditParamsSize += sizeof (AUDIT_OBJECT_TYPES);
                AuditParamsSize = PtrAlignSize( AuditParamsSize );
                AuditParamsSize += sizeof(AUDIT_OBJECT_TYPE) * aot->Count;
                AuditParamsSize = PtrAlignSize( AuditParamsSize );
                break;
            }
        default:
            {
                ASSERT(L"Invalid Authz audit parameter" && FALSE);
                SetLastError(ERROR_INVALID_PARAMETER);
                b = FALSE;
                break;
            }
        }

        if (!b)
        {
            goto Cleanup;
        }
    }

    //
    // Allocate space for the marshalled blob.
    //

    pMarshalledAuditParams = (PAUDIT_PARAMS) AuthzpAlloc(AuditParamsSize);

    if (AUTHZ_ALLOCATION_FAILED(pMarshalledAuditParams))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        b = FALSE;
        goto Cleanup;
    }

    //
    // Set the fields of the marshalled AUDIT_PARAMS
    //

    pMarshalledAuditParams->Count      = pAuditParams->Count;
    pMarshalledAuditParams->Flags      = pAuditParams->Flags;
    pMarshalledAuditParams->Length     = pAuditParams->Length;
    pMarshalledAuditParams->Parameters = (AUDIT_PARAM *)((PUCHAR)pMarshalledAuditParams + sizeof(AUDIT_PARAMS));

    //
    // Base points to the beginning of the "data" section of the marshalled space, 
    // that is, Base is the area to copy member fields in and subsequently point at.
    //

    Base = (PUCHAR)pMarshalledAuditParams;
    Base += PtrAlignSize( sizeof(AUDIT_PARAMS) + sizeof(AUDIT_PARAM) * pAuditParams->Count );

    ASSERT(Base > (PUCHAR)pMarshalledAuditParams);
    ASSERT(Base < (PUCHAR)((PUCHAR)pMarshalledAuditParams + AuditParamsSize));

    //
    // Move the Parameters array into the marshalled blob.
    //

    RtlCopyMemory(
        pMarshalledAuditParams->Parameters,
        pAuditParams->Parameters,
        sizeof(AUDIT_PARAM) * pAuditParams->Count
        );

    for (i = 0; i < pMarshalledAuditParams->Count; i++) 
    {
        inData0 = (PUCHAR) pAuditParams->Parameters[i].Data0;

        switch (pMarshalledAuditParams->Parameters[i].Type)
        {
        case APT_String:
            {
                if (AUTHZ_NON_NULL_PTR(inData0))
                {
                    DWORD StringLength = (DWORD)(sizeof(WCHAR) * wcslen((PWSTR) inData0) + sizeof(WCHAR));
                    pMarshalledAuditParams->Parameters[i].Data0 = (ULONG_PTR) Base;

                    RtlCopyMemory(
                        (PVOID) Base,
                        (PWSTR) inData0,
                        StringLength
                        );

                    Base += PtrAlignSize( StringLength );
                    ASSERT(Base > (PUCHAR)pMarshalledAuditParams);
                    ASSERT(Base <= (PUCHAR)((PUCHAR)pMarshalledAuditParams + AuditParamsSize));
                }
                break;
            }
        case APT_Pointer:
        case APT_Ulong:
        case APT_LogonId:
            {
                break;
            }
        case APT_Sid:
            {
                DWORD SidLength = RtlLengthSid((PSID) inData0);
                pMarshalledAuditParams->Parameters[i].Data0 = (ULONG_PTR) Base;

                RtlCopyMemory(
                    (PVOID) Base,
                    (PSID) inData0,
                    SidLength
                    );
                Base += PtrAlignSize( SidLength );
                ASSERT(Base > (PUCHAR)pMarshalledAuditParams);
                ASSERT(Base <= (PUCHAR)((PUCHAR)pMarshalledAuditParams + AuditParamsSize));
                break;
            }
        case APT_ObjectTypeList:
            {
                AUDIT_OBJECT_TYPES *aot = (AUDIT_OBJECT_TYPES *) inData0;
                DWORD OTLength = sizeof(AUDIT_OBJECT_TYPE) * aot->Count;
                
                pMarshalledAuditParams->Parameters[i].Data0 = (ULONG_PTR) Base;

                //
                // Copy the AUDIT_OBJECT_TYPES structure
                //

                RtlCopyMemory(
                    (PVOID) Base,
                    aot,
                    sizeof(AUDIT_OBJECT_TYPES)
                    );

                Base += PtrAlignSize( sizeof(AUDIT_OBJECT_TYPES) );

                //
                // Point the pObjectTypes field at the end of the copied blob.
                //

                ((AUDIT_OBJECT_TYPES *)pMarshalledAuditParams->Parameters[i].Data0)->pObjectTypes = (AUDIT_OBJECT_TYPE *) Base;

                //
                // Copy the AUDIT_OBJECT_TYPE array (pObjectTypes)
                //

                RtlCopyMemory(
                    (PVOID) Base,
                    (AUDIT_OBJECT_TYPE *) aot->pObjectTypes,
                    OTLength
                    );
                
                Base += PtrAlignSize( OTLength );
                ASSERT(Base > (PUCHAR)pMarshalledAuditParams);
                ASSERT(Base <= (PUCHAR)((PUCHAR)pMarshalledAuditParams + AuditParamsSize));
                break;
            }
        default:
            {
                ASSERT(L"Invalid Authz audit parameter" && FALSE);
                b = FALSE;
                SetLastError(ERROR_INVALID_PARAMETER);
                break;
            }
        }

        if (!b)
        {
            goto Cleanup;
        }
    }

    //
    // Sanity check on the Base value.  If this assertion passes, then I have
    // not exceeded my allocated space.
    //

    ASSERT(Base == ((PUCHAR)pMarshalledAuditParams + AuditParamsSize));

Cleanup:
    
    if (b)
    {
        *ppMarshalledAuditParams = pMarshalledAuditParams;
    }
    else
    {
        AuthzpFreeNonNull(pMarshalledAuditParams);
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\authzdebug.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    authzdebug.c

Abstract:

   This module implements debug helper functions for the user mode
   authorization APIs.

Author:

    Kedar Dubhashi - March 2000

Environment:

    User mode only.

Revision History:

    Created - March 2000

--*/


#include "pch.h"

#pragma hdrstop

#include <authzp.h>


//
// Function name: AuthzPrintContext
//
// Purpose: Debug support
//


VOID
AuthzPrintContext(
    IN PAUTHZI_CLIENT_CONTEXT pCC
    )
{

#ifdef AUTHZ_DEBUG

    DWORD i = 0;
    NTSTATUS Status;
    UNICODE_STRING mystr;
    WCHAR StrBuf[512];

    mystr.Length = 512;
    mystr.MaximumLength = 512;
    mystr.Buffer = (LPWSTR) StrBuf;

    fflush(stdout);

    wprintf(L"Server = %u", pCC->Server);
    wprintf(L"\t Revision = %x\n", pCC->Revision);
    wprintf(L"Flags = %x\n", pCC->Flags);
    wprintf(L"\t SidCount = %x\n", pCC->SidCount);

    for (i = 0; i < pCC->SidCount; i++ )
    {
        Status = RtlConvertSidToUnicodeString(&mystr, pCC->Sids[i].Sid, FALSE);

        if (!NT_SUCCESS(Status))
        {

            wprintf(L"RtlConvertSidToUnicode failed with %x\n", Status);

            return;
        }

        wprintf(L"Attrib = %x, Sid = %s\n", pCC->Sids[i].Attributes, mystr.Buffer);
    }

    wprintf(L"\n");


    for (i = 0; i < pCC->RestrictedSidCount; i++ )
    {
        Status = RtlConvertSidToUnicodeString(&mystr, pCC->RestrictedSids[i].Sid, FALSE);

        if (!NT_SUCCESS(Status))
        {
            return;
        }

        wprintf(L"Attrib = %x, Sid = %s\n", pCC->RestrictedSids[i].Attributes, mystr.Buffer);
    }

    wprintf(L"\n");

#if 0
    for (i = 0; i < pTPrivs->PrivilegeCount ; i++ )
    {
        DumpLuidAttr(&pTPrivs->Privileges[i], SATYPE_PRIV);
    }
#endif

    fflush(stdout);
#else
    UNREFERENCED_PARAMETER(pCC);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\adtutil.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T U T I L . C
//
// Contents:    Functions to construct audit event parameters
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "adtgen.h"
#include "authzp.h"



BOOL
AuthzpGetTokenInfo(
    IN     HANDLE       hToken,
    OUT    PSID*        ppUserSid,         OPTIONAL
    OUT    PLUID        pAuthenticationId
    )
/*++

Routine Description:

    Get user-sid and the user-logon-id from a token.

Arguments:

    hToken            - handle of token to query

    ppUserSid         - pointer to user sid
                        if non NULL, allocate and copy the user sid
                        from the token. callers must free it using LocalFree

    pAuthenticationId - pointer to logon-id

Return Value:

    TRUE  on success
    FALSE otherwise

    call GetLastError() to retrieve the errorcode,

Notes:
    Caller must have TOKEN_QUERY access right.

--*/
{
    BOOL  fResult = FALSE;
    TOKEN_STATISTICS TokenStats;
#define MAX_TOKEN_USER_INFO_SIZE 256    
    BYTE TokenInfoBuf[MAX_TOKEN_USER_INFO_SIZE];
    TOKEN_USER* pTokenUserInfo = (TOKEN_USER*) TokenInfoBuf;
    DWORD dwSize;

    if ( ppUserSid )
    {
        *ppUserSid = NULL;
    }

    if ( GetTokenInformation( hToken, TokenUser, pTokenUserInfo,
                              MAX_TOKEN_USER_INFO_SIZE, &dwSize ))
    {
        dwSize = GetLengthSid( pTokenUserInfo->User.Sid );

        if ( ppUserSid )
        {
            *ppUserSid = AuthzpAlloc( dwSize );

            if (*ppUserSid == NULL)
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                goto Finish;
            }

            CopyMemory( *ppUserSid, pTokenUserInfo->User.Sid, dwSize );
        }

        if ( GetTokenInformation( hToken, TokenStatistics,
                                  (PVOID) &TokenStats,
                                  sizeof(TOKEN_STATISTICS), &dwSize ) )
        {
            *pAuthenticationId = TokenStats.AuthenticationId;
            fResult = TRUE;
            goto Finish;
        }
    }

    //
    // error case
    //

    if ( ppUserSid && *ppUserSid )
    {
        LocalFree( *ppUserSid );
        *ppUserSid = NULL;
    }

Finish:
    return fResult;
}


BOOL
AuthzpGetThreadTokenInfo(
    OUT    PSID*        ppUserSid,         OPTIONAL
    OUT    PLUID        pAuthenticationId
    )
/*++

Routine Description:

    Get user-sid and the user-logon-id from the thread token.

Arguments:

    ppUserSid         - pointer to user sid
                        if non NULL, allocate and copy the user sid
                        from the token. callers must free it using LocalFree

    pAuthenticationId - pointer to logon id

Return Value:

    TRUE  on success
    FALSE otherwise

    call GetLastError() to retrieve the errorcode,


Notes:
    Caller must have TOKEN_QUERY access right.

--*/
{
    BOOL  fResult = FALSE;
    HANDLE hToken=NULL;


    if ( OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken ) )
    {
        fResult = AuthzpGetTokenInfo( hToken, ppUserSid, pAuthenticationId );
        CloseHandle( hToken );
    }

    return fResult;
}


BOOL
AuthzpGetProcessTokenInfo(
    OUT    PSID*        ppUserSid,         OPTIONAL
    OUT    PLUID        pAuthenticationId
    )
/*++

Routine Description:

    Get user-sid and the user-logon-id from the process token.

Arguments:

    ppUserSid         - pointer to user sid
                        if non NULL, allocate and copy the user sid
                        from the token. callers must free it using LocalFree

    pAuthenticationId - pointer to logon id

Return Value:

    TRUE  on success
    FALSE otherwise

    call GetLastError() to retrieve the errorcode,


Notes:
    Caller must have TOKEN_QUERY access right.

--*/
{
    BOOL  fResult = FALSE;
    HANDLE hToken=NULL;


    if ( OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ) )
    {
        fResult = AuthzpGetTokenInfo( hToken, ppUserSid, pAuthenticationId );
        CloseHandle( hToken );
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\authzp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    authzp.h

Abstract:

    Internal header file for authorization APIs.

Author:

    Kedar Dubhashi - March 2000

Environment:

    User mode only.

Revision History:

    Created - March 2000

--*/

#ifndef __AUTHZP_H__
#define __AUTHZP_H__

#define _AUTHZ_

#include <authz.h>
#include <authzi.h>

#if 0
#define AUTHZ_DEBUG       
#define AUTHZ_DEBUG_QUEUE 
#define AUTHZ_DEBUG_MEMLEAK
#else
#define AUTHZ_PARAM_CHECK
#define AUTHZ_AUDIT_COUNTER
#endif

#define AuthzpCloseHandleNonNull(h) if (NULL != (h)) { AuthzpCloseHandle((h)); }
#define AuthzpCloseHandle(h) CloseHandle((h))

//
// Size of the local stack buffer used to save a kernel call as well as a memory
// allocation.
//

#define AUTHZ_MAX_STACK_BUFFER_SIZE 1024

#ifndef AUTHZ_DEBUG_MEMLEAK

#define AuthzpAlloc(s) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, (s))
#define AuthzpFree(p) LocalFree((p))

#else

//
// This is to be used for debugging memory leaks. Primitive method but works in
// a small project like this.
//

PVOID
AuthzpAlloc(IN DWORD Size);

VOID
AuthzpFree(PVOID l);

#endif

//
// Given two sids and length of the first sid, compare the two sids.
//

#define AUTHZ_EQUAL_SID(s, d, l) ((*((DWORD*) s) == *((DWORD*) d)) && (RtlEqualMemory((s), (d), (l))))

//
// Compares a given sids with a well known constant PrincipalSelfSid.
//

#define AUTHZ_IS_PRINCIPAL_SELF_SID(s) (RtlEqualMemory(pAuthzPrincipalSelfSid, (s), 12))

//
// The client context is restricted if the restricted sid and attribute array is
// present.
//

#define AUTHZ_TOKEN_RESTRICTED(t) (NULL != (t)->RestrictedSids)

//
// Two privileges are inportant for access check:
//     SeSecurityPrivilege
//     SeTakeOwnershipPrivilege
// Both these are detected at the time of client context capture from token
// and stored in the flags.
//

#define AUTHZ_PRIVILEGE_CHECK(t, f) (FLAG_ON((t)->Flags, (f)))

//
// Flags in the cached handle.
//

#define AUTHZ_DENY_ACE_PRESENT            0x00000001
#define AUTHZ_PRINCIPAL_SELF_ACE_PRESENT  0x00000002
#define AUTHZ_DYNAMIC_ALLOW_ACE_PRESENT   0x00000004
#define AUTHZ_DYNAMIC_DENY_ACE_PRESENT    0x00000008
#define AUTHZ_DYNAMIC_EVALUATION_PRESENT  (AUTHZ_PRINCIPAL_SELF_ACE_PRESENT |  \
                                           AUTHZ_DYNAMIC_ALLOW_ACE_PRESENT  |  \
                                           AUTHZ_DYNAMIC_DENY_ACE_PRESENT)

//
// There are only two valid attributes from access check point of view
//     SE_GROUP_ENABLED
//     SE_GROUP_USE_FOR_DENY_ONLY
//

#define AUTHZ_VALID_SID_ATTRIBUTES (SE_GROUP_ENABLED | SE_GROUP_USE_FOR_DENY_ONLY)

#ifdef FLAG_ON
#undef FLAG_ON
#endif

#define FLAG_ON(f, b) (0 != ((f) & (b)))

#ifdef AUTHZ_NON_NULL_PTR
#undef AUTHZ_NON_NULL_PTR
#endif

#define AUTHZ_NON_NULL_PTR(f) (NULL != (f))

//
// If the pointer is not null then free it. This will save us a function call in
// cases when the pointer is null. Note that LocalFree would also take care null
// pointer being freed.
//

#define AuthzpFreeNonNull(p) if (NULL != (p)) { AuthzpFree((p)); }

//
// Check to see if the memory allocation failed.
//

#define AUTHZ_ALLOCATION_FAILED(p) (NULL == (p))

//
// Macros to traverse the acl.
//     The first one gets the first ace in a given acl.
//     The second one gives the next ace given the current one.
//

#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))
#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

//
// These do not need to be defined now since the decision was to put the burden
// on the resource managers. There are disadvantages of making it thread safe.
// Our choices are:
//     1. Have exactly one lock in authz.dll and suffer heavy contention.
//     2. Define one lock per client context which might be too expensive in
//        cases where the clients are too many.
//     3. Let the resource manager decide whether they need locking - unlikely
//        that locks are needed since it is wrong design on part of the RM to
//        have one thread that changes the client context while the other one
//        is doing an access check.
//

#define AuthzpAcquireClientContextWriteLock(c)
#define AuthzpAcquireClientContextReadLock(c)
#define AuthzpReleaseClientContextLock(c)

#define AuthzpAcquireClientCacheWriteLock(c)
#define AuthzpReleaseClientCacheLock(c)
#define AuthzpZeroMemory(p, s) RtlZeroMemory((p), (s))

#define AuthzObjectAceSid(Ace) \
    ((PSID)(((PUCHAR)&(((PKNOWN_OBJECT_ACE)(Ace))->SidStart)) + \
     (RtlObjectAceObjectTypePresent(Ace) ? sizeof(GUID) : 0 ) + \
     (RtlObjectAceInheritedObjectTypePresent(Ace) ? sizeof(GUID) : 0 )))

#define AuthzAceSid(Ace) ((PSID)&((PKNOWN_ACE)Ace)->SidStart)
    
#define AuthzCallbackAceSid(Ace) AuthzAceSid(Ace)

#define AuthzCallbackObjectAceSid(Ace) AuthzObjectAceSid(Ace)
                      
//
// Internal structure of the object type list.
//
// Level - Level of the element in the tree. The level of the root is 0.
// Flags - To be used for auditing. The valid ones are
//           AUTHZ_OBJECT_SUCCESS_AUDIT
//           AUTHZ_OBJECT_FAILURE_AUDIT
// ObjectType - Pointer to the guid for this element.
// ParentIndex - The index of the parent of this element in the array. The
//     parent index for the root is -1.
// Remaining - Remaining access bits for this element, used during normal access
//     check algorithm.
// CurrentGranted - Granted access bits so far for this element, used during
//     maximum allowed access check.
// CurrentDenied - Explicitly denied access bits for this element, used during
//     maximum allowed access check.
//

typedef struct _IOBJECT_TYPE_LIST {
    USHORT Level;
    USHORT Flags;
#define AUTHZ_OBJECT_SUCCESS_AUDIT 0x1
#define AUTHZ_OBJECT_FAILURE_AUDIT 0x2
    GUID ObjectType;
    LONG ParentIndex;
    ACCESS_MASK Remaining;
    ACCESS_MASK CurrentGranted;
    ACCESS_MASK CurrentDenied;
} IOBJECT_TYPE_LIST, *PIOBJECT_TYPE_LIST;

typedef struct _AUTHZI_AUDIT_QUEUE
{
    
    //
    // Flags defined in authz.h
    //

    DWORD Flags;

    //
    // High and low marks for the auditing queue
    //

    DWORD dwAuditQueueHigh;
    DWORD dwAuditQueueLow;

    //
    // CS for locking the audit queue
    //

    RTL_CRITICAL_SECTION AuthzAuditQueueLock;
    
    //
    // The audit queue and length.
    //

    LIST_ENTRY AuthzAuditQueue;
    ULONG AuthzAuditQueueLength;

    //
    // Handle to the thread that maintains the audit queue.
    //

    HANDLE hAuthzAuditThread;

    //
    // This event signals that an audit was placed on the queue.
    //

    HANDLE hAuthzAuditAddedEvent;

    //
    // This event signals that the queue is empty.  Initially signalled.
    //

    HANDLE hAuthzAuditQueueEmptyEvent;

    //
    // This boolean indicates that the queue size has reached the RM-specified high water mark.
    //

    BOOL bAuthzAuditQueueHighEvent;

    //
    // This event signals that the queue size is at or below the RM-specified low water mark.
    //

    HANDLE hAuthzAuditQueueLowEvent;

    //
    // This boolean is set to TRUE during the life of the resource manager.  When it turns to FALSE, the 
    // dequeue thread knows that it should exit.
    //

    BOOL bWorker;

} AUTHZI_AUDIT_QUEUE, *PAUTHZI_AUDIT_QUEUE;

typedef struct _AUTHZI_RESOURCE_MANAGER
{
    //
    // No valid flags have been defined yet.
    //

    DWORD Flags;

    //
    // Callback function registered by AuthzRegisterRMAccessCheckCallback, to be
    // used to interpret callback aces. If no such function is registered by the
    // RM then the default  behavior is to return TRUE for a deny ACE, FALSE for
    // a grant ACE.
    //

    PFN_AUTHZ_DYNAMIC_ACCESS_CHECK pfnDynamicAccessCheck;

    //
    // Callback function registered by AuthzRegisterDynamicGroupsCallback, to be
    // used to compute groups to be added to the client context. If no such
    // function is registered by the RM then the default behavior is to return
    // no groups.
    //

    PFN_AUTHZ_COMPUTE_DYNAMIC_GROUPS pfnComputeDynamicGroups;

    //
    // Callback function registered by AuthzRegisterDynamicGroupsCallback, to be
    // used to free memory allocated by ComputeDynamicGroupsFn.
    //

    PFN_AUTHZ_FREE_DYNAMIC_GROUPS pfnFreeDynamicGroups;

    //
    // String name of resource manager.  Appears in audits.
    //

    PWSTR szResourceManagerName;

    //
    // The user SID and Authentication ID of the RM process
    //

    PSID pUserSID;
    LUID AuthID;

    //
    // Default queue and audit events for the RM
    //

#define AUTHZP_DEFAULT_RM_EVENTS        0x2

    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAETDS;

    AUTHZ_AUDIT_QUEUE_HANDLE hAuditQueue;

} AUTHZI_RESOURCE_MANAGER, *PAUTHZI_RESOURCE_MANAGER;


typedef struct _AUTHZI_CLIENT_CONTEXT AUTHZI_CLIENT_CONTEXT, *PAUTHZI_CLIENT_CONTEXT;
typedef struct _AUTHZI_HANDLE AUTHZI_HANDLE, *PAUTHZI_HANDLE;

//
// the number of sids that we hash is equal to 
// the number of  bits in AUTHZI_SID_HASH_ENTRY
//

#ifdef _WIN64_
typedef ULONGLONG AUTHZI_SID_HASH_ENTRY, *PAUTHZI_SID_HASH_ENTRY;
#else
typedef DWORD AUTHZI_SID_HASH_ENTRY, *PAUTHZI_SID_HASH_ENTRY;
#endif

#define AUTHZI_SID_HASH_ENTRY_NUM_BITS (8*sizeof(AUTHZI_SID_HASH_ENTRY))

//
// the hash size is not related to the number of bits. it is the size
// required to hold two 16 element arrays
//

#define AUTHZI_SID_HASH_SIZE 32

struct _AUTHZI_CLIENT_CONTEXT
{

    //
    // The client context structure is recursive to support delegated clients.
    // Not in the picture yet though.
    //

    PAUTHZI_CLIENT_CONTEXT Server;

    //
    // Context will always be created with Revision of AUTHZ_CURRENT_CONTEXT_REVISION.
    //

#define AUTHZ_CURRENT_CONTEXT_REVISION 1

    DWORD Revision;

    //
    // Resource manager supplied identifier. We do not ever use this.
    //

    LUID Identifier;

    //
    // AuthenticationId captured from the token of the client. Needed for
    // auditing.
    //

    LUID AuthenticationId;

    //
    // Token expiration time. This one will be checked at the time of access check against
    // the current time.
    //

    LARGE_INTEGER ExpirationTime;

    //
    // Internal flags for the token.
    //

#define AUTHZ_TAKE_OWNERSHIP_PRIVILEGE_ENABLED 0x00000001
#define AUTHZ_SECURITY_PRIVILEGE_ENABLED       0x00000002


    DWORD Flags;

    //
    // Sids used for normal access checks.
    //

    DWORD SidCount;
    DWORD SidLength;
    PSID_AND_ATTRIBUTES Sids;
             
    AUTHZI_SID_HASH_ENTRY SidHash[AUTHZI_SID_HASH_SIZE];


    //
    // Sids used if the token is resticted. These will usually be 0 and NULL respectively.
    //

    DWORD RestrictedSidCount;
    DWORD RestrictedSidLength;
    PSID_AND_ATTRIBUTES RestrictedSids;

    AUTHZI_SID_HASH_ENTRY RestrictedSidHash[AUTHZI_SID_HASH_SIZE];
    
    //
    // Privileges used in access checks. Relevant ones are:
    //   1. SeSecurityPrivilege
    //   2. SeTakeOwnershipPrivilege
    // If there are no privileges associated with the client context then the PrivilegeCount = 0
    // and Privileges = NULL
    //

    DWORD PrivilegeCount;
    DWORD PrivilegeLength;
    PLUID_AND_ATTRIBUTES Privileges;

    //
    // Handles open for this client. When the client context is destroyed all the handles are
    // cleaned up.
    //

     PAUTHZI_HANDLE AuthzHandleHead;

    //
    // Pointer to the resource manager, needed to retrieve static auditing information.
    //

    PAUTHZI_RESOURCE_MANAGER pResourceManager;

};

struct _AUTHZI_HANDLE
{
    //
    // Pointers to the next handle maintained by the AuthzClientContext object.
    //

    PAUTHZI_HANDLE next;

    //
    // Pointer to the security descriptors provided by the RM at the time of first access
    // check call. We do not make a copy of the security descriptors. The assumption
    // is that the SDs will be valid at least as long as the the handle is open.
    //

    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray;
    DWORD OptionalSecurityDescriptorCount;

    //
    // Flags for internal usage only.
    //

    DWORD Flags;

    //
    // Back pointer to the client context that created this handle, required if the static
    // access granted is insufficient and access check needs to be performed again.
    //

    PAUTHZI_CLIENT_CONTEXT pAuthzClientContext;

    //
    // Results of the maximum allowed static access.
    //

    DWORD ResultListLength;
    ACCESS_MASK GrantedAccessMask[ANYSIZE_ARRAY];
};


//
// This structure stores per access audit information.  The structure
// is opaque and initialized with AuthzInitAuditInfo
//

typedef struct _AUTHZI_AUDIT_EVENT
{

    //
    // size of allocated blob for this structure
    //

    DWORD dwSize;

    //
    // Flags are specified in authz.h, and this single private flag for DS callers.
    //

    DWORD Flags;

    //
    // AuditParams used for audit if available.  If no AuditParams is available
    // and the audit id is SE_AUDITID_OBJECT_OPERATION then Authz will construct a
    // suitable structure.
    //

    PAUDIT_PARAMS pAuditParams;

    //
    // Structure defining the Audit Event category and id
    //

    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET;
    
    //
    // millisecond timeout value
    //

    DWORD dwTimeOut;

    //
    // RM specified strings describing this event.
    //

    PWSTR szOperationType;
    PWSTR szObjectType;
    PWSTR szObjectName;
    PWSTR szAdditionalInfo;

    AUTHZ_AUDIT_QUEUE_HANDLE hAuditQueue;

} AUTHZI_AUDIT_EVENT, *PAUTHZI_AUDIT_EVENT;

//
// structure to maintain queue of audits to be sent to LSA
//

typedef struct _AUTHZ_AUDIT_QUEUE_ENTRY
{
    LIST_ENTRY list;
    PAUTHZ_AUDIT_EVENT_TYPE_OLD pAAETO;
    DWORD Flags;
    AUDIT_PARAMS * pAuditParams;
    PVOID pReserved;
} AUTHZ_AUDIT_QUEUE_ENTRY, *PAUTHZ_AUDIT_QUEUE_ENTRY;

//
// Enumeration type to be used to specify what type of coloring should be
// passed on to the rest of the tree starting at a given node.
//   Deny gets propagted down the entire subtree as well as to all the
//     ancestors (but NOT to siblings and below)
//   Grants get propagated down the subtree. When a grant exists on all the
//     siblings the parent automatically gets it.
//   Remaining is propagated downwards. The remaining on the parent is a
//     logical OR of the remaining bits on all the children.
//

typedef enum {
    AuthzUpdateRemaining = 1,
    AuthzUpdateCurrentGranted,
    AuthzUpdateCurrentDenied
} ACCESS_MASK_FIELD_TO_UPDATE;

//
// Enumeration type to be used to specify the kind of well known sid for context
// changes. We are not going to support these unless we get a requirement.
//

typedef enum _AUTHZ_WELL_KNOWN_SID_TYPE
{
    AuthzWorldSid = 1,
    AuthzUserSid,
    AuthzAdminSid,
    AuthzDomainAdminSid,
    AuthzAuthenticatedUsersSid,
    AuthzSystemSid
} AUTHZ_WELL_KNOWN_SID_TYPE;

BOOL
AuthzpVerifyAccessCheckArguments(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE phAccessCheckResults OPTIONAL
    );

BOOL
AuthzpVerifyOpenObjectArguments(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN PAUTHZI_AUDIT_EVENT pAuditEvent
    );

BOOL
AuthzpCaptureObjectTypeList(
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeLocalTypeListLength,
    OUT PIOBJECT_TYPE_LIST *CapturedObjectTypeList,
    OUT PIOBJECT_TYPE_LIST *CapturedCachingObjectTypeList OPTIONAL
    );

VOID
AuthzpFillReplyStructure(
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN DWORD Error,
    IN ACCESS_MASK GrantedAccess
    );

BOOL
AuthzpMaximumAllowedAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN OUT PIOBJECT_TYPE_LIST LocalCachingTypeList OPTIONAL,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent,
    OUT PDWORD pCachingFlags
    );

BOOL
AuthzpMaximumAllowedMultipleSDAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN OUT PIOBJECT_TYPE_LIST LocalCachingTypeList OPTIONAL,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent,
    IN BOOL Restricted,
    OUT PDWORD pCachingFlags
    );

BOOL
AuthzpMaximumAllowedSingleAclAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pHash,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN OUT PIOBJECT_TYPE_LIST LocalCachingTypeList OPTIONAL,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent,
    OUT PDWORD pCachingFlags
    );


BOOL
AuthzpSidApplicable(
    IN DWORD SidCount,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN PAUTHZI_SID_HASH_ENTRY pHash,
    IN PSID pSid,
    IN PSID PrincipalSelfSid,
    IN PSID CreatorOwnerSid,
    IN BOOL DenyAce,
    OUT PDWORD pCachingFlags
    );

BOOL
AuthzpAccessCheckWithCaching(
    IN DWORD Flags,
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    OUT PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE phAccessCheckResults OPTIONAL,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN OUT PIOBJECT_TYPE_LIST LocalCachingTypeList OPTIONAL,
    IN DWORD LocalTypeListLength
    );

BOOL
AuthzpNormalAccessCheckWithoutCaching(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    );

BOOL
AuthzpNormalMultipleSDAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN ACCESS_MASK Remaining,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    );

BOOL
AuthzpOwnerSidInClientContext(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PISECURITY_DESCRIPTOR pSecurityDescriptor
    );

BOOL
AuthzpNormalAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN ACCESS_MASK Remaining,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    );

BOOL
AuthzpQuickMaximumAllowedAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZI_HANDLE pAH,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    );

BOOL
AuthzpQuickNormalAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZI_HANDLE pAH,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    );

BOOL
AuthzpAllowOnlyNormalMultipleSDAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN ACCESS_MASK Remaining,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    );

BOOL
AuthzpAllowOnlyNormalSingleAclAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN ACCESS_MASK Remaining,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    );

BOOL
AuthzpAllowOnlySidApplicable(
    IN DWORD SidCount,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN PSID pSid
    );


VOID
AuthzpAddAccessTypeList (
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeListLength,
    IN DWORD StartIndex,
    IN ACCESS_MASK AccessMask,
    IN ACCESS_MASK_FIELD_TO_UPDATE FieldToUpdate
    );

BOOL
AuthzpObjectInTypeList (
    IN GUID *ObjectType,
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeListLength,
    OUT PDWORD ReturnedIndex
    );

BOOL
AuthzpCacheResults(
    IN DWORD Flags,
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PIOBJECT_TYPE_LIST LocalCachingTypeList,
    IN DWORD LocalTypeListLength,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN DWORD CachingFlags,
    IN PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE phAccessCheckResults
    );


BOOL
AuthzpVerifyCachedAccessCheckArguments(
    IN PAUTHZI_HANDLE pAH,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN OUT PAUTHZ_ACCESS_REPLY pReply
    );

BOOL
AuthzpAllowOnlyMaximumAllowedMultipleSDAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent,
    IN BOOL Restricted
    );

BOOL
AuthzpAllowOnlyMaximumAllowedSingleAclAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent
    );

VOID
AuthzpAddAccessTypeList (
    IN OUT PIOBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeListLength,
    IN DWORD StartIndex,
    IN ACCESS_MASK AccessMask,
    IN ACCESS_MASK_FIELD_TO_UPDATE FieldToUpdate
    );

VOID
AuthzpUpdateParentTypeList(
    IN OUT PIOBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeListLength,
    IN DWORD StartIndex
    );

BOOL
AuthzpObjectInTypeList (
    IN GUID *ObjectType,
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeListLength,
    OUT PDWORD ReturnedIndex
    );


BOOL
AuthzpGenerateAudit(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PAUTHZI_AUDIT_EVENT pAuditEvent,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList
    );

BOOL
AuthzpCopySidsAndAttributes(
    IN OUT PSID_AND_ATTRIBUTES DestSidAttr,
    IN PSID_AND_ATTRIBUTES SidAttr1,
    IN DWORD Count1,
    IN PSID_AND_ATTRIBUTES SidAttr2,
    IN DWORD Count2
    );

VOID
AuthzpCopyLuidAndAttributes(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PLUID_AND_ATTRIBUTES Source,
    IN DWORD Count,
    IN OUT PLUID_AND_ATTRIBUTES Destination
    );

BOOL
AuthzpDefaultAccessCheck(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext,
    IN PACE_HEADER pAce,
    IN PVOID pArgs OPTIONAL,
    IN OUT PBOOL pbAceApplicable
    );

VOID
AuthzPrintContext(
    IN PAUTHZI_CLIENT_CONTEXT pCC
    );

VOID
AuthzpFillReplyFromParameters(
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN PIOBJECT_TYPE_LIST LocalTypeList
    );

BOOL
AuthzpGetAllGroupsBySid(
    IN  PSID pUserSid,
    IN  DWORD Flags,
    OUT PSID_AND_ATTRIBUTES *ppSidAttr,
    OUT PDWORD pSidCount,
    OUT PDWORD pSidLength
    );

BOOL
AuthzpGetAllGroupsByName(
    IN  PUNICODE_STRING pusUserName,
    IN  PUNICODE_STRING pusDomainName,
    IN  DWORD Flags,
    OUT PSID_AND_ATTRIBUTES *ppSidAttr,
    OUT PDWORD pSidCount,
    OUT PDWORD pSidLength
    );

BOOL
AuthzpAllocateAndInitializeClientContext(
    OUT PAUTHZI_CLIENT_CONTEXT *ppCC,
    IN PAUTHZI_CLIENT_CONTEXT Server,
    IN DWORD Revision,
    IN LUID Identifier,
    IN LARGE_INTEGER ExpirationTime,
    IN DWORD Flags,
    IN DWORD SidCount,
    IN DWORD SidLength,
    IN PSID_AND_ATTRIBUTES Sids,
    IN DWORD RestrictedSidCount,
    IN DWORD RestrictedSidLength,
    IN PSID_AND_ATTRIBUTES RestrictedSids,
    IN DWORD PrivilegeCount,
    IN DWORD PrivilegeLength,
    IN PLUID_AND_ATTRIBUTES Privileges,
    IN LUID AuthenticationId,
    IN PAUTHZI_HANDLE AuthzHandleHead,
    IN PAUTHZI_RESOURCE_MANAGER pRM
    );

BOOL
AuthzpAddDynamicSidsToToken(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZI_RESOURCE_MANAGER pRM,
    IN PVOID DynamicGroupsArgs,
    IN PSID_AND_ATTRIBUTES Sids,
    IN DWORD SidLength,
    IN DWORD SidCount,
    IN PSID_AND_ATTRIBUTES RestrictedSids,
    IN DWORD RestrictedSidLength,
    IN DWORD RestrictedSidCount,
    IN PLUID_AND_ATTRIBUTES Privileges,
    IN DWORD PrivilegeLength,
    IN DWORD PrivilegeCount,
    IN BOOL bAllocated
    );

BOOL
AuthzpExamineSingleSacl(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN ACCESS_MASK AccessMask,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN UCHAR AuditMaskType,
    IN BOOL bMaximumFailed,
    OUT PAUTHZ_ACCESS_REPLY pReply,
    OUT PBOOL pbGenerateAudit
    );

BOOL
AuthzpExamineSacl(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN PAUTHZ_ACCESS_REPLY pReply,
    OUT PBOOL pbGenerateAudit
    );


BOOL
AuthzpExamineSaclForObjectTypeList(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    OUT PBOOL pbGenerateSuccessAudit,
    OUT PBOOL pbGenerateFailureAudit
    );

BOOL
AuthzpExamineSingleSaclForObjectTypeList(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    OUT PBOOL pbGenerateSuccessAudit,
    OUT PBOOL pbGenerateFailureAudit
    );

VOID
AuthzpSetAuditInfoForObjectType(
    IN PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD StartIndex,
    IN ACCESS_MASK AceAccessMask,
    IN ACCESS_MASK DesiredAccessMask,
    IN UCHAR AceFlags,
    OUT PBOOL pbGenerateSuccessAudit,
    OUT PBOOL pbGenerateFailureAudit
    );

BOOL
AuthzpCreateAndLogAudit(
    IN DWORD AuditTypeFlag,
    IN PAUTHZI_CLIENT_CONTEXT pAuthzClientContext,
    IN PAUTHZI_AUDIT_EVENT pAuditEvent,
    IN PAUTHZI_RESOURCE_MANAGER pRM,
    IN PIOBJECT_TYPE_LIST LocalTypeList,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PAUTHZ_ACCESS_REPLY pReply
    );

VOID
AuthzpFillReplyStructureFromCachedGrantedAccessMask(
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN ACCESS_MASK DesiredAccess,
    IN PACCESS_MASK GrantedAccessMask
    );

BOOL
AuthzpSendAuditToLsa(
    IN AUDIT_HANDLE  hAuditContext,
    IN DWORD         Flags,
    IN PAUDIT_PARAMS pAuditParams,
    IN PVOID         Reserved
    );

BOOL
AuthzpEnQueueAuditEvent(
    PAUTHZI_AUDIT_QUEUE pQueue,
    PAUTHZ_AUDIT_QUEUE_ENTRY pAudit
    );

BOOL
AuthzpEnQueueAuditEventMonitor(
    PAUTHZI_AUDIT_QUEUE pQueue,
    PAUTHZ_AUDIT_QUEUE_ENTRY pAudit
    );

BOOL
AuthzpMarshallAuditParams(
    OUT PAUDIT_PARAMS * ppMarshalledAuditParams,
    IN  PAUDIT_PARAMS   pAuditParams
    );

ULONG
AuthzpDeQueueThreadWorker(
    LPVOID lpParameter
    );

#define AUTHZ_SID_HASH_LOW_MASK 0xf
#define AUTHZ_SID_HASH_HIGH_MASK 0xf0
#define AUTHZ_SID_HASH_HIGH 16
#define AUTHZ_SID_HASH_LOOKUP(table, byte) (((table)[(byte) & 0xf]) & ((table)[AUTHZ_SID_HASH_HIGH + (((byte) & 0xf0) >> 4)]))
    
VOID
AuthzpInitSidHash(
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN ULONG SidCount,
    OUT PAUTHZI_SID_HASH_ENTRY pHash
    );

BOOL
AuthzpGetThreadTokenInfo(
    OUT PSID* pUserSid,
    OUT PLUID pAuthenticationId
    );

BOOL
AuthzpGetProcessTokenInfo(
    OUT PSID* ppUserSid,
    OUT PLUID pAuthenticationId
    );

VOID
AuthzpReferenceAuditEventType(
    IN AUTHZ_AUDIT_EVENT_TYPE_HANDLE
    );
BOOL
AuthzpDereferenceAuditEventType(
    IN OUT AUTHZ_AUDIT_EVENT_TYPE_HANDLE
    );

BOOL
AuthzpEveryoneIncludesAnonymous(
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\makefile.inc ===
PRIVLIB= $(O)\authzi.lib
$(O)\authz.lib : $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\authzi.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\authzi.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\authzi.def: authz.def
    $(C_PREPROCESSOR) $** -DPRIVATE= > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\god.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <dsgetdc.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <sddl.h>
#include <seopaque.h>
#include <sertlp.h>
#include "authz.h"


#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))

#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

#define MY_MAX 1024

CHAR Buffer[MY_MAX];
CHAR TypeListBuffer[MY_MAX];

GUID Guid0 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x00}};
GUID Guid1 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x01}};
GUID Guid2 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x02}};
GUID Guid3 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x03}};
GUID Guid4 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x04}};
GUID Guid5 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x05}};
GUID Guid6 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x06}};
GUID Guid7 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x07}};
GUID Guid8 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x08}};

ULONG WORLD_SID[] = {0x101, 0x1000000, 0};

// S-1-5-21-397955417-626881126-188441444-2791022
ULONG KEDAR_SID[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x002a966e};

// S-1-5-21-397955417-626881126-188441444-2204519
ULONG RAHUL_SID[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x0021a367};

// S-1-5-21-397955417-626881126-188441444-2101332
ULONG ROBER_SID[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00201054};

ULONG LOCAL_RAJ_SID[] = {0x00000501, 0x05000000, 21, 1085031214, 57989841, 725345543, 1002};
BOOL GlobalTruthValue = FALSE;

BOOL
MyAccessCheck(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
    IN PACE_HEADER pAce,
    IN PVOID pArgs OPTIONAL,
    IN OUT PBOOL pbAceApplicable
    )
{
    *pbAceApplicable = GlobalTruthValue;

    return TRUE;
}

BOOL
MyComputeDynamicGroups(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
    IN PVOID Args,
    OUT PSID_AND_ATTRIBUTES *pSidAttrArray,
    OUT PDWORD pSidCount,
    OUT PSID_AND_ATTRIBUTES *pRestrictedSidAttrArray,
    OUT PDWORD pRestrictedSidCount
    )
{
    ULONG Length = 0;

    *pSidCount = 2;
    *pRestrictedSidCount = 0;

    *pRestrictedSidAttrArray = 0;

    Length = RtlLengthSid((PSID) KEDAR_SID);
    Length += RtlLengthSid((PSID) RAHUL_SID);

    if (!(*pSidAttrArray = malloc(sizeof(SID_AND_ATTRIBUTES) * 2 + Length)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    (*pSidAttrArray)[0].Attributes = SE_GROUP_ENABLED;
    (*pSidAttrArray)[0].Sid = ((PUCHAR) (*pSidAttrArray)) + 2 * sizeof(SID_AND_ATTRIBUTES);
    RtlCopySid(Length/2, (*pSidAttrArray)[0].Sid, (PSID) KEDAR_SID);

    (*pSidAttrArray)[1].Attributes = SE_GROUP_USE_FOR_DENY_ONLY;
    (*pSidAttrArray)[1].Sid = ((PUCHAR) (*pSidAttrArray)) + 2 * sizeof(SID_AND_ATTRIBUTES) + Length/2;
    RtlCopySid(Length/2, (*pSidAttrArray)[1].Sid, (PSID) RAHUL_SID);

    // wprintf(L"Returning two groups in COMPUTE_DYNAMIC\n");

    return TRUE;
}

VOID
MyFreeDynamicGroups (
    IN PSID_AND_ATTRIBUTES pSidAttrArray
    )

{
    if (pSidAttrArray) free(pSidAttrArray);
}

ULONG Special[] = {0x101, 0x2000000, 2};

#if 1
void _cdecl wmain( int argc, WCHAR * argv[] )
{
    NTSTATUS Status = STATUS_SUCCESS;

    BOOL b = TRUE;
    AUTHZ_RESOURCE_MANAGER_HANDLE RM = NULL;
    HANDLE hToken = NULL;
    LUID luid = {0xdead,0xbeef};
    AUTHZ_CLIENT_CONTEXT_HANDLE CC = NULL;
    AUTHZ_ACCESS_REQUEST Request;
    PAUTHZ_ACCESS_REPLY pReply = (PAUTHZ_ACCESS_REPLY) Buffer;
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD dwErr;
    ULONG i = 0;
    PACE_HEADER Ace = NULL;
    DWORD AceCount = 0;
    LUID MySeLuid = {0, SE_SECURITY_PRIVILEGE};
    LUID MyOwLuid = {0, SE_TAKE_OWNERSHIP_PRIVILEGE};
    DWORD Len = 0;
    SID_AND_ATTRIBUTES SidAttr[10];
    AUTHZ_AUDIT_INFO_HANDLE AuditInfo;
    PAUTHZ_AUDIT_INFO_HANDLE pAuditInfo = NULL;

    CHAR TokenBuff[100];
    PTOKEN_PRIVILEGES TokenPriv = (PTOKEN_PRIVILEGES) TokenBuff;

    AUTHZ_HANDLE AuthHandle = 0;
    AUTHZ_HANDLE AuthHandlePS = 0;
    PACL pAcl = NULL;

    /*
    PWCHAR StringSD = L"O:BAG:DUD:(D;;0xFFFFFF;;;s-0x1-000000000005-15-65d637a8-5274c742-3f32a78a-20) (A;;0xFFFFFF;;;s-0x1-000000000005-15-65d637a8-5274c742-3f32a78a-21) (D;;0x60000;;;s-0x1-000000000005-15-65d637a8-5274c742-3f32a78a-201) (OA;;0x1;00000000-0000-0000-00000000;;s-0x1-000000000005-15-65d637a8-5274c742-3f32a78a-201) S:(AU;IDSA;SD;;;DU)";

    PWCHAR StringSD = L"O:BAG:DUD:(D;;0xFFFFFF;;;s-0x1-000000000005-15-65d637a8-5274c742-3f32a78a-20)
    (A;;0xFFFFFF;;;s-0x1-000000000005-15-65d637a8-5274c742-3f32a78a-25)
    (D;;0x60000;;;s-0x1-000000000005-15-65d637a8-5274c742-3f32a78a-201)
    (A;;0x1;;;s-0x1-000000000005-15-65d637a8-5274c742-3f32a78a-201)
    (OA;;0x2;00000000-0000-0000-00000001;;s-0x1-000000000005-15-65d637a8-5274c742-3f32a78a-201)
    (OD;;0x2;00000000-0000-0000-00000004;;s-0x1-000000000001-0)
    (OA;;0x4;00000000-0000-0000-00000002;;s-0x1-000000000005-20-220)
    (OA;;0x4;00000000-0000-0000-00000006;;s-0x1-000000000005-20-220)
    (OD;;0xC;00000000-0000-0000-00000000;;s-0x1-000000000005-20-221)
    (OA;;0x18;00000000-0000-0000-00000004;;s-0x1-000000000005-5-0-ae35)
    (OA;;0x38;00000000-0000-0000-00000001;;s-0x1-000000000002-0)
    (OA;;0xF90000;00000000-0000-0000-00000000;;s-0x1-000000000005-4)
    (OA;;0x1000000;00000000-0000-0000-00000004;;s-0x1-000000000005-b)
    S:(AU;IDSA;SD;;;DU)";

    */

    PWCHAR StringSD = L"O:BAG:DUD:(A;;0x40;;;s-1-2-2)(A;;0x1;;;BA)(OA;;0x2;6da8a4ff-0e52-11d0-a286-00aa00304900;;BA)(OA;;0x4;6da8a4ff-0e52-11d0-a286-00aa00304901;;BA)(OA;;0x8;6da8a4ff-0e52-11d0-a286-00aa00304903;;AU)(OA;;0x10;6da8a4ff-0e52-11d0-a286-00aa00304904;;BU)(OA;;0x20;6da8a4ff-0e52-11d0-a286-00aa00304905;;AU)(A;;0x40;;;PS)S:(AU;IDSAFA;0xFFFFFF;;;WD)";
    // PWCHAR StringSD = L"O:BAG:DUD:(A;;0x40;;;SY)(A;;0x1;;;BA)S:(AU;IDSA;SD;;;DU)";
    // PWCHAR StringSD = L"O:BAG:DUD:(A;;0x40;;;SY)(A;;0x1;;;PS)S:(AU;IDSA;SD;;;DU)";

    TokenPriv->PrivilegeCount = 2;
    TokenPriv->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    TokenPriv->Privileges[0].Luid = MySeLuid;

    TokenPriv->Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;
    TokenPriv->Privileges[1].Luid = MyOwLuid;

    b = ConvertStringSecurityDescriptorToSecurityDescriptorW(StringSD, SDDL_REVISION_1, &pSD, NULL);

    if (!b)
    {
        wprintf(L"SDDL failed with %d\n", GetLastError());
        return;
    }


    if (argc == 2)
    {
        wprintf(L"\n\n CALLBACK ACES!!!!\n\n");

        pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSD);

        // pAcl = (PACL) (((SECURITY_DESCRIPTOR_RELATIVE *) pSD)->Dacl + (PUCHAR) pSD);

        AceCount = pAcl->AceCount;
        for (i = 0, Ace = FirstAce(pAcl); i < AceCount; i++, Ace = NextAce(Ace))
        {
            switch(Ace->AceType)
            {
            case ACCESS_ALLOWED_ACE_TYPE:
                Ace->AceType = ACCESS_ALLOWED_CALLBACK_ACE_TYPE;
                break;
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                Ace->AceType = ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE;
                break;
            }
        }
    }

    b = AuthzInitializeResourceManager(
            MyAccessCheck,
            MyComputeDynamicGroups,
            MyFreeDynamicGroups,
            NULL,
            0,                          // Flags
            &RM
            );

    if (!b)
    {
        wprintf(L"AuthzRMInitialize failed with %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"AuthzRMInitialize succeeded\n");
    }

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
    {
        wprintf(L"OpenProcessToken failed with %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"OpenProcessToken succeeded\n");
    }

    wprintf(L"Calling initialize token\n");

    b = AdjustTokenPrivileges(
            hToken,
            FALSE,
            TokenPriv,
            100,
            NULL,
            NULL
            );

    if (!b)
    {
        wprintf(L"Can not adjust privilege, %x\n", GetLastError());
        // return;
    }

    if (!wcscmp(argv[2], L"User"))
    {
        b = AuthzInitializeContextFromSid(
                // (PSID) LOCAL_RAJ_SID,
                (PSID) KEDAR_SID,
                NULL,
                RM,
                NULL,
                luid,
                0,
                NULL,
                &CC
                );
    }
    else
    {
        b = AuthzInitializeContextFromToken(
               hToken,
               RM,
               NULL,
               luid,
               0,
               NULL,
               &CC
               );
    }

    if (!wcscmp(argv[3], L"Audit"))
    {
        pAuditInfo = &AuditInfo;
    }

    pAuditInfo = &AuditInfo;

    if (!b)
    {
        wprintf(L"AuthzInitializeContextFromToken failed with %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"AuthzInitializeContextFromToken succeeded\n");
    }


    Request.DesiredAccess = MAXIMUM_ALLOWED;
    Request.DesiredAccess = wcstol(argv[1], NULL, 16);
    wprintf(L"Desired = %x\n", Request.DesiredAccess);

    Request.ObjectTypeList = (POBJECT_TYPE_LIST) TypeListBuffer;

    Request.ObjectTypeList[0].Level = 0;
    Request.ObjectTypeList[0].ObjectType = &Guid0;
    Request.ObjectTypeList[0].Sbz = 0;

    Request.ObjectTypeList[1].Level = 1;
    Request.ObjectTypeList[1].ObjectType = &Guid1;
    Request.ObjectTypeList[1].Sbz = 0;

    Request.ObjectTypeList[2].Level = 2;
    Request.ObjectTypeList[2].ObjectType = &Guid2;
    Request.ObjectTypeList[2].Sbz = 0;

    Request.ObjectTypeList[3].Level = 2;
    Request.ObjectTypeList[3].ObjectType = &Guid3;
    Request.ObjectTypeList[3].Sbz = 0;

    Request.ObjectTypeList[4].Level = 1;
    Request.ObjectTypeList[4].ObjectType = &Guid4;
    Request.ObjectTypeList[4].Sbz = 0;

    Request.ObjectTypeList[5].Level = 2;
    Request.ObjectTypeList[5].ObjectType = &Guid5;
    Request.ObjectTypeList[5].Sbz = 0;

    Request.ObjectTypeList[6].Level = 3;
    Request.ObjectTypeList[6].ObjectType = &Guid6;
    Request.ObjectTypeList[6].Sbz = 0;

    Request.ObjectTypeList[7].Level = 2;
    Request.ObjectTypeList[7].ObjectType = &Guid7;
    Request.ObjectTypeList[7].Sbz = 0;

    Request.ObjectTypeListLength = 8;
    Request.OptionalArguments = NULL;

    Request.PrincipalSelfSid = NULL;

    pReply->ResultListLength = 8;
    pReply->Error = (PDWORD) (((PCHAR) pReply) + sizeof(AUTHZ_ACCESS_REPLY));
    pReply->GrantedAccessMask = (PACCESS_MASK) (pReply->Error + pReply->ResultListLength);

    b = AuthzAccessCheck(
            CC,
            &Request,
            pAuditInfo,
            pSD,
            NULL,
            0,
            pReply,
            &AuthHandle
            );

    if (!b)
    {
        wprintf(L"AccessCheck no SELF failed\n");
        return;
    }
    else
    {
        wprintf(L"\nAccessCheck no SELF succeeded\n\n");

        for (i = 0; i < pReply->ResultListLength; i++)
        {
            wprintf(L"i = %d, AccessMask = %x, Error = %d\n",
                    i, pReply->GrantedAccessMask[i], pReply->Error[i]);
        }
    }

    Request.PrincipalSelfSid = (PSID) RAHUL_SID;

    GlobalTruthValue = TRUE;

    SidAttr[0].Attributes = SE_GROUP_ENABLED;
    SidAttr[0].Sid = (PSID) Special;
//
//     b = AuthzAddSidsToContext(
//             CC,
//             SidAttr,
//             1,
//             NULL,
//             0
//             );
//
//     if (!b)
//     {
//         wprintf(L"AuthzNormalGroups failed with %d\n", GetLastError());
//         return;
//     }
//
    b = AuthzAccessCheck(
            CC,
            &Request,
            pAuditInfo,
            pSD,
            NULL,
            0,
            pReply,
            &AuthHandlePS
            );

    if (!b)
    {
        wprintf(L"AccessCheck SELF = ROBER failed\n");
        return;
    }
    else
    {
        wprintf(L"\nAccessCheck SELF + ROBER succeeded\n\n");

        for (i = 0; i < pReply->ResultListLength; i++)
        {
            wprintf(L"i = %d, AccessMask = %x, Error = %d\n",
                    i, pReply->GrantedAccessMask[i], pReply->Error[i]);
        }
    }

    Request.PrincipalSelfSid = NULL;

    GlobalTruthValue = FALSE;

    if (AuthHandlePS)
    {
        b = AuthzCachedAccessCheck(
                AuthHandlePS,
                &Request,
                pAuditInfo,
                pReply
                );

        if (!b)
        {
            wprintf(L"CachedAccessCheck failed\n");
            return;
        }
        else
        {
            wprintf(L"\nCachedAccessCheck succeeded\n\n");

            for (i = 0; i < pReply->ResultListLength; i++)
            {
                wprintf(L"i = %d, AccessMask = %x, Error = %d\n",
                        i, pReply->GrantedAccessMask[i], pReply->Error[i]);
            }
        }
        AuthzFreeHandle(AuthHandlePS);
    }
    else
    {
        wprintf(L"No CachedAccessCheck done since NULL = AuthHandlePS\n");
    }

    if (AuthHandle)
    {
        Request.PrincipalSelfSid = (PSID) RAHUL_SID;

        GlobalTruthValue = TRUE;
        b = AuthzCachedAccessCheck(
                AuthHandle,
                &Request,
                pAuditInfo,
                pReply
                );

        if (!b)
        {
            wprintf(L"CachedAccessCheck failed\n");
            return;
        }
        else
        {
            wprintf(L"\nCachedAccessCheck succeeded\n\n");

            for (i = 0; i < pReply->ResultListLength; i++)
            {
                wprintf(L"i = %d, AccessMask = %x, Error = %d\n",
                        i, pReply->GrantedAccessMask[i], pReply->Error[i]);
            }
        }

        AuthzFreeHandle(AuthHandle);
    }
    else
    {
        wprintf(L"No CachedAccessCheck done since NULL = AuthHandle\n");
    }

    AuthzFreeContext(CC);

    return;
}

#else

void _cdecl wmain( int argc, WCHAR * argv[] )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i = 0, j = 0;

    BOOL b = TRUE;
    AUTHZ_RESOURCE_MANAGER RM = NULL;
    HANDLE hToken = NULL;
    LUID luid = {0xdead,0xbeef};
    AUTHZ_CLIENT_CONTEXT_HANDLE CC = NULL;
    AUTHZ_ACCESS_REQUEST Request;
    PAUTHZ_ACCESS_REPLY pReply = (PAUTHZ_ACCESS_REPLY) Buffer;
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD dwErr;
    PACE_HEADER Ace = NULL;
    DWORD AceCount = 0;
    LUID MySeLuid = {0, SE_SECURITY_PRIVILEGE};
    LUID MyOwLuid = {0, SE_TAKE_OWNERSHIP_PRIVILEGE};
    DWORD Len = 0;
    SID_AND_ATTRIBUTES SidAttr[10];
    AUTHZ_AUDIT_INFO AuditInfo;
    PAUTHZ_AUDIT_INFO pAuditInfo = NULL;

    CHAR TokenBuff[100];
    PTOKEN_PRIVILEGES TokenPriv = (PTOKEN_PRIVILEGES) TokenBuff;

    AUTHZ_HANDLE AuthHandle = 0;
    AUTHZ_HANDLE AuthHandlePS = 0;
    PACL pAcl = NULL;


    PWCHAR StringSD = L"O:BAG:DUD:(A;;0x40;;;s-1-2-2)(A;;0x1;;;BA)(OA;;0x2;6da8a4ff-0e52-11d0-a286-00aa00304900;;BA)(OA;;0x4;6da8a4ff-0e52-11d0-a286-00aa00304901;;BA)(OA;;0x8;6da8a4ff-0e52-11d0-a286-00aa00304903;;AU)(OA;;0x10;6da8a4ff-0e52-11d0-a286-00aa00304904;;BU)(OA;;0x20;6da8a4ff-0e52-11d0-a286-00aa00304905;;AU)(A;;0x40;;;PS)S:(AU;IDSAFA;0xFFFFFF;;;WD)";

    b = ConvertStringSecurityDescriptorToSecurityDescriptorW(StringSD, SDDL_REVISION_1, &pSD, NULL);

    if (!b)
    {
        wprintf(L"SDDL failed with %d\n", GetLastError());
        return;
    }

    b = AuthzRMInitialize(
            MyAccessCheck,
            MyComputeDynamicGroups,
            MyFreeDynamicGroups,
            NULL,
            0,
            &RM
            );

    if (!b)
    {
        wprintf(L"AuthzRMInitialize failed with %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"AuthzRMInitialize succeeded\n");
    }

    Request.DesiredAccess = 0x101;
    wprintf(L"Desired = %x\n", Request.DesiredAccess);

    Request.ObjectTypeList = (POBJECT_TYPE_LIST) TypeListBuffer;

    Request.ObjectTypeList[0].Level = 0;
    Request.ObjectTypeList[0].ObjectType = &Guid0;
    Request.ObjectTypeList[0].Sbz = 0;

    Request.ObjectTypeList[1].Level = 1;
    Request.ObjectTypeList[1].ObjectType = &Guid1;
    Request.ObjectTypeList[1].Sbz = 0;

    Request.ObjectTypeList[2].Level = 2;
    Request.ObjectTypeList[2].ObjectType = &Guid2;
    Request.ObjectTypeList[2].Sbz = 0;

    Request.ObjectTypeList[3].Level = 2;
    Request.ObjectTypeList[3].ObjectType = &Guid3;
    Request.ObjectTypeList[3].Sbz = 0;

    Request.ObjectTypeList[4].Level = 1;
    Request.ObjectTypeList[4].ObjectType = &Guid4;
    Request.ObjectTypeList[4].Sbz = 0;

    Request.ObjectTypeList[5].Level = 2;
    Request.ObjectTypeList[5].ObjectType = &Guid5;
    Request.ObjectTypeList[5].Sbz = 0;

    Request.ObjectTypeList[6].Level = 2;
    Request.ObjectTypeList[6].ObjectType = &Guid6;
    Request.ObjectTypeList[6].Sbz = 0;

    Request.ObjectTypeListLength = 7;
    Request.OptionalArguments = NULL;

    Request.PrincipalSelfSid = NULL;

    pReply->ResultListLength = 7;
    pReply->Error = (PDWORD) (((PCHAR) pReply) + sizeof(AUTHZ_ACCESS_REPLY));
    pReply->GrantedAccessMask = (PACCESS_MASK) (pReply->Error + pReply->ResultListLength);


    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
    {
        // wprintf(L"OpenProcessToken failed with %d\n", GetLastError());
        return;
    }
    else
    {
        // wprintf(L"OpenProcessToken succeeded\n");
    }

    // wprintf(L"Calling initialize token\n");

    b = AuthzInitializeContextFromToken(
               hToken,
               RM,
               NULL,
               luid,
               0,
               NULL,
               &CC
               );

    if (!b)
    {
        // wprintf(L"AuthzInitializeContextFromToken failed\n");
        return;
    }

    for (i = 0; i < 100000; i++)
    {
        DWORD StartTime, EndTime;

        StartTime = GetCurrentTime();

        for (j = 0; j < 50000; j++)
        {
            b = AuthzAccessCheck(
                    CC,
                    &Request,
                    pAuditInfo,
                    pSD,
                    NULL,
                    0,
                    pReply,
                    0
                    );

            if (!b)
            {
                // wprintf(L"AccessCheck no SELF failed\n");
                return;
            }


        }

        EndTime = GetCurrentTime();
        wprintf(L"Time taken %d\n", EndTime - StartTime);
    }

    AuthzFreeContext(CC);
    CloseHandle(hToken);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\context.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    context.c

Abstract:

   This module implements the internal worker routines to create and manipulate
   client context.

Author:

    Kedar Dubhashi - March 2000

Environment:

    User mode only.

Revision History:

    Created - March 2000

--*/

#include "pch.h"

#pragma hdrstop

#include <authzp.h>

LUID AuthzTakeOwnershipPrivilege = {SE_TAKE_OWNERSHIP_PRIVILEGE, 0};
LUID AuthzSecurityPrivilege = {SE_SECURITY_PRIVILEGE, 0};


//
// Definitions used by AuthzpGetAllGroups.
//

const DWORD                     c_dwMaxSidCount = 1000;
static DWORD                    s_dwPageSize = 0;

typedef struct _SID_DESC
{
    DWORD                       dwAttributes;
    DWORD                       dwLength;
    BYTE                        sid[SECURITY_MAX_SID_SIZE];
}
SID_DESC, *PSID_DESC;

typedef struct _SID_SET
{
    DWORD                               dwCount;
    DWORD                               dwMaxCount;
    PSID_DESC                           pSidDesc;

    DWORD                               dwFlags;
    DWORD                               dwBaseCount;

    // user information
    PSID                                pUserSid;
    PSID                                pDomainSid;
    PUNICODE_STRING                     pusUserName;
    PUNICODE_STRING                     pusDomainName;

    // user name & domain
    PLSA_TRANSLATED_NAME                pNames;
    PLSA_REFERENCED_DOMAIN_LIST         pDomains;
    PLSA_TRANSLATED_SID2                pSids;
    SID_NAME_USE                        sidUse;

    // information about the local machine
    PPOLICY_ACCOUNT_DOMAIN_INFO         pAccountInfo;
    PPOLICY_PRIMARY_DOMAIN_INFO         pPrimaryInfo;
    BOOL                                bStandalone;
    BOOL                                bSkipNonLocal;

    // user domain dc info
    PDOMAIN_CONTROLLER_INFO             pUdDcInfo;
    PDOMAIN_CONTROLLER_INFO             pPdDcInfo;
    PDOMAIN_CONTROLLER_INFO             pRdDcInfo;

    // role information for user domain & primary domain
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pUdBasicInfo;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pPdBasicInfo;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pRdBasicInfo;

    // name of the user domain DC
    PWSTR                               pszUdDcName;
    PWSTR                               pszRdDcName;
}
SID_SET, *PSID_SET;


//
// Forward declarations of functions called by
// AuthzpGetAllGroups.
//

DWORD
AuthzpAddWellKnownSids(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetTokenGroupsXp(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetTokenGroupsDownlevel(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetAccountDomainGroupsDs(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetAccountDomainGroupsSam(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetResourceDomainGroups(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetLocalGroups(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetSidHistory(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetSamGroups(
    IN PUNICODE_STRING pusDcName,
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetAliasMembership(
    IN SAM_HANDLE hSam,
    IN PSID pDomainSid,
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpInitializeSidSetByName(
    IN PUNICODE_STRING pusUserName,
    IN PUNICODE_STRING pusDomainName,
    IN DWORD dwFlags,
    IN PSID_SET pSidSet
    );

DWORD
AuthzpInitializeSidSetBySid(
    IN PSID pUserSid,
    IN DWORD dwFlags,
    IN PSID_SET pSidSet
    );

DWORD
AuthzpDeleteSidSet(
    IN PSID_SET pSidSet
    );

DWORD
AuthzpAddSidToSidSet(
    IN PSID_SET pSidSet,
    IN PSID pSid,
    IN DWORD dwSidLength,
    IN DWORD dwAttributes,
    OUT PBOOL pbAdded OPTIONAL,
    OUT PSID* ppSid OPTIONAL
    );

DWORD
AuthzpGetUserDomainSid(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetUserDomainName(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetLocalInfo(
    IN OUT PSID_SET pSidSet
    );

DWORD
AuthzpGetDcName(
    IN LPCTSTR pszDomain,
    IN OUT PDOMAIN_CONTROLLER_INFO* ppDcInfo
    );

VOID
AuthzpConvertSidToEdn(
    IN PSID pSid,
    OUT PWSTR pszSid
    );


BOOL
AuthzpCopySidsAndAttributes(
    IN OUT PSID_AND_ATTRIBUTES DestSidAttr,
    IN PSID_AND_ATTRIBUTES SidAttr1,
    IN DWORD Count1,
    IN PSID_AND_ATTRIBUTES SidAttr2,
    IN DWORD Count2
)

/*++

Routine description:

    This routine takes two sets of sid and attribute strucutes and concatenates
    them into a single one. The new structure is constructed into the buffer
    supplied by the caller.

Arguments:

    DestSidAttr - Caller supplied buffer into which the resultant structure
        will be copied. The caller has already computed the size of the buffer
        required to hold the output.

    SidAttr1 - The first sid and attributes structure.

    Count1 - The number of elements in SidAttr1 structure.

    SidAttr2 - The second sid and attributes structure.

    Count2 - The number of elements in SidAttr2 structure.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PUCHAR   pCurrent = ((PUCHAR) DestSidAttr) + (sizeof(SID_AND_ATTRIBUTES) * (Count1 + Count2));
    NTSTATUS Status   = STATUS_SUCCESS;
    DWORD    Length   = 0;
    DWORD    i        = 0;

    //
    // Loop thru the first set and copy the sids and their attribtes.
    //

    for (i = 0; i < Count1; i++)
    {
        Length = RtlLengthSid(SidAttr1[i].Sid);

        Status = RtlCopySid(
                     Length,
                     pCurrent,
                     SidAttr1[i].Sid
                     );

        if (!NT_SUCCESS(Status))
        {
            SetLastError(RtlNtStatusToDosError(Status));
            return FALSE;
        }

        DestSidAttr[i].Sid = (PSID) pCurrent;
        DestSidAttr[i].Attributes = SidAttr1[i].Attributes;
        pCurrent += Length;
    }

    //
    // Loop thru the second set and copy the sids and their attribtes.
    //

    for (; i < (Count1 + Count2); i++)
    {
        Length = RtlLengthSid(SidAttr2[i - Count1].Sid);

        Status = RtlCopySid(
                     Length,
                     pCurrent,
                     SidAttr2[i - Count1].Sid
                     );

        if (!NT_SUCCESS(Status))
        {
            SetLastError(RtlNtStatusToDosError(Status));
            return FALSE;
        }

        DestSidAttr[i].Sid = (PSID) pCurrent;
        DestSidAttr[i].Attributes = SidAttr2[i - Count1].Attributes;
        pCurrent += Length;
    }

    return TRUE;
}


VOID
AuthzpCopyLuidAndAttributes(
    IN OUT PAUTHZI_CLIENT_CONTEXT pCC,
    IN PLUID_AND_ATTRIBUTES Source,
    IN DWORD Count,
    IN OUT PLUID_AND_ATTRIBUTES Destination
)

/*++

Routine description:

    This routine takes a luid and attributes array and copies them into a caller
    supplied buffer. It also records presence of SecurityPrivilege and
    SeTakeOwnershipPrivilege into the client context flags.

Arguments:

    pCC - Pointer to the client context structure into which the presence of
        privileges would be recorded.

    Source - The array of privileges and attributes to be copied into a supplied
        buffer.

    Count - Number of elements in the array.

    Destination - Caller allocated buffer into which the input array will be
        copied.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD i = 0;

    for (i = 0; i < Count; i++)
    {
        //
        // Record the presence of SecurityPrivilege or SeTakeOwnershipPrivilege.
        //

        if ((RtlEqualLuid(&AuthzTakeOwnershipPrivilege, &Source[i].Luid)) &&
            (Source[i].Attributes & SE_PRIVILEGE_ENABLED))
        {
            pCC->Flags |= AUTHZ_TAKE_OWNERSHIP_PRIVILEGE_ENABLED;
        }
        else if ((RtlEqualLuid(&AuthzSecurityPrivilege, &Source[i].Luid)) &&
                 (Source[i].Attributes & SE_PRIVILEGE_ENABLED))
        {
            pCC->Flags |= AUTHZ_SECURITY_PRIVILEGE_ENABLED;
        }

        RtlCopyLuid(&(Destination[i].Luid), &(Source[i].Luid));

        Destination[i].Attributes = Source[i].Attributes;
    }
}


BOOL
AuthzpGetAllGroupsByName(
    IN PUNICODE_STRING pusUserName,
    IN PUNICODE_STRING pusDomainName,
    IN DWORD dwFlags,
    OUT PSID_AND_ATTRIBUTES* ppSidAndAttributes,
    OUT PDWORD pdwSidCount,
    OUT PDWORD pdwSidLength
    )

/*++

Routine description:

    This routine works as AuthzpGetAllGroupsBySid but takes a username
    domain name pair instead of a SID. It also accepts a UPN as the
    username and an empty domain name.


Arguments:

    pusUserName - Name of the user. Can be a UPN.

    pusDomainName - domain name of the user account or NULL in case
        the user name is a UPN.

    Flags -
      AUTHZ_SKIP_TOKEN_GROUPS - Do not compute TokenGroups.
      AUTHZ_SKIP_WORLD_SID    - Do not add the WORLD SID to the context.

    ppSidAttr - Returns SidAndAttribute array. The routine allocates memory
        for this array.

    pSidCount - Returns the number of sids in the array.

    pSidLength - Returns the size of memory allocated to hold the array.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD                       dwError;
    BOOL                        bStatus             = TRUE;
    SID_SET                     sidSet              = {0};
    PSID_DESC                   pSidDesc;
    PBYTE                       pSid;
    PSID_AND_ATTRIBUTES         pSidAndAttribs;
    DWORD                       i;


    //
    // Initialize output parameters to zero.
    //

    *ppSidAndAttributes = 0;
    *pdwSidCount = 0;
    *pdwSidLength = 0;


    //
    // Initialize the SID set
    //

    dwError = AuthzpInitializeSidSetByName(
                  pusUserName,
                  pusDomainName,
                  dwFlags,
                  &sidSet
                  );

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    if (sidSet.dwFlags & AUTHZ_SKIP_TOKEN_GROUPS)
    {
        //
        // Initialize the user SID.
        //

        dwError = AuthzpGetUserDomainSid(
                      &sidSet
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        //
        // Stick the user SID, the WORLD SID and others
        // into the set if requested.
        //

        dwError = AuthzpAddWellKnownSids(
                      &sidSet
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }
    }
    else
    {
        dwError = AuthzpGetTokenGroupsXp(
                      &sidSet
                      );

        if (dwError != ERROR_SUCCESS)
        {
            //
            // enable this after LsaLogonUser gets its error codes right
            // for now we try the downlevel scenario for every possible
            // failure of (even not enough memory)
            // LsaLogonUser will return ERROR_NO_LOGON_SERVERS
            // if it can't deal with a downlevel client
            //

//            if (dwError != ERROR_INVALID_PARAMETER &&
//                dwError != ERROR_NOT_SUPPORTED)
//            {
//                goto Cleanup;
//            }


            //
            // Initialize the user SID.
            //

            dwError = AuthzpGetUserDomainSid(
                          &sidSet
                          );

            if (dwError != ERROR_SUCCESS)
            {
                goto Cleanup;
            }


            //
            // Stick the user SID, the WORLD SID and others
            // into the set if requested.
            //

            dwError = AuthzpAddWellKnownSids(
                          &sidSet
                          );

            if (dwError != ERROR_SUCCESS)
            {
                goto Cleanup;
            }


            //
            // In case AuthzpAddWellKnownSids finds that the SID is the
            // Anonymous SID, it sets the AUTHZ_SKIP_TOKEN_GROUPS flag.
            //

            if (!(sidSet.dwFlags & AUTHZ_SKIP_TOKEN_GROUPS))
            {
                //
                // Try the downlevel scenario.
                //

                dwError = AuthzpGetTokenGroupsDownlevel(
                              &sidSet
                              );

                if (dwError != ERROR_SUCCESS)
                {
                    goto Cleanup;
                }
            }
        }
    }


    //
    // Allocate memory and copy all SIDs
    // from the SID set into ppSidAndAttributes.
    //

    *pdwSidCount = sidSet.dwCount;
    *pdwSidLength = sidSet.dwCount * sizeof(SID_AND_ATTRIBUTES);

    pSidDesc = sidSet.pSidDesc;

    for (i=0;i < sidSet.dwCount;i++,pSidDesc++)
    {
        *pdwSidLength += pSidDesc->dwLength;
    }

    *ppSidAndAttributes = (PSID_AND_ATTRIBUTES)AuthzpAlloc(*pdwSidLength);

    if (*ppSidAndAttributes == 0)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    pSid = ((PBYTE)*ppSidAndAttributes) +
            sidSet.dwCount * sizeof(SID_AND_ATTRIBUTES);
    pSidDesc = sidSet.pSidDesc;
    pSidAndAttribs = *ppSidAndAttributes;

    for (i=0;i < sidSet.dwCount;i++,pSidDesc++,pSidAndAttribs++)
    {
        pSidAndAttribs->Attributes = pSidDesc->dwAttributes;
        pSidAndAttribs->Sid = pSid;

        RtlCopyMemory(
            pSid,
            pSidDesc->sid,
            pSidDesc->dwLength
            );

        pSid += pSidDesc->dwLength;
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (dwError != ERROR_SUCCESS)
    {
        SetLastError(dwError);
        bStatus = FALSE;

        *pdwSidCount = 0;
        *pdwSidLength = 0;

        if (*ppSidAndAttributes)
        {
            AuthzpFree(*ppSidAndAttributes);
            *ppSidAndAttributes = 0;
        }
    }

    AuthzpDeleteSidSet(&sidSet);

    return bStatus;
}


BOOL
AuthzpGetAllGroupsBySid(
    IN PSID pUserSid,
    IN DWORD dwFlags,
    OUT PSID_AND_ATTRIBUTES* ppSidAndAttributes,
    OUT PDWORD pdwSidCount,
    OUT PDWORD pdwSidLength
    )

/*++

Routine description:

    This routine computes the groups a given user is a member of.
    It uses a data structure called a SID_SET for collecting the SIDs.

    1. Initialize the SID_SET.

    2. Put the user SID into the set.
       If requested, put the EVERYONE SID into the set.
       Add Well Known SIDs.

    3. If requested, put the SIDs for non-local groups the user is
       a member of into the set. There are three scenarios for this
       step, depending on the version of the DC we are talking to:

       xp:  Use LsaLogonUser with the Kerberos S4U package and
            extract the groups from the token returned
            (AuthzpGetWXPDomainTokenGroups).

       W2k: Use ldap and the SAM API to compute memberships in
       NT4: the account and primary domain and to get the SID history
            (AuthzpGetW2kDomainTokenGroups).

    4. Transmogrify the SID_SET into a SID_AND_ATTRIBUTES array
       and free the SID_SET.

Arguments:

    pUserSid - The user SID for which the groups should be computed.

    Flags -
      AUTHZ_SKIP_TOKEN_GROUPS - Do not compute TokenGroups.
      AUTHZ_SKIP_WORLD_SID    - Do not add the WORLD SID to the context.

    ppSidAttr - Returns SidAndAttribute array. The routine allocates memory
        for this array.

    pSidCount - Returns the number of sids in the array.

    pSidLength - Returns the size of memory allocated to hold the array.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD                       dwError;
    BOOL                        bStatus             = TRUE;
    SID_SET                     sidSet              = {0};
    PSID_DESC                   pSidDesc;
    PBYTE                       pSid;
    PSID_AND_ATTRIBUTES         pSidAndAttribs;
    DWORD                       i;


    //
    // Initialize output parameters to zero.
    //

    *ppSidAndAttributes = 0;
    *pdwSidCount = 0;
    *pdwSidLength = 0;


    //
    // Initialize the SID set
    //

    dwError = AuthzpInitializeSidSetBySid(
                  pUserSid,
                  dwFlags,
                  &sidSet
                  );

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    if (sidSet.dwFlags & AUTHZ_SKIP_TOKEN_GROUPS)
    {
        //
        // Stick the user SID, the WORLD SID and others
        // into the set if requested.
        //

        dwError = AuthzpAddWellKnownSids(
                      &sidSet
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }
    }
    else
    {
        //
        // Initialize user and domain name members of the sid set.
        //

        dwError = AuthzpGetUserDomainName(
                      &sidSet
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        if (sidSet.pNames->Use == SidTypeAlias ||
            sidSet.pNames->Use == SidTypeGroup ||
            sidSet.pNames->Use == SidTypeWellKnownGroup)
        {
            //
            // LsaLogonUser cannot log on groups...
            //

            dwError = ERROR_NOT_SUPPORTED;
        }
        else
        {
            dwError = AuthzpGetTokenGroupsXp(
                          &sidSet
                          );
        }

        if (dwError != ERROR_SUCCESS)
        {
            //
            // enable this after LsaLogonUser gets its error codes right
            // for now we try the downlevel scenario for every possible
            // failure of (even not enough memory)
            // LsaLogonUser will return ERROR_NO_LOGON_SERVERS
            // if it can't deal with a downlevel client
            //

//            if (dwError != ERROR_INVALID_PARAMETER &&
//                dwError != ERROR_NOT_SUPPORTED)
//            {
//                goto Cleanup;
//            }


            //
            // Stick the user SID, the WORLD SID and others
            // into the set if requested.
            //

            dwError = AuthzpAddWellKnownSids(
                          &sidSet
                          );

            if (dwError != ERROR_SUCCESS)
            {
                goto Cleanup;
            }


            //
            // In case AuthzpAddWellKnownSids finds that the SID is the
            // Anonymous SID, it sets the AUTHZ_SKIP_TOKEN_GROUPS flag.
            //

            if (!(sidSet.dwFlags & AUTHZ_SKIP_TOKEN_GROUPS))
            {
                //
                // Try the downlevel scenario.
                //

                dwError = AuthzpGetTokenGroupsDownlevel(
                              &sidSet
                              );

                if (dwError != ERROR_SUCCESS)
                {
                    goto Cleanup;
                }
            }
        }
    }


    //
    // Allocate memory and copy all SIDs
    // from the SID set into ppSidAndAttributes.
    //

    *pdwSidCount = sidSet.dwCount;
    *pdwSidLength = sidSet.dwCount * sizeof(SID_AND_ATTRIBUTES);

    pSidDesc = sidSet.pSidDesc;

    for (i=0;i < sidSet.dwCount;i++,pSidDesc++)
    {
        *pdwSidLength += pSidDesc->dwLength;
    }

    *ppSidAndAttributes = (PSID_AND_ATTRIBUTES)AuthzpAlloc(*pdwSidLength);

    if (*ppSidAndAttributes == 0)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    pSid = ((PBYTE)*ppSidAndAttributes) +
            sidSet.dwCount * sizeof(SID_AND_ATTRIBUTES);
    pSidDesc = sidSet.pSidDesc;
    pSidAndAttribs = *ppSidAndAttributes;

    for (i=0;i < sidSet.dwCount;i++,pSidDesc++,pSidAndAttribs++)
    {
        pSidAndAttribs->Attributes = pSidDesc->dwAttributes;
        pSidAndAttribs->Sid = pSid;

        RtlCopyMemory(
            pSid,
            pSidDesc->sid,
            pSidDesc->dwLength
            );

        pSid += pSidDesc->dwLength;
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (dwError != ERROR_SUCCESS)
    {
        SetLastError(dwError);
        bStatus = FALSE;

        *pdwSidCount = 0;
        *pdwSidLength = 0;

        if (*ppSidAndAttributes)
        {
            AuthzpFree(*ppSidAndAttributes);
            *ppSidAndAttributes = 0;
        }
    }

    AuthzpDeleteSidSet(&sidSet);

    return bStatus;
}


DWORD
AuthzpAddWellKnownSids(
    IN OUT PSID_SET pSidSet
    )
{
    DWORD                       dwError;
    BOOL                        bStatus;
    BOOL                        bEqual;
    BOOL                        bAddEveryone        = TRUE;
    BOOL                        bAddLocal           = TRUE;
    BOOL                        bAddAuthUsers       = TRUE;
    BOOL                        bAddAdministrators  = FALSE;
    BYTE                        sid[SECURITY_MAX_SID_SIZE];
    PSID                        pSid                = (PSID)sid;
    DWORD                       dwLengthSid;


    //
    // Stick the user SID into the set
    //

    dwError = AuthzpAddSidToSidSet(
                  pSidSet,
                  pSidSet->pUserSid,
                  0,
                  SE_GROUP_ENABLED,
                  0,
                  0
                  );

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    pSidSet->dwBaseCount = 1;


    //
    // Test for some well known SIDs.
    //
    // If the SID passed in is the Anonymous SID, then check the registry
    // value to determine if the Everyone SID should be included in the
    // resulting client context.
    //

    if (IsWellKnownSid(
            pSidSet->pUserSid,
            WinAnonymousSid))
    {
        bAddEveryone = FALSE;
        bAddLocal = FALSE;
        bAddAuthUsers = FALSE;

        bStatus = AuthzpEveryoneIncludesAnonymous(
                      &bAddEveryone
                      );

        if (bStatus == FALSE)
        {
            bAddEveryone = FALSE;
        }

        pSidSet->dwFlags |= AUTHZ_SKIP_TOKEN_GROUPS;
    }
    else if (IsWellKnownSid(
                pSidSet->pUserSid,
                WinLocalSystemSid))
    {
        bAddEveryone = TRUE;
        bAddLocal = TRUE;
        bAddAuthUsers = TRUE;
        bAddAdministrators = TRUE;

        pSidSet->dwFlags |= AUTHZ_SKIP_TOKEN_GROUPS;
    }
    else
    {
        dwLengthSid = SECURITY_MAX_SID_SIZE;

        bStatus = CreateWellKnownSid(
                      WinBuiltinDomainSid,
                      0,
                      pSid,
                      &dwLengthSid
                      );

        if (bStatus == FALSE)
        {
            dwError = GetLastError();
            goto Cleanup;
        }

        bStatus = EqualDomainSid(
                      pSidSet->pUserSid,
                      pSid,
                      &bEqual
                      );
        //
        // ERROR_NON_DOMAIN_SID os returned for wellknown sids.
        // It is ok to ignore thhis error and continue.
        //

        if ((bStatus == FALSE) && (GetLastError() != ERROR_NON_DOMAIN_SID))
        {
            dwError = GetLastError();
            goto Cleanup;
        }

        if (bEqual)
        {
            pSidSet->bSkipNonLocal = TRUE;
        }
        else
        {
            bAddEveryone = TRUE;
            bAddLocal = TRUE;
            bAddAuthUsers = TRUE;
        }
    }

    if (bAddEveryone)
    {
        dwLengthSid = SECURITY_MAX_SID_SIZE;

        bStatus = CreateWellKnownSid(
                      WinWorldSid,
                      0,
                      pSid,
                      &dwLengthSid
                      );

        if (bStatus == FALSE)
        {
            dwError = GetLastError();
            goto Cleanup;
        }

        dwError = AuthzpAddSidToSidSet(
                      pSidSet,
                      pSid,
                      dwLengthSid,
                      SE_GROUP_MANDATORY
                        | SE_GROUP_ENABLED_BY_DEFAULT
                        | SE_GROUP_ENABLED,
                      0,
                      0
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        pSidSet->dwBaseCount++;
    }

    if (bAddLocal)
    {
        //
        // add \LOCAL to the set
        //

        dwLengthSid = SECURITY_MAX_SID_SIZE;

        bStatus = CreateWellKnownSid(
                      WinLocalSid,
                      0,
                      pSid,
                      &dwLengthSid
                      );

        if (bStatus == FALSE)
        {
            dwError = GetLastError();
            goto Cleanup;
        }

        dwError = AuthzpAddSidToSidSet(
                      pSidSet,
                      pSid,
                      dwLengthSid,
                      SE_GROUP_MANDATORY
                        | SE_GROUP_ENABLED_BY_DEFAULT
                        | SE_GROUP_ENABLED,
                      0,
                      0
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        pSidSet->dwBaseCount++;
    }


    //
    // Add  NT AUTHORITY\Authenticated Users  to the set
    // only if the user does not have the Guest RID
    //

    if (bAddAuthUsers &&
        *RtlSubAuthorityCountSid(pSidSet->pUserSid) > 0 &&
        (*RtlSubAuthoritySid(
            pSidSet->pUserSid,
            (ULONG)(*RtlSubAuthorityCountSid(
                        pSidSet->pUserSid)) - 1) != DOMAIN_USER_RID_GUEST) &&
        (*RtlSubAuthoritySid(
            pSidSet->pUserSid,
            (ULONG)(*RtlSubAuthorityCountSid(
                        pSidSet->pUserSid)) - 1) != DOMAIN_GROUP_RID_GUESTS))
    {
        dwLengthSid = SECURITY_MAX_SID_SIZE;

        bStatus = CreateWellKnownSid(
                      WinAuthenticatedUserSid,
                      0,
                      pSid,
                      &dwLengthSid
                      );

        if (bStatus == FALSE)
        {
            dwError = GetLastError();
            goto Cleanup;
        }

        dwError = AuthzpAddSidToSidSet(
                      pSidSet,
                      pSid,
                      dwLengthSid,
                      SE_GROUP_MANDATORY
                        | SE_GROUP_ENABLED_BY_DEFAULT
                        | SE_GROUP_ENABLED,
                      0,
                      0
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        pSidSet->dwBaseCount++;
    }

    if (bAddAdministrators)
    {
        //
        // add \LOCAL to the set
        //

        dwLengthSid = SECURITY_MAX_SID_SIZE;

        bStatus = CreateWellKnownSid(
                      WinBuiltinAdministratorsSid,
                      0,
                      pSid,
                      &dwLengthSid
                      );

        if (bStatus == FALSE)
        {
            dwError = GetLastError();
            goto Cleanup;
        }

        dwError = AuthzpAddSidToSidSet(
                      pSidSet,
                      pSid,
                      dwLengthSid,
                      SE_GROUP_MANDATORY
                        | SE_GROUP_ENABLED_BY_DEFAULT
                        | SE_GROUP_ENABLED,
                      0,
                      0
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        pSidSet->dwBaseCount++;
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    return dwError;
}


DWORD
AuthzpGetTokenGroupsXp(
    IN OUT PSID_SET pSidSet
    )

/*++

Routine description:

    This routine connects to the domain specified by the SID and
    retrieves the list of groups to which the user belongs.
    This routine assumes we are talking to a WinXP DC.
    We take advantage of the new LsaLogonUser package, KerbS4ULogon.

Arguments:

    pUserSid - user SID for which the lookup should be performed.

    pSidSet - SID_SET in which we collect the SIDs of the groups
        we found in the token.

Return Value:

    Win32 error code:

    - ERROR_NOT_SUPPORTED if the DC does not support the call
        (pre ~2475 or client)
    - ERROR_INVALID_PARAMETER if the code is running on a
        pre XP platform

--*/

{
    DWORD                       dwError             = ERROR_SUCCESS;
    BOOL                        bStatus;
    NTSTATUS                    status;
    HANDLE                      hLsa                = 0;
    LSA_STRING                  asProcessName;
    LSA_STRING                  asPackageName;
    ULONG                       ulAuthPackage;
    TOKEN_SOURCE                sourceContext;
    PVOID                       pProfileBuffer      = 0;
    ULONG                       ulProfileLength     = 0;
    LUID                        luidLogonId;
    HANDLE                      hToken              = 0;
    QUOTA_LIMITS                quota;
    NTSTATUS                    subStatus;
    DWORD                       dwLength;
    DWORD                       i;
    PTOKEN_USER                 pTokenUser          = 0;
    PTOKEN_GROUPS               pTokenGroups        = 0;
    PSID_AND_ATTRIBUTES         pSidAndAttribs;
    ULONG                       ulPackageSize;
    PKERB_S4U_LOGON             pPackage            = 0;
    NT_PRODUCT_TYPE             ProductType;


    //
    // For now, S4U is not specified to work on the client.
    //

    if (!RtlGetNtProductType(&ProductType) ||
        ProductType == NtProductWinNt)
    {
        dwError = ERROR_NOT_SUPPORTED;
        goto Cleanup;
    }


    //
    // Set up the authentication package.
    //

    ulPackageSize = sizeof(KERB_S4U_LOGON);
    ulPackageSize += pSidSet->pusUserName->Length;

    if (pSidSet->pusDomainName)
    {
        ulPackageSize += pSidSet->pusDomainName->Length;
    }

    pPackage = (PKERB_S4U_LOGON)LocalAlloc(
                    LMEM_FIXED,
                    ulPackageSize
                    );

    if (pPackage == 0)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    pPackage->MessageType = KerbS4ULogon;
    pPackage->Flags = 0;

    pPackage->ClientUpn.Length = pSidSet->pusUserName->Length;
    pPackage->ClientUpn.MaximumLength = pSidSet->pusUserName->Length;
    pPackage->ClientUpn.Buffer = (PWSTR)(pPackage + 1);

    RtlCopyMemory(
        pPackage->ClientUpn.Buffer,
        pSidSet->pusUserName->Buffer,
        pSidSet->pusUserName->Length
        );

    if (pSidSet->pusDomainName)
    {
        pPackage->ClientRealm.Length = pSidSet->pusDomainName->Length;
        pPackage->ClientRealm.MaximumLength = pSidSet->pusDomainName->Length;
        pPackage->ClientRealm.Buffer = (PWSTR)
            (((PBYTE)(pPackage->ClientUpn.Buffer)) + pPackage->ClientUpn.Length);

        RtlCopyMemory(
            pPackage->ClientRealm.Buffer,
            pSidSet->pusDomainName->Buffer,
            pSidSet->pusDomainName->Length
            );
    }
    else
    {
        pPackage->ClientRealm.Length = 0;
        pPackage->ClientRealm.MaximumLength = 0;
        pPackage->ClientRealm.Buffer = 0;
    }


    //
    // Our name is AuthzApi.
    //

    RtlInitString(
        &asProcessName,
        "AuthzApi"
        );


    //
    // Set up the process name and
    // register with the LSA.
    //

    status = LsaConnectUntrusted(
                 &hLsa
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }


    //
    // Get the authentication package.
    //

    RtlInitString(&asPackageName, MICROSOFT_KERBEROS_NAME_A);

    status = LsaLookupAuthenticationPackage(
                 hLsa,
                 &asPackageName,
                 &ulAuthPackage
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }


    //
    // Prepare the source context.
    //

    RtlCopyMemory(
        sourceContext.SourceName,
        "Authz   ",
        sizeof(sourceContext.SourceName)
        );

    status = NtAllocateLocallyUniqueId(
                 &sourceContext.SourceIdentifier
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Do the logon.
    //

    status = LsaLogonUser(
                 hLsa,
                 &asProcessName,
                 Network,
                 ulAuthPackage,
                 pPackage,
                 ulPackageSize,
                 0,                          // no LocalGroups
                 &sourceContext,
                 &pProfileBuffer,
                 &ulProfileLength,
                 &luidLogonId,
                 &hToken,
                 &quota,
                 &subStatus
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }


    //
    // Figure out how much memory to allocate for the user info.
    //

    dwLength = 0;

    bStatus = GetTokenInformation(
                  hToken,
                  TokenUser,
                  0,
                  0,
                  &dwLength
                  );

    if (bStatus == FALSE)
    {
        dwError = GetLastError();

        if (dwError != ERROR_INSUFFICIENT_BUFFER)
        {
            goto Cleanup;
        }
    }

    pTokenUser = (PTOKEN_USER)LocalAlloc(
                        LMEM_FIXED,
                        dwLength
                        );

    if (pTokenUser == 0)
    {
        dwError = GetLastError();
        goto Cleanup;
    }


    //
    // Extract the user SID from the token and
    // add it to pSidSet.
    //

    bStatus = GetTokenInformation(
                  hToken,
                  TokenUser,
                  pTokenUser,
                  dwLength,
                  &dwLength
                  );

    if (bStatus == FALSE)
    {
        dwError = GetLastError();
        goto Cleanup;
    }


    //
    // Stick the user SID into the set.
    //

    if (!FLAG_ON(pTokenUser->User.Attributes, SE_GROUP_USE_FOR_DENY_ONLY))
    {
        pTokenUser->User.Attributes |= SE_GROUP_ENABLED;
    }

    dwError = AuthzpAddSidToSidSet(
                  pSidSet,
                  pTokenUser->User.Sid,
                  0,
                  pTokenUser->User.Attributes,
                  0,
                  0
                  );

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }


    //
    // Figure out how much memory to allocate for the token groups.
    //

    dwLength = 0;

    bStatus = GetTokenInformation(
                  hToken,
                  TokenGroups,
                  0,
                  0,
                  &dwLength
                  );

    if (bStatus == FALSE)
    {
        dwError = GetLastError();

        if (dwError != ERROR_INSUFFICIENT_BUFFER)
        {
            goto Cleanup;
        }
    }

    pTokenGroups = (PTOKEN_GROUPS)LocalAlloc(
                        LMEM_FIXED,
                        dwLength
                        );

    if (pTokenGroups == 0)
    {
        dwError = GetLastError();
        goto Cleanup;
    }


    //
    // Extract the user groups from the token and
    // add them to pSidSet.
    //

    bStatus = GetTokenInformation(
                  hToken,
                  TokenGroups,
                  pTokenGroups,
                  dwLength,
                  &dwLength
                  );

    if (bStatus == FALSE)
    {
        dwError = GetLastError();
        goto Cleanup;
    }


    //
    // Stick the group SIDs into the set
    // except for the Network and the LUID SID.
    //

    pSidAndAttribs = pTokenGroups->Groups;

    for (i=0;i < pTokenGroups->GroupCount;i++,pSidAndAttribs++)
    {
        if (!IsWellKnownSid(
                pSidAndAttribs->Sid,
                WinNetworkSid) &&
            !IsWellKnownSid(
                pSidAndAttribs->Sid,
                WinLogonIdsSid))
        {
            dwError = AuthzpAddSidToSidSet(
                          pSidSet,
                          pSidAndAttribs->Sid,
                          0,
                          pSidAndAttribs->Attributes,
                          0,
                          0
                          );

            if (dwError != ERROR_SUCCESS)
            {
                goto Cleanup;
            }
        }
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (pTokenUser)
    {
        LocalFree((HLOCAL)pTokenUser);
    }

    if (pTokenGroups)
    {
        LocalFree((HLOCAL)pTokenGroups);
    }

    if (hToken)
    {
        CloseHandle(hToken);
    }

    if (pProfileBuffer)
    {
        LsaFreeReturnBuffer(pProfileBuffer);
    }

    if (hLsa)
    {
        LsaDeregisterLogonProcess(hLsa);
    }

    if (pPackage)
    {
        LocalFree((HLOCAL)pPackage);
    }

    return dwError;
}


DWORD
AuthzpGetTokenGroupsDownlevel(
    IN OUT PSID_SET pSidSet
    )

/*++

Routine description:

    This routine connects to the domain specified by the SID and
    retrieves the list of groups to which the user belongs.
    This routine assumes we are talking to a Win2k DC.
    First get the users domain universal and global groups
    memberships.
    Next check for nested memberships in the primary domain.
    The last step is getting the SID history for each SID collected
    so far.

Arguments:

    pUserSid - user SID for which the lookup should be performed.

    pSidSet - Returns the number of rids in the alias list

Return Value:

    Win32 error code.

--*/

{
    DWORD                       dwError;
    BOOL                        bUdIsNative         = FALSE;
    BOOL                        bRdIsNative         = FALSE;
    BOOL                        bAddPrimaryGroup    = FALSE;
    SAM_HANDLE                  hSam                = 0;
    SAM_HANDLE                  hDomain             = 0;
    SAM_HANDLE                  hUser               = 0;


    //
    // Retrieve information about the machine.
    //

    dwError = AuthzpGetLocalInfo(pSidSet);

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    if (pSidSet->bStandalone ||
        pSidSet->bSkipNonLocal)
    {
        //
        // In the standalone case there is no need to hit the wire.
        // We don't have to do anything here since local group
        // memberships are computed later anyway.
        //

        bAddPrimaryGroup = TRUE;
        goto LocalGroups;
    }


    //
    // Compare the user domain SID to the machine domain SID.
    // If they are equal, we don't need to go to a DC.
    // Instead we use the local machine.
    // The SID of the local machine is never zero in a non
    // standalone / workgroup case.
    //

    if (pSidSet->pAccountInfo->DomainSid &&
        RtlEqualSid(
            pSidSet->pDomainSid,
            pSidSet->pAccountInfo->DomainSid))
    {
        pSidSet->pszUdDcName = 0;
        bAddPrimaryGroup = TRUE;
        goto LocalGroups;
    }
    else
    {
        //
        // Find a DC and get its name.
        //

        dwError = AuthzpGetDcName(
                      pSidSet->pDomains->Domains->Name.Buffer,
                      &pSidSet->pUdDcInfo
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        pSidSet->pszUdDcName = pSidSet->pUdDcInfo->DomainControllerName;
    }


    //
    // User domain can only be in native mode if DS is running.
    //

    if ((pSidSet->pUdDcInfo == 0) ||
        (pSidSet->pUdDcInfo->Flags & DS_DS_FLAG) != 0)
    {
        //
        // Collect information about the domain.
        //

        dwError = DsRoleGetPrimaryDomainInformation(
                      pSidSet->pszUdDcName,
                      DsRolePrimaryDomainInfoBasic,
                      (PBYTE*)&pSidSet->pUdBasicInfo
                      );

        if (dwError != ERROR_SUCCESS)
        {
            //
            // If the domain is in mixed mode and we are passing in a DNS
            // name, the call fails. We have to get rid of the DC name
            // and get a flat one and then try again.
            //

            if (dwError == RPC_S_SERVER_UNAVAILABLE &&
                pSidSet->pUdDcInfo &&
                (pSidSet->pUdDcInfo->Flags & DS_INET_ADDRESS))
            {
                NetApiBufferFree(pSidSet->pUdDcInfo);
                pSidSet->pUdDcInfo = 0;

                dwError = DsGetDcName(
                              0,
                              pSidSet->pDomains->Domains->Name.Buffer,
                              0,
                              0,
                              0,
                              &pSidSet->pUdDcInfo
                              );

                if (dwError != ERROR_SUCCESS)
                {
                    goto Cleanup;
                }

                pSidSet->pszUdDcName = pSidSet->pUdDcInfo->DomainControllerName;

                dwError = DsRoleGetPrimaryDomainInformation(
                              pSidSet->pszUdDcName,
                              DsRolePrimaryDomainInfoBasic,
                              (PBYTE*)&pSidSet->pUdBasicInfo
                              );

                if (dwError != ERROR_SUCCESS)
                {
                    goto Cleanup;
                }
            }
            else
            {
                goto Cleanup;
            }
        }
        if ((pSidSet->pUdBasicInfo->Flags & DSROLE_PRIMARY_DS_RUNNING) &&
            ((pSidSet->pUdBasicInfo->Flags & DSROLE_PRIMARY_DS_MIXED_MODE) == 0))
        {
            bUdIsNative = TRUE;
        }
    }


    //
    // Check whether the account domain is in native or mixed mode
    // and call the appropriate routine to get the groups.
    //

    if (bUdIsNative)
    {
        //
        // User domain is in native mode.
        //

        dwError = AuthzpGetAccountDomainGroupsDs(
                      pSidSet
                      );
    }
    else
    {
        //
        // User domain is in mixed mode.
        //

        dwError = AuthzpGetAccountDomainGroupsSam(
                      pSidSet
                      );
    }

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }


    //
    // Check whether user domain and resource domain are different.
    //

    if (pSidSet->pPrimaryInfo->Sid &&
        RtlEqualSid(
            pSidSet->pDomainSid,
            pSidSet->pPrimaryInfo->Sid))
    {
        pSidSet->pszRdDcName = pSidSet->pszUdDcName;
        pSidSet->pRdDcInfo = pSidSet->pUdDcInfo;
        pSidSet->pRdBasicInfo = pSidSet->pUdBasicInfo;
        bRdIsNative = bUdIsNative;
    }
    else
    {
        //
        // Find a DC and get its name.
        //

        dwError = AuthzpGetDcName(
                      pSidSet->pPrimaryInfo->Name.Buffer,
                      &pSidSet->pPdDcInfo
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        pSidSet->pszRdDcName = pSidSet->pPdDcInfo->DomainControllerName;
        pSidSet->pRdDcInfo = pSidSet->pPdDcInfo;


        //
        // Resource domain can only be in native mode if DS is running.
        //

        if (pSidSet->pRdDcInfo->Flags & DS_DS_FLAG)
        {
            dwError = DsRoleGetPrimaryDomainInformation(
                          pSidSet->pszRdDcName,
                          DsRolePrimaryDomainInfoBasic,
                          (PBYTE*)&pSidSet->pPdBasicInfo
                          );

            if (dwError != ERROR_SUCCESS)
            {
                //
                // If the domain is in mixed mode and we are passing in a DNS
                // name, the call fails. We have to get rid of the DC name
                // and get a flat one and then try again.
                //

                if (dwError == RPC_S_SERVER_UNAVAILABLE &&
                    pSidSet->pPdDcInfo &&
                    (pSidSet->pPdDcInfo->Flags & DS_INET_ADDRESS))
                {
                    NetApiBufferFree(pSidSet->pPdDcInfo);
                    pSidSet->pPdDcInfo = 0;
                    pSidSet->pRdDcInfo = 0;

                    dwError = DsGetDcName(
                                  0,
                                  pSidSet->pPrimaryInfo->Name.Buffer,
                                  0,
                                  0,
                                  0,
                                  &pSidSet->pPdDcInfo
                                  );

                    if (dwError != ERROR_SUCCESS)
                    {
                        goto Cleanup;
                    }

                    pSidSet->pRdDcInfo = pSidSet->pPdDcInfo;
                    pSidSet->pszRdDcName = pSidSet->pRdDcInfo->DomainControllerName;

                    dwError = DsRoleGetPrimaryDomainInformation(
                                  pSidSet->pszRdDcName,
                                  DsRolePrimaryDomainInfoBasic,
                                  (PBYTE*)&pSidSet->pPdBasicInfo
                                  );

                    if (dwError != ERROR_SUCCESS)
                    {
                        goto Cleanup;
                    }
                }
                else
                {
                    goto Cleanup;
                }
            }

            pSidSet->pRdBasicInfo = pSidSet->pPdBasicInfo;

            if ((pSidSet->pRdBasicInfo->Flags & DSROLE_PRIMARY_DS_RUNNING) &&
                (pSidSet->pRdBasicInfo->Flags & DSROLE_PRIMARY_DS_MIXED_MODE) == 0)
            {
                bRdIsNative = TRUE;
            }
        }
    }


    //
    // Get domain local groups.
    //

    if (bRdIsNative)
    {
        //
        // Primary domain operates in native mode.
        // This means there could be domain local groups in the token.
        //

        dwError = AuthzpGetResourceDomainGroups(
                    pSidSet);

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }
    }


LocalGroups:


    //
    // If this is the local user case, we have to add the primary group for
    // for the user.
    //

    if (bAddPrimaryGroup)
    {
        NTSTATUS status;
        PUCHAR Buffer = NULL;
        PSID pPrimaryGroupSid = NULL;
        OBJECT_ATTRIBUTES obja = {0};
        DWORD dwRelativeId        = 0;

        //
        // Connect to local Sam.
        //

        status = SamConnect(
                     0,
                     &hSam,
                     SAM_SERVER_LOOKUP_DOMAIN,
                     &obja
                     );

        if (!NT_SUCCESS(status))
        {
            dwError = RtlNtStatusToDosError(status);
            goto Cleanup;
        }


        //
        // Open the domain we are interested in.
        //

        status = SamOpenDomain(
                     hSam,
                     DOMAIN_LOOKUP,
                     pSidSet->pDomainSid,
                     &hDomain
                     );

        if (!NT_SUCCESS(status))
        {
            dwError = RtlNtStatusToDosError(status);
            goto Cleanup;
        }


        //
        // Finally, get a SAM handle to the user.
        //

        dwRelativeId = *RtlSubAuthoritySid(
                            pSidSet->pUserSid,
                            *RtlSubAuthorityCountSid(pSidSet->pUserSid) - 1
                            );

        //
        // Open the user for read.
        //

        status = SamOpenUser(
                     hDomain,
                     USER_READ_GENERAL,
                     dwRelativeId,
                     &hUser
                     );

        if (!NT_SUCCESS(status))
        {
            dwError = RtlNtStatusToDosError(status);
            goto Cleanup;
        }

        //
        // Get the primary group information for the user.
        //

        status = SamQueryInformationUser(
                     hUser,
                     UserPrimaryGroupInformation,
                     (VOID *) &Buffer
                     );

        if (!NT_SUCCESS(status))
        {
            dwError = RtlNtStatusToDosError(status);
            goto Cleanup;
        }

        //
        // Convert the rid to Sid.
        //

        status = SamRidToSid(
                     hDomain,
                     ((USER_PRIMARY_GROUP_INFORMATION *) Buffer)->PrimaryGroupId,
                     &pPrimaryGroupSid
                     );

        (VOID) SamFreeMemory(Buffer);

        if (!NT_SUCCESS(status))
        {
            dwError = RtlNtStatusToDosError(status);
            goto Cleanup;
        }

        dwError = AuthzpAddSidToSidSet(
                      pSidSet,
                      pPrimaryGroupSid,
                      0,
                      SE_GROUP_ENABLED,
                      0,
                      0
                      );

        SamFreeMemory(pPrimaryGroupSid);

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }
    }

    //
    // Collect local groups information.
    //

    dwError = AuthzpGetLocalGroups(
                  pSidSet
                  );

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

Cleanup:

    if (bAddPrimaryGroup)
    {
        if (hUser)
        {
            SamCloseHandle(hUser);
        }

        if (hDomain)
        {
            SamCloseHandle(hDomain);
        }

        if (hSam)
        {
            SamCloseHandle(hSam);
        }

    }

    return dwError;
}


DWORD
AuthzpGetAccountDomainGroupsDs(
    IN OUT PSID_SET pSidSet
    )

/*++

Routine description:

    This routine connects to the user domain and queries AD for 
    the list of groups (global and universal) the user belongs to.

Arguments:

    pbNativeDomain - Pointer to a BOOL that will receive TRUE or FALSE depending
        on the domain operation mode (native or mixed, resp).

    pSidSet - Pointer to set of SIDs. New groups will be added to this set.

Return Value:

    Win32 error code.

--*/

{
    DWORD                       dwError;
    PLDAP                       pLdap               = 0;
    LDAPMessage*                pResult             = 0;
    LDAPMessage*                pEntry              = 0;
    PLDAP_BERVAL*               ppValue             = 0;
    PWCHAR                      ppszAttributes[]    = {L"tokenGroupsGlobalAndUniversal", 0};
    DWORD                       i;
    DWORD                       dwSidCount;
    WCHAR                       szSidEdn[SECURITY_MAX_SID_SIZE * 2 + 8];

    AuthzpConvertSidToEdn(
        pSidSet->pUserSid,
        szSidEdn
        );


    //
    // We now have the user's SID in LDAP readable form. Fetch the
    // tokenGroupsGlobalAndUniversal attribute.
    //

    pLdap = ldap_init(
                pSidSet->pszUdDcName ? pSidSet->pszUdDcName + 2 : 0,
                LDAP_PORT
                );

    if (pLdap == 0)
    {
        dwError = LdapMapErrorToWin32(LdapGetLastError());
        goto Cleanup;
    }

    if (pSidSet->pszUdDcName)
    {
        dwError = ldap_set_option(
                      pLdap,
                      LDAP_OPT_AREC_EXCLUSIVE,
                      LDAP_OPT_ON
                      );

        if (dwError != LDAP_SUCCESS)
        {
            dwError = LdapMapErrorToWin32(dwError);
            goto Cleanup;
        }
    }

    dwError = ldap_bind_s(
                  pLdap,
                  0,
                  0,
                  LDAP_AUTH_SSPI
                  );

    if (dwError != LDAP_SUCCESS)
    {
        dwError = LdapMapErrorToWin32(dwError);
        goto Cleanup;
    }

    dwError = ldap_search_s(
                  pLdap,
                  szSidEdn,
                  LDAP_SCOPE_BASE,
                  L"objectClass=*",
                  ppszAttributes,
                  FALSE,
                  &pResult
                  );

    if (dwError != LDAP_SUCCESS)
    {
        dwError = LdapMapErrorToWin32(dwError);
        goto Cleanup;
    }

    pEntry = ldap_first_entry(
                 pLdap,
                 pResult
                 );

    if (pEntry == 0)
    {
        dwError = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    ppValue = ldap_get_values_len(
                  pLdap,
                  pEntry,
                  ppszAttributes[0]
                  );

    dwSidCount = ldap_count_values_len(ppValue);


    //
    // Merge the groups for our user into the result set.
    //

    for (i=0;i < dwSidCount;i++)
    {
        dwError = AuthzpAddSidToSidSet(
                      pSidSet,
                      (*ppValue[i]).bv_val,
                      (*ppValue[i]).bv_len,
                      SE_GROUP_ENABLED,
                      0,
                      0
                      );

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (ppValue)
    {
        ldap_value_free_len(ppValue);
    }

    if (pResult)
    {
        ldap_msgfree(pResult);
    }

    if (pLdap)
    {
        ldap_unbind(pLdap);
    }

    return dwError;
}


DWORD
AuthzpGetAccountDomainGroupsSam(
    IN OUT PSID_SET pSidSet
    )

/*++

Routine description:

    This routine connects to the domain specified by the SID and
    retrieves the list of groups to which the user belongs.
    This resembles what the NetUserGetGroups API does. We are
    not using it, because the Net APIs are name based and we
    are working with SIDs.

Arguments:

    pusDcName - DC on which the lookup should be performed.

    pSidSet - Returns the number of SIDs in the alias list.

Return Value:

    Win32 error code.

--*/

{
    NTSTATUS                    status;
    DWORD                       dwError             = ERROR_SUCCESS;
    PGROUP_MEMBERSHIP           pGroups             = 0;
    PGROUP_MEMBERSHIP           pGroup;
    DWORD                       dwGroupCount        = 0;
    DWORD                       dwRelativeId        = 0;
    DWORD                       i;
    PSID                        pSid                = 0;
    SAM_HANDLE                  hSam                = 0;
    SAM_HANDLE                  hDomain             = 0;
    SAM_HANDLE                  hUser               = 0;
    OBJECT_ATTRIBUTES           obja                = {0};
    UNICODE_STRING              usUdDcName          = {0};


    //
    // If the sid is not a principal,
    // it won't be a member of a SAM group.
    //

    if (pSidSet->sidUse != SidTypeUser &&
        pSidSet->sidUse != SidTypeComputer)
    {
        goto Cleanup;
    }


    //
    // Connect to the SAM server on the DC.
    // If we are on the DC, connect locally.
    //

    if (pSidSet->pszUdDcName)
    {
        RtlInitUnicodeString(
            &usUdDcName,
            pSidSet->pszUdDcName);

        status = SamConnect(
                     &usUdDcName,
                     &hSam,
                     SAM_SERVER_LOOKUP_DOMAIN,
                     &obja
                     );
    }
    else
    {
        status = SamConnect(
                     0,
                     &hSam,
                     SAM_SERVER_LOOKUP_DOMAIN,
                     &obja
                     );
    }

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Open the domain we are interested in.
    //

    status = SamOpenDomain(
                 hSam,
                 DOMAIN_LOOKUP,
                 pSidSet->pDomainSid,
                 &hDomain
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Finally, get a SAM handle to the user.
    //

    dwRelativeId = *RtlSubAuthoritySid(
                        pSidSet->pUserSid,
                        *RtlSubAuthorityCountSid(pSidSet->pUserSid) - 1
                        );

    status = SamOpenUser(
                 hDomain,
                 USER_LIST_GROUPS,
                 dwRelativeId,
                 &hUser
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Request all groups the user is a member of
    //

    status = SamGetGroupsForUser(
                 hUser,
                 &pGroups,
                 &dwGroupCount
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Stuff the group SIDs into pSidSet.
    //

    pGroup = pGroups;

    for (i=0;i < dwGroupCount;i++,pGroup++)
    {
        status = SamRidToSid(
                     hDomain,
                     pGroup->RelativeId,
                     &pSid
                     );

        if (!NT_SUCCESS(status))
        {
            dwError = RtlNtStatusToDosError(status);
            goto Cleanup;
        }

        dwError = AuthzpAddSidToSidSet(
                      pSidSet,
                      pSid,
                      0,
                      pGroup->Attributes,
                      0,
                      0
                      );

        SamFreeMemory(pSid);
        pSid = 0;

        if (dwError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (pGroups)
    {
        SamFreeMemory(pGroups);
    }

    if (hUser)
    {
        SamCloseHandle(hUser);
    }

    if (hDomain)
    {
        SamCloseHandle(hDomain);
    }

    if (hSam)
    {
        SamCloseHandle(hSam);
    }

    return dwError;
}


DWORD
AuthzpGetResourceDomainGroups(
    IN OUT PSID_SET pSidSet
    )

/*++

Routine description:

    This routine connects to the primary (resource) domain and
    queries SAM for nested memberships.

Arguments:

    pbNativeDomain - Pointer to a BOOL that will receive TRUE or FALSE depending
        on the domain operation mode (native or mixed, resp).

    pSidSet - Pointer to set of SIDs. New groups will be added to this set.

Return Value:

    Win32 error code.

--*/

{
    DWORD                       dwError             = ERROR_SUCCESS;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           obja                = {0};
    SAM_HANDLE                  hSam                = 0;
    UNICODE_STRING              usRdDcName;


    //
    // Open a SAM handle to the resource domain.
    //

    if (pSidSet->pszRdDcName)
    {
        RtlInitUnicodeString(
            &usRdDcName,
            pSidSet->pszRdDcName);

        status = SamConnect(
                     &usRdDcName,
                     &hSam,
                     SAM_SERVER_LOOKUP_DOMAIN,
                     &obja
                     );
    }
    else
    {
        status = SamConnect(
                     0,
                     &hSam,
                     SAM_SERVER_LOOKUP_DOMAIN,
                     &obja
                     );
    }

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Call AuthzpGetAliasMembership to get nested memberships.
    //

    dwError = AuthzpGetAliasMembership(
                  hSam,
                  pSidSet->pPrimaryInfo->Sid,
                  pSidSet
                  );

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }


    //
    // Retrieve the SID history.
    //

    dwError = AuthzpGetSidHistory(
                  pSidSet
                  );

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (hSam)
    {
        SamCloseHandle(hSam);
    }

    return dwError;
}


DWORD
AuthzpGetLocalGroups(
    IN OUT PSID_SET pSidSet
    )

/*++

Routine description:

    This routine connects to the domain specified by the caller and
    retrieves the list of groups to which the user belongs. 
    We are checking the account domain and the builtin domain
    using Sam APIs.

Arguments:

    pServerName - Pointer to a UNICODE_STRING identifying the computer
        to use for the lookup. If NULL is passed, the local computer will be used.

    pSidSet - Pointer to the SID of the user for which group membership array
        will be returned.

Return Value:

    Win32 error.

--*/

{
    DWORD                       dwError             = ERROR_SUCCESS;
    NTSTATUS                    status;
    SAM_HANDLE                  hSam                = 0;
    OBJECT_ATTRIBUTES           obja                = {0};
    BOOL                        bStatus;
    BYTE                        sid[SECURITY_MAX_SID_SIZE];
    PSID                        pBuiltinSid         = (PSID)sid;
    DWORD                       dwLengthSid         = SECURITY_MAX_SID_SIZE;


    //
    // Open a handle to the SAM on the local computer.
    //

    status = SamConnect(
                 0,
                 &hSam,
                 SAM_SERVER_LOOKUP_DOMAIN,
                 &obja
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Retrieve recursive membership for the account domain.
    //

    dwError = AuthzpGetAliasMembership(
                  hSam,
                  pSidSet->pAccountInfo->DomainSid,
                  pSidSet
                  );

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }


    //
    // Retrieve recursive membership for the BUILTIN domain.
    //

    bStatus = CreateWellKnownSid(
                  WinBuiltinDomainSid,
                  0,
                  pBuiltinSid,
                  &dwLengthSid
                  );

    if (bStatus == FALSE)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    dwError = AuthzpGetAliasMembership(
                  hSam,
                  pBuiltinSid,
                  pSidSet
                  );

    if (dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (hSam)
    {
        SamCloseHandle(hSam);
    }

    return dwError;
}


DWORD
AuthzpGetSidHistory(
    IN OUT PSID_SET pSidSet
    )

/*++

Routine description:

    This routine queries ldap for the sidHistory attribute for every SID
    in the set and adds the history SIDs the the set as well.

Arguments:

    pszDomainName - Name of the domain to connect to.

    pSidSet - Pointer to set of SIDs. New groups will be added to this set.

Return Value:

    Win32 error code.

--*/

{
    DWORD                       dwError             = ERROR_SUCCESS;
    PLDAP                       pLdap               = 0;
    LDAPMessage*                pResult             = 0;
    LDAPMessage*                pEntry              = 0;
    PLDAP_BERVAL*               ppValue             = 0;
    PWCHAR                      ppszAttributes[]    = {L"sidHistory", 0};
    DWORD                       i, j;
    DWORD                       dwSidCount;
    DWORD                       dwValueCount;
    PSID_DESC                   pSidDesc;
    WCHAR                       szSidEdn[SECURITY_MAX_SID_SIZE * 2 + 8];


    //
    // Open a ldap connection to the primary domain.
    // Get rid of the leading \\ before using the DC name.
    //

    pLdap = ldap_init(
                pSidSet->pszRdDcName ? pSidSet->pszRdDcName + 2 : 0,
                LDAP_PORT
                );

    if (pLdap == 0)
    {
        dwError = LdapMapErrorToWin32(LdapGetLastError());
        goto Cleanup;
    }

    if (pSidSet->pszRdDcName)
    {
        dwError = ldap_set_option(
                      pLdap,
                      LDAP_OPT_AREC_EXCLUSIVE,
                      LDAP_OPT_ON
                      );

        if (dwError != LDAP_SUCCESS)
        {
            dwError = LdapMapErrorToWin32(dwError);
            goto Cleanup;
        }
    }

    dwError = ldap_bind_s(
                  pLdap,
                  0,
                  0,
                  LDAP_AUTH_SSPI
                  );

    if (dwError != LDAP_SUCCESS)
    {
        dwError = LdapMapErrorToWin32(dwError);
        goto Cleanup;
    }


    //
    // Loop through all SIDs and retrieve the history attribute
    // for each one of them.
    //

    dwSidCount = pSidSet->dwCount;
    pSidDesc = pSidSet->pSidDesc;

    for (i=0;i < dwSidCount;i++,pSidDesc++)
    {
        AuthzpConvertSidToEdn(
            pSidDesc->sid,
            szSidEdn
            );

        dwError = ldap_search_s(
                      pLdap,
                      szSidEdn,
                      LDAP_SCOPE_BASE,
                      L"objectClass=*",
                      ppszAttributes,
                      FALSE,
                      &pResult
                      );

        if (dwError != LDAP_SUCCESS)
        {
            if (dwError == LDAP_NO_SUCH_OBJECT)
            {
                //
                // The SID was not found, this is not an error.
                //
                dwError = ERROR_SUCCESS;

                if (pResult)
                {
                    ldap_msgfree(pResult);
                    pResult = NULL;
                }

                continue;
            }

            dwError = LdapMapErrorToWin32(dwError);
            goto Cleanup;
        }

        pEntry = ldap_first_entry(
            pLdap,
            pResult);

        if (pEntry == 0)
        {
            dwError = ERROR_ACCESS_DENIED;
            goto Cleanup;
        }

        ppValue = ldap_get_values_len(
                      pLdap,
                      pEntry,
                      ppszAttributes[0]
                      );


        //
        // Now we have the history attribute for our group.
        // Merge it into the result set.
        //

        dwValueCount = ldap_count_values_len(ppValue);

        for (j=0;j < dwValueCount;j++)
        {
            dwError = AuthzpAddSidToSidSet(
                          pSidSet,
                          (*ppValue[j]).bv_val,
                          (*ppValue[j]).bv_len,
                          SE_GROUP_MANDATORY
                            | SE_GROUP_ENABLED_BY_DEFAULT
                            | SE_GROUP_ENABLED,
                          0,
                          0
                          );

            if (dwError != ERROR_SUCCESS)
            {
                goto Cleanup;
            }
        }

        if (ppValue)
        {
            ldap_value_free_len(ppValue);
            ppValue = 0;
        }

        if (pResult)
        {
            ldap_msgfree(pResult);
            pResult = 0;
        }
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (ppValue)
    {
        ldap_value_free_len(ppValue);
    }

    if (pResult)
    {
        ldap_msgfree(pResult);
    }

    if (pLdap)
    {
        ldap_unbind(pLdap);
    }

    return dwError;
}


DWORD
AuthzpGetAliasMembership(
    IN SAM_HANDLE hSam,
    IN PSID pDomainSid,
    IN OUT PSID_SET pSidSet
    )

/*++

Routine description:

    We try to find nested groups here. This only makes sense on domains
    in native mode.
    This routine calls SamGetAliasMembership iteratively until no
    more nested groups are returned.

Arguments:

    hSam - Handle to the SAM database.

    pDomainSid - SID of the domain to operate on.

    ppSidSet - Set of SIDs that are checked for membership. Newly
        found group SIDs are added to the set.

Return Value:

    Win32 error code.

--*/

{
    DWORD                       dwError             = ERROR_SUCCESS;
    NTSTATUS                    status;
    PSID                        pSid                = 0;
    SAM_HANDLE                  hDomain             = 0;
    DWORD                       dwSidCount;
    DWORD                       dwSidCountNew;
    DWORD                       dwSidListSize;
    DWORD                       i;
    BOOL                        bAdded;
    PSID*                       ppSidList           = 0;
    PDWORD                      pRidList            = 0;
    PDWORD                      pRid;


    //
    // Get a SAM handle to the domain.
    //

    status = SamOpenDomain(
                 hSam,
                 DOMAIN_GET_ALIAS_MEMBERSHIP,
                 pDomainSid,
                 &hDomain
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = RtlNtStatusToDosError(status);
        goto Cleanup;
    }


    //
    // Retrieve the memberships iteratively.
    //

    dwSidCount = pSidSet->dwCount;
    dwSidListSize = dwSidCount;

    ppSidList = (PSID*)AuthzpAlloc(
                    dwSidCount * sizeof(PSID)
                    );

    if (ppSidList == 0)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    for (i=0;i < dwSidCount;i++)
    {
        ppSidList[i] = pSidSet->pSidDesc[i].sid;
    }

    do
    {
        status = SamGetAliasMembership(
                     hDomain,
                     dwSidCount,
                     ppSidList,
                     &dwSidCountNew,
                     &pRidList
                     );

        if (!NT_SUCCESS(status))
        {
            dwError = RtlNtStatusToDosError(status);
            goto Cleanup;
        }

        if (dwSidCountNew > dwSidListSize)
        {
            AuthzpFree(ppSidList);

            ppSidList = (PSID*)AuthzpAlloc(
                            dwSidCountNew * sizeof(PSID)
                            );

            if (ppSidList == 0)
            {
                dwError = GetLastError();
                goto Cleanup;
            }

            dwSidListSize = dwSidCountNew;
        }

        dwSidCount = 0;
        pRid = pRidList;

        for (i=0;i < dwSidCountNew;i++,pRid++)
        {
            status = SamRidToSid(
                         hDomain,
                         *pRid,
                         &pSid
                         );

            if (!NT_SUCCESS(status))
            {
                dwError = RtlNtStatusToDosError(status);
                goto Cleanup;
            }

            dwError = AuthzpAddSidToSidSet(
                          pSidSet,
                          pSid,
                          0,
                          SE_GROUP_MANDATORY
                            | SE_GROUP_ENABLED_BY_DEFAULT
                            | SE_GROUP_ENABLED,
                          &bAdded,
                          ppSidList + dwSidCount
                          );

            SamFreeMemory(pSid);
            pSid = 0;

            if (dwError != ERROR_SUCCESS)
            {
                goto Cleanup;
            }

            if (bAdded)
            {
                dwSidCount++;
            }
        }

        if (pRidList)
        {
            SamFreeMemory(pRidList);
            pRidList = 0;
        }
    }
    while (dwSidCount);

    dwError = ERROR_SUCCESS;

Cleanup:

    if (pRidList)
    {
        SamFreeMemory(pRidList);
    }

    if (ppSidList)
    {
        AuthzpFree(ppSidList);
    }

    if (hDomain)
    {
        SamCloseHandle(hDomain);
    }

    return dwError;
}


DWORD
AuthzpInitializeSidSetByName(
    IN PUNICODE_STRING pusUserName,
    IN PUNICODE_STRING pusDomainName,
    IN DWORD dwFlags,
    IN PSID_SET pSidSet
    )

/*++

Routine description:

    Initializes a sid set and reserves memory for the
    max amount of memory it will ever need.
    The memory is not allocated yet. This only happens as SIDs get
    added to the set. All members are initialized to meaningful values.

Arguments:

    pSidSet - The sid set to operate on.

Return Value:

    Win32 error code.

--*/

{
    DWORD                       dwError             = ERROR_SUCCESS;
    SYSTEM_INFO                 sysInfo;

    if (s_dwPageSize == 0)
    {
        GetSystemInfo(&sysInfo);

        s_dwPageSize = sysInfo.dwPageSize;
    }

    pSidSet->pSidDesc = (PSID_DESC)VirtualAlloc(
                            0,
                            c_dwMaxSidCount * sizeof(SID_DESC),
                            MEM_RESERVE,
                            PAGE_NOACCESS
                            );

    if (pSidSet->pSidDesc == 0)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    pSidSet->dwCount = 0;
    pSidSet->dwMaxCount = 0;

    pSidSet->dwBaseCount = 0;
    pSidSet->dwFlags = dwFlags;

    pSidSet->pUserSid = 0;
    pSidSet->pDomainSid = 0;
    pSidSet->pusUserName = pusUserName;


    //
    // Verify for once we got a valid domain.
    // Otherwise we assume we got a UPN in pusUserName.
    //

    if (pusDomainName &&
        pusDomainName->Length &&
        pusDomainName->Buffer)
    {
        pSidSet->pusDomainName = pusDomainName;
    }
    else
    {
        pSidSet->pusDomainName = 0;
    }

    pSidSet->pNames = 0;
    pSidSet->pDomains = 0;
    pSidSet->pSids = 0;
    pSidSet->sidUse = SidTypeUnknown;

    pSidSet->pAccountInfo = 0;
    pSidSet->pPrimaryInfo = 0;
    pSidSet->bStandalone = TRUE;
    pSidSet->bSkipNonLocal = FALSE;

    pSidSet->pUdDcInfo = 0;
    pSidSet->pPdDcInfo = 0;
    pSidSet->pRdDcInfo = 0;

    pSidSet->pUdBasicInfo = 0;
    pSidSet->pPdBasicInfo = 0;
    pSidSet->pRdBasicInfo = 0;

    pSidSet->pszUdDcName = 0;
    pSidSet->pszRdDcName = 0;

    dwError = ERROR_SUCCESS;

Cleanup:

    return dwError;
}


DWORD
AuthzpInitializeSidSetBySid(
    IN PSID pUserSid,
    IN DWORD dwFlags,
    IN PSID_SET pSidSet
    )

/*++

Routine description:

    Initializes a sid set and reserves memory for the
    max amount of memory it will ever need.
    The memory is not allocated yet. This only happens as SIDs get
    added to the set. All members are initialized to meaningful values.

Arguments:

    pSidSet - The sid set to operate on.

Return Value:

    Win32 error code.

--*/

{
    DWORD                       dwError             = ERROR_SUCCESS;
    SYSTEM_INFO                 sysInfo;

    if (s_dwPageSize == 0)
    {
        GetSystemInfo(&sysInfo);

        s_dwPageSize = sysInfo.dwPageSize;
    }

    if (!RtlValidSid(pUserSid))
    {
        dwError = ERROR_INVALID_SID;
        goto Cleanup;
    }

    pSidSet->pSidDesc = (PSID_DESC)VirtualAlloc(
                            0,
                            c_dwMaxSidCount * sizeof(SID_DESC),
                            MEM_RESERVE,
                            PAGE_NOACCESS
                            );

    if (pSidSet->pSidDesc == 0)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    pSidSet->dwCount = 0;
    pSidSet->dwMaxCount = 0;

    pSidSet->dwBaseCount = 0;
    pSidSet->dwFlags = dwFlags;

    pSidSet->pUserSid = pUserSid;
    pSidSet->pDomainSid = 0;
    pSidSet->pusUserName = 0;
    pSidSet->pusDomainName = 0;

    pSidSet->pNames = 0;
    pSidSet->pDomains = 0;
    pSidSet->pSids = 0;
    pSidSet->sidUse = SidTypeUnknown;

    pSidSet->pAccountInfo = 0;
    pSidSet->pPrimaryInfo = 0;
    pSidSet->bStandalone = TRUE;
    pSidSet->bSkipNonLocal = FALSE;

    pSidSet->pUdDcInfo = 0;
    pSidSet->pPdDcInfo = 0;
    pSidSet->pRdDcInfo = 0;

    pSidSet->pUdBasicInfo = 0;
    pSidSet->pPdBasicInfo = 0;
    pSidSet->pRdBasicInfo = 0;

    pSidSet->pszUdDcName = 0;
    pSidSet->pszRdDcName = 0;

    dwError = ERROR_SUCCESS;

Cleanup:

    return dwError;
}


DWORD
AuthzpDeleteSidSet(
    IN PSID_SET pSidSet
    )

/*++

Routine description:

    Deletes all memory allocated to the sid set
    structure and resets all members to zero.

Arguments:

    pSidSet - The sid set to operate on.

Return Value:

    Win32 error code.

--*/

{
    if (pSidSet->pSidDesc)
    {
        VirtualFree(pSidSet->pSidDesc, 0, MEM_RELEASE);
    }

    if (pSidSet->pNames)
    {
        LsaFreeMemory(pSidSet->pNames);
    }

    if (pSidSet->pDomains)
    {
        LsaFreeMemory(pSidSet->pDomains);
    }

    if (pSidSet->pSids)
    {
        LsaFreeMemory(pSidSet->pSids);
    }

    if (pSidSet->pAccountInfo)
    {
        LsaFreeMemory(pSidSet->pAccountInfo);
    }

    if (pSidSet->pPrimaryInfo)
    {
        LsaFreeMemory(pSidSet->pPrimaryInfo);
    }

    if (pSidSet->pUdDcInfo)
    {
        NetApiBufferFree(pSidSet->pUdDcInfo);
    }

    if (pSidSet->pPdDcInfo)
    {
        NetApiBufferFree(pSidSet->pPdDcInfo);
    }

    if (pSidSet->pUdBasicInfo)
    {
        DsRoleFreeMemory(pSidSet->pUdBasicInfo);
    }

    if (pSidSet->pPdBasicInfo)
    {
        DsRoleFreeMemory(pSidSet->pPdBasicInfo);
    }

    RtlZeroMemory(
        pSidSet,
        sizeof(SID_SET));

    return ERROR_SUCCESS;
}


DWORD
AuthzpAddSidToSidSet(
    IN PSID_SET pSidSet,
    IN PSID pSid,
    IN DWORD dwSidLength OPTIONAL,
    IN DWORD dwAttributes,
    OUT PBOOL pbAdded OPTIONAL,
    OUT PSID* ppSid OPTIONAL
    )

/*++

Routine description:

    Check if the given SID already exists in the set. If yes, return.
    Otherwise, add it to the set.

Arguments:

    pSidSet - The sid set to operate on.

    pSid - The SID to add to the set.

    dwSidLength - Length of the SID in bytes. If zero is passed in,
        the routine calculates the length itself.

    dwAttributes - Attributes of the SID like in the
        SID_AND_ATTRIBUTES structure.

    pbAdded - Optional pointer that receives indication if the SID
        was indeed added or not (because it was a duplicate).

    ppSid - Optional pointer to where the new sid is stored.

Return Value:

    Win32 error code.

--*/

{
    DWORD                       dwError             = ERROR_SUCCESS;
    DWORD                       i;
    DWORD                       dwSize;
    BOOL                        bAdded              = FALSE;
    PSID_DESC                   pSidDesc;

    if (dwSidLength == 0)
    {
        dwSidLength = RtlLengthSid(pSid);
    }

    pSidDesc = pSidSet->pSidDesc;

    for (i=0;i < pSidSet->dwCount;i++,pSidDesc++)
    {
        if (dwSidLength == pSidDesc->dwLength)
        {
            if (RtlEqualSid(
                    pSid,
                    pSidDesc->sid))
            {
                goto Cleanup;
            }
        }
    }

    if (pSidSet->dwCount >= pSidSet->dwMaxCount)
    {
        if (pSidSet->dwCount >= c_dwMaxSidCount)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }


        //
        // Commit one more page in the buffer.
        //

        dwSize = (pSidSet->dwCount + 1) * sizeof(SID_DESC);
        dwSize += s_dwPageSize - 1;
        dwSize &= ~(s_dwPageSize - 1);

        pSidDesc = (PSID_DESC)VirtualAlloc(
                        pSidSet->pSidDesc,
                        dwSize,
                        MEM_COMMIT,
                        PAGE_READWRITE
                        );

        if (pSidDesc != pSidSet->pSidDesc)
        {
            dwError = GetLastError();
            goto Cleanup;
        }

        pSidSet->dwMaxCount = dwSize / sizeof(SID_DESC);
    }

    pSidDesc = pSidSet->pSidDesc + pSidSet->dwCount;

    pSidDesc->dwAttributes = dwAttributes;
    pSidDesc->dwLength = dwSidLength;

    RtlCopyMemory(
        pSidDesc->sid,
        pSid,
        dwSidLength
        );

    bAdded = TRUE;

    pSidSet->dwCount++;

    if (ppSid)
    {
        *ppSid = pSidDesc->sid;
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (pbAdded)
    {
        *pbAdded = bAdded;
    }

    return dwError;
}


DWORD
AuthzpGetUserDomainSid(
    PSID_SET pSidSet
    )
{
    DWORD                       dwError;
    NTSTATUS                    status;
    LSA_HANDLE                  hPolicy             = 0;
    OBJECT_ATTRIBUTES           obja                = {0};
    SECURITY_QUALITY_OF_SERVICE sqos;
    WCHAR                       wc[2]               = L"\\";
    UNICODE_STRING          usName              = {0};
    PUNICODE_STRING         pusName             = 0;


    //
    // Build the string domain - name string that should be
    // translated.
    //

    if (pSidSet->pusDomainName)
    {
        usName.MaximumLength = 
                            pSidSet->pusDomainName->Length +
                            sizeof(WCHAR) +
                            pSidSet->pusUserName->Length +
                            sizeof(WCHAR);

        usName.Buffer = (PWSTR)LocalAlloc(
                            LMEM_FIXED,
                            usName.MaximumLength
                            );

        if (usName.Buffer == 0)
        {
            dwError = GetLastError();
            goto Cleanup;
        }

        RtlCopyMemory(
            usName.Buffer,
            pSidSet->pusDomainName->Buffer,
            pSidSet->pusDomainName->Length
            );

        usName.Length = (USHORT)(usName.Length + pSidSet->pusDomainName->Length);

        RtlCopyMemory(
            ((PBYTE)usName.Buffer) + usName.Length,
            wc + 0,
            sizeof(WCHAR)
            );

        usName.Length += sizeof(WCHAR);

        RtlCopyMemory(
            ((PBYTE)usName.Buffer) + usName.Length,
            pSidSet->pusUserName->Buffer,
            pSidSet->pusUserName->Length
            );

        usName.Length = (USHORT)(usName.Length + pSidSet->pusUserName->Length);

        RtlCopyMemory(
            ((PBYTE)usName.Buffer) + usName.Length,
            wc + 1,
            sizeof(WCHAR)
            );

        pusName = &usName;
    }
    else
    {
        //
        // Assume we got an UPN.
        //

        pusName = pSidSet->pusUserName;
    }

    //
    // set up the object attributes prior to opening the LSA
    //

    sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;

    obja.SecurityQualityOfService = &sqos;


    //
    // open the LSA policy
    //

    status = LsaOpenPolicy(
                 0,
                 &obja,
                 POLICY_LOOKUP_NAMES,
                 &hPolicy
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }

    status = LsaLookupNames2(
                 hPolicy,
                 0,          // no flags
                 1,
                 pusName,
                 &pSidSet->pDomains,
                 &pSidSet->pSids
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }

    if (pSidSet->pSids == 0)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    switch (pSidSet->pSids->Use)
    {
    case SidTypeDomain:
    case SidTypeInvalid:
    case SidTypeUnknown:
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // The name was successfully translated.
    // There should be exactly one domain and its index should be zero.
    //

    ASSERT(pSidSet->pDomains->Entries == 1);
    ASSERT(pSidSet->pDomains->Domains != 0);
    ASSERT(pSidSet->pSids->DomainIndex == 0);

    pSidSet->pUserSid = pSidSet->pSids->Sid;
    pSidSet->pDomainSid = pSidSet->pDomains->Domains->Sid;
    pSidSet->sidUse = pSidSet->pSids->Use;

    dwError = ERROR_SUCCESS;

Cleanup:

    if (hPolicy)
    {
        LsaClose(hPolicy);
    }

    if (usName.Buffer)
    {
        LocalFree((HLOCAL)usName.Buffer);
    }

    return dwError;
}


DWORD
AuthzpGetUserDomainName(
    PSID_SET pSidSet
    )
{
    DWORD                       dwError;
    NTSTATUS                    status;
    LSA_HANDLE                  hPolicy             = 0;
    OBJECT_ATTRIBUTES           obja                = {0};
    SECURITY_QUALITY_OF_SERVICE sqos;


    //
    // set up the object attributes prior to opening the LSA
    //

    sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;

    obja.SecurityQualityOfService = &sqos;


    //
    // open the LSA policy
    //

    status = LsaOpenPolicy(
                 0,
                 &obja,
                 POLICY_LOOKUP_NAMES,
                 &hPolicy
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }

    status = LsaLookupSids(
                 hPolicy,
                 1,
                 &pSidSet->pUserSid,
                 &pSidSet->pDomains,
                 &pSidSet->pNames
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }

    if (pSidSet->pNames == 0)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    switch (pSidSet->pNames->Use)
    {
    case SidTypeDomain:
    case SidTypeUnknown:
    case SidTypeInvalid:
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // The SID was successfully translated.
    // There should be exactly one domain and its index should be zero.
    //

    ASSERT(pSidSet->pDomains->Entries == 1);
    ASSERT(pSidSet->pDomains->Domains != 0);
    ASSERT(pSidSet->pNames->DomainIndex == 0);

    pSidSet->pDomainSid = pSidSet->pDomains->Domains->Sid;
    pSidSet->pusUserName = &pSidSet->pNames->Name;
    pSidSet->pusDomainName = &pSidSet->pDomains->Domains->Name;
    pSidSet->sidUse = pSidSet->pNames->Use;

    dwError = ERROR_SUCCESS;

Cleanup:

    if (hPolicy)
    {
        LsaClose(hPolicy);
    }

    return dwError;
}


DWORD
AuthzpGetLocalInfo(
    IN PSID_SET pSidSet
    )
{
    DWORD                       dwError;
    NTSTATUS                    status;
    LSA_HANDLE                  hPolicy             = 0;
    OBJECT_ATTRIBUTES           obja                = {0};
    SECURITY_QUALITY_OF_SERVICE sqos;
    NT_PRODUCT_TYPE             ProductType;
    PPOLICY_LSA_SERVER_ROLE_INFO    pRole           = 0;


    //
    // Set up the object attributes prior to opening the LSA.
    //

    sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;

    obja.SecurityQualityOfService = &sqos;


    //
    // open LSA policy
    //

    status = LsaOpenPolicy(
                 0,
                 &obja,
                 POLICY_VIEW_LOCAL_INFORMATION,
                 &hPolicy
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }

    status = LsaQueryInformationPolicy(
                 hPolicy,
                 PolicyAccountDomainInformation,
                 (PVOID*)&pSidSet->pAccountInfo
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }

    status = LsaQueryInformationPolicy(
                 hPolicy,
                 PolicyPrimaryDomainInformation,
                 (PVOID*)&pSidSet->pPrimaryInfo
                 );

    if (!NT_SUCCESS(status))
    {
        dwError = LsaNtStatusToWinError(status);
        goto Cleanup;
    }


    //
    // Determine the role of the machine.
    //

    if (RtlGetNtProductType(&ProductType) == FALSE)
    {
        dwError = ERROR_GEN_FAILURE;
        goto Cleanup;
    }

    switch (ProductType)
    {
    case NtProductWinNt:
    case NtProductServer:
        pSidSet->bStandalone = pSidSet->pPrimaryInfo->Sid == 0 ? TRUE : FALSE;
        break;
    
    case NtProductLanManNt:
        status = LsaQueryInformationPolicy(
                     hPolicy,
                     PolicyLsaServerRoleInformation,
                     (PVOID*)&pRole
                     );

        if (!NT_SUCCESS(status))
        {
            dwError = LsaNtStatusToWinError(status);
            goto Cleanup;
        }

        pSidSet->bStandalone = FALSE;

        if (pRole->LsaServerRole == PolicyServerRolePrimary)
        {
            //
            // If we think we're a primary domain controller, we'll need to
            // guard against the case where we're actually standalone
            // during setup
            //

            if (pSidSet->pPrimaryInfo->Sid == 0 ||
                pSidSet->pAccountInfo->DomainSid == 0 ||
                !RtlEqualSid(
                    pSidSet->pPrimaryInfo->Sid,
                    pSidSet->pAccountInfo->DomainSid))
            {
                pSidSet->bStandalone = TRUE;
            }
        }
        break;

    default:
        dwError = ERROR_GEN_FAILURE;
        goto Cleanup;
    }

    dwError = ERROR_SUCCESS;

Cleanup:

    if (pRole)
    {
        LsaFreeMemory(pRole);
    }

    if (hPolicy)
    {
        LsaClose(hPolicy);
    }

    return dwError;
}


DWORD
AuthzpGetDcName(
    IN LPCTSTR pszDomain,
    IN OUT PDOMAIN_CONTROLLER_INFO* ppDcInfo
    )
{
    DWORD                       dwError;


    //
    // First try to get a DC with DS running.
    //

    dwError = DsGetDcName(
                  0,
                  pszDomain,
                  0,
                  0,
                  DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME,
                  ppDcInfo
                  );

    if (dwError == ERROR_NO_SUCH_DOMAIN)
    {
        //
        // Try again with no flags set, because this is the only way
        // an NT4 domain will reveal its secrets.
        //

        dwError = DsGetDcName(
                      0,
                      pszDomain,
                      0,
                      0,
                      0,
                      ppDcInfo
                      );
    }

    return dwError;
}


VOID
AuthzpConvertSidToEdn(
    IN PSID pSid,
    OUT PWSTR pszSidEdn
    )

/*++

    Print pSid into pszSidEdn as an Extended Distinguished Name.

    pszSidEdn should provide room for at least
    SECURITY_MAX_SID_SIZE * 2 + 8 WCHARs.

--*/

{
    DWORD                       dwLength            = RtlLengthSid(pSid);
    DWORD                       i;
    PBYTE                       pbSid               = (PBYTE)pSid;
    PWCHAR                      pChar               = pszSidEdn;
    static WCHAR                szHex[]             = L"0123456789ABCDEF";

    *pChar++ = L'<';
    *pChar++ = L'S';
    *pChar++ = L'I';
    *pChar++ = L'D';
    *pChar++ = L'=';
    
    for (i=0;i < dwLength;i++,pbSid++)
    {
        *pChar++ = szHex[*pbSid >> 4];
        *pChar++ = szHex[*pbSid & 0x0F];
    }

    *pChar++ = L'>';
    *pChar = L'\0';
}


BOOL
AuthzpAllocateAndInitializeClientContext(
    OUT PAUTHZI_CLIENT_CONTEXT *ppCC,
    IN PAUTHZI_CLIENT_CONTEXT Server,
    IN DWORD Revision,
    IN LUID Identifier,
    IN LARGE_INTEGER ExpirationTime,
    IN DWORD Flags,
    IN DWORD SidCount,
    IN DWORD SidLength,
    IN PSID_AND_ATTRIBUTES Sids,
    IN DWORD RestrictedSidCount,
    IN DWORD RestrictedSidLength,
    IN PSID_AND_ATTRIBUTES RestrictedSids,
    IN DWORD PrivilegeCount,
    IN DWORD PrivilegeLength,
    IN PLUID_AND_ATTRIBUTES Privileges,
    IN LUID AuthenticationId,
    IN PAUTHZI_HANDLE AuthzHandleHead,
    IN PAUTHZI_RESOURCE_MANAGER pRM
)

/*++

Routine description:

    This routine initializes fields in a client context. It is called by all the
    AuthzInitializClientContextFrom* routines.

Arguments:

    ppCC - Returns the newly allocated and initialized client context structure.

    Rest of the parameters are copied into the client context. For explanation
    of these, see the definition of AUTHZI_CLIENT_CONTEXT.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PAUTHZI_CLIENT_CONTEXT pCC = (PAUTHZI_CLIENT_CONTEXT) AuthzpAlloc(sizeof(AUTHZI_CLIENT_CONTEXT));

    if (AUTHZ_ALLOCATION_FAILED(pCC))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    *ppCC = pCC;

    RtlZeroMemory(
        pCC,
        sizeof(AUTHZ_CLIENT_CONTEXT_HANDLE)
        );

    pCC->AuthenticationId = AuthenticationId;
    pCC->AuthzHandleHead = AuthzHandleHead;
    pCC->ExpirationTime = ExpirationTime;
    pCC->Flags = Flags;
    pCC->Identifier = Identifier;
    pCC->pResourceManager = pRM;
    pCC->PrivilegeCount = PrivilegeCount;
    pCC->PrivilegeLength = PrivilegeLength;
    pCC->Privileges = Privileges;
    pCC->RestrictedSidCount = RestrictedSidCount;
    pCC->RestrictedSidLength = RestrictedSidLength;
    pCC->RestrictedSids = RestrictedSids;
    pCC->Revision = Revision;
    pCC->Server = Server;
    pCC->SidCount = SidCount;
    pCC->SidLength = SidLength;
    pCC->Sids = Sids;

    return TRUE;
}


BOOL
AuthzpAddDynamicSidsToToken(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZI_RESOURCE_MANAGER pRM,
    IN PVOID DynamicGroupArgs,
    IN PSID_AND_ATTRIBUTES Sids,
    IN DWORD SidLength,
    IN DWORD SidCount,
    IN PSID_AND_ATTRIBUTES RestrictedSids,
    IN DWORD RestrictedSidLength,
    IN DWORD RestrictedSidCount,
    IN PLUID_AND_ATTRIBUTES Privileges,
    IN DWORD PrivilegeLength,
    IN DWORD PrivilegeCount,
    IN BOOL bAllocated
)

/*++

Routine description:

    This routine computes resource manager specific groups and add them to the
    client context. This is a worker routine for all AuthzInitializeFrom*
    routines.

Arguments:

    pCC - Pointer to the client context structure for which the three fields
        will be set - sids, restricted sids, privileges.

    pRM - Pointer to the resource manager structure, supplies the callback
        function to be used.

    DynamicGroupArgs - Caller supplied argument pointer to be passed as an input
        to the callback function that'd compute dynamic groups

    Sids - The sid and atttribute array for the normal part of the client
        context.

    SidLength - Size of the buffer required to hold this array.

    SidCount - Number of sids in the array.

    RestrictedSids - The sid and atttribute array for the normal part of the
        client context.

    RestrictedSidLength - Size of the buffer required to hold this array.

    RestrictedSidCount - Number of restricted sids in the array.

    Privileges - The privilege and attribute array.

    PrivilegeLength - Size required to hold this array.

    PrivilegeCount - The number of privileges in the array.

    bAllocated - To specify whether the Sids and RestrictedSids pointers in
        client context have been allocated separately.

    When the client context has been created thru a token, the two pointers
    point somewhere into a buffer and a new buffer has to be allocated to store
    these.

    When the client context has been created thru a sid, the buffer is a valid
    allocated one. If no dynamic groups need to be added then we do not have to
    do anything int this case.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    BOOL                         b                        = TRUE;
    PSID_AND_ATTRIBUTES          pRMSids                  = NULL;
    PSID_AND_ATTRIBUTES          pRMRestrictedSids        = NULL;
    PSID_AND_ATTRIBUTES          pLocalSids               = NULL;
    PSID_AND_ATTRIBUTES          pLocalRestrictedSids     = NULL;
    PLUID_AND_ATTRIBUTES         pLocalPrivileges         = NULL;
    DWORD                        RMSidCount               = 0;
    DWORD                        RMRestrictedSidCount     = 0;
    DWORD                        LocalSidLength           = 0;
    DWORD                        LocalRestrictedSidLength = 0;
    DWORD                        i                        = 0;

    //
    // Compute dynamic groups.
    //

    if (AUTHZ_NON_NULL_PTR(pRM->pfnComputeDynamicGroups))
    {
        b = pRM->pfnComputeDynamicGroups(
                     (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                     DynamicGroupArgs,
                     &pRMSids,
                     &RMSidCount,
                     &pRMRestrictedSids,
                     &RMRestrictedSidCount
                     );

        if (!b) goto Cleanup;
    }

    //
    // Copy the existing sids as well as the dynamic ones into a new buffer if
    // needed.
    //

    if ((0 != RMSidCount) || !bAllocated)
    {
        LocalSidLength = SidLength + RMSidCount * sizeof(SID_AND_ATTRIBUTES);

        for (i = 0; i < RMSidCount; i++)
        {
            LocalSidLength += RtlLengthSid(pRMSids[i].Sid);
        }

        pLocalSids = (PSID_AND_ATTRIBUTES) AuthzpAlloc(LocalSidLength);

        if (AUTHZ_ALLOCATION_FAILED(pLocalSids))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            b = FALSE;
            goto Cleanup;
        }

        pCC->SidCount = RMSidCount + SidCount;
        pCC->Sids = pLocalSids;

        b = AuthzpCopySidsAndAttributes(
                pLocalSids,
                Sids,
                SidCount,
                pRMSids,
                RMSidCount
                );

        if (!b)
        {
            goto Cleanup;
        }

        if (!FLAG_ON(pCC->Sids[0].Attributes, SE_GROUP_USE_FOR_DENY_ONLY))
        {
            pCC->Sids[0].Attributes |= SE_GROUP_ENABLED;
        }

        pCC->SidLength = LocalSidLength;
    }

    if ((0 != RMRestrictedSidCount) || !bAllocated)
    {
        LocalRestrictedSidLength = RestrictedSidLength + RMRestrictedSidCount * sizeof(SID_AND_ATTRIBUTES);

        for (i = 0; i < RMRestrictedSidCount; i++)
        {
            LocalRestrictedSidLength += RtlLengthSid(pRMRestrictedSids[i].Sid);
        }

        if (LocalRestrictedSidLength > 0)
        {
            pLocalRestrictedSids = (PSID_AND_ATTRIBUTES) AuthzpAlloc(LocalRestrictedSidLength);

            if (AUTHZ_ALLOCATION_FAILED(pLocalRestrictedSids))
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                b = FALSE;
                goto Cleanup;
            }
        }

        pCC->RestrictedSidCount = RMRestrictedSidCount + RestrictedSidCount;
        pCC->RestrictedSids = pLocalRestrictedSids;

        b = AuthzpCopySidsAndAttributes(
                pLocalRestrictedSids,
                RestrictedSids,
                RestrictedSidCount,
                pRMRestrictedSids,
                RMRestrictedSidCount
                );

        if (!b) goto Cleanup;

        pCC->RestrictedSidLength = LocalRestrictedSidLength;
    }

    //
    // Privileges need to copied only in the case of initilize from token.
    //

    if (PrivilegeLength > 0)
    {
        pLocalPrivileges = (PLUID_AND_ATTRIBUTES) AuthzpAlloc(PrivilegeLength);

        if (AUTHZ_ALLOCATION_FAILED(pLocalPrivileges))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            b = FALSE;
            goto Cleanup;
        }

        pCC->PrivilegeCount = PrivilegeCount;
        pCC->Privileges = pLocalPrivileges;

        AuthzpCopyLuidAndAttributes(
            pCC,
            Privileges,
            PrivilegeCount,
            pLocalPrivileges
            );
    }
    else
    {
        pCC->Privileges = NULL;
    }

Cleanup:

    if (!b)
    {
        AuthzpFreeNonNull(pLocalSids);
        AuthzpFreeNonNull(pLocalRestrictedSids);
        AuthzpFreeNonNull(pLocalPrivileges);
    }

    if (AUTHZ_NON_NULL_PTR(pRMSids))
    {
        pRM->pfnFreeDynamicGroups(pRMSids);
    }

    if (AUTHZ_NON_NULL_PTR(pRMRestrictedSids))
    {
        pRM->pfnFreeDynamicGroups(pRMSids);
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\authzp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    authzp.c

Abstract:

   This module implements the internal worker routines for access check and
   audit APIs.

Author:

    Kedar Dubhashi - March 2000

Environment:

    User mode only.

Revision History:

    Created - March 2000

--*/

#include "pch.h"

#pragma hdrstop

#include <authzp.h>

DWORD AuthzpPrincipalSelfSidBuffer[] = {0x101, 0x5000000, 0xA};
PSID pAuthzPrincipalSelfSid          = (PSID) AuthzpPrincipalSelfSidBuffer;
USHORT AuthzpPrincipalSelfSidLen     = sizeof(AuthzpPrincipalSelfSidBuffer);

DWORD AuthzpCreatorOwnerSidBuffer[] = {0x101, 0x3000000, 0x0};
PSID pAuthzCreatorOwnerSid          = (PSID) AuthzpCreatorOwnerSidBuffer;

//
// This is used to get the index of the first '1' bit in a given byte.
//     a[0] = 9     // This is a dummy.
//     a[1] = 0
//     a[2] = 1
//     a[3] = 0
//     ...
//     a[i] = first '1' bit from LSB
//

UCHAR AuthzpByteToIndexLookupTable[] = {
    9,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
    4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0
};

#ifndef AUTHZ_DEBUG_MEMLEAK

#define AuthzpAlloc(s) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, (s))
#define AuthzpFree(p) LocalFree((p))

#else

//
// This is to be used for debugging memory leaks. Primitive method but works in
// a small project like this.
//


PVOID
AuthzpAlloc(IN DWORD Size)
{

    PVOID l = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, Size);

    wprintf(L"Allocated %d at %x\n", Size, l);

    return l;
}


VOID
AuthzpFree(PVOID l)
{
    LocalFree(l);
    wprintf(L"Freeing %x\n", l);
}

#endif


BOOL
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )

/*++

Routine Description

    This initializes global events and variables for the DLL.
    
Arguments

    Predefined DllMain arguments.                                           
    
Return Value

    Boolean: TRUE on success, FALSE on fail.  
    
--*/

{
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(lpReserved);
    UNREFERENCED_PARAMETER(dwReason);

    return TRUE;
}


BOOL
AuthzpVerifyAccessCheckArguments(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE phAccessCheckResults OPTIONAL
    )

/*++

Routine description:

    This routine validates inputs for the access check call. It also initializes
    input parameters to default.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    pReply - Supplies a pointer to a reply structure used to return the results.

    phAccessCheckResults - Supplies a pointer to return a handle to the cached results
        of access check.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    if (ARGUMENT_PRESENT(phAccessCheckResults))
    {
        *phAccessCheckResults = NULL;
    }

    if (!ARGUMENT_PRESENT(pCC))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
   
    if (!ARGUMENT_PRESENT(pSecurityDescriptor))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

#ifdef DBG
    if (!RtlValidSecurityDescriptor(pSecurityDescriptor))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
#endif

    if (!ARGUMENT_PRESENT(RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ((0 != OptionalSecurityDescriptorCount) && (!ARGUMENT_PRESENT(OptionalSecurityDescriptorArray)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // The caller can specify one of the two values for Reply->ResultListLength
    //     a. 1 - representing the whole object.
    //     b. pRequest->ObjectTypeListLength - for every node in the type list.
    //

    if ((1 != pReply->ResultListLength) &&
        (pReply->ResultListLength != pRequest->ObjectTypeListLength))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return TRUE;
}


BOOL
AuthzpVerifyOpenObjectArguments(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN PAUTHZI_AUDIT_EVENT pAuditEvent
    )

/*++

Routine description:

    This routine validates inputs for AuthzOpenObjectAuditAlarm.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    pReply - Supplies a pointer to a reply structure containing the results of 
        an AuthzAccessCheck.

    pAuditEvent - pointer to AUTHZ_AUDIT_EVENT.
    
Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    if (!ARGUMENT_PRESENT(pCC))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!ARGUMENT_PRESENT(pAuditEvent))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!ARGUMENT_PRESENT(pSecurityDescriptor))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

#if DBG
    if (!RtlValidSecurityDescriptor(pSecurityDescriptor))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
#endif

    if (!ARGUMENT_PRESENT(RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ((0 != OptionalSecurityDescriptorCount) && (!ARGUMENT_PRESENT(OptionalSecurityDescriptorArray)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return TRUE;
}


BOOL
AuthzpCaptureObjectTypeList(
    IN POBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeListLength,
    OUT PIOBJECT_TYPE_LIST *CapturedObjectTypeList,
    OUT PIOBJECT_TYPE_LIST *CapturedCachingObjectTypeList OPTIONAL
    )

/*++

Routine description:

    This routine captures an object type list into internal structres.

Arguments:

    ObjectTypeList - Object type list to capture.

    ObjectTypeListLength - Length of the object type list.

    CapturedObjectTypeList - To return the internal representation of the
    input list. This routine allocates memory for this structure.

    CapturedCachingObjectTypeList - To return internal representation of the
    input list This list will be used to hold static always-granted access bits.
    This routine allocates memory for this structure.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD              i                    = 0;
    PIOBJECT_TYPE_LIST LocalTypeList        = NULL;
    PIOBJECT_TYPE_LIST LocalCachingTypeList = NULL;
    DWORD              Size                 = 0;
    BOOL               b                    = TRUE;

    DWORD Levels[ACCESS_MAX_LEVEL + 1];

    if (ARGUMENT_PRESENT(CapturedCachingObjectTypeList))
    {
        *CapturedCachingObjectTypeList = NULL;
    }

    *CapturedObjectTypeList = NULL;

    if ((0 == ObjectTypeListLength) || (!ARGUMENT_PRESENT(ObjectTypeList)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    Size = sizeof(IOBJECT_TYPE_LIST) * ObjectTypeListLength;
    LocalTypeList = (PIOBJECT_TYPE_LIST) AuthzpAlloc(Size);

    if (AUTHZ_ALLOCATION_FAILED(LocalTypeList))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    for (i = 0; i < ObjectTypeListLength; i++)
    {
        USHORT CurrentLevel;

        CurrentLevel = ObjectTypeList[i].Level;

        if (CurrentLevel > ACCESS_MAX_LEVEL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            b = FALSE;
            goto Cleanup;
        }

        //
        // Copy data the caller passed in.
        //

        LocalTypeList[i].Level = CurrentLevel;
        LocalTypeList[i].Flags = 0;
        LocalTypeList[i].ObjectType = *ObjectTypeList[i].ObjectType;
        LocalTypeList[i].Remaining = 0;
        LocalTypeList[i].CurrentGranted = 0;
        LocalTypeList[i].CurrentDenied = 0;

        //
        // Ensure that the level number is consistent with the
        // level number of the previous entry.
        //

        if (0 == i)
        {
            if (0 != CurrentLevel)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                b = FALSE;
                goto Cleanup;
            }
        }
        else
        {
            //
            // The previous entry is either:
            //  my immediate parent,
            //  my sibling, or
            //  the child (or grandchild, etc.) of my sibling.
            //

            if ( CurrentLevel > LocalTypeList[i-1].Level + 1 )
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                b = FALSE;
                goto Cleanup;
            }

            //
            // Don't support two roots.
            //

            if (0 == CurrentLevel)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                b = FALSE;
                goto Cleanup;
            }
        }

        //
        // If the above rules are maintained,
        //  then my parent object is the last object seen that
        //  has a level one less than mine.
        //

        if (0 == CurrentLevel)
        {
            LocalTypeList[i].ParentIndex = -1;
        }
        else
        {
            LocalTypeList[i].ParentIndex = Levels[CurrentLevel-1];
        }

        //
        // Save this obect as the last object seen at this level.
        //

        Levels[CurrentLevel] = i;
    }

    //
    // If the caller has requested caching then create a copy of the object type
    // list that we just captured.
    //

    if (ARGUMENT_PRESENT(CapturedCachingObjectTypeList))
    {
        LocalCachingTypeList = (PIOBJECT_TYPE_LIST) AuthzpAlloc(Size);

        if (AUTHZ_ALLOCATION_FAILED(LocalCachingTypeList))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            b = FALSE;
            goto Cleanup;
        }

        memcpy(
            LocalCachingTypeList,
            LocalTypeList,
            Size
            );

        *CapturedCachingObjectTypeList = LocalCachingTypeList;
    }

    *CapturedObjectTypeList = LocalTypeList;

    return TRUE;

Cleanup:

    AuthzpFreeNonNull(LocalTypeList);

    return FALSE;
}


VOID
AuthzpFillReplyStructure(
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN DWORD Error,
    IN ACCESS_MASK GrantedAccess
    )

/*++

Routine description:

    This routine fills the reply structure with supplied parameters.

Arguments:

    pReply - The reply structure to fill.

    Error - The same error value is filled in all the elements of the array.

    GrantedAccess - Access granted to the entire object.

Return Value:

    None.

--*/

{
    DWORD i = 0;

    for (i = 0; i < pReply->ResultListLength; i++)
    {
        pReply->GrantedAccessMask[i] = GrantedAccess;
        pReply->Error[i] = Error;
    }
}


BOOL
AuthzpMaximumAllowedAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN OUT PIOBJECT_TYPE_LIST LocalCachingTypeList OPTIONAL,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent,
    OUT PDWORD pCachingFlags
    )

/*++

Routine description:

    This routine does a maximum allowed access check on multiple security
        descriptors. In case of restricted tokens, access granted is a bitwise
        AND of granted access by the normal as well as the restricted parts of
        the client context.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalCachingTypeList - Internal object type list structure used to hold
        intermediate results for static granted bits.

    LocalTypeListLength - Length of the array represnting the object.

    ObjectTypeListPresent - Whether the called supplied an object type list.

    pCachingFlags - To return the flags that will be stored in the caching
        handle if the caller requested caching.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    BOOL b = TRUE;

    //
    // Do the access check with the non-restricted part of the client context.
    //

    b = AuthzpMaximumAllowedMultipleSDAccessCheck(
            pCC,
            pRequest,
            pSecurityDescriptor,
            OptionalSecurityDescriptorArray,
            OptionalSecurityDescriptorCount,
            LocalTypeList,
            LocalCachingTypeList,
            LocalTypeListLength,
            ObjectTypeListPresent,
            FALSE,  // Non-restricted access check
            pCachingFlags
            );

#ifdef AUTHZ_DEBUG
    wprintf(L"AuthzpMaximumAllowedAccessCheck: GrantedAccess = %x\n",
            LocalTypeList->CurrentGranted);
#endif

    if (!b)
    {
        return FALSE;
    }

    //
    // Do the access check with the restricted part of the client context if
    // it exists.
    //

    if (AUTHZ_TOKEN_RESTRICTED(pCC))
    {
        b = AuthzpMaximumAllowedMultipleSDAccessCheck(
                pCC,
                pRequest,
                pSecurityDescriptor,
                OptionalSecurityDescriptorArray,
                OptionalSecurityDescriptorCount,
                LocalTypeList,
                LocalCachingTypeList,
                LocalTypeListLength,
                ObjectTypeListPresent,
                TRUE, // Restricted access check
                pCachingFlags
                );

#ifdef AUTHZ_DEBUG
    wprintf(L"AuthzpMaximumAllowedAccessCheck: RestrictedGrantedAccess = %x\n",
            LocalTypeList->CurrentGranted);
#endif

    }

    return b;
}


BOOL
AuthzpMaximumAllowedMultipleSDAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN OUT PIOBJECT_TYPE_LIST LocalCachingTypeList OPTIONAL,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent,
    IN BOOL Restricted,
    OUT PDWORD pCachingFlags
    )

/*++

Routine description:

    This routine performs access check for all security descriptors provided.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalCachingTypeList - Internal object type list structure used to hold
        intermediate results for static granted bits.

    LocalTypeListLength - Length of the array represnting the object.

    ObjectTypeListPresent - Whether the called supplied an object type list.

    Restricted - Whether the restricted part of the client context should be
        used for access check.

    pCachingFlags - To return the flags that will be stored in the caching
        handle if the caller requested caching.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD                  i               = 0;
    DWORD                  j               = 0;
    DWORD                  SidCount        = 0;
    BOOL                   b               = TRUE;
    PSID_AND_ATTRIBUTES    pSidAttr        = NULL;
    PACL                   pAcl            = NULL;
    PSID                   pOwnerSid       = NULL;
    PAUTHZI_SID_HASH_ENTRY pSidHash        = NULL;

    pOwnerSid = RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);

    if (Restricted)
    {
        //
        // For restricted client context, granted access is a bitwise AND of
        // granted access from both parts of the context.
        //

        if (ARGUMENT_PRESENT(LocalCachingTypeList))
        {
            for (j = 0; j < LocalTypeListLength; j++)
            {
                LocalTypeList[j].Remaining = LocalTypeList[j].CurrentGranted;
                LocalTypeList[j].CurrentGranted = 0;

                LocalCachingTypeList[j].Remaining = LocalCachingTypeList[j].CurrentGranted;
                LocalCachingTypeList[j].CurrentGranted = 0;
            }
        }
        else
        {
            for (j = 0; j < LocalTypeListLength; j++)
            {
                LocalTypeList[j].Remaining = LocalTypeList[j].CurrentGranted;
                LocalTypeList[j].CurrentGranted = 0;
            }
        }

        pSidAttr = pCC->RestrictedSids;
        SidCount = pCC->RestrictedSidCount;
        pSidHash = pCC->RestrictedSidHash;
    }
    else
    {
        pSidAttr = pCC->Sids;
        SidCount = pCC->SidCount;
        pSidHash = pCC->SidHash;
    }

    pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);

    b = AuthzpMaximumAllowedSingleAclAccessCheck(
            pCC,
            pSidAttr,
            SidCount,
            pSidHash,
            pRequest,
            pAcl,
            pOwnerSid,
            LocalTypeList,
            LocalCachingTypeList,
            LocalTypeListLength,
            ObjectTypeListPresent,
            pCachingFlags
            );

    if (!b)
    {
        return FALSE;
    }

    for (i = 0; i < OptionalSecurityDescriptorCount; i++)
    {
        pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) OptionalSecurityDescriptorArray[i]);

        if (!AUTHZ_NON_NULL_PTR(pAcl))
        {
            continue;
        }

        b = AuthzpMaximumAllowedSingleAclAccessCheck(
                pCC,
                pSidAttr,
                SidCount,
                pSidHash,
                pRequest,
                pAcl,
                pOwnerSid,
                LocalTypeList,
                LocalCachingTypeList,
                LocalTypeListLength,
                ObjectTypeListPresent,
                pCachingFlags
                );

        if (!b)
        {
            break;
        }
    }

    return b;
}


BOOL
AuthzpMaximumAllowedSingleAclAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN OUT PIOBJECT_TYPE_LIST LocalCachingTypeList OPTIONAL,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent,
    OUT PDWORD pCachingFlags
    )

/*++

Routine description:

    This routine

Arguments:
    pCC - Pointer to the client context.

    pSidAttr - Sids and attributes to be used for matching the one in the aces.

    SidCount - Number of sids in the pSidAttr array

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pAcl - Discretionary acl against which access check will be performed.
        It is assumed that the acl is non-null.

    pOwnerSid - To support the future DS requirement of not mapping Creator
        Owner at the time of object creation.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalCachingTypeList - Internal object type list structure used to hold
        intermediate results for static granted bits.

    LocalTypeListLength - Length of the array represnting the object.

    ObjectTypeListPresent - Whether the called supplied an object type list.

    Restricted - Whether the restricted part of the client context should be
        used for access check.

    pCachingFlags - To return the flags that will be stored in the caching
        handle if the caller requested caching.

Algorithm:

    BEGIN_MAX_ALGO

    for all aces
      skip INHERIT_ONLY aces

      ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

        If (the sid is applicable) AND (Server Sid is also applicable)
          Update the entire tree starting at the root.
          Grant those bits that have not already been denied.

        Note: No one uses these!!

      ACCESS_ALLOWED_ACE_TYPE

        If the sid is applicable
          Update the entire tree starting at the root.
          Grant those bits that have not already been denied.

      ACCESS_ALLOWED_CALLBACK_ACE_TYPE

        If (the sid is applicable) AND (callback call evaluates ace applicable)
          Update the entire tree starting at the root.
          Grant those bits that have not already been denied.

      ACCESS_ALLOWED_OBJECT_ACE_TYPE

        If the sid is applicable
          get the ObjectType guid from the ace

          if the guid is NULL
            Update the entire tree starting at the root.
            Grant those bits that have not already been denied.
          else
            If (object type list exists) AND (contains a matching guid)
              Update the tree starting at the MATCH.
              Grant those bits that have not already been denied.

      ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE

        If (the sid is applicable) AND (callback call evaluates ace applicable)
          get the ObjectType guid from the ace

          if the guid is NULL
            Update the entire tree starting at the root.
            Grant those bits that have not already been denied.
          else
            If (object type list exists) AND (contains a matching guid)
              Update the tree starting at the MATCH.
              Grant those bits that have not already been denied.

      ACCESS_DENIED_ACE_TYPE

        If the sid is applicable
          Update the entire tree starting at the root.
          Deny those bits that have not already been granted.
          Propagate the deny all the way up to the root.

      ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE

        If (the sid is applicable) AND (callback call evaluates ace applicable)
          Update the entire tree starting at the root.
          Deny those bits that have not already been granted.
          Propagate the deny all the way up to the root.

      ACCESS_DENIED_OBJECT_ACE_TYPE

        If the sid is applicable
          get the ObjectType guid from the ace

          if the guid is NULL
            Update the entire tree starting at the root.
            Deny those bits that have not already been granted.
            Propagate the deny all the way up to the root.
          else
            If (object type list exists) AND (contains a matching guid)
              Update the tree starting at the MATCH.
              Deny those bits that have not already been granted.
              Propagate the deny all the way up to the root.

      ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE

        If (the sid is applicable) AND (callback call evaluates ace applicable)
          get the ObjectType guid from the ace

          if the guid is NULL
            Update the entire tree starting at the root.
            Deny those bits that have not already been granted.
            Propagate the deny all the way up to the root.
          else
            If (object type list exists) AND (contains a matching guid)
              Update the tree starting at the MATCH.
              Deny those bits that have not already been granted.
              Propagate the deny all the way up to the root.

Note:

    LocalCachingFlags is used to return whether the ace is contains principal
    self sid.

    We take a pessimistic view for dynamic aces. There are two types of
    dynamic aces:
        1. Call back aces
        2. Normal aces with principal self sid in it.

    For any dynamic ace,
        Grant aces are never applicable to the caching list.
        Deny aces are always applicable to the caching list.


Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD     AceCount          = 0;
    DWORD     i                 = 0;
    DWORD     Index             = 0;
    PVOID     Ace               = NULL;
    GUID    * ObjectTypeInAce   = NULL;
    BOOL      bAceApplicable    = FALSE;
    DWORD     LocalCachingFlags = 0;
    
    AceCount = pAcl->AceCount;

    for (i = 0, Ace = FirstAce(pAcl); i < AceCount; i++, Ace = NextAce(Ace))
    {

        //
        // Skip INHERIT_ONLY aces.
        //

        if (FLAG_ON(((PACE_HEADER) Ace)->AceFlags, INHERIT_ONLY_ACE))
        {
            continue;
        }
        
        LocalCachingFlags = 0;

        switch (((PACE_HEADER) Ace)->AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled. S-1-5-A is replaced by the principal sid
            // supplied by the caller. In future, Creator Owner will be replaced
            // by the owner sid in the primary security descriptor.
            //
                                               
                bAceApplicable = AuthzpSidApplicable(
                                     SidCount,
                                     pSidAttr,
                                     pSidHash,
                                     AuthzAceSid(Ace),
                                     pRequest->PrincipalSelfSid,
                                     pOwnerSid,
                                     FALSE,
                                     &LocalCachingFlags
                                     );

            //
            // Record the caching flags for this ace into the global flags.
            //

            *pCachingFlags |= LocalCachingFlags;

            if (!bAceApplicable)
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Grant access bits that have not already been denied.
                //

                LocalTypeList->CurrentGranted |= (((PKNOWN_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);

                //
                // A grant ace is considered static only if PrincipalSelf sid
                // is not found in the ace.
                //

                if (ARGUMENT_PRESENT(LocalCachingTypeList) && (0 == LocalCachingFlags))
                {
                    LocalCachingTypeList->CurrentGranted |= (((PKNOWN_ACE) Ace)->Mask & ~LocalCachingTypeList->CurrentDenied);
                }
            }
            else
            {
                //
                // Propagate grant bits down the tree starting at the root.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PKNOWN_ACE) Ace)->Mask,
                    AuthzUpdateCurrentGranted
                    );

                //
                // A grant ace is considered static only if PrincipalSelf sid
                // is not found in the ace.
                //

                if (ARGUMENT_PRESENT(LocalCachingTypeList) && (0 == LocalCachingFlags))
                {
                    AuthzpAddAccessTypeList(
                        LocalCachingTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );
                }
            }

            break;

        case ACCESS_ALLOWED_CALLBACK_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled. S-1-5-A is replaced by the principal sid
            // supplied by the caller. In future, Creator Owner will be replaced
            // by the owner sid in the primary security descriptor.
            //

                bAceApplicable = AuthzpSidApplicable(
                                     SidCount,
                                     pSidAttr,
                                     pSidHash,
                                     AuthzCallbackAceSid(Ace),
                                     pRequest->PrincipalSelfSid,
                                     pOwnerSid,
                                     FALSE,
                                     &LocalCachingFlags
                                     );


            //
            // Record the presence of a dynamic grant ace as well as the caching
            // flags for this ace into the global flags.
            //

            *pCachingFlags |= (LocalCachingFlags | AUTHZ_DYNAMIC_ALLOW_ACE_PRESENT);

            if (!bAceApplicable)
            {
                break;
            }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Grant access bits that have not already been denied.
                //

                LocalTypeList->CurrentGranted |= (((PKNOWN_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);
            }
            else
            {
                //
                // Propagate grant bits down the tree starting at the root.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PKNOWN_ACE) Ace)->Mask,
                    AuthzUpdateCurrentGranted
                    );
            }

            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            if ( ObjectTypeInAce && ( pRequest->ObjectTypeListLength == 0 ))
            {
                break;
            }

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled. S-1-5-A is replaced by the principal sid
            // supplied by the caller. In future, Creator Owner will be replaced
            // by the owner sid in the primary security descriptor.
            //

                bAceApplicable = AuthzpSidApplicable(
                                     SidCount,
                                     pSidAttr,
                                     pSidHash,
                                     AuthzObjectAceSid(Ace),
                                     pRequest->PrincipalSelfSid,
                                     pOwnerSid,
                                     FALSE,
                                     &LocalCachingFlags
                                     );

            //
            // Record the the caching flags for this ace into the global flags.
            //

            *pCachingFlags |= LocalCachingFlags;

            if (!bAceApplicable)
            {
                break;
            }

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (NULL == ObjectTypeInAce)
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Grant access bits that have not already been denied.
                    //

                    LocalTypeList->CurrentGranted |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);

                    //
                    // A grant ace is considered static only if PrincipalSelf sid
                    // is not found in the ace.
                    //

                    if (ARGUMENT_PRESENT(LocalCachingTypeList) && (0 == LocalCachingFlags))
                    {
                        LocalCachingTypeList->CurrentGranted |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalCachingTypeList->CurrentDenied);
                    }
                }
                else
                {
                    //
                    // Propagate grant bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );

                    //
                    // A grant ace is considered static only if PrincipalSelf sid
                    // is not found in the ace.
                    //

                    if (ARGUMENT_PRESENT(LocalCachingTypeList) && (0 == LocalCachingFlags))
                    {
                        AuthzpAddAccessTypeList(
                            LocalCachingTypeList,
                            LocalTypeListLength,
                            0,
                            ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                            AuthzUpdateCurrentGranted
                            );
                    }
                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        LocalTypeListLength,
                        &Index
                        )
                    )
                {
                    //
                    // Propagate grant bits down the tree starting at the
                    // index at which the guids matched.
                    // In the case when this is the last of the siblings to be
                    // granted access, the parent also is granted access.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );

                    //
                    // A grant ace is considered static only if PrincipalSelf sid
                    // is not found in the ace.
                    //

                    if (ARGUMENT_PRESENT(LocalCachingTypeList) && (0 == LocalCachingFlags))
                    {
                        AuthzpAddAccessTypeList(
                            LocalCachingTypeList,
                            LocalTypeListLength,
                            Index,
                            ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                            AuthzUpdateCurrentGranted
                            );
                    }
                }
            }

           break;

        case ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled. S-1-5-A is replaced by the principal sid
            // supplied by the caller. In future, Creator Owner will be replaced
            // by the owner sid in the primary security descriptor.
            //

                bAceApplicable = AuthzpSidApplicable(
                                     SidCount,
                                     pSidAttr,
                                     pSidHash,
                                     AuthzCallbackObjectAceSid(Ace),
                                     pRequest->PrincipalSelfSid,
                                     pOwnerSid,
                                     FALSE,
                                     &LocalCachingFlags
                                     );

            //
            // Record the presence of a dynamic grant ace as well as the caching
            // flags for this ace into the global flags.
            //

            *pCachingFlags |= (LocalCachingFlags | AUTHZ_DYNAMIC_ALLOW_ACE_PRESENT);

            if (!bAceApplicable)
            {
                break;
            }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Grant access bits that have not already been denied.
                    //

                    LocalTypeList->CurrentGranted |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);
                }
                else
                {
                    //
                    // Propagate grant bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );
                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        LocalTypeListLength,
                        &Index
                        )
                    )
                {
                    //
                    // Propagate grant bits down the tree starting at the
                    // index at which the guids matched.
                    // In the case when this is the last of the siblings to be
                    // granted access, the parent also is granted access.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );

                }
            }

           break;

        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

            if (!AUTHZ_NON_NULL_PTR(pCC->Server))
            {
                break;
            }

            LocalCachingFlags = 0;

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled. S-1-5-A is replaced by the principal sid
            // supplied by the caller. In future, Creator Owner will be replaced
            // by the owner sid in the primary security descriptor.
            //

                bAceApplicable = AuthzpSidApplicable(
                                     SidCount,
                                     pSidAttr,
                                     pSidHash,
                                     RtlCompoundAceClientSid(Ace),
                                     pRequest->PrincipalSelfSid,
                                     pOwnerSid,
                                     FALSE,
                                     &LocalCachingFlags
                                     );

            //
            // Record the caching flags for this ace into the global flags.
            //

            *pCachingFlags |= LocalCachingFlags;

            if (!bAceApplicable)
            {
                break;
            }

                bAceApplicable = AuthzpSidApplicable(
                                     pCC->Server->SidCount,
                                     pCC->Server->Sids,
                                     pCC->Server->SidHash,
                                     RtlCompoundAceServerSid(Ace),
                                     NULL,
                                     NULL,
                                     FALSE,
                                     NULL
                                     );

            if (!bAceApplicable)
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Grant access bits that have not already been denied.
                //

                LocalTypeList->CurrentGranted |= (((PCOMPOUND_ACCESS_ALLOWED_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);

                //
                // A grant ace is considered static only if PrincipalSelf sid
                // is not found in the ace.
                //

                if (ARGUMENT_PRESENT(LocalCachingTypeList) && (0 == LocalCachingFlags))
                {
                    LocalCachingTypeList->CurrentGranted |= (((PCOMPOUND_ACCESS_ALLOWED_ACE) Ace)->Mask & ~LocalCachingTypeList->CurrentDenied);
                }
            }
            else
            {
                //
                // Propagate grant bits down the tree starting at the root.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PCOMPOUND_ACCESS_ALLOWED_ACE) Ace)->Mask,
                    AuthzUpdateCurrentGranted
                    );

                //
                // A grant ace is considered static only if PrincipalSelf sid
                // is not found in the ace.
                //

                if (ARGUMENT_PRESENT(LocalCachingTypeList) && (0 == LocalCachingFlags))
                {
                    AuthzpAddAccessTypeList(
                        LocalCachingTypeList,
                        LocalTypeListLength,
                        0,
                        ((PCOMPOUND_ACCESS_ALLOWED_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );
                }
            }

            break;

        case ACCESS_DENIED_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only. S-1-5-A is replaced by
            // the principal sid supplied by the caller. In future, Creator
            // Owner will be replaced by the owner sid in the primary security
            // descriptor.
            //

                bAceApplicable = AuthzpSidApplicable(
                                     SidCount,
                                     pSidAttr,
                                     pSidHash,
                                     AuthzAceSid(Ace),
                                     pRequest->PrincipalSelfSid,
                                     pOwnerSid,
                                     TRUE,
                                     &LocalCachingFlags
                                     );

            //
            // Record the presence of a Deny ace as well as the caching
            // flags for this ace into the global flags.
            //

            *pCachingFlags |= (LocalCachingFlags | AUTHZ_DENY_ACE_PRESENT);

            //
            // If the ace is applicable or principal self sid is present then
            // deny the access bits to the cached access check results. We
            // take a pessimistic view and assume that the principal self sid
            // will be applicable in the next access check.
            //

            if ((bAceApplicable || (0 != LocalCachingFlags)) &&
                (ARGUMENT_PRESENT(LocalCachingTypeList)))
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Deny access bits that have not already been granted.
                    //

                    LocalCachingTypeList->CurrentDenied |= (((PKNOWN_ACE) Ace)->Mask & ~LocalCachingTypeList->CurrentGranted);
                }
                else
                {
                    //
                    // Propagate deny bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalCachingTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_ACE) Ace)->Mask,
                        AuthzUpdateCurrentDenied
                        );
                }
            }

            if (!bAceApplicable)
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Deny access bits that have not already been granted.
                //

                LocalTypeList->CurrentDenied |= (((PKNOWN_ACE) Ace)->Mask & ~LocalTypeList->CurrentGranted);
            }
            else
            {
                //
                // Propagate deny bits down the tree starting at the root.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PKNOWN_ACE) Ace)->Mask,
                    AuthzUpdateCurrentDenied
                    );
            }

            break;

        case ACCESS_DENIED_CALLBACK_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only. S-1-5-A is replaced by
            // the principal sid supplied by the caller. In future, Creator
            // Owner will be replaced by the owner sid in the primary security
            // descriptor.
            //

                bAceApplicable = AuthzpSidApplicable(
                                     SidCount,
                                     pSidAttr,
                                     pSidHash,
                                     AuthzCallbackAceSid(Ace),
                                     pRequest->PrincipalSelfSid,
                                     pOwnerSid,
                                     TRUE,
                                     &LocalCachingFlags
                                     );

            //
            // Record the presence of a dynamic Deny ace as well as the caching
            // flags for this ace into the global flags.
            //

            *pCachingFlags |= (LocalCachingFlags | AUTHZ_DYNAMIC_DENY_ACE_PRESENT);

            //
            // If the ace is applicable or principal self sid is present then
            // deny the access bits to the cached access check results. We
            // take a pessimistic view and assume that the principal self sid
            // will be applicable in the next access check.
            //

            if ((bAceApplicable || (0 != LocalCachingFlags)) &&
                (ARGUMENT_PRESENT(LocalCachingTypeList)))
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Deny access bits that have not already been granted.
                    //

                    LocalCachingTypeList->CurrentDenied |= (((PKNOWN_ACE) Ace)->Mask & ~LocalCachingTypeList->CurrentGranted);
                }
                else
                {
                    //
                    // Propagate deny bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalCachingTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_ACE) Ace)->Mask,
                        AuthzUpdateCurrentDenied
                        );
                }
            }

            if (!bAceApplicable)
            {
                break;
            }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }


            if (!bAceApplicable)
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Deny access bits that have not already been granted.
                //

                LocalTypeList->CurrentDenied |= (((PKNOWN_ACE) Ace)->Mask & ~LocalTypeList->CurrentGranted);
            }
            else
            {
                //
                // Propagate deny bits down the tree starting at the root.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PKNOWN_ACE) Ace)->Mask,
                    AuthzUpdateCurrentDenied
                    );
            }

            break;

        case ACCESS_DENIED_OBJECT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only. S-1-5-A is replaced by
            // the principal sid supplied by the caller. In future, Creator
            // Owner will be replaced by the owner sid in the primary security
            // descriptor.
            //

                bAceApplicable = AuthzpSidApplicable(
                                     SidCount,
                                     pSidAttr,
                                     pSidHash,
                                     AuthzObjectAceSid(Ace),
                                     pRequest->PrincipalSelfSid,
                                     pOwnerSid,
                                     TRUE,
                                     &LocalCachingFlags
                                     );

            //
            // Record the presence of a Deny ace as well as the caching
            // flags for this ace into the global flags.
            //

            *pCachingFlags |= (LocalCachingFlags | AUTHZ_DENY_ACE_PRESENT);

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // If the ace is applicable or principal self sid is present then
            // deny the access bits to the cached access check results. We
            // take a pessimistic view and assume that the principal self sid
            // will be applicable in the next access check.
            //

            if ((bAceApplicable || (0 != LocalCachingFlags)) &&
                (ARGUMENT_PRESENT(LocalCachingTypeList)))
            {
                //
                // An object type ace with a NULL Object Type guid is the same
                // as a normal ace.
                //

                if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
                {
                    //
                    // Optimize the common case instead of calling a subroutine.
                    //

                    if (1 == LocalTypeListLength)
                    {
                        //
                        // Deny access bits that have not already been granted.
                        //

                        LocalCachingTypeList->CurrentDenied |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalCachingTypeList->CurrentGranted);
                    }
                    else
                    {
                        //
                        // Propagate deny bits down the tree starting at the root.
                        //

                        AuthzpAddAccessTypeList(
                            LocalCachingTypeList,
                            LocalTypeListLength,
                            0,
                            ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                            AuthzUpdateCurrentDenied
                            );
                    }
                }

                //
                // So, it is a true object type ace. Proceed only if we are doing
                // access check on a object type list.
                //

                else if (ObjectTypeListPresent)
                {
                    //
                    // Look for a matching object type guid that matches the one in
                    // the ace.
                    //

                    if (AuthzpObjectInTypeList(
                                 ObjectTypeInAce,
                                 LocalTypeList,
                                 LocalTypeListLength,
                                 &Index
                                 )
                             )
                    {
                        //
                        // Propagate deny bits down the tree starting at the
                        // index at which the guids matched. Deny bits are
                        // propagated to all the ancestors as well.
                        //

                        AuthzpAddAccessTypeList(
                            LocalCachingTypeList,
                            LocalTypeListLength,
                            Index,
                            ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                            AuthzUpdateCurrentDenied
                            );
                    }
                }
            }

            if (!bAceApplicable)
            {
                break;
            }

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Deny access bits that have not already been granted.
                    //

                    LocalTypeList->CurrentDenied |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalTypeList->CurrentGranted);
                }
                else
                {                    
                    //
                    // Propagate deny bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentDenied
                        );
                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                             ObjectTypeInAce,
                             LocalTypeList,
                             LocalTypeListLength,
                             &Index
                             )
                         )
                {
                    //
                    // Propagate deny bits down the tree starting at the
                    // index at which the guids matched. Deny bits are
                    // propagated to all the ancestors as well.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentDenied
                        );
                }
            }

            break;

        case ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only. S-1-5-A is replaced by
            // the principal sid supplied by the caller. In future, Creator
            // Owner will be replaced by the owner sid in the primary security
            // descriptor.
            //

                bAceApplicable = AuthzpSidApplicable(
                                     SidCount,
                                     pSidAttr,
                                     pSidHash,
                                     AuthzObjectAceSid(Ace),
                                     pRequest->PrincipalSelfSid,
                                     pOwnerSid,
                                     TRUE,
                                     &LocalCachingFlags
                                     );

            //
            // Record the presence of a dynamic Deny ace as well as the caching
            // flags for this ace into the global flags.
            //

            *pCachingFlags |= (LocalCachingFlags | AUTHZ_DYNAMIC_DENY_ACE_PRESENT);

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // If the ace is applicable or principal self sid is present then
            // deny the access bits to the cached access check results. We
            // take a pessimistic view and assume that the principal self sid
            // will be applicable in the next access check.
            //

            if ((bAceApplicable || (0 != LocalCachingFlags)) &&
                (ARGUMENT_PRESENT(LocalCachingTypeList)))
            {
                //
                // An object type ace with a NULL Object Type guid is the same
                // as a normal ace.
                //

                if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
                {
                    //
                    // Optimize the common case instead of calling a subroutine.
                    //

                    if (1 == LocalTypeListLength)
                    {
                        //
                        // Deny access bits that have not already been granted.
                        //

                        LocalCachingTypeList->CurrentDenied |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalCachingTypeList->CurrentGranted);
                    }
                    else
                    {
                        //
                        // Propagate deny bits down the tree starting at the root.
                        //

                        AuthzpAddAccessTypeList(
                            LocalCachingTypeList,
                            LocalTypeListLength,
                            0,
                            ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                            AuthzUpdateCurrentDenied
                            );
                    }
                }

                //
                // So, it is a true object type ace. Proceed only if we are doing
                // access check on a object type list.
                //

                else if (ObjectTypeListPresent)
                {
                    //
                    // Look for a matching object type guid that matches the one in
                    // the ace.
                    //

                    if (AuthzpObjectInTypeList(
                                 ObjectTypeInAce,
                                 LocalTypeList,
                                 LocalTypeListLength,
                                 &Index
                                 )
                             )
                    {
                        //
                        // Propagate deny bits down the tree starting at the
                        // index at which the guids matched. Deny bits are
                        // propagated to all the ancestors as well.
                        //

                        AuthzpAddAccessTypeList(
                            LocalCachingTypeList,
                            LocalTypeListLength,
                            Index,
                            ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                            AuthzUpdateCurrentDenied
                            );
                    }
                }
            }

            if (!bAceApplicable)
            {
                break;
            }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Deny access bits that have not already been granted.
                    //

                    LocalTypeList->CurrentDenied |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalTypeList->CurrentGranted);
                }
                else
                {
                    //
                    // Propagate deny bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentDenied
                        );
                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                             ObjectTypeInAce,
                             LocalTypeList,
                             LocalTypeListLength,
                             &Index
                             )
                         )
                {
                    //
                    // Propagate deny bits down the tree starting at the
                    // index at which the guids matched. Deny bits are
                    // propagated to all the ancestors as well.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentDenied
                        );
                }
            }

            break;

        default:
            break;
        }
    }

    return TRUE;
}

#if 0

BOOL
AuthzpSidApplicableOrig(
    IN DWORD SidCount,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN PSID pAceSid,
    IN PSID PrincipalSelfSid,
    IN PSID CreatorOwnerSid,
    IN BOOL DenyAce,
    OUT PDWORD pCachingFlags
    )

/*++

Routine description:

    This routine decides whether the ace is applicable to the client context.

Arguments:

    SidCount - Number of sids in the pSidAttrArray

    pSidAttr - Sid and attributes against which the ace sid should be compared.

    pAceSid - Sid in the ace.

    PrincipalSelfSid - To replace the ace sid if the ace sid is
        Principal Self Sid (S-1-5-A).

    CreatorOwnerSid - To replace the ace sid if the ace sid is Creator Owner
        sid (S-1-3-0). This will not be used in the current implementation but
        will come in effect once we do single instancing.

    DenyAce - Boolean specifying whether the ace is a deny ace.

    pCachingFlags - To return caching information in the form of:
        AUTHZ_PRINCIPAL_SELF_ACE_PRESENT
        AUTHZ_DYNAMIC_ALLOW_ACE_PRESENT
        AUTHZ_DYNAMIC_DENY_ACE_PRESENT

Return Value:

    A value of TRUE is returned if the effective sid is found in the client
    context and (is enabled OR enabled for deny only for deny aces).
    FALSE otherwise.

--*/

{
    DWORD i        = 0;
    PISID MatchSid = NULL;
    PSID  pSid     = pAceSid;
    DWORD SidLen   = RtlLengthSid(pAceSid);

    UNREFERENCED_PARAMETER(CreatorOwnerSid);

    //
    // If the principal ace sid is principal self sid and Principal self sid
    // has been provided then use it.
    //

    if (AUTHZ_EQUAL_SID(pSid, pAuthzPrincipalSelfSid, SidLen))
    {
        //
        // Record the presence of a principal self sid in this ace.
        //

        *pCachingFlags |= AUTHZ_PRINCIPAL_SELF_ACE_PRESENT;

        if (ARGUMENT_PRESENT(PrincipalSelfSid))
        {
            pSid = PrincipalSelfSid;
            SidLen = RtlLengthSid(pSid);
        }
        else
        {
            return FALSE;
        }
    }

#ifdef AUTHZ_SINGLE_INSTANCE

    //
    // Single instance security descriptor code
    //

    else if (ARGUMENT_PRESENT(CreatorOwnerSid) && AUTHZ_EQUAL_SID(pSid, pAuthzCreatorOwnerSid, SidLen))
    {
        pSid = CreatorOwnerSid;
        SidLen   = RtlLengthSid(pSid);
    }

#endif

    //
    // Loop thru the sids to find a match.
    //

    for (i = 0; i < SidCount; i++, pSidAttr++)
    {
        MatchSid = (PISID) pSidAttr->Sid;

        if (AUTHZ_EQUAL_SID(pSid, MatchSid, SidLen))
        {
            //
            // Return TRUE if
            //    a. the sid is enabled OR
            //    b the sid is enabled for deny only and the ace is a Deny ace.
            // Else
            //    return FALSE.
            //

            if (FLAG_ON(pSidAttr->Attributes, SE_GROUP_ENABLED) ||
                (DenyAce && FLAG_ON(pSidAttr->Attributes, SE_GROUP_USE_FOR_DENY_ONLY))
                )
            {

#ifdef AUTHZ_DEBUG
                wprintf(L"Applicable sid = %x, %x, %x, %x, %x, %x, %x\n",
                        ((DWORD *) MatchSid)[0], ((DWORD *) MatchSid)[1],
                        ((DWORD *) MatchSid)[2], ((DWORD *) MatchSid)[3],
                        ((DWORD *) MatchSid)[4], ((DWORD *) MatchSid)[5],
                        ((DWORD *) MatchSid)[1]);
#endif
                return TRUE;
            }

            return FALSE;
        }
    }

    return FALSE;
}
#endif

#define AUTHZ_SID_HASH_BYTE(s) ((UCHAR)(((PISID)s)->SubAuthority[((PISID)s)->SubAuthorityCount - 1]))


VOID
AuthzpInitSidHash(
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN ULONG SidCount,
    OUT PAUTHZI_SID_HASH_ENTRY pHash
    )

/*++

Routine Description

    Initializes the SID hash table.
 
Arguments

    pSidAttr - array of sids to store in hash.
    
    SidCount - number of sids in array.
    
    pHash - pointer to the sid hash table.  
    
Return Value

    None.

--*/

{
    ULONG i           = 0;
    ULONG PositionBit = 0;
    BYTE  HashByte    = 0;

    //
    // Zero the table.
    //

    RtlZeroMemory(
        pHash,
        sizeof(AUTHZI_SID_HASH_ENTRY) * AUTHZI_SID_HASH_SIZE
        );

    if (pSidAttr == NULL)
    {
        return;
    }

    //
    // Can only hash the number of sids that each table entry can hold
    //

    if (SidCount > AUTHZI_SID_HASH_ENTRY_NUM_BITS)
    {
        SidCount = AUTHZI_SID_HASH_ENTRY_NUM_BITS;
    }

    for (i = 0; i < SidCount; i++)
    {
        //
        // HashByte is last byte in SID.
        //

        HashByte = AUTHZ_SID_HASH_BYTE(pSidAttr[i].Sid);
        
        //
        // Position indicates the location of this SID in pSidAttr.
        //

        PositionBit = 1 << i;
        
        //
        // Store the position bit in the low hash indexed by the low order bits of the HashByte
        //

        pHash[(HashByte & AUTHZ_SID_HASH_LOW_MASK)] |= PositionBit;
        
        //
        // Store the position bit in the high hash indexed by the high order bits of the HashByte
        //

        pHash[AUTHZ_SID_HASH_HIGH + ((HashByte & AUTHZ_SID_HASH_HIGH_MASK) >> 4)] |= PositionBit;
    }
}


BOOL
AuthzpSidApplicable(
    IN DWORD SidCount,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN PAUTHZI_SID_HASH_ENTRY pHash,
    IN PSID pAceSid,
    IN PSID PrincipalSelfSid,
    IN PSID CreatorOwnerSid,
    IN BOOL DenyAce,
    OUT PDWORD pCachingFlags
)

/*++

Routine description:

    This routine decides whether the ace is applicable to the client context.

Arguments:

    SidCount - Number of sids in the pSidAttrArray

    pSidAttr - Sid and attributes against which the ace sid should be compared.

    pHash - Hash table of the pSidAttr array.
                                                                                 
    pAceSid - Sid in the ace.

    PrincipalSelfSid - To replace the ace sid if the ace sid is
        Principal Self Sid (S-1-5-A).

    CreatorOwnerSid - To replace the ace sid if the ace sid is Creator Owner
        sid (S-1-3-0). This will not be used in the current implementation but
        will come in effect once we do single instancing.

    DenyAce - Boolean specifying whether the ace is a deny ace.

    pCachingFlags - To return caching information in the form of:
        AUTHZ_PRINCIPAL_SELF_ACE_PRESENT
        AUTHZ_DYNAMIC_ALLOW_ACE_PRESENT
        AUTHZ_DYNAMIC_DENY_ACE_PRESENT

Return Value:

    A value of TRUE is returned if the effective sid is found in the client
    context and (is enabled OR enabled for deny only for deny aces).
    FALSE otherwise.

--*/

{
    DWORD                 SidLen;
    DWORD                 BitIndex;
    UCHAR                 HashByte;
    DWORD                 i;
    UCHAR                 ByteToExamine;
    UCHAR                 ByteOffset;
    AUTHZI_SID_HASH_ENTRY SidPositionBitMap;
    PSID_AND_ATTRIBUTES   pSA;

    UNREFERENCED_PARAMETER(CreatorOwnerSid);

    //
    // If the principal ace sid is principal self sid and Principal self sid
    // has been provided then use it.
    //

    if (ARGUMENT_PRESENT(PrincipalSelfSid))
    {
        SidLen = RtlLengthSid(pAceSid);

        if ((SidLen == AuthzpPrincipalSelfSidLen) &&
            (AUTHZ_EQUAL_SID(pAceSid, pAuthzPrincipalSelfSid, SidLen)))
        {
            //
            // Record the presence of a principal self sid in this ace.
            //

            *pCachingFlags |= AUTHZ_PRINCIPAL_SELF_ACE_PRESENT;

            pAceSid = PrincipalSelfSid;
            SidLen = RtlLengthSid(pAceSid);
        }
    }

    //
    // Index into pHash by the last byte of the SID.  The resulting value (SidPositionBitMap) 
    // indicates the locations of SIDs in a corresponding SID_AND_ATTRIBUTES array that match 
    // that last byte.
    //

    HashByte          = AUTHZ_SID_HASH_BYTE(pAceSid);
    SidPositionBitMap = AUTHZ_SID_HASH_LOOKUP(pHash, HashByte);
    SidLen            = RtlLengthSid(pAceSid);
    ByteOffset        = 0;

    while (0 != SidPositionBitMap)
    {
        ByteToExamine = (UCHAR)SidPositionBitMap;

        while (ByteToExamine)
        {
            //
            // Get the first nonzero bit in ByteToExamine
            //

            BitIndex = AuthzpByteToIndexLookupTable[ByteToExamine];
            
            //
            // Find the PSID_AND_ATTRIBUTES to which the bit refers.
            //

            pSA = &pSidAttr[ByteOffset + BitIndex];

            if (AUTHZ_EQUAL_SID(pAceSid, pSA->Sid, SidLen))
            {
                if ((FLAG_ON(pSA->Attributes, SE_GROUP_ENABLED)) ||
                    (DenyAce && FLAG_ON(pSA->Attributes, SE_GROUP_USE_FOR_DENY_ONLY)))
                {
                    return TRUE;
                }

                return FALSE;
            }

            // 
            // Turn the current bit off and try the next SID.
            //

            ByteToExamine ^= (1 << BitIndex);
        }

        ByteOffset        = ByteOffset + sizeof(UCHAR);
        SidPositionBitMap = SidPositionBitMap >> sizeof(UCHAR);
    }
    
    //
    // If a matching sid was not found in the pHash and there are SIDS in pSidAttr which did not 
    // get placed in pHash, then search those SIDS for a match.
    //
    
    for (i = AUTHZI_SID_HASH_ENTRY_NUM_BITS; i < SidCount; i++)
    {
        pSA = &pSidAttr[i];

        if (AUTHZ_EQUAL_SID(pAceSid, pSA->Sid, SidLen))
        {
            if ((FLAG_ON(pSA->Attributes, SE_GROUP_ENABLED)) ||
                (DenyAce && FLAG_ON(pSA->Attributes, SE_GROUP_USE_FOR_DENY_ONLY)))
            {
                return TRUE;
            }

            return FALSE;
        }
    }

    return FALSE;
}


BOOL
AuthzpAccessCheckWithCaching(
    IN DWORD Flags,
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    OUT PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE phAccessCheckResults OPTIONAL,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN OUT PIOBJECT_TYPE_LIST LocalCachingTypeList OPTIONAL,
    IN DWORD LocalTypeListLength
    )

/*++

Routine description:

    This routine does a MaximumAllowed access check. It is called if any of the
    following is TRUE
        1. RM has requested for caching
        2. DesiredAccessMask has MAXIMUM_ALLOWED turned on.
        3. ObjectTypeList is present and pReply->ResultList has a length > 1

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    pReply - To return the results of access check call.

    phAccessCheckResults - To return a handle to cached results of the access check
        call.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalCachingTypeList - Internal object type list structure used to hold
        intermediate results for static granted bits.

    LocalTypeListLength - Length of the array represnting the object.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    ACCESS_MASK PreviouslyGrantedAccess = 0;
    DWORD       CachingFlags            = 0;
    DWORD       i                       = 0;
    BOOL        b                       = TRUE;
    PACL        pAcl                    = NULL;

    //
    // Owner is always granted READ_CONTROL and WRITE_DAC.
    //

    if (AuthzpOwnerSidInClientContext(pCC, pSecurityDescriptor))
    {
        PreviouslyGrantedAccess |= (WRITE_DAC | READ_CONTROL);
    }

    //
    // Take ownership privilege grants WRITE_OWNER.
    //

    if (AUTHZ_PRIVILEGE_CHECK(pCC, AUTHZ_TAKE_OWNERSHIP_PRIVILEGE_ENABLED))
    {
        PreviouslyGrantedAccess |= WRITE_OWNER;
    }

    //
    // SecurityPrivilege grants ACCESS_SYSTEM_SECURITY.
    //

    if (AUTHZ_PRIVILEGE_CHECK(pCC, AUTHZ_SECURITY_PRIVILEGE_ENABLED))
    {
        PreviouslyGrantedAccess |= ACCESS_SYSTEM_SECURITY;
    }
    else if (FLAG_ON(pRequest->DesiredAccess, ACCESS_SYSTEM_SECURITY))
    {
        AuthzpFillReplyStructure(
            pReply,
            ERROR_PRIVILEGE_NOT_HELD,
            0
            );

        SetLastError(ERROR_SUCCESS);
        return TRUE;
    }

    pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);

    //
    // NULL Dacl is synonymous with Full Control.
    //

    if (!AUTHZ_NON_NULL_PTR(pAcl))
    {
        PreviouslyGrantedAccess |= (STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL);

        for (i = 0; i < LocalTypeListLength; i++)
        {
             LocalTypeList[i].CurrentGranted |= PreviouslyGrantedAccess;

             if (ARGUMENT_PRESENT(LocalCachingTypeList))
             {
                 LocalCachingTypeList[i].CurrentGranted |= PreviouslyGrantedAccess;
             }
        }
    }
    else
    {
        for (i = 0; i < LocalTypeListLength; i++)
        {
             LocalTypeList[i].CurrentGranted |= PreviouslyGrantedAccess;

             if (ARGUMENT_PRESENT(LocalCachingTypeList))
             {
                 LocalCachingTypeList[i].CurrentGranted |= PreviouslyGrantedAccess;
             }
        }

        b = AuthzpMaximumAllowedAccessCheck(
                    pCC,
                    pRequest,
                    pSecurityDescriptor,
                    OptionalSecurityDescriptorArray,
                    OptionalSecurityDescriptorCount,
                    LocalTypeList,
                    LocalCachingTypeList,
                    LocalTypeListLength,
                    0 != pRequest->ObjectTypeListLength,
                    &CachingFlags
                    );

        if (!b) 
        {
            goto Cleanup;
        }
    }

    //
    // If the caller asked for caching then allocate a handle, store the results
    // of the static access check in it and insert it into the list of handles.
    //

    if (ARGUMENT_PRESENT(phAccessCheckResults))
    {
        b = AuthzpCacheResults(
                Flags,
                pCC,
                LocalCachingTypeList,
                LocalTypeListLength,
                pSecurityDescriptor,
                OptionalSecurityDescriptorArray,
                OptionalSecurityDescriptorCount,
                CachingFlags,
                phAccessCheckResults
                );

        if (!b) goto Cleanup;
    }

    AuthzpFillReplyFromParameters(
        pRequest,
        pReply,
        LocalTypeList
        );

Cleanup:

    return b;
}


VOID
AuthzpFillReplyFromParameters(
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN PIOBJECT_TYPE_LIST LocalTypeList
    )

/*++

Routine description:

    This routine fills in the reply structure wih the results of access check
    supplied by LocalTypeList.

Arguments:

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pReply - The reply structure to fill.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results. This is used to fill the reply structure.

Return Value:

    None.

--*/

{
    ACCESS_MASK DesiredAccess   = 0;
    ACCESS_MASK RelevantAccess  = 0;
    DWORD       i               = 0;

    if (FLAG_ON(pRequest->DesiredAccess, ACCESS_SYSTEM_SECURITY))
    {
        RelevantAccess = STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL | ACCESS_SYSTEM_SECURITY;
    }
    else
    {
        RelevantAccess = STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL;
    }

    if (FLAG_ON(pRequest->DesiredAccess, MAXIMUM_ALLOWED))
    {
        DesiredAccess = pRequest->DesiredAccess & ~(MAXIMUM_ALLOWED);
   
        for (i = 0; i < pReply->ResultListLength; i++)
        {
            if (FLAG_ON(DesiredAccess, ~(LocalTypeList[i].CurrentGranted)) ||
                (0 == LocalTypeList[i].CurrentGranted))
            {
                pReply->GrantedAccessMask[i] = 0;
                pReply->Error[i] = ERROR_ACCESS_DENIED;
            }
            else
            {
                pReply->GrantedAccessMask[i] = LocalTypeList[i].CurrentGranted & RelevantAccess;
                pReply->Error[i] = ERROR_SUCCESS;
            }
        }
    }
    else
    {
        for (i = 0; i < pReply->ResultListLength; i++)
        {
            if (FLAG_ON(pRequest->DesiredAccess, ~(LocalTypeList[i].CurrentGranted)))
            {
                pReply->GrantedAccessMask[i] = 0;
                pReply->Error[i] = ERROR_ACCESS_DENIED;
            }
            else
            {
                pReply->GrantedAccessMask[i] = pRequest->DesiredAccess & RelevantAccess;
                pReply->Error[i] = ERROR_SUCCESS;
            }
        }
    }

}


BOOL
AuthzpNormalAccessCheckWithoutCaching(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    )

/*++

Routine description:

    This routine does a normal access check. If desired access is denied at any
    point then it stops acl evaluation.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    pReply - The reply structure to return the results.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    ACCESS_MASK Remaining = pRequest->DesiredAccess;
    PACL        pAcl      = NULL;
    BOOL        b         = TRUE;

    //
    // Check for SeSecurityPrivilege.
    //

    if (FLAG_ON(Remaining, ACCESS_SYSTEM_SECURITY))
    {
        if (AUTHZ_PRIVILEGE_CHECK(pCC, AUTHZ_SECURITY_PRIVILEGE_ENABLED))
        {
            Remaining &= ~(ACCESS_SYSTEM_SECURITY);
        }
        else
        {
            AuthzpFillReplyStructure(
                pReply,
                ERROR_PRIVILEGE_NOT_HELD,
                0
                );

            SetLastError(ERROR_SUCCESS);
            return TRUE;
        }
    }

    //
    // Ownership of the object grants READ_CONTROL and WRITE_DAC.
    //

    if (FLAG_ON(Remaining, (READ_CONTROL | WRITE_DAC)) &&
        AuthzpOwnerSidInClientContext(pCC, pSecurityDescriptor))
    {
        Remaining &= ~(WRITE_DAC | READ_CONTROL);
    }

    //
    // SeTakeOwnership privilege grants WRITE_OWNER.
    //

    if (FLAG_ON(Remaining, WRITE_OWNER) &&
        AUTHZ_PRIVILEGE_CHECK(pCC, AUTHZ_TAKE_OWNERSHIP_PRIVILEGE_ENABLED))
    {
        Remaining &= ~(WRITE_OWNER);
    }

    pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);

    //
    // Null acl represents FULL CONTROL.
    //

    if (!AUTHZ_NON_NULL_PTR(pAcl))
    {
        Remaining = 0;
    }

    //
    // If we have been granted access at this point then acl evaluation is not
    // needed.
    //

    if (0 == Remaining)
    {
        AuthzpFillReplyStructure(
            pReply,
            ERROR_SUCCESS,
            pRequest->DesiredAccess
            );

        SetLastError(ERROR_SUCCESS);
        return TRUE;
    }

    //
    // Do the access check with the non-restricted part of the client context.
    //

    b = AuthzpNormalMultipleSDAccessCheck(
            pCC,
            pCC->Sids,
            pCC->SidCount,
            pCC->SidHash,
            Remaining,
            pRequest,
            pSecurityDescriptor,
            OptionalSecurityDescriptorArray,
            OptionalSecurityDescriptorCount,
            LocalTypeList,
            LocalTypeListLength
            );

    if (!b)
    {
        return FALSE;
    }

#ifdef AUTHZ_DEBUG
    wprintf(L"Remaining = %x, LocalTypeList = %x\n", Remaining, LocalTypeList->Remaining);
#endif

    if (0 != LocalTypeList->Remaining)
    {
        AuthzpFillReplyStructure(
            pReply,
            ERROR_ACCESS_DENIED,
            0
            );

        SetLastError(ERROR_SUCCESS);
        return TRUE;
    }

    //
    // If the client context is resticted then even the resticted part has to
    // grant all the access bits that were asked.
    //

    if (AUTHZ_TOKEN_RESTRICTED(pCC))
    {
        b = AuthzpNormalMultipleSDAccessCheck(
                pCC,
                pCC->RestrictedSids,
                pCC->RestrictedSidCount,
                pCC->RestrictedSidHash,
                Remaining,
                pRequest,
                pSecurityDescriptor,
                OptionalSecurityDescriptorArray,
                OptionalSecurityDescriptorCount,
                LocalTypeList,
                LocalTypeListLength
                );

        if (!b)
        {
            return FALSE;
        }

        if (0 != LocalTypeList->Remaining)
        {
            AuthzpFillReplyStructure(
                pReply,
                ERROR_ACCESS_DENIED,
                0
                );

            SetLastError(ERROR_SUCCESS);
            return TRUE;
        }
    }

    //
    // If we made it till here then all access bits have been granted.
    //

    AuthzpFillReplyStructure(
        pReply,
        ERROR_SUCCESS,
        pRequest->DesiredAccess
        );

    SetLastError(ERROR_SUCCESS);
    return TRUE;
}


BOOL
AuthzpNormalMultipleSDAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN ACCESS_MASK Remaining,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList OPTIONAL,
    IN DWORD LocalTypeListLength
    )

/*++

Routine description:

    This routine loops thru all the security descriptors and calls
    AuthzpNormalAccessCheck.

Arguments:

    pCC - Pointer to the client context.

    pSidAttr - Sids and attributes array to compare ace sids.

    SidCount - Number of elements in the array.

    Remaining - Access bits that are yet to be granted.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PSID  pOwnerSid = RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);
    PACL  pAcl      = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);
    BOOL  b         = TRUE;
    DWORD i         = 0;

    ASSERT(AUTHZ_NON_NULL_PTR(pAcl));

    b = AuthzpNormalAccessCheck(
            pCC,
            pSidAttr,
            SidCount,
            pSidHash,
            Remaining,
            pRequest,
            pAcl,
            pOwnerSid,
            LocalTypeList,
            LocalTypeListLength
            );

    if (!b)
    {
        return FALSE;
    }

    for (i = 0; i < OptionalSecurityDescriptorCount; i++)
    {
        pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) OptionalSecurityDescriptorArray[i]);

        if (!AUTHZ_NON_NULL_PTR(pAcl))
        {
            continue;
        }

        b = AuthzpNormalAccessCheck(
                pCC,
                pSidAttr,
                SidCount,
                pSidHash,
                Remaining,
                pRequest,
                pAcl,
                pOwnerSid,
                LocalTypeList,
                LocalTypeListLength
                );

        if (!b)
        {
            break;
        }
    }

    return b;
}


BOOL
AuthzpOwnerSidInClientContext(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PISECURITY_DESCRIPTOR pSecurityDescriptor
    )

/*++

Routine description:

    This routine determines if client context is the owner of the given object.

Arguments:

    pCC - Pointer to the client context.

    pSecurityDescriptor - To supply the owner sid for the object.

Return Value:

    A value of TRUE is returned if the owner sid in the security descriptor is
    present in the normal part (as well as the restricted part, if it exists).

--*/

{
    PSID pOwnerSid = RtlpOwnerAddrSecurityDescriptor(pSecurityDescriptor);
    BOOL b         = TRUE;

    //
    // Check if the sid exists in the normal part of the token.
    //

        b = AuthzpSidApplicable(
                pCC->SidCount,
                pCC->Sids,
                pCC->SidHash,
                pOwnerSid,
                NULL,
                NULL,
                FALSE,
                NULL
                );

    if (!b)
    {
        return FALSE;
    }

    //
    // If the token is restricted then the sid must exist in the restricted part
    // of the token.
    //

    if (AUTHZ_TOKEN_RESTRICTED(pCC))
    {

            b = AuthzpSidApplicable(
                    pCC->RestrictedSidCount,
                    pCC->RestrictedSids,
                    pCC->RestrictedSidHash,
                    pOwnerSid,
                    NULL,
                    NULL,
                    FALSE,
                    NULL
                    );

        return b;
    }

    return TRUE;
}

BOOL
AuthzpNormalAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN ACCESS_MASK Remaining,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    )

/*++

Routine description:

    This routine loops thru the acl till we are denied some access bit that the
    caller asked for or the acl is exhausted.

Arguments:

    pCC - Pointer to the client context.

    pSidAttr - Sids and attributes array to compare ace sids.

    SidCount - Number of elements in the array.

    Remaining - Access bits that are yet to be granted.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pAcl - Dacl against which the access check will be performed.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalCachingTypeList - Internal object type list structure used to hold
        intermediate results for static granted bits.

    LocalTypeListLength - Length of the array represnting the object.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD   i                     = 0;
    DWORD   AceCount              = 0;
    DWORD   Index                 = 0;
    DWORD   Ignore                = 0;
    PVOID   Ace                   = NULL;
    GUID  * ObjectTypeInAce       = NULL;
    BOOL    ObjectTypeListPresent = (0 != pRequest->ObjectTypeListLength);
    BOOL    bAceApplicable        = FALSE;

    for (i = 0; i < LocalTypeListLength; i++)
    {
        LocalTypeList[i].Remaining = Remaining;
    }

    AceCount = pAcl->AceCount;

    for (i = 0, Ace = FirstAce(pAcl); 
         (i < AceCount) && (LocalTypeList[0].Remaining != 0);
         i++, Ace = NextAce(Ace))
    {
        //
        // Skip INHERIT_ONLY aces.
        //

        if (FLAG_ON(((PACE_HEADER) Ace)->AceFlags, INHERIT_ONLY_ACE))
        {
            continue;
        }

        switch (((PACE_HEADER) Ace)->AceType)
        {

        case ACCESS_ALLOWED_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled. S-1-5-A is replaced by the principal sid
            // supplied by the caller. In future, Creator Owner will be replaced
            // by the owner sid in the primary security descriptor.
            //

                if (!AuthzpSidApplicable(
                        SidCount,
                        pSidAttr,
                        pSidHash,
                        AuthzAceSid(Ace),
                        pRequest->PrincipalSelfSid,
                        pOwnerSid,
                        FALSE,
                        &Ignore
                        ))
                {
                    break;
                }
            

#ifdef AUTHZ_DEBUG
            wprintf(L"Allowed access Mask = %x\n", ((PKNOWN_ACE) Ace)->Mask);
#endif

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Clear the granted bits from the remaining.
                //

                LocalTypeList->Remaining &= ~((PKNOWN_ACE) Ace)->Mask;
            }
            else
            {
                //
                // Clear off the granted bits from the remaining for the entire
                // tree.
                //

                AuthzpAddAccessTypeList(
                     LocalTypeList,
                     LocalTypeListLength,
                     0,
                     ((PKNOWN_ACE) Ace)->Mask,
                     AuthzUpdateRemaining
                     );
            }

            break;

        case ACCESS_ALLOWED_CALLBACK_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled. S-1-5-A is replaced by the principal sid
            // supplied by the caller. In future, Creator Owner will be replaced
            // by the owner sid in the primary security descriptor.
            //

                if (!AuthzpSidApplicable(
                        SidCount,
                        pSidAttr,
                        pSidHash,
                        AuthzAceSid(Ace),
                        pRequest->PrincipalSelfSid,
                        pOwnerSid,
                        FALSE,
                        &Ignore
                        ))
                {
                    break;
                }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Clear the granted bits from the remaining.
                //

                LocalTypeList->Remaining &= ~((PKNOWN_ACE) Ace)->Mask;
            }
            else
            {
                //
                // Clear off the granted bits from the remaining for the entire
                // tree.
                //

                AuthzpAddAccessTypeList(
                     LocalTypeList,
                     LocalTypeListLength,
                     0,
                     ((PKNOWN_ACE) Ace)->Mask,
                     AuthzUpdateRemaining
                     );
            }

            break;

        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

            if (!AUTHZ_NON_NULL_PTR(pCC->Server))
            {
                break;
            }

            if (!AuthzpSidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    RtlCompoundAceClientSid(Ace),
                    pRequest->PrincipalSelfSid,
                    pOwnerSid,
                    FALSE,
                    &Ignore
                    ) ||
                !AuthzpSidApplicable(
                        pCC->Server->SidCount,
                        pCC->Server->Sids,
                        pCC->Server->SidHash,
                        RtlCompoundAceServerSid(Ace),
                        NULL,
                        NULL,
                        FALSE,
                        &Ignore
                        ))
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Clear the granted bits from the remaining.
                //

                LocalTypeList->Remaining &= ~((PKNOWN_ACE) Ace)->Mask;
            }
            else
            {
                //
                // Clear off the granted bits from the remaining for the entire
                // tree.
                //

                AuthzpAddAccessTypeList(
                     LocalTypeList,
                     LocalTypeListLength,
                     0,
                     ((PCOMPOUND_ACCESS_ALLOWED_ACE) Ace)->Mask,
                     AuthzUpdateRemaining
                     );
            }

            break;

        case ACCESS_DENIED_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only. S-1-5-A is replaced by
            // the principal sid supplied by the caller. In future, Creator
            // Owner will be replaced by the owner sid in the primary security
            // descriptor.
            //

                if (!AuthzpSidApplicable(
                        SidCount,
                        pSidAttr,
                        pSidHash,
                        AuthzAceSid(Ace),
                        pRequest->PrincipalSelfSid,
                        pOwnerSid,
                        TRUE,
                        &Ignore
                        ))
                {
                    break;
                }

#ifdef AUTHZ_DEBUG
            wprintf(L"Allowed access Mask = %x\n", ((PKNOWN_ACE) Ace)->Mask);
#endif

            //
            // If any of the remaining bits are denied by this ace, exit early.
            //

            if (LocalTypeList->Remaining & ((PKNOWN_ACE) Ace)->Mask)
            {
                return TRUE;
            }

            break;

        case ACCESS_DENIED_CALLBACK_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only. S-1-5-A is replaced by
            // the principal sid supplied by the caller. In future, Creator
            // Owner will be replaced by the owner sid in the primary security
            // descriptor.
            //
                
                if (!AuthzpSidApplicable(
                        SidCount,
                        pSidAttr,
                        pSidHash,
                        AuthzCallbackAceSid(Ace),
                        pRequest->PrincipalSelfSid,
                        pOwnerSid,
                        TRUE,
                        &Ignore
                        ))
                {
                    break;
                }
            

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            //
            // If any of the remaining bits are denied by this ace, exit early.
            //

            if (LocalTypeList->Remaining & ((PKNOWN_ACE) Ace)->Mask)
            {
                return TRUE;
            }

            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            
            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            if ((ObjectTypeInAce) && (0 == pRequest->ObjectTypeListLength))
            {
                break;
            }

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled. S-1-5-A is replaced by the principal sid
            // supplied by the caller. In future, Creator Owner will be replaced
            // by the owner sid in the primary security descriptor.
            //

                if (!AuthzpSidApplicable(
                        SidCount,
                        pSidAttr,
                        pSidHash,
                        RtlObjectAceSid(Ace),
                        pRequest->PrincipalSelfSid,
                        pOwnerSid,
                        FALSE,
                        &Ignore
                        ))
                {
                    break;
                }
            
            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Clear the granted bits from the remaining.
                    //

                    LocalTypeList->Remaining &= ~((PKNOWN_OBJECT_ACE) Ace)->Mask;
                }
                else
                {
                    //
                    // Clear off the granted bits from the remaining for the entire
                    // tree.
                    //

                    AuthzpAddAccessTypeList(
                         LocalTypeList,
                         LocalTypeListLength,
                         0,
                         ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                         AuthzUpdateRemaining
                         );

                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        LocalTypeListLength,
                        &Index
                        )
                    )
                {
                    //
                    // Clear off the granted bits from the remaining for the
                    // subtree starting at the matched Index.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE)Ace)->Mask,
                        AuthzUpdateRemaining
                        );

                }
            }

           break;

        case ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled. S-1-5-A is replaced by the principal sid
            // supplied by the caller. In future, Creator Owner will be replaced
            // by the owner sid in the primary security descriptor.
            //

                if (!AuthzpSidApplicable(
                        SidCount,
                        pSidAttr,
                        pSidHash,
                        AuthzObjectAceSid(Ace),
                        pRequest->PrincipalSelfSid,
                        pOwnerSid,
                        FALSE,
                        &Ignore
                        ))
                {
                    break;
                }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Clear the granted bits from the remaining.
                    //

                    LocalTypeList->Remaining &= ~((PKNOWN_OBJECT_ACE) Ace)->Mask;
                }
                else
                {
                    //
                    // Clear off the granted bits from the remaining for the entire
                    // tree.
                    //

                    AuthzpAddAccessTypeList(
                         LocalTypeList,
                         LocalTypeListLength,
                         0,
                         ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                         AuthzUpdateRemaining
                         );
                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        LocalTypeListLength,
                        &Index
                        )
                    )
                {
                    //
                    // Clear off the granted bits from the remaining for the
                    // subtree starting at the matched Index.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE)Ace)->Mask,
                        AuthzUpdateRemaining
                        );
                }
            }

           break;

        case ACCESS_DENIED_OBJECT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only. S-1-5-A is replaced by
            // the principal sid supplied by the caller. In future, Creator
            // Owner will be replaced by the owner sid in the primary security
            // descriptor.
            //

                if (!AuthzpSidApplicable(
                        SidCount,
                        pSidAttr,
                        pSidHash,
                        AuthzObjectAceSid(Ace),
                        pRequest->PrincipalSelfSid,
                        pOwnerSid,
                        TRUE,
                        &Ignore
                        ))
                {
                    break;
                }
            
            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // If any of the remaining bits are denied by this ace, exit
                // early.
                //

                if (LocalTypeList->Remaining & ((PKNOWN_OBJECT_ACE) Ace)->Mask)
                {
                    return TRUE;
                }
            }

            //
            // Look for a matching object type guid that matches the one in
            // the ace.
            //

            if (AuthzpObjectInTypeList(
                    ObjectTypeInAce,
                    LocalTypeList,
                    LocalTypeListLength,
                    &Index
                    ))
            {
                //
                // If any of the remaining bits are denied by this ace, exit
                // early.
                //

                if (LocalTypeList[Index].Remaining & ((PKNOWN_OBJECT_ACE) Ace)->Mask)
                {
                    return TRUE;
                }
            }

            break;

        case ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only. S-1-5-A is replaced by
            // the principal sid supplied by the caller. In future, Creator
            // Owner will be replaced by the owner sid in the primary security
            // descriptor.
            //
                
            if (!AuthzpSidApplicable(
                        SidCount,
                        pSidAttr,
                        pSidHash,
                        AuthzObjectAceSid(Ace),
                        pRequest->PrincipalSelfSid,
                        pOwnerSid,
                        TRUE,
                        &Ignore
                        ))
                {
                    break;
                }
            
            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // If any of the remaining bits are denied by this ace, exit
                // early.
                //

                if (LocalTypeList->Remaining & ((PKNOWN_OBJECT_ACE) Ace)->Mask)
                {
                    return TRUE;
                }
            }

            //
            // Look for a matching object type guid that matches the one in
            // the ace.
            //

            if (AuthzpObjectInTypeList(
                    ObjectTypeInAce,
                    LocalTypeList,
                    LocalTypeListLength,
                    &Index
                    ))
            {
                //
                // If any of the remaining bits are denied by this ace, exit
                // early.
                //

                if (LocalTypeList[Index].Remaining & ((PKNOWN_OBJECT_ACE) Ace)->Mask)
                {
                    return TRUE;
                }
            }

            break;

        default:
            break;
        }
    }

    return TRUE;
}


BOOL
AuthzpQuickNormalAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZI_HANDLE pAH,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    )

/*++

Routine description:

    This routine calls AuthzpQuickNormalAccessCheck on regular part as well as
    restricted part (if it exists).

    Access granted = AccessGranted(Sids) [&& AccessGranted(RestrictedSids)
                                            for restricted tokens]

Arguments:

    pCC - Pointer to the client context.

    pAH - Pointer to the authz handle structure.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).
    pReply - The reply structure to return the results.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    BOOL        b         = TRUE;
    ACCESS_MASK Remaining = pRequest->DesiredAccess & ~pAH->GrantedAccessMask[0];

    //
    // Do the access check with the non-restricted part of the client context.
    //

    b = AuthzpAllowOnlyNormalMultipleSDAccessCheck(
            pCC,
            pCC->Sids,
            pCC->SidCount,
            pCC->SidHash,
            Remaining,
            pRequest,
            pAH->pSecurityDescriptor,
            pAH->OptionalSecurityDescriptorArray,
            pAH->OptionalSecurityDescriptorCount,
            LocalTypeList,
            LocalTypeListLength
            );

    if (!b)
    {
        return FALSE;
    }

    //
    // If some access bits were not granted then no access bits will be granted.
    //

    if (0 != LocalTypeList->Remaining)
    {
        AuthzpFillReplyStructure(
            pReply,
            ERROR_ACCESS_DENIED,
            0
            );

        SetLastError(ERROR_SUCCESS);
        return TRUE;
    }

    //
    // Do the access check with the restricted part of the client context if
    // it exists.
    //

    if (AUTHZ_TOKEN_RESTRICTED(pCC))
    {
        b = AuthzpAllowOnlyNormalMultipleSDAccessCheck(
                pCC,
                pCC->RestrictedSids,
                pCC->RestrictedSidCount,
                pCC->RestrictedSidHash,
                Remaining,
                pRequest,
                pAH->pSecurityDescriptor,
                pAH->OptionalSecurityDescriptorArray,
                pAH->OptionalSecurityDescriptorCount,
                LocalTypeList,
                LocalTypeListLength
                );

        if (!b)
        {
            return FALSE;
        }

        //
        // Make sure that all the bits are granted by the restricted part too.
        //

        if (0 != LocalTypeList->Remaining)
        {
            AuthzpFillReplyStructure(
                pReply,
                ERROR_ACCESS_DENIED,
                0
                );

            SetLastError(ERROR_SUCCESS);
            return TRUE;
        }
    }

    AuthzpFillReplyStructure(
        pReply,
        ERROR_SUCCESS,
        pRequest->DesiredAccess
        );

    return TRUE;
}


BOOL
AuthzpAllowOnlyNormalMultipleSDAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN ACCESS_MASK Remaining,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    )

/*++

Routine description:

    This routine loops thru all the security descriptors and calls
    AuthzpAllowOnlyNormalSingleAclAccessCheck.

Arguments:

    pCC - Pointer to the client context.

    pSidAttr - Sids and attributes array to compare ace sids.

    SidCount - Number of elements in the array.

    Remaining - Access bits that are yet to be granted.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PACL  pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);
    BOOL  b    = TRUE;
    DWORD i    = 0;

    ASSERT(AUTHZ_NON_NULL_PTR(pAcl));

    b = AuthzpAllowOnlyNormalSingleAclAccessCheck(
            pCC,
            pSidAttr,
            SidCount,
            pSidHash,
            Remaining,
            pRequest,
            pAcl,
            LocalTypeList,
            LocalTypeListLength
            );

    if (!b)
    {
        return FALSE;
    }

    for (i = 0; i < OptionalSecurityDescriptorCount; i++)
    {
        pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) OptionalSecurityDescriptorArray[i]);

        if (!AUTHZ_NON_NULL_PTR(pAcl))
        {
            return TRUE;
        }

        b = AuthzpAllowOnlyNormalSingleAclAccessCheck(
                pCC,
                pSidAttr,
                SidCount,
                pSidHash,
                Remaining,
                pRequest,
                pAcl,
                LocalTypeList,
                LocalTypeListLength
                );

        if (!b)
        {
            break;
        }
    }

    return b;
}


BOOL
AuthzpAllowOnlyNormalSingleAclAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN ACCESS_MASK Remaining,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    )

/*++

Routine description:

    This routine evaluates only those Grant aces that have principal self sid or
    are callback aces. Deny aces can not exist in the acl unless the resource
    manager messed up with the assumption and changed the security descriptors.

Arguments:

    pCC - Pointer to the client context.

    pSidAttr - Sids and attributes array to compare ace sids.

    SidCount - Number of elements in the array.

    Remaining - Access bits that are yet to be granted.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pAcl - Dacl against which the accesscheck will be preformed.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    BOOL    ObjectTypeListPresent = (0 != pRequest->ObjectTypeListLength);
    DWORD   i                     = 0;
    DWORD   Index                 = 0;
    DWORD   AceCount              = 0;
    GUID  * ObjectTypeInAce       = NULL;
    PVOID   Ace                   = NULL;
    PSID    pSid                  = NULL;
    BOOL    bAceApplicable        = FALSE;

    for (i = 0; i < LocalTypeListLength; i++)
    {
        LocalTypeList[i].Remaining = Remaining;
    }

    AceCount = pAcl->AceCount;

    for (i = 0, Ace = FirstAce(pAcl); i < AceCount; i++, Ace = NextAce(Ace))
    {
        //
        // Skip INHERIT_ONLY aces.
        //

        if (FLAG_ON(((PACE_HEADER) Ace)->AceFlags, INHERIT_ONLY_ACE))
        {
            continue;
        }

        switch (((PACE_HEADER) Ace)->AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:

            //
            // We have determined that only dynamic aces should be evaluated.
            // For non-callback aces, the dynamic factor arises from Principal
            // self sid. Skip the ace if the ace sid is not Principal Self sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(&((PKNOWN_ACE) Ace)->SidStart))
            {
                break;
            }

            //
            // Check if the caller supplied Principal self sid is present in the
            // client context and is enabled.
            //

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pRequest->PrincipalSelfSid
                    ))
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Clear the granted bits from the remaining.
                //

                LocalTypeList->Remaining &= ~((PKNOWN_ACE) Ace)->Mask;
            }
            else
            {
                //
                // Clear off the granted bits from the remaining for the entire
                // tree.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PKNOWN_ACE) Ace)->Mask,
                    AuthzUpdateRemaining
                    );
            }

            break;

        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

            if (!AUTHZ_NON_NULL_PTR(pCC->Server))
            {
                break;
            }

            //
            // We have determined that only dynamic aces should be evaluated.
            // For non-callback aces, the dynamic factor arises from Principal
            // self sid. Skip the ace if the ace sid is not Principal Self sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(RtlCompoundAceClientSid(Ace)))
            {
                break;
            }

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pRequest->PrincipalSelfSid
                    ) ||
                !AuthzpAllowOnlySidApplicable(
                        pCC->Server->SidCount,
                        pCC->Server->Sids,
                        pCC->Server->SidHash,
                        RtlCompoundAceServerSid(Ace)
                        ))
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Clear the granted bits from the remaining.
                //

                LocalTypeList->Remaining &= ~((PKNOWN_ACE) Ace)->Mask;
            }
            else
            {
                //
                // Clear off the granted bits from the remaining for the entire
                // tree.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PCOMPOUND_ACCESS_ALLOWED_ACE) Ace)->Mask,
                    AuthzUpdateRemaining
                    );
            }

            break;


        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

            //
            // We have determined that only dynamic aces should be evaluated.
            // For non-callback aces, the dynamic factor arises from Principal
            // self sid. Skip the ace if the ace sid is not Principal Self sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(RtlObjectAceSid(Ace)))
            {
                break;
            }

            //
            // Check if the caller supplied Principal self sid is present in the
            // client context and is enabled.
            //

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pRequest->PrincipalSelfSid
                    ))
            {
                break;
            }

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Grant access bits that have not already been denied.
                    //

                    LocalTypeList->CurrentGranted |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);
                }
                else
                {
                    //
                    // Propagate grant bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );
                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        LocalTypeListLength,
                        &Index
                        )
                    )
                {
                    //
                    // Clear off the granted bits from the remaining for the
                    // subtree starting at the matched Index.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );

                }
            }

           break;

        case ACCESS_ALLOWED_CALLBACK_ACE_TYPE:

            //
            // If the ace sid is Principal Self, replace it with the caller
            // supplied Principal sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(&(((PKNOWN_ACE) Ace)->SidStart)))
            {
                pSid = (PSID) &(((PKNOWN_ACE) Ace)->SidStart);
            }
            else
            {
                pSid = pRequest->PrincipalSelfSid;
            }

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled.
            //

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pSid
                    ))
            {
                break;
            }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Clear the granted bits from the remaining.
                //

                LocalTypeList->Remaining &= ~((PKNOWN_ACE) Ace)->Mask;
            }
            else
            {
                //
                // Clear off the granted bits from the remaining for the entire
                // tree.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PKNOWN_ACE) Ace)->Mask,
                    AuthzUpdateRemaining
                    );
            }

            break;

        case ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE:

            //
            // If the ace sid is Principal Self, replace it with the caller
            // supplied Principal sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(RtlObjectAceSid(Ace)))
            {
                pSid = RtlObjectAceSid(Ace);
            }
            else
            {
                pSid = pRequest->PrincipalSelfSid;
            }

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled.
            //

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pSid
                    ))
            {
                break;
            }

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Grant access bits that have not already been denied.
                    //

                    LocalTypeList->CurrentGranted |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);
                }
                else
                {
                    //
                    // Propagate grant bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );
                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        LocalTypeListLength,
                        &Index
                        )
                    )
                {
                    //
                    // Propagate grant bits down the tree starting at the
                    // index at which the guids matched.
                    // In the case when this is the last of the siblings to be
                    // granted access, the parent also is granted access.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );
                }
            }

           break;

        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
        case ACCESS_DENIED_CALLBACK_ACE_TYPE:
        case ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE:
            ASSERT(FALSE);
            break;
        default:
            break;
        }
    }

    return TRUE;
}


BOOL
AuthzpAllowOnlySidApplicable(
    IN DWORD SidCount,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN PSID pSid
    )

/*++

Routine description:

    This routine determine whether the given ace sid is present in the client
    context and is enabled.

Arguments:

    SidCount - Number of sids in the pSidAttrArray

    pSidAttr - Sid and attributes against which the ace sid should be compared.

    pAceSid - Sid in the ace.

Return Value:

    A value of TRUE is returned if the effective sid is found in the client
    context and is enabled.
    FALSE otherwise.

--*/

{
    DWORD i        = 0;
    DWORD SidLen   = 0;
    PISID MatchSid = NULL;

    UNREFERENCED_PARAMETER(pSidHash);

    if (!ARGUMENT_PRESENT(pSid))
    {
        return FALSE;
    }

    SidLen = RtlLengthSid(pSid);

    //
    // Loop thru the sids and return TRUE is a match is found and the sid
    // is enabled.
    //

    for (i = 0; i < SidCount; i++, pSidAttr++)
    {
        MatchSid = (PISID) pSidAttr->Sid;

        if (AUTHZ_EQUAL_SID(pSid, MatchSid, SidLen))
        {
            if (FLAG_ON(pSidAttr->Attributes, SE_GROUP_ENABLED))
            {
                return TRUE;
            }

            return FALSE;
        }
    }

    return FALSE;
}



BOOL
AuthzpQuickMaximumAllowedAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZI_HANDLE pAH,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength
    )

/*++

Routine description:

    This routine calls AuthzpQuickMaximumAllowedAccessCheck on normal part (as
    well as restricted part if it exists).

Arguments:

    pCC - Pointer to the client context.

    pAH - Pointer to the authz handle structure.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pReply - The reply structure to return the results.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    BOOL b                     = FALSE;
    BOOL ObjectTypeListPresent = (0 != pRequest->ObjectTypeListLength);

    UNREFERENCED_PARAMETER(pReply);

    //
    // Do the access check with the non-restricted part of the client context.
    //

    b = AuthzpAllowOnlyMaximumAllowedMultipleSDAccessCheck(
            pCC,
            pRequest,
            pAH->pSecurityDescriptor,
            pAH->OptionalSecurityDescriptorArray,
            pAH->OptionalSecurityDescriptorCount,
            LocalTypeList,
            LocalTypeListLength,
            ObjectTypeListPresent,
            FALSE
            );

    if (!b)
    {
        return FALSE;
    }

    //
    // Do the access check with the restricted part of the client context if
    // it exists.
    //

    if (AUTHZ_TOKEN_RESTRICTED(pCC))
    {
        b = AuthzpAllowOnlyMaximumAllowedMultipleSDAccessCheck(
                pCC,
                pRequest,
                pAH->pSecurityDescriptor,
                pAH->OptionalSecurityDescriptorArray,
                pAH->OptionalSecurityDescriptorCount,
                LocalTypeList,
                LocalTypeListLength,
                ObjectTypeListPresent,
                TRUE
                );
    }

    return b;
}


BOOL
AuthzpAllowOnlyMaximumAllowedMultipleSDAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount OPTIONAL,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent,
    IN BOOL Restricted
    )

/*++

Routine description:

    This routine call AuthzpAllowOnlyMaximumAllowedSingleAclAccessCheck for all
    given security descriptors.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

    ObjectTypeListPresent - Whether the called supplied an object type list.

    Restricted - Whether this is an access check on the restricted part of the
        client context.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD                  i               = 0;
    DWORD                  j               = 0;
    DWORD                  SidCount        = 0;
    BOOL                   b               = TRUE;
    PSID_AND_ATTRIBUTES    pSidAttr        = NULL;
    PACL                   pAcl            = NULL;
    PSID                   pOwnerSid       = RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);
    PAUTHZI_SID_HASH_ENTRY pSidHash        = NULL;

    if (Restricted)
    {
        //
        // Access granted is a bitwise AND of both (normal & restricted) part
        // of the client context.
        //

        for (j = 0; j < LocalTypeListLength; j++)
        {
            LocalTypeList[j].Remaining = LocalTypeList[j].CurrentGranted;
            LocalTypeList[j].CurrentGranted = 0;
        }

        pSidAttr = pCC->RestrictedSids;
        SidCount = pCC->RestrictedSidCount;
        pSidHash = pCC->RestrictedSidHash;
    }
    else
    {
        pSidAttr = pCC->Sids;
        SidCount = pCC->SidCount;
        pSidHash = pCC->SidHash;
    }

    pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);

    b = AuthzpAllowOnlyMaximumAllowedSingleAclAccessCheck(
            pCC,
            pSidAttr,
            SidCount,
            pSidHash,
            pRequest,
            pAcl,
            pOwnerSid,
            LocalTypeList,
            LocalTypeListLength,
            ObjectTypeListPresent
            );

    if (!b)
    {
        return FALSE;
    }

    for (i = 0; i < OptionalSecurityDescriptorCount; i++)
    {
        pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) OptionalSecurityDescriptorArray[i]);

        if (!AUTHZ_NON_NULL_PTR(pAcl))
        {
            continue;
        }

        b = AuthzpAllowOnlyMaximumAllowedSingleAclAccessCheck(
                pCC,
                pSidAttr,
                SidCount,
                pSidHash,
                pRequest,
                pAcl,
                pOwnerSid,
                LocalTypeList,
                LocalTypeListLength,
                ObjectTypeListPresent
                );

        if (!b)
        {
            break;
        }
    }

    return b;
}



BOOL
AuthzpAllowOnlyMaximumAllowedSingleAclAccessCheck(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PSID_AND_ATTRIBUTES pSidAttr,
    IN DWORD SidCount,
    IN PAUTHZI_SID_HASH_ENTRY pSidHash,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD LocalTypeListLength,
    IN BOOL ObjectTypeListPresent
    )

/*++

Routine description:

    This routine loops thru the entire acl and evaluates only those Grant aces
    that have principal self sid in them or are callback aces.

Arguments:

    pCC - Pointer to the client context.

    pSidAttr - Sids and attributes array to compare ace sids.

    SidCount - Number of elements in the array.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pAcl - Sacl to be used to make the decision about audit generation.

    pOwnerSid - The owner sid in the primary security descriptor. This will be
        needed after we implement single instancing.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

    ObjectTypeListPresent - Whether the called supplied an object type list.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD   AceCount        = 0;
    DWORD   i               = 0;
    DWORD   Index           = 0;
    PVOID   Ace             = NULL;
    GUID  * ObjectTypeInAce = NULL;
    BOOL    bAceApplicable  = FALSE;
    PSID    pSid            = NULL;

    UNREFERENCED_PARAMETER(pOwnerSid);

    AceCount = pAcl->AceCount;

    for (i = 0, Ace = FirstAce(pAcl); i < AceCount; i++, Ace = NextAce(Ace))
    {
        //
        // Skip INHERIT_ONLY aces.
        //

        if (FLAG_ON(((PACE_HEADER) Ace)->AceFlags, INHERIT_ONLY_ACE))
        {
            continue;
        }

        switch (((PACE_HEADER) Ace)->AceType)
        {

        case ACCESS_ALLOWED_ACE_TYPE:

            //
            // We have determined that only dynamic aces should be evaluated.
            // For non-callback aces, the dynamic factor arises from Principal
            // self sid. Skip the ace if the ace sid is not Principal Self sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(&((PKNOWN_ACE) Ace)->SidStart))
            {
                break;
            }

            //
            // Check if the caller supplied Principal self sid is present in the
            // client context and is enabled.
            //

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pRequest->PrincipalSelfSid
                    ))
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Grant access bits that have not already been denied.
                //

                LocalTypeList->CurrentGranted |= (((PKNOWN_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);
            }
            else
            {
                //
                // Propagate grant bits down the tree starting at the root.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PKNOWN_ACE) Ace)->Mask,
                    AuthzUpdateCurrentGranted
                    );
            }

            break;

        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

            if (!AUTHZ_NON_NULL_PTR(pCC->Server))
            {
                break;
            }

            //
            // We have determined that only dynamic aces should be evaluated.
            // For non-callback aces, the dynamic factor arises from Principal
            // self sid. Skip the ace if the ace sid is not Principal Self sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(RtlCompoundAceClientSid(Ace)))
            {
                break;
            }

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pRequest->PrincipalSelfSid
                    ) ||
                !AuthzpAllowOnlySidApplicable(
                        pCC->Server->SidCount,
                        pCC->Server->Sids,
                        pCC->Server->SidHash,
                        RtlCompoundAceServerSid(Ace)
                        ))
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Grant access bits that have not already been denied.
                //

                LocalTypeList->CurrentGranted |= (((PCOMPOUND_ACCESS_ALLOWED_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);
            }
            else
            {
                //
                // Propagate grant bits down the tree starting at the root.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PCOMPOUND_ACCESS_ALLOWED_ACE) Ace)->Mask,
                    AuthzUpdateCurrentGranted
                    );
            }

            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

            //
            // We have determined that only dynamic aces should be evaluated.
            // For non-callback aces, the dynamic factor arises from Principal
            // self sid. Skip the ace if the ace sid is not Principal Self sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(RtlObjectAceSid(Ace)))
            {
                break;
            }

            //
            // Check if the caller supplied Principal self sid is present in the
            // client context and is enabled.
            //

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pRequest->PrincipalSelfSid
                    ))
            {
                break;
            }

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Grant access bits that have not already been denied.
                    //

                    LocalTypeList->CurrentGranted |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);
                }
                else
                {
                    //
                    // Propagate grant bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );
                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        LocalTypeListLength,
                        &Index
                        )
                    )
                {
                    //
                    // Propagate grant bits down the tree starting at the
                    // index at which the guids matched.
                    // In the case when this is the last of the siblings to be
                    // granted access, the parent also is granted access.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );
                }
            }

           break;

        case ACCESS_ALLOWED_CALLBACK_ACE_TYPE:

            //
            // If the ace sid is Principal Self, replace it with the caller
            // supplied Principal sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(&((PKNOWN_ACE) Ace)->SidStart))
            {
                pSid = (PSID) &(((PKNOWN_ACE) Ace)->SidStart);
            }
            else
            {
                pSid = pRequest->PrincipalSelfSid;
            }

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled.
            //

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pSid
                    ))
            {
                break;
            }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            //
            // Optimize the common case instead of calling a subroutine.
            //

            if (1 == LocalTypeListLength)
            {
                //
                // Clear the granted bits from the remaining.
                //

                LocalTypeList->Remaining &= ~((PKNOWN_ACE) Ace)->Mask;
            }
            else
            {
                //
                // Propagate grant bits down the tree starting at the root.
                //

                AuthzpAddAccessTypeList(
                    LocalTypeList,
                    LocalTypeListLength,
                    0,
                    ((PKNOWN_ACE) Ace)->Mask,
                    AuthzUpdateCurrentGranted
                    );
            }

            break;

        case ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE:

            //
            // If the ace sid is Principal Self, replace it with the caller
            // supplied Principal sid.
            //

            if (!AUTHZ_IS_PRINCIPAL_SELF_SID(RtlObjectAceSid(Ace)))
            {
                pSid = RtlObjectAceSid(Ace);
            }
            else
            {
                pSid = pRequest->PrincipalSelfSid;
            }

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled.
            //

            if (!AuthzpAllowOnlySidApplicable(
                    SidCount,
                    pSidAttr,
                    pSidHash,
                    pSid
                    ))
            {
                break;
            }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            //
            // An object type ace with a NULL Object Type guid is the same as a
            // normal ace.
            //

            if (!AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // Optimize the common case instead of calling a subroutine.
                //

                if (1 == LocalTypeListLength)
                {
                    //
                    // Grant access bits that have not already been denied.
                    //

                    LocalTypeList->CurrentGranted |= (((PKNOWN_OBJECT_ACE) Ace)->Mask & ~LocalTypeList->CurrentDenied);
                }
                else
                {
                    //
                    // Propagate grant bits down the tree starting at the root.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        0,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );
                }
            }

            //
            // So, it is a true object type ace. Proceed only if we are doing
            // access check on a object type list.
            //

            else if (ObjectTypeListPresent)
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        LocalTypeListLength,
                        &Index
                        )
                    )
                {
                    //
                    // Propagate grant bits down the tree starting at the
                    // index at which the guids matched.
                    // In the case when this is the last of the siblings to be
                    // granted access, the parent also is granted access.
                    //

                    AuthzpAddAccessTypeList(
                        LocalTypeList,
                        LocalTypeListLength,
                        Index,
                        ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                        AuthzUpdateCurrentGranted
                        );
                }
            }

           break;

        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
        case ACCESS_DENIED_CALLBACK_ACE_TYPE:
        case ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE:
            ASSERT(FALSE);
            break;

        default:
            break;
        }
    }

    return TRUE;
}


BOOL
AuthzpObjectInTypeList (
    IN GUID *ObjectType,
    IN PIOBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeListLength,
    OUT PDWORD ReturnedIndex
    )

/*++

Routine description:

    This routine searches an ObjectTypeList to determine if the specified object
    type is in the list. It returns the index of the node if a match is found.

Arguments:

    ObjectType - Object Type guid to search for.

    ObjectTypeList - The object type list to search in.

    ObjectTypeListLength - Number of elements in ObjectTypeList.

    ReturnedIndex - Index to the element ObjectType was found in.


Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD   Index           = 0;
    GUID  * LocalObjectType = NULL;

    for (Index = 0; Index < ObjectTypeListLength; Index++)
    {
        LocalObjectType = &ObjectTypeList[Index].ObjectType;

        if (RtlpIsEqualGuid(ObjectType, LocalObjectType))
        {
            *ReturnedIndex = Index;
            return TRUE;
        }
    }

    return FALSE;
}


VOID
AuthzpUpdateParentTypeList(
    IN OUT PIOBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeListLength,
    IN DWORD StartIndex
    )

/*++

    This routine updates the Access fields of the parent object of the specified
    object.

        The "remaining" field of a parent object is the logical OR of
        the remaining field of all of its children.

        The CurrentGranted field of the parent is the collection of bits
        granted to every one of its children..

        The CurrentDenied fields of the parent is the logical OR of
        the bits denied to any of its children.

    This routine takes an index to one of the children and updates the
    remaining field of the parent (and grandparents recursively).

Arguments:

    ObjectTypeList - The object type list to update.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    StartIndex - Index to the "child" element whose parents are to be updated.

Return Value:

    None.

--*/

{
    DWORD       Index             = 0;
    DWORD       ParentIndex       = 0;
    DWORD       Level             = 0;
    ACCESS_MASK NewRemaining      = 0;
    ACCESS_MASK NewCurrentDenied  = 0;
    ACCESS_MASK NewCurrentGranted = 0xFFFFFFFF;

    //
    // If the target node is at the root,
    //  we're all done.
    //

    if (-1 == ObjectTypeList[StartIndex].ParentIndex)
    {
        return;
    }

    //
    // Get the index to the parent that needs updating and the level of
    // the siblings.
    //

    ParentIndex = ObjectTypeList[StartIndex].ParentIndex;
    Level = ObjectTypeList[StartIndex].Level;

    //
    // Loop through all the children.
    //

    for (Index = ParentIndex + 1; Index < ObjectTypeListLength; Index++)
    {

        //
        // By definition, the children of an object are all those entries
        // immediately following the target.  The list of children (or
        // grandchildren) stops as soon as we reach an entry the has the
        // same level as the target (a sibling) or lower than the target
        // (an uncle).
        //

        if (ObjectTypeList[Index].Level <= ObjectTypeList[ParentIndex].Level)
        {
            break;
        }

        //
        // Only handle direct children of the parent.
        //

        if (ObjectTypeList[Index].Level != Level)
        {
            continue;
        }

        //
        // Compute the new bits for the parent.
        //

        NewRemaining |= ObjectTypeList[Index].Remaining;
        NewCurrentGranted &= ObjectTypeList[Index].CurrentGranted;
        NewCurrentDenied |= ObjectTypeList[Index].CurrentDenied;

    }

    //
    // If we've not changed the access to the parent,
    //  we're done.
    //

    if ((NewRemaining == ObjectTypeList[ParentIndex].Remaining) &&
        (NewCurrentGranted == ObjectTypeList[ParentIndex].CurrentGranted) &&
        (NewCurrentDenied == ObjectTypeList[ParentIndex].CurrentDenied))
    {
        return;
    }


    //
    // Change the parent.
    //

    ObjectTypeList[ParentIndex].Remaining = NewRemaining;
    ObjectTypeList[ParentIndex].CurrentGranted = NewCurrentGranted;
    ObjectTypeList[ParentIndex].CurrentDenied = NewCurrentDenied;

    //
    // Go update the grand parents.
    //

    AuthzpUpdateParentTypeList(
        ObjectTypeList,
        ObjectTypeListLength,
        ParentIndex
        );
}


VOID
AuthzpAddAccessTypeList (
    IN OUT PIOBJECT_TYPE_LIST ObjectTypeList,
    IN DWORD ObjectTypeListLength,
    IN DWORD StartIndex,
    IN ACCESS_MASK AccessMask,
    IN ACCESS_MASK_FIELD_TO_UPDATE FieldToUpdate
    )

/*++

Routine Description:

    This routine grants the specified AccessMask to all of the objects that
    are descendents of the object specified by StartIndex.

    The Access fields of the parent objects are also recomputed as needed.

    For example, if an ACE granting access to a Property Set is found,
        that access is granted to all the Properties in the Property Set.

Arguments:

    ObjectTypeList - The object type list to update.

    ObjectTypeListLength - Number of elements in ObjectTypeList

    StartIndex - Index to the target element to update.

    AccessMask - Mask of access to grant to the target element and
        all of its decendents

    FieldToUpdate - Indicate which fields to update in object type list

Updation cases:

                             A
                            / \
                           /   \
                          B     E
                         / \   / \
                        C   D F   G

    Consider an object type list of length 7, with two property sets, each with
    two properties. In array form this is represented as
    {(A, 0), (B, 1), (C, 2), (D, 2), (E, 1), (F, 2), (G, 2)}

    The following diagrams explain access granted/denied at each node.

    Access may be granted because of one (or more) of the following reasons:
        a  = Access granted by an ace on the node
        ca = Access granted by ORing of the children
        pa = Access granted by an ancestor

    Access may be denied because of one (or more) of the following reasons.

        d  = Access explicitly denied by an ace on the node
        cd = Access explicitly denied by child, grandchild, etc
        pd = Access explicitly denied by an ancestor
        id = Access implicitly denied because no ace was applicable

       case 1:                case 2:                case 3:
           Deny D                 Deny B                 Grant B
           Grant A                Grant E                Grant F
                                  Grant D                Grant G

            cd                      cd                     ca
            / \                    / \                   / \
           /   \                  /   \                 /   \
         cd    pa                d     a               a     ca
         / \   / \             / \   / \             / \   / \
       pa   d pa  pa         pd  pd pa  pa         pa  pa a   a


       case 4:                case 5:                case 6:
           Grant A                Grant C                Grant B
           Deny  B                Grant D                Grant F
           Deny  F                Grant F
                                  Grant G
                                  Deny  A

             a                      ca                    id
            / \                    / \                   / \
           /   \                  /   \           bf154a58      /   \
         pa    pa               ca    ca               a     id
         / \   / \             / \   / \             / \   / \
       pa  pa pa  pa          a   a a   a          pa  pa a   id

Return Value:

    None.

--*/

{
    DWORD Index;
    ACCESS_MASK OldRemaining;
    ACCESS_MASK OldCurrentGranted;
    ACCESS_MASK OldCurrentDenied;
    BOOL AvoidParent = FALSE;

    //
    // Update the requested field.
    //
    // Always handle the target entry.
    //
    // If we've not actually changed the bits, early out.
    //

    switch (FieldToUpdate)
    {
    case AuthzUpdateRemaining:

        OldRemaining = ObjectTypeList[StartIndex].Remaining;
        ObjectTypeList[StartIndex].Remaining = OldRemaining & ~AccessMask;

        if (OldRemaining == ObjectTypeList[StartIndex].Remaining)
        {
            return;
        }

        break;

    case AuthzUpdateCurrentGranted:

        OldCurrentGranted = ObjectTypeList[StartIndex].CurrentGranted;
        ObjectTypeList[StartIndex].CurrentGranted |=
            AccessMask & ~ObjectTypeList[StartIndex].CurrentDenied;

        if (OldCurrentGranted == ObjectTypeList[StartIndex].CurrentGranted)
        {

            //
            // We can't simply return here.
            // We have to visit our children.  Consider the case where there
            // was a previous deny ACE on a child.  That deny would have
            // propagated up the tree to this entry.  However, this allow ACE
            // needs to be added all of the children that haven't been
            // explictly denied.
            //

            AvoidParent = TRUE;
        }

        break;

    case AuthzUpdateCurrentDenied:

        OldCurrentDenied = ObjectTypeList[StartIndex].CurrentDenied;
        ObjectTypeList[StartIndex].CurrentDenied |=
            AccessMask & ~ObjectTypeList[StartIndex].CurrentGranted;

        if (OldCurrentDenied == ObjectTypeList[StartIndex].CurrentDenied)
        {
            return;
        }

        break;

    default:
        return;
    }


    //
    // Go update parent of the target.
    //

    if (!AvoidParent)
    {
        AuthzpUpdateParentTypeList(
            ObjectTypeList,
            ObjectTypeListLength,
            StartIndex
            );
    }

    //
    // Loop handling all children of the target.
    //

    for (Index = StartIndex + 1; Index < ObjectTypeListLength; Index++)
    {

        //
        // By definition, the children of an object are all those entries
        // immediately following the target.  The list of children (or
        // grandchildren) stops as soon as we reach an entry the has the
        // same level as the target (a sibling) or lower than the target
        // (an uncle).
        //

        if (ObjectTypeList[Index].Level <= ObjectTypeList[StartIndex].Level)
        {
            break;
        }

        //
        // Grant access to the children
        //

        switch (FieldToUpdate)
        {
        case AuthzUpdateRemaining:

            ObjectTypeList[Index].Remaining &= ~AccessMask;

            break;

        case AuthzUpdateCurrentGranted:

            ObjectTypeList[Index].CurrentGranted |=
                AccessMask & ~ObjectTypeList[Index].CurrentDenied;

            break;

        case AuthzUpdateCurrentDenied:

            ObjectTypeList[Index].CurrentDenied |=
                AccessMask & ~ObjectTypeList[Index].CurrentGranted;

            break;

        default:
            return;
        }
    }
}


BOOL
AuthzpCacheResults(
    IN DWORD Flags,
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PIOBJECT_TYPE_LIST LocalCachingTypeList,
    IN DWORD LocalTypeListLength,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN DWORD CachingFlags,
    OUT PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE phAccessCheckResults
    )

/*++

Routine description:

    This routine allocates a handle node, stores the results of static access
    check in it and inserts it into the list of handles.

Arguments:

    pCC - Pointer to the client context.

    LocalCachingTypeList - Internal object type list structure used to hold
        intermediate results for static granted bits.

    LocalTypeListLength - Length of the array represnting the object.

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    CachingFlags - Flags that will be stored in the caching handle.

    phAccessCheckResults - To return the newly allocated handle.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD          i            = 0;
    DWORD          Size         = 0;
    DWORD          SDSize       = 0;
    DWORD          SDArraySize  = 0;
    ULONG          LengthNeeded = 0;
    PAUTHZI_HANDLE pHandle      = NULL;
    NTSTATUS       Status       = STATUS_SUCCESS;
    PUCHAR         pWrite       = NULL;
    BOOL           b            = TRUE;

    Size = PtrAlignSize((LocalTypeListLength - 1) * sizeof(ACCESS_MASK) + sizeof(AUTHZI_HANDLE));

    //
    // If we are going to copy the SDs we will need some space for the pointers.
    //

    if (!FLAG_ON(Flags, AUTHZ_ACCESS_CHECK_NO_DEEP_COPY_SD))
    {
        SDSize      = PtrAlignSize(RtlLengthSecurityDescriptor(pSecurityDescriptor));
        SDArraySize = PtrAlignSize(sizeof(ULONG_PTR) * OptionalSecurityDescriptorCount);
        
        for (i = 0; i < OptionalSecurityDescriptorCount; i++)
        {
            SDArraySize += PtrAlignSize(RtlLengthSecurityDescriptor(OptionalSecurityDescriptorArray[i]));
        }
    }

    pHandle = (PAUTHZI_HANDLE) AuthzpAlloc(Size + SDSize + SDArraySize);

    if (AUTHZ_ALLOCATION_FAILED(pHandle))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    if (FLAG_ON(Flags, AUTHZ_ACCESS_CHECK_NO_DEEP_COPY_SD))
    {
        pHandle->pSecurityDescriptor             = pSecurityDescriptor;
        pHandle->OptionalSecurityDescriptorArray = OptionalSecurityDescriptorArray;
    }
    else
    {
        //
        // Put the primary SD immediately after the pHandle
        //

        pWrite                       = ((PUCHAR)pHandle + Size);
        pHandle->pSecurityDescriptor = (PSECURITY_DESCRIPTOR) pWrite;
        
        LengthNeeded = SDSize;

        Status = RtlMakeSelfRelativeSD(
                     pSecurityDescriptor,
                     pHandle->pSecurityDescriptor,
                     &LengthNeeded
                     );

        ASSERT(NT_SUCCESS(Status));

        if (!NT_SUCCESS(Status))
        {
            b = FALSE;
            goto Cleanup;
        }

        pWrite += PtrAlignSize(LengthNeeded);

        //
        // After the primary SD we put the Optional SD array
        //

        if (OptionalSecurityDescriptorCount == 0)
        {
            pHandle->OptionalSecurityDescriptorArray = NULL;
        }
        else 
        {
            pHandle->OptionalSecurityDescriptorArray = (PSECURITY_DESCRIPTOR *) pWrite;
            pWrite += (sizeof(ULONG_PTR) * OptionalSecurityDescriptorCount);

            for (i = 0; i < OptionalSecurityDescriptorCount; i++)
            {
                //
                // After the array put in each optional SD, and point an array element at the SD
                //

                pHandle->OptionalSecurityDescriptorArray[i] = pWrite;

                LengthNeeded = PtrAlignSize(RtlLengthSecurityDescriptor(OptionalSecurityDescriptorArray[i]));

                Status = RtlMakeSelfRelativeSD(
                             OptionalSecurityDescriptorArray[i],
                             pHandle->OptionalSecurityDescriptorArray[i],
                             &LengthNeeded
                             );

                ASSERT(NT_SUCCESS(Status));

                if (!NT_SUCCESS(Status))
                {
                    b = FALSE;
                    goto Cleanup;
                }
                
                pWrite += PtrAlignSize(LengthNeeded);
            }
        }
    }

    ASSERT(((PUCHAR)pHandle + Size + SDSize + SDArraySize) == pWrite);

    pHandle->Flags                           = CachingFlags;
    pHandle->pAuthzClientContext             = pCC;
    pHandle->ResultListLength                = LocalTypeListLength;
    pHandle->OptionalSecurityDescriptorCount = OptionalSecurityDescriptorCount;

    //
    // Store the static access check results in the handle.
    //

    for (i = 0; i < LocalTypeListLength; i++)
    {
        pHandle->GrantedAccessMask[i] = LocalCachingTypeList[i].CurrentGranted;
    }

    AuthzpAcquireClientCacheWriteLock(pCC);

    pHandle->next = pCC->AuthzHandleHead;
    pCC->AuthzHandleHead = pHandle;

    AuthzpReleaseClientCacheLock(pCC);

    *phAccessCheckResults = (AUTHZ_ACCESS_CHECK_RESULTS_HANDLE) pHandle;

Cleanup:
    
    if (!b)
    {
        AuthzpFreeNonNull(pHandle);
        SetLastError(RtlNtStatusToDosError(Status));
    }
    return b;
}


BOOL
AuthzpDefaultAccessCheck(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
    IN PACE_HEADER pAce,
    IN PVOID pArgs OPTIONAL,
    IN OUT PBOOL pbAceApplicable
    )

/*++

Routine description:

    This routine is the default function to be used for callback aces if none
    has been specified by the resource manager.

    Returns AceApplicable = TRUE for DENY aces.
                            FALSE for Grant and audit aces.

Arguments:
    Ignores all arguments other than pAce->AceType.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{

    UNREFERENCED_PARAMETER(pArgs);
    UNREFERENCED_PARAMETER(pAuthzClientContext);

    switch (pAce->AceType)
    {
    case ACCESS_ALLOWED_CALLBACK_ACE_TYPE:
    case ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_CALLBACK_ACE_TYPE:
    case SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE:

        *pbAceApplicable = FALSE;

        break;

    case ACCESS_DENIED_CALLBACK_ACE_TYPE:
    case ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE:

        *pbAceApplicable = TRUE;

        break;

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return TRUE;
}


BOOL
AuthzpGenerateAudit(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PAUTHZI_AUDIT_EVENT pAuditEvent,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList
    )

/*++

Routine description:

    This routine decides whether an audit needs to be generated. It is called
    at the end of the access check.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pAuditEvent - Audit info to be in case we decide to generate an audit.

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    pReply - The reply structure holding the results of the access check.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    BOOL b                     = FALSE;
    BOOL bGenerateAudit        = FALSE;
    BOOL bGenerateSuccessAudit = FALSE;
    BOOL bGenerateFailureAudit = FALSE;

    //
    // if the caller is interested in the whole object
    //     generate a normal audit
    // else
    //     generate an audit for the entire tree - DS style
    //

    if ((1 == pReply->ResultListLength) && (NULL == pRequest->ObjectTypeList))
    {
        b = AuthzpExamineSacl(
                pCC,
                pRequest,
                pSecurityDescriptor,
                OptionalSecurityDescriptorArray,
                OptionalSecurityDescriptorCount,
                pReply,
                &bGenerateAudit
                );

        if (!b)
        {
            return FALSE;
        }

        if (bGenerateAudit)
        {
            if (ERROR_SUCCESS == pReply->Error[0])
            {
                LocalTypeList->Flags |= AUTHZ_OBJECT_SUCCESS_AUDIT;
                
                b = AuthzpCreateAndLogAudit(
                        AUTHZ_OBJECT_SUCCESS_AUDIT,
                        pCC,
                        pAuditEvent,
                        (PAUTHZI_RESOURCE_MANAGER)pCC->pResourceManager,
                        LocalTypeList,
                        pRequest,
                        pReply
                        );
                ASSERT(b && L"AuthzpCreateAndLogAudit did not succeed.");
            }
            else
            {
                LocalTypeList->Flags |= AUTHZ_OBJECT_FAILURE_AUDIT;
                
                b = AuthzpCreateAndLogAudit(
                        AUTHZ_OBJECT_FAILURE_AUDIT,
                        pCC,
                        pAuditEvent,
                        (PAUTHZI_RESOURCE_MANAGER)pCC->pResourceManager,
                        LocalTypeList,
                        pRequest,
                        pReply
                        );
                ASSERT(b && L"AuthzpCreateAndLogAudit did not succeed.");
            }
        }
    }
    else
    {
        b = AuthzpExamineSaclForObjectTypeList(
                pCC,
                pRequest,
                pSecurityDescriptor,
                OptionalSecurityDescriptorArray,
                OptionalSecurityDescriptorCount,
                pReply,
                LocalTypeList,
                &bGenerateSuccessAudit,
                &bGenerateFailureAudit
                );

        if (!b)
        {
            return FALSE;
        }

        if (bGenerateSuccessAudit)
        {
            b = AuthzpCreateAndLogAudit(
                    AUTHZ_OBJECT_SUCCESS_AUDIT,
                    pCC,
                    pAuditEvent,
                    (PAUTHZI_RESOURCE_MANAGER)pCC->pResourceManager,
                    LocalTypeList,
                    pRequest,
                    pReply
                    );
            ASSERT(b);
        }
        if (bGenerateFailureAudit)
        {
            b = AuthzpCreateAndLogAudit(
                    AUTHZ_OBJECT_FAILURE_AUDIT,
                    pCC,
                    pAuditEvent,
                    (PAUTHZI_RESOURCE_MANAGER)pCC->pResourceManager,
                    LocalTypeList,
                    pRequest,
                    pReply
                    );
            ASSERT(b);
        }
    }

    return b;
}



BOOL
AuthzpExamineSacl(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN PAUTHZ_ACCESS_REPLY pReply,
    OUT PBOOL pbGenerateAudit
    )

/*++

Routine description:

    This routine loops thru the entire list of security descriptors and call
    AuthzpExamineSingleSacl for each security descriptor.

    Called in one of the following cases:
        - the caller has not passed in an object type list
        - the caller has passed in an object type list and asked for access at
          the root of the tree instead of the whole tree.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    pReply - The reply structure holding the results of the access check.

    pbGenerateAudit - To return whether an audit needs to be generated.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PACL        pAcl              = NULL;
    PSID        pOwnerSid         = NULL;
    BOOL        b                 = FALSE;
    BOOL        bMaximumFailed    = FALSE;
    UCHAR       AuditMaskType     = SUCCESSFUL_ACCESS_ACE_FLAG;
    ACCESS_MASK AccessMask        = 0;
    DWORD       i                 = 0;

    if (0 == pReply->GrantedAccessMask[0])
    {
        AuditMaskType = FAILED_ACCESS_ACE_FLAG;

        if (FLAG_ON(pRequest->DesiredAccess, MAXIMUM_ALLOWED))
        {
            bMaximumFailed = TRUE;
        }

        AccessMask = pRequest->DesiredAccess;
    }
    else
    {
        AccessMask = pReply->GrantedAccessMask[0];
    }

    pAcl = RtlpSaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);
    pOwnerSid = RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);

    b = AuthzpExamineSingleSacl(
            pCC,
            pRequest,
            AccessMask,
            pAcl,
            pOwnerSid,
            AuditMaskType,
            bMaximumFailed,
            pReply,
            pbGenerateAudit
            );

    if (!b)
    {
        return FALSE;
    }

    for (i = 0; (i < OptionalSecurityDescriptorCount) && (!*pbGenerateAudit); i++)
    {
        pAcl = RtlpSaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) OptionalSecurityDescriptorArray[i]);

        b = AuthzpExamineSingleSacl(
                pCC,
                pRequest,
                AccessMask,
                pAcl,
                pOwnerSid,
                AuditMaskType,
                bMaximumFailed,
                pReply,
                pbGenerateAudit
                );

        if (!b)
        {
            break;
        }
    }

    return b;
}


BOOL
AuthzpExamineSingleSacl(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN ACCESS_MASK AccessMask,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN UCHAR AuditMaskType,
    IN BOOL bMaximumFailed,
    OUT PAUTHZ_ACCESS_REPLY pReply,
    OUT PBOOL pbGenerateAudit
    )

/*++

Routine description:

    This routine walk the sacl till we hit an ace that is applicable for the
    access check result.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list structure (if any).

    AccessMask - Desired access mask in case of failure,
                 Granted access mask in case of success

    pAcl - The sacl against which granted/desired access bits will be matched

    pOwnerSid - Need for single instance work later on

    pReply - Results of the access check.

    AuditMaskType - SUCCESSFUL_ACCESS_ACE_FLAG if access check succeeded
                    FAILED_ACCESS_ACE_FLAG otherwise

    bMaximumFailed - Whether the caller asked for MaximumAllowed and access
        check failed

    pbGenerateAudit - To return whether an audit should be generated

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD   AceCount          = 0;
    DWORD   i                 = 0;
    PVOID   Ace               = NULL;
    BOOL    bAceApplicable    = FALSE;
    DWORD   Ignore            = 0;

    //
    // Ignore NULL as well as Empty sacls.
    //

    if ((!ARGUMENT_PRESENT(pAcl)) || (0 == (AceCount = pAcl->AceCount)))
    {
        return TRUE;
    }

    for (i = 0, Ace = FirstAce(pAcl); i < AceCount; i++, Ace = NextAce(Ace))
    {
        //
        // We are not interested in the ace if one of the following is true
        //     - inherit only ace
        //     - AuditMaskType does not match
        //     - AccessMask has no matching bits with the Mask in the acl and
        //       we are not looking for a MaximumAllowed failure audit
        //

        if (FLAG_ON(((PACE_HEADER) Ace)->AceFlags, INHERIT_ONLY_ACE) ||
            !FLAG_ON(((PACE_HEADER) Ace)->AceFlags, AuditMaskType) ||
            (!FLAG_ON(((PKNOWN_ACE) Ace)->Mask, AccessMask) && !bMaximumFailed))
        {
            continue;
        }

        switch(((PACE_HEADER) Ace)->AceType)
        {
        case SYSTEM_AUDIT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only if FAILED_ACCESS_ACE_FLAG
            // is on. S-1-5-A is replaced by the principal sid supplied by the
            // caller. In future, Creator Owner will be replaced by the owner
            // sid in the primary security descriptor.
            //

                bAceApplicable = AuthzpSidApplicable(
                                     pCC->SidCount,
                                     pCC->Sids,
                                     pCC->SidHash,
                                     AuthzAceSid(Ace),
                                     pRequest->PrincipalSelfSid,
                                     pOwnerSid,
                                     FLAG_ON(((PACE_HEADER) Ace)->AceFlags, FAILED_ACCESS_ACE_FLAG),
                                     &Ignore
                                     );

            if (!bAceApplicable)
            {
                break;
            }

            *pbGenerateAudit = TRUE;
            if (NULL != pReply->SaclEvaluationResults)
            {
                pReply->SaclEvaluationResults[0] |= 
                    (pReply->Error[0] == ERROR_SUCCESS ? AUTHZ_GENERATE_SUCCESS_AUDIT : AUTHZ_GENERATE_FAILURE_AUDIT);
            }

            return TRUE;

        case SYSTEM_AUDIT_CALLBACK_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only if FAILED_ACCESS_ACE_FLAG
            // is on. S-1-5-A is replaced by the principal sid supplied by the
            // caller. In future, Creator Owner will be replaced by the owner
            // sid in the primary security descriptor.
            //

                bAceApplicable = AuthzpSidApplicable(
                                     pCC->SidCount,
                                     pCC->Sids,
                                     pCC->SidHash,
                                     AuthzCallbackAceSid(Ace),
                                     pRequest->PrincipalSelfSid,
                                     pOwnerSid,
                                     FLAG_ON(((PACE_HEADER) Ace)->AceFlags, FAILED_ACCESS_ACE_FLAG),
                                     &Ignore
                                     );

            if (!bAceApplicable)
            {
                break;
            }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            *pbGenerateAudit = TRUE;
            if (NULL != pReply->SaclEvaluationResults)
            {
                pReply->SaclEvaluationResults[0] |= 
                    (pReply->Error[0] == ERROR_SUCCESS ? AUTHZ_GENERATE_SUCCESS_AUDIT : AUTHZ_GENERATE_FAILURE_AUDIT);
            }

            return TRUE;

        default:
            break;
        }
    }

    return TRUE;
}


BOOL
AuthzpExamineSaclForObjectTypeList(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    OUT PBOOL pbGenerateSuccessAudit,
    OUT PBOOL pbGenerateFailureAudit
    )

/*++

Routine description:

    This routine walks thru the entire list of security descriptors and calls
    AuthzpExamineSingleSaclForObjectTypeList for each security descriptor.
    Called when an object type list is passed and the caller has asked for
    the results at each node.

Arguments:

    pCC - Pointer to the client context.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pSecurityDescriptor - Primary security descriptor to be used for access
        checks. The owner sid for the object is picked from this one. A NULL
        DACL in this security descriptor represents a NULL DACL for the entire
        object. A NULL SACL in this security descriptor is treated the same way
        as an EMPTY SACL.

    OptionalSecurityDescriptorArray - The caller may optionally specify a list
        of security descriptors. NULL ACLs in these security descriptors are
        treated as EMPTY ACLS and the ACL for the entire object is the logical
        concatenation of all the ACLs.

    OptionalSecurityDescriptorCount - Number of optional security descriptors
        This does not include the Primary security descriptor.

    pReply - The reply structure to return the results.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    LocalTypeListLength - Length of the array represnting the object.

    pbGenerateSuccessAudit - Returns whether a success audit should be
        generated.

    pbGenerateFailureAudit - Returns whether a failure audit should be
        generated.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    PACL  pAcl      = NULL;
    PSID  pOwnerSid = NULL;
    BOOL  b         = FALSE;
    DWORD i         = 0;

    pAcl = RtlpSaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);
    pOwnerSid = RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSecurityDescriptor);

    b = AuthzpExamineSingleSaclForObjectTypeList(
            pCC,
            pRequest,
            pAcl,
            pOwnerSid,
            pReply,
            LocalTypeList,
            pbGenerateSuccessAudit,
            pbGenerateFailureAudit
            );

    if (!b)
    {
        return FALSE;
    }

    for (i = 0; i < OptionalSecurityDescriptorCount; i++)
    {
        pAcl = RtlpSaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) OptionalSecurityDescriptorArray[i]);

        b = AuthzpExamineSingleSaclForObjectTypeList(
                pCC,
                pRequest,
                pAcl,
                pOwnerSid,
                pReply,
                LocalTypeList,
                pbGenerateSuccessAudit,
                pbGenerateFailureAudit
                );

        if (!b)
        {
            break;
        }
    }

    return b;
}



BOOL
AuthzpExamineSingleSaclForObjectTypeList(
    IN PAUTHZI_CLIENT_CONTEXT pCC,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN PACL pAcl,
    IN PSID pOwnerSid,
    IN PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    OUT PBOOL pbGenerateSuccessAudit,
    OUT PBOOL pbGenerateFailureAudit
    )

/*++

Routine description:

    This routine walk thru the entire sacl and mark those nodes in the tree that
    need be dumped to the audit log. It colors the whole subtree including the
    node at which the ace is applicable. A normal ace is applicable at the root
    of the tree.

Arguments:
    pCC - Pointer to the client context to be audited.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pAcl - Sacl to be used to make the decision about audit generation.

    pOwnerSid - The owner sid in the primary security descriptor. This will be
        needed after we implement single instancing.

    pReply - Supplies a pointer to a reply structure used to return the results.

    LocalTypeList - Internal object type list structure used to hold
        intermediate results.

    pbGenerateSuccessAudit - Returns whether a success audit should be
        generated.

    pbGenerateFailureAudit - Returns whether a failure audit should be
        generated.

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    DWORD   AceCount        = 0;
    DWORD   i               = 0;
    DWORD   Ignore          = 0;
    DWORD   Index           = 0;
    PVOID   Ace             = NULL;
    GUID  * ObjectTypeInAce = NULL;
    BOOL    bAceApplicable  = FALSE;

    //
    // Ignore NULL as well as Empty sacls.
    //

    if ((!ARGUMENT_PRESENT(pAcl)) || (0 == (AceCount = pAcl->AceCount)))
    {
        return TRUE;
    }

    for (i = 0, Ace = FirstAce(pAcl); i < AceCount; i++, Ace = NextAce(Ace))
    {
        //
        // Skip INHERIT_ONLY aces.
        //

        if (FLAG_ON(((PACE_HEADER) Ace)->AceFlags, INHERIT_ONLY_ACE))
        {
            continue;
        }

        switch(((PACE_HEADER) Ace)->AceType)
        {
        case SYSTEM_AUDIT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only if FAILED_ACCESS_ACE_FLAG
            // is on. S-1-5-A is replaced by the principal sid supplied by the
            // caller. In future, Creator Owner will be replaced by the owner
            // sid in the primary security descriptor.
            //

                bAceApplicable = AuthzpSidApplicable(
                                     pCC->SidCount,
                                     pCC->Sids,
                                     pCC->SidHash,
                                     AuthzAceSid(Ace),
                                     pRequest->PrincipalSelfSid,
                                     pOwnerSid,
                                     FLAG_ON(((PACE_HEADER) Ace)->AceFlags, FAILED_ACCESS_ACE_FLAG),
                                     &Ignore
                                     );

            if (!bAceApplicable)
            {
                break;
            }

            //
            // We have found an ace that is applicable. Walk the tree to decide
            // if an audit should be generated. Also, mark the nodes that need
            // be dumped to the audit log.
            //

            AuthzpSetAuditInfoForObjectType(
                pReply,
                LocalTypeList,
                0,
                ((PKNOWN_ACE) Ace)->Mask,
                pRequest->DesiredAccess,
                ((PACE_HEADER) Ace)->AceFlags,
                pbGenerateSuccessAudit,
                pbGenerateFailureAudit
                );

            break;

        case SYSTEM_AUDIT_CALLBACK_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only if FAILED_ACCESS_ACE_FLAG
            // is on. S-1-5-A is replaced by the principal sid supplied by the
            // caller. In future, Creator Owner will be replaced by the owner
            // sid in the primary security descriptor.
            //

                bAceApplicable = AuthzpSidApplicable(
                                     pCC->SidCount,
                                     pCC->Sids,
                                     pCC->SidHash,
                                     AuthzAceSid(Ace),
                                     pRequest->PrincipalSelfSid,
                                     pOwnerSid,
                                     FLAG_ON(((PACE_HEADER) Ace)->AceFlags, FAILED_ACCESS_ACE_FLAG),
                                     &Ignore
                                     );

            if (!bAceApplicable)
            {
                break;
            }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            //
            // We have found an ace that is applicable. Walk the tree to decide
            // if an audit should be generated. Also, mark the nodes that need
            // be dumped to the audit log.
            //

            AuthzpSetAuditInfoForObjectType(
                pReply,
                LocalTypeList,
                0,
                ((PKNOWN_ACE) Ace)->Mask,
                pRequest->DesiredAccess,
                ((PACE_HEADER) Ace)->AceFlags,
                pbGenerateSuccessAudit,
                pbGenerateFailureAudit
                );

            break;

        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only if FAILED_ACCESS_ACE_FLAG
            // is on. S-1-5-A is replaced by the principal sid supplied by the
            // caller. In future, Creator Owner will be replaced by the owner
            // sid in the primary security descriptor.
            //

                bAceApplicable = AuthzpSidApplicable(
                                     pCC->SidCount,
                                     pCC->Sids,
                                     pCC->SidHash,
                                     RtlObjectAceSid(Ace),
                                     pRequest->PrincipalSelfSid,
                                     pOwnerSid,
                                     FLAG_ON(((PACE_HEADER) Ace)->AceFlags, FAILED_ACCESS_ACE_FLAG),
                                     &Ignore
                                     );

            if (!bAceApplicable)
            {
                break;
            }

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            Index = 0;

            if (AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (!AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        pReply->ResultListLength,
                        &Index
                        ))
                {
                    break;
                }
            }

            //
            // We have found an ace that is applicable. Walk the tree to decide
            // if an audit should be generated. Also, mark the nodes that need
            // be dumped to the audit log.
            //

            AuthzpSetAuditInfoForObjectType(
                pReply,
                LocalTypeList,
                Index,
                ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                pRequest->DesiredAccess,
                ((PACE_HEADER) Ace)->AceFlags,
                pbGenerateSuccessAudit,
                pbGenerateFailureAudit
                );

            break;

        case SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE:

            //
            // Check if the effective ace sid is present in the client context
            // and is enabled or enabled for deny only if FAILED_ACCESS_ACE_FLAG
            // is on. S-1-5-A is replaced by the principal sid supplied by the
            // caller. In future, Creator Owner will be replaced by the owner
            // sid in the primary security descriptor.
            //

                bAceApplicable = AuthzpSidApplicable(
                                     pCC->SidCount,
                                     pCC->Sids,
                                     pCC->SidHash,
                                     AuthzObjectAceSid(Ace),
                                     pRequest->PrincipalSelfSid,
                                     pOwnerSid,
                                     FLAG_ON(((PACE_HEADER) Ace)->AceFlags, FAILED_ACCESS_ACE_FLAG),
                                     &Ignore
                                     );

            if (!bAceApplicable)
            {
                break;
            }

            bAceApplicable = FALSE;

            //
            // Make a call to the resource manager to get his opinion. His
            // evaluation is returned in bAceApplicalble.
            //
            // Note: The return value of the callback is used to decide whether
            // the API failed/succeeded. On a failure, we exit out of access
            // check. On success, we check the boolean returned by
            // bAceApplicable to decide whether to use the current ace.
            //

            if (!((*(pCC->pResourceManager->pfnDynamicAccessCheck)) (
                       (AUTHZ_CLIENT_CONTEXT_HANDLE) pCC,
                       Ace,
                       pRequest->OptionalArguments,
                       &bAceApplicable
                       )))
            {
                return FALSE;
            }

            if (!bAceApplicable)
            {
                break;
            }

            ObjectTypeInAce = RtlObjectAceObjectType(Ace);

            Index = 0;

            if (AUTHZ_NON_NULL_PTR(ObjectTypeInAce))
            {
                //
                // Look for a matching object type guid that matches the one in
                // the ace.
                //

                if (!AuthzpObjectInTypeList(
                        ObjectTypeInAce,
                        LocalTypeList,
                        pReply->ResultListLength,
                        &Index
                        ))
                {
                    break;
                }
            }

            //
            // We have found an ace that is applicable. Walk the tree to decide
            // if an audit should be generated. Also, mark the nodes that need
            // be dumped to the audit log.
            //

            AuthzpSetAuditInfoForObjectType(
                pReply,
                LocalTypeList,
                Index,
                ((PKNOWN_OBJECT_ACE) Ace)->Mask,
                pRequest->DesiredAccess,
                ((PACE_HEADER) Ace)->AceFlags,
                pbGenerateSuccessAudit,
                pbGenerateFailureAudit
                );

            break;

        default:
            break;
        }
    }

    return TRUE;
}


VOID
AuthzpSetAuditInfoForObjectType(
    IN PAUTHZ_ACCESS_REPLY pReply,
    IN OUT PIOBJECT_TYPE_LIST LocalTypeList,
    IN DWORD StartIndex,
    IN ACCESS_MASK AceAccessMask,
    IN ACCESS_MASK DesiredAccessMask,
    IN UCHAR AceFlags,
    OUT PBOOL pbGenerateSuccessAudit,
    OUT PBOOL pbGenerateFailureAudit
    )

/*++

Routine description:

    This routine propagate the audit decision down the subtree starting at
    StartIndex.

Arguments:

    pReply - This has been filled by access check at this point. We just read
        the values to make audit decision.

    LocalTypeList - Decision to audit a node is stored into Flags corresponding
        member of this array.

    StartIndex - The index in the array at which the coloring should start.

    AceAccessMask - Access mask in the audit ace.

    DesiredAccessMask - Desired access mask in the access request.

    AceFlags - AceFlags member of the ace header. We are interested in the
        audit flags.

    pbGenerateSuccessAudit - Returns whether a success audit should be
        generated.

    pbGenerateFailureAudit - Returns whether a failure audit should be
        generated.

Return Value:

    None

--*/

{
    DWORD i = StartIndex;

    do
    {
        //
        // Store the decision to audit in the local type list if there is a
        // match of access bits.
        //

        if (ERROR_SUCCESS == pReply->Error[i])
        {
            if (FLAG_ON(AceFlags, SUCCESSFUL_ACCESS_ACE_FLAG) &&
                FLAG_ON(pReply->GrantedAccessMask[i], AceAccessMask))
            {
                *pbGenerateSuccessAudit = TRUE;
                LocalTypeList[i].Flags |= AUTHZ_OBJECT_SUCCESS_AUDIT;
                if (NULL != pReply->SaclEvaluationResults)
                {
                    pReply->SaclEvaluationResults[i] |= AUTHZ_GENERATE_SUCCESS_AUDIT;
                }
            }
        }
        else
        {
            //
            // Failure audit is generated even if the bits do not match if the
            // caller asked for MAXIMUM_ALLOWED.
            //

            if (FLAG_ON(AceFlags, FAILED_ACCESS_ACE_FLAG) &&
                FLAG_ON(DesiredAccessMask, (AceAccessMask | MAXIMUM_ALLOWED)))
            {
                *pbGenerateFailureAudit = TRUE;
                LocalTypeList[i].Flags |= AUTHZ_OBJECT_FAILURE_AUDIT;
                if (NULL != pReply->SaclEvaluationResults)
                {
                    pReply->SaclEvaluationResults[i] |= AUTHZ_GENERATE_FAILURE_AUDIT;
                }
            }

        }

        i++;

        //
        // Stop the traversal when the list is exhausted or when we have hit a
        // sibling of the starting node.
        //

    } while ((i < pReply->ResultListLength) &&
             (LocalTypeList[i].Level > LocalTypeList[StartIndex].Level));
}



BOOL
AuthzpVerifyCachedAccessCheckArguments(
    IN PAUTHZI_HANDLE pAH,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN OUT PAUTHZ_ACCESS_REPLY pReply
    )

/*++

Routine description:

    This routine verifies arguments for the cached access check call.

Arguments:

    pAH - Pointer to the authz handle structure.

    pRequest - Access request specifies the desired access mask, principal self
        sid, the object type list strucutre (if any).

    pReply - Supplies a pointer to a reply structure used to return the results

Return Value:

    A value of TRUE is returned if the routine is successful. Otherwise,
    a value of FALSE is returned. In the failure case, error value may be
    retrieved using GetLastError().

--*/

{
    if (!ARGUMENT_PRESENT(pAH))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!ARGUMENT_PRESENT(pRequest))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!ARGUMENT_PRESENT(pReply))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // The caller can specify one of the two values for Reply->ResultListLength
    //     a. 1 - representing the whole object.
    //     b. pRequest->ObjectTypeListLength - for every node in the type list.
    //

    if ((1 != pReply->ResultListLength) &&
        (pReply->ResultListLength != pRequest->ObjectTypeListLength))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return TRUE;
}

VOID
AuthzpFillReplyStructureFromCachedGrantedAccessMask(
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    IN ACCESS_MASK DesiredAccess,
    IN PACCESS_MASK GrantedAccessMask
    )

/*++

Routine description:

    This routine fills the reply structure from the granted access mask array
    in the cache.

Arguments:

    pReply - The reply structure to fill.

    DesiredAccess - Access mask desired.

    GrantedAccessMask - Array of granted masks from the cache.

Return Value:

    None.

--*/

{
    DWORD i = 0;

    for (i = 0; i < pReply->ResultListLength; i++)
    {
        if (FLAG_ON(DesiredAccess, ~(GrantedAccessMask[i])))
        {
            pReply->GrantedAccessMask[i] = 0;
            pReply->Error[i] = ERROR_ACCESS_DENIED;
        }
        else
        {
            pReply->GrantedAccessMask[i] = DesiredAccess;
            pReply->Error[i] = ERROR_SUCCESS;
        }
    }
}


VOID
AuthzpReferenceAuditEventType(
    IN AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET
    )

/*++

Routine Description

    This references an AUTHZ_AUDIT_EVENT_TYPE_HANDLE.  The handle is referenced whenever
    it is used in a situation where it will be 'unused.'  For instance, when an audit is placed
    on the audit queue, we reference hAET.  When we take that audit off of the queue, we deref
    hAET.  This allows the user to not have to concern himself with sync issues revolving around
    the implementation of the hAET.  
    
Arguments

    hAET - the AUTHZ_AUDIT_EVENT_TYPE_HANDLE to reference.
    
Return Value

    Boolean: TRUE on success, FALSE on fail.  Extended information is available with GetLastError().
                                               
--*/

{
    PAUTHZ_AUDIT_EVENT_TYPE_OLD pAAETO = (PAUTHZ_AUDIT_EVENT_TYPE_OLD)hAET;
    InterlockedIncrement(&pAAETO->RefCount);
}


BOOL
AuthzpDereferenceAuditEventType(
    IN OUT AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET
    )

/*++

Routine Description

    Dereferences and AUTHZ_AUDIT_EVENT_TYPE_HANDLE.
    
Arguments

    hAET - handle to dereference.

Return Value

    Boolean: TRUE on success, FALSE on fail.  Extended information is available with GetLastError().
    
--*/

{
    PAUTHZ_AUDIT_EVENT_TYPE_OLD pAAETO = (PAUTHZ_AUDIT_EVENT_TYPE_OLD)hAET;
    LONG                        Refs   = 0;
    BOOL                        b      = TRUE;

    Refs = InterlockedDecrement(&pAAETO->RefCount);
    
    ASSERT(Refs >= 0);

    if (Refs == 0)
    {
        b = AuthzpUnregisterAuditEvent((PAUDIT_HANDLE)&(pAAETO->hAudit));
        ASSERT(pAAETO->hAudit == (ULONG_PTR)0 && b);
        AuthzpFree(hAET);
    }

    return b;
}


BOOL
AuthzpEveryoneIncludesAnonymous(
    OUT PBOOL pbInclude
    )

/*++

Routine Description:

    This routine checks to see if we should include Everyone Sid in Anonymous 
    contexts.  
    
    The reg key under system\currentcontrolset\Control\Lsa\
    AnonymousIncludesEveryone indicates whether or not to include the group.
    If the value is zero (or doesn't exist), we restrict Anonymous context by
    not giving it the Everyone Sid.

Arguments:

    bInclude - TRUE if Everyone Sid should be in the context, false otherwise.

Return Value:

    Boolean: TRUE on success, FALSE on fail.  Extended information is available with GetLastError().
    
--*/
{
    NTSTATUS                       NtStatus            = STATUS_SUCCESS;
    UNICODE_STRING                 KeyName             = {0};     
    OBJECT_ATTRIBUTES              ObjectAttributes    = {0};
    HANDLE                         KeyHandle           = NULL;
    UCHAR                          Buffer[100];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
    ULONG                          KeyValueLength      = 100;
    ULONG                          ResultLength        = 0;
    PULONG                         Flag                = NULL;
    BOOL                           b                   = TRUE;

    *pbInclude = FALSE;

    //
    // Open the Lsa key in the registry
    //

    RtlInitUnicodeString(
        &KeyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    NtStatus = NtOpenKey(
                &KeyHandle,
                KEY_READ,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(NtStatus)) {
        b = FALSE;
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &KeyName,
        L"EveryoneIncludesAnonymous"
        );

    NtStatus = NtQueryValueKey(
                    KeyHandle,
                    &KeyName,
                    KeyValuePartialInformation,
                    KeyValueInformation,
                    KeyValueLength,
                    &ResultLength
                    );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Check that the data is the correct size and type - a ULONG.
        //

        if ((KeyValueInformation->DataLength >= sizeof(ULONG)) &&
            (KeyValueInformation->Type == REG_DWORD)) {


            Flag = (PULONG) KeyValueInformation->Data;

            if (*Flag != 0 ) {
               *pbInclude = TRUE;
            }
        }

    }
    NtClose(KeyHandle);

Cleanup:

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\pch.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        P C H . H
//
// Contents:    pre-compiled header file
//
//
// History:     
//   31-March-2000  kumarp        created
//
//------------------------------------------------------------------------

#pragma once

#pragma warning(push, 3)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include "windows.h"
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>

#include <seopaque.h>
#include <sertlp.h>

#include <lm.h>
#include <winldap.h>
#include <dsgetdc.h>
#include <rpc.h>
#include <rpcdce.h>
#include <ntdsapi.h>
#include <dsrole.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <lsarpc.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <kerberos.h>

#define SECURITY_WIN32

#include "sspi.h"
#include "secint.h"
#pragma warning(pop)

//  
// unreferenced inline removal
//

#pragma warning (disable: 4514)

//
// conditional expression is constant
//

#pragma warning (disable: 4127)

//
// often, we have local variables for the express purpose of ASSERTion.
// when compiling retail, those assertions disappear, leaving our locals
// as unreferenced.
//

#ifndef DBG

#pragma warning (disable: 4189 4100)

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\adl\adlconvert.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adlconvert.cpp

Abstract:

   The routines to convert between AdlStatement, string in the ADL
   language, and a DACL.
   
Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created                 - August 2000
    Semantics finalized     - September 2000

--*/

#include "adl.h"
#include "adlconvert.h"


void AdlStatement::ConvertFromDacl(IN const PACL pDacl)
/*++

Routine Description:

    Traverses the given ACL, and creates an AdlStatement structure
    representative of the DACL.
    
    Algorithm:
    
    First, break up the ACL into 32 stacks, by access mask bits, keeping
    track of the inheritance and SID.
    
    Then use the heuristic algorithm in ConvertStacksToPops to get a 'good'
    (though not necessarily optimal) sequence of stack pops to perform so as
    to produce the optimal set of ADL statements for the DACL.
    
    Finally, perform the sequence of pops and create the ADL statement.
    
    
Arguments:

    pDacl   -       The DACL to convert to an AdlStatement
    
Return Value:

    none
    
--*/
{
    
    DWORD dwIdx;

    DWORD dwIdxElems;
    
    AdlToken *pTok = NULL;
    
    AdlStatement::ADL_ERROR_TYPE adlErr = AdlStatement::ERROR_NO_ERROR;

    //
    // The stack representation of a DACL
    //

    DWORD pdwStackTop[32];
    DWORD pdwStackSize[32];
    PBIT_STACK_ELEM pStacks[32];


    //
    // Mappings from PSID to AdlToken of the name string and from
    // pointer into the user-specified language def to the appropriate
    // permission token. This allows reuse of name and permission tokens
    //
    
    map<const PSID, const AdlToken *> mapSidName;
    map<const WCHAR *, const AdlToken *> mapStringTok;

    //
    // list of pairs <Stack mask, Block Size>, which define the set of pops
    // to perform. This is filled in by the decision algorithm. For every
    // bit set in the stack mask, a block of the given size will be popped
    // into ADL from the stack.
    //

    list<pair<DWORD, DWORD> > listPops;
    list<pair<DWORD, DWORD> >::iterator iterPops;
    list<pair<DWORD, DWORD> >::iterator iterPopsEnd;

    //
    // List of permissions for a given access mask, used as output
    // by the access mask -> set of names lookup
    // 

    list<WCHAR *> lPermissions;
    list<WCHAR *>::iterator iterPerm;
    list<WCHAR *>::iterator iterPermEnd;

    //
    // Initialize the stacks
    //

    for( dwIdx = 0; dwIdx < 32; dwIdx++ )
    {
        pdwStackSize[dwIdx] = 0;
        pdwStackTop[dwIdx] = 0;
        pStacks[dwIdx] = NULL;
    }
    
    //
    // First look up all names. If some names don't exist, save time
    // by not doing the rest of the conversion below
    //

    ConvertSidsToNames(pDacl, &mapSidName);

    //
    // Now convert the ACL to the set of 32 stacks (this needs to be freed
    // later)
    //

    ConvertDaclToStacks(pDacl, _pControl, pdwStackSize, pStacks);

    //
    // A bit of pre-processing: we will need a map from WCHAR * to
    // AdlToken *, so as to reuse AdlTokens for the same permission
    // name. The tokens will be garbage-collected later.
    //

    try
    {
        for( dwIdx = 0; _pControl->pPermissions[dwIdx].str != NULL; dwIdx++ )
        {
            pTok = new AdlToken(_pControl->pPermissions[dwIdx].str, 0, 0);

            try
            {
                AddToken(pTok);
            }
            catch(exception)
            {
                delete pTok;
                throw AdlStatement::ERROR_OUT_OF_MEMORY;
            }

            mapStringTok[_pControl->pPermissions[dwIdx].str] = pTok;
        }

    }
    catch(exception)
    {
        adlErr = AdlStatement::ERROR_OUT_OF_MEMORY;
        goto error;
    }

    //
    // Now we are ready to actually convert the stacks into an ADL statement
    // First we run the recursive algorithm to determine the sequence of 
    // pop operations on the stacks
    //

    try
    {
        ConvertStacksToPops(_pControl,
                            pStacks,
                            pdwStackSize,
                            pdwStackTop,
                            &listPops);
    }
    catch(exception)
    {
        adlErr = AdlStatement::ERROR_OUT_OF_MEMORY;
        goto error;
    }
    catch(AdlStatement::ADL_ERROR_TYPE err)
    {
        adlErr = err;
        goto error;
    }

    //
    // Now we perform the calculated pops
    //

    try
    {
        //
        // Go through the pops in order, and perform them
        //

        DWORD dwStacksPopped;
        DWORD dwBlockSize;

        for( iterPops = listPops.begin(), iterPopsEnd = listPops.end();
             iterPops != iterPopsEnd;
             iterPops++ )
        {
            dwStacksPopped = (*iterPops).first;
            dwBlockSize = (*iterPops).second;

            ASSERT( dwStacksPopped > 0 );
            ASSERT( dwBlockSize > 0 );

            // 
            // Create new ADL statement
            //

            Next();

            //
            // Set permissions once, mask is same as stacks popped
            //

            lPermissions.erase(lPermissions.begin(), lPermissions.end());

            MapMaskToStrings(dwStacksPopped, &lPermissions);

            for( iterPerm = lPermissions.begin(),
                    iterPermEnd = lPermissions.end();
                 iterPerm != iterPermEnd;
                 iterPerm++ )
            {
                Cur()->AddPermission(mapStringTok[*iterPerm]);
            }

            //
            // Now find the first stack with the block in question
            // 

            for( dwIdx = 0; dwIdx < 32; dwIdx++ )
            {
                if( dwStacksPopped & ( 0x00000001 << dwIdx ) )
                {
                    break;
                }
            }

            //
            // Add the Principals, ExPrincipals, and inheritance flags
            // to the ADL statement. The blocks should all be the same,
            // so first block is sufficient
            //

            //
            // First the inheritance flags
            //

            Cur()->OverwriteFlags(pStacks[dwIdx][pdwStackTop[dwIdx]].dwFlags);

            //
            // Now the principals and exprincipals
            //

            for( dwIdxElems = 0; dwIdxElems < dwBlockSize; dwIdxElems++ )
            {

                if(     pStacks[dwIdx][pdwStackTop[dwIdx]+dwIdxElems].bAllow
                    ==  FALSE )
                {
                    Cur()->AddExPrincipal(
                        mapSidName[ 
                                  pStacks[dwIdx][pdwStackTop[dwIdx] + dwIdxElems
                                   ].pSid]);
                }
                else
                {
                    Cur()->AddPrincipal(
                        mapSidName[ 
                                  pStacks[dwIdx][pdwStackTop[dwIdx] + dwIdxElems
                                   ].pSid]);
                }
            }

            //
            // Finally, move the tops of the stacks down to get rid of the
            // popped items
            //


            for( dwIdx = 0; dwIdx < 32; dwIdx++ )
            {
                if( dwStacksPopped & ( 0x00000001 << dwIdx ) )
                {
                    pdwStackTop[dwIdx] += dwBlockSize;
                    ASSERT(pdwStackTop[dwIdx] <= pdwStackSize[dwIdx]);
                }
            }
        }
    }
    catch(exception)
    {
        adlErr = AdlStatement::ERROR_OUT_OF_MEMORY;
        goto error;
    }
    catch(AdlStatement::ADL_ERROR_TYPE err)
    {
        adlErr = err;
        goto error;
    }



    error:;

    if( pStacks[0] != NULL )
    {
        //
        // Free the chunk of memory allocated by the converion
        //

        FreeMemory(pStacks[0]);
    }

    if( adlErr != AdlStatement::ERROR_NO_ERROR )
    {
        throw adlErr;
    }
    
}



////////////////////////////////////////////////////////////////////////////////
/////////////
///////////// DACL -> ADL conversion algorithm
/////////////
////////////////////////////////////////////////////////////////////////////////


void ConvertStacksToPops(
                        IN      const PADL_PARSER_CONTROL pControl,
                        IN      const PBIT_STACK_ELEM pStacks[32],
                        IN      const DWORD pdwStackSize[32],
                        IN      const DWORD pdwStackTop[32],
                        OUT     list< pair<DWORD, DWORD> > * pListPops
                        )
/*++

Routine Description:

    Recursive heuristic to determine the 'good' conversion from ACL to ADL.
    Not necessarily optimal, but computationally feasible. 
    
    This finds a sequence of pops which will empty the 32 per-bit stacks
    while trying to reduce the number of ADL statements output.
    
    Stacks are empty when the stack tops reach the stack ends.
    
    Algorithm:
    
    ---------
    While stacks are not empty:
        FindOptimalPop with given stack ends
        Set temporary stack sizes to the offsets for the optimal pop
        ConvertStacksToPops on the temporary stack ends
        Store the calculated optimal pop in pListPops
        Perform the optimal pops off the stacks
    Endwhile
    ---------
    
    For empty stacks, this just returns.
    
    The output offsets from FindOptimalPop work as temporary stack sizes,
    since everything ebove that must be popped off.
    
    WARNING: This is recursive, and uses 268 bytes of stack for locals. 
    Therefore, a large worst-case ACL will blow the stack (if the recursion
    is near the bottom of the stack at every step). Once ADL goes into OS,
    this recursion can be rewritten as iteration by keeping a stack of the 
    StackTop and StackSize in the heap instead of locals, as a finite-state
    stack machine.
    
Arguments:
    
    pControl        -   The ADL parser spec, used for determining the number
                        of strings it will take to express a permission
    
    pStacks         -   The stack representation of the DACL
    
    pdwStackSize    -   These are offsets to 1 past the last element in the
                        stacks which should be considered
                        
    pdwStackTop     -   These are offsets to the tops of the stacks to be
                        considered
                        
    pListPops       -   The STL list containing the sequence of pop operations
                        to be performed, new pops are appended to this
    
Return Value:

    none
        
--*/

{
    DWORD pdwTmpStackTop[32];

    DWORD pdwTmpStackSize[32];

    DWORD dwIdx;

    DWORD dwStacksPopped;

    DWORD dwBlockSize;

    //
    // Start with top of given stack
    //

    for( dwIdx = 0; dwIdx < 32; dwIdx++ )
    {
        pdwTmpStackTop[dwIdx] = pdwStackTop[dwIdx];
    }

    // 
    // Stacks are empty when the top of each stack points to 1 past the end
    // Therefore, we can just use a memory compare on the tops array and
    // the stack sizes to check. Empty stacks have 0 size and top offset.
    //

    while( memcmp(pdwStackSize, pdwTmpStackTop, sizeof(DWORD) * 32) )
    {
        //
        // The loop should end on empty stacks. Therefore, if this fails, 
        // we have an internal error. Otherwise, we have our optimal pop.
        //

        if( FALSE == FindOptimalPop(
                                pControl,
                                pStacks,
                                pdwStackSize,
                                pdwTmpStackTop,
                                &dwStacksPopped,
                                &dwBlockSize,
                                pdwTmpStackSize
                                ) )
        {
            throw AdlStatement::ERROR_FATAL_ACL_CONVERT_ERROR;
        }

        //
        // Now recurse, and pop off everything ABOVE the optimal pop
        //
        
        ConvertStacksToPops(
                            pControl,
                            pStacks,
                            pdwTmpStackSize,
                            pdwTmpStackTop,
                            pListPops
                            );
        

        

        //
        // Add the optimal pop to the list
        //

        pListPops->push_back(pair<DWORD, DWORD>(dwStacksPopped, dwBlockSize));

        //
        // Now update the tops of the stacks by lowering the tops by
        // the block size
        //
        
        for( dwIdx = 0; dwIdx < 32; dwIdx++ )
        {
            if( (0x00000001 << dwIdx) & dwStacksPopped )
            {
                //
                // By now we have removed everything ebove the optimal pop, and
                // the optimal pop itself. Therefore, go dwBlockSize past the
                // beginning of the optimal pop. Stacks other than those 
                // involved in the optimal pop cannot be effected.
                //

                pdwTmpStackTop[dwIdx] = pdwTmpStackSize[dwIdx] + dwBlockSize;
            }
        }
    }
}



BOOL FindBlockInStack(
                        IN      const PBIT_STACK_ELEM pBlock,
                        IN      const DWORD dwBlockSize,
                        IN      const PBIT_STACK_ELEM pStack,
                        IN      const DWORD dwStackSize,
                        IN      const DWORD dwStackTop,
                        OUT     PDWORD pdwBlockStart
                        )
/*++

Routine Description:

    Attempts to locate the first block of dwBlockSize which matches a block
    of the same size at pBlock in the given stack pStack, between dwStackTop
    and dwStackSize - 1. If successful, start offset of the block is stored in
    pdwBlockStart.
    
Arguments:

    pBlock          -   A single block (see GetBlockSize for definition)
                        for which to look for in pStack
                        
    dwBlockSize     -   The number of elements composing this block
    
    pStack          -   The stack in which to look for pBlock
    
    dwStackSize     -   Offset to 1 past the last element in the stack to
                        consider
                        
    dwStackTop      -   Offset to the effective beginning of the stack
    
    pdwBlockStart   -   If successful, offset to the beginning of the
                        found block is returned in this.                        
    
Return Value:

    TRUE if block found
    FALSE otherwise, in which case *pdwBlockStart is undefined
    
--*/
{
    //
    // States used by this function
    //

#define TMP2_NO_MATCH_STATE 0
#define TMP2_MATCH_STATE 1

    DWORD dwState = TMP2_NO_MATCH_STATE;

    DWORD dwMatchStartIdx;
    DWORD dwIdxStack;
    DWORD dwIdxBlock;

    ASSERT( dwBlockSize > 0 );
    ASSERT( dwStackTop <= dwStackSize );
    
    for( dwIdxStack = dwStackTop, dwIdxBlock = 0;
         dwIdxStack < dwStackSize;
         dwIdxStack++ )
    {
        switch(dwState)
        {
        case TMP2_NO_MATCH_STATE:

            //
            // If the remaining stack is smaller than the block, no need to 
            // check further
            //
        
            if( dwStackSize - dwIdxStack < dwBlockSize )
            {
                return FALSE;
            }
            
            //
            // Check for match start
            //

            if(     pStack[dwIdxStack].bAllow == pBlock[dwIdxBlock].bAllow
                &&  pStack[dwIdxStack].dwFlags == pBlock[dwIdxBlock].dwFlags
                &&  EqualSid(pStack[dwIdxStack].pSid, pBlock[dwIdxBlock].pSid) )
            {
                //
                // Special case: block size 1
                //

                if( dwBlockSize == 1 )
                {
                    *pdwBlockStart = dwIdxStack;
                    return TRUE;
                }
                else
                {
                    dwState = TMP2_MATCH_STATE;
                    dwMatchStartIdx = dwIdxStack;
                    dwIdxBlock++;
                }
            }
            break;
        
        case TMP2_MATCH_STATE:
            
            //
            // If still matched
            //

            if(     pStack[dwIdxStack].bAllow == pBlock[dwIdxBlock].bAllow
                &&  pStack[dwIdxStack].dwFlags == pBlock[dwIdxBlock].dwFlags
                &&  EqualSid(pStack[dwIdxStack].pSid, pBlock[dwIdxBlock].pSid) )
            {
                dwIdxBlock++;

                //
                // Check for complete match
                //

                if( dwIdxBlock == dwBlockSize )
                {
                    *pdwBlockStart = dwMatchStartIdx;
                    return TRUE;
                }

            }
            else
            {
                //
                // Backtrack to the match start
                //

                dwState = TMP2_NO_MATCH_STATE;
                dwIdxBlock = 0;
                dwIdxStack = dwMatchStartIdx;
            }
            break;
            
        default:
            throw AdlStatement::ERROR_FATAL_ACL_CONVERT_ERROR;
            break;
        }
    }

    //
    // If never matched whole block, return FALSE
    //

    return FALSE;

}


BOOL FindOptimalPop(
                        IN      const PADL_PARSER_CONTROL pControl,
                        IN      const PBIT_STACK_ELEM pStacks[32],
                        IN      const DWORD pdwStackSize[32],
                        IN      const DWORD pdwStackTop[32],
                        OUT     PDWORD pdwStacksPopped,
                        OUT     PDWORD pdwBlockSize,
                        OUT     DWORD pdwPopOffsets[32]
                        )
/*++

Routine Description:

    Attempts to locate the greedy-choice optimal set of blocks to pop off.
    Returns the optimal choice in the OUT values on success.
    
    The weight function can be tweaked, and may allow negative values, however
    the value of popping a single stack off the top MUST be positive.
    
    Uses this algorithm:
    -----------
    Start with weight 0
    For every non-empty stack:
        Get top block of stack
        Search all stacks for this block
        Compute the weight of this solution based on block size and # of stacks
        If the weight is greater than the current best weight:
            store the new weight as best weight
            store the new solution as best solution
        Endif
    Endfor
    If weight > 0
        Return the current best solution
    Else
        Report failure
    Endif
    -----------
    
Arguments:

    pControl        -   The ADL parser spec, used for determining the number
                        of strings it will take to express a permission
    
    pStacks         -   The stack representation of the DACL
    
    pdwStackSize    -   These are offsets to 1 past the last element in the
                        stacks which should be considered
                        
    pdwStackTop     -   These are offsets to the tops of the stacks to be
                        considered
                        
    pdwStacksPopped -   Bitmask for which stacks will be popped, stacks which
                        are effected by this pop have the appropriate bit set
    
    pdwBlockSize    -   The size of the block (same for all effected stacks) to
                        be popped is returned through this.
                        
    pdwPopOffsets   -   The start offsets of the blocks to pop are returned here
    
Return Value:

    TRUE on success, if a pop with weight > 0 has been found
    FALSE otherwise, in which case OUT values are undefined
    
--*/
{

    DWORD dwIdxStacks1;
    DWORD dwIdxStacks2;

    //
    // Initial optimal solution
    //

    LONG iCurrentWeight = 0;

    
    
    //
    // Current solution
    //

    LONG iTempWeight;

    DWORD dwTempStacksPopped;
    DWORD dwTempBlockSize;
    DWORD pdwTempPops[32];

    DWORD dwBlockOffset;


    //
    // Try the block at the top of every stack
    //

    for( dwIdxStacks1 = 0; dwIdxStacks1 < 32; dwIdxStacks1++ )
    {
        //
        // Skip empty stacks
        //

        if( pdwStackSize[dwIdxStacks1] == pdwStackTop[dwIdxStacks1] )
        {
            continue;
        }


        dwTempBlockSize = GetStackBlockSize(pStacks[dwIdxStacks1],
                                        pdwStackTop[dwIdxStacks1],
                                        pdwStackSize[dwIdxStacks1]);


        //
        // If a block size of 0 is detected in a non-empty stack, then
        // this is not expressable in ADL, throw the error here
        //

        if( dwTempBlockSize == 0 )
        {
            throw AdlStatement::ERROR_INEXPRESSIBLE_ACL;
        }

        //
        // The initial weight is 0, since loop will account for top loop stack
        // Same with initial stacks popped
        //

        iTempWeight = 0;
        dwTempStacksPopped = 0;

        //
        // Now, try to find this block in all stacks
        //

        for( dwIdxStacks2 = 0; dwIdxStacks2 < 32; dwIdxStacks2++ )
        {

            //
            // Fist assume pop location is at the top (no pop),
            // even for empty stacks
            //

            pdwTempPops[dwIdxStacks2] = pdwStackTop[dwIdxStacks2];

            
            //
            // Skip empty stacks
            //

            if( ! (pdwStackSize[dwIdxStacks2] - pdwStackTop[dwIdxStacks2] > 0) )
            {
                continue;
            }

            if( TRUE == FindBlockInStack(
                            &(pStacks[dwIdxStacks1][pdwStackTop[dwIdxStacks1]]),
                            dwTempBlockSize,
                            pStacks[dwIdxStacks2],
                            pdwStackSize[dwIdxStacks2],
                            pdwStackTop[dwIdxStacks2],
                            &dwBlockOffset) )
            {
                //
                // Block was found in this stack
                //

                pdwTempPops[dwIdxStacks2] = dwBlockOffset;
                dwTempStacksPopped |= ( 0x00000001 << dwIdxStacks2);

            }
        }

        //
        // Calculate the weight of this solution
        //

        //
        // Weight for number of principals expressed
        //

        iTempWeight += (WEIGHT_STACK_HEIGHT) * dwTempBlockSize;

        //
        // Weights for each bit
        // also weights (or penalties) for having to pop things
        // off above the optimal pop
        //

        for( dwIdxStacks2 = 0; dwIdxStacks2 < 32; dwIdxStacks2++ )
        {
            if( dwTempStacksPopped & ( 0x00000001 << dwIdxStacks2 ) )
            {
                iTempWeight += (WEIGHT_PERM_BIT);

                iTempWeight +=   (WEIGHT_ITEM_ABOVE_POP)
                               * (   pdwTempPops[dwIdxStacks2]
                                   - pdwStackTop[dwIdxStacks2] );
                                 
                
            }
        }

        //
        // Finally the weight/penalty for number of permission names
        // needed beyond the 1st one
        //

        iTempWeight +=   (WEIGHT_PERMISSION_NAME) 
                       * (NumStringsForMask(pControl, dwTempStacksPopped) - 1 );
        

        //
        // If this solution is better than the best so far, save it
        //

        if( iTempWeight > iCurrentWeight )
        {
            iCurrentWeight = iTempWeight;

            *pdwStacksPopped = dwTempStacksPopped;

            *pdwBlockSize = dwTempBlockSize;

            for( dwIdxStacks2 = 0; dwIdxStacks2 < 32; dwIdxStacks2++ )
            {
                pdwPopOffsets[dwIdxStacks2] = pdwTempPops[dwIdxStacks2];
            }
        }
    }

    //
    // If we have not found any solution, we were passed an empty set of stacks
    // Otherwise, the optimal solution is already in the OUT values
    //

    if( iCurrentWeight > 0 )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}



void ConvertDaclToStacks(
                        IN      const PACL pDacl,
                        IN      const PADL_PARSER_CONTROL pControl,
                        OUT     DWORD pdwStackSize[32],
                        OUT     PBIT_STACK_ELEM pStacks[32]
                        )
/*++

Routine Description:

    Traverses the given ACL, allocates the 32 per-bit stacks, and fills them
    with the ACL broken up per-bit. The allocated memory can be freed by
    a SINGLE call to AdlStatement::FreeMemory(pStacks[0]), since the block
    allocated is a single block.
    
Arguments:

    pDacl           -       The DACL to convert
    
    pControl        -       The ADL_PARSER_CONTROL, for permission mapping
    
    pdwStackSize    -       The sizes of the stacks are returned here
    
    pStacks         -       The pointers to the per-bit stacks are returned here
                            pStacks[0] should be freed later using
                            AdlStatement::FreeMemory
    
Return Value:

    none
    
--*/
{
    
    DWORD dwIdx;
    DWORD dwIdx2;
    DWORD dwTmp;
    DWORD dwNumBlocksTotal = 0;

    DWORD dwFlags;
    ACCESS_MASK amMask;
    BOOL bAllow;
    
    PVOID pAce;
    PSID pSid;

    DWORD pdwStackCur[32];

    for( dwIdx = 0; dwIdx < 32; dwIdx++ )
    {
        pdwStackSize[dwIdx] = 0;
        pdwStackCur[dwIdx] = 0;
        pStacks[dwIdx] = NULL;
    }

    //
    // Determine amount of stack space needed for each stack
    //
    
    for( dwIdx = 0; dwIdx < pDacl->AceCount; dwIdx++ )
    {
        GetAce(pDacl, dwIdx, &pAce);

        switch(((PACE_HEADER)pAce)->AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
            amMask = ((PACCESS_ALLOWED_ACE)pAce)->Mask
                     & ~(pControl->amNeverSet | pControl->amSetAllow);
            break;

        case ACCESS_DENIED_ACE_TYPE:
            amMask = ((PACCESS_DENIED_ACE)pAce)->Mask
                     & ~(pControl->amNeverSet | pControl->amSetAllow);
            break;
        
        default:
            throw AdlStatement::ERROR_UNKNOWN_ACE_TYPE;
            break;
        }
        
        for( dwIdx2 = 0, dwTmp = 0x00000001;
             dwIdx2 < 32 ; 
             dwTmp <<= 1, dwIdx2++ )
        {
            if( dwTmp & amMask )
            {
                pdwStackSize[dwIdx2]++;
                dwNumBlocksTotal++;
            }
        }
    }


    //
    // Allocate the 32 stacks of pointers as a single memory chunk
    //

    pStacks[0] = (PBIT_STACK_ELEM) 
                            new BYTE[dwNumBlocksTotal * sizeof(BIT_STACK_ELEM)];

    if( pStacks[0] == NULL )
    {
        throw AdlStatement::ERROR_OUT_OF_MEMORY;
    }

    //
    // Set the stack pointers to the proper locations in the single memory chunk
    //

    for( dwIdx = 1, dwTmp = pdwStackSize[0];
         dwIdx < 32;
         dwIdx++ )
    {
        if( pdwStackSize[dwIdx] > 0 )
        {
            pStacks[dwIdx] = &(pStacks[0][dwTmp]);
            
            dwTmp += pdwStackSize[dwIdx];
        }
    }

    ASSERT( dwTmp == dwNumBlocksTotal );

    //
    // Now go through the ACL again and fill in the stacks and advancing
    // the pStacksCur pointers
    // Stack sizes are known, so we treat the start of memory at TOP
    // of stack
	//
	// Make sure to strip out the INHERITED_ACE flag from the ACEs,
	// and handle the special access masks in the parser control
    //

    for( dwIdx = 0; dwIdx < pDacl->AceCount; dwIdx++ )
    {
        GetAce(pDacl, dwIdx, &pAce);

        switch(((PACE_HEADER)pAce)->AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
            dwFlags = ((PACCESS_ALLOWED_ACE)pAce)->Header.AceFlags
				      & ( CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE
						  | NO_PROPAGATE_INHERIT_ACE | OBJECT_INHERIT_ACE );

            amMask = ((PACCESS_ALLOWED_ACE)pAce)->Mask
                     & ~(pControl->amNeverSet | pControl->amSetAllow);

            bAllow = TRUE;

            pSid = &(((PACCESS_ALLOWED_ACE)pAce)->SidStart);

            break;

        case ACCESS_DENIED_ACE_TYPE:
            dwFlags = ((PACCESS_DENIED_ACE)pAce)->Header.AceFlags
				& ( CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE
					| NO_PROPAGATE_INHERIT_ACE | OBJECT_INHERIT_ACE );

            amMask = ((PACCESS_DENIED_ACE)pAce)->Mask
                     & ~(pControl->amNeverSet | pControl->amSetAllow);

            bAllow = FALSE;

            pSid = &(((PACCESS_DENIED_ACE)pAce)->SidStart);

            break;

        default:
            throw AdlStatement::ERROR_UNKNOWN_ACE_TYPE;
            break;
        }
        
        for( dwIdx2 = 0, dwTmp = 0x00000001;
             dwIdx2 < 32; 
             dwIdx2++, dwTmp <<= 1 )
        {
            if( dwTmp & amMask )
            {
                //
                // Index should never reach size (1 past bottom) of the stack
                //

                ASSERT( pdwStackCur[dwIdx2] < pdwStackSize[dwIdx2] );
                
                //
                // Fill in the actual structure
                //

                pStacks[dwIdx2][pdwStackCur[dwIdx2]].bAllow = bAllow;
                pStacks[dwIdx2][pdwStackCur[dwIdx2]].pSid = pSid;
                pStacks[dwIdx2][pdwStackCur[dwIdx2]].dwFlags = dwFlags;

                //
                // Top of the stack is the top, but we fill the stack top-first
                // So advance toward bottom of stack
                //
                
                pdwStackCur[dwIdx2]++;
                


            }
        }
    }

#if DBG
    //
    // Now perform an additional check in debug only that all stacks have
    // been filled as allocated
    //

    for( dwIdx = 0; dwIdx < 32; dwIdx++ )
    {
        ASSERT( pdwStackCur[dwIdx] == pdwStackSize[dwIdx] );
    }

#endif

}




DWORD GetStackBlockSize(
                        IN const PBIT_STACK_ELEM pStack,
                        IN DWORD dwStartOffset,
                        IN DWORD dwStackSize 
                        )
/*++

Routine Description:

    Finds the size of the maximum 'block' in the current per-bit stack, from
    the current position.
    
    A block is defined to be a set of 0 or more consecutive deny per-bit 
    ACE entries immediately followed by 1 or more consecutive allow per-bit
    ACE entries such that the inheritance masks are the same.
    
    Therefore, a DENY without a matching allow is NOT a block. This is detected
    when we are in the TMP_READ_DENY_STATE (indicating we have already read at
    least one deny) and read either a deny or allow with a non-matching mask.
    
    On the other hand, even a single ALLOW is a valid block. Therefore this
    can only fail if dwStartOffset points to a deny. 
    
Arguments:

    pStack          -   The per-bit stack to check
    
    dwStartOffset   -   Position to begin at (using that ace, not the next one)
    
    dwStackSize     -   Maximum offset will be dwStackSize - 1, this should
                        never get called with dwStackSize of 0.
    
Return Value:

    Number of entries in the block if successful
    0 if not successful
    
--*/
{

//
// States used by this function
//

#define TMP_START_STATE 0
#define TMP_READ_DENY_STATE 1
#define TMP_READ_ALLOW_STATE 2
#define TMP_DONE_STATE 3

    DWORD dwCurState = TMP_START_STATE;

    DWORD dwCurOffset = dwStartOffset;

    DWORD dwFlags;

    ASSERT( dwStackSize > 0 );
    ASSERT( dwStartOffset < dwStackSize );

    //
    // Returns are inside the loop, they will terminate it
    //

    while( ( dwCurState != TMP_DONE_STATE ) && ( dwCurOffset < dwStackSize ) )
    {
        switch( dwCurState )
        {
        case TMP_START_STATE:
    
            dwFlags = pStack[dwCurOffset].dwFlags;
            
            if( pStack[dwCurOffset].bAllow == FALSE ) // DENY entry
            {
                dwCurState = TMP_READ_DENY_STATE;
                dwCurOffset++;
            }
            else // Otherwise an ALLOW entry
            {
                dwCurState = TMP_READ_ALLOW_STATE;
                dwCurOffset++;
            }

            break;

        case TMP_READ_DENY_STATE:

            //
            // If we are in this state, and find an entry with non-matching
            // flags, this means no valid block is possible, return 0
            //

            if( pStack[dwCurOffset].dwFlags != dwFlags )
            {
                //
                // Set end offset to indicate 0 block size and finish
                // This indicates there is no valid block
                //

                dwCurState = TMP_DONE_STATE;
                dwCurOffset = dwStartOffset;
            }
            else
            {
                if( pStack[dwCurOffset].bAllow == FALSE )
                {
                    //
                    // Another deny, stay in same state
                    //

                    dwCurOffset++;
                }
                else
                {
                    //
                    // Allow with matching flags, go into allow state
                    //

                    dwCurState = TMP_READ_ALLOW_STATE;
                    dwCurOffset++;
                }
            }

            break;

        case TMP_READ_ALLOW_STATE:

            //
            // If we are in this state, we have read 0 or more denies and
            // at least 1 allow. Therefore, we already have a block, so we 
            // just need to find its end and return. 
            //

            if(    (dwFlags == pStack[dwCurOffset].dwFlags)
                && (pStack[dwCurOffset].bAllow == TRUE) )
            {
                //
                // Another matching allow
                //

                dwCurOffset++;
            }
            else
            {
                //
                // End of block found
                //

                dwCurState = TMP_DONE_STATE;
            }

            break;
        }
    }

    //
    // Two ways to reach this point, hitting the bottom of the stack or
    // finding the end of the block (or lack thereof). In both cases, the
    // size of the block is dwCurOffset - dwStartOffset. In case of no
    // valid block, this will evaluate to 0.
    //

    return dwCurOffset - dwStartOffset;
}


DWORD NumStringsForMask(
                    IN     const PADL_PARSER_CONTROL pControl,
                    IN     ACCESS_MASK amMask
                    ) 
/*++

Routine Description:
    
    Determines the number of permission names which would be required 
    to express the access mask
        
Arguments:

    pControl    -   This contains the mapping between permission names and masks

    amMask      -   The mask to represent
    
Return Value:

    DWORD       -   The number of strings which would be required
    
--*/

{
    ACCESS_MASK amOptional = amMask;

    DWORD dwIdx = 0;

    DWORD dwNumStrings = 0;
    
    while(     amMask != 0 
            && (pControl->pPermissions )[dwIdx].str != NULL )
    {
        //
        // If all the bits representing the string are present in the whole mask
        // and at least some of the bits have not yet been represented
        // by another string, add this string to the list and remove the 
        // bits from amMask (representing the still required bits)
        //
        if( ( (amOptional & (pControl->pPermissions )[dwIdx].mask)
                ==   (pControl->pPermissions )[dwIdx].mask )
            && (amMask & (pControl->pPermissions )[dwIdx].mask))

        {
            amMask &= ~(pControl->pPermissions )[dwIdx].mask;
            dwNumStrings++;
        }
        
        dwIdx++;
    }

    //
    // If any of the rights are not mapped, throw an exception
    //

    if( amMask != 0 )
    {
            throw AdlStatement::ERROR_UNKNOWN_ACCESS_MASK;
    }

    return dwNumStrings;
}




////////////////////////////////////////////////////////////////////////////////
/////////////
///////////// Conversion from ADL to DACL
/////////////
////////////////////////////////////////////////////////////////////////////////


void AdlStatement::WriteToDacl(OUT PACL * ppDacl)

/*++

Routine Description:

    Creates a DACL representative of the AdlStatement structure.
    
    The PACL to the DACL is stored in ppDacl. It should be freed
    with the AdlStatement::FreeMemory() function.
    
    The algorithm is very straightforward, it's just a linear conversion
    from ADL to a DACL, taking each ADL substatement and creating deny ACEs
    for every ExPrincipal and allow ACEs for Principals.
    
Arguments:

    ppDacl  -       A pointer to the allocated DACL is stored in *pDacl
    
Return Value:

    none
    
--*/

{

    //
    // If not initialized, do not output
    //

    if( _bReady == FALSE )
    {
        throw AdlStatement::ERROR_NOT_INITIALIZED;
    }

    //
    // Mapping from token *'s to SIDs
    //

    map<const AdlToken *, PSID> mapTokSid;

    //
    // Mapping from Adl substatements (AdlTree *'s) to their access mask
    // This is before the special treatment masks are applied
    //

    map<const AdlTree *, ACCESS_MASK> mapTreeMask;

    //
    // Iterators which are reused
    //

    list<AdlTree *>::iterator iterTrees;
    list<AdlTree *>::iterator iterTreesEnd;
    list<const AdlToken *>::iterator iterTokens;
    list<const AdlToken *>::iterator iterTokensEnd;

    ACCESS_MASK amMask;

    stack<PBYTE> stackToFree;
    PBYTE pbLastAllocated;

    DWORD dwAclSize = sizeof(ACL);

    PACL pAcl = NULL;

    try {

        //
        // Do a single LSA lookup, convert all at once
        // SIDs will need to be deleted by retrieving them from the map
        //

        ConvertNamesToSids(&mapTokSid);

    
        //
        // Calculate the ACL size
        //

        for(iterTrees = _lTree.begin(), iterTreesEnd = _lTree.end();
            iterTrees != iterTreesEnd;
            iterTrees++)
        {
        
            //
            // Now go through the Principals
            //
        
            for(iterTokens = (*iterTrees)->GetPrincipals()->begin(), 
                    iterTokensEnd = (*iterTrees)->GetPrincipals()->end();
                iterTokens != iterTokensEnd;
                iterTokens ++)
            {
                dwAclSize += ( 
                          sizeof(ACCESS_ALLOWED_ACE)
                        - sizeof(DWORD)
                        + GetLengthSid((*(mapTokSid.find(*iterTokens))).second)
                          );
            }
        
            //
            // And the ExPrincipals
            //
        
            for(iterTokens = (*iterTrees)->GetExPrincipals()->begin(), 
                    iterTokensEnd = (*iterTrees)->GetExPrincipals()->end();
                iterTokens != iterTokensEnd;
                iterTokens ++)
            {
                dwAclSize += ( 
                          sizeof(ACCESS_DENIED_ACE)
                        - sizeof(DWORD)
                        + GetLengthSid((*(mapTokSid.find(*iterTokens))).second)
                          );
            }

            //
            // Calculate the effective permissions ahead of time
            //

            amMask = 0;

            for(iterTokens = (*iterTrees)->GetPermissions()->begin(), 
                    iterTokensEnd = (*iterTrees)->GetPermissions()->end();
                iterTokens != iterTokensEnd;
                iterTokens ++)
            {
                amMask |= MapTokenToMask(*iterTokens);
            }

            //
            // And enter the AdlTree *, Mask pair into the map
            //

            mapTreeMask[*iterTrees] = amMask;

        }

        //
        // Allocate the ACL
        //

        pAcl = (PACL)new BYTE[dwAclSize];

        if( pAcl == NULL )
        {
            throw AdlStatement::ERROR_OUT_OF_MEMORY;
        }
        
        //
        // Initialize the ACL
        //

        if( ! InitializeAcl(pAcl, dwAclSize, ACL_REVISION_DS))
        {
            throw AdlStatement::ERROR_ACL_API_FAILED;
        }

        
        //
        // Now go through the substatements and create the ACEs
        //

        for(iterTrees = _lTree.begin(), iterTreesEnd = _lTree.end();
            iterTrees != iterTreesEnd;
            iterTrees++)
        {

            //
            // First add the denies for this statement
            //
            
            
            for(iterTokens = (*iterTrees)->GetExPrincipals()->begin(),
                    iterTokensEnd = (*iterTrees)->GetExPrincipals()->end();
                iterTokens != iterTokensEnd; 
                iterTokens ++)
            {
                if( ! AddAccessDeniedAceEx(
                            pAcl,
                            ACL_REVISION_DS,
                            (*iterTrees)->GetFlags(),
                            ( mapTreeMask[*iterTrees] 
                                & ~_pControl->amSetAllow)
                                & ~_pControl->amNeverSet,
                            mapTokSid[*iterTokens] ))
                {
                    throw AdlStatement::ERROR_ACL_API_FAILED;
                }
            }

            
            //
            // Now go through the Principals, add allows
            //
            
            for(iterTokens = (*iterTrees)->GetPrincipals()->begin(),
                    iterTokensEnd = (*iterTrees)->GetPrincipals()->end();
                iterTokens != iterTokensEnd;
                iterTokens ++)
            {
                if( ! AddAccessAllowedAceEx(
                            pAcl,
                            ACL_REVISION_DS,
                            (*iterTrees)->GetFlags(),
                            (mapTreeMask[*iterTrees]
                                | _pControl->amSetAllow)
                                & ~_pControl->amNeverSet,

                            mapTokSid[*iterTokens] ))
                {
                    throw AdlStatement::ERROR_ACL_API_FAILED;
                }
                

            }

        }
    }
    catch(...)
    {
        if( pAcl != NULL )
        {
            //
            // Memory allocated for ACL
            //

            delete[] (PBYTE)pAcl;
        }

        //
        // Memory allocated for the SIDs
        //

        while( !mapTokSid.empty() )
        {
            delete[] (PBYTE) (*(mapTokSid.begin())).second;
            mapTokSid.erase(mapTokSid.begin());
        }

        //
        // and pass the exception along
        //

        throw;
    }

    //
    // Free the SIDs if done, since they are copied into the ACL
    //

    while( !mapTokSid.empty() )
    {
        delete[] (PBYTE) (*(mapTokSid.begin())).second;
        mapTokSid.erase(mapTokSid.begin());
    }

    //
    // The DACL is returned, so it should not be deallocated
    //

    *ppDacl = pAcl;

}





////////////////////////////////////////////////////////////////////////////////
/////////////
///////////// Utility functions
/////////////
////////////////////////////////////////////////////////////////////////////////


bool AdlCompareStruct::operator()(IN const PSID pSid1,
                                  IN const PSID pSid2 ) const
/*++

Routine Description:

	This is a less-than function which places a complete ordering on
	a set of PSIDs by value, NULL PSIDs are valid. This is used by the 
	STL map.
	
	Since the number of subauthorities appears before the subauthorities
	themselves, that difference will be noticed for two SIDs of different
	size before the memcmp tries to access the nonexistant subauthority
	in the shorter SID, therefore an access violation will not occur.

Arguments:

    pSid1   -       First PSID
    pSid2   -       Second PSID

Return Value:

    Returns TRUE iff SID1 < SID2
    FALSE otherwise
    
--*/

{
    
	//
    // If both are NULL, false should be returned for complete ordering
    //

    if(pSid2 == NULL)
    {
        return false;
    }

    if(pSid1 == NULL)
    {
        return true;
    }

    if( memcmp(pSid1, pSid2, GetLengthSid(pSid1)) < 0 )
    {
        return true;
    }
    else
    {
        return false;
    }
}



bool AdlCompareStruct::operator()(IN const WCHAR * sz1,
                                  IN const WCHAR * sz2 ) const
/*++

Routine Description:

    operator() compares two null-terminated WCHAR* strings, case-INSENSITIVE. 
    
Arguments:

    sz1     -       First string
    sz2     -       Second string

Return Value:

    Returns TRUE iff sz1 < sz2
    FALSE otherwise
    
--*/
{

    return ( _wcsicmp(sz1, sz2) < 0 );
}




void AdlStatement::MapMaskToStrings(
                                      IN     ACCESS_MASK amMask,
                                      IN OUT list<WCHAR *> *pList ) const
/*++

Routine Description:

    Converts the given access mask into a list of const WCHAR *'s representing
    the possibly overlapping permission strings which, when combined by a 
    bitwise OR, are equal to the access mask given. Throws exception if
    a given access mask cannot be represented by the user-specified permissions.
    
    The WCHAR * pointers are const, and should not be deallocated.
        
Arguments:

    amMask      -   The mask to represent
    
    pList       -   An allocated STL list in which to store the pointers
    
Return Value:

    none
    
--*/

{
    ACCESS_MASK amOptional = amMask;

    DWORD dwIdx = 0;
    
    while(     amMask != 0 
            && (_pControl->pPermissions )[dwIdx].str != NULL )
    {
        //
        // If all the bits representing the string are present in the whole mask
        // and at least some of the bits have not yet been represented
        // by another string, add this string to the list and remove the 
        // bits from amMask (representing the still required bits)
        //
        if( ( (amOptional & (_pControl->pPermissions )[dwIdx].mask)
                ==   (_pControl->pPermissions )[dwIdx].mask )
            && (amMask & (_pControl->pPermissions )[dwIdx].mask))

        {
            amMask &= ~(_pControl->pPermissions )[dwIdx].mask;
            pList->push_back((_pControl->pPermissions )[dwIdx].str);
        }
        
        dwIdx++;
    }

    //
    // If any of the rights are not mapped, throw an exception
    //

    if( amMask != 0 )
    {
            throw AdlStatement::ERROR_UNKNOWN_ACCESS_MASK;
    }
}



void AdlStatement::ConvertSidsToNames(
    IN const PACL pDacl,
    IN OUT map<const PSID, const AdlToken *> * mapSidsNames 
    )
/*++

Routine Description:

    Traverses a DACL, and creates string representations of every SID
    found in the DACL. Returns them in the provided map. The newly allocated
    tokens will get garbage-collected by the AdlStatement later, no need
    to free manually. Since the PSIDs used are the same as in the ACL itself,
    we don't need to map by value, since pointer uniqueness is guaranteed here.
        
Arguments:

    pDacl  -  DACL to traverse
    
    mapSidNames  -  Where to store the resulting mapping
    
Return Value:

    none
    
--*/

{
    
    AdlStatement::ADL_ERROR_TYPE adlError = AdlStatement::ERROR_NO_ERROR;

    DWORD dwIdx = 0;
    LPVOID pAce = NULL;
    AdlToken *pTok = NULL;
    AdlToken *pTokLastAllocated = NULL;

    wstring wsName, wsDomain;

    NTSTATUS ntErr = STATUS_SUCCESS;

    LSA_HANDLE LsaPolicy;
    PLSA_REFERENCED_DOMAIN_LIST RefDomains = NULL;
    PLSA_TRANSLATED_NAME Names = NULL;
    
    
    LSA_OBJECT_ATTRIBUTES LsaObjectAttributes;

    //
    // Traverse the ACL to get the list of SIDs used
    //

    PSID *ppSids = NULL;
     
    ppSids = (PSID *) new BYTE[sizeof(PSID) * pDacl->AceCount];

    if( ppSids == NULL )
    {
        adlError = AdlStatement::ERROR_OUT_OF_MEMORY;
        goto error;
    }

    for(dwIdx = 0; dwIdx < pDacl->AceCount; dwIdx++)
    {
        GetAce(pDacl, dwIdx, &pAce);

        switch( ((ACE_HEADER *)pAce)->AceType )
        {
        case ACCESS_ALLOWED_ACE_TYPE:
            ppSids[dwIdx] = &( ((ACCESS_ALLOWED_ACE *)pAce)->SidStart);
            break;

        case ACCESS_DENIED_ACE_TYPE:
            ppSids[dwIdx] = &( ((ACCESS_DENIED_ACE *)pAce)->SidStart);
            break;
            
        default:
            adlError = AdlStatement::ERROR_UNKNOWN_ACE_TYPE;
            goto error;
            break;
        }
    }

    //
    // Look up all SIDs, getting user and domain names, single LSA call
    //

    LsaObjectAttributes.Length = sizeof(LSA_OBJECT_ATTRIBUTES);
    LsaObjectAttributes.RootDirectory = NULL;
    LsaObjectAttributes.ObjectName = NULL;
    LsaObjectAttributes.Attributes = 0;
    LsaObjectAttributes.SecurityDescriptor = NULL;
    LsaObjectAttributes.SecurityQualityOfService = NULL;
    
    ntErr = LsaOpenPolicy(
                        NULL,
                        &LsaObjectAttributes,
                        POLICY_LOOKUP_NAMES,
                        &LsaPolicy);
    
    if( ntErr != STATUS_SUCCESS )
    {
        adlError = AdlStatement::ERROR_LSA_FAILED;
        goto error;
    }
    
    //
    // Garbage collect later
    //

    ntErr = LsaLookupSids(LsaPolicy,
                          pDacl->AceCount,
                          ppSids,
                          &RefDomains,
                          &Names);
    
    LsaClose(LsaPolicy);

    if( ntErr != ERROR_SUCCESS )
    {

        if( (ntErr == STATUS_SOME_NOT_MAPPED) || (ntErr == STATUS_NONE_MAPPED) )
        {
            adlError = AdlStatement::ERROR_UNKNOWN_SID;
        }
        else
        {
            adlError = AdlStatement::ERROR_LSA_FAILED;
        }

        goto error;
    }

    //
    // Now traverse the list ppSids, creating matching tokens for the 
    // SIDs in the ACL.
    //
    
    try
    {
        for(dwIdx = 0; dwIdx < pDacl->AceCount; dwIdx++)
        {
            pTok = NULL;
            
            //
            // LSA Strings not terminated, create terminated version
            // LSA buffer sizes in bytes, not wchars
            //
    
            assert(Names[dwIdx].DomainIndex >= 0);
    
            wsName.assign(Names[dwIdx].Name.Buffer,
                          Names[dwIdx].Name.Length / sizeof(WCHAR));
    
            //
            // If builtin, no need for domain info
            //
                
            if(Names[dwIdx].Use == SidTypeWellKnownGroup)
            {
                pTok = new AdlToken(wsName.c_str(), 0, 0);
            }
            else
            {
                wsDomain.assign(
                    RefDomains->Domains[Names[dwIdx].DomainIndex].Name.Buffer,
                    RefDomains->Domains[Names[dwIdx].DomainIndex].Name.Length 
                        / sizeof(WCHAR));
    
                pTok = new AdlToken(wsName.c_str(), wsDomain.c_str(), 0, 0);
            }

            if( pTok == NULL )
            {
                adlError = AdlStatement::ERROR_OUT_OF_MEMORY;
                goto error;
            }
            else
            {
                //
                // This will be deleted immediately if we cannot save the token
                // for later deallocation
                //

                pTokLastAllocated = pTok;
            }
                
            AddToken(pTok); // For later garbage collection
            
            //
            // No need ot delete immedeately, since no exception thrown
            //

            pTokLastAllocated = NULL;


            (*mapSidsNames)[(ppSids[dwIdx])] = pTok;
        }
    }
    catch(exception)
    {
        adlError = AdlStatement::ERROR_OUT_OF_MEMORY;
        goto error;
    }

    // 
    // Done with the SIDs and LSA info, deallocate
    //

    error:;

    if( RefDomains != NULL )
    {
        LsaFreeMemory(RefDomains);
    }

    if( Names != NULL )
    {
        LsaFreeMemory(Names);
    }

    if( ppSids != NULL )
    {
        delete[] (PBYTE) ppSids;
    }

    if( adlError != AdlStatement::ERROR_NO_ERROR )
    {
        throw adlError;
    }

}





ACCESS_MASK AdlStatement::MapTokenToMask(
                                IN const AdlToken * tokPermission
                          )  

/*++

Routine Description:

    This routine maps a string represening a right to the matching access bits
    using the user-supplied mapping.
    
    This assumes that there are no pairs with ACCESS_MASK of 0 in the
    user-supplied mapping.
    
Arguments:

    tokPermission   -       The permission token to be looked up
    
Return Value:

    ACCESS_MASK     -       The corresponding access mask
    
--*/

{
    ACCESS_MASK amMask = 0;

    DWORD dwIdx = 0;

    //
    // The token should never have a second value
    //

    if( tokPermission->GetOptValue() != NULL )
    {
        throw AdlStatement::ERROR_FATAL_PARSER_ERROR;
    }

    while(amMask == 0 && (_pControl->pPermissions)[dwIdx].str != NULL)
    {
        if(0 == _wcsicmp(tokPermission->GetValue(),
                         (_pControl->pPermissions)[dwIdx].str ))
        {
            amMask = (_pControl->pPermissions)[dwIdx].mask;
        }

        ++dwIdx;
    }

    //
    // If mask was not matched, throw exception
    //

    if(amMask == 0)
    {
        SetErrorToken(tokPermission);
        throw AdlStatement::ERROR_UNKNOWN_PERMISSION;
    }

    return amMask;
}



void AdlStatement::ConvertNamesToSids(
                        IN OUT map<const AdlToken *, PSID> * mapTokSid
                        )

/*++

Routine Description:
    
    This routine traverses all AdlTree's in the AdlStatement, and creates a list
    of all usernames used. It then makes a single LSA call, and creates a map
    of name AdlToken*'s to PSIDs, for later use by the conversion function.
    
    The newly allocated PSIDs are stored in the map. They should be freed
    using the AdlStatement::FreeMemory() function.
    
    On error, any PSIDs that have been added to the map are deleted.
    
Arguments:

    mapTokSid       -       Allocated map to which the Token,PSID entries should
                                be added. This MUST be empty. Otherwise, on
                                error, externally allocated memory would get
                                freed here.
    
Return Value:

    none
    
--*/

{

    list<AdlTree *>::iterator iterTrees;
    list<AdlTree *>::iterator iterTreesEnd;
    list<const AdlToken *>::iterator iterTokens;
    list<const AdlToken *>::iterator iterTokensEnd;

    //
    // List of all Principal tokens used, allows for a single tree traversal
    //

    list<const AdlToken *> listAllPrincipals;

    //
    // Mapping from PLSA_STRING to AdlToken, for detecting which
    // username is invalid
    //

    map<DWORD, const AdlToken *> mapIdxToken;

    //
    // Delayed garbage collection
    //

    stack<PBYTE> stackToFree;

    void * pLastAllocated = NULL;


    AdlStatement::ADL_ERROR_TYPE adlError = AdlStatement::ERROR_NO_ERROR;

    DWORD dwDomainSidSize;
    DWORD numNames;
    DWORD dwIdx;

    PSID pSidTemp;

    LSA_HANDLE LsaPolicy;

    PLSA_UNICODE_STRING pLsaStrings;

    PLSA_REFERENCED_DOMAIN_LIST RefDomains = NULL;
    PLSA_TRANSLATED_SID TranslatedSids = NULL;

    LSA_OBJECT_ATTRIBUTES LsaObjectAttributes;
    LsaObjectAttributes.Length = sizeof(LSA_OBJECT_ATTRIBUTES);
    LsaObjectAttributes.RootDirectory = NULL;
    LsaObjectAttributes.ObjectName = NULL;
    LsaObjectAttributes.Attributes = 0;
    LsaObjectAttributes.SecurityDescriptor = NULL;
    LsaObjectAttributes.SecurityQualityOfService = NULL;
    

    //
    // Verify that the input map is empty as required
    //

    if( !(*mapTokSid).empty() )
    {
        throw AdlStatement::ERROR_FATAL_PARSER_ERROR;
    }

    //
    // STL throws exceptions, catch them here
    //
    try
    {
        //
        // Determine total number of names and place them all in the list
        //
    
        for(numNames = 0, iterTrees = _lTree.begin(), iterTreesEnd = _lTree.end();
            iterTrees != iterTreesEnd;
            iterTrees++)
        {
            iterTokensEnd = (*iterTrees)->GetPrincipals()->end();
    
            for(iterTokens = (*iterTrees)->GetPrincipals()->begin(); 
                iterTokens != iterTokensEnd; iterTokens ++)
            {
                numNames++;
                listAllPrincipals.push_back(*iterTokens);
            }
    
            iterTokensEnd = (*iterTrees)->GetExPrincipals()->end();
    
            for(iterTokens = (*iterTrees)->GetExPrincipals()->begin();
                iterTokens != iterTokensEnd; iterTokens ++)
            {
                numNames++;
                listAllPrincipals.push_back(*iterTokens);
            }
        }
    
        //
        // Allocate the needed memory for the LSA name list
        //
    
        pLsaStrings = (PLSA_UNICODE_STRING)
                        new BYTE[numNames * sizeof(LSA_UNICODE_STRING)];
        
        if( pLsaStrings == NULL )
        {
            adlError = AdlStatement::ERROR_OUT_OF_MEMORY;
            goto error;
        }
        else
        {
            pLastAllocated = pLsaStrings;
            stackToFree.push( (PBYTE)pLsaStrings );
            pLastAllocated = NULL;
        }
    
    
        //      
        // Retrieve name strings here in proper format, DOMAIN\USER
        // 
    
        for(iterTokens = listAllPrincipals.begin(),
                dwIdx = 0,
                iterTokensEnd = listAllPrincipals.end();
            iterTokens != iterTokensEnd;
            iterTokens ++, dwIdx++)
        {
            //
            // Name may be with domain, or just username
            //
    
            if( (*iterTokens)->GetOptValue() != NULL )
            {
                //
                // Extra 1 wchar for the '\' character, 2 bytes per wchar
                //
                pLsaStrings[dwIdx].Length = sizeof(WCHAR) * 
                        ( wcslen((*iterTokens)->GetValue()) +
                          wcslen((*iterTokens)->GetOptValue()) + 1);
            }
            else
            {
                pLsaStrings[dwIdx].Length = sizeof(WCHAR) * 
                             (wcslen((*iterTokens)->GetValue()) + 1);
            }
    
            pLsaStrings[dwIdx].MaximumLength = pLsaStrings[dwIdx].Length 
                                             + sizeof(WCHAR);
    
            pLsaStrings[dwIdx].Buffer = 
                          (LPTSTR)new BYTE[pLsaStrings[dwIdx].MaximumLength];
    
            if( pLsaStrings[dwIdx].Buffer == NULL )
            {
                adlError = AdlStatement::ERROR_OUT_OF_MEMORY;
                goto error;
            }
            else
            {
                pLastAllocated = pLsaStrings[dwIdx].Buffer;
                stackToFree.push((PBYTE)(pLsaStrings[dwIdx].Buffer));
                pLastAllocated = NULL;

                mapIdxToken[dwIdx] = *iterTokens;
            }
    
            if( (*iterTokens)->GetOptValue != NULL )
            {
                wsprintf( (LPTSTR)(pLsaStrings[dwIdx].Buffer), 
                          L"%s%c%s", 
                          (*iterTokens)->GetOptValue(),
                          _pControl->pLang->CH_SLASH,
                          (*iterTokens)->GetValue() );
    
            }
            else
            {
                wsprintf( (LPTSTR)(pLsaStrings[dwIdx].Buffer), 
                          L"%s", 
                          (*iterTokens)->GetValue() );
            }
        }
        
        //
        // Open the LSA policy
        //
    
        NTSTATUS ntErr;
    
        ntErr = LsaOpenPolicy(
                            NULL,
                            &LsaObjectAttributes,
                            POLICY_LOOKUP_NAMES,
                            &LsaPolicy);
    
        if( ntErr != STATUS_SUCCESS )
        {
            adlError = AdlStatement::ERROR_LSA_FAILED;
            goto error;
        }
        
        //
        // Now perform the LsaLookupNames call
        // 
    
        ntErr = LsaLookupNames(
                            LsaPolicy, 
                            numNames,
                            pLsaStrings,
                            &RefDomains,
                            &TranslatedSids);
    
        //
        // Free the LSA handle
        //
    
        LsaClose(LsaPolicy);
    
        //
        // Check for any unknown names
        //
    
        if( ntErr != STATUS_SUCCESS )
        {
            adlError = AdlStatement::ERROR_LSA_FAILED;
            
            if( ntErr == STATUS_SOME_NOT_MAPPED || ntErr == STATUS_NONE_MAPPED )
            {
                
                adlError = AdlStatement::ERROR_UNKNOWN_USER;
    
                //
                // Find first unknown name and return it to user
                //
    
                for( dwIdx = 0; dwIdx < numNames; dwIdx++ )
                {
                    if( TranslatedSids[dwIdx].Use == SidTypeInvalid ||
                        TranslatedSids[dwIdx].Use == SidTypeUnknown )
                    {
                        SetErrorToken(mapIdxToken[dwIdx]);
                        adlError = AdlStatement::ERROR_UNKNOWN_USER;
                    }
                }
            }
    
            goto error;
        }
    
    
        //
        // Assume all names now mapped if this point is reached 
        // Traverse all tokens again, pairing them with SIDs
        //
    
        for(iterTokens = listAllPrincipals.begin(),
                dwIdx = 0,
                iterTokensEnd = listAllPrincipals.end();
            iterTokens != iterTokensEnd;
            iterTokens ++, dwIdx++)
        {
            //
            // Make sure all domains were looked up successfuly
            // Invalid SIDs caught earlier
            //
    
            assert(TranslatedSids[dwIdx].DomainIndex >= 0);
    
            dwDomainSidSize = GetLengthSid(
                RefDomains->Domains[TranslatedSids[dwIdx].DomainIndex].Sid);
            
            //
            // One more RID for the user
            //
    
            pSidTemp = new BYTE[dwDomainSidSize + sizeof(DWORD)];
    
            if( pSidTemp == NULL )
            {
                adlError = AdlStatement::ERROR_OUT_OF_MEMORY;
                goto error;
            }
    
            //
            // Copy the domain SID
            //
    
            CopySid(dwDomainSidSize + sizeof(DWORD), pSidTemp, 
                RefDomains->Domains[TranslatedSids[dwIdx].DomainIndex].Sid);
    
            //
            // If the SID is not a domain SID, and is valid, then we need to add
            // the last RID. If domain SID, then referenced domain is the only
            // SID we need, and we already have copied it
            //
    
            if( TranslatedSids[dwIdx].Use != SidTypeDomain )
            {
                ((SID *)pSidTemp)->SubAuthority[
                                    ((SID *)pSidTemp)->SubAuthorityCount
                                   ] = TranslatedSids[dwIdx].RelativeId;
    
                //
                // Add 1 more subauthority
                //
    
                ((SID *)pSidTemp)->SubAuthorityCount++;
    
            }
            
            //
            // If this fails, need to allocate the single uninserted SID
            // Other SIDs will be deallocated externally
            //

            pLastAllocated = pSidTemp;
            
            (*mapTokSid)[(*iterTokens)] = pSidTemp;
            
            pLastAllocated = NULL;
    

        }
    }

    //
    // Catch STL exceptions here, if exception is thrown, either the above
    // code is wrong, or out of memory. Assume out of memory.
    //

    catch(exception ex)
    {
        adlError = AdlStatement::ERROR_OUT_OF_MEMORY;
    }

error:;
    //
    // Garbage collection
    //

    if( RefDomains != NULL)
    {
        LsaFreeMemory(RefDomains);
    }
    
    if( TranslatedSids != NULL)
    {
        LsaFreeMemory(TranslatedSids);
    }

    //
    // If the grabage stack threw an exception, deallocate last allocated object
    //

    if( pLastAllocated != NULL )
    {
        delete[] (PBYTE)pLastAllocated;
    }

    while( ! stackToFree.empty() )
    {
        //
        // If popping a stack causes an STL exception, we have bigger problems
        // than memory leaks
        //

        delete[] stackToFree.top();
        stackToFree.pop();
    }

    //
    // If any other error code happened earlier, pass it on
    //

    if( adlError != AdlStatement::ERROR_NO_ERROR )
    {
        while( !(*mapTokSid).empty() )
        {
            delete[] (PBYTE) (*((*mapTokSid).begin())).second;
            (*mapTokSid).erase( (*mapTokSid).begin() );
        }
        throw adlError;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\adl\adl.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adl.h

Abstract:

   The header file for the ADL language parser / printer

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/


#include "pch.h"
#include "adlinterface.h"

#include <string>
#include <list>
#include <stack>
#include <map>

using namespace std;

//
// Forward declarations
//

class AdlToken;
class AdlLexer;
class AdlTree;
class AdlStatement;


struct AdlCompareStruct
/*++
   
   Struct:             AdlCompareStruct
   
   Description:        
        
        STL requires custom key comparisons for containers to be supplied in
        such a struct.                
                
--*/

{
    bool operator()(IN const PSID pSid1,
                    IN const PSID pSid2) const;

    bool operator()(IN const WCHAR * sz1,
                    IN const WCHAR * sz2) const;
};



class AdlStatement
/*++
   
   Class:              AdlStatement
   
   Description:        
                
    This class contains a description of a DACL on an object, using the ADL
    language. An instance of this class can be constructed from an ACL or
    from a string statement in the ADL language. Once constructed, an ACL
    or a string statement in the ADL language can be output by an instance
    of this class.
 
   Base Classes:       none
 
   Friend Classes:     AdlLexer 
 
--*/
{
    //
    // Friend classes necessary to access the garbage collection functionality,
    // and for parsing ADL
    //
    
    friend class AdlLexer;

public:

    //
    // Initializes the AdlStatement
    //

    AdlStatement(IN const PADL_PARSER_CONTROL pControl)
        { _bReady = FALSE; _tokError = NULL; _pControl = pControl;
          ValidateParserControl(); }

    
    //
    // Destructor, frees tokens created by this and other classes
    //
    
    ~AdlStatement();

    //
    // Reads in the ADL statement in the input string
    //
    
    void ReadFromString(IN const WCHAR *szInput);

    //
    // Creates an ADL statement equivalent to the given DACL
    //
    
    void ReadFromDacl(IN const PACL pDacl);
    

    //
    // Prints the AdlStatement as a statement in the ADL language,
    // appending it to the allocated STL wstring pSz
    //
    
    void WriteToString(OUT wstring *pSz);

    //
    // Writes the ADL statement to a new DACL and returns the pointer to
    // the new DACL in *ppDacl
    //
    
    void WriteToDacl(OUT PACL *ppDacl);

    //
    // Gets the error string token, if any (depends on error code)
    //

    const AdlToken * GetErrorToken()
        { return _tokError; }

    //
    // This should be used to free any memory allocated by this class
    //

    static void FreeMemory(PVOID pMem)
        {  delete[] (PBYTE) pMem; }



public:

    //
    // AdlStatement throws exceptions of this type on any error
    // Some of the errors will make the offending token available
    // through GetErrorToken()
    //
    
    typedef enum 
    {
        ERROR_NO_ERROR = 0,

        //
        // Internal errors which shoul not occur
        //

        ERROR_FATAL_LEXER_ERROR,
        ERROR_FATAL_PARSER_ERROR,
        ERROR_FATAL_ACL_CONVERT_ERROR,


        //
        // Errors due to the system the code is running on
        //

        ERROR_OUT_OF_MEMORY,
        ERROR_ACL_API_FAILED,
        
        //
        // Possible error due to network problems
        //

        ERROR_LSA_FAILED,


        //
        // If the ADL_PARSER_CONTROL is invalid, this is thrown
        //

        ERROR_INVALID_PARSER_CONTROL,

        //
        // Unknown ACE type encountered in DACL, no token supplied
        //

        ERROR_UNKNOWN_ACE_TYPE,
        
        //
        // User tried to specify impersonation as "user1 as user2"
        // Not currently supported
        //

        ERROR_IMPERSONATION_UNSUPPORTED,
        

        //
        // User error, no token supplied, quote with no closing quote
        //

        ERROR_UNTERMINATED_STRING,

        //
        // The user's statement was not in the ADL language (grammar error)
        // For this error, the offending token is supplied, though
        // the mistake may have happened before that token and was
        // accepted by the grammar
        //

        ERROR_NOT_IN_LANGUAGE,
        

        //
        // User input-related errors
        // For these errors, the offending token is supplied
        //

        //
        // User was not found by LSA lookup
        //

        ERROR_UNKNOWN_USER,
        
        //
        // Permission string was not one of those listed in the parser control
        //

        ERROR_UNKNOWN_PERMISSION,

        //
        // Username contained invalid characters
        //

        ERROR_INVALID_USERNAME,

        //
        // Domain name contained invalid characters
        //

        ERROR_INVALID_DOMAIN,

        //
        // Invalid inheritance specified. Not currently used, since 
        // object type errors are caught at the grammar level
        //

        ERROR_INVALID_OBJECT,

        //
        // Other errors with no token supplied
        //
        
        //
        // A SID in an ACE was not found and mapped to a name by the LSA lookup
        //

        ERROR_UNKNOWN_SID,

        //
        // An access mask was encountered in an ACE that could not be 
        // expressed by the user-specified permission mapping
        //

        ERROR_UNKNOWN_ACCESS_MASK,

        //
        // The ACL cannot be expressed in ADL. This means that, for some access
        // mask bit and set of inheritance flags, there exists a DENY ACE in the
        // ACL with the given bit set in its mask and with the given flags such
        // that either there is no ALLOW ACE which also has this bit set and has
        // the same inheritance flags further down in the ACL, or another 
        // ACE with DIFFERENT inheritance flags and the same bit set follows 
        // this DENY ace. For more information, see the ADL conversion
        // algorithm.
        // 
        ERROR_INEXPRESSIBLE_ACL,

        //
        // User attempted an output operation on AdlStatement without
        // first successfully inputting data from either a string or an ACL
        //

        ERROR_NOT_INITIALIZED

    } ADL_ERROR_TYPE;

private:

    //
    // Internal representation of an ADL statement
    //

    list<AdlTree *> _lTree; // A set of parsed ADL statements, as AdlTree's

    list<AdlTree *>::iterator _iter; // Iterator for the above set

    stack<AdlToken *> _AllocatedTokens; // Tokens to be garbage collected

    PADL_PARSER_CONTROL _pControl;

    const AdlToken * _tokError;

    BOOL _bReady;

private:

    //
    // Goes through the list of AdlTrees, collects a list of all usernames
    // used, and makes a single LSA call to look up all SIDs, inserting the
    // PSIDs into the map by the (unique) token pointer.
    //
    
    void ConvertNamesToSids(
                          IN OUT map<const AdlToken *, PSID> * mapTokSid
                          );

    //
    // Goes throw the DACL, collects a lost of all SIDs used, and makes a 
    // single LSA call to look up all names, inserting the looked up
    // names into the provided map as AdlTokens, which are garbage-
    // collected when the AdlStatement is deleted
    //

    void ConvertSidsToNames(
                      IN const PACL pDacl,
                      IN OUT map<const PSID, const AdlToken *> * mapSidsNames 
                      );

    //
    // Reads a DACL, and constructs an ADL statement from it
    //
    
    void ConvertFromDacl(
                          IN const PACL pDacl
                          );

    //
    // Returns the access mask corresponding to the given right name
    //
    
    ACCESS_MASK MapTokenToMask(
                          IN const AdlToken * tokPermission
                          );

    //
    // Fills in a list ofr const WCHAR *'s matching the passed in access
    // mask, using the preference order given in the grammar
    //

    void MapMaskToStrings(IN     ACCESS_MASK amMask,
                          IN OUT list<WCHAR *> *pList 
                          ) const;

    //
    // Cleans up all of the AdlTrees and all tokens
    //

    void Cleanup();

    //
    // Parses a string in the ADL language
    // This function is generated by YACC from the ADL grammar
    //

    int ParseAdl(IN      const WCHAR *szInput);

    //
    // Returns the current AdlTree, this is used by the ADL parser to create
    // an ADL statement, one tree at a time
    //
    
    AdlTree * Cur();

    //
    // Creates a new AdlTree and pushes it onto the top of the list
    // Used by the ADL parser once the end of a single ADL statement is reached
    //
    
    void Next();


    //
    // If the last added AdlTree is empty, remove it
    // Used by the ADL parser, since it adds an AdlTree at the end
    // of a production instead of the beginning (YACC problem)
    //
    
    void PopEmpty();

    //
    // This is used to validate passed in ADL_PARSER_CONTROL structure
    // referenced by this class
    //

    void ValidateParserControl();

protected:

    //
    // Used to set the error-causing string
    //

    void SetErrorToken(const AdlToken *tokError)
        { _tokError = tokError; }
        
    //
    // Adds a token pointer to be deleted when the AdlStatement is deleted
    //
    
    void AddToken(IN AdlToken *tok);
};




class AdlLexer 
/*++
   
   Class:              AdlLexer
   
   Description:        
                
    This class is the lexer for the ADL language. It allows the ADL parser
    to retrieve tokens from an input string, one token at a time.
 
   Base Classes:       none
 
   Friend Classes:     none
 
--*/
{

private:

    const WCHAR *_input; // The input string

    DWORD _position; // Current position in the input string

    DWORD _start; // Start of current token in the buffer

    DWORD _tokCount; // Number of tokens so far retrieved

    //
    // Pointer to the AdlStatement instance which created this AdlLexer 
    // instance, for token garbage collection
    //
    
    AdlStatement *_adlStat; 

    //
    // Pointer to the ADL_LANGUAGE_SPEC structure defining the language to 
    // be parsed
    //
    
    PADL_LANGUAGE_SPEC _pLang;

    //
    // Mapping of special characters to character codes
    // Special characters are assigned codes above WCHAR max
    //
    
    map<WCHAR, DWORD> _mapCharCode;

    //
    // Mapping from wstring to identify special tokens
    //

    map<const WCHAR *, DWORD, AdlCompareStruct> _mapStringToken;

    //
    // Iterators used by NextToken, this way they are only allocated once
    //
    
    map<WCHAR, DWORD>::iterator _iterEnd;
    map<WCHAR, DWORD>::iterator _iter;


public:

    //
    // Constructs a lexer for an input string
    // NextToken() can then be called
    //
    
    AdlLexer(IN const WCHAR *input,
             IN OUT AdlStatement *adlStat,
             IN const PADL_LANGUAGE_SPEC pLang);

    //
    // Retrieves the next token from the input string
    // Returns 0 for the token type when the end of the string
    // is reached, as the YACC-generated parser requires.
    // A pointer to a new token instance containing the token
    // string, row, col, etc, is stored in *value
    //
    
    DWORD NextToken(OUT AdlToken **value);
};



class AdlToken 
/*++
   
   Class:              AdlToken
   
   Description:        
                
    This class contains the relevant information for a token. It is used in
    parsing ADL.
 
   Base Classes:       none
 
   Friend Classes:     none
 
--*/
{
private:

    DWORD _begin;           // Start position in the buffer

    DWORD _end;             // End position in the buffer

    wstring _value;         // String value of token
    
    //
    // This allows for collapsing multi-part tokens
    // such as user@domain.domain.domain into a single
    // token by the parser after the individual subparts
    // are verified
    //
    
    wstring _optValue;  
    
public:

    //
    // Constructor for a single-part token
    //
    
    AdlToken(IN const WCHAR *value,
             IN DWORD begin,
             IN DWORD end
             )
        { _value.append(value); _begin = begin; _end = end; }
    
    //
    // Constructor for a multi-part token
    //
    
    AdlToken(IN const WCHAR *value,
             IN const WCHAR *optValue,
             IN DWORD begin,
             IN DWORD end
             )
        { _value.append(value); _optValue.append(optValue);
          _begin = begin; _end = end; }


    //
    // Accessors
    //
    
    DWORD GetStart() const
        { return _begin; }
    
    DWORD GetEnd() const
        { return _end; }

    const WCHAR * GetValue() const
        { return _value.c_str(); }

    const WCHAR * GetOptValue() const
        { return (_optValue.empty() ? NULL : _optValue.c_str()); }
};




class AdlTree
/*++
   
   Class:              AdlTree
   
   Description:        
                
        This class contains the parsed information from a single ADL
        substatement, still in string form. The inheritance information
        is converted to a mask. The names contained are not necessarily
        valid however.
                
   Base Classes:       none
 
   Friend Classes:     none
 
--*/
{
private:

    list<const AdlToken *> _lpTokPrincipals;
    list<const AdlToken *> _lpTokExPrincipals;
    list<const AdlToken *> _lpTokPermissions;

    DWORD _dwInheritFlags;

public:

    //
    // Default to inherit-only, since "this object" must be specified
    // to clear that bit
    //

    AdlTree()
        { _dwInheritFlags = INHERIT_ONLY_ACE; }
    //
    // This outputs the ADL statement to stdout
    // Later to go to a string
    //
    
    void PrintAdl(wstring *pSz, PADL_PARSER_CONTROL pControl);

    //
    // Accessors/mutators
    // The Add*/Set* mutators are used by the YACC-generated AdlParse() 
    // function to store information as it is parsed, adding the tokens
    // to the correct places in the AdlTree
    //
    
    void AddPrincipal(IN const AdlToken * pTokPrincipal)
        { _lpTokPrincipals.push_back(pTokPrincipal); }

    void AddExPrincipal(IN const AdlToken * pTokPrincipal)
        { _lpTokExPrincipals.push_back(pTokPrincipal); }        

    void AddPermission(IN const AdlToken * pTokPermission)
        { _lpTokPermissions.push_back(pTokPermission); }

    //
    // Accessors used by AdlStat conversion functions
    //

    list<const AdlToken *> * GetPrincipals()  
        { return &_lpTokPrincipals; }

    list<const AdlToken *> * GetExPrincipals()  
        { return &_lpTokExPrincipals; }

    list<const AdlToken *> * GetPermissions() 
        { return &_lpTokPermissions; }

    //
    // Set/unset/get inheritance flags
    //

    void SetFlags(DWORD dwFlags)
        { _dwInheritFlags |= dwFlags; }

    void UnsetFlags(DWORD dwFlags)
        { _dwInheritFlags &= (~dwFlags); }

    void OverwriteFlags(DWORD dwFlags)
        { _dwInheritFlags = dwFlags; }

    DWORD GetFlags()
        { return _dwInheritFlags; }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\adl\adlconvert.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adlconvert.h

Abstract:

   The private header file for the ADL conversion routines

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/


#pragma once


//
// Weights for the weight function to determine the optimal pops
// These weights can be modified to change the behavior of the conversion.
// The algorithm selects an action by trying to maximize the weight of the 
// action. For more flexibility (such as squaring some quentities, etc),
// the algorithm itself should be changed in FindOptimalPop()
//
// RESTRICTION: The weight of popping a block of any height off a single stack 
// 				MUST be positive
//

//
// This quantity is added to the weight of the action for every additional
// permission bit expressed by the ADL statement created by this action.
//

#define WEIGHT_PERM_BIT (4)

//
// This quantity is added to the weight of the action for every additional
// Principal expressed by the ADL statement created by this action.
//

#define WEIGHT_STACK_HEIGHT (7)

//
// This quantity is added to the weight of the action for every item which
// will have to be popped off in order to take this action. See the algorithm
// description in adlconvert.cpp for more details. 
//

#define WEIGHT_ITEM_ABOVE_POP (-5)


//
// This quantity is added for every permission name beyond the first needed
// to express a given access mask. This should be a penalty, however for
// better results this should NOT negate the bonus from WEIGHT_PERM_BIT.
// Therefore, if this is negative, it should be greater than (- WEIGHT_PERM_BIT)
//

#define WEIGHT_PERMISSION_NAME (-1)

//
// The stacks in the DACL->ADL conversion consist of these elements
//

typedef struct
{
    PSID pSid;
    DWORD dwFlags;
    BOOL bAllow;
} BIT_STACK_ELEM, *PBIT_STACK_ELEM;


//
// Forward declarations for DACL->ADL conversion
//

DWORD GetStackBlockSize(
                        IN const PBIT_STACK_ELEM pStack,
                        IN DWORD dwStartOffset,
                        IN DWORD dwStackSize 
                        );



void ConvertDaclToStacks(
                        IN      const PACL pDacl,
                        IN      const PADL_PARSER_CONTROL pControl,
                        OUT     DWORD pdwStackSize[32],
                        OUT     PBIT_STACK_ELEM pStacks[32]
                        );

BOOL FindBlockInStack(
                        IN      const PBIT_STACK_ELEM pBlock,
                        IN      const DWORD dwBlockSize,
                        IN      const PBIT_STACK_ELEM pStack,
                        IN      const DWORD dwStackSize,
                        IN      const DWORD dwStackTop,
                        OUT     PDWORD pdwBlockStart
                        );

BOOL FindOptimalPop(
                        IN      const PADL_PARSER_CONTROL pControl,
                        IN      const PBIT_STACK_ELEM pStacks[32],
                        IN      const DWORD pdwStackSize[32],
                        IN      const DWORD pdwStackTop[32],
                        OUT     PDWORD pdwStacksPopped,
                        OUT     PDWORD pdwBlockSize,
                        OUT     DWORD pdwPopOffsets[32]
                        );

void ConvertStacksToPops(
                        IN      const PADL_PARSER_CONTROL pControl,
                        IN      const PBIT_STACK_ELEM pStacks[32],
                        IN      const DWORD pdwStackSize[32],
                        IN      const DWORD pdwStackTop[32],
                        OUT     list< pair<DWORD, DWORD> > * pListPops
                        );

DWORD NumStringsForMask(
						IN     const PADL_PARSER_CONTROL pControl,
						IN     ACCESS_MASK amMask
						);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\adl\adlinterface.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adlinterface.h

Abstract:

    The interface used to specify a language definition to the ADL parser

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/


#pragma once

//
// YACC-generated tokens
// Language type tokens are in this file
//

#include "tokens.h"

//
// Languages currently supported by the parser
// The ADL_LANGUAGE_* parameter should be used in the ADL_LANGUAGE_SPEC
// structure
//

#define ADL_LANGUAGE_ENGLISH TK_LANG_ENGLISH
#define ADL_LANGUAGE_REVERSE TK_LANG_REVERSE


typedef struct 
/*++
   
   Struct:              ADL_MASK_STRING
   
   Description:        
                
        This is used to specify a mapping between permission strings
        and access masks in the ADL_PARSER_CONTROL structure.
        
        A list of these is traversed in order to map an access mask
        to a set of strings, or a set of strings to an access mask
 
--*/
{
    ACCESS_MASK mask;
    WCHAR *str;
} ADL_MASK_STRING, *PADL_MASK_STRING;


//
// ADL Language Definition, includes grammar type, characters,
// and special token strings
//

typedef struct
/*++
   
   Struct:              ADL_LANGUAGE_SPEC
   
   Description:        
        
        This is used to define the locale-specific detail about the language
        to be used by the ADL parser, such as all specific characters and
        string tokens.
        
        Requirement: All CH_* characters must be distinct. If two of the
                     characters were identical, the lexer behavior would be
                     undefined.
     
        Requirement: All SZ_ strings must be non-null, NULL terminated,
                     and distinct. Distinctness is not verified, and is 
                     left to the user.
                     
        Requirement: dwLanguageType must be one of the language types supported
                     by the given version of the parser. Valid languages are
                     defined above.
 
--*/
{
    //
    // Grammar type (see adl.y for supported grammar types)
    //
    
    DWORD dwLanguageType;

    //
    // Whitespace
    //
    
    WCHAR CH_NULL;
    WCHAR CH_SPACE;
    WCHAR CH_TAB;
    WCHAR CH_NEWLINE;
    WCHAR CH_RETURN;

    //
    // Separators
    //
    
    WCHAR CH_QUOTE;
    WCHAR CH_COMMA;
    WCHAR CH_SEMICOLON;
    WCHAR CH_OPENPAREN;
    WCHAR CH_CLOSEPAREN;

    //
    // Domain / username specifiers
    //
    
    WCHAR CH_AT;
    WCHAR CH_SLASH;
    WCHAR CH_PERIOD;

    //
    // padding
    //
    
    WORD sbz0;

    //
    // ADL-specific tokens
    //
    
    WCHAR * SZ_TK_AND;
    WCHAR * SZ_TK_EXCEPT;
    WCHAR * SZ_TK_ON;
    WCHAR * SZ_TK_ALLOWED;
    WCHAR * SZ_TK_AS;

    //
    // Inheritance specifier tokens
    // 
    
    WCHAR * SZ_TK_THIS_OBJECT;
    WCHAR * SZ_TK_CONTAINERS;
    WCHAR * SZ_TK_OBJECTS;
    WCHAR * SZ_TK_CONTAINERS_OBJECTS;
    WCHAR * SZ_TK_NO_PROPAGATE;

    
} ADL_LANGUAGE_SPEC, *PADL_LANGUAGE_SPEC;


typedef struct
/*++
   
   Struct:              ADL_PARSER_CONTROL
   
   Description:        
        
        This is used to define the behavior of the ADL parser / printer.
        
        Requirement: pLand be non-NULL and valid (see 
                     comments in ADL_LANGUAGE_SPEC definition).
     
        Requirement: pPermissions must be non-null and must be an array of 1
                     or more ADL_MASK_STRING structs with non-NULL strings
                     and non-zero masks. This must be terminated by an entry
                     with a NULL string and a 0 mask.
                     
        Requirement: pPermissions may NOT contain any access masks such that
                     the bitwise AND of that mask and either amNeverSet or
                     amSetAllow is non-zero.
        
        Requirement: For any access mask or subset of one that could be 
                     encountered in the given use of ADL, there must exist a set
                     of pPermissions entries such that the logical OR of that 
                     set (ANDed with the negation of amNeverSet and amSetAllow) 
                     is equal to the access mask encountered. This means that
                     any bit used should have a name associated with it, though
                     masks with multiple bits may be specified.
                     
        Requirement: If mask B is a subset of mask A, then the entry for mask
                     A MUST appear before the entry for mask B, otherwise there
                     will be redundant permission names in the produced ADL
                     statements.
                      
--*/
{
    //
    // Language specification
    //

    PADL_LANGUAGE_SPEC pLang;

    //
    // Permission mapping
    //

    PADL_MASK_STRING pPermissions;

    //
    // Special cases for permission bits never to be set in an ACE
    // such as MAXIMUM_ALLOWED and ACCESS_SYSTEM_SECURITY
    //

    ACCESS_MASK amNeverSet;

    //
    // Special cases for bits which are to be set in all allows
    // and never set in denies. 
    //
    // With files, for example, this is the SYNCHRONIZE bit
    //

    ACCESS_MASK amSetAllow;


} ADL_PARSER_CONTROL, *PADL_PARSER_CONTROL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\adl\adllexer.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

   adllexer.cpp

Abstract:

   Implementation of the lexer for the ADL language

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/


#include "adl.h"

//
// Constant values outside WCHAR range, for special characters
//

#define CHAR_COMMA      65538
#define CHAR_QUOTE      65539
#define CHAR_SEMICOLON  65540
#define CHAR_OPENPAREN  65541
#define CHAR_CLOSEPAREN 65542
#define CHAR_NULL       65543
#define CHAR_NEWLINE    65544
#define CHAR_RETURN     65545
#define CHAR_TAB        65546
#define CHAR_SPACE      65547
#define CHAR_AT         65548
#define CHAR_SLASH      65549
#define CHAR_PERIOD     65550

//
// States of the lexer DFA
//

#define STATE_WHITESPACE    0
#define STATE_BEGIN         1
#define STATE_IDENT         2
#define STATE_QUOTE         3
#define STATE_DONE          4


//
// If the character is found in the special character map, use the special
// symbol (>65535), otherwise use the regular character value
//

#define RESOLVE_CHAR(CHAR, MAP, ITER, ITEREND) \
   ((((ITER) = (MAP).find((CHAR)) ) == (ITEREND) ) ? (CHAR) : (*(ITER)).second)
        


AdlLexer::AdlLexer(IN       const WCHAR *input,
                   IN OUT   AdlStatement *adlStat,
                   IN       const PADL_LANGUAGE_SPEC pLang) 
/*++

Routine Description:

    Constructor for the AdlLexer. Initializes the mapping for finding special 
    characters, and other initial state information   

Arguments:

    input   -   The input string
    
    adlStat -   The AdlStatement instance, for token garbage collection
    
    pLang   -   The ADL language description

Return Value:
    
    none    
    
--*/

{

    _input = input;
    _pLang = pLang;
    _adlStat = adlStat;

    _position = 0;
    _tokCount = 0;


    //
    // Special character mapping
    //

    _mapCharCode[_pLang->CH_NULL] = CHAR_NULL;
    _mapCharCode[_pLang->CH_SPACE] = CHAR_SPACE;
    _mapCharCode[_pLang->CH_TAB] = CHAR_TAB;
    _mapCharCode[_pLang->CH_NEWLINE] = CHAR_NEWLINE;
    _mapCharCode[_pLang->CH_RETURN] = CHAR_RETURN;
    _mapCharCode[_pLang->CH_QUOTE] = CHAR_QUOTE;
    _mapCharCode[_pLang->CH_COMMA] = CHAR_COMMA;
    _mapCharCode[_pLang->CH_SEMICOLON] = CHAR_SEMICOLON;
    _mapCharCode[_pLang->CH_OPENPAREN] = CHAR_OPENPAREN;
    _mapCharCode[_pLang->CH_CLOSEPAREN] = CHAR_CLOSEPAREN;
    _mapCharCode[_pLang->CH_AT] = CHAR_AT;
    _mapCharCode[_pLang->CH_SLASH] = CHAR_SLASH;
    _mapCharCode[_pLang->CH_PERIOD] = CHAR_PERIOD;

    //
    // Only find end of map once
    //

    _iterEnd = _mapCharCode.end();


    //
    // Place all special tokens into a map, for O(log n) string searches
    //

    _mapStringToken[_pLang->SZ_TK_AND] = TK_AND;
    _mapStringToken[_pLang->SZ_TK_EXCEPT] = TK_EXCEPT;
    _mapStringToken[_pLang->SZ_TK_ON] = TK_ON;
    _mapStringToken[_pLang->SZ_TK_ALLOWED] = TK_ALLOWED;
    _mapStringToken[_pLang->SZ_TK_AS] = TK_AS;
    _mapStringToken[_pLang->SZ_TK_THIS_OBJECT] = TK_THIS_OBJECT;
    _mapStringToken[_pLang->SZ_TK_CONTAINERS] = TK_CONTAINERS;
    _mapStringToken[_pLang->SZ_TK_OBJECTS] = TK_OBJECTS;
    _mapStringToken[_pLang->SZ_TK_CONTAINERS_OBJECTS] = TK_CONTAINERS_OBJECTS;
    _mapStringToken[_pLang->SZ_TK_NO_PROPAGATE] = TK_NO_PROPAGATE;

}


DWORD AdlLexer::NextToken(OUT AdlToken **value) 
/*++

Routine Description:

    This retrieves the next token from the input string. This is basically a
    DFA which begins in the WHITESPACE state, and runs until it reaches
    the DONE state, at which point it returns a token. 
    
Arguments:

    value   -   Pointer to a new token containing the string value
                is stored in *value
                
Return Value:
    
    DWORD   -   The token type, as #define'd by YACC in tokens.h
    
--*/
{

    //
    // Initial DFA state
    //

    DWORD state = STATE_WHITESPACE;
    
    DWORD tokType = TK_ERROR;
    
    wstring curToken;
    
    DWORD dwInput;

    DWORD dwTokStart = 0;

    // 
    // First token should be the grammar type
    //

    if( _tokCount == 0 ) 
    {
        _tokCount++;
        return _pLang->dwLanguageType;
        
    }


    dwInput = RESOLVE_CHAR(_input[_position], _mapCharCode, _iter, _iterEnd);

    while( state != STATE_DONE ) 
    {
        switch( state ) 
        {

        case STATE_WHITESPACE:

            switch( dwInput ) 
            {
            
            case CHAR_NULL:
                tokType = 0;
                state = STATE_DONE;
                break;

            case CHAR_NEWLINE:
                _position++;
                dwInput = RESOLVE_CHAR(_input[_position],
                                       _mapCharCode,
                                       _iter,
                                       _iterEnd);

                break;

            case CHAR_RETURN:
                _position++;
                dwInput = RESOLVE_CHAR(_input[_position],
                                       _mapCharCode,
                                       _iter,
                                       _iterEnd);
                
                break;

            case CHAR_SPACE:
                _position++;
                dwInput = RESOLVE_CHAR(_input[_position],
                                       _mapCharCode,
                                       _iter,
                                       _iterEnd);
                break;

            case CHAR_TAB:
                _position++;
                dwInput = RESOLVE_CHAR(_input[_position],
                                       _mapCharCode,
                                       _iter,
                                       _iterEnd);
                break;

            default:
                state = STATE_BEGIN;
                break;
            }
            
            break;
            
        case STATE_BEGIN:

            dwTokStart = _position;

            tokType = TK_ERROR;

            switch( dwInput ) 
            {
            case CHAR_NULL:
                state = STATE_DONE;
                break;

            case CHAR_COMMA:
                if( tokType == TK_ERROR )
                {
                    tokType = TK_COMMA;
                }

            case CHAR_OPENPAREN:
                if( tokType == TK_ERROR )
                {
                    tokType = TK_OPENPAREN;
                }

            case CHAR_CLOSEPAREN:
                if( tokType == TK_ERROR )
                {
                    tokType = TK_CLOSEPAREN;
                }

            case CHAR_SEMICOLON:
                if( tokType == TK_ERROR )
                { 
                    tokType = TK_SEMICOLON;
                }

            case CHAR_AT:
                if( tokType == TK_ERROR )
                { 
                    tokType = TK_AT;
                }

            case CHAR_SLASH:
                if( tokType == TK_ERROR )
                {
                    tokType = TK_SLASH;
                }

            case CHAR_PERIOD:
                if( tokType == TK_ERROR )
                {
                    tokType = TK_PERIOD;
                }

                //
                // Same action for all special single-char tokens
                //
                curToken.append( &(_input[_position]), 1 );
                _position++;
                dwInput = RESOLVE_CHAR(_input[_position],
                                       _mapCharCode,
                                       _iter,
                                       _iterEnd);

                state = STATE_DONE;
                break;
            
            case CHAR_QUOTE:
                _position++;
                dwInput = RESOLVE_CHAR(_input[_position],
                                       _mapCharCode,
                                       _iter,
                                       _iterEnd);

                state = STATE_QUOTE;
                tokType = TK_IDENT;
                break;

            default:
                state = STATE_IDENT;
                tokType = TK_IDENT;
                break;
            }

            break;

        case STATE_IDENT:

            switch( dwInput ) 
            {
            case CHAR_NULL:
            case CHAR_COMMA:
            case CHAR_OPENPAREN:
            case CHAR_CLOSEPAREN:
            case CHAR_SEMICOLON:
            case CHAR_NEWLINE:
            case CHAR_RETURN:
            case CHAR_TAB:
            case CHAR_SPACE:
            case CHAR_AT:
            case CHAR_SLASH:
            case CHAR_PERIOD:
            case CHAR_QUOTE:

                state = STATE_DONE;
                break;

            default:
                curToken.append( &(_input[_position]), 1 );
                _position++;
                dwInput = RESOLVE_CHAR(_input[_position],
                                       _mapCharCode,
                                       _iter,
                                       _iterEnd);

                break;
            }

            break;

        case STATE_QUOTE:

            switch( dwInput ) 
            {
            case CHAR_NULL:
            case CHAR_TAB:
            case CHAR_NEWLINE:
            case CHAR_RETURN:
                throw AdlStatement::ERROR_UNTERMINATED_STRING;
                break;
            

            case CHAR_QUOTE:

                _position++;
                dwInput = RESOLVE_CHAR(_input[_position],
                                       _mapCharCode,
                                       _iter,
                                       _iterEnd);
                state = STATE_DONE;
                break;

            default:
                curToken.append( &(_input[_position]), 1 );
                _position++;
                dwInput = RESOLVE_CHAR(_input[_position],
                                       _mapCharCode,
                                       _iter,
                                       _iterEnd);
                break;
            }

            break;

        default:

            //
            // Should never get here, well-defined states
            //

            assert(FALSE);
            break;
        }
    }
    
    //
    // Done state was reached
    // Export the string and column/row info in YACC-form here
    //
    
    AdlToken *outVal;
    
    outVal = new AdlToken(curToken.c_str(), dwTokStart, _position - 1);
    
    _adlStat->AddToken(outVal);

    //
    // Check if the string is a special token, case-insensitive
    //

    if( _mapStringToken.find(outVal->GetValue()) != _mapStringToken.end() )
    {
        tokType = _mapStringToken[outVal->GetValue()];
    }


    *value = outVal;

	// 
	// Set this token to be the error token. This way, if the string is
	// not accepted by the parser, we know at which token the parser failed
	// If another error occurs later, this value will be overwritten
	//

	_adlStat->SetErrorToken(outVal);

    _tokCount++;

    return tokType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\adl\adlparser.cpp ===
#ifndef lint
static char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define YYPREFIX "yy"
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

   adl.y/adlparser.cpp

Abstract:

   YACC parser definition for the ADL language
   AdlParser::ParseAdl() function

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/

#include "pch.h"
#include "adl.h"

/**/
/* YACC generates some long->short automatic conversion, disable the warning*/
/**/
#pragma warning(disable : 4242)

/**/
/* ISSUE-2000/08/28-t-eugenz*/
/* This is a private netlib function. */
/**/
    
extern "C" NET_API_STATUS
NetpwNameValidate(
    IN  LPTSTR  Name,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

/**/
/* Name types for I_NetName* and I_NetListCanonicalize*/
/**/

#define NAMETYPE_USER           1
#define NAMETYPE_PASSWORD       2
#define NAMETYPE_GROUP          3
#define NAMETYPE_COMPUTER       4
#define NAMETYPE_EVENT          5
#define NAMETYPE_DOMAIN         6
#define NAMETYPE_SERVICE        7
#define NAMETYPE_NET            8
#define NAMETYPE_SHARE          9
#define NAMETYPE_MESSAGE        10
#define NAMETYPE_MESSAGEDEST    11
#define NAMETYPE_SHAREPASSWORD  12
#define NAMETYPE_WORKGROUP      13



/**/
/* Validate various tokens, with error handling*/
/* have to cast away const, since NetpNameValidate takes a non-const for some*/
/* reason*/
/**/

#define VALIDATE_USERNAME(TOK) \
    if( NetpwNameValidate( \
                          (WCHAR *)(TOK)->GetValue(), \
                          NAMETYPE_USER, \
                          0) != ERROR_SUCCESS) \
    { \
        this->SetErrorToken( TOK ); \
        throw AdlStatement::ERROR_INVALID_USERNAME; \
    }

#define VALIDATE_DOMAIN(TOK) \
    if( NetpwNameValidate( \
                          (WCHAR *)(TOK)->GetValue(), \
                          NAMETYPE_DOMAIN, \
                          0) != ERROR_SUCCESS) \
    { \
        this->SetErrorToken( TOK ); \
        throw AdlStatement::ERROR_INVALID_DOMAIN; \
    }
    
#define VALIDATE_PERMISSION(TOK) \
    { \
        for(DWORD i = 0;; i++) \
        { \
            if( (_pControl->pPermissions)[i].str == NULL ) \
            { \
                this->SetErrorToken( TOK ); \
                throw AdlStatement::ERROR_UNKNOWN_PERMISSION; \
            } \
            if(!_wcsicmp(TOK->GetValue(), \
                         (_pControl->pPermissions)[i].str)) \
            { \
                break; \
            } \
        } \
    }


/**/
/* YACC value type*/
/**/

#define YYSTYPE AdlToken *

/**/
/* YACC error handler: raise an exception*/
/**/

void yyerror(char *szErr)
{
    throw AdlStatement::ERROR_NOT_IN_LANGUAGE;
}



#define TK_ERROR 257
#define TK_IDENT 258
#define TK_AT 259
#define TK_SLASH 260
#define TK_PERIOD 261
#define TK_COMMA 262
#define TK_OPENPAREN 263
#define TK_CLOSEPAREN 264
#define TK_SEMICOLON 265
#define TK_EXCEPT 266
#define TK_ON 267
#define TK_ALLOWED 268
#define TK_AND 269
#define TK_AS 270
#define TK_THIS_OBJECT 271
#define TK_CONTAINERS 272
#define TK_OBJECTS 273
#define TK_CONTAINERS_OBJECTS 274
#define TK_NO_PROPAGATE 275
#define TK_LANG_ENGLISH 276
#define TK_LANG_REVERSE 277
#define YYERRCODE 256
short yylhs[] = {                                        -1,
    0,    0,    1,    1,    3,    3,    2,    2,    8,    8,
    4,    4,    4,    5,    5,    5,    6,    6,    6,   10,
    7,    7,    7,    9,    9,   13,   13,   13,   14,   14,
   12,   12,   12,   12,   12,   11,   11,   11,   11,   11,
   11,   11,
};
short yylen[] = {                                         2,
    2,    2,    1,    2,   10,    6,    1,    2,   10,    6,
    1,    3,    3,    1,    3,    3,    1,    3,    3,    1,
    1,    3,    3,    1,    3,    3,    3,    1,    1,    3,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,
};
short yydefred[] = {                                      0,
    0,    0,    0,   42,   36,   40,   41,   37,   38,   39,
    0,    3,    0,   11,    0,    0,    0,    0,    0,    0,
    7,    4,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    8,    0,   12,    0,    0,   17,   20,   13,   29,
    0,   25,   27,   30,    0,   14,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   19,   31,   32,   33,
   34,   35,    0,   21,   18,   15,    0,   16,    0,    0,
    0,    6,    0,    0,   10,    0,   23,   22,    0,    0,
    0,    0,    0,    5,    9,
};
short yydgoto[] = {                                       3,
   11,   19,   12,   13,   45,   36,   63,   21,   14,   37,
   15,   64,   16,   17,
};
short yysindex[] = {                                   -222,
 -238, -210,    0,    0,    0,    0,    0,    0,    0,    0,
 -238,    0, -184,    0, -249, -257, -136, -248, -210, -254,
    0,    0, -238, -240, -238, -238, -238, -238, -238, -238,
 -238,    0, -238,    0, -238, -179,    0,    0,    0,    0,
 -227,    0,    0,    0, -224,    0, -176, -220, -238, -152,
 -238, -238, -238, -238, -152, -216,    0,    0,    0,    0,
    0,    0, -173,    0,    0,    0, -168,    0, -167, -238,
 -152,    0, -152, -238,    0, -163,    0,    0, -159, -152,
 -152, -153, -151,    0,    0,
};
short yyrindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   41,    0,    0,    0, -199, -187,    0,    0,   80,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 -196,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,
};
short yygindex[] = {                                      0,
    0,    0,   76,   -2,   62,  -31,  -44,   86,  -19,  -28,
  -24,  -49,   79,   88,
};
#define YYTABLESIZE 125
short yytable[] = {                                      20,
   38,   47,   40,   34,   43,   44,   39,   23,   38,   27,
   69,   46,   28,   33,   26,   46,   20,   31,    4,    5,
   57,   77,   65,   78,   38,   35,   38,    6,    7,    8,
    9,   10,   66,   30,   68,   82,   83,   52,   76,   53,
    1,   52,   79,   56,   54,   38,    4,    5,   54,   38,
   67,   70,   18,    1,    2,    6,    7,    8,    9,   10,
   29,   29,   28,   28,   28,   26,   26,   26,   28,   28,
   28,   26,   26,   26,   24,   24,   24,   23,   24,    2,
   24,   24,   49,   25,   26,   49,   22,   50,   71,   51,
   55,   72,   51,   23,   71,   73,   48,   75,   49,   74,
   26,   73,   49,   80,   32,   51,   42,   81,   71,   51,
   71,   84,    0,   85,   41,   73,    0,   73,   58,   59,
   60,   61,   62,   29,   30,
};
short yycheck[] = {                                       2,
   25,   33,   27,   23,   29,   30,   26,  262,   33,  259,
   55,   31,  270,  268,  269,   35,   19,  266,  257,  258,
   49,   71,   51,   73,   49,  266,   51,  266,  267,  268,
  269,  270,   52,  261,   54,   80,   81,  262,   70,  264,
    0,  262,   74,  264,  269,   70,  257,  258,  269,   74,
   53,  268,  263,  276,  277,  266,  267,  268,  269,  270,
  260,  261,  262,  263,  264,  262,  263,  264,  268,  269,
  270,  268,  269,  270,  262,  263,  264,  262,  263,    0,
  268,  269,  262,  268,  269,  262,   11,  267,  262,  269,
  267,  265,  269,  262,  262,  269,   35,  265,  262,  268,
  269,  269,  262,  267,   19,  269,   28,  267,  262,  269,
  262,  265,   -1,  265,   27,  269,   -1,  269,  271,  272,
  273,  274,  275,  260,  261,
};
#define YYFINAL 3
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 277
#ifndef YYSTYPE
typedef int YYSTYPE;
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
#define yystacksize YYSTACKSIZE
#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
AdlStatement::ParseAdl(const WCHAR *szInput)
{
    register int yym, yyn, yystate;

	int yydebug = 0;
	int yynerrs;
	int yyerrflag;
	int yychar;
	short *yyssp;
	YYSTYPE *yyvsp;
	YYSTYPE yyval;
	YYSTYPE yylval;
	short yyss[YYSTACKSIZE];
	YYSTYPE yyvs[YYSTACKSIZE];
	AdlLexer Lexer(szInput, this, _pControl->pLang);


    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = Lexer.NextToken(&yylval)) < 0) yychar = 0;
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        if (yyssp >= yyss + yystacksize - 1)
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#ifdef lint
    goto yynewerror;
#endif
    yyerror("syntax error");
#ifdef lint
    goto yyerrlab;
#endif
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
                if (yyssp >= yyss + yystacksize - 1)
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
{
            /**/
            /* At the end of all ADL_STATEMENT's*/
            /* pop the extra AdlTree that was pushed*/
            /* on when the last ADL_STATEMENT*/
            /* was completed*/
            /**/
            
            this->PopEmpty();
        }
break;
case 2:
{
            /**/
            /* At the end of all ADL_STATEMENT's*/
            /* pop the extra AdlTree that was pushed*/
            /* on when the last ADL_STATEMENT*/
            /* was completed*/
            /**/
            
            this->PopEmpty();
        }
break;
case 5:
{
            this->Next();
        }
break;
case 6:
{
            this->Next();
        }
break;
case 9:
{
            this->Next();
        }
break;
case 10:
{
            this->Next();
        }
break;
case 11:
{
            this->Cur()->AddPrincipal( yyvsp[0] ); 
        }
break;
case 12:
{       
            this->Cur()->AddPrincipal( yyvsp[0] ); 
        }
break;
case 13:
{       
            this->Cur()->AddPrincipal( yyvsp[0] ); 
        }
break;
case 14:
{
            this->Cur()->AddExPrincipal( yyvsp[0] ); 
        }
break;
case 15:
{
            this->Cur()->AddExPrincipal( yyvsp[0] ); 
        }
break;
case 16:
{
            this->Cur()->AddExPrincipal( yyvsp[0] ); 
        }
break;
case 17:
{       
            this->Cur()->AddPermission( yyvsp[0] ); 
        }
break;
case 18:
{       
            this->Cur()->AddPermission( yyvsp[0] );
        }
break;
case 19:
{       
            this->Cur()->AddPermission( yyvsp[0] );
        }
break;
case 20:
{
            VALIDATE_PERMISSION(yyvsp[0]);
        }
break;
case 25:
{       
            /**/
            /* For now, impersonation is not supported*/
            /**/
            
            throw AdlStatement::ERROR_IMPERSONATION_UNSUPPORTED;
        }
break;
case 26:
{       
            VALIDATE_USERNAME(yyvsp[-2]);
            VALIDATE_DOMAIN(yyvsp[0]);
            AdlToken *newTok = new AdlToken(yyvsp[-2]->GetValue(),
                                            yyvsp[0]->GetValue(),
                                            yyvsp[-2]->GetStart(),
                                            yyvsp[0]->GetEnd());
            this->AddToken(newTok);
            yyval = newTok;
        }
break;
case 27:
{       

            VALIDATE_USERNAME(yyvsp[0]);
            VALIDATE_DOMAIN(yyvsp[-2]);
            AdlToken *newTok = new AdlToken(yyvsp[0]->GetValue(),
                                            yyvsp[-2]->GetValue(),
                                            yyvsp[-2]->GetStart(), 
                                            yyvsp[0]->GetEnd());
            this->AddToken(newTok);
            yyval = newTok;
        }
break;
case 28:
{
            VALIDATE_USERNAME(yyvsp[0]);
            yyval = yyvsp[0];
        }
break;
case 30:
{
            /**/
            /* Concatenate into single domain string*/
            /**/
            
            wstring newStr;
            newStr.append(yyvsp[-2]->GetValue());
            newStr.append(yyvsp[-1]->GetValue());
            newStr.append(yyvsp[0]->GetValue());
            AdlToken *newTok = new AdlToken(newStr.c_str(),
                                            yyvsp[-2]->GetStart(),
                                            yyvsp[-2]->GetEnd());
            this->AddToken(newTok);
            yyval = newTok;
        }
break;
case 31:
{
            this->Cur()->UnsetFlags(INHERIT_ONLY_ACE);
        }
break;
case 32:
{
            this->Cur()->SetFlags(CONTAINER_INHERIT_ACE);
        }
break;
case 33:
{
            this->Cur()->SetFlags(OBJECT_INHERIT_ACE);
        }
break;
case 34:
{
            this->Cur()->SetFlags(CONTAINER_INHERIT_ACE);
            this->Cur()->SetFlags(OBJECT_INHERIT_ACE);
        }
break;
case 35:
{
            this->Cur()->SetFlags(NO_PROPAGATE_INHERIT_ACE);
        }
break;
case 42:
{
            /**/
            /* This should never happen*/
            /**/

            throw AdlStatement::ERROR_FATAL_LEXER_ERROR;
        }
break;
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = Lexer.NextToken(&yylval)) < 0) yychar = 0;
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
    if (yyssp >= yyss + yystacksize - 1)
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    return (1);
yyaccept:
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\adl\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <authz.h>
#include <sddl.h>
#include <assert.h>
#include <winnls.h>

#define SECURITY_WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\adl\makefile.inc ===
YACC=byacc
GRAMMAR=adl.y
YACCPARAMS=-d -l
SED=sed
SEDCMD=adlyacc.sed
OUTPUTC=adlparser.cpp
OUTPUTH=tokens.h
CC=cl
LINK=link
INCLUDE=d:\nt\public\sdk\inc
CCOPTS=-I$(INCLUDE)

parseronly: parser

test:       parser lexer test testlexer.o
            $(LINK) testlexer.o adllexer.o /link

parser:     adl.y adlyacc.sed
            $(YACC) $(YACCPARAMS) $(GRAMMAR)
            $(SED) -f $(SEDCMD) y_tab.c > $(OUTPUTC)
            rm -f y_tab.c $(OUTPUTH)
            ren y_tab.h $(OUTPUTH)


lexer:      parser adllexer.o 

adllexer.o: adllexer.cpp adllexer.h
            $(CC) adllexer.cpp $(CCOPTS)

testlexer.o: testlexer.cpp
            $(CC) testlexer.cpp $(CCOPTS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\audit\adtgenp.c ===
/*

*/

#include "pch.h"
#pragma hdrstop

#include "lsaptmp.h"
// #include "adtgen.h"
// #include "adtgenp.h"

#define SE_ADT_NO_AUDIT_PRIVILEGE_CHECK

#include "\nt\ds\security\base\lsa\server\cfiles\adtgenp.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\adl\adlstat.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

   adlstat.cpp

Abstract:

   Implementation of AdlStatement and AdlTree class methods

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/


#include "adl.h"
#include <set>

void AdlStatement::ReadFromDacl(IN const PACL pDacl)
/*++

Routine Description:

    Empties anything in the current ADL statement, and attempts to fill it with
    the ADL representation of the given DACL.
        
Arguments:

    pDacl        -      The DACL from which to construct the statement

Return Value:
    
    none    
    
--*/
{
    //
    // Start with cleanup
    //

    Cleanup();

    try
    {
        ConvertFromDacl(pDacl);
    }
    catch(exception)
    {
        throw AdlStatement::ERROR_OUT_OF_MEMORY;
    }

    _bReady = TRUE;
}


void AdlStatement::ReadFromString(IN const WCHAR *szInput)
/*++

Routine Description:

    Empties anything in the current ADL statement, and attempts to fill it with
    the parsed version of the ADL statement szInput.
    
Arguments:

    szInput      -      Input string in the ADL language describing the 
                        permissions

Return Value:
    
    none    
    
--*/
{
    //
    // Start with cleanup
    //

    Cleanup();

    //
    // Manually create first AdlTree, since the parser only creates
    // new trees AFTER completing an ADL_STATEMENT. At the end, the
    // ParseAdl function itself removes the extra empty tree
    // pushed on
    //

    this->Next();

    try
    {
        ParseAdl(szInput);
    }
    catch(exception)
    {
        Cleanup();
        throw AdlStatement::ERROR_OUT_OF_MEMORY;
    }

    //
    // If no exceptions thrown, the instance is ready for output
    //

    _bReady = TRUE;

}




AdlStatement::~AdlStatement()
/*++

Routine Description:

    Destructor for the AdlStatement
    
    Uses the private Cleanup() function to deallocate
    
Arguments:

    none

Return Value:
    
    none    
    
--*/

{
    this->Cleanup();
}
        


void AdlStatement::Cleanup()
/*++

Routine Description:

    Cleans up any memory used by the parse tree and any allocated tokens
        
Arguments:

    none

Return Value:
    
    none    
    
--*/

{
    _bReady = FALSE;

    this->_tokError = NULL;

    while( !_lTree.empty() )
    {
        delete _lTree.front();
        _lTree.pop_front();
    }

    while( !_AllocatedTokens.empty() )
    {
        delete _AllocatedTokens.top();
        _AllocatedTokens.pop();
    }
}


AdlTree * AdlStatement::Cur()
/*++

Routine Description:

    This protected method returns the current AdlTree being filled in by the
    parser. It is only used by the ParseAdl function when it fills in the
    AdlTree structures
        
Arguments:

    none
    
Return Value:
    
    AdlTree *   -   non-const pointer to the AdlTree    
    
--*/
{
    return *_iter;
}


void AdlStatement::Next()
/*++

Routine Description:

    This protected method constructs a new AdlTree and pushes it on top of the
    list (to make it accessable by this->Cur())
    It is only used by the ParseAdl function after completing an ADL_STATEMENT
    production, and by the AdlStatement constructor (once).
            
Arguments:

    none
    
Return Value:
    
    none
    
--*/
{
    
    AdlTree *pAdlTree = new AdlTree();
    if( pAdlTree == NULL )
    {
        throw AdlStatement::ERROR_OUT_OF_MEMORY;
    }

    try
    {
        _lTree.push_back(pAdlTree);
        _iter = --_lTree.end();
    }
    catch(...)
    {
        delete pAdlTree;
        throw;
    }

}


void AdlStatement::PopEmpty()
/*++

Routine Description:

    This protected method pops the extra empty AdlTree added by the ParseAdl
    function after completing the last ADL_STATEMENT.
            
Arguments:

    none
    
Return Value:
    
    none
    
--*/
{
    delete _lTree.back();
    _lTree.pop_back();
    _iter = -- _lTree.end();
}


void AdlStatement::AddToken(AdlToken *tok)
/*++

Routine Description:

    This protected method is used by AdlStatement and friend classes to keep
    track of tokens which need to be garbage collected later. Tokens need
    to be kept around because they are used in the AdlTrees, and in error
    handling.
            
Arguments:

    tok     -   Pointer to the token to be deleted when ~this is called
    
Return Value:
    
    none
    
--*/
{
    _AllocatedTokens.push(tok);
}


void AdlStatement::WriteToString(OUT wstring *pSz)
/*++

Routine Description:

    This routine prints the AdlStatement structure as a statement in the ADL
    language to stdout. This will be replaced when the ADL semantics are
    finalized.
                
Arguments:

    none
    
Return Value:
    
    none
    
--*/
{

    if( _bReady == FALSE )
    {
        throw AdlStatement::ERROR_NOT_INITIALIZED;
    }

    list<AdlTree *>::iterator iter, iterEnd;
    
    for(iter = _lTree.begin(), iterEnd = _lTree.end();
        iter != iterEnd;
        iter++)
    {
        (*iter)->PrintAdl(pSz, _pControl);
        pSz->append(&(_pControl->pLang->CH_NEWLINE), 1);
    }
}


void AdlStatement::ValidateParserControl()
/*++

Routine Description:

        This validates the ADL_PARSER_CONTROL structure referenced by this
        AdlStatement instance
                                        
Arguments:

    none
    
Return Value:
    
    none
    
--*/
{

    try
    {
        //
        // Test to verify that all characters are unique
        // set.insert returns a pair, with 2nd element being a bool, which
        // is true iff an insertion occured. Set cannot have duplicates.
        //

        set<WCHAR> sChars;
        
        if(
            !sChars.insert(_pControl->pLang->CH_NULL).second ||
            !sChars.insert(_pControl->pLang->CH_SPACE).second ||
            !sChars.insert(_pControl->pLang->CH_TAB).second ||
            !sChars.insert(_pControl->pLang->CH_NEWLINE).second ||
            !sChars.insert(_pControl->pLang->CH_RETURN).second ||
            !sChars.insert(_pControl->pLang->CH_QUOTE).second ||
            !sChars.insert(_pControl->pLang->CH_COMMA).second ||
            !sChars.insert(_pControl->pLang->CH_SEMICOLON).second ||
            !sChars.insert(_pControl->pLang->CH_OPENPAREN).second ||
            !sChars.insert(_pControl->pLang->CH_CLOSEPAREN).second ||
            !sChars.insert(_pControl->pLang->CH_AT).second ||
            !sChars.insert(_pControl->pLang->CH_SLASH).second ||
            !sChars.insert(_pControl->pLang->CH_PERIOD).second 
           )
        {
            throw AdlStatement::ERROR_INVALID_PARSER_CONTROL;
        }


        //
        // Check all strings for null pointers
        //

        if( 
             _pControl->pLang->SZ_TK_AND == NULL ||
             _pControl->pLang->SZ_TK_EXCEPT == NULL ||
             _pControl->pLang->SZ_TK_ON == NULL ||
             _pControl->pLang->SZ_TK_ALLOWED == NULL ||
             _pControl->pLang->SZ_TK_AS == NULL ||
             _pControl->pLang->SZ_TK_THIS_OBJECT == NULL ||
             _pControl->pLang->SZ_TK_CONTAINERS == NULL ||
             _pControl->pLang->SZ_TK_OBJECTS == NULL ||
             _pControl->pLang->SZ_TK_CONTAINERS_OBJECTS == NULL ||
             _pControl->pLang->SZ_TK_NO_PROPAGATE == NULL 
           )
        {
            throw AdlStatement::ERROR_INVALID_PARSER_CONTROL;
        }

    }
    catch(exception)
    {
        throw AdlStatement::ERROR_OUT_OF_MEMORY;
    }

}




/******************************************************************************

        AdlTree Methods

 *****************************************************************************/


//
// An array of these is used to determine the order in which to print
//

#define PRINT_PRINCIPALS 0
#define PRINT_EXPRINCIPALS 1
#define PRINT_ALLOWED 2
#define PRINT_ACCESS 3
#define PRINT_ON 4
#define PRINT_OBJECTS 5

#define PRINT_DEF_SIZE 6

DWORD pdwLangEnglish[6] = 
{
    PRINT_PRINCIPALS,
    PRINT_EXPRINCIPALS,
    PRINT_ALLOWED,
    PRINT_ACCESS,
    PRINT_ON,
    PRINT_OBJECTS
};

DWORD pdwLangReverse[6] = 
{
    PRINT_EXPRINCIPALS,
    PRINT_PRINCIPALS,
    PRINT_ALLOWED,
    PRINT_ACCESS,
    PRINT_ON,
    PRINT_OBJECTS
};

//
// Append a wchar array to the STL string POUTSTLSTRING, add quotes
// if the input string contains any characters in the wchar
// array SPECIALCHARS 
//
#define APPEND_QUOTED_STRING(POUTSTLSTRING, INSTRING, SPECIALCHARS, QUOTECHAR) \
  if( wcspbrk( (INSTRING), (SPECIALCHARS) ) ) { \
      (POUTSTLSTRING)->append(&(QUOTECHAR), 1); \
      (POUTSTLSTRING)->append(INSTRING); \
      (POUTSTLSTRING)->append(&(QUOTECHAR), 1); \
  } else { \
      (POUTSTLSTRING)->append(INSTRING); \
  }
  

void AdlTree::PrintAdl(wstring *pSz, PADL_PARSER_CONTROL pControl)
/*++

Routine Description:

    This routine prints the AdlTree structure using one of the pre-defined
    language specifications, selected by checking the ADL_PARSER_CONTROL 
    structure. To add new languages, simply add a new 6 int array as above,
    and add it into the switch statement below so it will be recognized.
    
Arguments:

    pSz      -   An existing wstring to which the ADL statement output will
                 be appended
    pControl -   Pointer to the ADL_PARSER_CONTROL structure to define the
                 printing
    
Return Value:
    
    none
    
--*/

{


    //
    // Iterators for token lists in the AdlTree
    //

    list<const AdlToken *>::iterator iter;
    list<const AdlToken *>::iterator iter_end;
    list<const AdlToken *>::iterator iter_tmp;

    // 
    // If a string contains these characters, use quotes
    //

    WCHAR szSpecialChars[] = 
    { 
        pControl->pLang->CH_SPACE,
        pControl->pLang->CH_NEWLINE,
        pControl->pLang->CH_TAB,
        pControl->pLang->CH_RETURN,
        pControl->pLang->CH_COMMA,
        pControl->pLang->CH_OPENPAREN,
        pControl->pLang->CH_CLOSEPAREN,
        pControl->pLang->CH_SEMICOLON,
        pControl->pLang->CH_AT,
        pControl->pLang->CH_SLASH,
        pControl->pLang->CH_PERIOD,
        pControl->pLang->CH_QUOTE,
        0
    };

    DWORD dwIdx;
    DWORD dwTmp;

    PDWORD pdwPrintSpec;

    //
    // Determine which type of grammar to use.
    //

    switch( pControl->pLang->dwLanguageType )
    {
    case TK_LANG_ENGLISH:
        pdwPrintSpec = pdwLangEnglish;
        break;
        
    case TK_LANG_REVERSE:
        pdwPrintSpec = pdwLangReverse;
        break;

    default:
        throw AdlStatement::ERROR_INVALID_PARSER_CONTROL;
        break;
    }

    //
    // Using that grammar, print the appropriate parts of each
    // ADL_STATEMENT production
    //
    
    for( dwIdx = 0; dwIdx < PRINT_DEF_SIZE; dwIdx++ )
    {

        switch(pdwPrintSpec[dwIdx])
        {
        
        case PRINT_PRINCIPALS:
            for( iter = _lpTokPrincipals.begin(),
                 iter_end = _lpTokPrincipals.end();
                 iter != iter_end;
                 iter++)
            {
                APPEND_QUOTED_STRING(pSz, 
                                     (*iter)->GetValue(), 
                                     szSpecialChars, 
                                     pControl->pLang->CH_QUOTE);

                //
                // ISSUE-2000/8/31
                // Need to find a way to determine this instead of string comp
                //
                
                if( (*iter)->GetOptValue() != NULL &&
                    _wcsicmp(L"BUILTIN", (*iter)->GetOptValue()))
                {
                    pSz->append(&(pControl->pLang->CH_AT), 1);
                    
                    APPEND_QUOTED_STRING(pSz, 
                                         (*iter)->GetOptValue(), 
                                         szSpecialChars, 
                                         pControl->pLang->CH_QUOTE);
                }

                //
                // Separate with commas except the last one, there use "and"
                //
        
                iter_tmp = iter;
                if( ++iter_tmp == iter_end )
                {
                    //
                    // Do nothing for the last principal
                    //
                }
                else if( ++iter_tmp == iter_end )
                {
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                    pSz->append(pControl->pLang->SZ_TK_AND);
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                }
                else
                {
                    pSz->append(&(pControl->pLang->CH_COMMA), 1);
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                }


            }

            //
            // And a trailing space
            //

            pSz->append(&(pControl->pLang->CH_SPACE), 1);
            
            break;
        
        case PRINT_EXPRINCIPALS:
            
            if( ! _lpTokExPrincipals.empty())
            {
                pSz->append(&(pControl->pLang->CH_OPENPAREN), 1);
                pSz->append(pControl->pLang->SZ_TK_EXCEPT);
                pSz->append(&(pControl->pLang->CH_SPACE), 1);
                
                for( iter = _lpTokExPrincipals.begin(),
                     iter_end = _lpTokExPrincipals.end();
                     iter != iter_end;
                     iter++)
                {
                    APPEND_QUOTED_STRING(pSz, 
                                         (*iter)->GetValue(), 
                                         szSpecialChars, 
                                         pControl->pLang->CH_QUOTE);
    
                    //
                    // ISSUE-2000/8/31
                    // Need to find a way to determine this instead of string comp
                    //
                    
                    if( (*iter)->GetOptValue() != NULL &&
                        _wcsicmp(L"BUILTIN", (*iter)->GetOptValue()))
                    {
                        pSz->append(&(pControl->pLang->CH_AT), 1);
                        
                        APPEND_QUOTED_STRING(pSz, 
                                             (*iter)->GetOptValue(), 
                                             szSpecialChars, 
                                             pControl->pLang->CH_QUOTE);
                    }
    
                    //
                    // Separate with commas except the last one, there use "and"
                    //
            
                    iter_tmp = iter;
                    if( ++iter_tmp == iter_end )
                    {
                        //
                        // Do nothing for the last principal
                        //
                    }
                    else if( ++iter_tmp == iter_end )
                    {
                        pSz->append(&(pControl->pLang->CH_SPACE), 1);
                        pSz->append(pControl->pLang->SZ_TK_AND);
                        pSz->append(&(pControl->pLang->CH_SPACE), 1);
                    }
                    else
                    {
                        pSz->append(&(pControl->pLang->CH_COMMA), 1);
                        pSz->append(&(pControl->pLang->CH_SPACE), 1);
                    }
    
    
                }
    
                
                pSz->append(&(pControl->pLang->CH_CLOSEPAREN), 1);
                pSz->append(&(pControl->pLang->CH_SPACE), 1);
            }

            break;
        
        case PRINT_ALLOWED:
            pSz->append(pControl->pLang->SZ_TK_ALLOWED);
            pSz->append(&(pControl->pLang->CH_SPACE), 1);

            break;
        
        case PRINT_ACCESS:

            for( iter = _lpTokPermissions.begin(),
                 iter_end = _lpTokPermissions.end();
                 iter != iter_end;
                 iter++)
            {
                APPEND_QUOTED_STRING(pSz, 
                                     (*iter)->GetValue(), 
                                     szSpecialChars, 
                                     pControl->pLang->CH_QUOTE);


                //
                // Separate with commas except the last one, there use "and"
                //
        
                iter_tmp = iter;
                if( ++iter_tmp == iter_end )
                {
                    //
                    // Do nothing for the last permission
                    //
                }
                else if( ++iter_tmp == iter_end )
                {
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                    pSz->append(pControl->pLang->SZ_TK_AND);
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                }
                else
                {
                    pSz->append(&(pControl->pLang->CH_COMMA), 1);
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                }


            }

            //
            // And a trailing space
            //
            pSz->append(&(pControl->pLang->CH_SPACE), 1);
            
            break;
        
        case PRINT_ON:

            pSz->append(pControl->pLang->SZ_TK_ON);
            pSz->append(&(pControl->pLang->CH_SPACE), 1);
            
            break;
        
        case PRINT_OBJECTS:
            
            //
            // Make sure all bits are defined
            //

            if( _dwInheritFlags & ~(CONTAINER_INHERIT_ACE |
                                    INHERIT_ONLY_ACE |
                                    NO_PROPAGATE_INHERIT_ACE |
                                    OBJECT_INHERIT_ACE) )
            {
                throw AdlStatement::ERROR_INVALID_OBJECT;
            }

            //
            // Count the number of object statements, for proper punctuation
            //

            dwTmp = 0;
            
            if( ! ( _dwInheritFlags & INHERIT_ONLY_ACE) )
            {
                dwTmp++;
            }

            if(_dwInheritFlags & ( CONTAINER_INHERIT_ACE || OBJECT_INHERIT_ACE))
            {
                dwTmp++;
            }

            if(_dwInheritFlags & NO_PROPAGATE_INHERIT_ACE)
            {
                dwTmp++;
            }


            //
            // First "this object"
            //

            if( ! ( _dwInheritFlags & INHERIT_ONLY_ACE) )
            {
                APPEND_QUOTED_STRING(pSz, 
                                     pControl->pLang->SZ_TK_THIS_OBJECT,
                                     szSpecialChars, 
                                     pControl->pLang->CH_QUOTE);

                //
                // Print "and" if 1 more left, "," if two
                //
                
                dwTmp--;

                if( dwTmp == 2 )
                {
                    pSz->append(&(pControl->pLang->CH_COMMA), 1);
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                }
                else if( dwTmp == 1)
                {
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                    pSz->append(pControl->pLang->SZ_TK_AND);
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                }
            }



            //
            // Then container/object inheritance
            //

            if( _dwInheritFlags & ( CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE))
            {
                if(    (_dwInheritFlags & OBJECT_INHERIT_ACE) 
                    && (_dwInheritFlags & CONTAINER_INHERIT_ACE) )
                {
                    APPEND_QUOTED_STRING(pSz, 
                                      pControl->pLang->SZ_TK_CONTAINERS_OBJECTS,
                                      szSpecialChars, 
                                      pControl->pLang->CH_QUOTE);
                }
                else if( _dwInheritFlags & CONTAINER_INHERIT_ACE )
                {
                    APPEND_QUOTED_STRING(pSz, 
                                      pControl->pLang->SZ_TK_CONTAINERS,
                                      szSpecialChars, 
                                      pControl->pLang->CH_QUOTE);
                }
                else
                {
                    APPEND_QUOTED_STRING(pSz, 
                                      pControl->pLang->SZ_TK_OBJECTS,
                                      szSpecialChars, 
                                      pControl->pLang->CH_QUOTE);
                }
                
                dwTmp--;

                //
                // Print "and" if 1 more left
                // nothing if 0
                //

                if( dwTmp == 1)
                {
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                    pSz->append(pControl->pLang->SZ_TK_AND);
                    pSz->append(&(pControl->pLang->CH_SPACE), 1);
                }
            }


            //
            // Now no-propagate
            //

            if(_dwInheritFlags & NO_PROPAGATE_INHERIT_ACE)
            {
                APPEND_QUOTED_STRING(pSz, 
                                  pControl->pLang->SZ_TK_NO_PROPAGATE,
                                  szSpecialChars, 
                                  pControl->pLang->CH_QUOTE);
            }
            

            break;

        default:

            //
            // Should not get here unless language defs are wrong
            //

            throw AdlStatement::ERROR_FATAL_PARSER_ERROR;
            break;
        }

    }


    //
    // And terminate the statement with a semicolon, invariable per grammar
    //

    pSz->append(&(pControl->pLang->CH_SEMICOLON), 1);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\adl\test.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

   test.cpp

Abstract:

   Utility which allows to dump a file DACL in ADL or set a file DACL from ADL

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/


#include "adl.h"


//
// Various file rights
// More general rights have priority
//

ADL_MASK_STRING MaskStringMap[] = 
{
    { (FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE | WRITE_DAC
      | WRITE_OWNER | READ_CONTROL | DELETE)  & ~SYNCHRONIZE , L"full control" },
    { FILE_GENERIC_READ & ~SYNCHRONIZE, L"read" },
    { FILE_GENERIC_WRITE & ~SYNCHRONIZE, L"write" },
    { FILE_GENERIC_EXECUTE & ~SYNCHRONIZE, L"execute" },
    { DELETE & ~SYNCHRONIZE, L"delete" },
    { READ_CONTROL, L"read control"},
    { WRITE_DAC, L"write dac"},
    { WRITE_OWNER, L"write owner" },
    { SYNCHRONIZE, L"synchronize" },
    { FILE_READ_DATA, L"read data" },
    { FILE_WRITE_DATA, L"write data" },
    { FILE_APPEND_DATA, L"append data" },
    { FILE_READ_EA, L"read extended attributes" },
    { FILE_WRITE_EA, L"write extended attributes" },
    { FILE_EXECUTE, L"file execute" },
    { FILE_READ_ATTRIBUTES, L"read attributes" },
    { FILE_WRITE_ATTRIBUTES, L"write attributes" },
    { 0, NULL }
};


//
// Representation of the English version of ADL
//

ADL_LANGUAGE_SPEC lEnglish = 
{
    TK_LANG_ENGLISH,
    0,
    L' ',
    L'\t',
    L'\n',
    L'\r',
    L'"',
    L',',
    L';',
    L'(',
    L')',
    L'@',
    L'\\',
    L'.',
    0,
    L"and",
    L"except",
    L"on",
    L"allowed",
    L"as",
    L"this file",
    L"subfolders",
    L"files",
    L"subfolders and files",
    L"noprop"
};

ADL_PARSER_CONTROL EnglishFileParser = 
{
    &lEnglish,
    MaskStringMap,
    ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED,
    SYNCHRONIZE   
};



//
// Error handler
//

void HandleError(AdlStatement::ADL_ERROR_TYPE adlErr, const AdlToken *pTok)
{
    switch(adlErr)
    {
    
    //
    // Errors that should not happen unless there is a problem with the 
    // system or the user makes a mistake
    //

    case AdlStatement::ERROR_FATAL_LEXER_ERROR:
    case AdlStatement::ERROR_FATAL_PARSER_ERROR:
    case AdlStatement::ERROR_FATAL_ACL_CONVERT_ERROR:
    case AdlStatement::ERROR_OUT_OF_MEMORY:
    case AdlStatement::ERROR_ACL_API_FAILED:
    case AdlStatement::ERROR_NOT_INITIALIZED:
        wprintf(L"\n\nFatal internal error, Errorcode %u, THIS IS BAD\n\n", adlErr);
        break;

    case AdlStatement::ERROR_LSA_FAILED:
        wprintf(L"\n\nError: LSA failed. Unable to resolve user information\n\n");
        break;


    //
    // Input-related grammar errors: no token supplied
    //

    case AdlStatement::ERROR_UNTERMINATED_STRING:
        wprintf(L"\n\nError: unmatched quote in the input\n\n");
        break;

    case AdlStatement::ERROR_UNKNOWN_ACE_TYPE:
        wprintf(L"\n\nError: Unknown ACE type encountered\n\n");
        break;

    case AdlStatement::ERROR_IMPERSONATION_UNSUPPORTED:
        wprintf(L"\n\nError: Impersonation is currently not supported in ADL\n\n");
        break;

    case AdlStatement::ERROR_INVALID_PARSER_CONTROL:
        wprintf(L"\n\nError: The specified laanguage type is not supported\n\n");
        break;

    //
    // For this error, the last read token is supplied
    //
        
    case AdlStatement::ERROR_NOT_IN_LANGUAGE:
        wprintf(L"\n\nError, invalid ADL statement, did not expect '%s',\n\
                which was found between characters %u and %u\n\n", pTok->GetValue(),
                pTok->GetStart(), pTok->GetEnd());
        break;
        

    //
    // Input-related semantic errors
    //

    //
    // For these errors, the offending token is supplied
    //

    case AdlStatement::ERROR_UNKNOWN_USER:
        
        wprintf(L"\n\nError, unknown user: ");
        if( pTok->GetOptValue() != NULL )
        {
            wprintf(L"'%s%c%s' ", pTok->GetValue(), lEnglish.CH_AT, pTok->GetOptValue());
        }
        else
        {
            wprintf(L"'%s' ", pTok->GetValue());
        }
        wprintf(L"found between characters %u and %u\n\n", pTok->GetStart(), pTok->GetEnd());
        break;


    case AdlStatement::ERROR_UNKNOWN_PERMISSION:
        wprintf(L"\n\nError, unknown permission: '%s' \
                found between characters %u and %u\n\n", 
                pTok->GetValue(), pTok->GetStart(), pTok->GetEnd());
        break;

    case AdlStatement::ERROR_INVALID_USERNAME:
        wprintf(L"\n\nError, invalid username string: '%s' \
                found between characters %u and %u\n\n", 
                pTok->GetValue(), pTok->GetStart(), pTok->GetEnd());
        break;

    case AdlStatement::ERROR_INVALID_DOMAIN:
        wprintf(L"\n\nError, invalid domain name string: '%s' \
                found between characters %u and %u\n\n", 
                pTok->GetValue(), pTok->GetStart(), pTok->GetEnd());
        break;

    case AdlStatement::ERROR_INVALID_OBJECT:
        wprintf(L"\n\nError, invalid object specifier: '%s' \
                found between characters %u and %u\n\n", 
                pTok->GetValue(), pTok->GetStart(), pTok->GetEnd());
        break;

    //
    // Other errors with no token supplied
    //
        
    case AdlStatement::ERROR_UNKNOWN_SID:
        wprintf(L"\n\nError: SID encountered which could not be resolved to a name\n\n");
        break;

    case AdlStatement::ERROR_UNKNOWN_ACCESS_MASK:
        wprintf(L"\n\nError: Access mask contains unknown bit\n\n");
        break;

    case AdlStatement::ERROR_INEXPRESSIBLE_ACL:
        wprintf(L"\n\nError: This DACL cannot be expressed in ADL\n\n");
        break;

    default:
        wprintf(L"\n\nUNKNOWN Error code: %u, THIS IS VERY BAD\n\n", adlErr);
        break;
    }

}

//
// -dump Filename
//

void DumpDaclToAdl(int argc, WCHAR *argv[]) {

    DWORD dwErr;

    if(argc != 3) 
    {
        wprintf(L"\nUsage:\n\n%s -dump <target>\n\n", argv[0]);
        exit(1);
    }

    PSECURITY_DESCRIPTOR pSD;
    SECURITY_INFORMATION SecInfo = DACL_SECURITY_INFORMATION;

    DWORD dwLengthNeeded;
    GetFileSecurity(
        argv[2],
        SecInfo,
        NULL,
        0,
        &dwLengthNeeded);

    pSD = (PSECURITY_DESCRIPTOR) new BYTE[dwLengthNeeded];

    dwErr = GetFileSecurity(
        argv[2],
        SecInfo,
        pSD,
        dwLengthNeeded,
        &dwLengthNeeded);

    if( dwErr == 0)
    {
        dwErr = GetLastError();
        wprintf(L"GetFileSecurity failed on file '%s' with error %u, 0x%x\n",
                argv[2], dwErr, dwErr);
        exit(5);
    }

    PACL pDacl;

    BOOL fDaclPresent;
    BOOL fDaclDefaulted;
    GetSecurityDescriptorDacl(pSD, &fDaclPresent, &pDacl, &fDaclDefaulted);

    if( !fDaclPresent || pDacl == NULL )
    {
        wprintf(L"Security descriptor of '%s' does not contain a DACL",argv[2]);
        exit(6);
    }

    AdlStatement *stat;

    try
    {
        stat = new AdlStatement(&EnglishFileParser);
        wstring ws;
        stat->ReadFromDacl(pDacl);
        stat->WriteToString(&ws);
        wprintf(L"%s", ws.c_str());
    }
    catch(AdlStatement::ADL_ERROR_TYPE adlErr)
    {
        HandleError(adlErr, stat->GetErrorToken());
    }

    if( stat != NULL )
    {
        delete stat;
    }

    delete[] (PBYTE)pSD;
}


//
// -set adlfile target
//

void WriteDaclFromAdl(int argc, WCHAR *argv[]) {

    WCHAR buf[16384];
    char buf3[16384];
    DWORD i;
    DWORD dwErr;

    if(argc != 4) 
    {
        wprintf(L"\nUsage:\n\n%s -set <adl rules file> <target>\n\n", argv[0]);
        exit(1);
    }

    FILE *in = _wfopen(argv[2], L"rb");
    if(in == NULL) 
    {
        wprintf(L"Error: cannot open input ADL file '%s', exiting\n", argv[2]);
        exit(2);
    }

    // skip top byte
    if( fgetwc(in) != 0xFEFF)
    {
        fseek(in, 0, SEEK_SET);
        for(i = 0; (buf3[i] = (char)fgetc(in)) != EOF && i < 16384; i++);
        buf3[i] = 0;
        MultiByteToWideChar(CP_ACP, 0, buf3, i+1, buf, 16384);
    }
    else
    {
        for(i = 0; (buf[i] = fgetwc(in)) != WEOF && i < 16384; i++);
        buf[i] = 0;
    }

    AdlStatement * stat;

    try 
    {
        stat = new AdlStatement( &EnglishFileParser);
        wstring ws;
        stat->ReadFromString(buf);
        stat->WriteToString(&ws);
        wprintf(L"Setting permissions to:\n-------------\n%s\n-------------\n",
                ws.c_str());

    }
    catch(AdlStatement::ADL_ERROR_TYPE adlErr)
    {
        HandleError(adlErr, stat->GetErrorToken());
        if( stat != NULL )
        {
            delete stat;
        }
        exit(6);
    }
    
    //
    // Initialize the security descriptor
    //
    
    SECURITY_DESCRIPTOR SD;
    
    InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorGroup(&SD, NULL, FALSE);
    SetSecurityDescriptorOwner(&SD, NULL, FALSE);
    SetSecurityDescriptorSacl(&SD, FALSE, NULL, FALSE);

    PACL pDacl = NULL;
    
    try 
    {
        stat->WriteToDacl(&pDacl);
    }
    catch(AdlStatement::ADL_ERROR_TYPE adlErr)
    {
        HandleError(adlErr, stat->GetErrorToken());
        delete stat;
        exit(7);
    }

    SetSecurityDescriptorDacl(&SD, TRUE, pDacl, FALSE);
    
    //
    // Set the file security
    //
        
    SECURITY_INFORMATION SecInfo = DACL_SECURITY_INFORMATION;
    dwErr = SetFileSecurity(argv[3], SecInfo, &SD);
    if(dwErr == 0)
    {
        dwErr = GetLastError();
        wprintf(L"SetFileSecurity on %s failed with %d, 0x%x\n",
                argv[3],
                dwErr,
                dwErr);
    }
    else
    {
        wprintf(L"Success, permissions set.\n");
    }

    AdlStatement::FreeMemory(pDacl);

    delete stat;
}


void __cdecl wmain(int argc, WCHAR *argv[])
{

    if(argc < 2)
    {
        wprintf(L"\nUsage:\n\n%s -set <adl rules file> <target>\n"
               L"%s -dump <target>\n\n", argv[0], argv[0]);
    }
    else
    {
        if(!_wcsicmp(argv[1], L"-dump"))
        {
            DumpDaclToAdl(argc, argv);
        } 
        else if(!_wcsicmp(argv[1], L"-set"))
        {
            WriteDaclFromAdl(argc, argv);
        } 
        else
        {
            wprintf(L"\nUsage:\n\n%s -set <adl rules file> <target>\n"
                L"%s -dump <target>\n\n", argv[0], argv[0]);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\adl\tokens.h ===
#define TK_ERROR 257
#define TK_IDENT 258
#define TK_AT 259
#define TK_SLASH 260
#define TK_PERIOD 261
#define TK_COMMA 262
#define TK_OPENPAREN 263
#define TK_CLOSEPAREN 264
#define TK_SEMICOLON 265
#define TK_EXCEPT 266
#define TK_ON 267
#define TK_ALLOWED 268
#define TK_AND 269
#define TK_AS 270
#define TK_THIS_OBJECT 271
#define TK_CONTAINERS 272
#define TK_OBJECTS 273
#define TK_CONTAINERS_OBJECTS 274
#define TK_NO_PROPAGATE 275
#define TK_LANG_ENGLISH 276
#define TK_LANG_REVERSE 277
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\audit\lsapch2.h ===
// empty file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\audit\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include "windows.h"
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>

#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>

#define SECURITY_WIN32

#include "sspi.h"
#include "secint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\audit\adttest.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T U T I L . C
//
// Contents:    Functions to test generic audit support in LSA
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------

#pragma once

EXTERN_C
NTSTATUS
TestEventGenMulti(
    IN  USHORT NumThreads,
    IN  ULONG  NumIter
    );

EXTERN_C
NTSTATUS
kElfReportEventW (
    IN      HANDLE          LogHandle,
    IN      USHORT          EventType,
    IN      USHORT          EventCategory OPTIONAL,
    IN      ULONG           EventID,
    IN      PSID            UserSid,
    IN      USHORT          NumStrings,
    IN      ULONG           DataSize,
    IN      PUNICODE_STRING *Strings,
    IN      PVOID           Data,
    IN      USHORT          Flags,
    IN OUT  PULONG          RecordNumber OPTIONAL,
    IN OUT  PULONG          TimeWritten  OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\audit\lsaptmp.h ===
#pragma once

#define FLAG_ON(flags,bit)        ((flags) & (bit))

#define SE_MAX_AUDIT_PARAM_STRINGS 32

extern LUID AuditPrivilege;

NTSTATUS
LsapRtlConvertSidToString(
    IN     PSID   Sid,
    OUT    PWSTR  szString,
    IN OUT DWORD *pdwRequiredSize
    );

PVOID NTAPI
LsapAllocateLsaHeap(
    IN ULONG cbMemory
    );

void NTAPI
LsapFreeLsaHeap(
    IN PVOID pvMemory
    );


NTSTATUS
LsapAdtDemarshallAuditInfo(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters
    );

NTSTATUS
LsapAdtBuildDashString(
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildUlongString(
    IN ULONG Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildHexUlongString(
    IN ULONG Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildPtrString(
    IN  PVOID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildLuidString(
    IN PLUID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );


NTSTATUS
LsapAdtBuildSidString(
    IN PSID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildObjectTypeStrings(
    IN PUNICODE_STRING SourceModule,
    IN PUNICODE_STRING ObjectTypeName,
    IN PSE_ADT_OBJECT_TYPE ObjectTypeList,
    IN ULONG ObjectTypeCount,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone,
    OUT PUNICODE_STRING NewObjectTypeName
    );

NTSTATUS
LsapAdtBuildAccessesString(
    IN PUNICODE_STRING SourceModule,
    IN PUNICODE_STRING ObjectTypeName,
    IN ACCESS_MASK Accesses,
    IN BOOLEAN Indent,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildFilePathString(
    IN PUNICODE_STRING Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

NTSTATUS
LsapAdtBuildLogonIdStrings(
    IN PLUID LogonId,
    OUT PUNICODE_STRING ResultantString1,
    OUT PBOOLEAN FreeWhenDone1,
    OUT PUNICODE_STRING ResultantString2,
    OUT PBOOLEAN FreeWhenDone2,
    OUT PUNICODE_STRING ResultantString3,
    OUT PBOOLEAN FreeWhenDone3
    );

NTSTATUS
LsapBuildPrivilegeAuditString(
    IN PPRIVILEGE_SET PrivilegeSet,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    );

VOID
LsapAdtSubstituteDriveLetter(
    IN PUNICODE_STRING FileName
    );

#define DsysAssertMsg(exp, msg) ASSERT(exp)

EXTERN_C
NTSTATUS
LsapApiReturnResult(
    ULONG ExceptionCode
    );

NTSTATUS
LsapAdtWriteLog(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters OPTIONAL,
    IN ULONG Options
    );

BOOLEAN
LsapAdtIsAuditingEnabledForCategory(
    IN POLICY_AUDIT_EVENT_TYPE AuditCategory,
    IN UINT AuditEventType
    );

VOID
LsapAuditFailed(
    IN NTSTATUS AuditStatus
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\audit\adttest.cpp ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T U T I L . C
//
// Contents:    Functions to test generic audit support in LSA
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "authz.h"
#include "authzi.h"
#include "adtgen.h"

//
// defining USE_LOCAL_AUDIT causes audits to be processed in proc
// instead of being sent to lsa. This allows much faster debug
// cycle since LSA is not involved. The audit marshal/process code
// is taken directly from LSA. Thus the same code path is exercised
// as that when this is not defined.
//

//#define USE_LOCAL_AUDIT


#ifdef USE_LOCAL_AUDIT

#include "\nt\ds\security\base\lsa\server\cfiles\adtgenp.h"

#endif 


// ----------------------------------------------------------------------
//
// forward declarations
//
DWORD 
EnableSinglePrivilege(
    IN PWCHAR szPrivName
    );

// ----------------------------------------------------------------------

EXTERN_C
DWORD
TestEventGen( ULONG NumIter )
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD dwError=NO_ERROR;
    HANDLE hAudit = NULL;
    AUDIT_PARAMS AuditParams;
    AUDIT_PARAM ParamArray[SE_MAX_AUDIT_PARAMETERS];
    PSID pUserSid = NULL;
    AUTHZ_AUDIT_EVENT_TYPE_LEGACY AuditEventInfoLegacy = { 0 };
    //AUDIT_EVENT_INFO AuditEventInfo = { 0 };
    AUTHZ_AUDIT_EVENT_TYPE_OLD AuditEventType;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hEventType = NULL;
    BOOL fDone=FALSE;
    PWSTR szMsg = NULL;
    BOOL fResult;

    AUDIT_OBJECT_TYPE Objects[3] =
    {
        {
            { /* f3548725-0458-11d4-bd96-006008269001 */
                0xf3548725,
                0x0458,
                0x11d4,
                {0xbd, 0x96, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01}
            },
            0, 0, STANDARD_RIGHTS_ALL
        },
        {
            { /* f3548726-0458-11d4-bd96-006008269001 */
                0xf3548726,
                0x0458,
                0x11d4,
                {0xbd, 0x96, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01}
            },
            0, 1, STANDARD_RIGHTS_ALL
        },
        {
            { /* f3548727-0458-11d4-bd96-006008269001 */
                0xf3548727,
                0x0458,
                0x11d4,
                {0xbd, 0x96, 0x00, 0x60, 0x08, 0x26, 0x90, 0x01}
            },
            0, 2, STANDARD_RIGHTS_ALL | ACCESS_SYSTEM_SECURITY
        },
    };

    AUDIT_OBJECT_TYPES ObjectTypes =
    {
        3, 0, Objects
    };
    
    AuditParams.Parameters = ParamArray;

    wprintf(L"[%03d] begin...\n", GetCurrentThreadId());

//      AuditEventInfo.Version                  = AUDIT_TYPE_LEGACY;
//      //AuditEventInfo.u.Legacy                 = &AuditEventInfoLegacy;
//      AuditEventInfo.u.Legacy.CategoryId     = SE_CATEGID_OBJECT_ACCESS;
//      AuditEventInfo.u.Legacy.AuditId        = SE_AUDITID_OBJECT_OPERATION;
//      AuditEventInfo.u.Legacy.ParameterCount = 11;

    fResult = AuthziInitializeAuditEventType(
                  0,
                  SE_CATEGID_OBJECT_ACCESS,
                  SE_AUDITID_OBJECT_OPERATION,
                  11,
                  &hEventType
                  );
    if ( !fResult )
    {
        szMsg = L"AuthziInitializeAuditEventType";
        goto Cleanup;
    }
    
#ifdef USE_LOCAL_AUDIT
    Status = LsapRegisterAuditEvent( &AuditEventInfo, &hAudit );

    if (!NT_SUCCESS(Status))
    {
        szMsg = L"LsapRegisterAuditEvent";
        goto Cleanup;
    }
#else    
//      fResult = AuthzpRegisterAuditEvent( &AuditEventInfo, &hAudit );

//      if (!fResult)
//      {
//          szMsg = L"AuthzRegisterAuditEvent";
//          goto Cleanup;
//      }
#endif

    //
    // initialize the AuditParams structure
    //

//      fResult = AuthziInitializeAuditParams(
//                    //
//                    // flags
//                    //

//                    0,
                  
//                    &AuditParams,

//                    //
//                    // sid of the user generating this audit
//                    //

//                    &pUserSid,

//                    //
//                    // resource manager name
//                    //

//                    L"mysubsystem",

//                    //
//                    // generate a success audit
//                    //

//                    APF_AuditSuccess,

//                    //
//                    // there are 9 params to follow
//                    //
//                    9,

//                    //
//                    // operation type
//                    //

//                    APT_String,     L"test",

//                    //
//                    // object type
//                    //

//                    APT_String,     L"File",

//                    //
//                    // object name
//                    //

//                    APT_String,     L"foo-obj",

//                    //
//                    // handle id
//                    //

//                    APT_Pointer,    0x123,

//                    //
//                    // primary user info
//                    //

//                    APT_LogonId | AP_PrimaryLogonId,

//                    //
//                    // client user info
//                    //

//                    APT_LogonId | AP_ClientLogonId,

//                    //
//                    // requested accesses
//                    // 1 refers to 0 based index of the
//                    // parameter (object-type) that is
//                    // passed to this function.
//                    //

//                    APT_Ulong   | AP_AccessMask,
//                    STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL, 1,

//                    //
//                    // object properties
//                    // 1 refers to 0 based index of the
//                    // parameter (object-type) that is
//                    // passed to this function.
//                    //

//                    APT_ObjectTypeList, &ObjectTypes, 1,

//                    //
//                    // additional info
//                    //

//                    APT_String, L"this is not a real obj-opn"
//                    );
//      if (!fResult)
//      {
//  #ifdef USE_LOCAL_AUDIT
//          Status = STATUS_UNSUCCESSFUL;
//          wprintf(L"[%03d] AuthzInitAuditParams: %x\n",
//                  GetCurrentThreadId(), GetLastError());
//  #endif        
//          szMsg = L"AuthzInitAuditParams";
//          goto Cleanup;
//      }

    for (ULONG i=0; i<NumIter; i++)
    {
        Sleep( 10 );

#ifdef USE_LOCAL_AUDIT
        Status = LsapGenAuditEvent( hAudit, 0, &AuditParams, 0 );

        if (!NT_SUCCESS(Status))
        {
            szMsg = L"LsapGenAuditEvent";
            goto Cleanup;
        }
#else        
//          fResult = AuthzGenAuditEvent( hAudit, 0, &AuditParams, 0 );

//          if (!fResult)
//          {
//              szMsg = L"AuthzGenAuditEvent";
//              goto Cleanup;
//          }
#endif
    }
    

Cleanup:
#ifdef USE_LOCAL_AUDIT
    if (!NT_SUCCESS(Status))
    {
        dwError = Status;
    }
#else    
    if (!fResult)
    {
        dwError = GetLastError();
    }
#endif

    wprintf(L"[%03d] end: %s %x\n",
            GetCurrentThreadId(), szMsg ? szMsg : L"", dwError);
    LocalFree( pUserSid );

    if ( hAudit )
    {
#ifdef USE_LOCAL_AUDIT
        Status = LsapUnregisterAuditEvent( &hAudit );

        if (!NT_SUCCESS(Status))
        {
            wprintf (L"LsapUnregisterAuditEvent: %x\n", Status);
        }
#else
        fResult = AuthziFreeAuditEventType( hEventType );

        if (!fResult)
        {
            dwError = GetLastError();

            wprintf (L"AuthziFreeAuditEventType: %x\n", dwError);
        }
#endif
    }

    return dwError;
}

DWORD WINAPI TestEventGenThreadProc( PVOID p )
{
    TestEventGen( (ULONG) (ULONG_PTR) p );

    return 0;
}


DWORD WaitForTonsOfObjects(
    IN  DWORD   dwNumThreads,
    IN  HANDLE* phThreads,
    IN  BOOL    fWaitAll,
    IN  DWORD   dwMilliseconds
    )
{
    LONG dwNumBundles=dwNumThreads / MAXIMUM_WAIT_OBJECTS;
    DWORD dwRem = dwNumThreads % MAXIMUM_WAIT_OBJECTS;
    DWORD dwError = NO_ERROR;
    
    for (LONG i=0; i<dwNumBundles-1; i++)
    {
        dwError = WaitForMultipleObjects( MAXIMUM_WAIT_OBJECTS,
                                          &phThreads[i*MAXIMUM_WAIT_OBJECTS],
                                          fWaitAll,
                                          dwMilliseconds );
        if ( dwError == WAIT_FAILED )
        {
            goto Cleanup;
        }
    }

    dwError = WaitForMultipleObjects( dwRem,
                                      &phThreads[i*MAXIMUM_WAIT_OBJECTS],
                                      fWaitAll,
                                      dwMilliseconds );
    
Cleanup:
    return dwError;
}

EXTERN_C
NTSTATUS
TestEventGenMulti(
    IN  USHORT NumThreads,
    IN  ULONG  NumIter
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE* phThreads = NULL;
    DWORD* pdwThreadIds = NULL;
    PWSTR szMsg = NULL;
    DWORD dwError;

#ifdef USE_LOCAL_AUDIT
    Status = LsapAdtInitGenericAudits();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
#endif
    
    dwError = EnableSinglePrivilege( SE_AUDIT_NAME );

    if ( dwError != NO_ERROR )
    {
        szMsg = L"EnableSinglePrivilege: SeAuditPrivilege";
        Status = dwError;
        goto Cleanup;
    }
    
    phThreads = (HANDLE*) LocalAlloc( LMEM_ZEROINIT,
                                      sizeof(HANDLE) * NumThreads );
    if ( !phThreads )
    {
        Status = STATUS_NO_MEMORY;
        szMsg = L"LsapAllocateLsaHeap";
        goto Cleanup;
    }

    wprintf(L"Creating %d threads...\n", NumThreads);
    
    for (int i=0; i<NumThreads; i++)
    {
        phThreads[i] = CreateThread( NULL, 0,
                                     TestEventGenThreadProc, (PVOID) NumIter,
                                     CREATE_SUSPENDED, NULL );
        if (!phThreads[i])
        {
            szMsg = L"CreateThread";
            goto Cleanup;
        }
    }
    wprintf(L"...done\n");

    wprintf(L"Waiting for the threads to finish work...\n");

    for (int i=0; i<NumThreads; i++)
    {
        ResumeThread( phThreads[i] );
    }

    dwError = WaitForTonsOfObjects( NumThreads, phThreads, TRUE, INFINITE );
    if ( dwError == WAIT_FAILED )
    {
        szMsg = L"WaitForMultipleObjects";
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }
    
    for (int i=0; i<NumThreads; i++)
    {
        CloseHandle( phThreads[i] );
    }
    RtlZeroMemory( phThreads, sizeof(HANDLE) * NumThreads );
    
Cleanup:
    if ( szMsg )
    {
        wprintf (L"%s: %x\n", szMsg, Status);
    }

    for (i=0; i<NumThreads; i++)
    {
        if (phThreads[i])
        {
            TerminateThread( phThreads[i], 0 );
        }
    }

    LocalFree( phThreads );
    //LocalFree( pdwThreadIds );

    return Status;
}

EXTERN_C
NTSTATUS
GetSidName(
    IN  PSID   pSid,
    OUT PWSTR szName
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    LSA_OBJECT_ATTRIBUTES ObjectAttrs = { 0 };
    PLSA_REFERENCED_DOMAIN_LIST pDomains;
    PLSA_TRANSLATED_NAME pNames;
    LSA_HANDLE hLsa;

    *szName = UNICODE_NULL;
    
    Status = LsaOpenPolicy( NULL, &ObjectAttrs, POLICY_LOOKUP_NAMES, &hLsa );
    if (NT_SUCCESS(Status))
    {
        Status = LsaLookupSids( hLsa, 1, &pSid, &pDomains, &pNames );
        if (NT_SUCCESS(Status))
        {
            if (pDomains->Entries > 0)
            {
                lstrcpyn( szName, pDomains->Domains[0].Name.Buffer,
                          pDomains->Domains[0].Name.Length / sizeof(WCHAR) + 1);
                lstrcat( szName, L"\\" );
                if ( pNames[0].Use == SidTypeUser )
                {
                    lstrcat( szName, pNames[0].Name.Buffer );
                }
                else
                {
                    lstrcat( szName, L"unknown" );
                }
            }
        }
    }
    
    return Status;
}

DWORD 
EnableSinglePrivilege(
    IN PWCHAR szPrivName
    )
{
    DWORD dwError=NO_ERROR;
    HANDLE hToken;
    LUID   luidPriv;
    TOKEN_PRIVILEGES Privileges;
    //LUID_AND_ATTRIBUTES lna[1];

    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES,
                          &hToken))
    {
        goto GetError;
    }

    
    if (!LookupPrivilegeValue(NULL, szPrivName, &Privileges.Privileges[0].Luid))
    {
        goto GetError;
    }

    Privileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    Privileges.PrivilegeCount = 1;


    if (!AdjustTokenPrivileges(hToken, FALSE, &Privileges, 0, NULL, 0 ))
    {
        goto GetError;
    }

    CloseHandle(hToken);
    

Cleanup:

    return dwError;
    
GetError:
    dwError = GetLastError();
    goto Cleanup;
}


EXTERN_C
NTSTATUS
kElfReportEventW (
    IN      HANDLE          LogHandle,
    IN      USHORT          EventType,
    IN      USHORT          EventCategory OPTIONAL,
    IN      ULONG           EventID,
    IN      PSID            UserSid,
    IN      USHORT          NumStrings,
    IN      ULONG           DataSize,
    IN      PUNICODE_STRING *Strings,
    IN      PVOID           Data,
    IN      USHORT          Flags,
    IN OUT  PULONG          RecordNumber OPTIONAL,
    IN OUT  PULONG          TimeWritten  OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCWSTR szT;
    WCHAR szUserName[256];
    
    ASSERT((EventType == EVENTLOG_AUDIT_SUCCESS) ||
           (EventType == EVENTLOG_AUDIT_FAILURE));
    
    return Status;
    
    wprintf(L"-----------------------------------------------------------------\n");
    
    if (EventType == EVENTLOG_AUDIT_SUCCESS)
    {
        szT = L"AUDIT_SUCCESS";
    }
    else
    {
        szT = L"AUDIT_FAILURE";
    }

    wprintf(L"Type\t: %s\n", szT);

    wprintf(L"Category: %d\n", EventCategory);
    wprintf(L"AuditId\t: %d\n", EventID);

    if (STATUS_SUCCESS == GetSidName( UserSid, szUserName ))
    {
        wprintf(L"UserSid\t: %s\n\n", szUserName);
    }
    else
    {
        wprintf(L"UserSid\t: <NA>\n\n");
    }

    wprintf(L"#strings: %d\n", NumStrings);

    for (int i=0; i<NumStrings; i++)
    {
        wprintf(L"[%02d]\t: %wZ\n", i, Strings[i]);
    }

    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\audit\adtp.h ===
// empty file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\audit\main.cpp ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        M A I N . C P P
//
// Contents:    The main fn
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "adttest.h"

extern "C" int __cdecl wmain(int argc, PWSTR argv[])
{
    ULONG NumThreads = 1;
    ULONG  NumIter = 10;
    
    if ( argc == 2 )
    {
        swscanf(argv[1], L"%d", &NumThreads);
    }

    if ( argc == 3 )
    {
        swscanf(argv[1], L"%d", &NumThreads);
        swscanf(argv[2], L"%d", &NumIter);
    }

    printf("TestEventGenMulti: #threads: %d\t#iterations: %d...\n",
           NumThreads, NumIter);
    //getchar();
    
    TestEventGenMulti( (USHORT) NumThreads, NumIter );
    printf("TestEventGenMulti: done\n");
    
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\audit\lsaptmp.c ===
#include "pch.h"
#pragma hdrstop


#if !defined(lint)

#include "lsaptmp.h"
#include "adttest.h"

LUID AuditPrivilege = { SE_AUDIT_PRIVILEGE, 0 };

NTSTATUS
LsapGetLogonSessionAccountInfo(
    IN PLUID Value,
    OUT PUNICODE_STRING AccountName,
    OUT PUNICODE_STRING AuthorityName
    );


NTSTATUS
LsapRtlConvertSidToString(
    IN     PSID   Sid,
    OUT    PWSTR  szString,
    IN OUT DWORD *pdwRequiredSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PWSTR   szBufPtr = szString;
    ULONG   ulNumChars;
    UCHAR   i;
    ULONG   Tmp;
    PISID   iSid = (PISID)Sid;

    if ( *pdwRequiredSize < 256 )
    {
        Status = STATUS_BUFFER_OVERFLOW;
        *pdwRequiredSize = 256;
        goto Cleanup;
    }

    ulNumChars = wsprintf(szBufPtr, L"S-%u-", (USHORT)iSid->Revision );
    szBufPtr += ulNumChars;
    
    if (  (iSid->IdentifierAuthority.Value[0] != 0)  ||
          (iSid->IdentifierAuthority.Value[1] != 0)     )
    {
        ulNumChars = wsprintf(szBufPtr, L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                              (USHORT)iSid->IdentifierAuthority.Value[0],
                              (USHORT)iSid->IdentifierAuthority.Value[1],
                              (USHORT)iSid->IdentifierAuthority.Value[2],
                              (USHORT)iSid->IdentifierAuthority.Value[3],
                              (USHORT)iSid->IdentifierAuthority.Value[4],
                              (USHORT)iSid->IdentifierAuthority.Value[5] );
    }
    else
    {
        Tmp = (ULONG)iSid->IdentifierAuthority.Value[5]          +
              (ULONG)(iSid->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(iSid->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(iSid->IdentifierAuthority.Value[2] << 24);
        ulNumChars = wsprintf(szBufPtr, L"%lu", Tmp);
    }
    szBufPtr += ulNumChars;

    for (i=0;i<iSid->SubAuthorityCount ;i++ )
    {
        ulNumChars = wsprintf(szBufPtr, L"-%lu", iSid->SubAuthority[i]);
        szBufPtr += ulNumChars;
    }

Cleanup:

    return(Status);
}

PVOID NTAPI
LsapAllocateLsaHeap(
    IN ULONG cbMemory
    )
{
    return(RtlAllocateHeap(
                RtlProcessHeap(),
                HEAP_ZERO_MEMORY,
                cbMemory
                ));
}

void NTAPI
LsapFreeLsaHeap(
    IN PVOID pvMemory
    )
{

    RtlFreeHeap(RtlProcessHeap(), 0, pvMemory);

}


NTSTATUS
LsapAdtDemarshallAuditInfo(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters
    )

/*++

Routine Description:

    This routine will walk down a marshalled audit parameter
    array and unpack it so that its information may be passed
    into the event logging service.

    Three parallel data structures are maintained:

    StringArray - Array of Unicode string structures.  This array
    is used primarily as temporary storage for returned string
    structures.

    StringPointerArray - Array of pointers to Unicode string structures.

    FreeWhenDone - Array of booleans describing how to dispose of each
    of the strings pointed to by the StringPointerArray.


    Note that entries in the StringPointerArray are contiguous, but that
    there may be gaps in the StringArray structure.  For each entry in the
    StringPointerArray there will be a corresponding entry in the FreeWhenDone
    array.  If the entry for a particular string is TRUE, the storage for
    the string buffer will be released to the process heap.



      StringArray
                                       Other strings
    +----------------+
    |                |<-----------+  +----------------+
    |                |            |  |                |<-------------------+
    +----------------+            |  |                |                    |
    |    UNUSED      |            |  +----------------+                    |
    |                |            |                                        |
    +----------------+            |                                        |
    |                |<------+    |  +----------------+                    |
    |                |       |    |  |                |<-----------+       |
    +----------------+       |    |  |                |            |       |
    |    UNUSED      |       |    |  +----------------+            |       |
    |                |       |    |                                |       |
    +----------------+       |    |                                |       |
    |                |<--+   |    |                                |       |
    |                |   |   |    |                                |       |
    +----------------+   |   |    |                                |       |
    |                |   |   |    |                                |       |
    |                |   |   |    |     StringPointerArray         |       |
          ....           |   |    |                                |       |
                         |   |    |     +----------------+         |       |
                         |   |    +-----|                |         |       |
                         |   |          +----------------+         |       |
                         |   |          |                |---------+       |
                         |   |          +----------------+                 |
                         |   +----------|                |                 |
                         |              +----------------+                 |
                         |              |                |-----------------+
                         |              +----------------+
                         +--------------|                |
                                        +----------------+
                                        |                |
                                        +----------------+
                                        |                |
                                        +----------------+
                                        |                |
                                              ....


Arguments:

    AuditParameters - Receives a pointer to an audit
        parameters array in self-relative form.

Return Value:


--*/

{

    ULONG ParameterCount;
    USHORT i;
    PUNICODE_STRING StringPointerArray[SE_MAX_AUDIT_PARAM_STRINGS];
    UNICODE_STRING NewObjectTypeName;
    ULONG NewObjectTypeStringIndex = 0;
    BOOLEAN FreeWhenDone[SE_MAX_AUDIT_PARAM_STRINGS];
    UNICODE_STRING StringArray[SE_MAX_AUDIT_PARAM_STRINGS];
    USHORT StringIndexArray[SE_MAX_AUDIT_PARAM_STRINGS];
    USHORT StringIndex = 0;
    UNICODE_STRING DashString;
    BOOLEAN FreeDash;
    NTSTATUS Status;
    PUNICODE_STRING SourceModule;
    PSID UserSid;


    //
    // Initialization.
    //

    RtlInitUnicodeString( &NewObjectTypeName, NULL );

    Status= LsapAdtBuildDashString(
                &DashString,
                &FreeDash
                );

    if ( !NT_SUCCESS( Status )) {
        return( Status );
    }

    ParameterCount = AuditParameters->ParameterCount;

    //
    // Parameter 0 will always be the user SID.  Convert the
    // offset to the SID into a pointer.
    //

    ASSERT( AuditParameters->Parameters[0].Type == SeAdtParmTypeSid );



    UserSid =      (PSID)AuditParameters->Parameters[0].Address;



    //
    // Parameter 1 will always be the Source Module (or Subsystem Name).
    // Unpack this now.
    //

    ASSERT( AuditParameters->Parameters[1].Type == SeAdtParmTypeString );



    SourceModule = (PUNICODE_STRING)AuditParameters->Parameters[1].Address;


    for (i=2; i<ParameterCount; i++) {
        StringIndexArray[i] = StringIndex;

        switch ( AuditParameters->Parameters[i].Type ) {
            case SeAdtParmTypeNone:
                {
                    StringPointerArray[StringIndex] = &DashString;

                    FreeWhenDone[StringIndex] = FALSE;

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeString:
                {
                    StringPointerArray[StringIndex] =
                        (PUNICODE_STRING)AuditParameters->Parameters[i].Address;

                    FreeWhenDone[StringIndex] = FALSE;

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeFileSpec:
                {
                    //
                    // Same as a string, except we must attempt to replace
                    // device information with a drive letter.
                    //

                    StringPointerArray[StringIndex] =
                        (PUNICODE_STRING)AuditParameters->Parameters[i].Address;


                    //
                    // This may not do anything, in which case just audit what
                    // we have.
                    //

                    //LsapAdtSubstituteDriveLetter( StringPointerArray[StringIndex] );

                    FreeWhenDone[StringIndex] = FALSE;

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeUlong:
                {
                    ULONG Data;

                    Data = (ULONG) AuditParameters->Parameters[i].Data[0];

                    Status = LsapAdtBuildUlongString(
                                 Data,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];


                    } else {

                        //
                        // Couldn't allocate memory for that string,
                        // use the Dash string that we've already created.
                        //

                        StringPointerArray[StringIndex] = &DashString;
                        FreeWhenDone[StringIndex] = FALSE;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeHexUlong:
                {
                    ULONG Data;

                    Data = (ULONG) AuditParameters->Parameters[i].Data[0];

                    Status = LsapAdtBuildHexUlongString(
                                 Data,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];


                    } else {

                        //
                        // Couldn't allocate memory for that string,
                        // use the Dash string that we've already created.
                        //

                        StringPointerArray[StringIndex] = &DashString;
                        FreeWhenDone[StringIndex] = FALSE;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeSid:
                {
                    PSID Sid;

                    Sid = (PSID)AuditParameters->Parameters[i].Address;

                    Status = LsapAdtBuildSidString(
                                 Sid,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];

                    } else {

                        //
                        // Couldn't allocate memory for that string,
                        // use the Dash string that we've already created.
                        //

                        StringPointerArray[StringIndex] = &DashString;
                        FreeWhenDone[StringIndex] = FALSE;
                    }

                    StringIndex++;


                    break;
                }
            case SeAdtParmTypeLogonId:
                {
                    PLUID LogonId;
                    ULONG j;

                    LogonId = (PLUID)(&AuditParameters->Parameters[i].Data[0]);

                    Status = LsapAdtBuildLogonIdStrings(
                                 LogonId,
                                 &StringArray [ StringIndex     ],
                                 &FreeWhenDone[ StringIndex     ],
                                 &StringArray [ StringIndex + 1 ],
                                 &FreeWhenDone[ StringIndex + 1 ],
                                 &StringArray [ StringIndex + 2 ],
                                 &FreeWhenDone[ StringIndex + 2 ]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        for (j=0; j<3; j++) {

                            StringPointerArray[StringIndex] = &StringArray[StringIndex];
                            StringIndex++;
                        }

                        //
                        // Finished, break out to surrounding loop.
                        //

                        break;

                    } else {

                        //
                        // Do nothing, fall through to the NoLogonId case
                        //

                    }
                }
            case SeAdtParmTypeNoLogonId:
                {
                    ULONG j;
                    //
                    // Create three "-" strings.
                    //

                    for (j=0; j<3; j++) {

                        StringPointerArray[ StringIndex ] = &DashString;
                        FreeWhenDone[ StringIndex ] = FALSE;
                        StringIndex++;
                    }

                    break;
                }
            case SeAdtParmTypeAccessMask:
                {
                    PUNICODE_STRING ObjectTypeName;
                    ULONG ObjectTypeNameIndex;
                    ACCESS_MASK Accesses;

                    ObjectTypeNameIndex = (ULONG) AuditParameters->Parameters[i].Data[1];
                    ObjectTypeName = AuditParameters->Parameters[ObjectTypeNameIndex].Address;
                    Accesses= (ACCESS_MASK) AuditParameters->Parameters[i].Data[0];

                    //
                    // We can determine the index to the ObjectTypeName
                    // parameter since it was stored away in the Data[1]
                    // field of this parameter.
                    //

                    Status = LsapAdtBuildAccessesString(
                                 SourceModule,
                                 ObjectTypeName,
                                 Accesses,
                                 TRUE,
                                 &StringArray [ StringIndex ],
                                 &FreeWhenDone[ StringIndex ]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[ StringIndex ] = &StringArray[ StringIndex ];

                    } else {

                        //
                        // That didn't work, use the Dash string instead.
                        //

                        StringPointerArray[ StringIndex ] = &DashString;
                        FreeWhenDone      [ StringIndex ] = FALSE;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypePrivs:
                {

                    PPRIVILEGE_SET Privileges = (PPRIVILEGE_SET)AuditParameters->Parameters[i].Address;

                    Status = LsapBuildPrivilegeAuditString(
                                 Privileges,
                                 &StringArray [ StringIndex ],
                                 &FreeWhenDone[ StringIndex ]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[ StringIndex ] = &StringArray[ StringIndex ];

                    } else {

                        //
                        // That didn't work, use the Dash string instead.
                        //

                        StringPointerArray[ StringIndex ] = &DashString;
                        FreeWhenDone      [ StringIndex ] = FALSE;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeObjectTypes:
                {
                    PUNICODE_STRING ObjectTypeName;
                    ULONG ObjectTypeNameIndex;
                    PSE_ADT_OBJECT_TYPE ObjectTypeList;
                    ULONG ObjectTypeCount;
                    ULONG j;

                    ObjectTypeNameIndex = (ULONG) AuditParameters->Parameters[i].Data[1];
                    NewObjectTypeStringIndex = StringIndexArray[ObjectTypeNameIndex];
                    ObjectTypeName = AuditParameters->Parameters[ObjectTypeNameIndex].Address;
                    ObjectTypeList = AuditParameters->Parameters[i].Address;
                    ObjectTypeCount = AuditParameters->Parameters[i].Length / sizeof(SE_ADT_OBJECT_TYPE);

                    //
                    // Will Fill in 10 entries.
                    Status = LsapAdtBuildObjectTypeStrings(
                                 SourceModule,
                                 ObjectTypeName,
                                 ObjectTypeList,
                                 ObjectTypeCount,
                                 &StringArray [ StringIndex ],
                                 &FreeWhenDone[ StringIndex ],
                                 &NewObjectTypeName
                                 );

                    for (j=0; j<10; j++) {
                        StringPointerArray[StringIndex] = &StringArray[StringIndex];
                        StringIndex++;
                    }


                    //
                    //
                    // &StringArray [ StringIndexArray[ObjectTypeNameIndex]],
                    // &FreeWhenDone[ StringIndexArray[ObjectTypeNameIndex]],

                    //
                    // Finished, break out to surrounding loop.
                    //

                    break;
                }
            case SeAdtParmTypePtr:
                {
                    PVOID Data;

                    Data = (PVOID) AuditParameters->Parameters[i].Data[0];

                    Status = LsapAdtBuildPtrString(
                                 Data,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];


                    } else {

                        //
                        // Couldn't allocate memory for that string,
                        // use the Dash string that we've already created.
                        //

                        StringPointerArray[StringIndex] = &DashString;
                        FreeWhenDone[StringIndex] = FALSE;
                    }

                    StringIndex++;

                    break;
                }
        }
    }

    //
    // If the generic object type name has been converted to something
    //  specific to this audit,
    //  substitute it now.
    //

    if ( NewObjectTypeName.Length != 0 ) {

        //
        // Free the previous object type name.
        //
        if ( FreeWhenDone[NewObjectTypeStringIndex] ) {
            LsapFreeLsaHeap( StringPointerArray[NewObjectTypeStringIndex]->Buffer );
        }

        //
        // Save the new object type name.
        //

        FreeWhenDone[NewObjectTypeStringIndex] = TRUE;
        StringPointerArray[NewObjectTypeStringIndex] = &NewObjectTypeName;

    }

    //
    // Probably have to do this from somewhere else eventually, but for now
    // do it from here.
    //

    Status = kElfReportEventW (
                 NULL, //LsapAdtLogHandle,
                 AuditParameters->Type,
                 (USHORT)AuditParameters->CategoryId,
                 AuditParameters->AuditId,
                 UserSid,
                 StringIndex,
                 0,
                 StringPointerArray,
                 NULL,
                 0,
                 NULL,
                 NULL
                 );

    //
    // cleanup
    //

    for (i=0; i<StringIndex; i++) {

        if (FreeWhenDone[i]) {
            LsapFreeLsaHeap( StringPointerArray[i]->Buffer );
        }
    }

    //
    // If we are shutting down and we got an expected error back from the
    // eventlog, don't worry about it. This prevents bugchecking from an
    // audit failure while shutting down.
    //

    if ( ( (Status == RPC_NT_UNKNOWN_IF) || (Status == STATUS_UNSUCCESSFUL)) &&
         TRUE /*LsapState.SystemShutdownPending*/ ) {
        Status = STATUS_SUCCESS;
    }
    return( Status );
}

// ======================================================================
// adtbuild.c
// ======================================================================



////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Local Macro definitions and local function prototypes             //
//                                                                    //
////////////////////////////////////////////////////////////////////////



#ifdef LSAP_ADT_UMTEST

//
// Define all external routines that we won't pick up in a user mode test
//

// NTSTATUS
// LsapGetLogonSessionAccountInfo(
//     IN PLUID Value,
//     OUT PUNICODE_STRING AccountName,
//     OUT PUNICODE_STRING AuthorityName
//     );



#endif



////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Data types used within this module                                //
//                                                                    //
////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Variables global within this module                               //
//                                                                    //
////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Services exported by this module.                                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////


NTSTATUS
LsapAdtBuildUlongString(
    IN ULONG Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed value.

    The resultant string will be formatted as a decimal value with not
    more than 10 digits.


Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;



    //
    // Maximum length is 10 wchar characters plus a null termination character.
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = 11 * sizeof(WCHAR); // 10 digits & null termination

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL) {
        return(STATUS_NO_MEMORY);
    }




    Status = RtlIntegerToUnicodeString( Value, 10, ResultantString );
    ASSERT(NT_SUCCESS(Status));


    (*FreeWhenDone) = TRUE;
    return(STATUS_SUCCESS);



}


NTSTATUS
LsapAdtBuildHexUlongString(
    IN ULONG Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed value.

    The resultant string will be formatted as a hexidecimal value with not
    more than 10 digits.


Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;



    //
    // Maximum length is 10 wchar characters plus a null termination character.
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = 11 * sizeof(WCHAR); // 8 digits, a 0x, & null termination

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL) {
        return(STATUS_NO_MEMORY);
    }


    ResultantString->Buffer[0] = L'0';
    ResultantString->Buffer[1] = L'x';
    ResultantString->Buffer += 2;


    Status = RtlIntegerToUnicodeString( Value, 16, ResultantString );
    ASSERT(NT_SUCCESS(Status));

    //
    // Subtract off the two
    //

    ResultantString->Buffer -= 2;
    ResultantString->Length += 2 * sizeof(WCHAR);

    (*FreeWhenDone) = TRUE;
    return(STATUS_SUCCESS);



}


NTSTATUS
LsapAdtBuildPtrString(
    IN  PVOID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed pointer.

    The resultant string will be formatted as a hexidecimal value.


Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT NumChars;
    
    ResultantString->Length        = 0;
    //
    // Maximum length: 0x + 16 digit hex + null + 1 bonus == 20 chars
    //
    ResultantString->MaximumLength = 20 * sizeof(WCHAR);

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL) {
    
        Status = STATUS_NO_MEMORY;

    } else {
    
        NumChars = (USHORT) wsprintf( ResultantString->Buffer, L"0x%p", Value );

        ResultantString->Length = NumChars * sizeof(WCHAR);

        (*FreeWhenDone) = TRUE;
    }
    
    return Status;
}


NTSTATUS
LsapAdtBuildLuidString(
    IN PLUID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed LUID.

    The resultant string will be formatted as follows:

        (0x00005678,0x12340000)

Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;

    UNICODE_STRING          IntegerString;


    ULONG                   Buffer[(16*sizeof(WCHAR))/sizeof(ULONG)];


    IntegerString.Buffer = (PWCHAR)&Buffer[0];
    IntegerString.MaximumLength = 16*sizeof(WCHAR);


    //
    // Length (in WCHARS) is  3 for   (0x
    //                       10 for   1st hex number
    //                        3 for   ,0x
    //                       10 for   2nd hex number
    //                        1 for   )
    //                        1 for   null termination
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = 28 * sizeof(WCHAR);

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL) {
        return(STATUS_NO_MEMORY);
    }



    Status = RtlAppendUnicodeToString( ResultantString, L"(0x" );
    ASSERT(NT_SUCCESS(Status));


    Status = RtlIntegerToUnicodeString( Value->HighPart, 16, &IntegerString );
    ASSERT(NT_SUCCESS(Status));
    Status = RtlAppendUnicodeToString( ResultantString, IntegerString.Buffer );
    ASSERT(NT_SUCCESS(Status));


    Status = RtlAppendUnicodeToString( ResultantString, L",0x" );
    ASSERT(NT_SUCCESS(Status));

    Status = RtlIntegerToUnicodeString( Value->LowPart, 16, &IntegerString );
    ASSERT(NT_SUCCESS(Status));
    Status = RtlAppendUnicodeToString( ResultantString, IntegerString.Buffer );
    ASSERT(NT_SUCCESS(Status));

    Status = RtlAppendUnicodeToString( ResultantString, L")" );
    ASSERT(NT_SUCCESS(Status));


    (*FreeWhenDone) = TRUE;
    return(STATUS_SUCCESS);



}


NTSTATUS
LsapAdtBuildSidString(
    IN PSID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed LUID.

    The resultant string will be formatted as follows:

        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal

Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status=STATUS_NO_MEMORY;
    LPWSTR   UniBuffer=NULL;
    USHORT   Len;
    USHORT   MaxLen;
    
    *FreeWhenDone = FALSE;
    //
    // Note: RtlConvertSidToUnicodeString also uses a hard-coded const 256
    //       to generate the string SID.
    //
    MaxLen    = (256+3) * sizeof(WCHAR);
    UniBuffer = LsapAllocateLsaHeap(MaxLen);

    if (UniBuffer)
    {
        ResultantString->Buffer        = UniBuffer+2;
        ResultantString->MaximumLength = MaxLen;
        Status = RtlConvertSidToUnicodeString( ResultantString, Value, FALSE );

        if (Status == STATUS_SUCCESS)
        {
            *FreeWhenDone = TRUE;
            UniBuffer[0] = L'%';
            UniBuffer[1] = L'{';
            Len = ResultantString->Length / sizeof(WCHAR);
            UniBuffer[Len+2] = L'}';
            UniBuffer[Len+3] = UNICODE_NULL;
            ResultantString->Buffer = UniBuffer;
            ResultantString->Length = (Len+3)*sizeof(WCHAR);
        }
        else
        {
            LsapFreeLsaHeap(UniBuffer);
        }
    }

    return(Status);
}



NTSTATUS
LsapAdtBuildDashString(
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function returns a string containing a dash ("-").
    This is commonly used to represent "No value" in audit records.


Arguments:


    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_SUCCESS only.

--*/

{
    RtlInitUnicodeString(ResultantString, L"-");

    (*FreeWhenDone) = FALSE;

    return STATUS_SUCCESS;
}




NTSTATUS
LsapAdtBuildFilePathString(
    IN PUNICODE_STRING Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed file
    path name.  If possible, the string will be generated using drive
    letters instead of object architecture namespace.


Arguments:

    Value - The original file path name.  This is expected (but does not
        have to be) a standard NT object architecture name-space pathname.

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status = STATUS_SUCCESS;



    //
    // For now, don't do the conversion.
    // Do this if we have time before we ship.
    //

    ResultantString->Length        = Value->Length;
    ResultantString->Buffer        = Value->Buffer;
    ResultantString->MaximumLength = Value->MaximumLength;


    (*FreeWhenDone) = FALSE;
    return(Status);
}




NTSTATUS
LsapAdtBuildLogonIdStrings(
    IN PLUID LogonId,
    OUT PUNICODE_STRING ResultantString1,
    OUT PBOOLEAN FreeWhenDone1,
    OUT PUNICODE_STRING ResultantString2,
    OUT PBOOLEAN FreeWhenDone2,
    OUT PUNICODE_STRING ResultantString3,
    OUT PBOOLEAN FreeWhenDone3
    )

/*++

Routine Description:

    This function builds a 3 unicode strings representing the specified
    logon ID.  These strings will contain the username, domain, and
    LUID string of the specified logon session (respectively).


Arguments:

    Value - The logon ID.

    ResultantString1 - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

        This parameter will contain the username.


    FreeWhenDone1 - If TRUE, indicates that the body of ResultantString1
        must be freed to process heap when no longer needed.

    ResultantString2 - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

        This parameter will contain the username.


    FreeWhenDone2 - If TRUE, indicates that the body of ResultantString2
        must be freed to process heap when no longer needed.

    ResultantString3 - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

        This parameter will contain the username.


    FreeWhenDone3 - If TRUE, indicates that the body of ResultantString3
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;
    UNICODE_STRING DashString;
    BOOLEAN FreeDash;
    
    //
    // Try to convert the LUID first.
    //

    Status= LsapAdtBuildDashString(
                &DashString,
                &FreeDash
                );

    if ( !NT_SUCCESS( Status )) {
        return( Status );
    }

    Status = LsapAdtBuildLuidString( LogonId, ResultantString3, FreeWhenDone3 );

    if (NT_SUCCESS(Status)) {

//         *ResultantString1 = DashString;
//         *ResultantString2 = DashString;
        *FreeWhenDone1 = FALSE;
        *FreeWhenDone2 = FALSE;
        
        //
        // Now get the username and domain names
        //

        Status = LsapGetLogonSessionAccountInfo( LogonId,
                                                 ResultantString1,
                                                 ResultantString2
                                                 );

        if (NT_SUCCESS(Status)) {

//             (*FreeWhenDone1) = TRUE;
//             (*FreeWhenDone2) = TRUE;

        } else {

            //
            // The LUID may be the system LUID
            //

            LUID SystemLuid = SYSTEM_LUID;

            if ( RtlEqualLuid( LogonId, &SystemLuid )) {

                RtlInitUnicodeString(ResultantString1, L"SYSTEM");
                RtlInitUnicodeString(ResultantString2, L"SYSTEM");

                (*FreeWhenDone1) = FALSE;
                (*FreeWhenDone2) = FALSE;

                Status = STATUS_SUCCESS;

            } else {

                //
                // We have no clue what this is, just free what we've
                // allocated.
                //

                if ((FreeWhenDone3)) {
                    LsapFreeLsaHeap( ResultantString3->Buffer );
                }
            }
        }
    }

    return(Status);

}






////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Services private to this module.                                  //
//                                                                    //
////////////////////////////////////////////////////////////////////////





//
// Define this routine only for user mode test
//

NTSTATUS
LsapGetLogonSessionAccountInfo(
    IN PLUID Value,
    OUT PUNICODE_STRING AccountName,
    OUT PUNICODE_STRING AuthorityName
    )

{
    NTSTATUS        Status = STATUS_UNSUCCESSFUL;
    HRESULT hr;
    SECURITY_USER_DATA* pUserData;
    
    hr = GetSecurityUserInfo( Value, 0, &pUserData  );
    if (SUCCEEDED(hr))
    {
        Status = STATUS_SUCCESS;
        *AccountName   = pUserData->UserName;
        *AuthorityName = pUserData->LogonDomainName;
    }

    
    return(Status);
}


// ======================================================================
// from adtobjs.c
// ======================================================================

#define LSAP_ADT_OBJECT_TYPE_STRINGS 10
#define LSAP_ADT_ACCESS_NAME_FORMATTING L"\r\n\t\t\t"
#define LSAP_ADT_ACCESS_NAME_FORMATTING_TAB L"\t"
#define LSAP_ADT_ACCESS_NAME_FORMATTING_NL L"\r\n"


UNICODE_STRING          LsapAdtEventIdStringDelete,
                        LsapAdtEventIdStringReadControl,
                        LsapAdtEventIdStringWriteDac,
                        LsapAdtEventIdStringWriteOwner,
                        LsapAdtEventIdStringSynchronize,
                        LsapAdtEventIdStringAccessSysSec,
                        LsapAdtEventIdStringMaxAllowed,
                        LsapAdtEventIdStringSpecific[16];


#define LsapAdtSourceModuleLock()    0
#define LsapAdtSourceModuleUnlock()  0




//
// Each event source is represented by a source module descriptor.
// These are kept on a linked list (LsapAdtSourceModules).
//

typedef struct _LSAP_ADT_OBJECT {

    //
    // Pointer to next source module descriptor
    // This is assumed to be the first field in the structure.
    //

    struct _LSAP_ADT_OBJECT *Next;

    //
    // Name of object
    //

    UNICODE_STRING Name;

    //
    // Base offset of specific access types
    //

    ULONG BaseOffset;

} LSAP_ADT_OBJECT, *PLSAP_ADT_OBJECT;




//
// Each event source is represented by a source module descriptor.
// These are kept on a linked list (LsapAdtSourceModules).
//

typedef struct _LSAP_ADT_SOURCE {

    //
    // Pointer to next source module descriptor
    // This is assumed to be the first field in the structure.
    //

    struct _LSAP_ADT_SOURCE *Next;

    //
    // Name of source module
    //

    UNICODE_STRING Name;

    //
    // list of objects
    //

    PLSAP_ADT_OBJECT Objects;

} LSAP_ADT_SOURCE, *PLSAP_ADT_SOURCE;


PLSAP_ADT_SOURCE LsapAdtSourceModules;



NTSTATUS
LsapDsGuidToString(
    IN GUID *ObjectType,
    IN PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine converts a GUID to a string.  The GUID is one of the following:

        Class Guid indicating the class of an object.
        Property Set Guid identifying a property set.
        Property Guid identifying a property.

    In each case, the routine returns a text string naming the object/property
    set or property.

    If the passed in GUID is cannot be found in the schema,
    the GUID will simply be converted to a text string.


Arguments:

    ObjectType - Specifies the GUID to translate.

    UnicodeString - Returns the text string.

Return Values:

    STATUS_NO_MEMORY - Not enough memory to allocate string.


--*/

{
    NTSTATUS Status;
    RPC_STATUS RpcStatus;
    LPWSTR GuidString = NULL;
    ULONG GuidStringSize;
    ULONG GuidStringLen;
    LPWSTR LocalGuidString;

    //
    // Convert the GUID to text
    //

    RpcStatus = UuidToStringW( ObjectType,
                               &GuidString );

    if ( RpcStatus != RPC_S_OK ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    GuidStringLen = wcslen( GuidString );
    GuidStringSize = (GuidStringLen + 4) * sizeof(WCHAR);

    LocalGuidString = LsapAllocateLsaHeap( GuidStringSize );

    if ( LocalGuidString == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    LocalGuidString[0] = L'%';
    LocalGuidString[1] = L'{';
    RtlCopyMemory( &LocalGuidString[2], GuidString, GuidStringLen*sizeof(WCHAR) );
    LocalGuidString[GuidStringLen+2] = L'}';
    LocalGuidString[GuidStringLen+3] = L'\0';
    RtlInitUnicodeString( UnicodeString, LocalGuidString );

    Status = STATUS_SUCCESS;

Cleanup:
    if ( GuidString != NULL ) {
        RpcStringFreeW( &GuidString );
    }
    return Status;
}


NTSTATUS
LsapAdtAppendString(
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone,
    IN PUNICODE_STRING StringToAppend,
    IN PULONG StringIndex
    )

/*++

Routine Description:

    This function appends a string to the next available of the LSAP_ADT_OBJECT_TYPE_STRINGS unicode
    output strings.


Arguments:

    ResultantString - Points to an array of LSAP_ADT_OBJECT_TYPE_STRINGS unicode string headers.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.

    StringToAppend - String to be appended to ResultantString.

    StringIndex - Index to the current ResultantString to be used.
        Passes in an index to the resultant string to use.
        Passes out the index to the resultant string being used.

Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        to store the object information.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING SourceString;
    ULONG Index;
// Must be multiple of sizeof(WCHAR)
#define ADT_MAX_STRING 0xFFFE

    //
    // Initialization.
    //

    SourceString = *StringToAppend;
    Index = *StringIndex;

    //
    // If all of the strings are already full,
    //  early out.
    //

    if ( Index >= LSAP_ADT_OBJECT_TYPE_STRINGS ) {
        return STATUS_SUCCESS;
    }

    //
    // Loop until the source string is completely appended.
    //

    while ( SourceString.Length ) {

        //
        // If the destination string has room,
        //  append to it.
        //

        if ( FreeWhenDone[Index] && ResultantString[Index].Length != ADT_MAX_STRING ){
            UNICODE_STRING SubString;
            USHORT RoomLeft;

            //
            // If the Source String is a replacement string,
            //  make sure we don't split it across a ResultantString boundary
            //

            RoomLeft = ResultantString[Index].MaximumLength -
                       ResultantString[Index].Length;

            if ( SourceString.Buffer[0] != L'%' ||
                 RoomLeft >= SourceString.Length ) {

                //
                // Compute the substring that fits.
                //

                SubString.Length = min( RoomLeft, SourceString.Length );
                SubString.Buffer = SourceString.Buffer;

                SourceString.Length -= SubString.Length;
                SourceString.Buffer = (LPWSTR)(((LPBYTE)SourceString.Buffer) + SubString.Length);


                //
                // Append the substring onto the destination.
                //

                Status = RtlAppendUnicodeStringToString(
                                    &ResultantString[Index],
                                    &SubString );

                ASSERT(NT_SUCCESS(Status));

            }



        }

        //
        // If there's more to copy,
        //  grow the buffer.
        //

        if ( SourceString.Length ) {
            ULONG NewSize;
            LPWSTR NewBuffer;

            //
            // If the current buffer is full,
            //  move to the next buffer.
            //

            if ( ResultantString[Index].Length == ADT_MAX_STRING ) {

                //
                // If ALL of the buffers are full,
                //  silently return to the caller.
                //
                Index ++;

                if ( Index >= LSAP_ADT_OBJECT_TYPE_STRINGS ) {
                    *StringIndex = Index;
                    return STATUS_SUCCESS;
                }
            }

            //
            // Allocate a buffer suitable for both the old string and the new one.
            //
            // Allocate the buffer at least large enough for the new string.
            // Always grow the buffer in 1Kb chunks.
            // Don't allocate larger than the maximum allowed size.
            //

            NewSize = max( ResultantString[Index].MaximumLength + 1024,
                           SourceString.Length );
            NewSize = min( NewSize, ADT_MAX_STRING );

            NewBuffer = LsapAllocateLsaHeap( NewSize );

            if ( NewBuffer == NULL ) {
                *StringIndex = Index;
                return STATUS_NO_MEMORY;
            }

            //
            // Copy the old buffer into the new buffer.
            //

            if ( ResultantString[Index].Buffer != NULL ) {
                RtlCopyMemory( NewBuffer,
                               ResultantString[Index].Buffer,
                               ResultantString[Index].Length );

                if ( FreeWhenDone[Index] ) {
                    LsapFreeLsaHeap( ResultantString[Index].Buffer );
                }
            }

            ResultantString[Index].Buffer = NewBuffer;
            ResultantString[Index].MaximumLength = (USHORT) NewSize;
            FreeWhenDone[Index] = TRUE;

        }
    }

    *StringIndex = Index;
    return STATUS_SUCCESS;

}


NTSTATUS
LsapAdtAppendZString(
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone,
    IN LPWSTR StringToAppend,
    IN PULONG StringIndex
    )

/*++

Routine Description:

    Same as LsapAdpAppendString but takes a zero terminated string.

Arguments:

    Same as LsapAdpAppendString but takes a zero terminated string.

Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        to store the object information.

    All other Result Codes are generated by called routines.

--*/

{
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, StringToAppend );

    return LsapAdtAppendString( ResultantString,
                                FreeWhenDone,
                                &UnicodeString,
                                StringIndex );
}

ULONG
__cdecl
CompareObjectTypes(
    const void * Param1,
    const void * Param2
    )

/*++

Routine Description:

    Qsort comparison routine for sorting an object type array by access mask.

--*/
{
    const SE_ADT_OBJECT_TYPE *ObjectType1 = Param1;
    const SE_ADT_OBJECT_TYPE *ObjectType2 = Param2;

    return ObjectType1->AccessMask - ObjectType2->AccessMask;
}



NTSTATUS
LsapAdtBuildObjectTypeStrings(
    IN PUNICODE_STRING SourceModule,
    IN PUNICODE_STRING ObjectTypeName,
    IN PSE_ADT_OBJECT_TYPE ObjectTypeList,
    IN ULONG ObjectTypeCount,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone,
    OUT PUNICODE_STRING NewObjectTypeName
    )

/*++

Routine Description:

    This function builds a LSAP_ADT_OBJECT_TYPE_STRINGS unicode strings containing parameter
    file replacement parameters (e.g. %%1043) and Object GUIDs separated by carriage
    return and tab characters suitable for display via the event viewer.


    The buffers returned by this routine must be deallocated when no
    longer needed if FreeWhenDone is true.


Arguments:

    SourceModule - The module (ala event viewer modules) defining the
        object type.

    ObjectTypeName - The type of object to which the access mask applies.

    ObjectTypeList - List of objects being granted access.

    ObjectTypeCount - Number of objects in ObjectTypeList.

    ResultantString - Points to an array of LSAP_ADT_OBJECT_TYPE_STRINGS unicode string headers.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.


    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.

    NewObjectTypeName - Returns a new name for the object type if one is
        available.

Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        to store the object information.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING LocalString;
    LPWSTR GuidString;
    UNICODE_STRING DsSourceName;
    UNICODE_STRING DsObjectTypeName;
    BOOLEAN LocalFreeWhenDone;
    ULONG ResultantStringIndex = 0;
    ULONG i;
    ACCESS_MASK PreviousAccessMask;
    ULONG Index;
    BOOLEAN IsDs;
    USHORT IndentLevel;

    static LPWSTR Tabs[] =
    {
        L"\t",
        L"\t\t",
        L"\t\t\t",
        L"\t\t\t\t"
    };
    USHORT cTabs = sizeof(Tabs) / sizeof(LPWSTR);

    //
    // Initialize all LSAP_ADT_OBJECT_TYPE_STRINGS buffers to empty strings
    //

    for ( i=0; i<LSAP_ADT_OBJECT_TYPE_STRINGS; i++ ) {
        RtlInitUnicodeString( &ResultantString[i], L"" );
        FreeWhenDone[i] = FALSE;
    }

    //
    // If there are no objects,
    //  we're done.
    //

    if ( ObjectTypeCount == 0 ) {
        return STATUS_SUCCESS;
    }

    //
    // Determine if this entry is for the DS.
    //

    RtlInitUnicodeString( &DsSourceName, ACCESS_DS_SOURCE_W );
    RtlInitUnicodeString( &DsObjectTypeName, ACCESS_DS_OBJECT_TYPE_NAME_W );

    IsDs = RtlEqualUnicodeString( SourceModule, &DsSourceName, TRUE) &&
           RtlEqualUnicodeString( ObjectTypeName, &DsObjectTypeName, TRUE);


    //
    // Group the objects with like access masks together.
    //  (Simply sort them).
    //

    qsort( ObjectTypeList,
           ObjectTypeCount,
           sizeof(SE_ADT_OBJECT_TYPE),
           CompareObjectTypes );

    //
    // Loop through the objects outputting a line for each one.
    //

    PreviousAccessMask = ObjectTypeList[0].AccessMask -1;
    for ( Index=0; Index<ObjectTypeCount; Index++ ) {

        if ( IsDs &&
             ObjectTypeList[Index].Level == ACCESS_OBJECT_GUID &&
             NewObjectTypeName->Length == 0 ) {

            (VOID) LsapDsGuidToString( &ObjectTypeList[Index].ObjectType,
                                      NewObjectTypeName );
        }

        //
        // If this entry simply represents the object itself,
        //  skip it.

        if ( ObjectTypeList[Index].Flags & SE_ADT_OBJECT_ONLY ) {
            continue;
        }

        //
        // If this access mask is different than the one for the previous
        //  object,
        //  output a new copy of the access mask.
        //

        if ( ObjectTypeList[Index].AccessMask != PreviousAccessMask ) {

            PreviousAccessMask = ObjectTypeList[Index].AccessMask;

            if ( ObjectTypeList[Index].AccessMask == 0 ) {
                RtlInitUnicodeString( &LocalString,
                                      L"---" LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
                LocalFreeWhenDone = FALSE;
            } else {

                //
                // Build a string with the access mask in it.
                //

                Status = LsapAdtBuildAccessesString(
                                  SourceModule,
                                  ObjectTypeName,
                                  ObjectTypeList[Index].AccessMask,
                                  FALSE,
                                  &LocalString,
                                  &LocalFreeWhenDone );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }
            }

            //
            // Append it to the output string.
            //

            Status = LsapAdtAppendString(
                        ResultantString,
                        FreeWhenDone,
                        &LocalString,
                        &ResultantStringIndex );

            if ( LocalFreeWhenDone ) {
                LsapFreeLsaHeap( LocalString.Buffer );
            }

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }
        }

        IndentLevel = ObjectTypeList[Index].Level;

        if (IndentLevel >= cTabs) {
            IndentLevel = cTabs-1;
        }
        
        //
        // Indent the GUID.
        //

        Status = LsapAdtAppendZString(
            ResultantString,
            FreeWhenDone,
            Tabs[IndentLevel],
            &ResultantStringIndex );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // If this is the DS,
        //  convert the GUID to a name from the schema.
        //

        Status = LsapDsGuidToString( &ObjectTypeList[Index].ObjectType,
                                     &LocalString );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // Append the GUID string to the output strings.
        //

        Status = LsapAdtAppendString(
                    ResultantString,
                    FreeWhenDone,
                    &LocalString,
                    &ResultantStringIndex );

        LsapFreeLsaHeap( LocalString.Buffer );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // Put the GUID on a line by itself.
        //

        Status = LsapAdtAppendZString(
                    ResultantString,
                    FreeWhenDone,
                    LSAP_ADT_ACCESS_NAME_FORMATTING_NL,
                    &ResultantStringIndex );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

    }

    Status = STATUS_SUCCESS;
Cleanup:
    return Status;
}




NTSTATUS
LsapAdtBuildAccessesString(
    IN PUNICODE_STRING SourceModule,
    IN PUNICODE_STRING ObjectTypeName,
    IN ACCESS_MASK Accesses,
    IN BOOLEAN Indent,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string containing parameter
    file replacement parameters (e.g. %%1043) separated by carriage
    return and tab characters suitable for display via the event viewer.


    The buffer returned by this routine must be deallocated when no
    longer needed if FreeWhenDone is true.


    NOTE: To enhance performance, each time a target source module
          descriptor is found, it is moved to the beginning of the
          source module list.  This ensures frequently accessed source
          modules are always near the front of the list.

          Similarly, target object descriptors are moved to the front
          of their lists when found.  This further ensures high performance
          by quicly locating



Arguments:

    SourceModule - The module (ala event viewer modules) defining the
        object type.

    ObjectTypeName - The type of object to which the access mask applies.

    Accesses - The access mask to be used in building the display string.

    Indent - Access Mask should be indented.

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.


    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.

Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        to store the object information.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG AccessCount = 0;
    ULONG BaseOffset;
    ULONG i;
    ACCESS_MASK Mask;
    PLSAP_ADT_SOURCE Source;
    PLSAP_ADT_SOURCE FoundSource = NULL;
    PLSAP_ADT_OBJECT Object;
    PLSAP_ADT_OBJECT FoundObject = NULL;
    BOOLEAN Found;

#ifdef LSAP_ADT_TEST_DUMP_SOURCES
    printf("Module:\t%wS\n", SourceModule);
    printf("\t   Object:\t%wS\n", ObjectTypeName);
    printf("\t Accesses:\t0x%lx\n", Accesses);
#endif

    //
    // If we have no accesses, return "-"
    //

    if (Accesses == 0) {

        RtlInitUnicodeString( ResultantString, L"-" );
        (*FreeWhenDone) = FALSE;
        return(STATUS_SUCCESS);
    }

    //
    // First figure out how large a buffer we need
    //

    Mask = Accesses;

    //
    // Count the number of set bits in the
    // passed access mask.
    //

    while ( Mask != 0 ) {
        Mask = Mask & (Mask - 1);
        AccessCount++;
    }


#ifdef LSAP_ADT_TEST_DUMP_SOURCES
    printf("\t          \t%d bits set in mask.\n", AccessCount);
#endif


    //
    // We have accesses, allocate a string large enough to deal
    // with them all.  Strings will be of the format:
    //
    //      %%nnnnnnnnnn\n\r\t\t%%nnnnnnnnnn\n\r\t\t ... %nnnnnnnnnn\n\r\t\t
    //
    // where nnnnnnnnnn - is a decimal number 10 digits long or less.
    //
    // So, a typical string will look like:
    //
    //      %%601\n\r\t\t%%1604\n\r\t\t%%1608\n
    //
    // Since each such access may use at most:
    //
    //          10  (for the nnnnnnnnnn digit)
    //        +  2  (for %%)
    //        +  8  (for \n\t\t)
    //        --------------------------------
    //          20  wide characters
    //
    // The total length of the output string will be:
    //
    //           AccessCount    (number of accesses)
    //         x          20    (size of each entry)
    //         -------------------------------------
    //                          wchars
    //
    // Throw in 1 more WCHAR for null termination, and we are all set.
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = (USHORT)AccessCount * (20 * sizeof(WCHAR)) +
                                 sizeof(WCHAR);  //for the null termination

#ifdef LSAP_ADT_TEST_DUMP_SOURCES
    printf("\t          \t%d byte buffer allocated.\n", ResultantString->MaximumLength);
#endif
    ResultantString->Buffer = LsapAllocateLsaHeap( ResultantString->MaximumLength );


    if (ResultantString->Buffer == NULL) {

        return(STATUS_NO_MEMORY);
    }

    (*FreeWhenDone) = TRUE;

    //
    // Special case standard and special access types.
    // Walk the lists for specific access types.
    //

    if (Accesses & STANDARD_RIGHTS_ALL) {

        if (Accesses & DELETE) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringDelete);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));

        }


        if (Accesses & READ_CONTROL) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringReadControl);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));
        }


        if (Accesses & WRITE_DAC) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringWriteDac);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));
        }


        if (Accesses & WRITE_OWNER) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringWriteOwner);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));
        }

        if (Accesses & SYNCHRONIZE) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringSynchronize);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));
        }
    }


    if (Accesses & ACCESS_SYSTEM_SECURITY) {

        Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
        ASSERT( NT_SUCCESS( Status ));

        Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringAccessSysSec);
        ASSERT( NT_SUCCESS( Status ));

        if ( Indent ) {
            Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
        } else {
            Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
        }
        ASSERT( NT_SUCCESS( Status ));
    }

    if (Accesses & MAXIMUM_ALLOWED) {

        Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
        ASSERT( NT_SUCCESS( Status ));

        Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringMaxAllowed);
        ASSERT( NT_SUCCESS( Status ));

        if ( Indent ) {
            Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
        } else {
            Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
        }
        ASSERT( NT_SUCCESS( Status ));
    }


    //
    // If there are any specific access bits set, then get
    // the appropriate source module and object type base
    // message ID offset.  If there is no module-specific
    // object definition, then use SE_ACCESS_NAME_SPECIFIC_0
    // as the base.
    //

    if ((Accesses & SPECIFIC_RIGHTS_ALL) == 0) {
        return(Status);
    }

    LsapAdtSourceModuleLock();

    Source = (PLSAP_ADT_SOURCE)&LsapAdtSourceModules;
    Found  = FALSE;

    while ((Source->Next != NULL) && !Found) {

        if (RtlEqualUnicodeString(&Source->Next->Name, SourceModule, TRUE)) {

            Found = TR